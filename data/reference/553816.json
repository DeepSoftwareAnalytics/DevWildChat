[
    {
        "link": "https://infosecinstitute.com/resources/reverse-engineering/using-setwindowshookex-for-dll-injection-on-windows",
        "document": "Note: all the code examples can be found on my Github profile under visual-studio-projects accessible here: https://github.com/proteansec .\n\nIn this tutorial, we'll take a look at the DLL injections by using the SetWindowsHookEx method. I haven't found a good blog post on the subject, which is the reason I decided to write one that will cover that and serve as a reference for future security researchers trying to understand this method. First, I'll explain what we'll actually be doing throughout the article, so you may understand the method before looking at an actual example.\n\nLet's take a look at the picture below, which clarifies what we'll be doing next. At first, the picture might seem daunting, but we'll explain it in a bit. In the middle of the picture we can see the victim.exe process (in purple color), where we want to inject a malicious DLL. When the DLL is injected into the process it's DllMain function will be called where we can do whatever we may want. Usually, we want to change the IAT import table of the process, so whenever the process calls some function, it will end up calling some other function: our malicious function.\n\nWe've figured that if we're able to inject our DLL into the victim.exe process, we would practically be able to do anything in the process' address space. The first thing that we need is malicious DLL file, which we must code ourselves. We must write the code that does exactly what we want the DLL to do when it's injected into the process's address space. To inject the DLL into the process's address space, we'll use the SetWindowsHookEx function. To be able to use that function, we first need another program program.exe, which we can see on the picture below. That program needs the action we'll be hooking and the inject.dll, which is our malicious DLL we'll be injecting into the victim.exe's process space. The program.exe must first get a handle to our DLL and then get address of one of the exported functions inside that DLL. This means that we need to code our DLL is such a way it exports at least one function. After that, the program.exe will be calling SetWindowsHookEx function passing it the action to be hooked as well as the address of the exported function inside inject.dll.\n\nThe SetWindowsHookEx function will install the hook routine into the hook chain of the victim.exe process, which will be invoked whenever certain event is triggered. In our case, the event that needs to be triggered is the action that we've inputted into the SetWindowsHookEx function. Later on, we'll be using the WH_KEYBOARD action, which means that whenever we'll press some key inside the victim.exe process, the previously obtained exported function in the injected DLL will be called. When the event occurs, the OS first checks whether the required DLL is already loaded in to the process's address space. If it isn't, then the OS must load (read inject) the DLL into the process's address space upon which the DllMain function of the DLL is called. After that, the exported function we passed to the SetWindowsHookEx is also called to handle the triggered event—in our case a key press. On all subsequent key presses, the DLL need not be reloaded, because it's already loaded in the process's address space. This effectively enables us to do whatever we want in the hooked address space of the program.\n\nThe SetWindowsHookEx installs a hook routine into the hook chain, which is then invoked whenever certain events are triggered. Let's take a look at the function syntax (note that the picture was taken from [4]):\n• The parameters to the SetWindowsHooEx functions are as follows (summarized after [4]):\n• idHook: the type of hook to be installed, which can hold one of the following values:\n• If you would like to understand every single hook type, reference the documentation accessible at [4].\n• hMod: a handle to the DLL that contains the hook function.\n• dwThreadId: the identifier of the thread, which calls the hook function. If the parameter is 0, the hook will be called by all threads, so we don't have to restrict it to particular thread ID.\n\nIf the function succeeds, it returns a HHOOK handle to the hook function. Otherwise the function returns NULL. All of the above constants are written in the winuser.h header file, which is part of the Windows driver development kit, and can be seen on the picture below:\n\nIn our case, we'll be hooking the WH_KEYBOARD type of event, which will allow us to monitor keystroke messages.\n\nThe first step when injecting the DLL into some process's address space is creating the DLL itself. We won't go into the details on how to do that, since it's pretty much self-explanatory. We need to start a new project inside Visual Studio and select DLL when creating it. After that, we can change the dllmain.c source code into something that looks like the following:\n\nWe can see that we have a pretty simple DLL. The DllMain() function is called when the DLL is loaded into the process's address space. Upon that, one of the four messages is written to the C:temp.txt file based on the reason why the function was called. But there's also a function named meconnect, which is an exported function and saves the message \"Function keyboard_hook called.\" into the C:function.txt file. This is all there is to our DLL, it's pretty simple and doesn't do anything. If we would like to program a keylogger, we could simply done so in the DLL code where we would have to hook certain functions in the IAT import table. There are plenty of possibilities we can explore, because once the DLL is loaded, our code is being called. This is also the reason that we can do pretty much anything related to this process. We can instruct it to connect back to us and form a reverse session, we can send each pressed keystroke inside this application to the server over HTTP protocol, etc.\n\nThe next thing that we need to do is create the program.exe as was demonstrated on the first picture of the article. This is the program that will do the actual injection of our DLL into the process's address space. Let's not waste any more words and present the code of the program straight away. We can see the code below:\n\n* Load library in which we'll be hooking our functions.\n\nprintf(\"The DLL could not be found.n\");\n\n* Get the address of the function inside the DLL.\n\nprintf(\"The KEYBOARD could not be hooked.n\");\n\nprintf(\"Program successfully hooked.nPress enter to unhook the function and stop the program.n\");\n\nThe code of the program is again pretty simple. First, we're calling the LoadLibrary function to load our DLL into perspective. If the DLL isn't found a simple message, \"The DLL could not be found.\" is printed to the console window. For the DLL to be found we must change the path from the C:driversdllinject.dll to whatever the path to our DLL is or we can move the DLL to reflect the preset path. After that, we're calling the GetProcAddress function to get the address of the meconnect function that we exported in previously coded DLL. At this point, we can use the dumpbin tool to check whether that function is actually exported. The output from that command can be seen below:\n\nSection contains the following exports for dllinject.dll\n\nNotice that only one function is exported and it's exactly the meconnect function. The program.exe effectively gets the address of that function when calling GetProcAddress function. After that, the program calls the most important function, the SetWindowsHookEx. The parameters passed to that function determine what the function will actually do. Let's look at that function call again:\n\nprintf(\"The KEYBOARD could not be hooked.n\");\n\nWe can see that we want to hook the WH_KEYBOARD events, which means that whenever the keyboard event will occur, our function will be called. We're also passing the address to the function in our DLL as the function parameters: this is the addr parameter we can see above. The dll parameter is just a handle to our DLL. The last parameter 0 specifies that we want all programs to be hooked, not just a specific one.\n\nAt last, we're also calling the getchar() function to pause the execution of the program and the UnhookWindowsHookEx() function to unhook the previously hooked WH_KEYBOARD action.\n\nSeeing everything in action\n\nSo far, we've presented the two required pieces that tie the whole process together:\n\nEverything is in order, but we still have to see some action. Let's now compile and start the program.exe (note that the inject.dll should also be compiled and placed in the C:drivers directory on the hard drive). After we've compiled the program successfully, the following will be printed to the console window:\n\nWe can see that everything was completed successfully and at this point whenever we start a program in the Windows Desktop, our DLL will be injected into its address space. We can check this by loading the OllyDbg debugger and starting putty.exe program. The program will start normally with the following DLLs loaded:\n\nWe can see that so far the dllinject.dll was not loaded into the putty's address space. But how can that be if we've already started the program.exe that does exactly that? The answer is very simple and it has to do with the WH_KEYBOARD constant we passed to the SetWindowsHookEx function. That keyboard specifies that DLL will be injected into the process's address space only when certain key is pressed inside the program. So if we go into the putty.exe process now, and click in the \"Host Name\" input box and press some key, OllyDbg will print the following:\n\nThis error just tells us that the dllinject was injected into the process's address space and its entry point is outside of the code section of the program. We can simply press OK and analyze the loaded modules again. We can see all the loaded modules on the picture below:\n\nNotice the second entry, which is our dllinject.dll that was injected into the process's address space. After that, we can check the contents of the C:temp.txt file, which can be seen on the picture below:\n\nWe can see that the right message about DLL attach being called was saved into the file. Don't worry if there are multiple same entries saved in those files. This just means that the DLL was injected into multiple programs (this is a direct effect of passing the number 0 as the forth parameter to the SetWindowsHookEx function). If we open the C:function.txt, we can see that our exported function was also called. The contents of that file are presented below:\n\nIn this article, we've seen how we can use the SetWindowsHookEx function to inject the DLL into the process's address space and execute arbitrary code inside the process's address space.\n• Working with the AppInit_DLLs registry value"
    },
    {
        "link": "https://cocomelonc.github.io/tutorial/2021/11/25/malware-injection-7.html",
        "document": "In this tutorial, I’ll take a look at the DLL injection by using the method.\n\nLet’s go to look an example which demonstrates this technique. The installs a hook routine into the hook chain, which is then invoked whenever certain events are triggered. Let’s take a look at the function syntax:\n\nThe most important param here is . The type of hook to be installed, which can hold one of the following values:\n\nIn our case, I’ll be hooking the type of event, which will allow us to monitor keystroke messages.\n\nLet’s go to prepare our malicious DLL. For simplicity, we create DLL which just pop-up a message box:\n\nAs you can see we have a pretty simple DLL. The function is called when the DLL is loaded into the process’s address space. There’s also a function named , which is an exported function and which is just pop-up message “Meow from evil.dll!”.\n\nThe next thing that we need to do is create our malware. Let’s go to look the source code:\n\nIt’s also pretty simple. First of all we call to load our malicious DLL:\n\nThen, we are calling the to get the address of the exported function :\n\nAfter that, the our malware calls the most important function, the . The parameters passed to that function determine what the function will actually do:\n\nAs you can see, whenever the keyboard event will occur, our function will be called. And we are passing the address of the our exported function - parameter. Also we are passing the handle to our DLL - parameter. The last parameter specifies that we want all programs to be hooked, not just a specific one, so it’s a global hook.\n\nfor demonstrate that our hook works.\n\nThen we call the function to unhook the previously hooked action:\n\nSo finally after we understood entire code of the malware, we can test it. \n\n Let’s go to compile malicious DLL firstly:\n\nThen, see everything in action! Start our on the victim machine (Windows 7 x64):\n\nWe can see that everything was completed successfully and at this point whenever we start a program, pop-up our message only when keyboard key is pressed.\n\nIn this article, I’ve demonstrate how we can use the function to inject the DLL into the process’s address space and execute arbitrary code inside the process’s address space.\n\nThere is a caveat. This technique is not working in my Windows 10 x64 machine. I think the reason is this: CIG block this technique. Windows 10 x64 have two important things:\n• CIG (Code Integrity Guard) - only allow modules signed by Microsoft/Microsoft Store/WHQL to be loaded into the process memory.\n\nIn this presentation from BlackHat USA 2019, the authors explain that CIG block this technique.\n\nLet’s go to upload our to virustotal:\n\nSo, 5 of 67 AV engines detect our file as malicious.\n\nBlackHat USA 2019 process injection techniques Gotta Catch Them All \n\n SetWindowsHookEx \n\n Using Hooks MSDN \n\n Exporting from a DLL \n\n Source code in Github\n\nThanks for your time, happy hacking and good bye! \n\n PS. All drawings and screenshots are mine"
    },
    {
        "link": "https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-setwindowshookexa",
        "document": "Installs an application-defined hook procedure into a hook chain. You would install a hook procedure to monitor the system for certain types of events. These events are associated either with a specific thread or with all threads in the same desktop as the calling thread.\n\nThe type of hook procedure to be installed. This parameter can be one of the following values.\n\nInstalls a hook procedure that monitors messages before the system sends them to the destination window procedure. For more information, see the CallWndProc hook procedure. Installs a hook procedure that monitors messages after they have been processed by the destination window procedure. For more information, see the [HOOKPROC callback function](nc-winuser-hookproc.md) hook procedure. Installs a hook procedure that receives notifications useful to a CBT application. For more information, see the [CBTProc](/windows/win32/winmsg/cbtproc) hook procedure. Installs a hook procedure useful for debugging other hook procedures. For more information, see the DebugProc hook procedure. Installs a hook procedure that will be called when the application's foreground thread is about to become idle. This hook is useful for performing low priority tasks during idle time. For more information, see the ForegroundIdleProc hook procedure. Installs a hook procedure that monitors messages posted to a message queue. For more information, see the GetMsgProc hook procedure. Windows 11 and newer: Journaling hook APIs are not supported. We recommend using the SendInput TextInput API instead. Installs a hook procedure that posts messages previously recorded by a WH_JOURNALRECORD hook procedure. For more information, see the JournalPlaybackProc hook procedure. Windows 11 and newer: Journaling hook APIs are not supported. We recommend using the SendInput TextInput API instead. Installs a hook procedure that records input messages posted to the system message queue. This hook is useful for recording macros. For more information, see the JournalRecordProc hook procedure. Installs a hook procedure that monitors keystroke messages. For more information, see the KeyboardProc hook procedure. Installs a hook procedure that monitors low-level keyboard input events. For more information, see the LowLevelKeyboardProc hook procedure. Installs a hook procedure that monitors mouse messages. For more information, see the MouseProc hook procedure. Installs a hook procedure that monitors low-level mouse input events. For more information, see the LowLevelMouseProc hook procedure. Installs a hook procedure that monitors messages generated as a result of an input event in a dialog box, message box, menu, or scroll bar. For more information, see the MessageProc hook procedure. Installs a hook procedure that receives notifications useful to shell applications. For more information, see the [ShellProc](/windows/win32/winmsg/shellproc) hook procedure. Installs a hook procedure that monitors messages generated as a result of an input event in a dialog box, message box, menu, or scroll bar. The hook procedure monitors these messages for all applications in the same desktop as the calling thread. For more information, see the SysMsgProc hook procedure.\n\nA pointer to the hook procedure. If the dwThreadId parameter is zero or specifies the identifier of a thread created by a different process, the lpfn parameter must point to a hook procedure in a DLL. Otherwise, lpfn can point to a hook procedure in the code associated with the current process.\n\nA handle to the DLL containing the hook procedure pointed to by the lpfn parameter. The hMod parameter must be set to NULL if the dwThreadId parameter specifies a thread created by the current process and if the hook procedure is within the code associated with the current process.\n\nThe identifier of the thread with which the hook procedure is to be associated. For desktop apps, if this parameter is zero, the hook procedure is associated with all existing threads running in the same desktop as the calling thread. For Windows Store apps, see the Remarks section.\n\nIf the function succeeds, the return value is the handle to the hook procedure.\n\nIf the function fails, the return value is NULL. To get extended error information, call GetLastError.\n\nSetWindowsHookEx can be used to inject a DLL into another process. A 32-bit DLL cannot be injected into a 64-bit process, and a 64-bit DLL cannot be injected into a 32-bit process. If an application requires the use of hooks in other processes, it is required that a 32-bit application call SetWindowsHookEx to inject a 32-bit DLL into 32-bit processes, and a 64-bit application call SetWindowsHookEx to inject a 64-bit DLL into 64-bit processes. The 32-bit and 64-bit DLLs must have different names.\n\nBecause hooks run in the context of an application, they must match the \"bitness\" of the application. If a 32-bit application installs a global hook on 64-bit Windows, the 32-bit hook is injected into each 32-bit process (the usual security boundaries apply). In a 64-bit process, the threads are still marked as \"hooked.\" However, because a 32-bit application must run the hook code, the system executes the hook in the hooking app's context; specifically, on the thread that called SetWindowsHookEx. This means that the hooking application must continue to pump messages or it might block the normal functioning of the 64-bit processes.\n\nIf a 64-bit application installs a global hook on 64-bit Windows, the 64-bit hook is injected into each 64-bit process, while all 32-bit processes use a callback to the hooking application.\n\nTo hook all applications on the desktop of a 64-bit Windows installation, install a 32-bit global hook and a 64-bit global hook, each from appropriate processes, and be sure to keep pumping messages in the hooking application to avoid blocking normal functioning. If you already have a 32-bit global hooking application and it doesn't need to run in each application's context, you may not need to create a 64-bit version.\n\nAn error may occur if the hMod parameter is NULL and the dwThreadId parameter is zero or specifies the identifier of a thread created by another process.\n\nCalling the CallNextHookEx function function to chain to the next hook procedure is optional, but it is highly recommended; otherwise, other applications that have installed hooks will not receive hook notifications and may behave incorrectly as a result. You should call CallNextHookEx unless you absolutely need to prevent the notification from being seen by other applications.\n\nBefore terminating, an application must call the UnhookWindowsHookEx function function to free system resources associated with the hook.\n\nThe scope of a hook depends on the hook type. Some hooks can be set only with global scope; others can also be set for only a specific thread, as shown in the following table.\n\nFor a specified hook type, thread hooks are called first, then global hooks. Be aware that the WH_MOUSE, WH_KEYBOARD, WH_JOURNAL*, WH_SHELL, and low-level hooks can be called on the thread that installed the hook rather than the thread processing the hook. For these hooks, it is possible that both the 32-bit and 64-bit hooks will be called if a 32-bit hook is ahead of a 64-bit hook in the hook chain.\n\nThe global hooks are a shared resource, and installing one affects all applications in the same desktop as the calling thread. All global hook functions must be in libraries. Global hooks should be restricted to special-purpose applications or to use as a development aid during application debugging. Libraries that no longer need a hook should remove its hook procedure.\n\nWindows Store app development If dwThreadId is zero, then window hook DLLs are not loaded in-process for the Windows Store app processes and the Windows Runtime broker process unless they are installed by either UIAccess processes (accessibility tools). The notification is delivered on the installer's thread for these hooks:\n\nThis behavior is similar to what happens when there is an architecture mismatch between the hook DLL and the target application process, for example, when the hook DLL is 32-bit and the application process 64-bit.\n\nFor an example, see Installing and Releasing Hook Procedures."
    },
    {
        "link": "https://apriorit.com/dev-blog/679-windows-dll-injection-for-api-hooks",
        "document": "Being able to control and manipulate system behavior and API calls is a useful skill for any Windows developer. It allows you to investigate internal processes and detect suspicious and malicious code. Previously, we described an easy way to set a global API hook by manipulating the AppInit_DLLs registry key and make the calc.exe process invisible in the list of running processes.\n\nThis time, we dive even deeper into dynamic-link library (DLL) injection techniques. We demonstrate how to make any Windows process immortal so that no other process can terminate it. This DLL injection tutorial will be useful for Windows developers who want to know more about different ways of modifying the flow and behavior of API calls in Windows applications.\n\nBefore we dive into the depths of code manipulations, let’s go over some of the basics of API hooking.\n\nWhat is API hooking? API hooking is a technique that developers use for manipulating the behavior of a system or an application. With the help of API hooking, you can intercept calls in a Windows application or capture information related to API calls. Additionally, API hooking is one of the techniques that antivirus and Endpoint Detection and Response solutions use for identifying malicious code.\n\nThere are many ways you can implement API hooking. The three most popular methods are:\n• — Allows you to run your code inside a Windows process to perform different tasks\n• — Implemented via the WriteProcessMemory API used for pasting custom code into another process\n• toolset — Provides you with full control over a debugged application, making it easy to manipulate the memory of a debugged process\n\nIn this article, we focus on the DLL injection method as it’s the most flexible, best-known, and most studied approach to manipulating system behavior through API calls. But what is DLL injection to begin with? In short, it’s the process of running custom code within the address space of a different process. DLL injection is also the most universal API hooking method and has fewer limitations than other API hooking techniques.\n\nThere are three widely used DLL injection methods based on the use of:\n• the function. This method is only applicable to applications that use a graphical user interface (GUI).\n• the function. This method can be used for hooking any process but requires a lot of coding.\n• remote thread context patching. This method is efficient but rather complex, so it’s better to use it only if the other two methods don’t work out for some reason.\n\nFurther in this article, we explain how to implement each of these methods and provide a practical example of setting API hooks with one of them. Our journey begins with overviewing the first technique on this list — using the SetWindowsHookEx function.\n\nThe first DLL injection technique we overview in this post is based on the SetWindowsHookEx function. Using the WH_GETMESSAGE hook, we set a process that will watch for messages processed by system windows. To set the hook, we call the SetWindowsHookEx function:\n\nThe WH_GETMESSAGE argument determines the type of hook, and the functionAddress parameter determines the address of the function (in the address space of your process) that the system should call whenever a window is about to process a message.\n\nThe dllToBeInjected parameter identifies the DLL containing the functionAddress function. The last argument, 0, indicates the thread for which the hook is intended. Passing 0, we tell the system that we’re setting a hook for all GUI threads that exist in it. So this method can be applied to hook a specific process or all processes in the system.\n\nLet’s see how all this works:\n• The Some_application.exe thread is about to send a message to some window.\n• The system checks if the WH_GETMESSAGE hook is set for this thread.\n• Then the system finds out whether Inject.dll, the DLL containing the callback for the message, is mapped to the address space of the Some_application.exe process.\n• If Inject.dll isn’t mapped yet, the system maps it to the address space of the Some_application.exe process and increments the lock count of the DLL in that process.\n• The function of Inject.dll is called with the parameter.\n• Then a callback is called in the address space of the Some_application.exe process.\n• After returning from the callback, the DLL lock counter in the address space of the process is reduced by 1.\n\nNow let’s see how we can inject DLL with a second method — using the CreateRemoteThread function.\n\nNow we’re going to look at the most flexible way of injecting DLL — using the CreateRemoteThread function. The overall flow looks like this:\n\nInjecting a DLL involves invoking the LoadLibrary function within the thread of the target process to load the desired DLL. Since managing threads of another process is extremely complicated, it’s better to create your own thread in it. Fortunately, the CreateRemoteThread function makes this easy:\n\nThis function is very similar to the CreateThread function but has an additional hProcess parameter that identifies the process to which the new thread will belong.\n\nWe start with getting the handle of the process we’re going to hook:\n\nThen, we should allocate some memory in the target process in order to pass the DLL path, as the target process can access only its private memory:\n\nUsing the WriteProcessMemory function, we can place the DLL path into the address space of our target process:\n\nThen we can start a new thread. With the help of this thread, our DLL will be loaded into the target process.\n\nFinally, we can move to the third DLL injection method that’s based on thread context patching.\n\nThis method of DLL injection isn’t easy to detect, as it mostly looks like a regular thread activity. To succeed, we need to manipulate the context of an existing remote thread and make sure the thread doesn’t know about these manipulations. The instruction pointer of the target thread is first set to a custom piece of code. When the code is executed, the pointer is redirected to its original location.\n\nThis is what the whole process looks like:\n\nLet’s see how we can implement this DLL injection method in an x64 system.\n\nFirst, we need to locate the target process and pick a thread within it. It’s better to choose a thread that’s already running or is likely to run so that our DLL can be loaded as early as possible. Selecting a waiting thread isn’t the best idea, as such a thread won’t run the code unless it’s ready to run.\n\nFirst, we use the OpenThread function to open the handle of the remote thread:\n\nThen we need to allocate memory in the remote process to store our injected code and the DLL path in it:\n\nNext we write the DLL path in the middle of the remote allocated buffer:\n\nThen we suspend the remote thread and retrieve its context:\n\nNow we compile assembly code and save it in the buffer:\n\nWe set the remote IP (RIP) register of our remote thread to the buffer:\n\nFinally, we set a new context and resume the thread:\n\nNow that you’ve got a better understanding of different DLL injection techniques, it’s time to see how these techniques work in practice.\n\nWhile using the CreateRemoteThread function is the most universal way of setting API hooks with DLL injection, this method requires an extensive amount of preliminary coding. That’s why we’ll illustrate how to set API hooks with DLL injection using the SetWindowsHookEx function, which is a less time-consuming method.\n\nThis example is based on a basic user-mode DLL written in C++. To be able to follow your trail, make sure to add the latest version of the Mhook sources to your project.\n\nOur main goal here is to create an immortal process that’s impossible for any other process in the system to terminate. We begin with setting a global API hook.\n• We inject our DLL with the function:\n• To make sure we can restore the original function after removing our hook, we need to store its address.\n\nTo terminate a process, we need to call the TerminateProcess function from kernel32.dll. Thanks to the creation and initialization of a global variable, we can now store the original function’s address:\n• We’ve hooked the function instead of the original function. The hooked function first calls the function from kernel32.dll and gets the full name of the executable image for the process.\n\nNow we need to check the process name. If it has the “_immortal” suffix, it’s the process we should not allow to be terminated.\n\nNote: Both functions, the original and the hooked, must have identical signatures.\n• Here, we can finally inject our DLL into the code of the target process to set our hook.\n\nOnce loaded in the target process, the DllMain function will receive the DLL_PROCESS_ATTACH parameter. Now we can manipulate this process and hook the chosen function with the help of the Mhook library:\n• Once the DLL is unloaded from the target process’s address space, the function receives the parameter. After that, we remove the hook and restore the original function.\n\nWe now have all the code needed for setting API hooks with Windows DLL injection. It’s time to check if this code is actually working.\n\nFor a practical illustration, we used the Structured Storage Viewer utility and turned it into an immortal process by injecting a DLL with the SetWindowsHookEx function. As a result of this process, we got an executable with the name SSView_immortal.exe. Let’s launch this executable and look at it in Task Manager. We’ll also need the Process Explorer utility installed to check if our DLL is, in fact, injected in the Taskmgr.exe process:\n\nIn Task Manager, we can see the SSView_immortal.exe process. Let’s try to terminate it:\n\nWhen we click End task, we get a message box with an error (the same error we show in our hooked function):\n\nThen we also receive a message saying “Access is denied.” This is the ERROR_ACCESS_DENIED response we set earlier with the help of the SetLastError function when implementing our hooked function:\n\nAs you can see, we successfully hooked a system process and made it impossible for any other Windows process to terminate it, which is exactly what we intended to do.\n\nThere are many methods to hook an API call. DLL injection is one of the most flexible, effective, and well-studied methods for injecting custom code into a system process. When performing DLL injection, it’s important to insert code into a running process, as DLLs are meant to be loaded as needed at runtime.\n\nThere are many ways you can hook a function with DLL injection — by setting hooks in specific functions or manipulating the context of a remote thread. From our experience, we can say that setting hooks with the CreateRemoteThread function is the most effective approach. As this function is supported by the Windows operating system, there’s no need to use any additional tricks, complicated executable file structures, or operating system internals when working with it. However, if you’re working with a GUI application, you can use the most effortless option — the SetWindowsHookEx function.\n\nAt Apriorit, we’ve already set thousands of hooks and know how to find our way around different operating systems and processes. Get a step closer to realizing your dream project — contact us and tell us all about it!"
    },
    {
        "link": "https://stackoverflow.com/questions/15305605/setwindowshookex-sometimes-not-working-after-dll-injection",
        "document": "I am using this lib http://code.google.com/p/injex/ to inject a dll that contains a keyboard hook function. The dll is simple, just create a thread and use the 'setWindowsHookEx' function.\n\nThe injection was always successful, but the keyboard hook didn't work for all the cases.\n• None I wrote a simple 'hello world' win32 app, and use injex.exe to inject the keyboard hook dll into it. All works as expected.\n• None If I choose a complex program to inject (A game written in delphi), the dll was successfully injected(I can see the injected main form), but it failed to hook the keyboard.\n\nSo my question is:\n• None Is the failure of keyboard hook because of the injection method, or the keyboard hook function?\n• None Is it possible that a dll can be injected, but its functionalities are not guaranteed?\n\nSo any advices are welcome.\n\nHere is the dll code:"
    },
    {
        "link": "https://stackoverflow.com/questions/70205568/working-with-hooks-setwindowshookex-wh-getmessage",
        "document": "I'll start with a description of what exactly I need and why.\n\nI am making an in-game interface in a library (dll), and I need the ability to both receive and delete messages (prevent the target process from receiving them), depending on different conditions in the code.\n\nIn addition to messages from the mouse and keyboard, I do not need anything else. For this, there are two ways. Find some kind of hook that will allow me to receive messages from both the mouse and the keyboard, or put two separate hooks on the mouse and keyboard, but there will be much more code than with one hook.\n\nI decided to go the first way and put a hook on the messages of the thread that created the window. However, my attempts to block the message were unsuccessful.\n\nI'm not sure if is the right hook for me. Perhaps much more experienced programmers will tell me that it is better to do, for example, two hooks, and , rather than using .\n\nBut if, nevertheless, using is not a bad idea, then please help me to make it so that I can control the receipt of some messages by the process (do not allow them to be seen by the process)."
    },
    {
        "link": "https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-setwindowshookexw",
        "document": "Installs an application-defined hook procedure into a hook chain. You would install a hook procedure to monitor the system for certain types of events. These events are associated either with a specific thread or with all threads in the same desktop as the calling thread.\n\nThe type of hook procedure to be installed. This parameter can be one of the following values.\n\nInstalls a hook procedure that monitors messages before the system sends them to the destination window procedure. For more information, see the CallWndProc hook procedure. Installs a hook procedure that monitors messages after they have been processed by the destination window procedure. For more information, see the HOOKPROC callback function hook procedure. Installs a hook procedure that receives notifications useful to a CBT application. For more information, see the CBTProc hook procedure. Installs a hook procedure useful for debugging other hook procedures. For more information, see the DebugProc hook procedure. Installs a hook procedure that will be called when the application's foreground thread is about to become idle. This hook is useful for performing low priority tasks during idle time. For more information, see the ForegroundIdleProc hook procedure. Installs a hook procedure that monitors messages posted to a message queue. For more information, see the GetMsgProc hook procedure. Journaling Hooks APIs are unsupported starting in Windows 11 and will be removed in a future release. Because of this, we highly recommend calling the SendInput TextInput API instead. Installs a hook procedure that posts messages previously recorded by a WH_JOURNALRECORD hook procedure. For more information, see the JournalPlaybackProc hook procedure. Journaling Hooks APIs are unsupported starting in Windows 11 and will be removed in a future release. Because of this, we highly recommend calling the SendInput TextInput API instead. Installs a hook procedure that records input messages posted to the system message queue. This hook is useful for recording macros. For more information, see the JournalRecordProc hook procedure. Installs a hook procedure that monitors keystroke messages. For more information, see the KeyboardProc hook procedure. Installs a hook procedure that monitors low-level keyboard input events. For more information, see the LowLevelKeyboardProc hook procedure. Installs a hook procedure that monitors mouse messages. For more information, see the MouseProc hook procedure. Installs a hook procedure that monitors low-level mouse input events. For more information, see the LowLevelMouseProc hook procedure. Installs a hook procedure that monitors messages generated as a result of an input event in a dialog box, message box, menu, or scroll bar. For more information, see the MessageProc hook procedure. Installs a hook procedure that receives notifications useful to shell applications. For more information, see the ShellProc hook procedure. Installs a hook procedure that monitors messages generated as a result of an input event in a dialog box, message box, menu, or scroll bar. The hook procedure monitors these messages for all applications in the same desktop as the calling thread. For more information, see the SysMsgProc hook procedure.\n\nA pointer to the hook procedure. If the dwThreadId parameter is zero or specifies the identifier of a thread created by a different process, the lpfn parameter must point to a hook procedure in a DLL. Otherwise, lpfn can point to a hook procedure in the code associated with the current process.\n\nA handle to the DLL containing the hook procedure pointed to by the lpfn parameter. The hMod parameter must be set to NULL if the dwThreadId parameter specifies a thread created by the current process and if the hook procedure is within the code associated with the current process.\n\nThe identifier of the thread with which the hook procedure is to be associated. For desktop apps, if this parameter is zero, the hook procedure is associated with all existing threads running in the same desktop as the calling thread. For Windows Store apps, see the Remarks section.\n\nIf the function succeeds, the return value is the handle to the hook procedure.\n\nIf the function fails, the return value is NULL. To get extended error information, call GetLastError.\n\nSetWindowsHookEx can be used to inject a DLL into another process. A 32-bit DLL cannot be injected into a 64-bit process, and a 64-bit DLL cannot be injected into a 32-bit process. If an application requires the use of hooks in other processes, it is required that a 32-bit application call SetWindowsHookEx to inject a 32-bit DLL into 32-bit processes, and a 64-bit application call SetWindowsHookEx to inject a 64-bit DLL into 64-bit processes. The 32-bit and 64-bit DLLs must have different names.\n\nBecause hooks run in the context of an application, they must match the \"bitness\" of the application. If a 32-bit application installs a global hook on 64-bit Windows, the 32-bit hook is injected into each 32-bit process (the usual security boundaries apply). In a 64-bit process, the threads are still marked as \"hooked.\" However, because a 32-bit application must run the hook code, the system executes the hook in the hooking app's context; specifically, on the thread that called SetWindowsHookEx. This means that the hooking application must continue to pump messages or it might block the normal functioning of the 64-bit processes.\n\nIf a 64-bit application installs a global hook on 64-bit Windows, the 64-bit hook is injected into each 64-bit process, while all 32-bit processes use a callback to the hooking application.\n\nTo hook all applications on the desktop of a 64-bit Windows installation, install a 32-bit global hook and a 64-bit global hook, each from appropriate processes, and be sure to keep pumping messages in the hooking application to avoid blocking normal functioning. If you already have a 32-bit global hooking application and it doesn't need to run in each application's context, you may not need to create a 64-bit version.\n\nAn error may occur if the hMod parameter is NULL and the dwThreadId parameter is zero or specifies the identifier of a thread created by another process.\n\nCalling the CallNextHookEx function function to chain to the next hook procedure is optional, but it is highly recommended; otherwise, other applications that have installed hooks will not receive hook notifications and may behave incorrectly as a result. You should call CallNextHookEx unless you absolutely need to prevent the notification from being seen by other applications.\n\nIn .NET apps, you must ensure the callback is not moved around by the garbage collector (otherwise your app will crash with an ExecutionEngineException). One way to do this is by making the callback a static method of your class.\n\nBefore terminating, an application must call the UnhookWindowsHookEx function function to free system resources associated with the hook.\n\nThe scope of a hook depends on the hook type. Some hooks can be set only with global scope; others can also be set for only a specific thread, as shown in the following table.\n\nFor a specified hook type, thread hooks are called first, then global hooks. Be aware that the WH_MOUSE, WH_KEYBOARD, WH_JOURNAL*, WH_SHELL, and low-level hooks can be called on the thread that installed the hook rather than the thread processing the hook. For these hooks, it is possible that both the 32-bit and 64-bit hooks will be called if a 32-bit hook is ahead of a 64-bit hook in the hook chain.\n\nThe global hooks are a shared resource, and installing one affects all applications in the same desktop as the calling thread. All global hook functions must be in libraries. Global hooks should be restricted to special-purpose applications or to use as a development aid during application debugging. Libraries that no longer need a hook should remove its hook procedure.\n\nWindows Store apps: If dwThreadId is zero, then window hook DLLs are not loaded in-process for the Windows Store app processes and the Windows Runtime broker process unless they are installed by either UIAccess processes (accessibility tools). The notification is delivered on the installer's thread for these hooks:\n\nThis behavior is similar to what happens when there is an architecture mismatch between the hook DLL and the target application process, for example, when the hook DLL is 32-bit and the application process 64-bit.\n\nFor an example, see Installing and Releasing Hook Procedures."
    },
    {
        "link": "https://stackoverflow.com/questions/4340313/calling-setwindowshookex-with-wh-getmessage-doesnt-work-on-any-process-except-t",
        "document": "I previously asked a question about something similar but I believe this time the circumstances are different.\n\nI have a DLL that has standard hook, unhook and msgProc functions. I load this DLL in my main application and then call 'hook', that is below:\n\nThe problem is that if I make it global, with threadID = 0, then msgHook only and only captures the messages received by the window of the process that loaded the library and nothing else, even if it is supposed to be a global hook.\n\nIf I supply a threadID of some other window, then I don't receive messages at all.\n\nWhat could perhaps be the reason for it?"
    },
    {
        "link": "https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-setwindowshookexa",
        "document": "Installs an application-defined hook procedure into a hook chain. You would install a hook procedure to monitor the system for certain types of events. These events are associated either with a specific thread or with all threads in the same desktop as the calling thread.\n\nThe type of hook procedure to be installed. This parameter can be one of the following values.\n\nInstalls a hook procedure that monitors messages before the system sends them to the destination window procedure. For more information, see the CallWndProc hook procedure. Installs a hook procedure that monitors messages after they have been processed by the destination window procedure. For more information, see the [HOOKPROC callback function](nc-winuser-hookproc.md) hook procedure. Installs a hook procedure that receives notifications useful to a CBT application. For more information, see the [CBTProc](/windows/win32/winmsg/cbtproc) hook procedure. Installs a hook procedure useful for debugging other hook procedures. For more information, see the DebugProc hook procedure. Installs a hook procedure that will be called when the application's foreground thread is about to become idle. This hook is useful for performing low priority tasks during idle time. For more information, see the ForegroundIdleProc hook procedure. Installs a hook procedure that monitors messages posted to a message queue. For more information, see the GetMsgProc hook procedure. Windows 11 and newer: Journaling hook APIs are not supported. We recommend using the SendInput TextInput API instead. Installs a hook procedure that posts messages previously recorded by a WH_JOURNALRECORD hook procedure. For more information, see the JournalPlaybackProc hook procedure. Windows 11 and newer: Journaling hook APIs are not supported. We recommend using the SendInput TextInput API instead. Installs a hook procedure that records input messages posted to the system message queue. This hook is useful for recording macros. For more information, see the JournalRecordProc hook procedure. Installs a hook procedure that monitors keystroke messages. For more information, see the KeyboardProc hook procedure. Installs a hook procedure that monitors low-level keyboard input events. For more information, see the LowLevelKeyboardProc hook procedure. Installs a hook procedure that monitors mouse messages. For more information, see the MouseProc hook procedure. Installs a hook procedure that monitors low-level mouse input events. For more information, see the LowLevelMouseProc hook procedure. Installs a hook procedure that monitors messages generated as a result of an input event in a dialog box, message box, menu, or scroll bar. For more information, see the MessageProc hook procedure. Installs a hook procedure that receives notifications useful to shell applications. For more information, see the [ShellProc](/windows/win32/winmsg/shellproc) hook procedure. Installs a hook procedure that monitors messages generated as a result of an input event in a dialog box, message box, menu, or scroll bar. The hook procedure monitors these messages for all applications in the same desktop as the calling thread. For more information, see the SysMsgProc hook procedure.\n\nA pointer to the hook procedure. If the dwThreadId parameter is zero or specifies the identifier of a thread created by a different process, the lpfn parameter must point to a hook procedure in a DLL. Otherwise, lpfn can point to a hook procedure in the code associated with the current process.\n\nA handle to the DLL containing the hook procedure pointed to by the lpfn parameter. The hMod parameter must be set to NULL if the dwThreadId parameter specifies a thread created by the current process and if the hook procedure is within the code associated with the current process.\n\nThe identifier of the thread with which the hook procedure is to be associated. For desktop apps, if this parameter is zero, the hook procedure is associated with all existing threads running in the same desktop as the calling thread. For Windows Store apps, see the Remarks section.\n\nIf the function succeeds, the return value is the handle to the hook procedure.\n\nIf the function fails, the return value is NULL. To get extended error information, call GetLastError.\n\nSetWindowsHookEx can be used to inject a DLL into another process. A 32-bit DLL cannot be injected into a 64-bit process, and a 64-bit DLL cannot be injected into a 32-bit process. If an application requires the use of hooks in other processes, it is required that a 32-bit application call SetWindowsHookEx to inject a 32-bit DLL into 32-bit processes, and a 64-bit application call SetWindowsHookEx to inject a 64-bit DLL into 64-bit processes. The 32-bit and 64-bit DLLs must have different names.\n\nBecause hooks run in the context of an application, they must match the \"bitness\" of the application. If a 32-bit application installs a global hook on 64-bit Windows, the 32-bit hook is injected into each 32-bit process (the usual security boundaries apply). In a 64-bit process, the threads are still marked as \"hooked.\" However, because a 32-bit application must run the hook code, the system executes the hook in the hooking app's context; specifically, on the thread that called SetWindowsHookEx. This means that the hooking application must continue to pump messages or it might block the normal functioning of the 64-bit processes.\n\nIf a 64-bit application installs a global hook on 64-bit Windows, the 64-bit hook is injected into each 64-bit process, while all 32-bit processes use a callback to the hooking application.\n\nTo hook all applications on the desktop of a 64-bit Windows installation, install a 32-bit global hook and a 64-bit global hook, each from appropriate processes, and be sure to keep pumping messages in the hooking application to avoid blocking normal functioning. If you already have a 32-bit global hooking application and it doesn't need to run in each application's context, you may not need to create a 64-bit version.\n\nAn error may occur if the hMod parameter is NULL and the dwThreadId parameter is zero or specifies the identifier of a thread created by another process.\n\nCalling the CallNextHookEx function function to chain to the next hook procedure is optional, but it is highly recommended; otherwise, other applications that have installed hooks will not receive hook notifications and may behave incorrectly as a result. You should call CallNextHookEx unless you absolutely need to prevent the notification from being seen by other applications.\n\nBefore terminating, an application must call the UnhookWindowsHookEx function function to free system resources associated with the hook.\n\nThe scope of a hook depends on the hook type. Some hooks can be set only with global scope; others can also be set for only a specific thread, as shown in the following table.\n\nFor a specified hook type, thread hooks are called first, then global hooks. Be aware that the WH_MOUSE, WH_KEYBOARD, WH_JOURNAL*, WH_SHELL, and low-level hooks can be called on the thread that installed the hook rather than the thread processing the hook. For these hooks, it is possible that both the 32-bit and 64-bit hooks will be called if a 32-bit hook is ahead of a 64-bit hook in the hook chain.\n\nThe global hooks are a shared resource, and installing one affects all applications in the same desktop as the calling thread. All global hook functions must be in libraries. Global hooks should be restricted to special-purpose applications or to use as a development aid during application debugging. Libraries that no longer need a hook should remove its hook procedure.\n\nWindows Store app development If dwThreadId is zero, then window hook DLLs are not loaded in-process for the Windows Store app processes and the Windows Runtime broker process unless they are installed by either UIAccess processes (accessibility tools). The notification is delivered on the installer's thread for these hooks:\n\nThis behavior is similar to what happens when there is an architecture mismatch between the hook DLL and the target application process, for example, when the hook DLL is 32-bit and the application process 64-bit.\n\nFor an example, see Installing and Releasing Hook Procedures."
    },
    {
        "link": "https://proteansec.com/reverse-engineering/using-setwindowshookex-for-dll-injection-on-windows",
        "document": "There are multiple ways of writing and disseminating a software program. The usual process includes software programmers writing the code in arbitrary programming language, after which the code is compiled or interpreted in order to be run on chosen architecture.\n\nOur reverse engineers are able to work with many different software programs, including with the executables and libraries written and compiled for the following architectures: ARM, x86/x64, MIPS, SPARC, etc. We will also use static as well as dynamic reverse engineering techniques to determine the program internals. If security measures like anti-debugging/anti-detection techniques are in place, we'll use the latest counter-measures to bypass them in order to determine how the program actually works."
    },
    {
        "link": "https://apriorit.com/dev-blog/secure-windows-software-against-dll-attacks",
        "document": "Any Windows application that handles sensitive data is a potential target for cyber attacks like dynamic link library (DLL) injection. By injecting malicious code into software, attackers can change the way processes behave to turn off security measures, steal data, or harm software.\n\nThus, taking relevant protection mechanisms into consideration during software development is a must. Protecting your software from DLL injection attacks can help your team reduce the risk of product hacking, preventing unjustified spending of money and time on handling incidents and mitigating reputational losses.\n\nThis article covers the DLL injection workflow, consequences of DLL injection, as well as nuances of detection and prevention. In the practical part, we show two simple but unique DLL injection attack examples and how to use popular API hooking libraries and a protection mechanism to prevent such attacks. You’ll also see a real-life example of how DLL injection can be detected and countered within a running process monitoring application.\n\nThis article will be helpful for project and development leaders working on Windows applications who want to enhance protection against cybersecurity attacks.\n\nMalicious actors can use many methods to hack or change the behavior of your software, aiming to steal sensitive data, request a ransom, or inject malware for some other reason.\n\nA common approach to hacking Windows software is DLL injection — inserting a DLL into the address space of a running process to execute code. When a DLL is injected, it becomes part of the target process. To inject a malicious DLL, attackers often use API hooking to add code that intercepts and modifies the behavior of existing functions within an application.\n\nDLL injection attacks don’t require access to the target application’s source code. This approach is common in Trojan horse malware that changes the behavior of running applications. For instance, DLL injection and API hooking can be used to hide some processes that the user should not see or cannot close. This way, an attacker, for example, can use the victim’s system to mine cryptocurrency. When applying both techniques simultaneously, hackers can integrate suspicious code into almost any existing process and gain control over it.\n\nBy inserting malicious code into a legitimate process, attackers can execute arbitrary code with the same privilege as the target process. The security consequences of DLL injection include:\n• Access sensitive information from the host and steal credentials, credit card information, and other personal data.\n• Crash a target process or potentially cause system-wide crashes or instability.\n• Gain unauthorized access and modify or turn off security measures.\n\nThe good and the bad of DLL injection\n\nDetecting malicious DLL injections is a challenging task, especially since you need to understand the context and intent behind each injection.\n\nOn the one hand, this technique can be used for legitimate and illegitimate purposes. Initially, Remote library injection was introduced as an exploitation technique in 2004 by Skape and JT [PDF]. Later, more libraries appeared allowing programmers to quickly and easily inject their DLL and set hooks on an API function.\n\nHere are a few examples of using DLL injection for good:\n• Software applications often use DLL injection as a legitimate means to extend a program’s functionality via plugins or extensions.\n• Security specialists might alter system behavior to investigate internal processes and detect suspicious and dangerous code.\n• Developers use DLL injection during debugging and profiling to analyze and monitor the behavior of running processes.\n• Security software, like antivirus or intrusion detection systems, may inject DLLs into processes to monitor and protect against malicious activity.\n\nOn the other hand, unwanted DLL injection is dangerous:\n• Malware often uses DLL injection to add malicious code to legitimate processes, changing the solution’s behavior.\n• Hackers can use DLL injection as part of an attack to gain unauthorized access to a system.\n• Game cheaters might use DLL injection to modify the behavior of games to gain unfair advantages.\n\nTo monitor unauthorized DLL injection in programs, organizations have developed various antivirus solutions and game anti-cheat software. For example, Microsoft Defender Antivirus in Windows scans DLLs and executables and flags malicious ones. But you shouldn’t entirely rely on such solutions, as they might not identify certain malicious injection techniques. One reason is that every time cybersecurity experts come up with a solution to prevent illegal DLL injection, attackers find ways to bypass it.\n\nBefore we move to showing methods for protecting against DLL injection, let’s briefly explore how DLL injection works.\n\nTo effectively detect and mitigate attacks, it’s crucial to understand the logic behind the injection process. Let’s overview a common DLL injection workflow and explore which Windows APIs and functions are usually involved in DLL injection attacks.\n\nHackers can run a DLL injection attack in four steps:\n• Attach their injection application to the target process\n• Upload the DLL data or path to the process’s memory and locate memory addresses appropriate for injection\n• Instruct the process to execute the injected DLL\n\nHow does DLL injection work in detail?\n\nFirst, hackers determine a target for DLL injection. The most popular Windows functions that injection applications can use for this purpose are:\n\nThese functions read all system processes to find a target process. As a result, the injection application can get all necessary information about the target process.\n\nNext, the injection application can call the following functions to obtain a handle value to access the target process:\n\nThen, hackers allocate memory for writing the name of the malicious DLL within the memory area of the target process. To do so, malicious actors can use the Kernel32.dll!VirtualAllocEx() function. The process of writing the DLL into allocated memory mainly occurs through the Kernel32.dll!WriteProcessMemory() function call.\n\nFinally, to make the target process execute their code, hackers might use the Kernel32.dll!LoadLibrary function and pass the result to one of these Windows API functions:\n\nAfter all of this, a remote process must execute the injected DLL in the target application.\n\nWith basic information about the DLL injection workflow in mind, let’s overview a few simple examples of DLL injection apps and a way to protect software from them.\n\nTo showcase an example of protecting software from malicious DLL injection, we’ll do the following:\n\n1. Create two unique applications that can inject a DLL into a target application and insert a hook for the Kernel32.dll!OpenProcess function. These apps will simulate Trojan malware that hides the running process named DangerMiner from users. We’ll develop these injection apps using two different libraries to show different algorithms for DLL injection.\n\n2. Create a mechanism to prevent DLL injection. You’ll see how this protection program blocks our unique apps that try to inject DLLs.\n\nTo demonstrate how these apps work, we’ve created a simple process monitoring program into which we’ll inject the DLL file and set the hook. This program monitors all existing and newly created processes in the system and prints information about them in the console.\n\nWe decided to create such a program because injecting a DLL into an existing solution’s process without permission from its developers or owners can be considered a violation of software terms of use, service agreements, or end-user license agreements. It also might be a breach of intellectual property rights and copyright laws. We believe it’s necessary to respect the boundaries and guidelines set by software developers and the law to ensure ethical and legal behavior.\n\nNote: The injection examples below are pretty simple, focused on only affecting one process in a system. They are created for security research purposes only. Tools like Windows Security Defender (which is built into Windows) can easily detect and prevent such injection attempts.\n\nHere’s what our custom process monitoring application looks like with the DangerMiner process running:\n\nNow, let’s move to developing two DLL injection apps and a program for protecting against them.\n\nOur first DLL injection program aims to:\n• Deny the target application the ability to open the DangerMiner process so a process with this name won’t appear in our custom process monitoring app\n\nWe’ll use Nektra Deviare, a library written in C++ and built on COM objects that you can use in different programming languages. This library opens a target process, allocates memory, then tries to load a DLL that must be injected.\n\nThe C# source code below demonstrates how to inject a DLL into a running process. After a DLL is injected, it will set hooks and start to intercept the target function.\n\nAs a result, the DLL is injected into CustomProcessMonitor.exe, and the DangerMiner process isn’t shown in our process monitor app. Everything works as expected:\n\nYou can find the full source code for this project on Apriorit’s GitHub page for ProcessHide_Deviare and on the page for ProcessHidePlugin_Deviare.\n• Inject a DLL called ProcessHidePlugin_EasyHook.dll into the target application. It works the same way as our previous application.\n• Prevent the target application from opening a DangerMiner process so that a process with this name won’t appear in our custom process monitoring app\n\nEasyHook is written in C# and divided into different DLLs like EasyHook.dll and EasyLoad32.dll. Because of that division, the library first loads these DLLs into the target process and only then injects the DLL.\n\nThe C# source code below demonstrates how to inject DLL into a running process using the EasyHook library:\n\nAs a result, the DLL is injected into CustomProcessMonitor.exe, and the DangerMiner process isn’t shown in our process monitoring app. The second program also works as intended.\n\nTo see the full source code of this app, check out Apriorit’s GitHub pages for ProcessHide_EasyHook and ProcessHidePlugin_EasyHook.\n\nIn previous articles, we proposed methods for protecting against hook and return-oriented programming attacks as well as security techniques to mitigate splicer-type hooking attacks. This time, we’d like to offer another way to safeguard your applications from DLL injection attacks.\n\nAs described earlier, to perform DLL injection, hackers can use function calls like Kernel32.dll!LoadLibrary and Kernel32.dll!CreateRemoteThread to upload to and execute DLLs in the target process. Therefore, we came up with the idea of hooking the LoadLibrary function to help us:\n\nThe LoadLibrary function takes as a parameter the full path to the DLL to be loaded. In this case, we need to figure out how to determine that injection of a particular DLL should be blocked.\n\nTo determine that a DLL can be injected, you can use many options like digital signature verification, hash verification, or vendor and source validation.\n\nFor the purposes of this article, we decided to use two methods:\n\nEvery time our application loads a DLL library, we check whether this DLL passes signature validation and is contained in the allow-list folder. After all checks, we can determine with a high degree of probability whether the library is legitimate.\n\nNote that such a technique isn’t comprehensive enough to detect and prevent illegal DLL injection. You can add other checks to more accurately determine the legitimacy of the downloaded DLL as well as hook other calls to prevent malicious injection.\n\nTo set protection from illegal DLL injection, let’s use the Microsoft Detours library. Here’s how it can help us set a hook to the Kernel32.dll!LoadLibrary function call:\n\nAfter setting the hook, the protection plugin intercepts all LoadLibrary calls. Thus, when LoadLibrary is called, we need to determine whether the loading DLL is legal. In case it’s not, we must deny the function call to prevent DLL injection. Here’s how to do so:\n\nTo illustrate how such detection and prevention of illegal DLL injection works, let’s try injecting the earlier created DLLs aimed at changing the behavior of our custom process monitoring app.\n\nHere are the results of an attempt to inject a DLL using the Nektra Deviare library:\n\nLet’s also try injecting a DLL using the EasyHook library:\n\nAs you can see, our solution managed to properly detect a DLL injection and block it, informing the user about this malicious attempt. The injection process failed, and the target application continued working as before.\n\nCheck out the source code of all these projects on Apriorit’s GitHub page.\n\nYou can use the described DLL injection prevention approach for almost every Windows process. Thus, it’s applicable for a wide range of projects, especially those that work with sensitive data and critical processes where protection against unauthorized or malicious code injection is a priority.\n\nThe offered approach won’t work for some processes: not because of our technique, but because of other reasons such as process design, security, or access rights. For example:\n• Processes designed to be more secure and resistant to tampering, such as antivirus or anti-malware processes, as they employ various security mechanisms to prevent external interference, including DLL injection\n• Processes that require administrator privileges to be attached to or injected into\n• Critical system processes and services that are protected against modification to ensure system stability\n• Universal Windows Platform apps that run in a more isolated environment for security reasons and have restrictions on attaching and manipulating them\n• Processes that enable debugging protection to prevent unauthorized debugging or code injection, which can restrict or disable attaching to, setting hooks, or injecting into those processes\n\nYou can use our approach both as a standalone security check and as part of a larger product like a cybersecurity system, antivirus software, game anti-cheat solution, or system monitoring application.\n\nNote that this method doesn’t protect against other common attacks. Also, this is not the primary technique to detect and prevent illegal DLL injection. To get the most out of this method, you might need to add more checks to accurately determine the legitimacy of the downloaded DLL as well as hook some other calls to prevent injections. We believe that such DLL injection protection works well as part of (and can complement) larger protection systems.\n\nThe solution we presented above is a simple example aimed to demonstrate one of many ways to secure your applications and systems from DLL injection attacks. Thus, our proposed solution has its flaws.\n\nOnly relying on a folder-based whitelist and signature verification might not provide foolproof protection against all forms of DLL injection or unauthorized DLL loading. A signature verification may return an invalid value for an illegal DLL, or the returned value may be modified by an attacker. Also, sophisticated attackers can find ways to place malicious DLLs in trusted folders, modify the whitelist, or bypass whitelist checks altogether.\n\nTo achieve robust protection from DLL injection, your team requires enough experience and knowledge to understand the possible context behind a particular DLL injection. Remember that security measures should be comprehensive and multi-layered to effectively address various attack vectors. We also recommend your team take the following steps to keep your systems secure:\n• Install security updates and patches as soon as they become available to ensure that your system is protected against known vulnerabilities.\n• Download software only from reputable sources and verify its authenticity before installing it.\n• Turn off any unneeded services or applications.\n• Use the principle of least privilege, giving users and processes only the access they need to carry out their tasks.\n• Enable Windows Defender Application Control to prevent the loading of unsigned DLLs.\n• Sign your DLLs using code signing certificates to ensure they have not been modified.\n• Monitor your systems for suspicious activity and investigate any anomalies you detect.\n\nIn all Apriorit projects, we assess a variety of security risks and choose relevant security measures that ensure complex software protection. Our experts will gladly help you protect your solutions against malicious attacks.\n\nKnowing how to detect DLL injections and mitigate them in your software can prevent costly incident handling, improve your reputation, and help your product better handle security threats. You can use the method for protecting against DLL injections proposed in this article as one way to increase product and data security. But keep in mind that your product will need more robust defenses to achieve comprehensive protection against various attacks.\n\nIn this article, we discussed the basics of how to prevent DLL injection. A comprehensive protection strategy requires a combination of security measures and a proactive security mindset. It’s essential to follow secure coding practices, implement proper access controls, and stay informed about the latest security threats and best practices.\n\nAt Apriorit, we have dedicated teams of Windows developers and cybersecurity experts with vast experience delivering efficient and protected software to our clients. Our engineers are ready to help you enhance your project’s security."
    },
    {
        "link": "https://stackoverflow.com/questions/869320/how-do-i-prevent-dll-injection",
        "document": "How to defend against those 3 techniques:\n\nYou can prevent the first technique (CreateRemoteThread which calls LoadLibrary) by hooking LoadLibrary. In your hook you check against a list of DLL names that you know are part of the process and that may be loaded, or you can check against a list of known DLLs you don't want to load.\n\nWhen you find a DLL you don't want to load SetLastError(ERROR_ACCESS_DENIED) then return NULL. I set the last error so that people that write code looking for an error code get one. This appears to work, perhaps a different code may be more appropriate.\n\nThat will stop the DLL from loading.\n\nI think the same technique for CreateRemoteThread blocking will work for SetWindowsHookEx, but only if you can get your hook installed before the SetWindowsHookEx technique has started loading its code (which is typically when the first Window is created in an app - so early in its lifetime).\n\nNice technique. Not seen that before. You can defend against this, but you'll have to hook the LoadLibrary entry point (not the IAT table) as the Code Cave calls LoadLibrary directly.\n\nAs the author of the article commented - there are many ways you can be attacked and you probably will have a hard time defeating them all. But often you only want to defend against certain DLL loads (such as a particular 3rd party DLL that is incompatible with your software because the 3rd party DLL wasn't written properly to accomodate the fact that another hook may also be present, so you block it from loading)."
    },
    {
        "link": "https://stackoverflow.com/questions/9450372/prevent-dll-injection-from-an-dll-c",
        "document": "This question is old but I will briefly answer it in better form for anyone who does happen to stumble upon it magically after a proper response.\n\nYou cannot fully prevent code injection from within your own process, but you can try to do some tricks without interception of other processes. It is not recommended because you need to have experience and knowledge with lower-level tasks, especially to get it working properly and not prevent functionality of your own software, however...\n\nAsynchronous Procedure Calls (APC) is an implementation from the Windows Kernel. It is primarily used for code injection into other running processes, Windows uses it a lot itself for a variety of things such as notifications being sent to specific processes. When a user-mode process calls QueueUserApc (KERNEL32), NtQueueApcThread (NTDLL) will be invoked. NtQueueApcThread (NTDLL) will perform a system call which will cause NtQueueApcThread (NTOSKRNL) to be invoked, which is not exported by NTOSKRNL - for anyone wondering, NTOSKRNL is the Windows Kernel, and a system-call is nothing more than a transition from user-mode to kernel-mode since the Native API System Routines exist in kernel-mode memory, NTDLL routines for NTAPI are system call stubs which direct control up to the Windows Kernel. When NtQueueApcThread (NTOSKRNL) is called, it'll use KeInitializeApc and KeInsertQueueApc (both do happen to be exported by NTOSKNL). When the APC is actually issued to the targeted process, KiUserApcDispatcher (NTDLL) will be locally called within the process, unless the APC is performed in a more extensive manner to bypass this activity (99% of the time it will not be prevented). This means that you have an oppertunity to intercept this behavior and prevent APC injection into your own process with one single local hook in your own process, via byte-patching (also known as \"inline hooking\") KiUserApcDispatcher, exported by NTDLL. The only problem which you will face is that it is undocumented and this is not officially supported by Microsoft; you'll need to figure out how the parameters work and how to prevent the callback routine from blocking off genuine requests which are needed to provide functionality for your own software. This will however include prevention of kernel-mode APC injection, not just user-mode attacks.\n\nThere are many ways to inject code into a process, and APC is simply one of them. Another common method would be through remote thread creation. When a user-mode process attacks another process via remote thread creation, it'll typically call CreateRemoteThread (KERNEL32). This will lead down to RtlCreateUserThread (NTDLL), and RtlCreateUserThread will call NtCreateThreadEx (NTDLL). NTDLL will perform a system call and then NtCreateThreadEx (non-exported routine from the Windows Kernel) will be invoked in kernel-mode memory. In the end, the targeted process will have LdrInitializeThunk locally invoked, and RtlUserThreadStart will also be invoked locally. Both of these routines are exported by NTDLL. This is a same scenario as with APC... You can patch LdrInitializeThunk locally, however you must do it properly to prevent genuine functionality within your own software.\n\nThese two techniques are not full-proof, there is no \"full-proof\" solution. There are many ways to inject code into a process, and there are very sophisticated methods to bypass said solutions from myself. Anti-Virus software has been battling anti-RCE/self-protection for as long as I can remember, as has Anti-Cheat systems. You should look into kernel-mode device driver development as well, it'll allow you to register kernel-mode callbacks which can help you out.\n\nThe first callback you should look into is ObRegisterCallbacks. It allows you to receive a Pre-operation callback notification whenever NtOpenProcess is called from the Windows Kernel. This means that user-mode processes will also trigger it, since NtOpenProcess ends up being called in kernel-mode after NTDLL makes the system-call. I cannot remember specifically if the callback APIs are triggered in the NtOpenProcess stub itself or if it goes deeper into Ob* kernel-mode only routines, but you can check at ease with WinDbg with remote kernel debugging, or Interactive Disassembler (target ntoskrnl.exe and use the symbolic links provided by Microsoft). ObRegisterCallbacks supports notifications for both handle creation & duplication for the process and the processes' threads, you can strip access rights you don't want permitted for the requested handle.\n\nThe second callback you should look into would be PsSetCreateThreadNotifyRoutineEx. This callback routine will allow you to receive a notification whenever a new thread creation occurs on the system; you can filter it out for your own process and if a rogue thread is created, terminate the thread.\n\nThe third callback you should look into would be PsSetLoadImageNotifyRoutineEx. This callback will provide a notification whenever a new module is loaded into a process; once again, you can filter for your own process. If you detect a rogue module, you can attempt to have your process call LdrUnloadDll (NTDLL) targeting the base address of the newly loaded image, however the reference count for the module needs to be 0 for it to be unloaded. In that case, you can try \"hacky\" methods like calling NtUnmapViewOfSection/NtFreeVirtualMemory. Bear in mind, if you mess up the rogue loaded module and it has set memory byte patches to redirect execution flow to its own routines, unless you restore them, your process will crash when they are referenced.\n\nThese are some ideas, commonly the ones typically used. Kernel-Mode callbacks are very popular among security software and anti-cheat software. As for thread creation, you'll be interested in mitigating this as much as possible -> if you only look for rogue DLL loads then you'll miss out on reflective DLL loading. Also remember of the other code injection methods, like thread hijacking, shared window memory exploitation with ROP chain call exploitation, DLL patching on-disk, etc."
    },
    {
        "link": "https://support.microsoft.com/en-us/topic/secure-loading-of-libraries-to-prevent-dll-preloading-attacks-d41303ec-0748-9211-f317-2edc819682e1",
        "document": "Support for Windows Vista Service Pack 1 (SP1) ends on July 12, 2011. To continue receiving security updates for Windows, make sure you're running Windows Vista with Service Pack 2 (SP2). For more information, refer to this Microsoft web page: Support is ending for some versions of Windows. When an application dynamically loads a dynamic link library (DLL) without specifying a fully qualified path, Windows tries to locate the DLL by searching a well-defined set of directories. If an attacker gains control of one of the directories, they can force the application to load a malicious copy of the DLL instead of the DLL that it was expecting. These attacks are known as “DLL preloading attacks” and are common to all operating systems that support dynamically loading shared DLL libraries. The effect of such attacks could be that an attacker can execute code in the context of the user who is running the application. When the application is being run as Administrator, this could lead to a local elevation of privilege. We know about renewed interest in these attacks. To limit the effect that this issue has on our mutual customers, we are releasing this document to the developer community to make sure that they know about this issue and have the necessary tools to address the issue in their applications.\n\nWhen an application dynamically loads a DLL without specifying a fully qualified path, Windows tries to locate this DLL by linearly searching through a well-defined set of directories, known as DLL Search Order. If Windows locates the DLL within the DLL Search Order, it will load that DLL. However, if Windows does not find the DLL in any of the directories in the DLL Search Order, it will return a failure to the DLL load operation. The following is the DLL Search Order for the LoadLibraryand LoadLibraryExfunctions, which are used to dynamically load DLLs:\n• The directory from which the application loaded\n• The directories that are listed in the PATH environment variable\n• An application loads a DLL without specifying a fully qualified path that it expects to find in the CWD of the application.\n• The application is fully prepared to handle the case when it does not find the DLL.\n• The attacker knows this information about the application and controls the CWD.\n• The attacker copies their own specially crafted version of the DLL in the CWD. This assumes that the attacker has permission to do this.\n• Windows searches through the directories in the DLL Search Order and finds the DLL in the CWD of the application. In this scenario, the specially crafted DLL runs within the application and gains the privileges of the current user.\n\n\n\nRecommendation\n\n\n\nTo prevent this attack, applications can remove the current working directory (CWD) from the DLL search path by calling the SetDllDirectory API by using an empty string (“”). If an application depends on loading a DLL from the current directory, please obtain the current working directory and use that to pass in a fully qualified path of LoadLibrary.\n\n\n\n\n\n\n\nWe are also aware that some developers use LoadLibrary to validate whether a specific DLL is present in order to determine which version of Windows is being run by the user. You should be aware that this could make the application vulnerable. If the affected library indeed does not exist on the Windows release that the application is executed on, an attacker could introduce a library with that same name into CWD. We strongly recommend against using this technique. Instead, use the recommended techniques that are described in MSDN article, \"Getting the System Version.\" \n\n\n\nAn application that loads third-party plugins and that cannot force the plugins to use a qualified path for its LoadLibrary calls should call SetDllDirectory(“”) to remove CWD and then call SetDllDirectory(“plugin install location”) to add the plugin install directory to the DLL search path. A similar attack exists when an application uses the SearchPath API to locate a DLL and dynamically load the path that is returned by SearchPath. The following is the default search order for the SearchPath API:\n• The directory from which the application loaded\n• The directories that are listed in the PATH environment variable We do not recommend this pattern because it is not secure. We do not recommend the SearchPath function as a method of locating a .dll file if the intended use of the output is in a call to the LoadLibrary function. This can result in locating the wrong .dll file because the search order of the SearchPath function differs from the search order used by the LoadLibrary function. If you have to locate and load a .dll file, use the LoadLibrary function. \n\nVariations of these issues can also exist when developers call similar functions such as ShellExecuteand CreateProcessto load external executables. We recommend that developers be careful when they are loading binaries and specify the fully qualified path. This should pose less complexity when you load a binary instead of a library. We recommend that developers do the following:\n• Validate their applications for instances of nonsecure library loads (examples of each are given later in this article). These include the following:\n• The use of SearchPath to identify the location of a library or component.\n• The use of LoadLibrary to identify the version of the operating system.\n• Use fully qualified paths for all calls to LoadLibrary, CreateProcess, and ShellExecute where you can.\n• Implement calls to SetDllDirectory with an empty string (“”) to remove the current working directory from the default DLL search order where it is required. Be aware that SetDllDirectory affects the whole process. Therefore, you should do this one time early in process initialization, not before and after calls to LoadLibrary. Because SetDllDirectory affects the whole process, multiple threads calling SetDllDirectory with different values could cause undefined behavior. Additionally, if the process is designed to load third-party DLLs, testing will be needed to determine whether making a process-wide setting will cause incompatibilities. A known issue is that when an application depends on Visual Basic for Applications, a process-wide setting may cause incompatibilities.\n• Use the SetSearchPathModefunction to enable safe process search mode for the process. This moves the current working directory to the last place in the SearchPath search list for the lifetime of the process.\n• Avoid using SearchPath to check for the existence of a DLL without specifying a fully qualified path, even if safe search mode is enabled, because this can still lead to DLL Preloading attacks. In source code, the following are examples of nonsecure library loads:\n• In the following code example, the application searches for “schannel.dll” by using the least secure search path. If an attacker can place schannel.dll in CWD, it will load even before the application searches the Windows directories for the appropriate library.\n• In the following code example, the application tries to load the library from the various application and operating system locations described in the beginning of this document for the LoadLibrary() call. If there is any risk that the file is not present, the application may try to load the file from the current working directory. This scenario is slightly less dangerous than the previous example. However, it still exposes the application user to risk if the environment is not completely predictable. \n\n \n\n \n\nThe following are examples of better, more secure library loads:\n• In the following code example, the library is loaded directly by using a fully qualified path. There is no risk of the attacker introducing malicious code unless he already has write permissions to the application’s target directory.\n\n\n\n \n\n \n\nNote For information about how to determine the system directory, see the following resources:\n\n\n\nGetSystemDirectory\n• In the following code example, the current working directory is removed from the search path before calling LoadLibrary. This reduces the risk significantly, as the attacker would have to control either the application directory, the Windows directory, or any directories that are specified in the user’s path in order to use a DLL preloading attack.\n• On all systems that have installed security update 963027 (described in MS09-014), the following code would permanently move CWD to the very last spot in the search order. Any later calls to the SetSearchPathMode function from inside that process that try to change the search mode will fail.\n• In the following code example, the current working directory is removed from the search path before calling LoadLibrary. This reduces the risk significantly, as the attacker would have to control either the application directory, the windows directory, or any directories that are specified in the user’s path in order to use a DLL preloading attack. Microsoft publishes a tool that is named Process Monitor. This tool enables developers and administrators to closely track the behavior of a running process. Process Monitor can be used to dynamically detect whether one of your applications may be vulnerable to this kind of issue.\n• To download Process Monitor, visit the following Microsoft webpage:\n• Try to start your application by using CWD set to a specific directory. For example, double-click a file that has an extension whose file handler is assigned to your application.\n• Set up Process Monitor with the following filters:\n• If a vulnerable path is being hit, you will see something that is similar to the following: \n\n\n\n The call to the remote file share to load a DLL indicates that this is a vulnerable program."
    },
    {
        "link": "https://quora.com/What-are-the-most-effective-strategies-for-protecting-software-from-DLL-injection?no_redirect=1",
        "document": "Something went wrong. Wait a moment and try again."
    }
]