[
    {
        "link": "https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/context",
        "document": "Here's a basic example of creating a context containing the active theme.\n\nWrap the components that need the context with a context provider:\n\nCall to read and subscribe to the context.\n\nIf you don't have any meaningful default value, specify :\n\nNow that the type of the context can be , you'll notice that you'll get a TypeScript error if you try to access the property. You can use optional chaining to access :\n\nHowever, it would be preferable to not have to check for , since we know that the context won't be . One way to do that is to provide a custom hook to use the context, where an error is thrown if the context is not provided:\n\nUsing a runtime type check in this will has the benefit of printing a clear error message in the console when a provider is not wrapping the components properly. Now it's possible to access without checking for :\n\nAnother way to avoid having to check for is to use type assertion to tell TypeScript you know the context is not :\n\nAnother option is to use an empty object as default value and cast it to the expected context type:\n\nYou can also use non-null assertion to get the same result:\n\nWhen you don't know what to choose, prefer runtime checking and throwing over type asserting."
    },
    {
        "link": "https://react.dev/learn/typescript",
        "document": "The type describing your component’s props can be as simple or as complex as you need, though they should be an object type described with either a or . You can learn about how TypeScript describes objects in Object Types but you may also be interested in using Union Types to describe a prop that can be one of a few different types and the Creating Types from Types guide for more advanced use cases. The type definitions from include types for the built-in Hooks, so you can use them in your components without any additional setup. They are built to take into account the code you write in your component, so you will get inferred types a lot of the time and ideally do not need to handle the minutiae of providing the types. However, we can look at a few examples of how to provide types for Hooks. The Hook will re-use the value passed in as the initial state to determine what the type of the value should be. For example: This will assign the type of to , and will be a function accepting either a argument, or a function that returns a . If you want to explicitly provide a type for the state, you can do so by providing a type argument to the call: This isn’t very useful in this case, but a common case where you may want to provide a type is when you have a union type. For example, here can be one of a few different strings: Or, as recommended in Principles for structuring state, you can group related state as an object and describe the different possibilities via object types: The Hook is a more complex Hook that takes a reducer function and an initial state. The types for the reducer function are inferred from the initial state. You can optionally provide a type argument to the call to provide a type for the state, but it is often better to set the type on the initial state instead:\n\nWe are using TypeScript in a few key places:\n• describes the shape of the reducer’s state.\n• describes the different actions which can be dispatched to the reducer.\n• provides a type for the initial state, and also the type which is used by by default.\n• sets the types for the reducer function’s arguments and return value. A more explicit alternative to setting the type on is to provide a type argument to : The Hook is a technique for passing data down the component tree without having to pass props through components. It is used by creating a provider component and often by creating a Hook to consume the value in a child component. The type of the value provided by the context is inferred from the value passed to the call:\n\nThis technique works when you have a default value which makes sense - but there are occasionally cases when you do not, and in those cases can feel reasonable as a default value. However, to allow the type-system to understand your code, you need to explicitly set on the . This causes the issue that you need to eliminate the in the type for context consumers. Our recommendation is to have the Hook do a runtime check for it’s existence and throw an error when not present: ! \"useGetComplexObject must be used within a Provider\" \n\n The Hooks will create/re-access a memorized value from a function call, re-running the function only when dependencies passed as the 2nd parameter are changed. The result of calling the Hook is inferred from the return value from the function in the first parameter. You can be more explicit by providing a type argument to the Hook. The provide a stable reference to a function as long as the dependencies passed into the second parameter are the same. Like , the function’s type is inferred from the return value of the function in the first parameter, and you can be more explicit by providing a type argument to the Hook. When working in TypeScript strict mode requires adding types for the parameters in your callback. This is because the type of the callback is inferred from the return value of the function, and without parameters the type cannot be fully understood. Depending on your code-style preferences, you could use the functions from the React types to provide the type for the event handler at the same time as defining the callback: There is quite an expansive set of types which come from the package, it is worth a read when you feel comfortable with how React and TypeScript interact. You can find them in React’s folder in DefinitelyTyped. We will cover a few of the more common types here. When working with DOM events in React, the type of the event can often be inferred from the event handler. However, when you want to extract a function to be passed to an event handler, you will need to explicitly set the type of the event.\n\nThere are many types of events provided in the React types - the full list can be found here which is based on the most popular events from the DOM. When determining the type you are looking for you can first look at the hover information for the event handler you are using, which will show the type of the event. If you need to use an event that is not included in this list, you can use the type, which is the base type for all events. There are two common paths to describing the children of a component. The first is to use the type, which is a union of all the possible types that can be passed as children in JSX: This is a very broad definition of children. The second is to use the type, which is only JSX elements and not JavaScript primitives like strings or numbers: Note, that you cannot use TypeScript to describe that the children are a certain type of JSX elements, so you cannot use the type-system to describe a component which only accepts children. You can see an example of both and with the type-checker in this TypeScript playground. When using inline styles in React, you can use to describe the object passed to the prop. This type is a union of all the possible CSS properties, and is a good way to ensure you are passing valid CSS properties to the prop, and to get auto-complete in your editor. This guide has covered the basics of using TypeScript with React, but there is a lot more to learn. Individual API pages on the docs may contain more in-depth documentation on how to use them with TypeScript. We recommend the following resources:\n• The TypeScript handbook is the official documentation for TypeScript, and covers most key language features.\n• The TypeScript release notes cover new features in depth.\n• React TypeScript Cheatsheet is a community-maintained cheatsheet for using TypeScript with React, covering a lot of useful edge cases and providing more breadth than this document.\n• TypeScript Community Discord is a great place to ask questions and get help with TypeScript and React issues."
    },
    {
        "link": "https://legacy.reactjs.org/docs/context.html",
        "document": "Context provides a way to pass data through the component tree without having to pass props down manually at every level.\n\nIn a typical React application, data is passed top-down (parent to child) via props, but such usage can be cumbersome for certain types of props (e.g. locale preference, UI theme) that are required by many components within an application. Context provides a way to share values like these between components without having to explicitly pass a prop through every level of the tree.\n• When to Use Context\n• Before You Use Context\n\nWhen to Use Context\n\nContext is designed to share data that can be considered “global” for a tree of React components, such as the current authenticated user, theme, or preferred language. For example, in the code below we manually thread through a “theme” prop in order to style the Button component:\n\nUsing context, we can avoid passing props through intermediate elements:\n\nBefore You Use Context\n\nContext is primarily used when some data needs to be accessible by many components at different nesting levels. Apply it sparingly because it makes component reuse more difficult.\n\nIf you only want to avoid passing some props through many levels, component composition is often a simpler solution than context.\n\nFor example, consider a component that passes a and prop several levels down so that deeply nested and components can read it:\n\nIt might feel redundant to pass down the and props through many levels if in the end only the component really needs it. It’s also annoying that whenever the component needs more props from the top, you have to add them at all the intermediate levels too.\n\nOne way to solve this issue without context is to pass down the component itself so that the intermediate components don’t need to know about the or props:\n\nWith this change, only the top-most Page component needs to know about the and components’ use of and .\n\nThis inversion of control can make your code cleaner in many cases by reducing the amount of props you need to pass through your application and giving more control to the root components. Such inversion, however, isn’t the right choice in every case; moving more complexity higher in the tree makes those higher-level components more complicated and forces the lower-level components to be more flexible than you may want.\n\nYou’re not limited to a single child for a component. You may pass multiple children, or even have multiple separate “slots” for children, as documented here:\n\nThis pattern is sufficient for many cases when you need to decouple a child from its immediate parents. You can take it even further with render props if the child needs to communicate with the parent before rendering.\n\nHowever, sometimes the same data needs to be accessible by many components in the tree, and at different nesting levels. Context lets you “broadcast” such data, and changes to it, to all components below. Common examples where using context might be simpler than the alternatives include managing the current locale, theme, or a data cache.\n\nCreates a Context object. When React renders a component that subscribes to this Context object it will read the current context value from the closest matching above it in the tree.\n\nThe argument is only used when a component does not have a matching Provider above it in the tree. This default value can be helpful for testing components in isolation without wrapping them. Note: passing as a Provider value does not cause consuming components to use .\n\nEvery Context object comes with a Provider React component that allows consuming components to subscribe to context changes.\n\nThe Provider component accepts a prop to be passed to consuming components that are descendants of this Provider. One Provider can be connected to many consumers. Providers can be nested to override values deeper within the tree.\n\nAll consumers that are descendants of a Provider will re-render whenever the Provider’s prop changes. The propagation from Provider to its descendant consumers (including and ) is not subject to the method, so the consumer is updated even when an ancestor component skips an update.\n\nChanges are determined by comparing the new and old values using the same algorithm as .\n\nThe property on a class can be assigned a Context object created by . Using this property lets you consume the nearest current value of that Context type using . You can reference this in any of the lifecycle methods including the render function.\n\nA React component that subscribes to context changes. Using this component lets you subscribe to a context within a function component.\n\nRequires a function as a child. The function receives the current context value and returns a React node. The argument passed to the function will be equal to the prop of the closest Provider for this context above in the tree. If there is no Provider for this context above, the argument will be equal to the that was passed to .\n\nContext object accepts a string property. React DevTools uses this string to determine what to display for the context.\n\nFor example, the following component will appear as MyDisplayName in the DevTools:\n\nA more complex example with dynamic values for the theme:\n\nIt is often necessary to update the context from a component that is nested somewhere deeply in the component tree. In this case you can pass a function down through the context to allow consumers to update the context:\n\nTo keep context re-rendering fast, React needs to make each context consumer a separate node in the tree.\n\nIf two or more context values are often used together, you might want to consider creating your own render prop component that provides both.\n\nBecause context uses reference identity to determine when to re-render, there are some gotchas that could trigger unintentional renders in consumers when a provider’s parent re-renders. For example, the code below will re-render all consumers every time the Provider re-renders because a new object is always created for :\n\nTo get around this, lift the value into the parent’s state:"
    },
    {
        "link": "https://stackoverflow.com/questions/68410046/what-is-one-standard-way-to-document-a-context-provider-in-react-js",
        "document": "I am writing a Context provider in React.js, and am stuck when it comes to documenting it. Is there a standard way to do that? What I'm looking for is something similar to component documentation using PropTypes, where you put comments on top of each , as well as on top of the component's definition. It is preferable if the solution is supported by"
    },
    {
        "link": "https://blog.logrocket.com/how-to-use-react-context-typescript",
        "document": "Editor’s note: This article was last reviewed and updated by Popoola Temitope on 4 December 2024. The updates include an exploration of when to use React Context, an explanation of conditional fetching with , and an overview of the React function.\n\nThe React Context API was introduced in React v16 as a way to share data in a component tree without needing to pass props down at every level.\n\nThe Context API is ideal for data that is considered “global” but not large or complex enough for a dedicated state manager like Redux or MobX, such as the user’s current language, current theme, or even data from a multi-step form before being sent to an API.\n\nReact Context is used to share global data or state between components, making it a great choice in the following areas:\n• Authentication: React Context can be used to manage a user’s authentication data, such as a login token, personal information, and roles that define the user’s permission levels within the application\n• Theme management: React Context can be used to load the user’s preferred theme across the application, ensuring consistent styling across all components\n• Localization: React Context can be used to manage a user’s preferred language, allowing applications to display content customized to their language preferences\n• Data sharing between components: React Context can be used to share data or state across application components, preventing prop drilling\n\nTo demonstrate React Context, we’ll build a to-do app that uses the Context API to manage tasks on the list, and also for theming.\n\nIn our tutorial, we will use Create React App to have a modern configuration with no hassle, but you are welcome to set up a new app from scratch using webpack.\n\nBegin by opening your terminal and running the following command:\n\nTo easily create a TypeScript project with CRA, you need to add the flag , otherwise the app will only support JavaScript.\n\nNext, let’s structure the project as follows:\n\nHere, there are two files to underline:\n• The file, which exports the created context for the to-do functionality and its provider\n• The in the file contains the type definitions for parts of the app that concern the to-do list implementation\n\nHaving dedicated type definition files is a best practice because it improves the structure of your project. The declared types can either be used by reference without importing them, or explicitly by importing them into another file — though they have to be exported first. Ideally, we’d want to import the types so we don’t pollute the global namespace.\n\nWith this in place, we can now get our hands dirty and code something meaningful.\n\nTypeScript types allow you to define what a variable or function should expect as a value to help the compiler catch errors before runtime:\n\nAs you can see, the interface defines the shape of a to-do object. Next, we have the type that exports an array of to-dos and the methods to add or update a to-do.\n\nReact Context allows you to share and manage state across your components without passing down props. The context will provide the data to just the components that need to consume it:\n\nHere, we start by creating a new context and setting its type to match or . We set the default value to temporarily when creating the context; the intended values will be assigned to the provider.\n\nNext, we create the component , which provides the context to the component consumers. Here, we initialize the state with some data to have to work:\n\nThe function will create a new to-do based on the interface and then append the object to the array of to-dos. The next function, , will look for the ID of the to-do passed as a parameter in the array of to-dos and then update it:\n\nNext, we pass the values to the context to make them consumable for the components:\n\nWith this, we are now able to consume the context. So, let’s create the components in the next section.\n\nThe Hook is a crucial tool in React development for efficient state management and data transfer between components. It enables components to access React context values without passing props through intermediary components.\n\nWhen used with TypeScript, the Hook adds an extra layer of type safety, ensuring correct types are used throughout the application. The Hook is part of the React Hooks API and consumes values from the React Context, returning the current context value for that context. In the next section, we will see how to import and use the Hook in our component.\n\nCreating the components and consuming the context\n\nBelow, we have a form component that allows us to handle the data entered by the user using the Hook. Once we get the form data, we use the function, pulled from the context object, to add a new to-do:\n\nNote that I use typecasting on the Hook to prevent TypeScript from throwing errors because the context will be at the beginning:\n\nAs you can see here, we have a presentational component that shows a single to-do. It receives the object and the function to update it as parameters that need to match the type defined above:\n\nThis component shows the list of to-dos when the page loads. It pulls the and the function from the to-do context. Next, we loop through the array and pass the object we want to display to the component.\n\nFrom this step onward, we will be able to provide the to-do context in the file to finish building the app. So, let’s use the context provider in the next part.\n\nHere, we import the component that wraps the consumers of the to-do context. That said, we can now access the array and the function to add or update a to-do using the Hook in other components.\n\nWith this, we can now open the project on the terminal and run either of the following commands:\n\nIf everything works, you’ll be able to see this in the browser:\n\n\n\nWhen managing complex shared states within React Context, combining the Hook with TypeScript helps manage the state at a higher level and share it across components, enhancing code robustness and developer experiences.\n\nThe benefits include type safety, code auto-completion, and refactoring support. Using the Hook also helps centralize state modifications and ensures a predictable state transition.\n\nWe’ll rewrite our simple to-do application but this time, we’ll use the context reducer with TypeScript. First, we will start by defining action types for the reducer:\n\nThe next step is to create a reducer function that will handle state changes based on dispatched actions. In this case, actions are either adding a new or updating an existing todo’s status:\n\nNow, in the , let’s provide it with an initial state and the reducer function:\n\nNow our React application is configured with a context reducer using TypeScript, ensuring type safety and a structured approach to managing global state. Let’s proceed to consume the context in our components.\n\nUpdate the code in the file with the code below:\n\nIn this example, the Hook is used to get the dispatch function from the . The component then uses the function to provide the functionality to add new todos.\n\nUpdate the code in file with the code below:\n\nHere the component receives the object and updates it as parameters that must match the defined type:\n\nWe display the list of and update the to-do using the function we pull out from the .\n\nIn your file, ensure it is wrapped with the to be able to access the array and the function to add or update a to-do using the Hook in other components:\n\nNow run the development server using or , and we will see that everything works the same way in our previous example without using the context reducer.\n\nIn this section, we’ll take another look at one more application of the Context API, theming:\n\nWe create the types necessary for implementing theming: specifies the possible theme modes and specifies the properties that will be available in the theme context as we consume it.\n\nNext, we create a file that exports the raw theme context and its provider:\n\nAfter creating the context, we create a component that will both consume it and toggle the theme on the app:\n\nWith ready, we can now import it into and test it out:\n\nOnce the attribute is modified by the change handler of the select element, the prewritten CSS file takes care of the rest.\n\nDespite its many advantages, developers often face challenges when using React Context with TypeScript.\n\nTypeScript can struggle to correctly infer types, especially with complex structures or nested contexts. To improve type safety, define types explicitly for context values or use the keyword for type assertion:\n\nIn situations where the default context value depends on other variables or cannot be determined during context creation, it is necessary to assign / as the default value or TypeScript will throw type errors.\n\nThe problem can be resolved by defining the context type as / or using optional chaining or non-null assertions for safe access:\n\nAnother way to address this issue is to use a helper function:\n\nThe function uses the Hook to get the current value of the . If it’s or , it throws an error, indicating the need to use the function within the .\n\nIf it’s available, it returns it, ensuring the consuming component receives the context value and TypeScript can infer the correct types:\n\nNow, and have the correct types and / issues are handled.\n\nIt can be difficult to ensure type safety in reducer functions, particularly when working with complex state structures.\n\nUsing discriminated unions to manage various action circumstances and establish clear and exact definitions for action types guarantees type safety in the reducer and aids TypeScript with appropriately interpreting types:\n\nThe example shows that two components ( and ) use the same context ( ) to access a counter value. The component renders both components, but when the counter is incremented, both re-render, a common issue with excessive context usage, potentially causing performance issues.\n\nTo address this, use judiciously for global or deeply shared data, consider alternative state management solutions like Redux, or optimize context updates using memoization techniques:\n\noptimizes components by preventing unnecessary re-renders when props remain unchanged, thereby mitigating performance issues due to excessive context updates.\n\nConditional fetching in is a pattern where you retrieve data or access a value from a context only under certain conditions. This approach helps avoid unnecessary computations, rendering, or accessing values from the context when they are not needed:\n\nFrom the code above, the value is retrieved only when the variable is true, which helps avoid unnecessary access to the context value.\n\nReact’s is a context property used in class components to access context values without the need for the component. By assigning a context object to the property, React makes the current value of the context accessible through the property within the class. This helps avoid the nested renders required when using the component.\n\nTo demonstrate how to use , let’s create a context object that will hold the global data. To do this, inside the folder, create and add the following code:\n\nIn your class component, to access the context data, you need to import the context state object and assign it to the static API. Then, the context data can be accessed using the property, as used in the component below:\n\nIn your main component, you can pass data to class using the code below:\n\nIn this guide, we explored how to effectively use React Context with TypeScript by building a demo to-do app. We covered setting up the app, creating types, establishing context, and implementing components. Additionally, we addressed common TypeScript issues in React Context, such as handling null or undefined values, ensuring reducer function type safety, and avoiding context overuse to maintain performance."
    },
    {
        "link": "https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/context",
        "document": "Here's a basic example of creating a context containing the active theme.\n\nWrap the components that need the context with a context provider:\n\nCall to read and subscribe to the context.\n\nIf you don't have any meaningful default value, specify :\n\nNow that the type of the context can be , you'll notice that you'll get a TypeScript error if you try to access the property. You can use optional chaining to access :\n\nHowever, it would be preferable to not have to check for , since we know that the context won't be . One way to do that is to provide a custom hook to use the context, where an error is thrown if the context is not provided:\n\nUsing a runtime type check in this will has the benefit of printing a clear error message in the console when a provider is not wrapping the components properly. Now it's possible to access without checking for :\n\nAnother way to avoid having to check for is to use type assertion to tell TypeScript you know the context is not :\n\nAnother option is to use an empty object as default value and cast it to the expected context type:\n\nYou can also use non-null assertion to get the same result:\n\nWhen you don't know what to choose, prefer runtime checking and throwing over type asserting."
    },
    {
        "link": "https://blog.logrocket.com/how-to-use-react-context-typescript",
        "document": "Editor’s note: This article was last reviewed and updated by Popoola Temitope on 4 December 2024. The updates include an exploration of when to use React Context, an explanation of conditional fetching with , and an overview of the React function.\n\nThe React Context API was introduced in React v16 as a way to share data in a component tree without needing to pass props down at every level.\n\nThe Context API is ideal for data that is considered “global” but not large or complex enough for a dedicated state manager like Redux or MobX, such as the user’s current language, current theme, or even data from a multi-step form before being sent to an API.\n\nReact Context is used to share global data or state between components, making it a great choice in the following areas:\n• Authentication: React Context can be used to manage a user’s authentication data, such as a login token, personal information, and roles that define the user’s permission levels within the application\n• Theme management: React Context can be used to load the user’s preferred theme across the application, ensuring consistent styling across all components\n• Localization: React Context can be used to manage a user’s preferred language, allowing applications to display content customized to their language preferences\n• Data sharing between components: React Context can be used to share data or state across application components, preventing prop drilling\n\nTo demonstrate React Context, we’ll build a to-do app that uses the Context API to manage tasks on the list, and also for theming.\n\nIn our tutorial, we will use Create React App to have a modern configuration with no hassle, but you are welcome to set up a new app from scratch using webpack.\n\nBegin by opening your terminal and running the following command:\n\nTo easily create a TypeScript project with CRA, you need to add the flag , otherwise the app will only support JavaScript.\n\nNext, let’s structure the project as follows:\n\nHere, there are two files to underline:\n• The file, which exports the created context for the to-do functionality and its provider\n• The in the file contains the type definitions for parts of the app that concern the to-do list implementation\n\nHaving dedicated type definition files is a best practice because it improves the structure of your project. The declared types can either be used by reference without importing them, or explicitly by importing them into another file — though they have to be exported first. Ideally, we’d want to import the types so we don’t pollute the global namespace.\n\nWith this in place, we can now get our hands dirty and code something meaningful.\n\nTypeScript types allow you to define what a variable or function should expect as a value to help the compiler catch errors before runtime:\n\nAs you can see, the interface defines the shape of a to-do object. Next, we have the type that exports an array of to-dos and the methods to add or update a to-do.\n\nReact Context allows you to share and manage state across your components without passing down props. The context will provide the data to just the components that need to consume it:\n\nHere, we start by creating a new context and setting its type to match or . We set the default value to temporarily when creating the context; the intended values will be assigned to the provider.\n\nNext, we create the component , which provides the context to the component consumers. Here, we initialize the state with some data to have to work:\n\nThe function will create a new to-do based on the interface and then append the object to the array of to-dos. The next function, , will look for the ID of the to-do passed as a parameter in the array of to-dos and then update it:\n\nNext, we pass the values to the context to make them consumable for the components:\n\nWith this, we are now able to consume the context. So, let’s create the components in the next section.\n\nThe Hook is a crucial tool in React development for efficient state management and data transfer between components. It enables components to access React context values without passing props through intermediary components.\n\nWhen used with TypeScript, the Hook adds an extra layer of type safety, ensuring correct types are used throughout the application. The Hook is part of the React Hooks API and consumes values from the React Context, returning the current context value for that context. In the next section, we will see how to import and use the Hook in our component.\n\nCreating the components and consuming the context\n\nBelow, we have a form component that allows us to handle the data entered by the user using the Hook. Once we get the form data, we use the function, pulled from the context object, to add a new to-do:\n\nNote that I use typecasting on the Hook to prevent TypeScript from throwing errors because the context will be at the beginning:\n\nAs you can see here, we have a presentational component that shows a single to-do. It receives the object and the function to update it as parameters that need to match the type defined above:\n\nThis component shows the list of to-dos when the page loads. It pulls the and the function from the to-do context. Next, we loop through the array and pass the object we want to display to the component.\n\nFrom this step onward, we will be able to provide the to-do context in the file to finish building the app. So, let’s use the context provider in the next part.\n\nHere, we import the component that wraps the consumers of the to-do context. That said, we can now access the array and the function to add or update a to-do using the Hook in other components.\n\nWith this, we can now open the project on the terminal and run either of the following commands:\n\nIf everything works, you’ll be able to see this in the browser:\n\n\n\nWhen managing complex shared states within React Context, combining the Hook with TypeScript helps manage the state at a higher level and share it across components, enhancing code robustness and developer experiences.\n\nThe benefits include type safety, code auto-completion, and refactoring support. Using the Hook also helps centralize state modifications and ensures a predictable state transition.\n\nWe’ll rewrite our simple to-do application but this time, we’ll use the context reducer with TypeScript. First, we will start by defining action types for the reducer:\n\nThe next step is to create a reducer function that will handle state changes based on dispatched actions. In this case, actions are either adding a new or updating an existing todo’s status:\n\nNow, in the , let’s provide it with an initial state and the reducer function:\n\nNow our React application is configured with a context reducer using TypeScript, ensuring type safety and a structured approach to managing global state. Let’s proceed to consume the context in our components.\n\nUpdate the code in the file with the code below:\n\nIn this example, the Hook is used to get the dispatch function from the . The component then uses the function to provide the functionality to add new todos.\n\nUpdate the code in file with the code below:\n\nHere the component receives the object and updates it as parameters that must match the defined type:\n\nWe display the list of and update the to-do using the function we pull out from the .\n\nIn your file, ensure it is wrapped with the to be able to access the array and the function to add or update a to-do using the Hook in other components:\n\nNow run the development server using or , and we will see that everything works the same way in our previous example without using the context reducer.\n\nIn this section, we’ll take another look at one more application of the Context API, theming:\n\nWe create the types necessary for implementing theming: specifies the possible theme modes and specifies the properties that will be available in the theme context as we consume it.\n\nNext, we create a file that exports the raw theme context and its provider:\n\nAfter creating the context, we create a component that will both consume it and toggle the theme on the app:\n\nWith ready, we can now import it into and test it out:\n\nOnce the attribute is modified by the change handler of the select element, the prewritten CSS file takes care of the rest.\n\nDespite its many advantages, developers often face challenges when using React Context with TypeScript.\n\nTypeScript can struggle to correctly infer types, especially with complex structures or nested contexts. To improve type safety, define types explicitly for context values or use the keyword for type assertion:\n\nIn situations where the default context value depends on other variables or cannot be determined during context creation, it is necessary to assign / as the default value or TypeScript will throw type errors.\n\nThe problem can be resolved by defining the context type as / or using optional chaining or non-null assertions for safe access:\n\nAnother way to address this issue is to use a helper function:\n\nThe function uses the Hook to get the current value of the . If it’s or , it throws an error, indicating the need to use the function within the .\n\nIf it’s available, it returns it, ensuring the consuming component receives the context value and TypeScript can infer the correct types:\n\nNow, and have the correct types and / issues are handled.\n\nIt can be difficult to ensure type safety in reducer functions, particularly when working with complex state structures.\n\nUsing discriminated unions to manage various action circumstances and establish clear and exact definitions for action types guarantees type safety in the reducer and aids TypeScript with appropriately interpreting types:\n\nThe example shows that two components ( and ) use the same context ( ) to access a counter value. The component renders both components, but when the counter is incremented, both re-render, a common issue with excessive context usage, potentially causing performance issues.\n\nTo address this, use judiciously for global or deeply shared data, consider alternative state management solutions like Redux, or optimize context updates using memoization techniques:\n\noptimizes components by preventing unnecessary re-renders when props remain unchanged, thereby mitigating performance issues due to excessive context updates.\n\nConditional fetching in is a pattern where you retrieve data or access a value from a context only under certain conditions. This approach helps avoid unnecessary computations, rendering, or accessing values from the context when they are not needed:\n\nFrom the code above, the value is retrieved only when the variable is true, which helps avoid unnecessary access to the context value.\n\nReact’s is a context property used in class components to access context values without the need for the component. By assigning a context object to the property, React makes the current value of the context accessible through the property within the class. This helps avoid the nested renders required when using the component.\n\nTo demonstrate how to use , let’s create a context object that will hold the global data. To do this, inside the folder, create and add the following code:\n\nIn your class component, to access the context data, you need to import the context state object and assign it to the static API. Then, the context data can be accessed using the property, as used in the component below:\n\nIn your main component, you can pass data to class using the code below:\n\nIn this guide, we explored how to effectively use React Context with TypeScript by building a demo to-do app. We covered setting up the app, creating types, establishing context, and implementing components. Additionally, we addressed common TypeScript issues in React Context, such as handling null or undefined values, ensuring reducer function type safety, and avoiding context overuse to maintain performance."
    },
    {
        "link": "https://dhiwise.com/post/a-beginner-guide-to-using-react-context-with-typescript",
        "document": "Majorly busy listening to songs, scrolling Reddit and reading other’s articles. And yeah, also a senior frontend engineer with 4+ years of experience, crafting performant and stunning UI using React, Next.js, JavaScript, TailwindCSS, TypeScript.\n\nReact's Context API is a powerful feature for effectively propagating data through component trees without manually passing props down at every level. In a TypeScript environment, React Context ensures type safety, providing developers a robust way to manage state across many components.\n\nTypeScript, a superset of JavaScript, adds static types to the language. Combined with React Context , it allows for defining the shape of the context value, which can prevent type errors and enhance code quality and maintainability.\n\nIn this blog, we will explore creating and using React Context with TypeScript, ensuring that our context is correctly typed and our components receive the right data.\n\nUnderstanding the Basics of Context in React and TypeScript\n\nBefore diving into the implementation, it's crucial to understand what context is and why it's beneficial in a React application. Context provides a way to share values, like user authentication, themes, or a preferred language, between components without explicitly passing a prop through every level of the tree.\n\nIn TypeScript, context is not just about passing data but also about ensuring that the data passed is of the correct type. This is where TypeScript shines, as it allows you to define the structure of the data you expect to be present in the context, thus avoiding potential runtime errors and making the developer experience much safer and more predictable.\n\nCreating a New Context with TypeScript in React\n\nTo create a new context in React with TypeScript, you start by importing the necessary functions from React and defining the shape of the context using interfaces or types.\n\nIn the above example, we define an interface UserContextType that specifies the structure of our context value. We then use the React.createContext function to create a new context, passing the default value as null. The generic type UserContextType | null ensures that the context can either be of UserContextType or null, providing a way to handle the absence of a value.\n\nOnce the context is created, we need to define a provider component that will wrap the part of our component tree that needs access to the context value. The provider component holds the state and passes it down to the consuming components.\n\nIn this code snippet, we create a UserProvider component that uses the useState hook to manage the user state. The updateUser function is a part of the state and is used to update the user's name and age. The UserContext.Provider component receives the user state as its value prop, making it available to any child components.\n\nUsing the useContext Hook in TypeScript to Consume Context\n\nTo access the context value within a component, React provides the useContext hook . In TypeScript, you can use this hook with the context object you've created to ensure that the consumed context is of the correct type.\n\nIn the UserProfile component, we use the useContext hook with UserContext to access the context value. We also include a runtime check to ensure that userContext is not null, throwing an error if the component is used outside of a UserProvider. This pattern is a safeguard to ensure the context is used correctly within the component tree.\n\nWhen using TypeScript with React Context, defining the types or interfaces for the context value is important to ensure type safety. This helps in catching potential bugs during development time rather than at runtime.\n\nHere, we define a ThemeContextType interface with a theme property and a toggleTheme method. The context is then created with the possibility of being null if no provider is found up the component tree.\n\nSharing Data Across Components with Context and TypeScript\n\nReact Context with TypeScript is particularly useful when you need to share data across different levels of components. It prevents prop drilling and makes your code cleaner and more maintainable.\n\nIn the App component, we wrap the UserProfile component with UserProvider. This makes the user context available to UserProfile and any other components nested within UserProvider.\n\nProp drilling is a common issue in React applications where you need to pass props through multiple levels of components that do not necessarily need the data. Context API , combined with TypeScript, offers a solution to this problem by allowing you to access the data at any level without passing it through every single level.\n\nUsing the useContext hook, DeeplyNestedComponent can access the UserContext directly, eliminating the need to pass the user data down through props from parent to child components.\n\nImplementing a Theme Context Example with TypeScript in React\n\nTo illustrate the use of React Context with TypeScript, let's implement a simple theme context that allows components to access and toggle the current theme.\n\nIn this example, we define a ThemeContextType interface and create a ThemeContext with a default value. The ThemeProvider component manages the theme state and provides a toggleTheme function to switch between light and dark themes.\n\nBest Practices for Using React Context with TypeScript\n\nWhen using React Context with TypeScript, there are several best practices to follow:\n• Always define the shape of your context data using interfaces or types to ensure type safety.\n• Provide a default value for your context that matches the defined type.\n• Use the useContext hook to access the context value in functional components.\n• Ensure that context-consuming components are wrapped with the appropriate provider.\n• Consider using custom hooks to abstract and simplify context usage.\n\nBy adhering to these best practices, you can leverage the full power of TypeScript to create more reliable and maintainable React applications.\n\nCommon Pitfalls and How to Avoid Them When Using Context in TypeScript\n\nWhile React Context with TypeScript is a powerful combination, there are some common pitfalls to be aware of:\n• Forgetting to wrap components with the provider: This will result in null context, which can lead to runtime errors. Always check if the context value is null before using it.\n• Overusing context: Context is not a silver bullet for state management. Use it judiciously for global state that many components need to access.\n• Mutating context directly: Always use the provided setter functions to update the context value to avoid unpredictable behavior.\n\nBy understanding these pitfalls and how to avoid them, you can create robust applications using React Context with TypeScript.\n\nReact Context API, when used with TypeScript, provides a scalable way to manage state across your application while ensuring type safety. By following the outlined steps and best practices, you can create a context that is easy to maintain and prevents common type-related bugs. Whether you're managing user data, application themes, or other global state, React Context with TypeScript is an invaluable tool in your development arsenal.\n\n**Ready to take your React development skills to the next level? **\n\nDhiWise the web and mobile app development platform streamlines application development by supporting popular technologies such as React, Next.js, HTML and so on. With it you can convert Figma design to code, cutomize UI and styling, and integrate API to app and more. Leverage the power of DhiWise and React Context with TypeScript effectively to build robust and maintainable applications. Sign up now!\n\nShort on time? Speed things up with DhiWise!\n\nTired of manually designing screens, coding on weekends, and technical debt? Let DhiWise handle it for you!\n\nYou can build an e-commerce store, healthcare app, portfolio, blogging website, social media or admin panel right away. Use our library of 40+ pre-built free templates to create your first application using DhiWise."
    },
    {
        "link": "https://medium.com/@nitinjha5121/mastering-react-context-with-typescript-a-comprehensive-tutorial-5bab5ef48a3b",
        "document": "In this article, I will guide you through the process of creating a more readable, easily understandable, and best-practice-oriented React context using TypeScript. React context provides a way to manage and share state data across components without passing props through every level of the component tree.\n\nTo begin, let’s create a context using the React Context API with a default value of .\n\nYou might be wondering why we set the default value of the context to . This choice has a purpose that will become clear shortly.\n\nHere’s how we can structure our context provider:\n\nIn the provided code snippet, you’ll notice our use of . The purpose here is to cleverly store the context value, ensuring it doesn't alter with each render. This process prevents unnecessary changes when the context is re-evaluated.\n\nLet’s break this down further: Imagine your application’s display shifts due to internal updates within the context provider. In such cases, reestablishing the context object makes sense. However, consider instances where the updates originate from external factors, like a parent component’s state change. In these scenarios, creating a new object every time would be excessive. This optimized approach prevents unnecessary object recreation during such non-provider-triggered renders.\n\nIt’s worth addressing a potential query that might arise: why should one be concerned about object recreation during each render? Indeed, in many cases, this might not seem like a substantial concern. However, delving deeper, this practice can lead to unforeseen bugs. A pertinent example emerges when the context’s value object is employed as a dependency within a hook. By maintaining the object reference consistency, we circumvent potential anomalies arising from inadvertent re-renders. This strategic maneuver ultimately contributes to the robustness and stability of our codebase.\n\nTo consume the context, we’ll create a custom hook. This approach enhances modularity and code readability.\n\nIn this snippet, we’re creating a custom hook named to encapsulate the consumption of the context. By doing so, we achieve two important goals:\n• Modularity: The custom hook abstracts the details of context consumption, making it easier to manage and reuse. If you need to change how the context is consumed across your application, you can do so in one central place.\n• Clarity and Readability: Using instead of the generic provides more descriptive semantics, making the code easier to understand. Anyone working on the codebase can quickly grasp the purpose of the context consumption.\n\nHere’s the implementation of the function that the hook relies on:\n\nThis function adds an extra layer of error handling. If the context is not properly provided by a corresponding provider, a clear and informative error message will be thrown, guiding developers to resolve the issue effectively.\n\nBy following these guidelines, you can create a well-structured React context with TypeScript that is both efficient and easy to maintain. Properly setting up context providers, defining types, and consuming the context through custom hooks will contribute to a more robust and scalable application."
    },
    {
        "link": "https://stackoverflow.com/questions/77217290/best-way-to-use-react-context-with-usestate-in-typescript",
        "document": "I agree, having to define (and maintain) default state is annoying (especially when there are several state values). I usually take the following approach:\n\nNote: much of this boilerplate can be abstracted into a helper/factory function (much like @Andrew's ) but we found that made it more difficult for developers to debug. Indeed, when you yourself revisit the code in 6-months time, it can be hard to figure out what's going on. So I like this explicit approach better."
    }
]