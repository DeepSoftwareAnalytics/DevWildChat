[
    {
        "link": "https://docs.oracle.com/javase/tutorial/jdbc/basics/prepared.html",
        "document": "The Java Tutorials have been written for JDK 8. Examples and practices described in this page don't take advantage of improvements introduced in later releases and might use technology no longer available. See Dev.java for updated tutorials taking advantage of the latest releases. See Java Language Changes for a summary of updated language features in Java SE 9 and subsequent releases. See JDK Release Notes for information about new features, enhancements, and removed or deprecated options for all JDK releases.\n\nThis page covers the following topics:\n\nSometimes it is more convenient to use a object for sending SQL statements to the database. This special type of statement is derived from the more general class, , that you already know.\n\nIf you want to execute a object many times, it usually reduces execution time to use a object instead.\n\nThe main feature of a object is that, unlike a object, it is given a SQL statement when it is created. The advantage to this is that in most cases, this SQL statement is sent to the DBMS right away, where it is compiled. As a result, the object contains not just a SQL statement, but a SQL statement that has been precompiled. This means that when the is executed, the DBMS can just run the SQL statement without having to compile it first.\n\nAlthough you can use objects for SQL statements with no parameters, you probably use them most often for SQL statements that take parameters. The advantage of using SQL statements that take parameters is that you can use the same statement and supply it with different values each time you execute it. Examples of this are in the following sections.\n\nHowever, the most important advantage of prepared statements is that they help prevent SQL injection attacks. SQL injection is a technique to maliciously exploit applications that use client-supplied data in SQL statements. Attackers trick the SQL engine into executing unintended commands by supplying specially crafted string input, thereby gaining unauthorized access to a database to view or manipulate restricted data. SQL injection techniques all exploit a single vulnerability in the application: Incorrectly validated or nonvalidated string literals are concatenated into a dynamically built SQL statement and interpreted as code by the SQL engine. Prepared statements always treat client-supplied data as content of a parameter and never as a part of an SQL statement. See the section SQL Injection in Database PL/SQL Language Reference, part of Oracle Database documentation, for more information.\n\nThe following method, , stores the number of pounds of coffee sold in the current week in the column for each type of coffee, and updates the total number of pounds of coffee sold in the column for each type of coffee:\n\nThe following creates a object that takes two input parameters:\n\nYou must supply values in place of the question mark placeholders (if there are any) before you can execute a object. Do this by calling one of the setter methods defined in the class. The following statements supply the two question mark placeholders in the named :\n\nThe first argument for each of these setter methods specifies the question mark placeholder. In this example, specifies the first placeholder and specifies the second placeholder.\n\nAfter a parameter has been set with a value, it retains that value until it is reset to another value, or the method is called. Using the object , the following code fragment illustrates reusing a prepared statement after resetting the value of one of its parameters and leaving the other one the same:\n\nYou can often make coding easier by using a loop or a loop to set values for input parameters.\n\nThe method uses a for-each loop to repeatedly set values in the objects and :\n\nThe method takes one argument, . Each element in the argument contains the name of one type of coffee and the number of pounds of that type of coffee sold during the current week. The for-each loop iterates through each element of the argument and sets the appropriate question mark placeholders in and .\n\nAs with objects, to execute a object, call an execute statement: if the query returns only one (such as a SQL statement), if the query does not return a (such as an SQL statement), or if the query might return more than one object. Both objects in contain SQL statements, so both are executed by calling :\n\nNo arguments are supplied to when they are used to execute and ; both objects already contain the SQL statement to be executed.\n\nNote: At the beginning of , the auto-commit mode is set to false:\n\nConsequently, no SQL statements are committed until the method is called. For more information about the auto-commit mode, see Transactions.\n\nWhereas returns a object containing the results of the query sent to the DBMS, the return value for is an value that indicates how many rows of a table were updated. For instance, the following code shows the return value of being assigned to the variable :\n\nThe table is updated; the value 50 replaces the value in the column in the row for . That update affects one row in the table, so is equal to 1.\n\nWhen the method is used to execute a DDL (data definition language) statement, such as in creating a table, it returns the value of 0. Consequently, in the following code fragment, which executes the DDL statement used to create the table , is assigned a value of 0:\n\nNote that when the return value for is 0, it can mean one of two things:\n• The statement executed was an update statement that affected zero rows."
    },
    {
        "link": "https://stackoverflow.com/questions/3385177/best-practices-with-preparedstatements-when-to-and-when-not-to",
        "document": "I recently have began using prepared statements again in a web application, and I know that it is discouraged to use prepared statements for all the transactions. What I do not know is when it is best to use prepared statements or not.\n\nI have read of when to use and not use them, but none of the examples really tell best practice of using them.\n\nI am trying to figure out which database calls I should be using them for and which ones I should not.\n\nFor Example the MySQL website mentions it in \"When to use prepared statements\" on the following page Prepared Statements-MySQL"
    },
    {
        "link": "https://geeksforgeeks.org/how-to-use-preparedstatement-in-java",
        "document": ""
    },
    {
        "link": "https://stackoverflow.com/questions/60388186/how-to-use-preparedstatement-with-jdbc",
        "document": "You create the but you don't use it.\n\nA prepared statement is there to e.g. insert different values into a table multiple times.\n\nYou create the once like you would execute a normal Statement and include instead of the values that differ.\n\nIf you want to execute it, you have to set the values (the s will be replaced with them) by using the methods and then execute it with .\n\nAs pointed out in the comments of the question, the SQL code is not valid. The sql code prepared statement is just like the sql code of a regular statement but the values that change all the time are replaced by .\n\nThe SQL code of the prepared statement would be something like that:\n\nIf you want to use the , you could set the values like that:\n\nNote that (as I already said) you should create the once and not every time you execute the method and in that method, you should just call the methods and the method.\n\nThe (and the object) should be closed when you don't need it anymore.\n\nAlso, as @TT. suggests in the comments, you should specify the columns in an statement. It would be something like"
    },
    {
        "link": "https://coderpad.io/blog/development/using-preparedstatement-in-jdbc-with-examples",
        "document": "The JD®BC (Java database connectivity) API defines a standard interface for Java applications to connect to different relational database (RDBMS) implementations. Most popular relational database vendors provide JDBC-compliant drivers for their databases.\n\nThe JDBC API provides the object to execute queries, updates, and DDL statements on data in a database. The is a subclass of` that provides better security, portability across vendors, and performance.\n\nThe prepared in the name comes from the fact that it’s prepared/compiled initially and then reused rather than having to be compiled for each execution.\n\nThis post will explain why and how to work with .\n\nSince a is a subclass of , it can do what a can do, plus more.\n\nThe fact that the is pre-compiled is transparent to its users. Where it differs in usage is in its ability to specify parameters.\n\nThe JDBC driver handles these parameters and thus, the handling is naturally compatible with the database we’re using. This leads to some benefits, as we will see later.\n\nBelow is an example of using the with two parameters:\n\nAs shown above, we’re inserting records into the table. In the SQL command string, we denote the places where a parameter should be with a question mark. When specifying parameter values, we identify a parameter by its position in the SQL command.\n\nThe starting position is 1 instead of the usual 0. If we use the same parameter value in multiple positions, we’ll have to set it for each position.\n\nThe first parameter is an integer, so we use the method. The second is a string, so we use . Using the strongly typed methods ensures that we won’t pass the wrong type of parameter by mistake.\n\nBut if we were getting the parameters dynamically, say, from an array or collection, it would be cumbersome to check the type of each parameter and then use the corresponding set method. The method is helpful here. Using it, we can set a parameter of any supported type.\n\nA PreparedStatement object is not we should not use the same instance concurrently from multiple threads.\n\nWe can only use parameters where we would use values. If we try to use parameters to build other parts of the SQL command, it won’t work. For example, what we see here would fail with an :\n\nHere, we’re trying to provide the table name as a parameter. However, this isn’t allowed, nor would any other syntax part be, like column names, by, etc.\n\nA provides better security against certain hacking attacks compared with its parent, the Statement. The object executes a string command. If it needs to use some parameters, we must concatenate them as strings with the SQL command. This creates a risk of the command being changed to something else using the parameters.\n\nConsider the query below using string concatenation to validate a user’s login:\n\nHere, is a string that the application’s user has provided. If a malicious user were to enter usrName as (note the single quotes used), the query string now becomes\n\nThis SQL command now circumvents the check for , since the added OR condition is always true. If the database allows us to run multiple commands in a go (separated by a semicolon, for example), then a hacker could append a destructive command like delete or drop as well. This type of hacking attack using injected parameters to alter the SQL command is called an SQL injection attack.\n\nNow, let’s try using a instead. Using , the above code would become\n\nWhat’s different here? The JDBC driver is handling the parameters. It’ll send the parameters to the database as variables bound to the pre-compiled SQL command. The database will escape the special character within them if needed. For example, it usually escapes a single quote with an additional single quote. Thus, the malicious value remains a value, and it cannot change the SQL command.\n\nNote that we can use a and escape the values ourselves before concatenating, but the escaping syntax can differ from database to database and hence, it’s best to let the JDBC driver handle it.\n\nAlso, there are still other advantages to using a . Read on.\n\nPortability and ease of use\n\nWhen we use string concatenation to inject parameters into the SQL command, we have to format and escape the values too. Also, this part could be database specific, making our code less portable across different database implementations.\n\nWe’ve seen an example of this in the SQL injection section above. Parameters in PreparedStatement make our life easier and keep the code portable since the JDBC driver handles them.\n\nLet’s see another example using dates. Let’s assume the user has entered a date and wants to filter records by that date. If we were building the query as a string, then we would need to convert the date into a string:\n\nWhat should be the format of the date string? For example, should it be or , etc.?\n\nThis would work only if the format of matches the default date format for the database. The default date format can vary from one database instance to another, so we cannot be sure about it.\n\nWe could use some database function like that will parse the with the given format and convert it back into the date.\n\nHowever, the syntax of functions like is specific to a database vendor; others might not have the same name or parameters. Some functions are supported by the JDBC spec using the keyword, but many JDBC drivers don’t have implementations for these.\n\nSo, it’s to the rescue:\n\nAll we need to do is pass the date as or to the . There’s no worrying about escaping or formatting or portability.\n\nWe mentioned at the start that the SQL command used in a PreparedStatement is pre-compiled or prepared initially and then reused.\n\nWhat does pre-compile mean, and who does it? When we run an SQL command on the database, the database will first validate, parse, and build an execution plan to run it. These steps come under pre-compiling.\n\nWhen the JDBC driver creates a prepared statement, it will ask the database to pre-compile that SQL command. Then, the database will store the pre-compiled command in a cache for the current database connection. If the same SQL command is to be run multiple times, using the pre-compiled version is better for performance since the compilation part has to be done only once.\n\nThe database has a limited cache for pre-compiled SQL commands and hence, we cannot have too many of them. Defining parameters helps make the command reusable and therefore reduces the number of distinct commands.\n\nIf the parameters weren’t separate, the same command with different parameters would each become a separate command.\n\nIn the above examples, the first two SQL commands are distinct since we didn’t define the parameters separately. Whereas, if we had used a PreparedStatement as in the third, then they could have used the same SQL command.\n\nUsing the same multiple times in the same database session/connection will be better for performance. Each time, we need to set the parameters and execute the . For example, we could use it to repeatedly insert data into a table\n\nor we could do the set parameters and inside a loop. This is still not the best solution since each will mean a round trip to the database.\n\nWe can send n number of statements in a single batch to the database, where n is up to us to decide. This will reduce the round trips and greatly improve performance. Below is an example using batching.\n\nHere, we call set parameters and for each row in the loop. The will store the current parameters for later execution.\n\nWhen the counter is a multiple of 100, we’ll execute the batched rows in one go. In our case, that means 100 at a time.\n\nreturns an array of integers corresponding to the number of rows affected by each statement in the batch. The SQL command needs to be sent to the database only once for pre-compilation. The batch needs to send a reference to the pre-compiled command and the parameters for all the rows in the batch.\n\nIn this post, we’ve seen when and why we should use PreparedStatements, along with examples using code.\n\nPreparedStatements are the preferred way to execute SQL commands using the JDBC API since they offer better security, ease of use, portability, and performance.\n\nThis post was written by Manoj Mokashi. Manoj has more than 25 years of experience as a developer, mostly on java, web technologies, and databases. He’s also worked on PHP, Python, Spark, AI/ML, and Solr and he really enjoys learning new things."
    },
    {
        "link": "https://docs.oracle.com/cd/E13222_01/wls/docs92/webserv/annotations.html",
        "document": "The following sections provide reference documentation about standard (JSR-181) and WebLogic-specific JWS annotations:\n\nThe WebLogic Web Services programming model uses the new JDK 5.0 metadata annotations feature (specified by JSR-175). In this programming model, you create an annotated Java file and then use Ant tasks to compile the file into the Java source code and generate all the associated artifacts.\n\nThe Java Web Service (JWS) annotated file is the core of your Web Service. It contains the Java code that determines how your Web Service behaves. A JWS file is an ordinary Java class file that uses annotations to specify the shape and characteristics of the Web Service. The JWS annotations you can use in a JWS file include the standard ones defined by the Web Services Metadata for the Java Platform specification (JSR-181) as well as a set of WebLogic-specific ones. This chapter provides reference information about both of these set of annotations.\n\nYou can target a JWS annotation at either the class-, method- or parameter-level in a JWS file. Some annotations can be targeted at more than one level, such as that can be targeted at both the class- and method-level. The documentation in this section lists the level to which you can target each annotation.\n\nThe following example shows a simple JWS file that uses both standard JSR-181 and WebLogic-specific JWS annotations, shown in bold:\n\nThe Web Services Metadata for the Java Platform (JSR-181) specification defines the standard annotations you can use in your JWS file to specify the shape and behavior of your Web Service. This section briefly describes each annotation, along with its attributes. See Programming the JWS File, for examples. For more detailed information about the annotations, such as the Java annotation type definition and additional examples, see the specification.\n\nThis section documents the following standard JWS annotations:\n\nSpecifies that the method is exposed as a public operation of the Web Service. You must explicitly use this annotation to expose a method; if you do not specify this annotation, the method by default is not exposed.\n\nSpecifies that the method has only input parameters, but does not return a value. This annotation must be used only in conjunction with the annotation.\n\nIt is an error to use this annotation on a method that returns anything other than , takes a class as an input parameter, or throws checked exceptions.\n\nThis annotation does not have any attributes.\n\nCustomizes the mapping between operation input parameters of the Web Service and elements of the generated WSDL file. Also used to specify the behavior of the parameter.\n\nCustomizes the mapping between the Web Service operation return value and the corresponding element of the generated WSDL file.\n\nAssociates a Web Service with an external file that contains the configuration of a handler chain. The configuration includes the list of handlers in the chain, the order in which they execute, the initialization parameters, and so on.\n\nUse the annotation, rather than the annotation, in your JWS file if:\n\nIt is an error to combine this annotation with the annotation.\n\nFor the XML Schema of the external configuration file, additional information about creating it, and additional examples, see the Web Services Metadata for the Java Platform specification.\n\nSpecifies the mapping of the Web Service onto the SOAP message protocol.\n\nTarget: None; this annotation can be used only inside of a array.\n\nSpecifies a particular SOAP message handler in a array. The annotation includes attributes to specify the class name of the handler, the initialization parameters, list of SOAP headers processed by the handler, and so on.\n\nTarget: None; this annotation can be used only as a value to the attribute of the annotation.\n\nUse this annotation in the attribute of the annotation to specify the array of parameters (name/value pairs) that are passed to a handler class during initialization.\n\nSpecifies an array of SOAP message handlers that execute before and after the operations of a Web Service. Use the annotation to specify a particular handler. Because you specify the list of handlers within the JWS file itself, the configuration of the handler chain is embedded within the Web Service.\n\nUse the annotation, rather than , if:\n\nThe annotation is an array of types. The handlers run in the order in which they appear in the annotation, starting with the first handler in the array.\n\nThis annotation does not have any attributes.\n\nWebLogic Web Services define a set of JWS annotations that you can use to specify behavior and features in addition to the standard JSR-181 JWS annotations. In particular, the WebLogic-specific annotations are:\n\nSpecifies the method that handles a potential failure when the main JWS file invokes an operation of another Web Service asynchronously.\n\nWhen you invoke, from within a JWS file, a Web Service operation asynchronously, the response (or exception, in the case of a failure) does not return immediately after the operation invocation, but rather, at some later point in time. Because the operation invocation did not wait for a response, a separate method in the JWS file must handle the response when it does finally return; similarly, another method must handle a potential failure. Use the annotation to specify the method in the JWS file that will handle the potential failure of an asynchronous operation invocation.\n\nThe annotation takes two parameters: the name of the JAX-RPC stub for the Web Service you are invoking and the name of the operation that you are invoking asynchronously. The JAX-RPC stub is the one that has been annotation with the annotation.\n\nThe method that handles the asynchronous failure must follow these guidelines:\n\nWithin the method itself you can get more information about the method failure from the context, and query the specific type of exception and act accordingly.\n\nTypically, you always use the annotation to explicitly specify the method that handles asynchronous operation failures. The only time you would not use this annotation is if you want a single method to handle failures for two or more stubs that invoke different Web Services. In this case, although the stubs connect to different Web Services, each Web Service must have a similarly named method, because the Web Services runtime relies on the name of the method ( ) to determine how to handle the asynchronous failure, rather than the annotation. However, if you always want a one-to-one correspondence between a stub and the method that handles an asynchronous failure from one of the operations, then BEA recommends that you explicitly use .\n\nSee Invoking a Web Service Using Asynchronous Request-Response for detailed information and examples of using this annotation.\n\nThe following sample snippet shows how to use the annotation in a JWS file that invokes the operation of another Web Service asynchronously; only the relevant Java code is included:\n\nThe example shows a JAX-RPC stub called , used to invoke the Web Service located at . The operation is invoked asynchronously, and any exception from this invocation is handled by the method, as specified by the annotation.\n\nSpecifies the method that handles the response when the main JWS file invokes an operation of another Web Service asynchronously.\n\nWhen you invoke, from within a JWS file, a Web Service operation asynchronously, the response does not return immediately after the operation invocation, but rather, at some later point in time. Because the operation invocation did not wait for a response, a separate method in the JWS file must handle the response when it does finally return. Use the annotation to specify the method in the JWS file that will handle the response of an asynchronous operation invocation.\n\nThe annotation takes two parameters: the name of the JAX-RPC stub for the Web Service you are invoking and the name of the operation that you are invoking asynchronously. The JAX-RPC stub is the one that has been annotation with the annotation.\n\nThe method that handles the asynchronous response must follow these guidelines:\n\nWithin the asynchronous-response method itself you add the code to handle the response. You can also get more information about the method invocation from the context.\n\nTypically, you always use the annotation to explicitly specify the method that handles asynchronous operation responses. The only time you would not use this annotation is if you want a single method to handle the response for two or more stubs that invoke different Web Services. In this case, although the stubs connect to different Web Services, each Web Service must have a similarly named method, because the Web Services runtime relies on the name of the method ( ) to determine how to handle the asynchronous response, rather than the annotation. However, if you always want a one-to-one correspondence between a stub and the method that handles an asynchronous response from one of the operations, then BEA recommends that you explicitly use .\n\nSee Invoking a Web Service Using Asynchronous Request-Response for detailed information and examples of using this annotation.\n\nThe following sample snippet shows how to use the annotation in a JWS file that invokes the operation of another Web Service asynchronously; only the relevant Java code is included:\n\nThe example shows a JAX-RPC stub called , used to invoke the Web Service located at . The operation is invoked asynchronously, and the response from this invocation is handled by the method, as specified by the annotation.\n\nSpecifies whether the Web Service uses version 1.1 or 1.2 of the Simple Object Access Protocol (SOAP) implementation when accepting or sending SOAP messages. By default, WebLogic Web Services use SOAP 1.1.\n\nThe following example shows how to specify SOAP 1.2; only the relevant code is shown:\n\nSpecifies the JNDI name of the JMS queue to which WebLogic Server:\n\nWhen used with buffered Web Services, you use this annotation in conjunction with , which specifies the methods of a JWS that are buffered. When used with reliable Web Services, you use this annotation in conjunction with , which specifies the reliable messaging WS-Policy file associated with the Web Service.\n\nIf you have enabled buffering or reliable messaging for a Web Service, but do not specify the annotation, WebLogic Server uses the default Web Services JMS queue ( ) to store buffered or reliable operation invocations. This JMS queue is also the default queue for the JMS transport features. It is assumed that you have already created this JMS queue if you intend on using it for any of these features.\n\nSee Creating Buffered Web Services and Using Web Service Reliable Messaging for detailed information and examples of creating buffered or reliable Web Services.\n\nThe following example shows a code snippet from a JWS file in which the public operation is buffered and the JMS queue to which WebLogic Server queues the operation invocation is called ; only the relevant Java code is shown:\n\nSpecifies that the annotated variable is a callback, which means that you can use the variable to send callback events back to the client Web Service that invoked an operation of the target Web Service.\n\nYou specify the annotation in the target Web Service so that it can call back to the client Web Service. The data type of the annotated variable is the callback interface.\n\nThe callback feature works between two WebLogic Web Services. When you program the feature, however, you create the following three Java files:\n\nSee Using Callbacks to Notify Clients of Events for additional overview and procedural information about programming callbacks.\n\nThe annotation does not have any attributes.\n\nThe following example shows a very simple target Web Service in which a variable called is annotated with the annotation. The data type of the variable is ; this means a callback Web Service must exist with this name. After the variable is injected with the callback information, you can invoke the callback methods defined in ; in the example, the callback method is .\n\nThe text in bold shows the relevant code:\n\nSpecifies the method in the client Web Service that handles the messages it receives from the callback Web Service. Use the attributes to link the callback message handler methods in the client Web Service with the callback method in the callback interface.\n\nThe callback feature works between two WebLogic Web Services. When you program the feature, however, you create the following three Java files:\n\nSee Using Callbacks to Notify Clients of Events for additional overview and procedural information about programming callbacks.\n\nThe following example shows a method of a client Web Service annotated with the annotation. The attributes show that a variable called must have previously been injected with JAX-RPC stub information and that the annotated method will handle messages received from a callback operation called .\n\nSpecifies that the JWS file is actually a Java interface that describes a callback Web Service. This annotation is analogous to the , but specific to callbacks and with a reduced set of attributes.\n\nThe callback feature works between two WebLogic Web Services. When you program the feature, however, you create the following three Java files:\n\nUse the annotation to specify that the Java file is a callback interface file.\n\nWhen you program the callback interface, you specify one or more callback methods; as with standard non-callback Web Services, you annotate these methods with the annotation to specify that they are Web Service operations. However, contrary to non-callback methods, you never write the actual implementation code for these callback methods; rather, when you compile the client Web Service with the Ant task, the task automatically creates an implementation of the interface and packages it into a Web Service. This generated implementation specifies that the callback methods all do the same thing: send a message from the target Web Service that invokes the callback method back to the client Web Service.\n\nSee Using Callbacks to Notify Clients of Events for additional overview and procedural information about programming callbacks.\n\nThe following example shows a very simple callback interface. The resulting callback Web Service has one callback method, .\n\nSpecifies that the annotated field provide access to the runtime context of the Web Service.\n\nWhen a client application invokes a WebLogic Web Service that was implemented with a JWS file, WebLogic Server automatically creates a context that the Web Service can use to access, and sometimes change, runtime information about the service. Much of this information is related to conversations, such as whether the current conversation is finished, the current values of the conversational properties, changing conversational properties at runtime, and so on. Some of the information accessible via the context is more generic, such as the protocol that was used to invoke the Web Service (HTTP/S or JMS), the SOAP headers that were in the SOAP message request, and so on. The data type of the annotation field must be , which is a WebLogic Web Service API that includes methods to query the context.\n\nFor additional information about using this annotation, see Accessing Runtime Information about a Web Service Using the JwsContext.\n\nThis annotation does not have any attributes.\n\nThe following snippet of a JWS file shows how to use the annotation; only parts of the file are shown, with relevant code in bold:\n\nSpecifies that a method annotated with the annotation can be invoked as part of a conversation between two WebLogic Web Services or a stand-alone Java client and a conversational Web Service.\n\nThe conversational Web Service typically specifies three methods, each annotated with the annotation that correspond to the start, continue, and finish phases of a conversation. Use the annotation to specify, at the class level, that a Web Service is conversational and to configure properties of the conversation, such as the maximum idle time.\n\nIf the conversation is between two Web Services, the client service uses the annotation to specify the wsdl, service name, and port of the invoked conversational service. In both the service and stand-alone client cases, the client then invokes the start, continue, and finish methods in the appropriate order to conduct a conversation.The only additional requirement to make a Web Service conversational is that it implement .\n\nSee Creating Conversational Web Services for detailed information and examples of using this annotation.\n\nThe following sample snippet shows a JWS file that contains three methods, , , and ) that are annotated with the annotation to specify the start, continue, and finish phases, respectively, of a conversation.\n\nYou are not required to use this annotation to specify that a Web Service is conversational; by simply annotating a single method with the annotation, all the methods of the JWS file are automatically tagged as conversational. Use the class-level annotation only if you want to change some of the conversational behavior or if you want to clearly show at the class level that the JWS if conversational.\n\nIf you do use the annotation in your JWS file, you can specify it without any attributes if their default values suit your needs. However, if you want to change values such as the maximum amount of time that a conversation can remain idle, the maximum age of a conversation, and so on, specify the appropriate attribute.\n\nSee Creating Conversational Web Services for detailed information and examples of using this annotation.\n\nThe following sample snippet shows how to specify that a JWS file implements a conversational Web Service. The maximum amount of time the conversation can be idle is ten minutes, and the maximum age of the conversation, regardless of activity, is one day. The continue and finish phases of the conversation can be executed by a user other than the one that started the conversation; if this happens, then the corresponding methods are run as the new user, not the original user.\n\nSpecifies which public methods of a JWS are buffered. If specified at the class-level, then all public methods are buffered; if you want only a subset of the methods to be buffered, specify the annotation at the appropriate method-level.\n\nWhen a client Web Service invokes a buffered operation of a different WebLogic Web Service, WebLogic Server (hosting the invoked Web Service) puts the invoke message on a JMS queue and the actual invoke is dealt with later on when the WebLogic Server delivers the message from the top of the JMS queue to the Web Service implementation. The client does not need to wait for a response, but rather, continues on with its execution. For this reason, buffered operations (without any additional asynchronous features) can only return and must be marked with the annotation. If you want to buffer an operation that returns a value, you must use asynchronous request-response from the invoking client Web Service. See Invoking a Web Service Using Asynchronous Request-Response for more information.\n\nBuffering works only between two Web Services in which one invokes the buffered operations of the other.\n\nUse the optional attributes of to specify the number of times the JMS queue attempts to invoke the buffered Web Service operation until it is invoked successfully, and the amount of time between attempts.\n\nUse the optional class-level annotation to specify the JMS queue to which the invoke messages are queued. If you do not specify this annotation, the messages are queued to the default Web Service queue, .\n\nSee Creating Buffered Web Services for detailed information and examples for using this annotation.\n\nThe following example shows a code snippet from a JWS file in which the public operation is buffered and the JMS queue to which WebLogic Server queues the operation invocation is called . The WebLogic Server instance that hosts the invoked Web Service tries a maximum of 10 times to deliver the invoke message from the JMS queue to the Web Service implementation, waiting 10 seconds between each retry. Only the relevant Java code is shown in the following snippet:\n\nUse this annotation if you want to attach more than one WS-Policy files to a class or method of a JWS file. If you want to attach just one WS-Policy file, you can use the on its own.\n\nSee Using Web Service Reliable Messaging and Configuring Message-Level Security (Digital Signatures and Encryption) for detailed information and examples of using this annotation.\n\nThis JWS annotation does not have any attributes.\n\nSpecifies that a WS-Policy file, which contains information about digital signatures, encryption, or Web Service reliable messaging, should be applied to the request or response SOAP messages.\n\nThis annotation can be used on its own to apply a single WS-Policy file to a class or method. If you want to apply more than one WS-Policy file to a class or method, use the annotation to group them together.\n\nIf this annotation is specified at the class level, the indicated WS-Policy file or files are applied to every public operation of the Web Service. If the annotation is specified at the method level, then only the corresponding operation will have the WS-Policy file applied.\n\nBy default, WS-Policy files are applied to both the request (inbound) and response (outbound) SOAP messages. You can change this default behavior with the attribute.\n\nAlso by default, the specified WS-Policy file is attached to the generated and published WSDL file of the Web Service so that consumers can view all the WS-Policy requirements of the Web Service. Use the attribute to change this default behavior.\n\nSee Using Web Service Reliable Messaging and Configuring Message-Level Security (Digital Signatures and Encryption) for detailed information and examples of using this annotation.\n\nUse this annotation to configure reliable messaging properties for an operation of a reliable Web Service, such as the number of times WebLogic Server should attempt to deliver the message from the JMS queue to the Web Service implementation, and the amount of time that the server should wait in between retries.\n\nSee Using Web Service Reliable Messaging for detailed information about enabling Web Services reliable messaging for your Web Service.\n\nThe following sample snippet shows how to use the annotation at the method-level to change the default retry count and delay of a reliable operation; only relevant Java code is shown:\n\nSpecifies the method that handles the error that results when a client Web Service invokes a reliable Web Service, but the client does not receive an acknowledgement that the reliable Web Service actually received the message.\n\nThis annotation is relevant only when you implement the Web Service reliable messaging feature; you specify the annotation in the client-side Web Service that invokes a reliable Web Service.\n\nThe method you annotate with the annotation takes a single parameter of data type weblogic.wsee.reliability.ReliabilityErrorContext. You can use this context to get more information about the cause of the error, such as the operation that caused it, the target Web Service, the fault, and so on. The method must return .\n\nThe single attribute of the annotation specifies the variable into which you have previously injected the JAX-RPC stub information of the reliable Web Service that the client Web Service is invoking; you inject this information in a variable using the annotation.\n\nThe following code snippet from a client Web Service that invokes a reliable Web Service shows how to use the annotation; not all code is shown, and the code relevant to this annotation is shown in bold:\n\nIn the example, the variable has been injected with the JAX-RPC stub that corresponds to the Web Service, and it is assumed that at some point in the client Web Service an operation of this stub is invoked. Because the method is annotated with the annotation and is linked with the JAX-RPC stub, the method is invoked if there is a failure in an invoke of the reliable Web Service. The reliable error handling method uses the object to get more details about the cause of the failure.\n\nSpecifies that the annotated variable in the JWS file is a JAX-RPC stub used to invoke another WebLogic Web Service when using the following features:\n\nYou use the reliable messaging and asynchronous request-response features only between two Web Services; this means, for example, that you can invoke a reliable Web Service operation only from within another Web Service, not from a stand-alone client. In the case of reliable messaging, the feature works between any two application servers that implement the WS-ReliableMessaging 1.0 specification. In the case of asynchronous request-response, the feature works only between two WebLogic Server instances.\n\nYou use the annotation in the client Web Service to specify which variable is a JAX-RPC port type for the Web Service described by the attributes. The Enterprise Application that contains the client Web Service must also include the JAX-RPC stubs of the Web Service you are invoking; you generate the stubs with the Ant task.\n\nSee Advanced JWS Programming: Implementing Asynchronous Features, for additional information and examples of using the annotation.\n\nThe following JWS file excerpt shows how to use the annotation in a client Web Service to annotate a field ( ) with the JAX-RPC stubs of the Web Service being invoked (called whose WSDL is at the URL ); only relevant parts of the example are shown:\n\nSpecifies that the WebLogic Web Services runtime use streaming APIs when reading the parameters of all methods of the Web Service. This increases the performance of Web Service operation invocation, in particular when the parameters are large, such as images.\n\nYou cannot use this annotation if you are also using the following features in the same Web Service:\n\nThe annotation does not have any attributes.\n\nThe following simple JWS file shows how to specify the annotation; the single method, , simply takes a parameter and echoes it back to the client application that invoked the Web Service operation. The WebLogic Web Services runtime uses streaming when reading the DataHandler content.\n\nSpecifies whether the annotated operation, or all the operations of the JWS file when the annotation is specified at the class-level, runs or run inside of a transaction. By default, the operations do not run inside of a transaction.\n\nThe following example shows how to use the annotation to specify that an operation of a Web Service executes as part of a transaction:\n\nSpecifies a comma-separated list of fully qualified Java class names of the alternative data types for a return type or parameter. The alternative data types must extend the data type specified in the method signature; if this is not the case, the Ant task returns a validation error when you compile the JWS file into a Web Service.\n\nFor example, assume you have created the base data type, and then created and that extend this base type. If the method signature specifies that it takes an parameter, you can annotate the parameter with the annotation to specify that that the public operation also takes and as a parameter, in addition to the base data type.\n\nYou can also use this annotation to restrict the data types that can be contained in parameters or return values of collection data types, such as or . By restricting the allowed contained data types, the generated WSDL is specific and unambiguous, and the Web Services runtime can do a better job of qualifying the parameters when a client application invokes a Web Service operation.\n\nIf you specify this annotation at the method-level, then it applies only to the return value. If you want the annotation to apply to parameters, you must specify it at the parameter-level for each relevant parameter.\n\nThe following example shows a simple JWS file that uses the annotation, with relevant Java code shown in bold:\n\nIn the example, the signature of the method shows that it takes a value as both a parameter and a return value. However, because both the method and the parameter are annotated with the annotation, a client application invoking the operation can also pass it a parameter of data type ; in this case the operation also returns an value. It is assumed that extends .\n\nSpecifies the XML Schema data type to which a wildcard class, such as or , binds. By default, these Java data types bind to the XML Schema data type. By using this class-level annotation, you can specify that the wildcard classes bind to instead.\n\nThe following example shows how to use the annotation to specify that the Apache XMLBeans data type XMLObject should bind to the XML Schema data type for this Web Service:\n\nThis JWS annotation does not have any attributes.\n\nSee weblogic.jws.WildcardBinding for an example.\n\nSpecifies the context path and service URI sections of the URL used to invoke the Web Service over the HTTP transport, as well as the name of the port in the generated WSDL.\n\nYou can specify this annotation only once (maximum) in a JWS file.\n\nSpecifies the context path and service URI sections of the URL used to invoke the Web Service over the HTTPS transport, as well as the name of the port in the generated WSDL.\n\nYou can specify this annotation only once (maximum) in a JWS file.\n\nSpecifies the context path and service URI sections of the URL used to invoke the Web Service over the JMS transport, as well as the name of the port in the generated WSDL. You also use this annotation to specify the JMS queue to which WebLogic Server queues the SOAP request messages from invokes of the operations.\n\nYou can specify this annotation only once (maximum) in a JWS file.\n\nThe following example shows how to specify that the JWS file implements a Web Service that is invoked using the JMS transport. The JMS queue to which WebLogic Server queues SOAP message requests from invokes of the service operations is ; it is assumed that this JMS queue has already been configured for WebLogic Server.\n\nSpecifies whether to expose the WSDL of a deployed WebLogic Web Service.\n\nBy default, the WSDL is exposed at the following URL:\n\nFor example, assume you used the following annotation:\n\nThe URL to get view the WSDL of the Web Service, assuming the service is running on a host called at the default port number, is:\n\nThe following use of the annotation shows how to specify that the WSDL of a deployed Web Service not be exposed; only relevant Java code is shown:\n\nSpecifies an array of JWS annotations that list the roles that are allowed to invoke the callback methods of the Web Service. A user that is mapped to an unspecified role, or is not mapped to any role at all, would not be allowed to invoke the callback methods.\n\nIf you use this annotation at the field level, then the specified roles are allowed to invoke all callback operations of the Web Service. If you use this annotation at the method-level, then the specified roles are allowed to invoke only that callback method. If specified at both levels, the method value overrides the field value if there is a conflict.\n\nThe following example shows how to use the annotation at the method level to specify that the role is allowed to invoke the callback method:\n\nJWS annotation used to enable basic authentication for a Web Service. In particular, it specifies an array of JWS annotations that describe the list of roles that are allowed to invoke the Web Service. A user that is mapped to an unspecified role, or is not mapped to any role at all, would not be allowed to invoke the Web Service.\n\nIf you use this annotation at the class-level, then the specified roles are allowed to invoke all operations of the Web Service. To specify roles for just a specific set of operations, specify the annotation at the operation-level.\n\nIn the example, only the roles and are allowed to invoke the Web Service. Within the context of the Web Service, the users and are assigned the role . The role , however, does not include a attribute, which implies that users have been mapped to this role externally. It is assumed that you have already added the two users ( and ) to the WebLogic Server security realm.\n\nJWS annotation used to specify the list of role names that reference actual roles that are allowed to invoke the Web Service. In particular, it specifies an array of JWS annotations, each of which describe a link between a referenced role name and an actual role defined by a annotation.\n\nThis JWS annotation does not have any attributes.\n\nIn the example, the role is linked to the role , which is allowed to invoke the Web Service. This means that any user who is assigned to the role of is also allowed to invoke the Web Service.\n\nSpecifies the role and user identity which actually runs the Web Service in WebLogic Server.\n\nFor example, assume that the annotation specifies the role and principal. This means that even if the Web Service is invoked by (mapped to ), the relevant operation is actually executed internal as .\n\nThe example shows how to specify that the Web Service is always run as user , mapped to the role , regardless of who actually invoked the Web Service.\n\nSpecifies the name of a role that is allowed to invoke the Web Service. This annotation is always specified in the JWS file as a member of a array.\n\nWhen a client application invokes the secured Web Service, it specifies a user and password as part of its basic authentication. It is assumed that an administrator has already configured the user as a valid WebLogic Server user using the Administration Console; for details see Create Users.\n\nThe user that is going to invoke the Web Service must also be mapped to the relevant role. You can perform this task in one of the following two ways:\n\nTo specify that multiple roles are allowed to invoke the Web Service, include multiple annotations within the annotation.\n\nIn the example, only the roles and are allowed to invoke the Web Service. Within the context of the Web Service, the users and are assigned the role . The role , however, does not include a attribute, which implies that users have been mapped to this role externally. It is assumed that you have already added the two users ( and ) to the WebLogic Server security realm.\n\nSpecifies a role name reference that links to an already-specified role that is allowed to invoke the Web Service.\n\nUsers that are mapped to the role reference can invoke the Web Service as long as the referenced role is specified in the annotation of the Web Service.\n\nIn the example, the role is linked to the role , which is allowed to invoke the Web Service. This means that any user who is assigned to the role of is also allowed to invoke the Web Service.\n\nSpecifies whether the client is required to use the HTTPS transport when invoking the Web Service.\n\nWebLogic Server establishes a Secure Sockets Layer (SSL) connection between the client and Web Service if the attribute of this annotation is set to either or in the JWS file that implements the Web Service.\n\nIf you specify this annotation in your JWS file, you must also specify the annotation (or the element of the Ant task) to ensure that an HTTPS binding is generated in the WSDL file by the Ant task.\n\nSpecifies the name of the Web Service security configuration you want the Web Service to use. If you do not specify this annotation in your JWS file, the Web Service is associated with the default security configuration (called ) if it exists in your domain.\n\nThe annotation only makes sense if your Web Service is configured for message-level security (encryption and digital signatures). The security configuration, associated to the Web Service using this annotation, specifies information such as whether to use an X.509 certificate for identity, whether to use password digests, the keystore to be used for encryption and digital signatures, and so on.\n\nWebLogic Web Services are not required to be associated with a security configuration; if the default behavior of the Web Services security runtime is adequate then no additional configuration is needed. If, however, a Web Service requires different behavior from the default (such as using an X.509 certificate for identity, rather than the default username/password token), then the Web Service must be associated with a security configuration.\n\nBefore you can successfully invoke a Web Service that specifies a security configuration, you must use the Administration Console to create it. For details, see Create a Web Services security configuration. For general information about message-level security, see Configuring Message-Level Security (Digital Signatures and Encryption).\n\nThe following example shows how to specify that a Web Service is associated with the security configuration; only the relevant Java code is shown:\n\nSpecifies the mapping of a Web Service operation onto the SOAP message protocol.\n\nThis annotation is analogous to except that it applies to a method rather than the class. With this annotation you can specify, for example, that one Web Service operation uses RPC-encoded SOAP bindings and another operation in the same Web Service uses document-literal-wrapped SOAP bindings.\n\nThe following simple JWS file shows how to specify that, by default, the operations of the Web Service use document-literal-wrapped SOAP bindings; you specify this by using the annotation at the class-level. The example then shows how to specify different SOAP bindings for individual methods by using the annotation at the method-level. In particular, the method uses document-literal-bare SOAP bindings, and the method uses RPC-encoded SOAP bindings.\n\nSpecifies the roles that are allowed to access the operations of the Web Service.\n\nIf you specify this annotation at the class level, then the specified roles apply to all public operations of the Web Service. You can also specify a list of roles at the method level if you want to associate different roles to different operations of the same Web Service.\n\nThe following example shows how to specify, at the class-level, that the Web Service can be invoked only by the role; only relevant parts of the example are shown:\n\nSpecifies the identity assumed by the Web Service when it is invoked.\n\nUnless otherwise specified, a Web Service assumes the identity of the authenticated invoker. This annotation allows the developer to override this behavior so that the Web Service instead executes as a particular role. The role must map to a user or group in the WebLogic Server security realm.\n\nThe following example shows how to specify that the Web Service, when invoked, runs as the role:"
    },
    {
        "link": "https://docs.oracle.com/middleware/1212/wls/WSREF/annotations.htm",
        "document": "The chapter provides reference documentation about the WebLogic-specific JWS annotations.\n\nThis chapter includes the following topics:\n\nThe following sections describe the JWS annotations that are supported.\n\nThe following example shows a simple JWS file that uses standard JSR-181, shown in bold:\n\nYou can target a JWS annotation at either the class-, method- or parameter-level in a JWS file. Some annotations can be targeted at more than one level, such as @SecurityRoles that can be targeted at both the class and method level.\n\nThe JWS annotations that are supported vary based on whether you are creating a JAX-WS or JAX-RPC Web Service. The following table compares the Web Service annotation support for JAX-WS and JAX-RPC.\n\nThe Java Web Service (JWS) annotated file is the core of your Web Service. It contains the Java code that determines how your Web Service behaves. A JWS file is an ordinary Java class file that uses annotations to specify the shape and characteristics of the Web Service.\n\nThe WebLogic Web Services programming model uses the JDK metadata annotations feature (specified by JSR-175 at http://www.jcp.org/en/jsr/detail?id=175 ). In this programming model, you create an annotated Java file and then use Ant tasks to compile the file into the Java source code and generate all the associated artifacts.\n\nAt the class level the SOAP bindings of the Web Service (such as, document-encoded or document-literal-wrapped ). For more information, see \"Specifying the Mapping of the Web Service to the SOAP Message Protocol ( @SOAPBinding Annotation)\" in Developing JAX-WS Web Services for Oracle WebLogic Server or Developing JAX-RPC Web Services for Oracle WebLogic Server .\n\nAn external handler chain. For more information, see \"Creating and Using SOAP Message Handlers\" in Developing JAX-WS Web Services for Oracle WebLogic Server or Developing JAX-RPC Web Services for Oracle WebLogic Server .\n\nThe mapping between the Web Service operation return value and the corresponding element of the generated WSDL file. For more information, see \"Customizing the Mapping Between the Operation Return Value and a WSDL Element ( @WebResult Annotation)\" in Developing JAX-WS Web Services for Oracle WebLogic Server or Developing JAX-RPC Web Services for Oracle WebLogic Server .\n\nThe mapping between operation input parameters of the Web Service and elements of the generated WSDL file, as well as specify the behavior of the parameter. For more information, see \"Customizing the Mapping Between Operation Parameters and WSDL Elements (@WebParam Annotation)\" in Developing JAX-WS Web Services for Oracle WebLogic Server or Developing JAX-RPC Web Services for Oracle WebLogic Server .\n\nThat an operation not return a value to the calling application. For more information, see \"Specifying That a JWS Method Be Exposed as a Public Operation ( @WebMethod and @OneWay Annotations)\" in Developing JAX-WS Web Services for Oracle WebLogic Server or Developing JAX-RPC Web Services for Oracle WebLogic Server .\n\nThat a method of the JWS file should be exposed as a public operation of the Web Service. For more information, see \"Specifying That a JWS Method Be Exposed as a Public Operation ( @WebMethod and @OneWay Annotations)\" in Developing JAX-WS Web Services for Oracle WebLogic Server or Developing JAX-RPC Web Services for Oracle WebLogic Server .\n\nAt the class level that the JWS file implements a Web Service. For more information, see \"Specifying that the JWS File Implements a Web Service ( @WebService Annotation)\" in Developing JAX-WS Web Services for Oracle WebLogic Server or in Developing JAX-RPC Web Services for Oracle WebLogic Server .\n\nThe following table summarizes the standard JSR-181 annotations that you can use in your JWS file to specify the shape and behavior of your Web Service. Each of these annotations are available with the javax.jws at https://download.oracle.com/javaee/6/api/javax/jws/package-summary.html or javax.jws.soap package at https://download.oracle.com/javaee/6/api/javax/jws/soap/package-summary.html and are described in more detail in the Web Services Metadata for the Java Platform (JSR-181) specification at http://www.jcp.org/en/jsr/detail?id=181 .\n\nA reference to a Web Service. For more information, see \"Defining a Web Service Reference Using the @WebServiceRef Annotation\" in Developing JAX-WS Web Services for Oracle WebLogic Server.\n\nService-specific exception classes to customize to the local and namespace name of the fault element and the name of the fault bean.\n\nWhether a provider implementation works with the entire protocol message or with the payload only.\n\nThe response wrapper bean to be used at runtime for the methods in the endpoint interface.\n\nThe request wrapper bean to be used at runtime for the methods in the endpoint interface.\n\nWhether to allow an explicit association of a WS-Addressing Action message addressing property with the fault messages of the WSDL operation mapped from the exception class. The @FaultAction annotation is used inside an @Action annotation.\n\nThe binding to use for a Web Service implementation class. For more information, see \"Specifying the Binding Type to Use for an Endpoint (@BindingType Annotation)\" in Developing JAX-WS Web Services for Oracle WebLogic Server.\n\nWhether to allow an explicit association of a WS-Addressing Action message addressing property with input , output , and fault messages of the mapped WSDL operation.\n\nThe following table summarizes the JAX-WS (JSR-224) annotations that you can use in your JWS file to specify the shape and behavior of your Web Service. Each of these annotations are available with the javax.xml.ws package at https://download.oracle.com/javaee/6/api/javax/xml/ws/package-summary.html and are described in more detail in JAX-WS 2.1 Annotations at http://jax-ws.java.net/nonav/2.1.4/docs/annotations.html .\n\nThe JAX-WS JWS annotations are relevant to JAX-WS Web Services only. This section does not apply to JAX-RPC Web Services.\n\nThat a class or enum type be mapped to an XML Schema type. For more information, see \"Mapping a Value Class to a Schema Type (@XmlType)\" in Developing JAX-WS Web Services for Oracle WebLogic Server.\n\nThe other classes to bind when binding the current class. For more information, see \"Binding a Set of Classes (@XmlSeeAlso)\" in Developing JAX-WS Web Services for Oracle WebLogic Server.\n\nThat a top-level class be mapped to a global element in the XML schema that is used by the WSDL of the Web Service. For more information, see \"Mapping a Top-level Class to a Global Element (@XmlRootElement)\" in Developing JAX-WS Web Services for Oracle WebLogic Server.\n\nThat a property contained in a class be mapped to a local element in the XML schema complex type to which the containing class is mapped. For more information, see \"Mapping Properties to Local Elements (@XmlElement)\" in Developing JAX-WS Web Services for Oracle WebLogic Server.\n\nWhether fields or properties are serialized by default. For more information, see \"Specifying Default Serialization of Fields and Properties (@XmlAccessorType)\" in Developing JAX-WS Web Services for Oracle WebLogic Server.\n\nThe JAXB (JSR-222) at http://jcp.org/en/jsr/detail?id=222 specification defines the JAXB annotations that you can use in your JWS file to specify the shape and behavior of your Web Service. The JAXB annotations are summarized in the following table. Each of these annotations are available with the javax.xml.bind.annotation package at https://download.oracle.com/javaee/6/api/javax/xml/bind/annotation/package-summary.html and are described in more detail in \"Customizing Java-to-XML Schema Mapping Using JAXB Annotations\" in Developing JAX-WS Web Services for Oracle WebLogic Server or the JAXB (JSR-222 at http://jcp.org/en/jsr/detail?id=222) specification.\n\nThe JAXB JWS annotations are relevant to JAX-WS Web Services only. This section does not apply to JAX-RPC Web Services.\n\nA callback notification om a method to signal that the instance is in the process of being removed by the container.\n\nA method that needs to be executed after dependency injection is done to perform initialization.\n\nA resource that is needed by the application. This annotation may be applied to an application component class or to fields or methods of the component class.\n\nEach of these annotations are available with the javax.annotation package at https://download.oracle.com/javaee/6/api/javax/annotation/package-summary.html and are described in more detail in the Common Annotations for the Java Platform (JSR-250) specification at http://jcp.org/en/jsr/detail?id=250 .\n\nThe following table summarizes the JAX-WS (JSR-250) annotations that you can use in your JWS file to specify the shape and behavior of your Web Service.\n\nWebLogic Web Services define a set of JWS annotations that you can use to specify behavior and features in addition to the standard JSR-181 JWS annotations. The following table summarizes the WebLogic-specific annotations and whether they are supported for JAX-WS or JAX-RPC. (The majority of annotations are supported for JAX-RPC only.) Each annotation is described in more detail in the sections that follow.\n\nThat the Web service client supports SOAP over JMS transport connection protocol. That the Web service supports SOAP over JMS transport connection protocol. The method that handles a potential failure when the main JWS file invokes an operation of another Web Service asynchronously. The method that handles the response when the main JWS file invokes an operation of another Web Service asynchronously. Whether the Web Service uses version 1.1 or 1.2 of the Simple Object Access Protocol (SOAP) implementation when accepting or sending SOAP messages. The JNDI name of the JMS queue to which WebLogic Server stores: That the annotated variable is a callback, which means that you can use the variable to send callback events back to the client Web Service that invoked an operation of the target Web Service. The method in the client Web Service that handles the messages it receives from the callback Web Service. That the JWS file is actually a Java interface that describes a callback Web Service. That the annotated field provides access to the runtime context of the Web Service. That a method annotated with the annotation can be invoked as part of a conversation between two WebLogic Web Services or a stand-alone Java client and a conversational Web Service. That the Web Service does not use the default WebLogic Server default filestore to store internal state information, such as conversational state, but rather uses one specified by the programmer. Which public methods of a JWS are buffered. If specified at the class-level, then all public methods are buffered; if you want only a subset of the methods to be buffered, specify the annotation at the appropriate method-level. That a WS-Policy file, which contains information about digital signatures, encryption, or Web Service reliable messaging, should be applied to the request or response SOAP messages. Reliable messaging properties for an operation of a reliable Web Service, such as the number of times WebLogic Server should attempt to deliver the message from the JMS queue to the Web Service implementation, and the amount of time that the server should wait in between retries. The method that handles the error that results when a client Web Service invokes a reliable Web Service, but the client does not receive an acknowledgement that the reliable Web Service actually received the message. That the annotated variable in the JWS file is a stub used to invoke another WebLogic Web Service when using the following features: That the WebLogic Web Services runtime use streaming APIs when reading the parameters of all methods of the Web Service. Whether the annotated operation, or all the operations of the JWS file when the annotation is specified at the class-level, runs or run inside of a transaction. A comma-separated list of fully qualified Java class names of the alternative data types for a return type or parameter. The XML Schema data type to which a wildcard class, such as or , binds. The context path and service URI sections of the URL used to invoke the Web Service over the HTTP transport, as well as the name of the port in the generated WSDL. The context path and service URI sections of the URL used to invoke the Web Service over the HTTPS transport, as well as the name of the port in the generated WSDL. The context path and service URI sections of the URL used to invoke the Web Service over the JMS transport, as well as the name of the port in the generated WSDL. Whether to expose the WSDL of a deployed WebLogic Web Service. An array of JWS annotations that list the roles that are allowed to invoke the callback methods of the Web Service. Whether to enable basic authentication for a Web Service. The list of role names that reference actual roles that are allowed to invoke the Web Service. The role and user identity which actually runs the Web Service in WebLogic Server. The name of a role that is allowed to invoke the Web Service. A role name reference that links to an already-specified role that is allowed to invoke the Web Service. Whether the client is required to use the HTTPS transport when invoking the Web Service. The name of the Web Service security configuration you want the Web Service to use. The mapping of a Web Service operation onto the SOAP message protocol. The roles that are allowed to access the operations of the Web Service. The identity assumed by the Web Service when it is invoked. Use this annotation with the annotation to override a configuration property when attaching a policy to a Web service client. That an Oracle Web Services Manager (OWSM) security policy be attached to the Web service or client. Whether the annotated class or method runs inside of a Web service atomic transaction. \n\n\n\nSpecifies the method that handles a potential failure when the main JWS file invokes an operation of another Web Service asynchronously. When you invoke, from within a JWS file, a Web Service operation asynchronously, the response (or exception, in the case of a failure) does not return immediately after the operation invocation, but rather, at some later point in time. Because the operation invocation did not wait for a response, a separate method in the JWS file must handle the response when it does finally return; similarly, another method must handle a potential failure. Use the annotation to specify the method in the JWS file that will handle the potential failure of an asynchronous operation invocation. The annotation takes two parameters: the name of the stub for the Web Service you are invoking and the name of the operation that you are invoking asynchronously. The stub is the one that has been annotation with the annotation. The method that handles the asynchronous failure must follow these guidelines:\n• Be named , where is the name of the method you are invoking asynchronously (with initial letter always capitalized.) In the main JWS file, the call to the asynchronous method will look something like: where is the non-asynchronous name of the method, is the asynchronous pre-call context, and is the usual parameter to the operation.\n• Have two parameters: the asynchronous post-call context (contained in the object) and the exception, potentially thrown by the asynchronous operation call. Within the method itself you can get more information about the method failure from the context, and query the specific type of exception and act accordingly. Typically, you always use the annotation to explicitly specify the method that handles asynchronous operation failures. The only time you would not use this annotation is if you want a single method to handle failures for two or more stubs that invoke different Web Services. In this case, although the stubs connect to different Web Services, each Web Service must have a similarly named method, because the Web Services runtime relies on the name of the method ( ) to determine how to handle the asynchronous failure, rather than the annotation. However, if you always want a one-to-one correspondence between a stub and the method that handles an asynchronous failure from one of the operations, then Oracle recommends that you explicitly use . See \"Invoking a Web Service Using Asynchronous Request-Response\" in Developing JAX-RPC Web Services for Oracle WebLogic Server for detailed information and examples of using this annotation. The following table lists the attributes of the annotation. The name of the stub of the Web Service for which you want to invoke an operation asynchronously. The stub is the one that has been annotated with the field-level annotation. The name of the operation that you want to invoke asynchronously. This is the actual name of the operation, as it appears in the WSDL file. When you invoke this operation in the main code of the JWS file, you add to its name. For example, if set , then in the JWS file you invoke it asynchronously as follows: \n\n The following sample snippet shows how to use the annotation in a JWS file that invokes the operation of another Web Service asynchronously; only the relevant Java code is included: The example shows a stub called , used to invoke the Web Service located at . The operation is invoked asynchronously, and any exception from this invocation is handled by the method, as specified by the annotation.\n\nSpecifies the method that handles the response when the main JWS file invokes an operation of another Web Service asynchronously. When you invoke, from within a JWS file, a Web Service operation asynchronously, the response does not return immediately after the operation invocation, but rather, at some later point in time. Because the operation invocation did not wait for a response, a separate method in the JWS file must handle the response when it does finally return. Use the annotation to specify the method in the JWS file that will handle the response of an asynchronous operation invocation. The annotation takes two parameters: the name of the stub for the Web Service you are invoking and the name of the operation that you are invoking asynchronously. The stub is the one that has been annotation with the annotation. The method that handles the asynchronous response must follow these guidelines:\n• Be named , where is the name of the method you are invoking asynchronously (with initial letter always capitalized.) In the main JWS file, the call to the asynchronous method will look something like: where is the non-asynchronous name of the method, is the asynchronous pre-call context, and is the usual parameter to the operation.\n• Have two parameters: the asynchronous post-call context (contained in the object) and the usual return value of the operation. Within the asynchronous-response method itself you add the code to handle the response. You can also get more information about the method invocation from the context. Typically, you always use the annotation to explicitly specify the method that handles asynchronous operation responses. The only time you would not use this annotation is if you want a single method to handle the response for two or more stubs that invoke different Web Services. In this case, although the stubs connect to different Web Services, each Web Service must have a similarly named method, because the Web Services runtime relies on the name of the method ( ) to determine how to handle the asynchronous response, rather than the annotation. However, if you always want a one-to-one correspondence between a stub and the method that handles an asynchronous response from one of the operations, then Oracle recommends that you explicitly use . See \"Invoking a Web Service Using Asynchronous Request-Response\" in Developing JAX-RPC Web Services for Oracle WebLogic Server for detailed information and examples of using this annotation. The name of the stub of the Web Service for which you want to invoke an operation asynchronously. The stub is the one that has been annotated with the field-level annotation. The name of the operation that you want to invoke asynchronously. This is the actual name of the operation, as it appears in the WSDL file. When you invoke this operation in the main code of the JWS file, you add to its name. For example, if set , then in the JWS file you invoke it asynchronously as follows: \n\n The following sample snippet shows how to use the annotation in a JWS file that invokes the operation of another Web Service asynchronously; only the relevant Java code is included: The example shows a stub called , used to invoke the Web Service located at . The operation is invoked asynchronously, and the response from this invocation is handled by the method, as specified by the annotation."
    },
    {
        "link": "https://stackoverflow.com/questions/53032248/how-webresult-annotation-works-in-jax-ws",
        "document": "I'm trying to create Jax-ws WebServices. But stuck with this behaviour of JAX-WS 2.2.\n\nI wrote the SEI class in the following way\n\nThe generated wsdl for the above SEI is as follows:\n\nI've tried to generate stubs using wsimport and this is what I could observe in the generated port class\n\nI'm curious to Know why is the WebResult name different in wsdl as \"return\" and in soap Response as \"GetServerTimeProperty\" and in generated stub as \"\".\n\nAlso If I dont annotate the Webmethod with @WebResult(name=\"GetServerTimeProperty\"), my stub-generated client response is null.\n\nIf I annotate my webmethod with @WebResult(name=\"GetServerTimeProperty\"), my soapResponse is looking as follows:\n\nIs @WebResult(name) is mandatory in jax-ws? I'm curios to Know how this webresult annotation is making a difference in soap response and client response.\n\nIs is that the name should be unique for every \"operationName\"+\"Respone\" element ? My wsdl has many elements with same name as\n\nPlease Suggest on this why the WebResult name returning soap response as null if we dont annotate"
    },
    {
        "link": "https://help.qlik.com/talend/en-US/esb-service-developer-guide/7.3/webmethod-annotation",
        "document": "This page has been archived.\n\nThis archival documentation relates to an older software release that is no longer supported.\n\nYou can view the latest version instead. Latest version"
    },
    {
        "link": "https://ibm.com/docs/ro/SS7K4U_8.5.5/com.ibm.websphere.base.doc/ae/rwbs_jaxwsannotations.html?view=kc",
        "document": "Java™ API for XML-Based Web Services (JAX-WS) relies on the use of annotations to specify metadata associated with web services implementations and to simplify the development of web services. Annotations describe how a server-side service implementation is accessed as a web service or how a client-side Java class accesses web services.\n\nThe JAX-WS programming standard introduces support for annotating Java classes with metadata that is used to define a service endpoint application as a web service and how a client can access the web service. JAX-WS supports the use of annotations based on the Metadata Facility for the Java Programming Language (Java Specification Request (JSR) 175) specification, the Web Services Metadata for the Java Platform (JSR 181) specification and annotations defined by the JAX-WS 2.0 and later (JSR 224) specification which includes JAXB annotations. Using annotations from the JSR 181 standard, you can simply annotate the service implementation class or the service interface and now the application is enabled as a web service. Using annotations within the Java source simplifies development and deployment of web services by defining some of the additional information that is typically obtained from deployment descriptor files, WSDL files, or mapping metadata from XML and WSDL into the source artifacts.\n\nUse annotations to configure bindings, handler chains, set names of portType, service and other WSDL parameters. Annotations are used in mapping Java to WSDL and schema, and at runtime to control how the JAX-WS runtime processes and responds to web service invocations.\n\nFor JAX-WS web services, the use of the webservices.xml deployment descriptor is optional because you can use annotations to specify all of the information that is contained within the deployment descriptor file. You can use the deployment descriptor file to augment or override existing JAX-WS annotations. Any information that you define in the webservices.xml deployment descriptor overrides any corresponding information that is specified by annotations.\n\nStarting with WebSphere® Application Server Version 7.0 and later, Java EE 5 application modules (Web application modules version 2.5 or later, or EJB modules version 3.0 or later) are scanned for annotations to identify JAX-WS services and clients. However, pre-Java EE 5 application modules (web application modules version 2.4 or before, or EJB modules version 2.1 or before) are not scanned for JAX-WS annotations, by default, for performance considerations.\n• You can set the property in the META-INF/MANIFEST.MF of a WAR file or EJB module to . For example: When this property is set to in the META-INF/MANIFEST.MF file of the module, the module is scanned for JAX-WS annotations regardless of the Java EE version of the module. The default value is and when the default value is in effect, JAX-WS annotations are only supported in modules whose version is Java EE 5 or later.\n• You can set the custom Java virtual machine (JVM) property using the administrative console. See the JVM custom properties documentation for the correct navigation path to use. To request annotation scanning in all modules regardless of their Java EE version, set the custom property to . You must change the setting on each server that requires a change in the default behavior. If the property is set within the META-INF/MANIFEST.MF file of the module, this setting takes precedence over the server's custom JVM property. When using either property, you must establish the desired annotation scanning behavior before the application is installed. You cannot dynamically change the scanning behavior once an application is installed. If changes to the behavior are required after your application is installed, you must first uninstall the application, specify the desired scanning behavior using the appropriate property and then install the application again. When federating nodes that have the set to in the configuration of the servers contained within the node, this property does not affect the deployment manager. You must set the property to on the deployment manager before the node is federated to preserve the behavior as it was on the node before federation. In the Version 6.1 Feature Pack for Web Services, the default behavior is to scan pre- Java Platform, Enterprise Edition (Java EE) 5 web application modules to identify JAX-WS services and to scan pre-Java EE 5 web application modules and EJB modules for service clients during application installation. Because the default behavior for WebSphere Application Server Version 7.0 and later is to not scan pre-Java EE 5 modules for annotations during application installation or server startup, to preserve backward compatability with the feature pack from previous releases, you must configure one of the following properties:If the property is set within the META-INF/MANIFEST.MF file of the module, this setting takes precedence over the server's custom JVM property. When using either property, you must establish the desired annotation scanning behavior before the application is installed. You cannot dynamically change the scanning behavior once an application is installed. If changes to the behavior are required after your application is installed, you must first uninstall the application, specify the desired scanning behavior using the appropriate property and then install the application again. When federating nodes that have theset toin the configuration of the servers contained within the node, this property does not affect the deployment manager. You must set the property toon the deployment manager before the node is federated to preserve the behavior as it was on the node before federation.\n\n. Describes the supported web services metadata annotations and their associated properties. The @WebService annotation marks a Java class as implementing a Web service or marks a service endpoint interface (SEI) as implementing a web service interface.\n• A Java class that implements a web service must specify either the @WebService or @WebServiceProvider annotation. Both annotations cannot be present. This annotation is applicable on a client or server SEI or a server endpoint implementation class.\n• If the annotation references an SEI through the attribute, the SEI must also be annotated with the @WebService annotation.\n• See the exposing methods in SEI-based JAX-WS web services information to learn about best practices for using the @WebService and @WebMethod annotations on a service endpoint implementation to specify Java methods that you want to expose as JAX-WS web services.\n• Properties: The name of the . The default value is the unqualified name of the Java class or interface. (String) Specifies the XML namespace of the WSDL and XML elements generated from the web service. The default value is the namespace mapped from the package name containing the web service. (String) Specifies the service name of the web service: . The default value is the simple name of the Java class + Service. (String) Specifies the qualified name of the service endpoint interface that defines the services' abstract web service contract. If specified, the service endpoint interface is used to determine the abstract WSDL contract. (String) The . The default value is WebService.name +Port . (String) Specifies the web address of the WSDL document that defines the web service. The web address is either relative or absolute. (String) The @WebMethod annotation denotes a method that is a web service operation. Apply this annotation to methods on a client or server Service Endpoint Interface (SEI) or a server endpoint implementation class.\n• Properties: Specifies the name of the matching this method. The default value is the name of Java method. (String) Defines the action for this operation. For SOAP bindings, this value determines the value of the SOAPAction header and must be explicitly set . Specifies whether to exclude a method from the web service. The default value is . (Boolean) The @Oneway annotation denotes a method as a web service one-way operation that only has an input message and no output message. Apply this annotation to methods on a client or server Service Endpoint Interface (SEI) or a server endpoint implementation class.\n• There are no properties on the Oneway annotation. The @WebParam annotation customizes the mapping of an individual parameter to a web service message part and XML element. Apply this annotation to methods on a client or server Service Endpoint Interface (SEI) or a server endpoint implementation class.\n• Properties: The name of the parameter. If the operation is remote procedure call (RPC) style and the attribute is not specified, then this is the name of the attribute representing the parameter. If the operation is document style or the parameter maps to a header, then is the local name of the XML element representing the parameter. This attribute is required if the operation is document style, the parameter style is , and the mode is or . (String) Defines the name of attribute representing this parameter. This is only used if the operation is RPC style, or the operation is document style and the parameter style is . (String) Specifies the XML namespace of the XML element for the parameter. Applies only for document bindings when the attribute maps to an XML element. The default value is the for the web service. (String) The value represents the direction the parameter flows for this method. Valid values are , , and . (String) Specifies whether the parameter is in a message header rather than a message body. The default value is . (Boolean) The @WebResult annotation customizes the mapping of a return value to a WSDL part or XML element. Apply this annotation to methods on a client or server Service Endpoint Interface (SEI) or a server endpoint implementation class.\n• Properties: Specifies the name of the return value as it is listed in the WSDL file and found in messages on the wire. For RPC bindings, this is the name of the attribute representing the return value. For document bindings, the parameter is the local name of the XML element representing the return value. The default value is for RPC and DOCUMENT/WRAPPED bindings. The default value is the method name + for DOCUMENT/BARE bindings. (String) Specifies the XML namespace for the return value. This parameter is only used if the operation is RPC style or if the operation is DOCUMENT style and the parameter style is BARE. (String) Specifies whether the result is carried in a header. The default value is . (Boolean) Specifies the part name for the result with RPC or DOCUMENT/BARE operations. The default value is . (String) The @HandlerChain annotation associates the web service with an externally defined handler chain. You can only configure the server side handler by using the @HandlerChain annotation on the Service Endpoint Interface (SEI) or the server endpoint implementation class. Use one of several ways to configure a client side handler. You can configure a client side handler by using the @HandlerChain annotation on the generated service class or SEI. Additionally, you can programmatically register your own implementation of the HandlerResolver interface on the Service, or programmatically set the handler chain on the Binding object.\n• Properties: Specifies the location of the handler chain file. The file location is either an absolute java.net.URL in external form or a relative path from the class file. (String) Specifies the name of the handler chain in the configuration file. (String) The @SOAPBinding annotation specifies the mapping of the web service onto the SOAP message protocol. Apply this annotation to a type or methods on a client or server Service Endpoint Interface (SEI) or a server endpoint implementation class. The method level annotation is limited in what it can specify and is only used if the property is . If the method level annotation is not specified, the @SOAPBinding behavior from the type is used.\n• Properties: Defines encoding style for messages sent to and from the web service. The valid values are and . The default value is . (String) Defines the formatting used for messages sent to and from the web service. The default value is . is not supported. (String) Determines whether the method's parameters represent the entire message body or whether parameters are elements wrapped inside a top-level element named after the operation. Valid values are or . You can only use the value with style bindings. The default value is . (String)\n\n. Describes the supported JAX-WS annotations and their associated properties. The @Action annotation specifies the WS-Addressing action that is associated with a web service operation. When you use this annotation with a particular method, and generate the corresponding WSDL document, the WS-Addressing Action extension attribute is added to the input and output elements of the WSDL operation that corresponds to that method. To add this attribute to the WSDL operation, you must also specify the @Addressing annotation on the server endpoint implementation class. If you do not want to use the @Addressing annotation you can supply your own WSDL document with the Action attribute already defined.\n• Properties: Specifies the array of for the of the operation. (String) Specifies the action for the of the operation. (String) Specifies the action for the of the operation. (String) The @BindingType annotation specifies the binding to use when publishing an endpoint of this type. You can use the @BindingType annotation on the JavaBeans endpoint implementation class to enable MTOM by specifying either or as the value for the annotation.\n• Properties: Indicates the binding identifier web address. Valid values are , , and . The default value is . (String) The @FaultAction annotation specifies the WS-Addressing action that is added to a fault response. This annotation must be contained within an @Action annotation. When you use this annotation with a particular method, the WS-Addressing FaultAction extension attribute is added to the fault element of the WSDL operation that corresponds to that method. To add this attribute to the WSDL operation, you must also specify the @Addressing annotation on the server endpoint implementation class. If you do not want to use the @Addressing annotation you can supply your own WSDL document with the Action attribute already defined.\n• Properties: Specifies the action of the of the operation. (String) Specifies the name of the exception class. (String) Specifies the name of the class representing the request wrapper. (String) The @RequestWrapper annotation supplies the JAXB generated request wrapper bean, the element name, and the namespace for serialization and deserialization with the request wrapper bean that is used at runtime. When starting with a Java object, this element is used to resolve overloading conflicts in document literal mode. Only the attribute is required in this case. Apply this annotation to methods on a client or server Service Endpoint Interface (SEI) or a server endpoint implementation class.\n• Properties: Specifies the local name of the XML schema element representing the request wrapper. The default value is the as defined in javax.jws.WebMethod annotation. (String) Specifies the XML namespace of the request wrapper method. The default value is the target namespace of the SEI. (String) Specifies the name of the class representing the request wrapper. (String) Specifies the name of the wsdl:part attribute that represents the XML schema element for the RequestWrapper class. This property is applicable for JAX-WS 2.2 and later. (String) The @ResponseWrapper annotation supplies the JAXB generated response wrapper bean, the element name, and the namespace for serialization and deserialization with the response wrapper bean that is used at runtime. When starting with a Java object, this element is used to resolve overloading conflicts in document literal mode. Only the attribute is required in this case. Apply this annotation to methods on a client or server Service Endpoint Interface (SEI) or a server endpoint implementation class.\n• Properties: Specifies the local name of the XML schema element representing the request wrapper. The default value is the + Response. is defined in javax.jws.WebMethod annotation. (String) Specifies the XML namespace of the request wrapper method. The default value is the target namespace of the SEI. (String) Specifies the name of the class representing the response wrapper. (String) Specifies the name of the wsdl:part attribute that represents the XML schema element for the ResponseWrapper class. This property is applicable for JAX-WS 2.2 and later. (String) The @RespectBinding annotation specifies whether the JAX-WS implementation must use the contents of the for an endpoint. When this annotation is specified, a check is performed to ensure all required WSDL extensibility elements with the enabled attribute set to true are supported. Apply this annotation to methods on a server endpoint implementation class.\n• Properties: Specifies whether the must be used or not. The default value is . (Boolean) The @ServiceMode annotation specifies whether a service provider needs to have access to an entire protocol message or just the message payload. The @ServiceMode annotation is only supported on classes that are annotated with the @WebServiceProvider annotation.\n• Properties: Indicates whether the provider class accepts the payload of the message, or the entire message . The default value is . (String) The @Addressing annotation specifies that this service wants to enable WS-Addressing support. Apply this annotation to methods on a server endpoint implementation class.\n• Properties: Specifies if WS-Addressing is enabled or not. The default value is . (Boolean) Specifies that WS-Addressing headers must be present on incoming messages. The default value is . (Boolean) Specifies the message exchange pattern to use. The default value is . This property is applicable for JAX-WS 2.2 and later. (String) The @MTOM annotation specifies whether binary content in the body of a SOAP message is sent using MTOM.\n• Properties: Specifies if MTOM is enabled for the JAX-WS endpoint. The default value is . (Boolean) Specifies the minimum size for messages that are sent using MTOM. When the message size is less than this specified integer, the message is inlined in the XML document as base64 or hexBinary data. (integer) The @WebFault annotation maps WSDL faults to Java exceptions. It is used to capture the name of the fault during the serialization of the JAXB type that is generated from a global element referenced by a WSDL fault message. It can also be used to customize the mapping of service specific exceptions to WSDL faults. This annotation can only be applied to a fault implementation class on the client or server.\n• Properties: Specifies the local name of the XML element that represents the corresponding fault in the WSDL file. The actual value must be specified. (String) Specifies the namespace of the XML element that represents the corresponding fault in the WSDL file. (String) Specifies the name of the fault bean class. (String) Specifies the name of the wsdl:message attribute that represents the corresponding fault in the WSDL file. This property is applicable for JAX-WS 2.2 and later. (String) The @WebServiceProvider annotation denotes that a class satisfies requirements for a JAX-WS Provider implementation class.\n• A Java class that implements a web service must specify either the @WebService or @WebServiceProvider annotation. Both annotations cannot be present.\n• The @WebServiceProvider annotation is only supported on the service implementation class. Any class with the @WebServiceProvider annotation must implement the javax.xml.ws.Provider interface. Any class with the @WebServiceProvider annotation must implement the javax.xml.ws.Provider interface.\n• Properties: Specifies the XML namespace of the WSDL and XML elements generated from the web service. The default value is the namespace mapped from the package name containing the web service. (String) Specifies the service name of the web service: . The default value is the simple name of the Java class + Service. (String) The . The default value is the name of the class + Port. (String) The web address of the WSDL document defining the web service. This attribute is required. (String) The @WebServiceRef annotation defines a reference to a web service invoked by the client.\n• The @WebServiceRef annotation can be used to inject instances of JAX-WS services and ports.\n• The @WebServiceRef annotation is only supported in certain class types. Examples are JAX-WS endpoint implementation classes, JAX-WS handler classes, Enterprise JavaBeans classes, and servlet classes. This annotation is supported in the same class types as the @Resource annotation. See the Java Platform, Enterprise Edition (Java EE) 5 specification for a complete list of supported class types.\n• Properties: Specifies the JNDI name of the resource. The field name is the default for field annotations. The JavaBeans property name that corresponds to the method is the default for method annotations. You must specify a value for class annotations as there is no default. (String) Indicates the Java type of the resource. The field type is the default for field annotations. The type of the JavaBeans property is the default for method annotations. You must specify a value for class annotations as there is no default. (Class) Specifies the name to map this resource to. (String) Indicates the value of the service class and it is a type that extends . This attribute is required when the type of the reference is a service endpoint interface. (Class) The web address of the WSDL document defining the web service. This attribute is required. (String) Specifies the JNDI lookup name for the target web service. This property is applicable for JAX-WS 2.2 and later. (String) The @WebServiceRefs annotation associates multiple @WebServiceRef annotations with a specific class. The @WebServiceRef annotation is only supported in certain class types. Examples are JAX-WS endpoint implementation classes, JAX-WS handler classes, Enterprise JavaBeans classes, and servlet classes. This annotation is supported in the same class types as the @Resource annotation. See the Java Platform, Enterprise Edition (Java EE) 5 specification for a complete list of supported class types.\n• Properties: Specifies an array for multiple web service reference declarations. This attribute is required."
    },
    {
        "link": "https://stackoverflow.com/questions/6609770/returning-an-arraylist-from-a-webservice-in-java",
        "document": "I am having a problem returning an ArrayList from my web service (Java).\n\nI have written a test web service and client which consumes it. All appears to work fine - that is the client is calling the server and the server receives the operation request.\n\nHowever, I have written a simple method that I want it to return an ArrayList.\n\nI have my interface definition as follows:\n\nI have my server side implementation to return the ArrayList:\n\nAnd finally my client call to it:\n\nThe server populates the array list fine. However, back at the client side, the ArrayList is empty. It has a size of 0.\n\nIf I examine the WSDL at my URL (http://127.0.0.1:9876/myservice-sql?wsdl) for the executeSelectSQL, it looks like:\n\nHowever, if I have a web method defines in the interface as:\n\nthen this works fine - is received on the client."
    },
    {
        "link": "https://stackoverflow.com/questions/3734645/how-to-return-resultset-from-web-service-in-java",
        "document": "i am writing an application in which i am creating web services. i am creating an operation(method) which retrieves database table values from database table in resultset. Hence we can't return resultset value directly in web services. i am creating a class which holds the values from resultset. instead of resultset i am returning object[] of newly created class as follows :\n\nbut while trying to access those values in web service client, it is giving java.lang.NullPointerException.\n\nhere is the code that i am using in web service client for accessing resultset values :\n\nI tried returning a singe row value by returning an object (HistoryInfoByUser) of newly created class instead of object[] (HistoryInfoByUser[] ). It works fine with single object but giving NullPointerException when i am using object[]. i am not getting any way which will help me to overcome with this problem of accessing resultset value.\n\nI thank in advance to your all valuable suggestions which will help me to overcome with this problem."
    },
    {
        "link": "https://forums.oracle.com/ords/apexds/post/returning-a-collection-from-a-web-service-method-4048",
        "document": "For appeals, questions and feedback about Oracle Forums, please email oracle-forums-moderators_us@oracle.com. Technical questions should be asked in the appropriate category. Thank you!\n\nInterested in getting your voice heard by members of the Developer Marketing team at Oracle? Check out this post for AppDev or this post for AI focus group information."
    },
    {
        "link": "https://coderanch.com/t/564445/java/Returning-array-objects-web-service",
        "document": "this forum made possible by our volunteer staff, including ..."
    },
    {
        "link": "https://vbforums.com/showthread.php?657475-RESOLVED-Webservice-return-multiple-records-from-table",
        "document": ""
    }
]