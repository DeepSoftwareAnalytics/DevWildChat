[
    {
        "link": "https://developer.android.com/jetpack/androidx/releases/lifecycle",
        "document": "Save and categorize content based on your preferences.\n\nLifecycle-aware components perform actions in response to a change in the lifecycle status of another component, such as activities and fragments. These components help you produce better-organized, and often lighter-weight code, that is easier to maintain.\n\nThis table lists all the artifacts in the group.\n\nThis library was last updated on: March 12, 2025\n\nTo add a dependency on Lifecycle, you must add the Google Maven repository to your project. Read Google's Maven repository for more information.\n\nAdd the dependencies for the artifacts you need in the file for your app or module:\n\nFor more information about dependencies, see Add Build Dependencies.\n\nYour feedback helps make Jetpack better. Let us know if you discover new issues or have ideas for improving this library. Please take a look at the existing issues in this library before you create a new one. You can add your vote to an existing issue by clicking the star button.\n\nSee the Issue Tracker documentation for more information.\n\nis released. Version 2.9.0-alpha12 contains these commits.\n• Add annotation to in all supported KMP platforms. (I7e8dd, b/397736115)\n\nis released. Version 2.9.0-alpha11 contains these commits.\n\nis released. Version 2.9.0-alpha10 contains these commits.\n• Adds a new Lint issue for calling in composition, instead suggesting using to ensure that changes in the Lifecycle state correctly cause recomposition. Thanks Steven Schoen! (Iad484)\n\nis released. Version 2.9.0-alpha09 contains these commits.\n• is deprecated as it creates a for every , causing unnecessary overhead. Use with instead for more efficient creation. (Ia920b, b/388590327)\n\nis released. Version 2.9.0-alpha08 contains these commits.\n• Add to simulate a System Process Death recreating the under test and all associated components. (Id6a69, b/381063087)\n• and instances retrieved via their respective APIs can now be resolved through disjoint parents of a view, such as a . See the release notes of core or the documentation in for more information on disjoint view parents. (I800f4)\n• Make the namings and package organization more consistent with (I8c135, b/376026744)\n• This library now uses JSpecify nullness annotations, which are type-use. Kotlin developers should use the following compiler arguments to enforce correct usage: (Ie4340, b/326456246)\n\nis released. Version 2.9.0-alpha07 contains these commits.\n• Lifecycle is now KMP compatible. This allows you to use in common code. (Ib6394, b/334076622)\n• None With the support of KotlinX Serialization added in SavedState , we have introduced , a lazy property delegate, to make it easy to store classes in a and have those classes automatically be restored across process death and recreation. Please note the delegate is lazy and will not call the lambda or save anything into the until it is accessed. (I47a88, b/376026744)\n• Add to to return a . This new function is key-exclusive and cannot be used with . An exception will be thrown if you try to use both to access the same state. (I04a4f, b/375408415)\n\nis released. Version 2.9.0-alpha06 contains these commits.\n• The state is terminal, and any attempt to move a from it to any other state will now result in an . (I116c4, b/370577987)\n• no longer includes any where the returned is empty. (I910b5, b/370577987)\n• now correctly complete when is (I293b2, b/374043130)\n\nis released with no notable changes. Version 2.9.0-alpha05 contains these commits.\n\nis released. Version 2.9.0-alpha04 contains these commits.\n• The module is now configured to be KMP compatible in preparation for APIs like being made available in the common source set in a future release. (I503ed, I48764, b/334076622)\n\nis released. Version 2.9.0-alpha03 contains these commits.\n• From Lifecycle : The Lint error has improved support for smart casts, avoiding false positives. (85fed6, b/181042665)\n• From Lifecycle : Lifecycle Runtime Compose now depends on Compose Runtime\n\nis released. Version 2.9.0-alpha02 contains these commits.\n• From Lifecycle : Update the ProGuard rules to allow obfuscation . (ff898e1)\n• Move to common source set (KMP). Thanks Ivan Matkov from JetBrains for the contribution. (8cd5d03)\n• From Lifecycle : SavedStateHandle.saveable` extension delegate now supports nullable values. Thanks Roman Kalukiewicz for the contribution. (0d78ea6)\n\nis released. Version 2.9.0-alpha01 contains these commits.\n• A new KMP artifact is available that provides a class for testing ViewModels in isolation, with support for (all platforms) and (Android only). (337f68d, c9b3409, 9799a95c, b/264602919)\n• Creating a with is now thread safe; annotations have been removed. (Ifd978, b/237006831)\n• Add the factory function to simplify the creation of anonymous objects. (I970ee)\n• now includes map-like operator overloads to enable idiomatic manipulation of content in Kotlin. It allows the use of , , and with . (Ib4353)\n• is now available on JVM Desktop and Android targets. (d3d0892)\n• Removed manual outlining of access to new platform APIs since this happens automatically via API modeling when using R8 with AGP 7.3 or later (e.g. R8 version 3.3) and for all builds when using AGP 8.1 or later (e.g. D8 version 8.1). Clients who are not using AGP are advised to update to D8 version 8.1 or later. See this article for more details. (If6b4c, b/345472586)\n\nis released. Version 2.8.7 contains these commits.\n• is now available in the common source set (KMP). (6a3f5b3)\n• : artifacts were removed and and artifacts were added. None of these targets are meant to be used, they are placeholders to help Jetbrains Compose efforts. (6a3f5b3)\n\nis released. Version 2.8.6 contains these commits.\n• The Lint error has improved support for smart casts, avoiding false positives. (85fed6, b/181042665)\n\nis released. Version 2.8.5 contains these commits.\n• Update the ProGuard rules to allow obfuscation . (ff898e1)\n• extension delegate now supports nullable values. Thanks Roman Kalukiewicz for the contribution. (0d78ea6)\n\nis released. Version 2.8.4 contains these commits.\n• now correctly handles cases where the returned Flow is immediately completed after receiving a value already set on the (for example, when using ). (I9c566)\n• completion is now idempotent (i.e., if the was called because of the Lifecycle being stopped, it won’t be called a second time upon disposal unless the Lifecycle goes back up to again). (I5f607, b/352364595)\n\nis released. Version 2.8.3 contains these commits.\n• Fixed an issue with Lifecycle 2.8’s backward compatibility with Compose 1.6.0 and lower when using code shrinking. (aosp/3133056, b/346808608)\n\nis released. Version 2.8.2 contains these commits.\n• Fixed errors when using Lifecycle 2.8.X with Compose 1.6.X or earlier - you can now use Lifecycle 2.8.2 with any version of Compose without any workarounds required. (aosp/3105647, b/336842920)\n• will no longer crash when mixing previous versions of Lifecycle dependencies with versions 2.8+, fixing issues with libraries such as LeakCanary. (I80383, b/341792251)\n\nis released. Version 2.8.1 contains these commits.\n• now only has a common dependency on , removing its common dependency on . The Android artifact retains its for compatibility. (aosp/3079334, b/339562627)\n• ’s integration using property delegates now uses the class name as part of the auto-generated key, avoiding conflicts if multiple classes use the same . (aosp/3063463)\n\nis released. Version 2.8.0 contains these commits.\n• has been moved from Compose UI to so that its Compose-based helper APIs can be used outside of Compose UI.\n• The artifact now contains the and APIs which allow you to drop click or other events that occur even after the has dropped below the given . For example, this can be used with Navigation Compose to avoid handling click events after a transition to another screen has already begun:\n• None is now an overridable constructor parameter, allowing you to inject your own dispatcher and or to override the default by using the available within . (I2817c, b/264598574) // Make Dispatchers.Main the default, rather than Dispatchers.Main.immediate // Use viewModelScope as before, without any code changes // Allows overriding the viewModelScope in a test\n• None has been rewritten in Kotlin and now uses instead of . It now supports adding objects with a that allows retrieving them via .\n• None Calling and without a key is now an error, following the same convention as the API that these APIs mirror.\n• None The kotlin extensions have now been moved to the module.\n• None The has been refactored to avoid many false positives.\n\nThe core Lifecycle APIs in , , , , , and are now shipped in artifacts compatible with Kotlin Multiplatform.\n• moves most APIs to and supports jvm and iOS in addition to Android.\n• moves most APIs to and supports jvm and iOS in addition to Android.\n• is now empty, with all APIs being moved into .\n• moves all APIs to and ships an Android artifact, matching the multiplatform support of .\n\nThe artifact and APIs like , , , and are now shipped in artifacts compatible with Kotlin Multiplatform.\n\nTo accommodate this change, methods such as those on that took a now have an equivalent method that takes a .\n\nBinary compatibility on Android has been maintained, but there are a few notable changes when comparing the Android API surface to the common API surface:\n• Constructing a instance is now done through the methods rather than directly calling its constructor.\n• and are only available on Android.\n• Custom Factories are recommended to extend from and use the method that takes a or use the Kotlin DSL.\n• Using without a custom factory on non-JVM platforms will result in an . On JVM platforms, compatibility is preserved by using the no-args ViewModel constructor if a custom factory is not provided.\n• will fallback to an in platforms where is not available (e.g., Linux).\n• moves most APIs to and supports jvm and iOS in addition to Android.\n• is now empty, with all APIs being moved into .\n• moves all APIs to and ships an Android artifact, matching the multiplatform support of .\n\nis released. Version 2.8.0-rc01 contains these commits.\n• Fixed an issue where the Baseline Profile for classes was not properly packaged. These are now packaged in the AAR. (aosp/3038274, b/322382422)\n• Fixed an unintentional ordering change in how instances attached to a ViewModel are cleared - the previous order of , then , then has been restored. (aosp/3041632)\n• Improve the default creation behavior for for native and JVM Desktop environments. (aosp/3039221)\n• Thanks Victor Kropp for improving the checking for the main thread on JVM Desktop. (aosp/3037116)\n\nis released. Version 2.8.0-beta01 contains these commits.\n• The artifact is now compatible with Kotlin Multiplatform, moving its code to and ships an Android artifact, matching the multiplatform support for . (If7a71, I4f4a0, b/331769623)\n\nis released. Version 2.8.0-alpha04 contains these commits.\n• The artifact is now compatible with Kotlin Multiplatform, moving its code to and ships an Android artifact, matching the multiplatform support of . The accommodate this change, the Composable method now accepts a in addition to a . (b/330323282)\n• The has been refactored to avoid many false positives. (I2d8c1, Iafb18, I03463, I7ecef)\n• The artifact now depends on Compose 1.6.0.\n\nis released. Version 2.8.0-alpha03 contains these commits.\n• None is now an overridable constructor parameter, allowing you to inject your own dispatcher and or to override the default by using the available within . (I2817c, b/264598574) // Make Dispatchers.Main the default, rather than Dispatchers.Main.immediate // Use viewModelScope as before, without any code changes // Allows overriding the viewModelScope in a test\n\nThe artifact and APIs like , , , and are now shipped in artifacts compatible with Kotlin Multiplatform. (b/214568825)\n\nTo accommodate this change, methods such as those on that took a now have an equivalent method that takes a .\n\nBinary compatibility on Android has been maintained, but there are a few notable changes when comparing the Android API surface to the common API surface:\n• Constructing a instance is now done through the methods rather than directly calling its constructor.\n• and are only available on Android.\n• Custom Factories are recommended to extend from and use the method that takes a or use the Kotlin DSL.\n• Using without a custom factory on non-JVM platforms will result in an . On JVM platforms, compatibility is preserved by using the no-args ViewModel constructor if a custom factory is not provided.\n• will fallback to an in platforms where is not available (e.g., Linux).\n• now handles duplicated keys: if the already has an resource associated with it, the old resource will be replaced and closed immediately. (Ibeb67)\n• Accessing the of a is now thread safe. (If4766, b/322407038)\n• moved from Compose UI to lifecycle-runtime-compose so that its Compose-based helper APIs can be used outside of Compose UI. Thanks Jake Wharton for the contribution. (I6c41b, b/328263448)\n\nis released. Version 2.8.0-alpha02 contains these commits.\n• The and APIs have been added which allow you to drop click or other events that occur even after the has dropped below the given . For example, this can be used with Navigation Compose to avoid handling click events after a transition to another screen has already begun: (Icba83, b/317230685)\n• is now written in Kotlin (I16f26, b/214568825)\n• The kotlin extensions have now been moved to the base lifecycle module. (Id787b, b/274800183)\n• The kotlin extensions have now been moved to the base lifecycle module. (Ic3686, b/274800183)\n• The kotlin extensions have now been moved to the base lifecycle module. (I54a3d, b/274800183)\n• The core Lifecycle APIs in , , , , , and are now shipped in artifacts compatible with Kotlin Multiplatform. (b/317249252)\n• Calling and without a key is now an error, following the same convention as the API that these APIs mirror. (Ib0e0c, b/323518079)\n• now uses instead of . That is a backward compatible change. (I27f8e, b/214568825)\n• Thanks Ivan Matkov from Jetbrains for helping move Lifecycle to Kotlin Multiplatform. (aosp/2926690, I0c5ac, If445d)\n\nis released. Version 2.8.0-alpha01 contains these commits.\n• now supports adding objects with a that allows retrieving them via . (I3cf63)\n\nis released. Version 2.7.0 contains these commits.\n• now includes a suspending function which ensures that the state change and all callbacks are completed before returning. Notably, unlike setting the property directly, this does not use , making it safe to use within a coroutine such as one provided by .\n• The extensions of and now mirror the behavior of - if the has a set, the / function will be immediately called to populate the of the returned . This ensures that the initial value will be set as part of the first composition (when used with ), but does not change the observation behavior - updates values from the source will still only apply once you start observing the .\n• This release fixes an issue where would not properly restore custom classes after process death and recreation. Due to type information that is lost by the Android framework, arrays of custom Parcelables require additional work (manually creating a typed array of the right type) and the documentation on , , and now specifically calls this limitation out.\n• The proguard keep rules associated with have been removed. This means that proguarded code that wishes to use APIs via reflection (such as using the long since deprecated annotation) will need to provide their own keep rules for their specific use case.\n• As an alternative to using a , you can now observe a of via the extension method.\n• Jetpack Compose users can now use to run Compose side effects based on .\n• Jetpack Compose users can use and to handle pairs of events - started to stopped and resumed to paused, respectively. This API mirrors the one found in and is suitable for cases where the change being made when the state is going up needs to be reversed when going back down.\n\nSee Run code on lifecycle events for more information.\n• The current can now be observed via the property, which returns a where the is the current .\n• Jetpack Compose users can use the extension to directly expose as Compose . This is equivalent (and a shorter alternative) to .\n\nSee Collect lifecycle state with flows for more information.\n\nis released. Version 2.7.0-rc02 contains these commits.\n• Fixed an issue where would not properly restore custom classes after process death and recreation. Due to type information that is lost by the Android framework, arrays of custom Parcelables require additional work (manually creating a typed array of the right type) and the documentation on , , and now specifically calls this limitation out. (I0b55a)\n\nis released. Version 2.7.0-rc01 contains these commits.\n• and now correctly dispose and recreate the effect block if the is changed. (Ia25c6)\n\nis released with no changes. Version 2.7.0-beta01 contains these commits.\n• A beta version bump, no major changes to this release version.\n\nis released. Version 2.7.0-alpha03 contains these commits.\n• now contains a new Lint check to avoid setting the of the by using the field when inside of a coroutine. The Lint check now suggests the suspending which allows setting the without blocking. (Icf728, b/297880630)\n• Fixed an issue with where returning the same instance both on the initial call and a subsequent call would prevent the instance from being added as a source. (Ibedcba7)\n\nis released. Version 2.7.0-alpha02 contains these commits.\n• now includes the suspending function to give users the option of using from within a coroutine such as one provided by . (I329de, b/259344129)\n• All files from the modules have been moved into the main module. (I10c6f, b/274800183)\n• The and extensions now sets the of the returned if the previous has had a value set on it, ensuring that using the resulting LiveData in Jetpack Compose has the right state on the initial composition. (I91d2b, b/269479952)\n• 's now immediately closes the if the has already received a call to . (I4712e, b/280294730)\n• From Lifecycle : Fixed an issue where would not correctly be restored after process death if the state was restored, was called without actually saving the state in the parent , and then the state was restored again. This fixes the interaction between and Navigation Compose’s . (aosp/2729289)\n\nis released. Version 2.7.0-alpha01 contains these commits.\n• is now Compose-observable via , which returns a where the is the current . (Ib212d, b/209684871)\n• s can now able to be observed as a with (If2c0f, b/176311030)\n• API has been added to run Compose s based on both and event callbacks. (I60386, b/235529345)\n• API has been added to run Compose s based on and event callbacks. (I5a8d1, b/235529345)\n• API has been added to run Compose s based on . (Ic9794, b/235529345)\n• extension has been added to directly expose as Compose . This is equivalent (and a shorter alternative) to . (I11015, b/235529345)\n• The extension now sets the of the returned if the previous has had a value set on it. This does not change the observation behavior - updated values from the source will still only apply once you start observing the returned from . (Ib482f)\n• The proguard keep rules associated with have been removed. This means that proguarded code that wishes to use APIs via reflection will need to provide their own keep rules for their specific use case. (Ia12fd)\n\nis released. Version 2.6.2 contains these commits.\n• Fixed an issue where would not correctly be restored after process death if the state was restored, was called without actually saving the state in the parent , and then the state was restored again. This fixes the interaction between and Navigation Compose’s . (aosp/2729289)\n\nis released. Version 2.6.1 contains these commits.\n\nis released. Version 2.6.0 contains these commits.\n• now includes a new property that indicates whether an explicit value has ever been set on the , allowing you to distinguish between returning because no value has ever been set or an explicit value.\n• now includes a constructor to set an initial value.\n• Added a new extension on and of that collect from flows and represents its latest value as Compose State in a lifecycle-aware manner.\n• methods and methods have been deprecated as the use of a pausing dispatcher can lead to wasted resources in some cases. It is recommended to use . For more information about one-time suspending work, please see this explanation on why this is inherently unsafe.\n• Kotlin Conversion - A large number of Lifecycle classes have been converted to Kotlin. All converted classes still retain their binary compatibility with previous versions. The following classes have source incompatible changes for classes written in Kotlin: , , , , , ,\n\nThe table below provides the source conversions for the new version of lifecycle.\n• The nullability of the method of a created in Kotlin now matches the nullability of the generic type. If you want to accept a nullable type, you must instantiate the with a nullable type.\n• These classes were also converted to Kotlin, but remain source compatible: , , , , , , , , , , and\n\nis released. Version 2.6.0-rc01 contains these commits.\n• The extension now sets the of the returned if the previous has had a value set on it. This does not change the observation behavior - updated values from the source will still only apply once you start observing the returned from . (Ib482f)\n\nis released. Version 2.6.0-beta01 contains these commits.\n• is now written in Kotlin. This is a source incompatible change for classes written in Kotlin - they must now override the property rather than implementing the previous function. (I75b4b, b/240298691)\n• is now in Kotlin. This is a source incompatible change for classes written in Kotlin - they must now override the property rather than implementing the previous function. (I86409, b/240298691)\n• The Kotlin extension on that provides the field has been moved to the artifact from . (I41d78, b/240298691)\n• The Kotlin extension on that provides the field has been moved to the artifact from . (Iabb91, b/240298691)\n\nis released. Version 2.6.0-alpha05 contains these commits.\n• is now written in Kotlin. This is a source incompatible change for those classes written in Kotlin that were directly using syntax such as - Kotlin code must now use the Kotlin extension method syntax that was previously only available when using . When using the Java programming language, the versions of these methods that take an method are deprecated and replaced with the versions that take a Kotlin . This change maintains binary compatibility. (I8e14f)\n• is now written in Kotlin. This is a source incompatible change for those classes written in Kotlin - you must now directly import and use the Kotlin extension methods on of and to set and find a previously set owner. This is binary compatible and remains source compatible for implementations written in the Java programming language. (Ia06d8, Ib22d8, b/240298691)\n• The interface is now written in Kotlin. This is a source incompatible change for classes written in Kotlin - they must now override the and properties rather than implementing the previous corresponding functions. (Iaed9c, b/240298691)\n• is now written in Kotlin. Its method now uses the name for its parameter. (Iffef2, I4995e, b/240298691)\n• , , , , and are now written in Kotlin (I2e771, Ibae40, I160d7, I08884, I1cda7, b/240298691)\n\nis released. Version 2.6.0-alpha04 contains these commits.\n• now includes a new property that indicates whether an explicit value has ever been set on the , allowing you to distinguish between returning because no value has ever been set or an explicit value. (Ibd018)\n• The APIs of are no longer in experimental status. (I09d42, b/258835424)\n• methods and methods have been deprecated as the use of a pausing dispatcher can lead to wasted resources in some cases. It is recommended to use . (Iafc54, b/248302832)\n• is now written in Kotlin. This is a source incompatible change for those classes written in Kotlin - you must now directly import and use the Kotlin extension methods on of and to set and find a previously set owner. This replaces the previous Kotlin extension in . This is binary compatible and remains source compatible for implementations written in the Java programming language. (I8a77a, I5234e, b/240298691)\n• is now written in Kotlin. The Kotlin extensions previously in have been moved into the module and have become the primary surface for code written in Kotlin. This is a source incompatible change for code written in Kotlin if you were not already using the Kotlin extension method APIs. (I2b1b9, I95d22, b/240298691)\n• , , , , , and are now written in Kotlin (Iadffd, (I60034, I8c52c, I9593d, I01fe1, I59a23, b/240298691)\n• no longer crashes with a when calling with the incorrect class type. (I6ae7c)\n\nis released. Version 2.6.0-alpha03 contains these commits.\n• Fixed an issue with constraints between different Lifecycle modules not working as intended. (I18d0d, b/249686765)\n• Errors thrown by now include a more helpful error messaging that informs developers of the component causing the error. (Idf4b2, b/244910446)\n\nis released. Version 2.6.0-alpha02 contains these commits.\n• now includes a constructor to set an initial value. (Ib6cc5, b/151244085)\n• artifacts now include constraints that ensure that all inter-dependent Lifecycle artifacts use the same version, automatically upgrading other dependencies when one is upgraded. b/242871265\n• now creates a rather than using its own implementation to ensure thread-safety and context preservation. (I4a8b2, b/200596935)\n• 's function will now preserve the initial value of a when creating the new object. (I3f530, b/157380488)\n• From Lifecycle : Custom implementations of now correctly calls the function when using the stateful constructor with 2.4+ (I5b315, b/238011621)\n\nis released. Version 2.6.0-alpha01 contains these commits.\n• Added a new extension on and of that collect from flows and represents its latest value as Compose State in a lifecycle-aware manner. The flow is collected and the new emission is set to the State's value when the lifecycle is at least in a certain . When the lifecycle falls below that , the flow collection stops and the State's value is not updated. (I1856e, b/230557927)\n\nis released. Version 2.5.1 contains these commits.\n• Custom implementations of now correctly call the function when using the stateful constructor with 2.4+. (I5b315, b/238011621)\n\nis released. Version 2.5.0 contains these commits.\n• None now offers a API that returns a Kotlin for monitoring value changes as an alternative to using .\n• None ViewModel CreationExtras - when writing a custom , it is no longer required to extend or to gain access to an or , respectively. Instead, these fields are provided to every subclass as via the new overload of : . These extras are provided automatically by your Activity or Fragment when using Activity and Fragment , respectively. < > // Get the Application object from extras // Create a SavedStateHandle for this ViewModel from extras >\n• None now provides a Kotlin DSL that allows you define your in terms of one or more lambda initializers, one for each particular class your custom factory supports, using as the primary data source. // The return type of the lambda automatically sets what class this lambda handles // Get the Application object from extras provided to the lambda\n• None now offers a API that takes a lambda factory for creating a instance without requiring the creation of a custom . // Within a @Composable, you can now skip writing a custom Factory // and instead write a lambda to do the initialization of your ViewModel // This lambda is only called the first time the ViewModel is created // and all CreationExtras are available inside the lambda\n• None SavedStateHandle Compose Saver Integration - the artifact now contains new experimental APIs in that allow like behavior backed by the of a `ViewModel. // This value survives both configuration changes and process death and recreation\n• None Added an API and a new constructor overload that allow you to add one or more objects to the that will be closed when the is cleared without requiring any manual work in . For instance, to create a coroutine scope that you can inject into a ViewModel, but control via testing, you can create a that implements : Which can then be used in your constructor while maintaining the same lifetime as : // You can now use customScope in the same way as viewModelScope\n• Attempting to move the from to will now always throw an regardless of whether the has an attached observer.\n• will now clear their observers when they reach the state.\n\nis released. Version 2.5.0-rc02 contains these commits.\n• will no longer crash when mixing previous versions of compileOnly Lifecycle dependencies with versions 2.5+. (I81a66, b/230454566)\n\nis released. Version 2.5.0-rc01 contains these commits.\n• now throws a when passed a source instead of propagating the source to observers.(Ibd0fb, b/123085232)\n\nis released. Version 2.5.0-beta01 contains these commits.\n• Added property delegates to use property names as keys for persisting state into the (I8bb86, b/225014345)\n• Fixed an issue where nesting one within another in a non-primary bottom navigation tab would lead to an when using multiple back stacks. (I11bd5, b/228865698)\n\nis released. Version 2.5.0-alpha06 contains these commits.\n• Add experimental overload to for parity with (I38cfe, b/224565154)\n• is now abstract instead of sealed. (Ib8a7a)\n\nis released. Version 2.5.0-alpha05 contains these commits.\n• The module now provides , an experimental API that ensures values in a are integrated correctly with the same saved instance state that uses. (Ia88b7, b/195689777)\n• Fixed a compatibility issue with Lifecycle 2.3 and newer Lifecycle versions in Java. (I52c8a, b/219545060)\n• now supports using even when it was initialized with a . If extras are provided, the initialized arguments are ignored. (I6c43b, b/224844583)\n\nis released. Version 2.5.0-alpha04 contains these commits.\n• now offers a API that returns a Kotlin for monitoring value changes as an alternative to using . (Iad3ab, b/178037961)\n\nis released. Version 2.5.0-alpha03 contains these commits.\n• Added an API and a new constructor overload that allow you to add one or more objects to the that will be closed when the is cleared without requiring any manual work in . (I55ea0)\n• now provides an that allows you to add lambda for handling particular classes, using as the primary data source. (If58fc, b/216687549)\n• now offers a API that takes a lambda factory for creating a instance without requiring the creation of a custom . (I97fbb, b/216688927)\n• You can now create a with via . (I08887, b/216688927)\n• Attempting to move the from to will now always throw an regardless of whether the has an attached observer. (I7c390, b/177924329)\n• will now clear their observers when they reach the state. (I4f8dd, b/142925860)\n\nis released. Version 2.5.0-alpha02 contains these commits.\n• and have been converted to Kotlin. This has improved the nullability of the generics in both classes. (Ib6ce2, b/216168263, I9647a, b/177667711)\n• The function parameter can now have a nullable output. (I40396, b/132923666)\n• The -ktx extensions are now annotated with to enforce that the result is used when calling these functions. (Ia0f05, b/207325134)\n• now properly stores the defaultValue when no value for the specified key exists. (I1c6ce, b/178510877)\n• From Lifecycle : Updated to depend on Startup 1.1.1 to ensure that fixes that prevent from throwing a are available by default. (Ib01df, b/216490724)\n• There is now an improved error message when custom classes have parameters in the wrong order and attempt to create a . (I340f7, b/177667711)\n• You can now create a view model via using the without setting an application. (I6ebef, b/217271656)\n\nis released. Version 2.5.0-alpha01 contains these commits.\n\nWith this release, we are laying the groundwork for restructuring how a is constructed. Instead of a rigid set of subclasses of that each add additional functionality (allowing an constructor parameter via , allowing a constructor parameter via and , etc.), we are moving to a world of stateless factories that rely on a new concept, . (Ia7343, b/188691010, b/188541057)\n\nWith this change, no longer makes direct calls into the previous method of . Instead, it calls into a new overload of : . This means that any direct implementation of the instance now has access to each of these new :\n• : this provides access to the custom key you passed to .\n• provides access to the class.\n• provides access to the that is being used to construct this ViewModel.\n• provides access to the that is being used to construct this ViewModel.\n• provides access to the of arguments that should be used to construct a .\n\nThese extras are provided by default when using Activity , Fragment , and Navigation . If you use an earlier version of those libraries, your will be empty - all of the existing subclasses of have been rewritten to support both the legacy creation path used by earlier versions of those libraries and the path which will be used going forward.\n\nThese allow you to construct a that passes just the information you need to each without relying on a strict hierarchy of Factory subclasses:\n\nWe use the Kotlin extension function on from to construct a only for the one ViewModel that needs it. (Ia6654, b/188541057)\n\nCustom can be provided by overriding in your or , thus making them available to your custom as a built in form of assisted injection. These extras will automatically be made available to your custom Factory when used directly with or when using the and Kotlin property extensions. (I79f2b, b/207012584, b/207012585, b/207012490)\n• Fixed an issue where the default value provided to a would reappear after process death and recreation, even if it was specifically removed from the . As a consequence of this, will no longer merge default values and restored values together, instead only using the restored values as the source of truth. (I53a4b)\n\nis released. Version 2.4.1 contains these commits.\n• Backported from Lifecycle : Fixed an issue where the default value provided to a would re-appear after process death and recreation, even if it was specifically removed from the . As a consequence of this, will no longer merge default values and restored values together, instead only using the restored values as the source of truth. (I53a4b)\n• now depends on Androidx Startup 1.1.1 which fixed a regression in where using would cause an . (b/216490724)\n\nis released. Version 2.4.0 contains these commits.\n• was deprecated. or should be used instead.\n• library was added. It provides composable and .\n• Source-breaking change: has been rewritten in Kotlin. method no longer allows nullable generic.\n• New coroutines API were added to :\n• , API that executes a block of code in a coroutine when the Lifecycle is at least in a certain state. The block will cancel and re-launch as the lifecycle moves in and out of the target state;\n• , API that emits values from the upstream Flow when the lifecycle is at least in a certain state.\n• was moved from to . doesn't provide anymore any additional functionality on top of , so dependency on it can be replaced by .\n• Non coroutines API from have been moved to the module.\n• None now uses to initialize the . Previously, this was being done by . If you used the being used to initialize process lifecycle in the past, then you need to do the following instead. <provider android:name=\"androidx.startup.InitializationProvider\" android:authorities=\\\"${applicationId}.androidx-startup\" android:exported=\"false\" tools:node=\\\"merge\"> <!-- If you are using androidx.startup to initialize other components --> <meta-data android:name=\"androidx.lifecycle.ProcessLifecycleInitializer\" android:value=\"androidx.startup\" tools:node=\"remove\" /> </provider>\n\nis released with no changes from Lifecycle 2.4.0-beta01. Version 2.4.0-rc01 contains these commits.\n\nis released. Version 2.4.0-beta01 contains these commits.\n• was deprecated. or should be used instead. (I5a8fa)\n• DefaultLifecycleObserver was moved from to . doesn't provide anymore any additional functionality on top of , so dependency on it can be replaced by . (I021aa)\n• Non coroutines API from have been moved to the module. (I6d5b2)\n• Thanks dmitrilc for fixing a type in the documentation! (#221)\n\nis released. Version 2.4.0-alpha03 contains these commits.\n• Source-breaking change: ViewModelProvider has been rewritten in Kotlin. method no longer allows nullable generic. (I9b9f6)\n• The : is now always invoked serially when repeating execution. (Ibab33)\n• Thanks chao2zhang for fixing the code snippets in the documentation. #205.\n\nis released. Version 2.4.0-alpha02 contains these commits.\n• Added a new lint check to that detects when is incorrectly used in or . (706078, b/187887400)\n• The API is removed in favor of that respects structured concurrency and is easier to reason about. (I4a3a8)\n• Make public so other s can use these as dependencies. (I94c31)\n• Fixed an issue with the lint check when the field has modifiers. (#147, b/183696616)\n• Fixed another issue with the lint check when using generics. (#161, b/184830263)\n• Thanks maxsav for improving the lint check. (#147, b/183696616)\n• Thanks kozaxinan for improving the lint check. (#161, b/184830263)\n\nis released. Version 2.4.0-alpha01 contains these commits.\n• None now uses to initialize the . Previously, this was being done by . If you used the being used to initialize process lifecycle in the past, then you need to do the following instead. <provider android:name=\"androidx.startup.InitializationProvider\" android:authorities=\\\"${applicationId}.androidx-startup\" android:exported=\"false\" tools:node=\\\"merge\"> <!-- If you are using androidx.startup to initialize other components --> <meta-data android:name=\"androidx.lifecycle.ProcessLifecycleInitializer\" android:value=\"androidx.startup\" tools:node=\"remove\" /> </provider> <!-- If you want to disable androidx.startup completely. --> <provider android:name=\"androidx.startup.InitializationProvider\" android:authorities=\"${applicationId}.androidx-startup\" tools:node=\"remove\"> </provider>\n• Added a API that emits values from the upstream Flow when the lifecycle is at least in a certain state using the API. This is an alternative to the also new API. (I0f4cd)\n• From Lifecycle 2.3.1: The lint rule can now properly differentiate between field variables with different nullability. (b/169249668)\n\nis released. Version 1.0.0-alpha07 contains these commits.\n• now takes an optional , making it easier to work with owners other than the . For example, you can now use to retrieve a ViewModel associated with a particular navigation graph. (I2628d, b/188693123)\n\nis released. Version 1.0.0-alpha06 contains these commits.\n\nUpdated to be compatible with Compose version .\n\nis released. Version 1.0.0-alpha05 contains these commits.\n• Updated to be compatible with Compose version .\n• The AndroidManifest files from ui-test-manifest and ui-tooling-data are now compatible with Android 12 (I6f9de, b/184718994)\n\nis released. Version 1.0.0-alpha04 contains these commits.\n• This version allows and to sync dependencies on and . For 1.0.0, it is required that the compiler and runtime match.\n\nis released. Version 1.0.0-alpha03 contains these commits.\n• now returns a nullable to better determine whether a is available in the current composition. APIs that require a , such as and , still throw an exception if a is not set. (Idf39a)\n\nis released. Version 1.0.0-alpha02 contains these commits.\n• now has a functions that can be used with , replacing the API. (I45d24)\n\nis released. Version 1.0.0-alpha01 contains these commits.\n• The composable and were moved from to this artifact in the package. (I7a374)\n\nis released. Version 2.3.1 contains these commits.\n• The lint rule can now properly differentiate between field variables with different nullability. (b/169249668)\n\nis released. Version 2.3.0 contains these commits.\n• support for non-parcelable classes: now supports lazy serialization by allowing you to call for a given key, providing a that will get a callback to when the is asked to save its state. See Saving non-parcelable classes.\n• Lifecycle Behavior Enforcement:\n• now verifies that its methods are called on main thread. It was always a requirement for lifecycles of activities, fragments etc. An addition of observers from non-main threads resulted in hard to catch crashes in runtime. For objects that owned by your own components, you can explicitly opt out from checks by using , but then you have to ensure that a proper synchronization is in place when this is accessed from different threads.\n• Lifecycle State and Event Helpers: Added static helper methods of , , , to for generating the given a and transition direction. Added the method that provides the that the Lifecycle will transition to directly following the .\n• : Added APIs that await a lifecycle state and run a non-suspending block of code synchronously at the point of state change, then resume with the result. These APIs differ from the existing methods as they do not permit running suspending code and do not employ a custom dispatcher. (aosp/1326081)\n• APIs: A new and API allows you to retrieve the containing and , respectively, given a instance. You must upgrade to Activity and Fragment , and AppCompat 1.3.0-alpha01 or higher to populate this correctly. The and Kotlin extensions are available in and , respectively.\n• Kotlin extension deprecation: The Kotlin extension necessary to use lambda syntax is now deprecated as it is not necessary when using Kotlin 1.4.\n\nis released. Version 2.3.0-rc01 contains these commits.\n• The method of is now consistent before and after the state is saved - it now includes keys previously used with in addition to the keys used with and . (aosp/1517919, b/174713653)\n• The APIs to suspend Lifecycle-aware coroutines now better handle calls to . Thanks Nicklas Ansman Giertz! (aosp/1430830, b/168777346)\n\nis released. Version 2.3.0-beta01 contains these commits.\n• The Kotlin extension necessary to use lambda syntax is now deprecated as it is not necessary when using Kotlin 1.4. (I40d3f)\n• The builder and docs have been updated to include details about changing the given timeout values. (aosp/1122324)\n\nis released. Version 2.3.0-alpha07 contains these commits.\n\nis released. Version 2.3.0-alpha06 contains these commits.\n• Added static helper methods of , , , to for generating the given a and transition direction. Added the method that provides the that the Lifecycle will transition to directly following the . (I00887)\n• Added APIs that await a lifecycle state and run a non-suspending block of code synchronously at the point of state change, then resume with the result. These APIs differ from the existing methods as they do not permit running suspending code and do not employ a custom dispatcher. (aosp/1326081)\n• now verifies that its methods are called on main thread. It was always a requirement for lifecycles of activities, fragments etc. An addition of observers from non-main threads resulted in hard to catch crashes in runtime. For objects that owned by your own components, you can explicitly opt out from checks by using , but then you have to ensure that a proper synchronization is in place when this is accessed from different threads (Ie7280, b/137392809)\n• Fixed an for Lint checks bundled with (and specifically ). (b/158699265)\n\nis released. Version 2.3.0-alpha05 contains these commits.\n• now better handles reentrant cases, avoiding duplicate calls to or . (b/157840298)\n• Fixed an issue where Lint checks would not run when using Android Studio 4.1 Canary 6 or higher. (aosp/1331903)\n\nis released. Version 2.3.0-alpha04 contains these commits.\n• The Lint check now covers significantly more cases where a value was set on a with a non-null type parameter. (b/156002218)\n\nare released. Version 2.3.0-alpha03 contains these commits.\n• now supports lazy serialization by allowing you to call for a given key, providing a that will get a callback to when the is asked to save its state. (b/155106862)\n• A new API allows you to retrieve the containing given a instance. You must upgrade to Activity , Fragment , and AppCompat to populate this correctly. A Kotlin extension has been added to . (aosp/1295522)\n• Fixed an issue that caused the Lint checks released in Lifecycle from being published alongside the artifact. (b/155323109)\n\nis released. Version 2.3.0-alpha02 contains these commits.\n• now allows you to pass a null to its constructor to better support cases where one is not readily available and support for is not needed. (aosp/1285740)\n• Improved cold start performance by avoiding class verification failure on API 28 and lower devices. (aosp/1282118)\n\nis released. Version 2.3.0-alpha01 contains these commits.\n• A new API allows you to retrieve the containing given a instance. You must upgrade to Activity and Fragment to populate this correctly. A Kotlin extension is available in . (aosp/1182361, aosp/1182956)\n• Added a new Lint check that warns you when setting a value on a that has been defined in Kotlin as non-null. This is available when using the or artifacts. (aosp/1154723, aosp/1159092)\n• A new artifact is available that provides a that implements and provides a thread safe mutable . (aosp/1242438)\n• The artifact now has a unique package name. (aosp/1187196)\n\nis released. Version 2.2.0 contains these commits.\n\nLifecycle ViewModel SavedState now shares the same version as other Lifecycle artifacts. The behavior of is identical to the behavior of .\n\nis released. Version 2.2.0 contains these commits.\n• Lifecycle Coroutine Integration: The new artifact adds integration between Lifecycle and Kotlin coroutines. The has also been expanded to take advantage of coroutines. See Use Kotlin coroutines with Architecture Components for more details.\n• deprecation: has been deprecated. You can pass a or to the new constructor to achieve the same functionality when using Fragment .\n• Artifact Deprecation: With the above deprecation of , this release marks the deprecation of the last API in and this artifact should now be considered deprecated in its entirety. We strongly recommend depending on the specific Lifecycle artifacts you need (such as if you’re using and if you’re using ) rather than as there will not be a future release of .\n• Gradle Incremental Annotation Processor: Lifecycle's annotation processor is incremental by default. If your app is written in the Java 8 programming language you can use instead; and if it's written in the Java 7 programming language you can use .\n\nis released. Version 2.2.0-rc03 contains these commits.\n• Fixed a failure occurring when a mocked was stored in and queried later with default factory.\n• Fix a usage of in and similar methods to be called synchronously during corresponding lifecycle event. (aosp/1156203)\n• Thanks to Anders Järleberg for contributing the fix! (aosp/1156203)\n• Thanks to Vsevolod Tolstopyatov from Jetbrains for reviewing an implementation of inlined execution.\n\nis released. Version 2.2.0-rc02 contains these commits.\n• Fixed a bug in the proguard setup of the library that affected devices running API 28+ if the target API is below 29. (b/142778206)\n\nis released. Version 2.2.0-rc01 contains these commits.\n• Fixed an issue where and related methods would run one frame later than the associated lifecycle method due to its use of instead of . (aosp/1145596)\n• Thanks to Nicklas Ansman for contributing the fix! (aosp/1145596)\n\nis released. Version 2.2.0-beta01 contains these commits.\n• Fixed a regression introduced in Lifecycle 2.2.0-alpha05 in the ordering of and the activity’s moving to started and resumed on Android 10 devices. (aosp/1128132)\n• Fixed a regression introduced in Lifecycle which would cause a when using version or of . (b/141536990)\n\nis released. Version 2.2.0-alpha05 contains these commits.\n\nis released. The commits included in this version can be found here.\n• , , , , , and the underlying implementation of now use instead of . (b/139740492)\n• Thanks to Nicklas Ansman for contributing the move to ! (aosp/1106073)\n\nis released. The commits included in this version can be found here.\n• Implementations of can now optionally implement to provide a default . This has been done for Activity , Fragment , and Navigation . (aosp/1092370, b/135716331)\n• has been deprecated. You can pass a or to the new constructor to achieve the same functionality. (aosp/1009889)\n\nis released. The commits included in this version can be found here.\n• Replaced with which will track the current emitted value of the block.\n• Added a new overload to the builder that receives parameter as type\n\nis released. The commits included in this version can be found here.\n• This release adds new features that adds support for Kotlin coroutines for Lifecycle and LiveData. Detailed documentation on them can be found here.\n\nis released. Version 1.0.0 contains these commits.\n• New SavedStateHandle class was added. It enables your classes to access and to contribute to the saved state. This object can be received in constructor of class and factories provided by default by Fragments and AppCompatActivity will inject automatically.\n• AbstractSavedStateViewModelFactory was added. It allows you to create custom factories for your and provide them access to .\n\nis released. Version 1.0.0-rc03 contains these commits.\n\nis released. Version 1.0.0-rc02 contains these commits.\n\nis released with no changes from . Version 1.0.0-rc01 contains these commits.\n\nis released. Version 1.0.0-beta01 contains these commits.\n• Fixed an issue where accessing a SavedState ViewModel for the first time in would result in an . (b/139093676)\n• Fixed an when using . (b/141225984)\n\nis released. Version 1.0.0-alpha05 contains these commits.\n• no longer extends and is created only for ViewModels that requested have it (aosp/1113593)\n\nis released. The commits included in this version can be found here.\n• no longer depends on and the related and constructors have been removed. Instead, is now the default factory for Activity , Fragment , and Navigation . (b/135716331)\n\nis released. The commits included in this version can be found here.\n\nis released. The full commit log for this initial release can be found here.\n• Now can contribute to savedstate. To do that you use newly introduced viewmodel’s factory and your ViewModel should have a constructor that receives object as a parameter.\n• Added for the cases when a stream of lifecycle events is needed. It is a public API instead of a hidden class.\n• Added , which creates a new LiveData object that does not emit a value until the source value has been changed.\n• Added coroutine support in ViewModels by adding the extension property .\n\nis released. The commits included in this version can be found here.\n\nis released with no changes from . The commits included in this version can be found here.\n\nis released. The commits included in this version can be found here.\n• Lifecycles are graduated to beta: api introduced in previous alphas such as extension functions for transformations and observations, initialisation with property delegation and others are stabilised and not going to change.\n\nis released. The commits included in this version can be found here.\n• Breaking change: the underlying API behind and has been changed to support a directly, rather than only a . (aosp/932932)\n\nis released. The full list of commits included in this version can be found here.\n• was removed. Second interface in addition to didn’t compose well with new features as property delegation in Kotlin . (aosp/914133)\n• now contains a method that replaces the now deprecated method. (aosp/880715)\n• Fixed an issue where mock instances would crash when the containing was cleared. b/122273087\n• Added for the cases when a stream of lifecycle events is needed. It is a public api instead of a hidden class.\n• Method was added. It creates a new object that does not emit a value until the source LiveData value has been changed.\n• Added , a factory for ViewModels that receives and in method.\n\nLifecycle is released with one bugfix from in ViewModel.\n• Fixed LifecycleObserver proguard rule to keep only implementations, not subinterfaces b/71389427\n• Fixed ViewModel proguard rules to allow obfuscation and shrinking\n\nFor the pre-AndroidX versions of Lifecycle that follow, include these dependencies:\n\nOnly one small change: is moved from to . This allows it to be used without the runtime dependency, e.g. in below.\n\nis a dependency of , so this change doesn’t affect directly, only modules that depend directly on , as Paging does.\n\nNew, much smaller dependencies are now available:\n• The deprecated and have now been removed - please use , or support .\n• annotations have been added to and\n• constructor has been deprecated - please use its static methods directly\n• has been deprecated - please use\n• The static method has been added to retrieve a static suitable for creating and instances."
    },
    {
        "link": "https://developer.android.com/topic/libraries/architecture/lifecycle",
        "document": "Save and categorize content based on your preferences.\n\nLifecycle-aware components perform actions in response to a change in the lifecycle status of another component, such as activities and fragments. These components help you produce better-organized, and often lighter-weight code, that is easier to maintain.\n\nA common pattern is to implement the actions of the dependent components in the lifecycle methods of activities and fragments. However, this pattern leads to a poor organization of the code and to the proliferation of errors. By using lifecycle-aware components, you can move the code of dependent components out of the lifecycle methods and into the components themselves.\n\nThe package provides classes and interfaces that let you build lifecycle-aware components—which are components that can automatically adjust their behavior based on the current lifecycle state of an activity or fragment.\n\nMost of the app components that are defined in the Android Framework have lifecycles attached to them. Lifecycles are managed by the operating system or the framework code running in your process. They are core to how Android works and your application must respect them. Not doing so may trigger memory leaks or even application crashes.\n\nImagine we have an activity that shows the device location on the screen. A common implementation might be like the following:\n\nEven though this sample looks fine, in a real app, you end up having too many calls that manage the UI and other components in response to the current state of the lifecycle. Managing multiple components places a considerable amount of code in lifecycle methods, such as and , which makes them difficult to maintain.\n\nMoreover, there's no guarantee that the component starts before the activity or fragment is stopped. This is especially true if we need to perform a long-running operation, such as some configuration check in . This can cause a race condition where the method finishes before the , keeping the component alive longer than it's needed.\n\nThe package provides classes and interfaces that help you tackle these problems in a resilient and isolated way.\n\nis a class that holds the information about the lifecycle state of a component (like an activity or a fragment) and allows other objects to observe this state.\n\nuses two main enumerations to track the lifecycle status for its associated component:\n\nThink of the states as nodes of a graph and events as the edges between these nodes.\n\nA class can monitor the component's lifecycle status by implementing and overriding corresponding methods such as , , etc. Then you can add an observer by calling the method of the class and passing an instance of your observer, as shown in the following example:\n\nIn the example above, the object implements the interface, which is explained in the following section.\n\nis a single method interface that denotes that the class has a . It has one method, , which must be implemented by the class. If you're trying to manage the lifecycle of a whole application process instead, see .\n\nThis interface abstracts the ownership of a from individual classes, such as and , and allows writing components that work with them. Any custom application class can implement the interface.\n\nComponents that implement work seamlessly with components that implement because an owner can provide a lifecycle, which an observer can register to watch.\n\nFor the location tracking example, we can make the class implement and then initialize it with the activity's in the method. This allows the class to be self-sufficient, meaning that the logic to react to changes in lifecycle status is declared in instead of the activity. Having the individual components store their own logic makes the activities and fragments logic easier to manage.\n\nA common use case is to avoid invoking certain callbacks if the isn't in a good state right now. For example, if the callback runs a fragment transaction after the activity state is saved, it would trigger a crash, so we would never want to invoke that callback.\n\nTo make this use case easy, the class allows other objects to query the current state.\n\nWith this implementation, our class is completely lifecycle-aware. If we need to use our from another activity or fragment, we just need to initialize it. All of the setup and teardown operations are managed by the class itself.\n\nIf a library provides classes that need to work with the Android lifecycle, we recommend that you use lifecycle-aware components. Your library clients can easily integrate those components without manual lifecycle management on the client side.\n\nFragments and Activities in Support Library 26.1.0 and later already implement the interface.\n\nIf you have a custom class that you would like to make a , you can use the LifecycleRegistry class, but you need to forward events into that class, as shown in the following code example:\n• Keep your UI controllers (activities and fragments) as lean as possible. They should not try to acquire their own data; instead, use a to do that, and observe a object to reflect the changes back to the views.\n• Try to write data-driven UIs where your UI controller’s responsibility is to update the views as data changes, or notify user actions back to the .\n• Put your data logic in your class. should serve as the connector between your UI controller and the rest of your app. Be careful though, it isn't 's responsibility to fetch data (for example, from a network). Instead, should call the appropriate component to fetch the data, then provide the result back to the UI controller.\n• Use Data Binding to maintain a clean interface between your views and the UI controller. This allows you to make your views more declarative and minimize the update code you need to write in your activities and fragments. If you prefer to do this in the Java programming language, use a library like Butter Knife to avoid boilerplate code and have a better abstraction.\n• If your UI is complex, consider creating a presenter class to handle UI modifications. This might be a laborious task, but it can make your UI components easier to test.\n• Avoid referencing a or context in your . If the outlives the activity (in case of configuration changes), your activity leaks and isn't properly disposed by the garbage collector.\n• Use Kotlin coroutines to manage long-running tasks and other operations that can run asynchronously.\n\nLifecycle-aware components can make it much easier for you to manage lifecycles in a variety of cases. A few examples are:\n• Switching between coarse and fine-grained location updates. Use lifecycle-aware components to enable fine-grained location updates while your location app is visible and switch to coarse-grained updates when the app is in the background. , a lifecycle-aware component, allows your app to automatically update the UI when your user changes locations.\n• Stopping and starting video buffering. Use lifecycle-aware components to start video buffering as soon as possible, but defer playback until app is fully started. You can also use lifecycle-aware components to terminate buffering when your app is destroyed.\n• Starting and stopping network connectivity. Use lifecycle-aware components to enable live updating (streaming) of network data while an app is in the foreground and also to automatically pause when the app goes into the background.\n• Pausing and resuming animated drawables. Use lifecycle-aware components to handle pausing animated drawables when the app is in the background and resume drawables after the app is in the foreground.\n\nWhen a belongs to an or , the 's state changes to and the event is dispatched when the or 's is called.\n\nWhen a or 's state is saved via , it's UI is considered immutable until is called. Trying to modify the UI after the state is saved is likely to cause inconsistencies in the navigation state of your application which is why throws an exception if the app runs a after state is saved. See for details.\n\nprevents this edge case out of the box by refraining from calling its observer if the observer's associated isn't at least . Behind the scenes, it calls before deciding to invoke its observer.\n\nUnfortunately, 's method is called after , which leaves a gap where UI state changes are not allowed but the has not yet been moved to the state.\n\nTo prevent this issue, the class in version and lower mark the state as without dispatching the event so that any code that checks the current state gets the real value even though the event isn't dispatched until is called by the system.\n\nUnfortunately, this solution has two major problems:\n• On API level 23 and lower, the Android system actually saves the state of an activity even if it is partially covered by another activity. In other words, the Android system calls but it doesn't necessarily call . This creates a potentially long interval where the observer still thinks that the lifecycle is active even though its UI state can't be modified.\n• Any class that wants to expose a similar behavior to the class has to implement the workaround provided by version and lower.\n\nTo learn more about handling lifecycles with lifecycle-aware components, consult the following additional resources."
    },
    {
        "link": "https://stackoverflow.com/questions/49934658/viewmodel-in-kotlin-unresolved-reference",
        "document": "I am trying to implement ViewModel in a 100% Kotlin app. Every piece of documentation I can find says I want to use this to get the ViewModel instance:\n\nAccording to the docs, I should be able to import this with:\n\nThis import is unresolved though. I am using the following in my build file:"
    },
    {
        "link": "https://mvnrepository.com/artifact/androidx.lifecycle/lifecycle-livedata-core/2.3.1",
        "document": ": There is a new version for this artifact"
    },
    {
        "link": "https://geeksforgeeks.org/jetpack-architecture-components-in-android",
        "document": "Android Jetpack is a set of software components, libraries, tools, and guidance to help in developing robust Android applications. Launched by Google in 2018, Jetpack comprises existing android support libraries, android architecture components with an addition of the Android KTX library as a single modular entity. Nowadays, nearly 99% of the apps present on the Google Play Store uses Android Jetpack libraries. Moreover, to deal with changes/updates in data and application lifecycle, Google introduced Architecture components. This article explains each and every library of this component in detail. Jetpack consist of a wide collection of libraries that are built in a way to work together and make robust mobile applications. Its software components have been divided into 4 categories:\n\nFurther, Architecture Components could be classified as follows:\n\nAndroid Jetpack with its architecture component defines some key principles which one should follow as a secure path to develop good and robust mobile apps. It does not support any particular architecture pattern but suggests a clear separation of concerns and controlling of UI from Model. By following these rules, developers can avoid problems related to lifecycle and it will be easy to test and maintain the application.\n\nFollowing are the architecture component’s element and their responsibilities\n• View layer is represented by the . They only deal with user interaction and observes as well as exhibits the LiveData element which is taken from the ViewModel\n• ViewMode l keeps a check on the Lifecycle of View and is responsible for maintaining data consistency during configuration changes in the device or other android lifecycle events.\n• Repository is a class with no proper implementation and is responsible for gathering data from all the sources. It handles all the data and transforms them into observable LiveData and makes it accessible to ViewModel.\n• Room is an SQLite mapping library that overcomes the challenges of like writing boilerplate codes, and query checking at compile time. It has the ability to return queries directly with observable LiveData\n\nWays to include Android Jetpack libraries in the application\n• None All Jetpack components are available in the Google Maven repository, include them in the build.gradle\n\nThe requirement of a database in Android is fulfilled by SQLite from the very beginning. However, it comes with some severe drawbacks like not checking the queries at compile-time, it does not save plain-old-Java Objects(commonly referred to as POJOs). Developers also need to write a lot of boilerplate code to make the SQLite database work in the Android OS environment. The Room component comes into the picture as an SQLite Object Mapping Library which overcomes all the mentioned challenges. Room converts queries directly into objects, check errors in queries at the compile-time, and is also capable of persisting the Java POJOs.\n\nMoreover, it produces LiveData results/observables from the given query result. Because of this versatile nature of the Room component, Google officially supports and recommends developers to use it. The Room consists of the following sub-components:\n• Entity: It is the annotated class for which the Room creates a table within the database. The field of the class represents columns in the table.\n• DAO(Data Access Object): It is responsible for defining the methods to access the database and to perform operations.\n• Database: It is an abstract class that extends RoomDatabase class and it serves as the main access point to the underlying app’s relational data.\n\nWorkManager API provides an optimal solution to manage the background tasks in Android which are deferrable(can be run later and is still useful) as well as guaranteed(runs even if the device restarts) in nature. Its capability to cover the power-saving feature of Android and the ability to run with or without Google Play Services are the reasons for its popularity among developers. Further, it is also backward compatible with API level 14.\n\nThe ability of android devices to download a file/document in chunks i.e., occasionally(like user resumes download as per the availability of the WiFi Network) and the feature of saving the downloaded state even if the device restarts is possible only because of WorkManager API. Its execution of tasks depends upon the order of requests made by the user and for each work request, it returns the state which is displayed on the UI of the device.\n• None Scheduling and chaining of tasks is possible\n• None Users can keep track of/status of the tasks.\n\nDetails of the lifecycle state of an android component are stored in the Lifecycle class and it permits other components/objects to observe this state. An android component is lifecycle-aware if it has the ability to detect the change in the lifecycle state of other components and respond accordingly. Proper management of application lifecycles is a challenging task for the developers as it can lead to severe issues like memory leaks and app crashing. The android.arch.lifecycle package facilitates the developers by managing the lifecycles attached to the components directly by the system. By implementing the LifecycleObserver interface within the desired class, it can be configured to be lifecycle-aware.\n\nThere are 2 ways to create Activity / Fragment which are Lifecycle aware:\n• None Ease in testing and maintenance of components\n\nViewModel is one of the most critical classes of the Android Jetpack Architecture Component that support data for UI components. Its purpose is to hold and manage UI-related data. Moreover, its main function is to maintain the integrity and allows data to service during configuration changes like screen rotations. Any kind of configuration change in Android devices tends to recreate the whole activity of the application. It means the data will be lost if it has been not saved and restored properly from the activity which was destroyed. To avoid these issues, it is recommended to store all UI data in the ViewModel instead of an activity.\n\nAn activity must extend the ViewModel class to create a view model:\n• None Helps in data management during configuration changes\n\nThis component is an observable data holder class i.e, the contained value can be observed. LiveData is a lifecycle-aware component and thus it performs its functions according to the lifecycle state of other application components. Further, if the observer’s lifecycle state is active i.e., either STARTED or RESUMED, only then LiveData updates the app component. LiveData always checks the observer’s state before making any update to ensure that the observer must be active to receive it. If the observer’s lifecycle state is destroyed, LiveData is capable to remove it, and thus it avoids memory leaks. It makes the task of data synchronization easier.\n\nIt is necessary to implement onActive and onInactive methods by LiveData:\n\nIn order to observe a LiveData Component observer(LifecycleOwner, Observer<T>) method is called:\n• None UI is updated as per the appropriate change in the data\n• None It removes the stopped or destroyed activities which reduce the chance of app crash\n• None No memory leaks as LiveData is a lifecycle-aware component.\n\nThe navigation component of Android architecture is a framework for designing the in-app UI. Developers can follow the single-activity app architecture to structure the application UI. Navigation manages the complexity related to the fragment transactions in the application. It also facilitates developers to display transitions and Back behavior.\n\nBy using the Navigation Component, one can get all the benefits of other Architecture components as well like Lifecycle and ViewModel. It helps in implementing basic navigation styles like simple button clicks to complex navigation patterns like app bar and navigation drawer. Further, it also supports deep links and helpers which enables the connection of this component with the navigation drawer and bottom navigation.\n• None Support common as well as a complex navigation pattern\n\nWhile developing an android application, it is very much important to organize the data loading process. Mostly, apps display one activity/fragment at a time and thus require to load and display only a small section of data. However, at the same time, the application is processing a large dataset that is currently of no use. Thus, it is a critical area of the application which must be handled, otherwise can lead to waste of the device’s battery and the network bandwidth.\n\nThe Paging library of the Android architecture component provides the optimal solution to these issues. This library provides the facility to load the application data slowly and in a cautious manner. Moreover, paging is a very cooperative library for those applications in which the displayed data is updating continuously as it provides a list of unbounded sites as well as large but bounded lists. Following are the three common ways of loading data through the paging library:\n• None Loading data is stored in the device database\n• None Loading data over a network by serving as a cache for the database\n• None Load data by serving from the back-end server\n• None Easy to integrate with Recycler View in order to display a large data set.\n• None Compatible with LiveData and RxJava for updating the UI data\n\nData Binding library is a support library that provides the feature of binding UI components in an activity/fragment to the data sources of the application. The library carries out this binding task in a declarative format and not in a programmatical way. Below is an example to understand the working of this library accurately:\n\nTo find a TextView widget and bind it to the userName property of the ViewModel variable, the findViewById() method is called:\n\nAfter using the Data Binding library, the above code changes by using the assignment expression as follows:\n• None Make code simpler and easy to maintain by removing UI frameworks called in the activity.\n• None Allows classes and methods to observe changes in data\n• None Allows to make objects and filled which works as collection observable.\n\nClick Here to learn more about Android Jetpack Compose"
    },
    {
        "link": "https://developer.android.com/jetpack/androidx/releases/lifecycle",
        "document": "Save and categorize content based on your preferences.\n\nLifecycle-aware components perform actions in response to a change in the lifecycle status of another component, such as activities and fragments. These components help you produce better-organized, and often lighter-weight code, that is easier to maintain.\n\nThis table lists all the artifacts in the group.\n\nThis library was last updated on: March 12, 2025\n\nTo add a dependency on Lifecycle, you must add the Google Maven repository to your project. Read Google's Maven repository for more information.\n\nAdd the dependencies for the artifacts you need in the file for your app or module:\n\nFor more information about dependencies, see Add Build Dependencies.\n\nYour feedback helps make Jetpack better. Let us know if you discover new issues or have ideas for improving this library. Please take a look at the existing issues in this library before you create a new one. You can add your vote to an existing issue by clicking the star button.\n\nSee the Issue Tracker documentation for more information.\n\nis released. Version 2.9.0-alpha12 contains these commits.\n• Add annotation to in all supported KMP platforms. (I7e8dd, b/397736115)\n\nis released. Version 2.9.0-alpha11 contains these commits.\n\nis released. Version 2.9.0-alpha10 contains these commits.\n• Adds a new Lint issue for calling in composition, instead suggesting using to ensure that changes in the Lifecycle state correctly cause recomposition. Thanks Steven Schoen! (Iad484)\n\nis released. Version 2.9.0-alpha09 contains these commits.\n• is deprecated as it creates a for every , causing unnecessary overhead. Use with instead for more efficient creation. (Ia920b, b/388590327)\n\nis released. Version 2.9.0-alpha08 contains these commits.\n• Add to simulate a System Process Death recreating the under test and all associated components. (Id6a69, b/381063087)\n• and instances retrieved via their respective APIs can now be resolved through disjoint parents of a view, such as a . See the release notes of core or the documentation in for more information on disjoint view parents. (I800f4)\n• Make the namings and package organization more consistent with (I8c135, b/376026744)\n• This library now uses JSpecify nullness annotations, which are type-use. Kotlin developers should use the following compiler arguments to enforce correct usage: (Ie4340, b/326456246)\n\nis released. Version 2.9.0-alpha07 contains these commits.\n• Lifecycle is now KMP compatible. This allows you to use in common code. (Ib6394, b/334076622)\n• None With the support of KotlinX Serialization added in SavedState , we have introduced , a lazy property delegate, to make it easy to store classes in a and have those classes automatically be restored across process death and recreation. Please note the delegate is lazy and will not call the lambda or save anything into the until it is accessed. (I47a88, b/376026744)\n• Add to to return a . This new function is key-exclusive and cannot be used with . An exception will be thrown if you try to use both to access the same state. (I04a4f, b/375408415)\n\nis released. Version 2.9.0-alpha06 contains these commits.\n• The state is terminal, and any attempt to move a from it to any other state will now result in an . (I116c4, b/370577987)\n• no longer includes any where the returned is empty. (I910b5, b/370577987)\n• now correctly complete when is (I293b2, b/374043130)\n\nis released with no notable changes. Version 2.9.0-alpha05 contains these commits.\n\nis released. Version 2.9.0-alpha04 contains these commits.\n• The module is now configured to be KMP compatible in preparation for APIs like being made available in the common source set in a future release. (I503ed, I48764, b/334076622)\n\nis released. Version 2.9.0-alpha03 contains these commits.\n• From Lifecycle : The Lint error has improved support for smart casts, avoiding false positives. (85fed6, b/181042665)\n• From Lifecycle : Lifecycle Runtime Compose now depends on Compose Runtime\n\nis released. Version 2.9.0-alpha02 contains these commits.\n• From Lifecycle : Update the ProGuard rules to allow obfuscation . (ff898e1)\n• Move to common source set (KMP). Thanks Ivan Matkov from JetBrains for the contribution. (8cd5d03)\n• From Lifecycle : SavedStateHandle.saveable` extension delegate now supports nullable values. Thanks Roman Kalukiewicz for the contribution. (0d78ea6)\n\nis released. Version 2.9.0-alpha01 contains these commits.\n• A new KMP artifact is available that provides a class for testing ViewModels in isolation, with support for (all platforms) and (Android only). (337f68d, c9b3409, 9799a95c, b/264602919)\n• Creating a with is now thread safe; annotations have been removed. (Ifd978, b/237006831)\n• Add the factory function to simplify the creation of anonymous objects. (I970ee)\n• now includes map-like operator overloads to enable idiomatic manipulation of content in Kotlin. It allows the use of , , and with . (Ib4353)\n• is now available on JVM Desktop and Android targets. (d3d0892)\n• Removed manual outlining of access to new platform APIs since this happens automatically via API modeling when using R8 with AGP 7.3 or later (e.g. R8 version 3.3) and for all builds when using AGP 8.1 or later (e.g. D8 version 8.1). Clients who are not using AGP are advised to update to D8 version 8.1 or later. See this article for more details. (If6b4c, b/345472586)\n\nis released. Version 2.8.7 contains these commits.\n• is now available in the common source set (KMP). (6a3f5b3)\n• : artifacts were removed and and artifacts were added. None of these targets are meant to be used, they are placeholders to help Jetbrains Compose efforts. (6a3f5b3)\n\nis released. Version 2.8.6 contains these commits.\n• The Lint error has improved support for smart casts, avoiding false positives. (85fed6, b/181042665)\n\nis released. Version 2.8.5 contains these commits.\n• Update the ProGuard rules to allow obfuscation . (ff898e1)\n• extension delegate now supports nullable values. Thanks Roman Kalukiewicz for the contribution. (0d78ea6)\n\nis released. Version 2.8.4 contains these commits.\n• now correctly handles cases where the returned Flow is immediately completed after receiving a value already set on the (for example, when using ). (I9c566)\n• completion is now idempotent (i.e., if the was called because of the Lifecycle being stopped, it won’t be called a second time upon disposal unless the Lifecycle goes back up to again). (I5f607, b/352364595)\n\nis released. Version 2.8.3 contains these commits.\n• Fixed an issue with Lifecycle 2.8’s backward compatibility with Compose 1.6.0 and lower when using code shrinking. (aosp/3133056, b/346808608)\n\nis released. Version 2.8.2 contains these commits.\n• Fixed errors when using Lifecycle 2.8.X with Compose 1.6.X or earlier - you can now use Lifecycle 2.8.2 with any version of Compose without any workarounds required. (aosp/3105647, b/336842920)\n• will no longer crash when mixing previous versions of Lifecycle dependencies with versions 2.8+, fixing issues with libraries such as LeakCanary. (I80383, b/341792251)\n\nis released. Version 2.8.1 contains these commits.\n• now only has a common dependency on , removing its common dependency on . The Android artifact retains its for compatibility. (aosp/3079334, b/339562627)\n• ’s integration using property delegates now uses the class name as part of the auto-generated key, avoiding conflicts if multiple classes use the same . (aosp/3063463)\n\nis released. Version 2.8.0 contains these commits.\n• has been moved from Compose UI to so that its Compose-based helper APIs can be used outside of Compose UI.\n• The artifact now contains the and APIs which allow you to drop click or other events that occur even after the has dropped below the given . For example, this can be used with Navigation Compose to avoid handling click events after a transition to another screen has already begun:\n• None is now an overridable constructor parameter, allowing you to inject your own dispatcher and or to override the default by using the available within . (I2817c, b/264598574) // Make Dispatchers.Main the default, rather than Dispatchers.Main.immediate // Use viewModelScope as before, without any code changes // Allows overriding the viewModelScope in a test\n• None has been rewritten in Kotlin and now uses instead of . It now supports adding objects with a that allows retrieving them via .\n• None Calling and without a key is now an error, following the same convention as the API that these APIs mirror.\n• None The kotlin extensions have now been moved to the module.\n• None The has been refactored to avoid many false positives.\n\nThe core Lifecycle APIs in , , , , , and are now shipped in artifacts compatible with Kotlin Multiplatform.\n• moves most APIs to and supports jvm and iOS in addition to Android.\n• moves most APIs to and supports jvm and iOS in addition to Android.\n• is now empty, with all APIs being moved into .\n• moves all APIs to and ships an Android artifact, matching the multiplatform support of .\n\nThe artifact and APIs like , , , and are now shipped in artifacts compatible with Kotlin Multiplatform.\n\nTo accommodate this change, methods such as those on that took a now have an equivalent method that takes a .\n\nBinary compatibility on Android has been maintained, but there are a few notable changes when comparing the Android API surface to the common API surface:\n• Constructing a instance is now done through the methods rather than directly calling its constructor.\n• and are only available on Android.\n• Custom Factories are recommended to extend from and use the method that takes a or use the Kotlin DSL.\n• Using without a custom factory on non-JVM platforms will result in an . On JVM platforms, compatibility is preserved by using the no-args ViewModel constructor if a custom factory is not provided.\n• will fallback to an in platforms where is not available (e.g., Linux).\n• moves most APIs to and supports jvm and iOS in addition to Android.\n• is now empty, with all APIs being moved into .\n• moves all APIs to and ships an Android artifact, matching the multiplatform support of .\n\nis released. Version 2.8.0-rc01 contains these commits.\n• Fixed an issue where the Baseline Profile for classes was not properly packaged. These are now packaged in the AAR. (aosp/3038274, b/322382422)\n• Fixed an unintentional ordering change in how instances attached to a ViewModel are cleared - the previous order of , then , then has been restored. (aosp/3041632)\n• Improve the default creation behavior for for native and JVM Desktop environments. (aosp/3039221)\n• Thanks Victor Kropp for improving the checking for the main thread on JVM Desktop. (aosp/3037116)\n\nis released. Version 2.8.0-beta01 contains these commits.\n• The artifact is now compatible with Kotlin Multiplatform, moving its code to and ships an Android artifact, matching the multiplatform support for . (If7a71, I4f4a0, b/331769623)\n\nis released. Version 2.8.0-alpha04 contains these commits.\n• The artifact is now compatible with Kotlin Multiplatform, moving its code to and ships an Android artifact, matching the multiplatform support of . The accommodate this change, the Composable method now accepts a in addition to a . (b/330323282)\n• The has been refactored to avoid many false positives. (I2d8c1, Iafb18, I03463, I7ecef)\n• The artifact now depends on Compose 1.6.0.\n\nis released. Version 2.8.0-alpha03 contains these commits.\n• None is now an overridable constructor parameter, allowing you to inject your own dispatcher and or to override the default by using the available within . (I2817c, b/264598574) // Make Dispatchers.Main the default, rather than Dispatchers.Main.immediate // Use viewModelScope as before, without any code changes // Allows overriding the viewModelScope in a test\n\nThe artifact and APIs like , , , and are now shipped in artifacts compatible with Kotlin Multiplatform. (b/214568825)\n\nTo accommodate this change, methods such as those on that took a now have an equivalent method that takes a .\n\nBinary compatibility on Android has been maintained, but there are a few notable changes when comparing the Android API surface to the common API surface:\n• Constructing a instance is now done through the methods rather than directly calling its constructor.\n• and are only available on Android.\n• Custom Factories are recommended to extend from and use the method that takes a or use the Kotlin DSL.\n• Using without a custom factory on non-JVM platforms will result in an . On JVM platforms, compatibility is preserved by using the no-args ViewModel constructor if a custom factory is not provided.\n• will fallback to an in platforms where is not available (e.g., Linux).\n• now handles duplicated keys: if the already has an resource associated with it, the old resource will be replaced and closed immediately. (Ibeb67)\n• Accessing the of a is now thread safe. (If4766, b/322407038)\n• moved from Compose UI to lifecycle-runtime-compose so that its Compose-based helper APIs can be used outside of Compose UI. Thanks Jake Wharton for the contribution. (I6c41b, b/328263448)\n\nis released. Version 2.8.0-alpha02 contains these commits.\n• The and APIs have been added which allow you to drop click or other events that occur even after the has dropped below the given . For example, this can be used with Navigation Compose to avoid handling click events after a transition to another screen has already begun: (Icba83, b/317230685)\n• is now written in Kotlin (I16f26, b/214568825)\n• The kotlin extensions have now been moved to the base lifecycle module. (Id787b, b/274800183)\n• The kotlin extensions have now been moved to the base lifecycle module. (Ic3686, b/274800183)\n• The kotlin extensions have now been moved to the base lifecycle module. (I54a3d, b/274800183)\n• The core Lifecycle APIs in , , , , , and are now shipped in artifacts compatible with Kotlin Multiplatform. (b/317249252)\n• Calling and without a key is now an error, following the same convention as the API that these APIs mirror. (Ib0e0c, b/323518079)\n• now uses instead of . That is a backward compatible change. (I27f8e, b/214568825)\n• Thanks Ivan Matkov from Jetbrains for helping move Lifecycle to Kotlin Multiplatform. (aosp/2926690, I0c5ac, If445d)\n\nis released. Version 2.8.0-alpha01 contains these commits.\n• now supports adding objects with a that allows retrieving them via . (I3cf63)\n\nis released. Version 2.7.0 contains these commits.\n• now includes a suspending function which ensures that the state change and all callbacks are completed before returning. Notably, unlike setting the property directly, this does not use , making it safe to use within a coroutine such as one provided by .\n• The extensions of and now mirror the behavior of - if the has a set, the / function will be immediately called to populate the of the returned . This ensures that the initial value will be set as part of the first composition (when used with ), but does not change the observation behavior - updates values from the source will still only apply once you start observing the .\n• This release fixes an issue where would not properly restore custom classes after process death and recreation. Due to type information that is lost by the Android framework, arrays of custom Parcelables require additional work (manually creating a typed array of the right type) and the documentation on , , and now specifically calls this limitation out.\n• The proguard keep rules associated with have been removed. This means that proguarded code that wishes to use APIs via reflection (such as using the long since deprecated annotation) will need to provide their own keep rules for their specific use case.\n• As an alternative to using a , you can now observe a of via the extension method.\n• Jetpack Compose users can now use to run Compose side effects based on .\n• Jetpack Compose users can use and to handle pairs of events - started to stopped and resumed to paused, respectively. This API mirrors the one found in and is suitable for cases where the change being made when the state is going up needs to be reversed when going back down.\n\nSee Run code on lifecycle events for more information.\n• The current can now be observed via the property, which returns a where the is the current .\n• Jetpack Compose users can use the extension to directly expose as Compose . This is equivalent (and a shorter alternative) to .\n\nSee Collect lifecycle state with flows for more information.\n\nis released. Version 2.7.0-rc02 contains these commits.\n• Fixed an issue where would not properly restore custom classes after process death and recreation. Due to type information that is lost by the Android framework, arrays of custom Parcelables require additional work (manually creating a typed array of the right type) and the documentation on , , and now specifically calls this limitation out. (I0b55a)\n\nis released. Version 2.7.0-rc01 contains these commits.\n• and now correctly dispose and recreate the effect block if the is changed. (Ia25c6)\n\nis released with no changes. Version 2.7.0-beta01 contains these commits.\n• A beta version bump, no major changes to this release version.\n\nis released. Version 2.7.0-alpha03 contains these commits.\n• now contains a new Lint check to avoid setting the of the by using the field when inside of a coroutine. The Lint check now suggests the suspending which allows setting the without blocking. (Icf728, b/297880630)\n• Fixed an issue with where returning the same instance both on the initial call and a subsequent call would prevent the instance from being added as a source. (Ibedcba7)\n\nis released. Version 2.7.0-alpha02 contains these commits.\n• now includes the suspending function to give users the option of using from within a coroutine such as one provided by . (I329de, b/259344129)\n• All files from the modules have been moved into the main module. (I10c6f, b/274800183)\n• The and extensions now sets the of the returned if the previous has had a value set on it, ensuring that using the resulting LiveData in Jetpack Compose has the right state on the initial composition. (I91d2b, b/269479952)\n• 's now immediately closes the if the has already received a call to . (I4712e, b/280294730)\n• From Lifecycle : Fixed an issue where would not correctly be restored after process death if the state was restored, was called without actually saving the state in the parent , and then the state was restored again. This fixes the interaction between and Navigation Compose’s . (aosp/2729289)\n\nis released. Version 2.7.0-alpha01 contains these commits.\n• is now Compose-observable via , which returns a where the is the current . (Ib212d, b/209684871)\n• s can now able to be observed as a with (If2c0f, b/176311030)\n• API has been added to run Compose s based on both and event callbacks. (I60386, b/235529345)\n• API has been added to run Compose s based on and event callbacks. (I5a8d1, b/235529345)\n• API has been added to run Compose s based on . (Ic9794, b/235529345)\n• extension has been added to directly expose as Compose . This is equivalent (and a shorter alternative) to . (I11015, b/235529345)\n• The extension now sets the of the returned if the previous has had a value set on it. This does not change the observation behavior - updated values from the source will still only apply once you start observing the returned from . (Ib482f)\n• The proguard keep rules associated with have been removed. This means that proguarded code that wishes to use APIs via reflection will need to provide their own keep rules for their specific use case. (Ia12fd)\n\nis released. Version 2.6.2 contains these commits.\n• Fixed an issue where would not correctly be restored after process death if the state was restored, was called without actually saving the state in the parent , and then the state was restored again. This fixes the interaction between and Navigation Compose’s . (aosp/2729289)\n\nis released. Version 2.6.1 contains these commits.\n\nis released. Version 2.6.0 contains these commits.\n• now includes a new property that indicates whether an explicit value has ever been set on the , allowing you to distinguish between returning because no value has ever been set or an explicit value.\n• now includes a constructor to set an initial value.\n• Added a new extension on and of that collect from flows and represents its latest value as Compose State in a lifecycle-aware manner.\n• methods and methods have been deprecated as the use of a pausing dispatcher can lead to wasted resources in some cases. It is recommended to use . For more information about one-time suspending work, please see this explanation on why this is inherently unsafe.\n• Kotlin Conversion - A large number of Lifecycle classes have been converted to Kotlin. All converted classes still retain their binary compatibility with previous versions. The following classes have source incompatible changes for classes written in Kotlin: , , , , , ,\n\nThe table below provides the source conversions for the new version of lifecycle.\n• The nullability of the method of a created in Kotlin now matches the nullability of the generic type. If you want to accept a nullable type, you must instantiate the with a nullable type.\n• These classes were also converted to Kotlin, but remain source compatible: , , , , , , , , , , and\n\nis released. Version 2.6.0-rc01 contains these commits.\n• The extension now sets the of the returned if the previous has had a value set on it. This does not change the observation behavior - updated values from the source will still only apply once you start observing the returned from . (Ib482f)\n\nis released. Version 2.6.0-beta01 contains these commits.\n• is now written in Kotlin. This is a source incompatible change for classes written in Kotlin - they must now override the property rather than implementing the previous function. (I75b4b, b/240298691)\n• is now in Kotlin. This is a source incompatible change for classes written in Kotlin - they must now override the property rather than implementing the previous function. (I86409, b/240298691)\n• The Kotlin extension on that provides the field has been moved to the artifact from . (I41d78, b/240298691)\n• The Kotlin extension on that provides the field has been moved to the artifact from . (Iabb91, b/240298691)\n\nis released. Version 2.6.0-alpha05 contains these commits.\n• is now written in Kotlin. This is a source incompatible change for those classes written in Kotlin that were directly using syntax such as - Kotlin code must now use the Kotlin extension method syntax that was previously only available when using . When using the Java programming language, the versions of these methods that take an method are deprecated and replaced with the versions that take a Kotlin . This change maintains binary compatibility. (I8e14f)\n• is now written in Kotlin. This is a source incompatible change for those classes written in Kotlin - you must now directly import and use the Kotlin extension methods on of and to set and find a previously set owner. This is binary compatible and remains source compatible for implementations written in the Java programming language. (Ia06d8, Ib22d8, b/240298691)\n• The interface is now written in Kotlin. This is a source incompatible change for classes written in Kotlin - they must now override the and properties rather than implementing the previous corresponding functions. (Iaed9c, b/240298691)\n• is now written in Kotlin. Its method now uses the name for its parameter. (Iffef2, I4995e, b/240298691)\n• , , , , and are now written in Kotlin (I2e771, Ibae40, I160d7, I08884, I1cda7, b/240298691)\n\nis released. Version 2.6.0-alpha04 contains these commits.\n• now includes a new property that indicates whether an explicit value has ever been set on the , allowing you to distinguish between returning because no value has ever been set or an explicit value. (Ibd018)\n• The APIs of are no longer in experimental status. (I09d42, b/258835424)\n• methods and methods have been deprecated as the use of a pausing dispatcher can lead to wasted resources in some cases. It is recommended to use . (Iafc54, b/248302832)\n• is now written in Kotlin. This is a source incompatible change for those classes written in Kotlin - you must now directly import and use the Kotlin extension methods on of and to set and find a previously set owner. This replaces the previous Kotlin extension in . This is binary compatible and remains source compatible for implementations written in the Java programming language. (I8a77a, I5234e, b/240298691)\n• is now written in Kotlin. The Kotlin extensions previously in have been moved into the module and have become the primary surface for code written in Kotlin. This is a source incompatible change for code written in Kotlin if you were not already using the Kotlin extension method APIs. (I2b1b9, I95d22, b/240298691)\n• , , , , , and are now written in Kotlin (Iadffd, (I60034, I8c52c, I9593d, I01fe1, I59a23, b/240298691)\n• no longer crashes with a when calling with the incorrect class type. (I6ae7c)\n\nis released. Version 2.6.0-alpha03 contains these commits.\n• Fixed an issue with constraints between different Lifecycle modules not working as intended. (I18d0d, b/249686765)\n• Errors thrown by now include a more helpful error messaging that informs developers of the component causing the error. (Idf4b2, b/244910446)\n\nis released. Version 2.6.0-alpha02 contains these commits.\n• now includes a constructor to set an initial value. (Ib6cc5, b/151244085)\n• artifacts now include constraints that ensure that all inter-dependent Lifecycle artifacts use the same version, automatically upgrading other dependencies when one is upgraded. b/242871265\n• now creates a rather than using its own implementation to ensure thread-safety and context preservation. (I4a8b2, b/200596935)\n• 's function will now preserve the initial value of a when creating the new object. (I3f530, b/157380488)\n• From Lifecycle : Custom implementations of now correctly calls the function when using the stateful constructor with 2.4+ (I5b315, b/238011621)\n\nis released. Version 2.6.0-alpha01 contains these commits.\n• Added a new extension on and of that collect from flows and represents its latest value as Compose State in a lifecycle-aware manner. The flow is collected and the new emission is set to the State's value when the lifecycle is at least in a certain . When the lifecycle falls below that , the flow collection stops and the State's value is not updated. (I1856e, b/230557927)\n\nis released. Version 2.5.1 contains these commits.\n• Custom implementations of now correctly call the function when using the stateful constructor with 2.4+. (I5b315, b/238011621)\n\nis released. Version 2.5.0 contains these commits.\n• None now offers a API that returns a Kotlin for monitoring value changes as an alternative to using .\n• None ViewModel CreationExtras - when writing a custom , it is no longer required to extend or to gain access to an or , respectively. Instead, these fields are provided to every subclass as via the new overload of : . These extras are provided automatically by your Activity or Fragment when using Activity and Fragment , respectively. < > // Get the Application object from extras // Create a SavedStateHandle for this ViewModel from extras >\n• None now provides a Kotlin DSL that allows you define your in terms of one or more lambda initializers, one for each particular class your custom factory supports, using as the primary data source. // The return type of the lambda automatically sets what class this lambda handles // Get the Application object from extras provided to the lambda\n• None now offers a API that takes a lambda factory for creating a instance without requiring the creation of a custom . // Within a @Composable, you can now skip writing a custom Factory // and instead write a lambda to do the initialization of your ViewModel // This lambda is only called the first time the ViewModel is created // and all CreationExtras are available inside the lambda\n• None SavedStateHandle Compose Saver Integration - the artifact now contains new experimental APIs in that allow like behavior backed by the of a `ViewModel. // This value survives both configuration changes and process death and recreation\n• None Added an API and a new constructor overload that allow you to add one or more objects to the that will be closed when the is cleared without requiring any manual work in . For instance, to create a coroutine scope that you can inject into a ViewModel, but control via testing, you can create a that implements : Which can then be used in your constructor while maintaining the same lifetime as : // You can now use customScope in the same way as viewModelScope\n• Attempting to move the from to will now always throw an regardless of whether the has an attached observer.\n• will now clear their observers when they reach the state.\n\nis released. Version 2.5.0-rc02 contains these commits.\n• will no longer crash when mixing previous versions of compileOnly Lifecycle dependencies with versions 2.5+. (I81a66, b/230454566)\n\nis released. Version 2.5.0-rc01 contains these commits.\n• now throws a when passed a source instead of propagating the source to observers.(Ibd0fb, b/123085232)\n\nis released. Version 2.5.0-beta01 contains these commits.\n• Added property delegates to use property names as keys for persisting state into the (I8bb86, b/225014345)\n• Fixed an issue where nesting one within another in a non-primary bottom navigation tab would lead to an when using multiple back stacks. (I11bd5, b/228865698)\n\nis released. Version 2.5.0-alpha06 contains these commits.\n• Add experimental overload to for parity with (I38cfe, b/224565154)\n• is now abstract instead of sealed. (Ib8a7a)\n\nis released. Version 2.5.0-alpha05 contains these commits.\n• The module now provides , an experimental API that ensures values in a are integrated correctly with the same saved instance state that uses. (Ia88b7, b/195689777)\n• Fixed a compatibility issue with Lifecycle 2.3 and newer Lifecycle versions in Java. (I52c8a, b/219545060)\n• now supports using even when it was initialized with a . If extras are provided, the initialized arguments are ignored. (I6c43b, b/224844583)\n\nis released. Version 2.5.0-alpha04 contains these commits.\n• now offers a API that returns a Kotlin for monitoring value changes as an alternative to using . (Iad3ab, b/178037961)\n\nis released. Version 2.5.0-alpha03 contains these commits.\n• Added an API and a new constructor overload that allow you to add one or more objects to the that will be closed when the is cleared without requiring any manual work in . (I55ea0)\n• now provides an that allows you to add lambda for handling particular classes, using as the primary data source. (If58fc, b/216687549)\n• now offers a API that takes a lambda factory for creating a instance without requiring the creation of a custom . (I97fbb, b/216688927)\n• You can now create a with via . (I08887, b/216688927)\n• Attempting to move the from to will now always throw an regardless of whether the has an attached observer. (I7c390, b/177924329)\n• will now clear their observers when they reach the state. (I4f8dd, b/142925860)\n\nis released. Version 2.5.0-alpha02 contains these commits.\n• and have been converted to Kotlin. This has improved the nullability of the generics in both classes. (Ib6ce2, b/216168263, I9647a, b/177667711)\n• The function parameter can now have a nullable output. (I40396, b/132923666)\n• The -ktx extensions are now annotated with to enforce that the result is used when calling these functions. (Ia0f05, b/207325134)\n• now properly stores the defaultValue when no value for the specified key exists. (I1c6ce, b/178510877)\n• From Lifecycle : Updated to depend on Startup 1.1.1 to ensure that fixes that prevent from throwing a are available by default. (Ib01df, b/216490724)\n• There is now an improved error message when custom classes have parameters in the wrong order and attempt to create a . (I340f7, b/177667711)\n• You can now create a view model via using the without setting an application. (I6ebef, b/217271656)\n\nis released. Version 2.5.0-alpha01 contains these commits.\n\nWith this release, we are laying the groundwork for restructuring how a is constructed. Instead of a rigid set of subclasses of that each add additional functionality (allowing an constructor parameter via , allowing a constructor parameter via and , etc.), we are moving to a world of stateless factories that rely on a new concept, . (Ia7343, b/188691010, b/188541057)\n\nWith this change, no longer makes direct calls into the previous method of . Instead, it calls into a new overload of : . This means that any direct implementation of the instance now has access to each of these new :\n• : this provides access to the custom key you passed to .\n• provides access to the class.\n• provides access to the that is being used to construct this ViewModel.\n• provides access to the that is being used to construct this ViewModel.\n• provides access to the of arguments that should be used to construct a .\n\nThese extras are provided by default when using Activity , Fragment , and Navigation . If you use an earlier version of those libraries, your will be empty - all of the existing subclasses of have been rewritten to support both the legacy creation path used by earlier versions of those libraries and the path which will be used going forward.\n\nThese allow you to construct a that passes just the information you need to each without relying on a strict hierarchy of Factory subclasses:\n\nWe use the Kotlin extension function on from to construct a only for the one ViewModel that needs it. (Ia6654, b/188541057)\n\nCustom can be provided by overriding in your or , thus making them available to your custom as a built in form of assisted injection. These extras will automatically be made available to your custom Factory when used directly with or when using the and Kotlin property extensions. (I79f2b, b/207012584, b/207012585, b/207012490)\n• Fixed an issue where the default value provided to a would reappear after process death and recreation, even if it was specifically removed from the . As a consequence of this, will no longer merge default values and restored values together, instead only using the restored values as the source of truth. (I53a4b)\n\nis released. Version 2.4.1 contains these commits.\n• Backported from Lifecycle : Fixed an issue where the default value provided to a would re-appear after process death and recreation, even if it was specifically removed from the . As a consequence of this, will no longer merge default values and restored values together, instead only using the restored values as the source of truth. (I53a4b)\n• now depends on Androidx Startup 1.1.1 which fixed a regression in where using would cause an . (b/216490724)\n\nis released. Version 2.4.0 contains these commits.\n• was deprecated. or should be used instead.\n• library was added. It provides composable and .\n• Source-breaking change: has been rewritten in Kotlin. method no longer allows nullable generic.\n• New coroutines API were added to :\n• , API that executes a block of code in a coroutine when the Lifecycle is at least in a certain state. The block will cancel and re-launch as the lifecycle moves in and out of the target state;\n• , API that emits values from the upstream Flow when the lifecycle is at least in a certain state.\n• was moved from to . doesn't provide anymore any additional functionality on top of , so dependency on it can be replaced by .\n• Non coroutines API from have been moved to the module.\n• None now uses to initialize the . Previously, this was being done by . If you used the being used to initialize process lifecycle in the past, then you need to do the following instead. <provider android:name=\"androidx.startup.InitializationProvider\" android:authorities=\\\"${applicationId}.androidx-startup\" android:exported=\"false\" tools:node=\\\"merge\"> <!-- If you are using androidx.startup to initialize other components --> <meta-data android:name=\"androidx.lifecycle.ProcessLifecycleInitializer\" android:value=\"androidx.startup\" tools:node=\"remove\" /> </provider>\n\nis released with no changes from Lifecycle 2.4.0-beta01. Version 2.4.0-rc01 contains these commits.\n\nis released. Version 2.4.0-beta01 contains these commits.\n• was deprecated. or should be used instead. (I5a8fa)\n• DefaultLifecycleObserver was moved from to . doesn't provide anymore any additional functionality on top of , so dependency on it can be replaced by . (I021aa)\n• Non coroutines API from have been moved to the module. (I6d5b2)\n• Thanks dmitrilc for fixing a type in the documentation! (#221)\n\nis released. Version 2.4.0-alpha03 contains these commits.\n• Source-breaking change: ViewModelProvider has been rewritten in Kotlin. method no longer allows nullable generic. (I9b9f6)\n• The : is now always invoked serially when repeating execution. (Ibab33)\n• Thanks chao2zhang for fixing the code snippets in the documentation. #205.\n\nis released. Version 2.4.0-alpha02 contains these commits.\n• Added a new lint check to that detects when is incorrectly used in or . (706078, b/187887400)\n• The API is removed in favor of that respects structured concurrency and is easier to reason about. (I4a3a8)\n• Make public so other s can use these as dependencies. (I94c31)\n• Fixed an issue with the lint check when the field has modifiers. (#147, b/183696616)\n• Fixed another issue with the lint check when using generics. (#161, b/184830263)\n• Thanks maxsav for improving the lint check. (#147, b/183696616)\n• Thanks kozaxinan for improving the lint check. (#161, b/184830263)\n\nis released. Version 2.4.0-alpha01 contains these commits.\n• None now uses to initialize the . Previously, this was being done by . If you used the being used to initialize process lifecycle in the past, then you need to do the following instead. <provider android:name=\"androidx.startup.InitializationProvider\" android:authorities=\\\"${applicationId}.androidx-startup\" android:exported=\"false\" tools:node=\\\"merge\"> <!-- If you are using androidx.startup to initialize other components --> <meta-data android:name=\"androidx.lifecycle.ProcessLifecycleInitializer\" android:value=\"androidx.startup\" tools:node=\"remove\" /> </provider> <!-- If you want to disable androidx.startup completely. --> <provider android:name=\"androidx.startup.InitializationProvider\" android:authorities=\"${applicationId}.androidx-startup\" tools:node=\"remove\"> </provider>\n• Added a API that emits values from the upstream Flow when the lifecycle is at least in a certain state using the API. This is an alternative to the also new API. (I0f4cd)\n• From Lifecycle 2.3.1: The lint rule can now properly differentiate between field variables with different nullability. (b/169249668)\n\nis released. Version 1.0.0-alpha07 contains these commits.\n• now takes an optional , making it easier to work with owners other than the . For example, you can now use to retrieve a ViewModel associated with a particular navigation graph. (I2628d, b/188693123)\n\nis released. Version 1.0.0-alpha06 contains these commits.\n\nUpdated to be compatible with Compose version .\n\nis released. Version 1.0.0-alpha05 contains these commits.\n• Updated to be compatible with Compose version .\n• The AndroidManifest files from ui-test-manifest and ui-tooling-data are now compatible with Android 12 (I6f9de, b/184718994)\n\nis released. Version 1.0.0-alpha04 contains these commits.\n• This version allows and to sync dependencies on and . For 1.0.0, it is required that the compiler and runtime match.\n\nis released. Version 1.0.0-alpha03 contains these commits.\n• now returns a nullable to better determine whether a is available in the current composition. APIs that require a , such as and , still throw an exception if a is not set. (Idf39a)\n\nis released. Version 1.0.0-alpha02 contains these commits.\n• now has a functions that can be used with , replacing the API. (I45d24)\n\nis released. Version 1.0.0-alpha01 contains these commits.\n• The composable and were moved from to this artifact in the package. (I7a374)\n\nis released. Version 2.3.1 contains these commits.\n• The lint rule can now properly differentiate between field variables with different nullability. (b/169249668)\n\nis released. Version 2.3.0 contains these commits.\n• support for non-parcelable classes: now supports lazy serialization by allowing you to call for a given key, providing a that will get a callback to when the is asked to save its state. See Saving non-parcelable classes.\n• Lifecycle Behavior Enforcement:\n• now verifies that its methods are called on main thread. It was always a requirement for lifecycles of activities, fragments etc. An addition of observers from non-main threads resulted in hard to catch crashes in runtime. For objects that owned by your own components, you can explicitly opt out from checks by using , but then you have to ensure that a proper synchronization is in place when this is accessed from different threads.\n• Lifecycle State and Event Helpers: Added static helper methods of , , , to for generating the given a and transition direction. Added the method that provides the that the Lifecycle will transition to directly following the .\n• : Added APIs that await a lifecycle state and run a non-suspending block of code synchronously at the point of state change, then resume with the result. These APIs differ from the existing methods as they do not permit running suspending code and do not employ a custom dispatcher. (aosp/1326081)\n• APIs: A new and API allows you to retrieve the containing and , respectively, given a instance. You must upgrade to Activity and Fragment , and AppCompat 1.3.0-alpha01 or higher to populate this correctly. The and Kotlin extensions are available in and , respectively.\n• Kotlin extension deprecation: The Kotlin extension necessary to use lambda syntax is now deprecated as it is not necessary when using Kotlin 1.4.\n\nis released. Version 2.3.0-rc01 contains these commits.\n• The method of is now consistent before and after the state is saved - it now includes keys previously used with in addition to the keys used with and . (aosp/1517919, b/174713653)\n• The APIs to suspend Lifecycle-aware coroutines now better handle calls to . Thanks Nicklas Ansman Giertz! (aosp/1430830, b/168777346)\n\nis released. Version 2.3.0-beta01 contains these commits.\n• The Kotlin extension necessary to use lambda syntax is now deprecated as it is not necessary when using Kotlin 1.4. (I40d3f)\n• The builder and docs have been updated to include details about changing the given timeout values. (aosp/1122324)\n\nis released. Version 2.3.0-alpha07 contains these commits.\n\nis released. Version 2.3.0-alpha06 contains these commits.\n• Added static helper methods of , , , to for generating the given a and transition direction. Added the method that provides the that the Lifecycle will transition to directly following the . (I00887)\n• Added APIs that await a lifecycle state and run a non-suspending block of code synchronously at the point of state change, then resume with the result. These APIs differ from the existing methods as they do not permit running suspending code and do not employ a custom dispatcher. (aosp/1326081)\n• now verifies that its methods are called on main thread. It was always a requirement for lifecycles of activities, fragments etc. An addition of observers from non-main threads resulted in hard to catch crashes in runtime. For objects that owned by your own components, you can explicitly opt out from checks by using , but then you have to ensure that a proper synchronization is in place when this is accessed from different threads (Ie7280, b/137392809)\n• Fixed an for Lint checks bundled with (and specifically ). (b/158699265)\n\nis released. Version 2.3.0-alpha05 contains these commits.\n• now better handles reentrant cases, avoiding duplicate calls to or . (b/157840298)\n• Fixed an issue where Lint checks would not run when using Android Studio 4.1 Canary 6 or higher. (aosp/1331903)\n\nis released. Version 2.3.0-alpha04 contains these commits.\n• The Lint check now covers significantly more cases where a value was set on a with a non-null type parameter. (b/156002218)\n\nare released. Version 2.3.0-alpha03 contains these commits.\n• now supports lazy serialization by allowing you to call for a given key, providing a that will get a callback to when the is asked to save its state. (b/155106862)\n• A new API allows you to retrieve the containing given a instance. You must upgrade to Activity , Fragment , and AppCompat to populate this correctly. A Kotlin extension has been added to . (aosp/1295522)\n• Fixed an issue that caused the Lint checks released in Lifecycle from being published alongside the artifact. (b/155323109)\n\nis released. Version 2.3.0-alpha02 contains these commits.\n• now allows you to pass a null to its constructor to better support cases where one is not readily available and support for is not needed. (aosp/1285740)\n• Improved cold start performance by avoiding class verification failure on API 28 and lower devices. (aosp/1282118)\n\nis released. Version 2.3.0-alpha01 contains these commits.\n• A new API allows you to retrieve the containing given a instance. You must upgrade to Activity and Fragment to populate this correctly. A Kotlin extension is available in . (aosp/1182361, aosp/1182956)\n• Added a new Lint check that warns you when setting a value on a that has been defined in Kotlin as non-null. This is available when using the or artifacts. (aosp/1154723, aosp/1159092)\n• A new artifact is available that provides a that implements and provides a thread safe mutable . (aosp/1242438)\n• The artifact now has a unique package name. (aosp/1187196)\n\nis released. Version 2.2.0 contains these commits.\n\nLifecycle ViewModel SavedState now shares the same version as other Lifecycle artifacts. The behavior of is identical to the behavior of .\n\nis released. Version 2.2.0 contains these commits.\n• Lifecycle Coroutine Integration: The new artifact adds integration between Lifecycle and Kotlin coroutines. The has also been expanded to take advantage of coroutines. See Use Kotlin coroutines with Architecture Components for more details.\n• deprecation: has been deprecated. You can pass a or to the new constructor to achieve the same functionality when using Fragment .\n• Artifact Deprecation: With the above deprecation of , this release marks the deprecation of the last API in and this artifact should now be considered deprecated in its entirety. We strongly recommend depending on the specific Lifecycle artifacts you need (such as if you’re using and if you’re using ) rather than as there will not be a future release of .\n• Gradle Incremental Annotation Processor: Lifecycle's annotation processor is incremental by default. If your app is written in the Java 8 programming language you can use instead; and if it's written in the Java 7 programming language you can use .\n\nis released. Version 2.2.0-rc03 contains these commits.\n• Fixed a failure occurring when a mocked was stored in and queried later with default factory.\n• Fix a usage of in and similar methods to be called synchronously during corresponding lifecycle event. (aosp/1156203)\n• Thanks to Anders Järleberg for contributing the fix! (aosp/1156203)\n• Thanks to Vsevolod Tolstopyatov from Jetbrains for reviewing an implementation of inlined execution.\n\nis released. Version 2.2.0-rc02 contains these commits.\n• Fixed a bug in the proguard setup of the library that affected devices running API 28+ if the target API is below 29. (b/142778206)\n\nis released. Version 2.2.0-rc01 contains these commits.\n• Fixed an issue where and related methods would run one frame later than the associated lifecycle method due to its use of instead of . (aosp/1145596)\n• Thanks to Nicklas Ansman for contributing the fix! (aosp/1145596)\n\nis released. Version 2.2.0-beta01 contains these commits.\n• Fixed a regression introduced in Lifecycle 2.2.0-alpha05 in the ordering of and the activity’s moving to started and resumed on Android 10 devices. (aosp/1128132)\n• Fixed a regression introduced in Lifecycle which would cause a when using version or of . (b/141536990)\n\nis released. Version 2.2.0-alpha05 contains these commits.\n\nis released. The commits included in this version can be found here.\n• , , , , , and the underlying implementation of now use instead of . (b/139740492)\n• Thanks to Nicklas Ansman for contributing the move to ! (aosp/1106073)\n\nis released. The commits included in this version can be found here.\n• Implementations of can now optionally implement to provide a default . This has been done for Activity , Fragment , and Navigation . (aosp/1092370, b/135716331)\n• has been deprecated. You can pass a or to the new constructor to achieve the same functionality. (aosp/1009889)\n\nis released. The commits included in this version can be found here.\n• Replaced with which will track the current emitted value of the block.\n• Added a new overload to the builder that receives parameter as type\n\nis released. The commits included in this version can be found here.\n• This release adds new features that adds support for Kotlin coroutines for Lifecycle and LiveData. Detailed documentation on them can be found here.\n\nis released. Version 1.0.0 contains these commits.\n• New SavedStateHandle class was added. It enables your classes to access and to contribute to the saved state. This object can be received in constructor of class and factories provided by default by Fragments and AppCompatActivity will inject automatically.\n• AbstractSavedStateViewModelFactory was added. It allows you to create custom factories for your and provide them access to .\n\nis released. Version 1.0.0-rc03 contains these commits.\n\nis released. Version 1.0.0-rc02 contains these commits.\n\nis released with no changes from . Version 1.0.0-rc01 contains these commits.\n\nis released. Version 1.0.0-beta01 contains these commits.\n• Fixed an issue where accessing a SavedState ViewModel for the first time in would result in an . (b/139093676)\n• Fixed an when using . (b/141225984)\n\nis released. Version 1.0.0-alpha05 contains these commits.\n• no longer extends and is created only for ViewModels that requested have it (aosp/1113593)\n\nis released. The commits included in this version can be found here.\n• no longer depends on and the related and constructors have been removed. Instead, is now the default factory for Activity , Fragment , and Navigation . (b/135716331)\n\nis released. The commits included in this version can be found here.\n\nis released. The full commit log for this initial release can be found here.\n• Now can contribute to savedstate. To do that you use newly introduced viewmodel’s factory and your ViewModel should have a constructor that receives object as a parameter.\n• Added for the cases when a stream of lifecycle events is needed. It is a public API instead of a hidden class.\n• Added , which creates a new LiveData object that does not emit a value until the source value has been changed.\n• Added coroutine support in ViewModels by adding the extension property .\n\nis released. The commits included in this version can be found here.\n\nis released with no changes from . The commits included in this version can be found here.\n\nis released. The commits included in this version can be found here.\n• Lifecycles are graduated to beta: api introduced in previous alphas such as extension functions for transformations and observations, initialisation with property delegation and others are stabilised and not going to change.\n\nis released. The commits included in this version can be found here.\n• Breaking change: the underlying API behind and has been changed to support a directly, rather than only a . (aosp/932932)\n\nis released. The full list of commits included in this version can be found here.\n• was removed. Second interface in addition to didn’t compose well with new features as property delegation in Kotlin . (aosp/914133)\n• now contains a method that replaces the now deprecated method. (aosp/880715)\n• Fixed an issue where mock instances would crash when the containing was cleared. b/122273087\n• Added for the cases when a stream of lifecycle events is needed. It is a public api instead of a hidden class.\n• Method was added. It creates a new object that does not emit a value until the source LiveData value has been changed.\n• Added , a factory for ViewModels that receives and in method.\n\nLifecycle is released with one bugfix from in ViewModel.\n• Fixed LifecycleObserver proguard rule to keep only implementations, not subinterfaces b/71389427\n• Fixed ViewModel proguard rules to allow obfuscation and shrinking\n\nFor the pre-AndroidX versions of Lifecycle that follow, include these dependencies:\n\nOnly one small change: is moved from to . This allows it to be used without the runtime dependency, e.g. in below.\n\nis a dependency of , so this change doesn’t affect directly, only modules that depend directly on , as Paging does.\n\nNew, much smaller dependencies are now available:\n• The deprecated and have now been removed - please use , or support .\n• annotations have been added to and\n• constructor has been deprecated - please use its static methods directly\n• has been deprecated - please use\n• The static method has been added to retrieve a static suitable for creating and instances."
    },
    {
        "link": "https://stackoverflow.com/questions/78556957/compiler-error-migrating-to-androidx-lifecycle-2-8-0-library",
        "document": "libraries in my Android Java project. If I try to move it to version, I have a message from compiler:\n\nUPDATE: Thanks to @IanHannibalLake, I have replaced deprecated library with and now I am able to compile the project with libraries version in the configuration:\n\nBut an attempt to compile with versions give me the same error from the compiler on the string:\n\nWhat change was made in the libraries in version that prevents me from compiling the project with the next version !?\n\nUPDATE 2: I have found a fresh bug ViewModel 2.8.0: constructor has private access in ViewModelProvider with the same question."
    },
    {
        "link": "https://developer.android.com/topic/libraries/architecture/lifecycle",
        "document": "Save and categorize content based on your preferences.\n\nLifecycle-aware components perform actions in response to a change in the lifecycle status of another component, such as activities and fragments. These components help you produce better-organized, and often lighter-weight code, that is easier to maintain.\n\nA common pattern is to implement the actions of the dependent components in the lifecycle methods of activities and fragments. However, this pattern leads to a poor organization of the code and to the proliferation of errors. By using lifecycle-aware components, you can move the code of dependent components out of the lifecycle methods and into the components themselves.\n\nThe package provides classes and interfaces that let you build lifecycle-aware components—which are components that can automatically adjust their behavior based on the current lifecycle state of an activity or fragment.\n\nMost of the app components that are defined in the Android Framework have lifecycles attached to them. Lifecycles are managed by the operating system or the framework code running in your process. They are core to how Android works and your application must respect them. Not doing so may trigger memory leaks or even application crashes.\n\nImagine we have an activity that shows the device location on the screen. A common implementation might be like the following:\n\nEven though this sample looks fine, in a real app, you end up having too many calls that manage the UI and other components in response to the current state of the lifecycle. Managing multiple components places a considerable amount of code in lifecycle methods, such as and , which makes them difficult to maintain.\n\nMoreover, there's no guarantee that the component starts before the activity or fragment is stopped. This is especially true if we need to perform a long-running operation, such as some configuration check in . This can cause a race condition where the method finishes before the , keeping the component alive longer than it's needed.\n\nThe package provides classes and interfaces that help you tackle these problems in a resilient and isolated way.\n\nis a class that holds the information about the lifecycle state of a component (like an activity or a fragment) and allows other objects to observe this state.\n\nuses two main enumerations to track the lifecycle status for its associated component:\n\nThink of the states as nodes of a graph and events as the edges between these nodes.\n\nA class can monitor the component's lifecycle status by implementing and overriding corresponding methods such as , , etc. Then you can add an observer by calling the method of the class and passing an instance of your observer, as shown in the following example:\n\nIn the example above, the object implements the interface, which is explained in the following section.\n\nis a single method interface that denotes that the class has a . It has one method, , which must be implemented by the class. If you're trying to manage the lifecycle of a whole application process instead, see .\n\nThis interface abstracts the ownership of a from individual classes, such as and , and allows writing components that work with them. Any custom application class can implement the interface.\n\nComponents that implement work seamlessly with components that implement because an owner can provide a lifecycle, which an observer can register to watch.\n\nFor the location tracking example, we can make the class implement and then initialize it with the activity's in the method. This allows the class to be self-sufficient, meaning that the logic to react to changes in lifecycle status is declared in instead of the activity. Having the individual components store their own logic makes the activities and fragments logic easier to manage.\n\nA common use case is to avoid invoking certain callbacks if the isn't in a good state right now. For example, if the callback runs a fragment transaction after the activity state is saved, it would trigger a crash, so we would never want to invoke that callback.\n\nTo make this use case easy, the class allows other objects to query the current state.\n\nWith this implementation, our class is completely lifecycle-aware. If we need to use our from another activity or fragment, we just need to initialize it. All of the setup and teardown operations are managed by the class itself.\n\nIf a library provides classes that need to work with the Android lifecycle, we recommend that you use lifecycle-aware components. Your library clients can easily integrate those components without manual lifecycle management on the client side.\n\nFragments and Activities in Support Library 26.1.0 and later already implement the interface.\n\nIf you have a custom class that you would like to make a , you can use the LifecycleRegistry class, but you need to forward events into that class, as shown in the following code example:\n• Keep your UI controllers (activities and fragments) as lean as possible. They should not try to acquire their own data; instead, use a to do that, and observe a object to reflect the changes back to the views.\n• Try to write data-driven UIs where your UI controller’s responsibility is to update the views as data changes, or notify user actions back to the .\n• Put your data logic in your class. should serve as the connector between your UI controller and the rest of your app. Be careful though, it isn't 's responsibility to fetch data (for example, from a network). Instead, should call the appropriate component to fetch the data, then provide the result back to the UI controller.\n• Use Data Binding to maintain a clean interface between your views and the UI controller. This allows you to make your views more declarative and minimize the update code you need to write in your activities and fragments. If you prefer to do this in the Java programming language, use a library like Butter Knife to avoid boilerplate code and have a better abstraction.\n• If your UI is complex, consider creating a presenter class to handle UI modifications. This might be a laborious task, but it can make your UI components easier to test.\n• Avoid referencing a or context in your . If the outlives the activity (in case of configuration changes), your activity leaks and isn't properly disposed by the garbage collector.\n• Use Kotlin coroutines to manage long-running tasks and other operations that can run asynchronously.\n\nLifecycle-aware components can make it much easier for you to manage lifecycles in a variety of cases. A few examples are:\n• Switching between coarse and fine-grained location updates. Use lifecycle-aware components to enable fine-grained location updates while your location app is visible and switch to coarse-grained updates when the app is in the background. , a lifecycle-aware component, allows your app to automatically update the UI when your user changes locations.\n• Stopping and starting video buffering. Use lifecycle-aware components to start video buffering as soon as possible, but defer playback until app is fully started. You can also use lifecycle-aware components to terminate buffering when your app is destroyed.\n• Starting and stopping network connectivity. Use lifecycle-aware components to enable live updating (streaming) of network data while an app is in the foreground and also to automatically pause when the app goes into the background.\n• Pausing and resuming animated drawables. Use lifecycle-aware components to handle pausing animated drawables when the app is in the background and resume drawables after the app is in the foreground.\n\nWhen a belongs to an or , the 's state changes to and the event is dispatched when the or 's is called.\n\nWhen a or 's state is saved via , it's UI is considered immutable until is called. Trying to modify the UI after the state is saved is likely to cause inconsistencies in the navigation state of your application which is why throws an exception if the app runs a after state is saved. See for details.\n\nprevents this edge case out of the box by refraining from calling its observer if the observer's associated isn't at least . Behind the scenes, it calls before deciding to invoke its observer.\n\nUnfortunately, 's method is called after , which leaves a gap where UI state changes are not allowed but the has not yet been moved to the state.\n\nTo prevent this issue, the class in version and lower mark the state as without dispatching the event so that any code that checks the current state gets the real value even though the event isn't dispatched until is called by the system.\n\nUnfortunately, this solution has two major problems:\n• On API level 23 and lower, the Android system actually saves the state of an activity even if it is partially covered by another activity. In other words, the Android system calls but it doesn't necessarily call . This creates a potentially long interval where the observer still thinks that the lifecycle is active even though its UI state can't be modified.\n• Any class that wants to expose a similar behavior to the class has to implement the workaround provided by version and lower.\n\nTo learn more about handling lifecycles with lifecycle-aware components, consult the following additional resources."
    },
    {
        "link": "https://stackoverflow.com/questions/75465435/unresolved-reference-transformations-after-upgrading-lifecycle-dependency",
        "document": "Transformations is now written in Kotlin. This is a source incompatible change for those classes written in Kotlin that were directly using syntax such as Transformations.map - Kotlin code must now use the Kotlin extension method syntax that was previously only available when using lifecycle-livedata-ktx. When using the Java programming language, the versions of these methods that take an androidx.arch.core.util.Function method are deprecated and replaced with the versions that take a Kotlin Function1.\n\nSo, instead of using , you need to use the extension function directly or\n\nSo, to fix this use:"
    },
    {
        "link": "https://github.com/mozilla-mobile/focus-android/issues/7374",
        "document": "You can’t perform that action at this time."
    }
]