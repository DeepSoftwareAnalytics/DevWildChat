[
    {
        "link": "https://geeksforgeeks.org/file-handling-c-classes",
        "document": "File handling is used to store data permanently in a computer. Using file handling we can store our data in secondary memory (Hard disk).\n\nHow to achieve the File Handling\n\nFor achieving file handling we need to follow the following steps:-\n\n STEP 1-Naming a file\n\n STEP 2-Opening a file\n\n STEP 3-Writing data into the file\n\n STEP 4-Reading data from the file\n\n STEP 5-Closing a file.\n\nWe give input to the executing program and the execution program gives back the output. The sequence of bytes given as input to the executing program and the sequence of bytes that comes as output from the executing program are called stream. In other words, streams are nothing but the flow of data in a sequence.\n\nThe input and output operation between the executing program and the devices like keyboard and monitor are known as “console I/O operation”. The input and output operation between the executing program and files are known as “disk I/O operation”.\n\nThe I/O system of C++ contains a set of classes which define the file handling methods. These include ifstream, ofstream and fstream classes. These classes are derived from fstream and from the corresponding iostream class. These classes, designed to manage the disk files, are declared in fstream and therefore we must include this file in any program that uses files. File handling is essential for data storage and retrieval in applications.\n• None This class is the base class for other classes in this class hierarchy.\n• None This class contains the necessary facilities that are used by all the other derived classes for input and output operations.\n• None This class is derived from the class ‘ios’.\n• None The extraction operator(>>) is overloaded in this class to handle input streams from files to the program execution.\n• None This class declares input functions such as get(), getline() and read().\n• None This class is derived from the class ‘ios’.\n• None The insertion operator(<<) is overloaded in this class to handle output streams to files from the program execution.\n• None This class declares output functions such as put() and write().\n• None This class contains a pointer which points to the buffer which is used to manage the input and output streams.\n• None This class provides operations common to the file streams. Serves as a base for fstream, ifstream and ofstream class.\n• None This class contains open() and close() function.\n• None It contains open() function with default input mode.\n• None Inherits the functions get(), getline(), read(), seekg() and tellg() functions from the istream.\n• None It contains open() function with default output mode.\n• None Inherits the functions put(), write(), seekp() and tellp() functions from the ostream.\n• None This class provides support for simultaneous input and output operations.\n• None Inherits all the functions from istream and ostream classes through iostream.\n• None Its purpose is to set the file buffers to read and write.\n• None We can also use file buffer member function to determine the length of the file. \n\n\n\nIn C++, files are mainly dealt by using three classes fstream, ifstream, ofstream available in fstream headerfile. \n\nofstream: Stream class to write on files \n\nifstream: Stream class to read from files \n\nfstream: Stream class to both read and write from/to files.\n\nNow the first step to open the particular file for read or write operation. We can open file by \n\n1. passing file name in constructor at the time of object creation \n\n2. using the open method\n\nBoth ios::app and ios::ate take us to the end of the file when it is opened. The difference between the two modes is that ios :: app allow us to add data to the end of the file only, while ios :: ate mode permits us add data or to modify the existing data anywhere in the file.\n\nProblem Statement : To read and write a File in C++. \n\nExamples:\n\nBelow is the implementation by using ifstream & ofstream classes.\n\nBelow is the implementation by using fstream class."
    },
    {
        "link": "https://cplusplus.com/doc/tutorial/files",
        "document": "std; main () { ofstream myfile ( ); (myfile.is_open()) { myfile << ; myfile << \"This is another line.\n\n\" ; myfile.close(); } cout << ; 0; }\n\n[file example.txt] This is a line. This is another line."
    },
    {
        "link": "https://stackoverflow.com/questions/49563597/using-ifstream-ofstream-and-fstream",
        "document": "This shadows the one you had already created before. Moreover, the one you are shadowing now is the object that contains a valid file pointer to . Using the new inner-scope doesn't point to any file yet, thus writing to it won't give you any results in .\n\nRemove it to use the correct object:"
    },
    {
        "link": "https://simplilearn.com/tutorials/cpp-tutorial/ifstream-in-cpp",
        "document": ""
    },
    {
        "link": "https://tutorialspoint.com/cplusplus/cpp_files_streams.htm",
        "document": "So far, we have been using the iostream standard library, which provides cin and cout methods for reading from standard input and writing to standard output respectively.\n\nThis tutorial will teach you how to read and write from a file. This requires another standard C++ library called fstream, which defines three new data types −\n\nTo perform file processing in C++, header files <iostream> and <fstream> must be included in your C++ source file.\n\nA file must be opened before you can read from it or write to it. Either ofstream or fstream object may be used to open a file for writing. And ifstream object is used to open a file for reading purpose only.\n\nFollowing is the standard syntax for open() function, which is a member of fstream, ifstream, and ofstream objects.\n\nHere, the first argument specifies the name and location of the file to be opened and the second argument of the open() member function defines the mode in which the file should be opened.\n\nYou can combine two or more of these values by ORing them together. For example if you want to open a file in write mode and want to truncate it in case that already exists, following will be the syntax −\n\nSimilar way, you can open a file for reading and writing purpose as follows −\n\nWhen a C++ program terminates it automatically flushes all the streams, release all the allocated memory and close all the opened files. But it is always a good practice that a programmer should close all the opened files before program termination.\n\nFollowing is the standard syntax for close() function, which is a member of fstream, ifstream, and ofstream objects.\n\nWhile doing C++ programming, you write information to a file from your program using the stream insertion operator (<<) just as you use that operator to output information to the screen. The only difference is that you use an ofstream or fstream object instead of the cout object.\n\nYou read information from a file into your program using the stream extraction operator (>>) just as you use that operator to input information from the keyboard. The only difference is that you use an ifstream or fstream object instead of the cin object.\n\nFollowing is the C++ program which opens a file in reading and writing mode. After writing information entered by the user to a file named afile.dat, the program reads information from the file and outputs it onto the screen −\n\nWhen the above code is compiled and executed, it produces the following sample input and output −\n\nAbove examples make use of additional functions from cin object, like getline() function to read the line from outside and ignore() function to ignore the extra characters left by previous read statement.\n\nBoth istream and ostream provide member functions for repositioning the file-position pointer. These member functions are seekg (\"seek get\") for istream and seekp (\"seek put\") for ostream.\n\nThe argument to seekg and seekp normally is a long integer. A second argument can be specified to indicate the seek direction. The seek direction can be ios::beg (the default) for positioning relative to the beginning of a stream, ios::cur for positioning relative to the current position in a stream or ios::end for positioning relative to the end of a stream.\n\nThe file-position pointer is an integer value that specifies the location in the file as a number of bytes from the file's starting location. Some examples of positioning the \"get\" file-position pointer are −"
    },
    {
        "link": "https://geeksforgeeks.org/vector-in-cpp-stl",
        "document": "In C++, vector is a dynamic array that stores collection of elements same type in contiguous memory. It has the ability to resize itself automatically when an element is inserted or deleted.\n\nVector is defined as the std::vector class template inside the <vector> header file.\n\nwhere T is the type of elements and v is the name assigned to the vector.\n\nCreating a vector involves creating an instance of std::vector class. This requires us to provide the type of elements as template parameter.\n\nWe can also provide the values to be stored in the vector inside {} curly braces. This process is called initialization.\n\nIn the above example,\n• vector<int> v2(5, 9) creates a vector of size 5 where each element initialized to 9.\n\nMore ways to declare and initialize vectors are discussed in this article – 8 Ways to Initialize Vector in C++\n\nAn element can be inserted into a vector using vector insert() method which takes linear time. But for the insertion at the end, the vector push_back() method can be used. It is much faster, taking only constant time.\n\nMore ways to insert an element in the vector are discussed in the article – Different Ways to Add Elements in a Vector\n\nJust like arrays, vector elements can be accessed using their index inside the [] subscript operator. This method is fast but doesn’t check whether the given index exists in the vector or not. So, there is another member method vector at() for safely accessing elements.\n\nTo know more about accessing vector elements, refer to the article – Different Ways to Access Elements in Vector\n\nUpdating elements is very similar to the accessing except that we use an assignment operator to assign a new value. It uses the same methods: [] subscript operator and vector at().\n\nMore methods to update vector elements are discussed in this article – Different Ways to Update Vector Elements\n\nOne of the common problems with arrays was to keep a separate variable to store the size information. Vector provides the solution to this problem by providing size() method.\n\nVector in C++ can be traversed using indexes in a loop. The indexes start from 0 and go up to vector size – 1. To iterate through this range, we can use a loop and determine the size of the vector using the vector size()method.\n\nWe can also use a range-based loop for simple traversal. More ways to traverse vectors are discussed in this article – Different Ways to Iterate Through Vector\n\nAn element can be deleted from a vector using vector erase() but this method needs iterator to the element to be deleted. If only the value of the element is known, then find() function is used to find the position of this element.\n\nFor the deletion at the end, the vector pop_back() method can be used, and it is much faster, taking only constant time.\n\nTo know more about the deletion of an element in the vector, refer to this article – Different Ways to Remove Elements from Vector\n\nVector is one of the most frequently used containers in C++. It is used in many situations for different purposes. The following examples aim to help you master vector operations beyond the basics.\n\nThe below table lists the time complexity of the above operations on a vector:\n\nVectors can be passed to a function as arguments just like any other variable in C++. But it is recommended to pass the vector by reference so as to avoid the copying of all elements which can be expensive if the vector is large. Refer to this article to know more – Passing Vector to a Function\n\nVector internal working is very interesting and useful to select and optimize its usage. Understanding the internal memory management also helps in modifying the default mechanism of vector to suits our needs. Refer to this article to know more – Internal Working of Vector\n\nJust like arrays, we can also create multidimensional vectors in C++. Each element of multidimensional vector can be visualized as the collection of vectors with dimension one less that the current vector. For example, 2D vectors are the collection of 1D vectors, while 3D vectors are the collection of 2D vectors and so on.\n\nWith the addition of each dimension, the complexity of operations on the vectors also increases.\n\nRefer to this article to know more – Multidimensional Vectors in C++\n\nFollowing is the list of all member functions of std::vector class in C++:\n\nAdds an element to the end of the vector. Removes the last element of the vector. Returns the number of elements in the vector. Returns the maximum number of elements that the vector can hold. Changes the size of the vector. Checks if the vector is empty. Accesses the element at a specific position, with bounds checking. Accesses the first element of the vector. Accesses the last element of the vector. Returns an iterator pointing to the first element of the vector. Returns an iterator pointing to the past-the-end element of the vector. Returns a reverse iterator pointing to the last element of the vector. Returns a reverse iterator pointing to the element preceding the first element of the vector. Inserts elements at a specific position in the vector. Removes elements from a specific position or range in the vector. Swaps the contents of the vector with those of another vector. Removes all elements from the vector. Constructs and inserts an element in the vector. Constructs and inserts an element at the end of the vector. Assigns new values to the vector elements by replacing old ones. Returns the size of the storage space currently allocated to the vector. Requests that the vector capacity be at least enough to contain a specified number of elements. Returns a direct pointer to the memory array used internally by the vector to store its owned elements. Returns a copy of the allocator object associated with the vector."
    },
    {
        "link": "https://geeksforgeeks.org/the-c-standard-template-library-stl",
        "document": "The C++ Standard Template Library (STL) is a set of template classes and functions that provides the implementation of common data structures and algorithms such as lists, stacks, arrays, sorting, searching, etc. It also provides the iterators and functors which makes it easier to work with algorithms and containers.\n\nSTL was originally designed by Alexander Stepanov and was later accepted as the part of C++ standard in C++ 98. It is a generalized library so we can use it with almost every data type without repeating the implementation code.\n\nThe components of STL are the features provided by Standard Template Library (STL) in C++ that can be classified into 4 types:\n\nThese components are designed to be efficient, flexible, and reusable, making them an integral part of modern C++ programming.\n\nContainers are the data structures used to store objects and data according to the requirement. Each container is implemented as a template class that also contains the methods to perform basic operations on it. Every STL container is defined inside its own header file.\n\nContainers can be further classified into 4 types:\n\nIf you want to dive deep into STL and understand its full potential, our Complete C++ Course offers a complete guide to mastering containers, iterators, and algorithms provided by STL.\n\nSequence containers store the data in the linear manner. They are also used to implement container adaptors.\n\nThere are 5 sequence containers in C++ STL:\n• Arrays : The STL array is an implementation of a compile time non-resizable array. It contains various method for common array operations.\n• Vector : An STL vector can be defined as the dynamic sized array which can be resized automatically when new elements are added or removed.\n• Deque : Deque or Double-Ended Queue is sequence containers with the feature of expansion and contraction on both ends. It means we can add and remove the data to and from both ends.\n• Lists : List container stores data in non-contiguous memory unlike vectors and only provide sequential access to the stored data. It basically implements the doubly linked list.\n• Forward Lists: Forward lists also store the data in a sequential manner like lists, but with the difference that forward list stores the location of only the next elements in the sequence. It implements the singly linked list.\n\nThe container adapters are the type of STL containers that adapt existing container classes to suit specific needs or requirements.\n\nThere are 3 container adaptors in C++ STL:\n• Stack: STL Stack follows the Last In First Out (LIFO) principle of element insertion and deletion. Also, these operations are performed only at one end of the stack.\n• Queue: STL Queue follows the First In First Out (FIFO) principle, means the element are inserted first are removed first and the elements inserted last are removed at last. It uses deque container by default.\n• Priority Queue: STL Priority Queue does not follow any of the FIFO or LIFO principle, but the deletion of elements is done on the basis of its priority. So, the element with the highest (by default) is always removed first. By default, it uses vector as underlying container.\n\nAssociative containers are the type of containers that store the elements in a sorted order based on keys rather than their insertion order.\n\nThere are 4 associative containers in C++ STL:\n• Sets : STL Set is a type of associative container in which each element has to be unique because the value of the element identifies it. By default, the values are stored in ascending order.\n• Maps : STL Maps are associative containers that store elements in the form of a key-value pair. The keys have to be unique and the container is sorted on the basis of the values of the keys.\n• Multisets : STL Multiset is similar to the set container except that it can store duplicate values.\n• Multimaps : STL Multimap is similar to a map container but allows multiple mapped values to have same keys.\n\nUnordered associative containers store the data in no particular order, but they allow the fastest insertion, deletion and search operations among all the container types in STL.\n\nThere are 4 unordered associative containers in C++ STL:\n• Unordered Set : STL Unordered Set stores the unique keys in the form of hash table. The order is randomized but insertion, deletion and search are fast.\n• Unordered Multiset : STL Unordered Multiset works similarly to an unordered set but can store multiple copies of the same key.\n• Unordered Map : STL Unordered Map stores the key-value pair in a hash table, where key is hashed to find the storage place.\n• Unordered Multimap : STL Unordered Multimap container is similar to unordered map, but it allows multiple values mapped to the same key.\n\nSTL algorithms offer a wide range of functions to perform common operations on data (mainly containers). These functions implement the most efficient version of the algorithm for tasks such as sorting, searching, modifying and manipulating data in containers, etc. All STL algorithms are defined inside the <algorithm> and <numeric> header file.\n\nThere is no formal classification of STL algorithms, but we can group them into two types based on the type of operations they perform:\n\nManipulative algorithms perform operations that modifies the elements of the given container or rearrange their order.\n\nSome of the common manipulative algorithm includes:\n• copy : Copies a specific number of elements from one range to another.\n• fill : Assigns a specified value to all elements in a range.\n• transform : Applies a function to each element in a range and stores the result in another range.\n• replace : Replaces all occurrences of a specific value in a range with a new value.\n• swap : Exchanges the values of two variables.\n• reverse : Reverses the order of elements in a range.\n• rotate : Rotates the elements in a range such that a specific element becomes the first.\n• remove : Removes all elements with a specified value from a range but does not reduce the container size.\n\nNon-manipulating algorithms are the type of algorithms provided by the Standard Template Library (STL) that operate on elements in a range without altering their values or the order of the elements.\n\nThe below are the few examples of the STL’s non-manipulative algorithms:\n• max_element : Find the maximum element in the given range.\n• min_element : To find the minimum element in the given range.\n• accumulate : Finds the sum of the elements of the given range.\n• count : Counts the occurrences of given element in the range.\n• find : Returns an iterator to the first occurrence of an element in the range.\n• is_permutation : Checks if one range is a permutation of another.\n• is_sorted : Checks if the elements in a range are sorted in non-decreasing order.\n• partial_sum : Computes the cumulative sum of elements in a range.\n\nIterators are the pointer like objects that are used to point to the memory addresses of STL containers. They are one of the most important components that contributes the most in connecting the STL algorithms with the containers. Iterators are defined inside the <iterator> header file.\n\nIn C++ STL, iterators are of 5 types:\n• Input Iterators : Input Iterators can be used to read values from a sequence once and only move forward.\n• Output Iterators : Output Iterators can be used to write values into a sequence once and only move forward.\n• Forward Iterators : Forward Iterators combine the features of both input and output iterators.\n• Bidirectional Iterators : Bidirectional Iterators support all operations of forward iterators and additionally can move backward.\n• Random Access Iterators : Random Access Iterators support all operations of bidirectional iterators and additionally provide efficient random access to elements.\n\nFunctors are objects that can be treated as though they are a function. Functors are most commonly used along with STL algorithms. It overloads the function-call operator and allows us to use an object like a function. There are many predefined functors in C++ STL that are defined inside the <functional> header file.\n\nFunctors can be classified into multiple types based on the type of operator they perform:\n• plus – Returns the sum of two parameters.\n• minus – Returns the difference of two parameters.\n• multiplies – Returns the product of two parameters.\n• divides – Returns the result after dividing two parameters.\n• modulus – Returns the remainder after dividing two parameters.\n• negate – Returns the negated value of a parameter.\n• equal_to – Returns true if the two parameters are equal.\n• not_equal_to – Returns true if the two parameters are not equal.\n• greater – Returns true if the first parameter is greater than the second.\n• greater_equal – Returns true if the first parameter is greater than or equal to the second.\n• less – Returns true if the first parameter is less than the second.\n• less_equal – Returns true if the first parameter is less than or equal to the second.\n• logical_and – Returns the result of Logical AND operation of two parameters.\n• logical_or – Returns the result of Logical OR operation of two parameters.\n• logical_not – Returns the result of Logical NOT operation of the parameters.\n• bit_and – Returns the result of Bitwise AND operation of two parameters.\n• bit_or – Returns the result of Bitwise OR operation of two parameters.\n• bit_xor – Returns the result of Bitwise XOR operation of two parameters.\n\nThe Utility Library is a collection of utility components provided by the Standard Template Library (STL) that does not fall in the above categories. It offers various features such as pairs, tuples, etc.\n\nThe memory library contains the function that helps users to efficiently manage the memory such as std::move, smart pointers, etc.\n• Move Semantics : It allows the transfer of resources from one object to another without copying.\n• Smart Pointers : They are a wrapper over the raw pointers and helps in avoiding errors associated with pointers.\n• Utility Functions : Utility functions in C++ provide important operations like std::forward to facilitate efficient, generic and safe code manipulation.\n• Integer Sequence : Enable compile-time generation of integer sequences, useful in metaprogramming.\n\nThe key benefit of the STL is that it provides a way to write generic, reusable code and tested code that can be applied to different data types. This means you can write an algorithm once and then use it with other types of data without having to write separate code for each type.\n\nOther benefits include:\n• None STL provides flexibility through customizable templates, functors, and lambdas.\n• None Pre-implemented tools let you focus on problem-solving rather than low-level coding.\n\nThe major limitation of the C++ Standard Template Library (STL) is Performance Overheads. While STL is highly optimized for general use cases, its generic nature can lead to less efficient memory usage and execution time compared to custom and specialized solutions.\n\nOther limitations can be:\n\nDespite these limitations, STL remains an invaluable part of C++ programming, offering a wide range of powerful and flexible tools."
    },
    {
        "link": "https://cplusplus.com/reference/vector/vector",
        "document": "an unsigned integral type that can represent any non-negative value of\n\nusually the same as size_t"
    },
    {
        "link": "https://en.cppreference.com/w/cpp/container/vector",
        "document": "The elements are stored contiguously, which means that elements can be accessed not only through iterators, but also using offsets to regular pointers to elements. This means that a pointer to an element of a vector may be passed to any function that expects a pointer to an element of an array.\n\nThe storage of the vector is handled automatically, being expanded as needed. Vectors usually occupy more space than static arrays, because more memory is allocated to handle future growth. This way a vector does not need to reallocate each time an element is inserted, but only when the additional memory is exhausted. The total amount of allocated memory can be queried using capacity() function. Extra memory can be returned to the system via a call to shrink_to_fit()[1].\n\nReallocations are usually costly operations in terms of performance. The reserve() function can be used to eliminate reallocations if the number of elements is known beforehand.\n\nThe complexity (efficiency) of common operations on vectors is as follows:\n• Insertion or removal of elements at the end - amortized constant .\n• Insertion or removal of elements - linear in the distance to the end of the vector .\n\n(for other than bool) meets the requirements of Container, AllocatorAwareContainer(since C++11), SequenceContainer, ContiguousContainer(since C++17) and ReversibleContainer.\n\nAll member functions of are constexpr: it is possible to create and use objects in the evaluation of a constant expression. However, objects generally cannot be constexpr, because any dynamically allocated storage must be released in the same evaluation of constant expression.\n• is In libstdc++,is not available in C++98 mode.\n\nThe type of the elements. must meet the requirements of and . The requirements that are imposed on the elements depend on the actual operations performed on the container. Generally, it is required that element type is a complete type and meets the requirements of , but many member functions impose stricter requirements. The requirements that are imposed on the elements depend on the actual operations performed on the container. Generally, it is required that element type meets the requirements of Erasable, but many member functions impose stricter requirements. This container (but not its members) can be instantiated with an incomplete element type if the allocator satisfies the allocator completeness requirements. An allocator that is used to acquire/release memory and to construct/destroy the elements in that memory. The type must meet the requirements of . if is not the same as .\n\nThe standard library provides a specialization of for the type bool, which may be optimized for space efficiency.\n\nThe following behavior-changing defect reports were applied retroactively to previously published C++ standards."
    },
    {
        "link": "https://mygreatlearning.com/blog/vectors-in-c",
        "document": "When it comes to programming in C++, vectors are an essential data structure that every developer should be familiar with. Vectors provide a dynamic array-like structure that can store and manipulate elements efficiently. Whether you are a beginner or an experienced programmer, understanding vectors in C++ is crucial for building robust and flexible applications.\n\nIn this blog, we will explore the concept of vectors in C++ and delve into their various functionalities, including how to create and initialize vectors, access and modify elements, perform common operations, and utilize some advanced features. By the end of this blog, you will have a solid understanding of vectors and be equipped with the knowledge to leverage their power in your own C++ programs.\n\nSTL stands for Standard Template Library. STL is a set of general-purpose classes and functions mainly for storing and processing data. STL can be defined as a library of container classes, algorithms, and iterators, and vectors in C++ is part of STL. The main idea behind STL is to reuse codes already written and tested. It saves time and effort.\n• Algorithms: It defines a collection of functions specially designed to be used on ranges of elements. Examples are sorting, searching, etc.\n• Containers: Containers store objects and data. There are in total seven standard “first-class” container classes and three container adaptor classes and only seven header files that provide access to these container adaptors.\n• Functions: STL includes classes which overload the function call operator. Instances of such classes are called functors.\n• Iterators: It is used for working upon a sequence of values.It provides generiality in STL.\n\nWhat are Vectors in C++?\n\nVectors are part of STL. Vectors in C++ are sequence containers representing arrays that can change their size during runtime. They use contiguous storage locations for their elements just as efficiently as in arrays, which means that their elements can also be accessed using offsets on regular pointers to its elements.\n\nVectors are the dynamic arrays that are used to store data.It is different from arrays which store sequential data and are static in nature, Vectors provide more flexibility to the program. Vectors can adjust their size automatically when an element is inserted or deleted from it.\n\nVectors are not ordered in C++. Vector elements are placed in adjacent storage and can be easily accessed and traversed across using iterators. In vectors, data is inserted at the end when we use push_back() function . Inserting an element at the end of a vector takes differential time, as sometimes there may be a need of extending the vector, but inserting the element at the beginning or at the middle takes linear time. Removing the last element takes only constant time because no resizing takes place. Check out this free online C++ tutorial to learn more and enhance your skills.\n\nDeclaration of Vectors in C++\n\nIt is mandatory to include #include<vector> library before using vectors in C++.\n\nFor Vector declaration we need to follow the below syntax:\n• Pushing the values one-by-one in vector using push_back():\n• All the elements that need to be stored in the vector are pushed back one-by-one in the vector using the push_back() method.\n• Using the overload constructor of the vector Class:\n• This method is used to populate a vector with multiple times the same value.\n• This method uses array as a parameter to be passed in the vector constructor.\n• This method uses an already created vector to create a new vector with the same values.\n• This method passes the begin() and end() of an already initialized vector.\n\n\n\n|\n\nSyntax:\n\nvector<object_type> vector_name_1{val1,val2,…,valn};\n\nVarious Functions in Vectors are\n• begin() – It returns an iterator pointing to the first element in the vector.\n• end() – It returns an iterator pointing to the last element in the vector.\n• rbegin() – It returns a reverse iterator pointing to the last element in the vector.\n• rend() – It returns a reverse iterator pointing to the element preceding the first element in the vector. Basically considered as a reverse end.\n• cbegin() – It returns a constant iterator pointing to the first element in the vector.\n• cend() – It returns a constant iterator pointing to the element that follows the last element in the vector.\n• crbegin() – It returns a constant reverse iterator pointing to the last element in the vector.\n• crend() – It returns a constant reverse iterator pointing to the element preceding the first element in the vector.\n\nExample Code for Visualizing the use of Iterators:\n• size() – It returns the number of elements currently present in the vector.\n• max_size() – It returns the maximum number of elements that a vector can hold.\n• capacity() – It returns the storage capacity currently allocated to the vector.\n• resize(n) – It resizes the container to store ‘n’ elements.\n• empty() – It returns whether the container is empty or not.\n\nExample Code for visualizing the use of capacity functions:\n• assign() – It assigns a new value to the existing elements of the vector.\n• push_back() – It pushes the element from back in the vector.\n• pop_back() – It removes elements from the back of the vector.\n• insert() – It inserts an element before a specified element in the vector.\n• erase() – It is used to remove elements from a specified element or a range in the vector.\n• swap() – It is used to swap the contents of two vectors of the same datatype. The sizes of vectors may differ.\n• clear() – It is used to remove all the elements from the vector.\n\nExample code to Visualize the Modifiers Function in vector:\n• reference_operator[g]: It returns a reference to the ‘g’ element in the vetor.\n• at(g): It returns a reference to the element at position ‘g’ in the vector.\n• front(): It returns a reference to the first element in the vector.\n• back(): It returns a reference to the last element in the vector.\n• data(): It returns a direct pointer to the memory array which is used internally by the vector to store its owned elements.\n\nExample code to visualize the Element access function in C++:\n• An allocator is an object that dynamically allocates and deallocates memory.\n• In C++ vectors, there is only one function which can be used as an allocator. This function is called the get_allocator() function. We basically use the get_allocator() to allocate chunks of memory which in return a copy of the allocator object associated with the vector.\n\nWhen to use Vectors?\n\nWe can use Vectors in the following circumstances:\n\nIt is advisable to use vectors when data are consistently changing.\n\nIf the size of data is unknown then it is advisable to use vectors.\n\nIt is advisable to use vectors when elements are not predefined.\n\nCompared to arrays there are more ways to copy vectors.\n\nVectors and Array in C++\n• Array is a fixed-size sequential collection of elements of the same type.\n• Once the array is initialized it’s size can’t be changed.\n• Vector occupies more memory as compared to array.\n• Accessing time in vectors is more.\n• Array elements are arranged in contiguous memory allocation so it accesses elements in constant time.\n• Vectors can be only declared in C++.\n• Arrays can be declared in any programming language like C, Java, Python, etc.\n\nVector of Vectors in C++ STL\n• Vector of Vectors is a two-dimensional vector with a variable number of rows where each row is considered as a vector.\n• Each index of vector stores a vector in it. It can be accessed or traversed using iterators.\n• Basically, it can be considered as the array of vectors with dynamic properties.\n\nExample code to visualize Vector of Vectors in C++:\n• It is dynamic in nature.\n• It is very easy to copy vectors from one to another by just using assignment operator.\n• It is not indexed.\n• It is more appropriate in storing a fixed number of elements.\n• It is easy to sort in arrays.\n• Dynamic creation of arrays is not possible.\n• Deletion of elements is not easy.\n\nAs we have learned about C++ vectors, it is clear that it is a data structure that not only acts as a dynamic array but also ensures quick and random access of elements pertaining to that vector. Now, you can easily insert, delete, traverse, and modify elements in vectors as well as manage computer memory in an efficient manner.We can now understand where to apply vectors and where to apply arrays in a program.Vectors are an important concept for every C++ professional.\n\nWith this, we come to the end of this article on Vectors in C++. I hope you got an idea of how to use and where to use vectors in C++ programs. I hope you all got an idea of how arrays differ from vectors."
    }
]