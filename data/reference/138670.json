[
    {
        "link": "https://geeksforgeeks.org/class-getresourceasstream-method-in-java-with-examples",
        "document": "The getResourceAsStream() method of java.lang.Class class is used to get the resource with the specified resource of this class. The method returns the specified resource of this class in the form of InputStream object.\n\nParameter: This method accepts a parameter resourceName which is the resource to get.\n\nReturn Value: This method returns the specified resource of this class in the form of InputStream objects.\n• NullPointerException if name is null"
    },
    {
        "link": "https://docs.oracle.com/javase/8/docs/api/java/lang/ClassLoader.html",
        "document": "A class loader is an object that is responsible for loading classes. The classis an abstract class. Given the binary name of a class, a class loader should attempt to locate or generate data that constitutes a definition for the class. A typical strategy is to transform the name into a file name and then read a \"class file\" of that name from a file system.\n\nEvery object contains a to the that defined it.\n\nobjects for array classes are not created by class loaders, but are created automatically as required by the Java runtime. The class loader for an array class, as returned by is the same as the class loader for its element type; if the element type is a primitive type, then the array class has no class loader.\n\nApplications implement subclasses of in order to extend the manner in which the Java virtual machine dynamically loads classes.\n\nClass loaders may typically be used by security managers to indicate security domains.\n\nThe class uses a delegation model to search for classes and resources. Each instance of has an associated parent class loader. When requested to find a class or resource, a instance will delegate the search for the class or resource to its parent class loader before attempting to find the class or resource itself. The virtual machine's built-in class loader, called the \"bootstrap class loader\", does not itself have a parent but may serve as the parent of a instance.\n\nClass loaders that support concurrent loading of classes are known as parallel capable class loaders and are required to register themselves at their class initialization time by invoking the method. Note that the class is registered as parallel capable by default. However, its subclasses still need to register themselves if they are parallel capable. \n\n In environments in which the delegation model is not strictly hierarchical, class loaders need to be parallel capable, otherwise class loading can lead to deadlocks because the loader lock is held for the duration of the class loading process (see methods).\n\nNormally, the Java virtual machine loads classes from the local file system in a platform-dependent manner. For example, on UNIX systems, the virtual machine loads classes from the directory defined by the environment variable.\n\nHowever, some classes may not originate from a file; they may originate from other sources, such as the network, or they could be constructed by an application. The method converts an array of bytes into an instance of class . Instances of this newly defined class can be created using .\n\nThe methods and constructors of objects created by a class loader may reference other classes. To determine the class(es) referred to, the Java virtual machine invokes the method of the class loader that originally created the class.\n\nFor example, an application could create a network class loader to download class files from a server. Sample code might look like:\n\nThe network class loader subclass must define the methods and to load a class from the network. Once it has downloaded the bytes that make up the class, it should use the method to create a class instance. A sample implementation is:\n\nAny class name provided as a parameter to methods in must be a binary name as defined by ."
    },
    {
        "link": "https://stackoverflow.com/questions/51645295/how-to-specify-the-path-for-getresourceasstream-method-in-java",
        "document": "I know this question has been asked several times but I still can't get it work by those solutions.\n\nI have a maven project. And one Config.java file located in . Here's the content:\n\nI kept getting . I know that's because it can't find the file .\n\nAt first I put the file in the same folder( ) as Config.java file. And tried use and 'property_table_config.txt`. Neither of them work.\n\nAnd then I tried using absolute path, not working. And tried using , not working either.\n\nThen I saw this solution: https://stackoverflow.com/a/2103625/8159477. So I make a directory called resources and put it under main folder (i.e. the path of the folder is , and create a sub-folder under . After putting the file there, I changed the code into this:\n\nBut this still didn't work. Can anyone give some hint on this? Any suggestions will be appreciated!!"
    },
    {
        "link": "https://tutorialspoint.com/java/lang/classloader_getresourceasstream.htm",
        "document": ""
    },
    {
        "link": "https://stackoverflow.com/questions/27155195/how-getclassloader-getresourceasstream-works-in-java",
        "document": "I google how below code loads the resource Abc.class.getClassLoader().getResourceAsStream(\"abc.txt\")\n\n and find that it searchs the resource in all jar file and zip file in class path.\n\nBut when i tried it I am not able to loads it but if i give package path then I am able to loads it can someone tell me how getResourceAsStream search the class path\n\none scenario is :- My below code is a simple program and my resource file abc.txt is inside com.abc package. when i specify path of package it worked and when i did not it does not work.\n\nif getResourceAsStream looks the resource in all jar file and directory then why i have to specify the package path"
    },
    {
        "link": "https://stackoverflow.com/questions/3861989/preferred-way-of-loading-resources-in-java",
        "document": "Work out the solution according to what you want...\n\nThere are two things that / will get from the class it is called on...\n\nSo if you do\n\nit will attempt to load foo.txt from the same package as the \"this\" class and with the class loader of the \"this\" class. If you put a \"/\" in front then you are absolutely referencing the resource.\n\nwill load the resource from the class loader of \"this\" and from the x.y.z package (it will need to be in the same directory as classes in that package).\n\nwill load with the context class loader but will not resolve the name according to any package (it must be absolutely referenced)\n\nWill load the resource with the system class loader (it would have to be absolutely referenced as well, as you won't be able to put anything into the java.lang package (the package of System).\n\nJust take a look at the source. Also indicates that getResourceAsStream just calls \"openStream\" on the URL returned from getResource and returns that."
    },
    {
        "link": "https://baeldung.com/java-classloaders",
        "document": "A class loader is an object that is responsible for loading classes. Further, class loaders load Java classes dynamically to the JVM (Java Virtual Machine) during runtime. They’re also part of the JRE (Java Runtime Environment). Therefore, the JVM doesn’t need to know about the underlying files or file systems to run Java programs thanks to class loaders.\n\nFurthermore, the JVM doesn’t load these Java classes into memory all at once, but rather when an application requires them. This is where class loaders come into the picture. They’re responsible for loading classes into memory.\n\nIn this tutorial, we’ll talk about different types of built-in class loaders and how they work. Then we’ll introduce our custom implementation.\n\n Learn what memory leaks are in Java, how to recognize them at runtime, what causes them, and strategies for preventing them. Learn about the differences between ClassNotFoundException and NoClassDefFoundError.\n\n2. What Are the Functions of a Class Loader?\n• Load Classes – Different built-in and custom class loaders load classes. We can extend the java.lang.ClassLoader abstract class to create class loader implementations\n• Locate Resources – A resource is some data such as a .class file, configuration information, or an image. We typically package resources with an application or library so that they are easy to locate\n\nAt the outset, class loaders don’t create objects for array classes. Instead, the Java runtime creates them automatically as required. Therefore, when we use Class#getClassLoader() to find the class loader for an array class, it returns the class loader for its element type. Accordingly, an array class has no class loader if the element type is a primitive data type.\n• Bootstrap class loader – The virtual machine’s built-in class loader, is represented as null\n• Platform class loader – Loads the platform classes, which include the Java SE platform APIs, their implementation classes, and JDK-specific run-time classes. The platform class loader is the parent of the system class loader\n• System class loader – Also known as application class loader, loads classes on the application class path, module path, and JDK-specific tools\n\nLet’s start by learning how we can load different classes using various class loaders:\n\nWhen executed, the above method prints:\n\nAs we can see, there are three different class loaders here: bootstrap (displayed as null), platform, and system.\n\nThe system class loader loads the class that contains the example method. Let’s remember that the system class loader loads our files in the classpath.\n\nNext, the platform class loader loads the DriverManager class.\n\nFinally, the bootstrap class loader loads the ArrayList class. A bootstrap or primordial class loader is the parent of all the others; however, it doesn’t have a parent.\n\nHowever, we can see that for the ArrayList, it displays null in the output. This is because the bootstrap class loader is written in native code, not Java, so it doesn’t show up as a Java class. As a result, the behavior of the bootstrap class loader will differ across JVMs.\n\nNow, let’s discuss each of these class loaders in more detail.\n\nAn instance of java.lang.ClassLoader loads Java classes. However, class loaders are classes themselves. So the question is, who loads the java.lang.ClassLoader itself? This is where the bootstrap or primordial class loader comes into play. It’s mainly responsible for loading JDK internal classes, typically rt.jar and other core libraries located in the $JAVA_HOME/jre/lib directory. Additionally, the Bootstrap class loader serves as the parent of all the other ClassLoader instances.\n\nThis bootstrap class loader is part of the core JVM and is written in native code, as pointed out in the above example. Different platforms might have different implementations of this particular class loader.\n\nThe platform class loader is a child of the bootstrap class loader and takes care of loading the standard core Java classes so that they’re available to all applications running on the platform.\n\nThe system or application class loader, on the other hand, takes care of loading all the application-level classes into the JVM. It loads files found in the classpath environment variable, -classpath, or -cp command line option. It’s also a child of the platform class loader.\n\nClass loaders are part of the Java Runtime Environment. When the JVM requests a class, the class loader tries to locate the class and load the class definition into the runtime using the fully qualified class name. The java.lang.ClassLoader.loadClass(String name, boolean resolve) method is responsible for loading the class definition into runtime using its binary name. This method is an overloaded method; it has a variant java.lang.ClassLoader.loadClass(String name) with different parameters. It performs an ordered search:\n• It calls the findLoadedClass(String name) to check if the class has already been loaded. The method returns the class with the given binary name if the loader has already loaded the class. Otherwise, it returns null.\n• It calls the loadClass(String) method on the parent class loader. Further, it uses the virtual machine’s built-in class loader if the parent is null.\n• It calls the findClass(String) method to find the class.\n\nAs a result of the ordered search, if it doesn’t find the class and additionally we have set the resolve flag to true, it calls the resolveClass(Class) method on the resulting binary Class object.\n\nAs a result of the ordered search, if the class is not found, it throws java.lang.ClassNotFoundException.\n\nNow, let’s examine three important features of class loaders.\n\nThe delegation model means that the ClassLoader class delegates the search for a class or resource to its parent class loader before it tries to find the class or resource itself. The delegation model is hierarchical by default. The ClassLoader class supports concurrent loading of classes; therefore, it is parallel capable. Class loader implementations can register themselves at initialization time if they are to be parallel capable.\n\nClass loaders follow the delegation model, where on being requested to find a class or resource, a ClassLoader instance will delegate the search of the class or resource to the parent class loader.\n\nLet’s say we have a request to load an application class into the JVM. The system class loader first delegates the loading of that class to its parent platform class loader, which in turn delegates it to the bootstrap class loader.\n\nOnly if the bootstrap and then the platform class loader are unsuccessful in loading the class, does the system class loader try to load the class itself.\n\nAs a consequence of the delegation model, it’s easy to ensure unique classes, as we always try to delegate upwards.\n\nIf the parent class loader isn’t able to find the class, only then will the current instance attempt to do so itself.\n\nIn addition, child class loaders are visible to classes loaded by their parent class loaders.\n\nFor instance, classes loaded by the system class loader have visibility into classes loaded by the platform and bootstrap class loaders, but not vice-versa.\n\nTo illustrate this, if Class A is loaded by the application class loader, and class B is loaded by the platform class loader, then both A and B classes are visible as far as other classes loaded by the application class loader are concerned.\n\nClass B, however, is the only class visible to other classes loaded by the platform class loader.\n\nThe built-in class loader is sufficient for most cases where the files are already in the file system.\n\nHowever, in scenarios where we need to load classes out of the local hard drive or a network, we may need to make use of custom class loaders.\n\nIn this section, we’ll cover some other use cases for custom class loaders and demonstrate how to create one.\n\nCustom class loaders are helpful for more than just loading the class during runtime. A few use cases might include:\n• Creating classes dynamically suited to the user’s needs, e.g. in JDBC, switching between different driver implementations is done through dynamic class loading.\n• Implementing a class versioning mechanism while loading different bytecodes for classes with the same names and packages. This can be done either through a URL class loader (load jars via URLs) or custom class loaders.\n\nBelow are more concrete examples where custom class loaders might come in handy.\n\nBrowsers, for instance, use a custom class loader to load executable content from a website. A browser can load applets from different web pages using separate class loaders. The applet viewer, which is used to run applets, contains a ClassLoader that accesses a website on a remote server instead of looking in the local file system.\n\nIt then loads the raw bytecode files via HTTP, and turns them into classes inside the JVM. Even if these applets have the same name, they’re considered different components if loaded by different class loaders.\n\nNow that we understand why custom class loaders are relevant, let’s implement a subclass of ClassLoader to extend and summarise the functionality of how the JVM loads classes.\n\nFor illustration purposes, let’s say we need to load classes from a file using a custom class loader.\n\nWe need to extend the ClassLoader class and override the findClass() method:\n\nIn the above example, we defined a custom class loader that extends the default class loader and loads a byte array from the specified file.\n\nLet’s discuss a few essential methods from the java.lang.ClassLoader class to get a clearer picture of how it works.\n\nThis method is responsible for loading the class given a name parameter. The name parameter refers to the fully qualified class name:\n\nThe Java Virtual Machine invokes the loadClass() method to resolve class references, setting resolve to true. However, it isn’t always necessary to resolve a class. If we only need to determine if the class exists or not, then we set the resolve parameter to false.\n\nThis method serves as an entry point for the class loader.\n\nThe default implementation of the method searches for classes in an order, already discussed.\n\nThis method is responsible for the conversion of an array of bytes into an instance of a class. Before we use the class, we need to resolve it:\n\nIf the data doesn’t contain a valid class, it throws a ClassFormatError.\n\nAlso, we can’t override this method, since it’s marked as final.\n\nThis method finds the class with the fully qualified name as a parameter. We need to override this method in custom class loader implementations that follow the delegation model for loading classes:\n\nIn addition, loadClass() invokes this method if the parent class loader can’t find the requested class.\n\nThe default implementation throws a ClassNotFoundException if no parent of the class loader finds the class.\n\nThis method returns the parent class loader for delegation:\n\nSome implementations, like the one seen before in Section 4, use null to represent the bootstrap class loader.\n\nThis method tries to find a resource with the given name:\n\nIt’ll first be delegated to the parent class loader for the resource. If the parent is null, the path of the class loader built into the virtual machine is searched.\n\nIf that fails, then the method will invoke findResource(String) to find the resource. The resource name specified as an input can be relative or absolute to the classpath.\n\nIt returns a URL object for reading the resource, or null if the resource can’t be found or the invoker doesn’t have adequate privileges to return the resource.\n\nIt’s important to note that Java loads resources from the classpath.\n\nFinally, resource loading in Java is considered location-independent, as it doesn’t matter where the code is running as long as the environment is set to find the resources.\n\nIn general, context class loaders provide an alternative method to the class-loading delegation scheme introduced in J2SE.\n\nAs we learned before, classloaders in a JVM follow a hierarchical model, such that every class loader has a single parent except for the bootstrap class loader.\n\nHowever, sometimes when JVM core classes need to dynamically load classes or resources provided by application developers, we might encounter a problem.\n\nFor example, in JNDI, the core functionality is implemented by the bootstrap classes in rt.jar. But these JNDI classes may load JNDI providers implemented by independent vendors (deployed in the application classpath). This scenario calls for the bootstrap class loader (parent class loader) to load a class visible to the application loader (child class loader).\n\nJ2SE delegation doesn’t work here, and to get around this problem, we need to find alternative ways of class loading. This can be achieved using thread context loaders.\n\nThe java.lang.Thread class has a method, getContextClassLoader(), that returns the ContextClassLoader for the particular thread. The ContextClassLoader is provided by the creator of the thread when loading resources and classes. As of Java SE 9, threads in the fork/join common pool always return the system class loader as their thread context class loader.\n\nClass loaders are essential to execute a Java program. In this article, we provided a good introduction to them.\n\nWe discussed the different types of class loaders, namely Bootstrap, Platform, and System class loaders. Bootstrap serves as a parent for all of them and is responsible for loading the JDK internal classes. Platform and system, on the other hand, load classes from the Java platform and classpath, respectively.\n\nWe also learned how class loaders work and examined some features, such as delegation, visibility, and uniqueness. Then we briefly explained how to create a custom class loader. Finally, we provided an introduction to Context class loaders."
    },
    {
        "link": "https://medium.com/@alxkm/java-classloaders-developing-own-classloader-d478c295b3af",
        "document": "Are you curious about the inner workings of Java applications and how they manage to load classes dynamically? Dive into the fascinating world of Java Classloaders and take control of the class loading process by developing your very own Classloader.\n\nIn this article, we’ll embark on an enlightening journey through the intricacies of Java Classloaders. We’ll uncover the crucial role they play in the Java Virtual Machine (JVM) and how they facilitate the dynamic loading of classes during runtime. Understanding Classloaders is essential for Java developers looking to optimize application performance, implement custom class loading strategies, and delve deeper into the JVM’s runtime behavior.\n\nBy delving into the development of your own Classloader, you’ll gain invaluable insights into the mechanisms behind class loading in Java. You’ll learn how to customize the class loading process to suit your application’s unique requirements, whether it’s loading classes from unconventional sources, implementing custom class loading policies, or enhancing security measures.\n\nMoreover, developing your own Classloader is not just an educational endeavor — it’s a gateway to unlocking new possibilities in Java development. Armed with a deeper understanding of Classloaders, you’ll be better equipped to tackle complex challenges, optimize application performance, and explore innovative approaches to software development.\n\nJoin us on this exciting journey as we unravel the mysteries of Java Classloaders and empower you to take your Java development skills to new heights. Whether you’re a seasoned Java developer or just starting your journey, this article promises to provide valuable insights and practical knowledge that will enrich your Java programming experience.\n\nAre you ready to elevate your Java development skills and become a master of Classloaders? Let’s embark on this thrilling adventure together and unlock the full potential of Java development.\n\nThe Java ClassLoader is an abstract class found within the java.lang package. It serves the purpose of loading classes from various resources dynamically during runtime. Essentially, the Java ClassLoader facilitates the linking process within the JVM as it loads classes according to the program’s requirements. Additionally, if a loaded class has dependencies on other classes, those dependencies are also loaded. When a class loading request is made, it is delegated to its parent, ensuring consistency and uniqueness within the runtime environment. The role of the Java ClassLoader is indispensable for the execution of Java programs.\n\nThe foundation of Java ClassLoader rests upon three core principles: Delegation, Visibility, and Uniqueness.\n• Delegation: Java ClassLoader follows the principle of delegation, where it delegates the task of loading classes to its parent ClassLoader before attempting to load them itself. This hierarchical structure ensures that class loading requests are handled systematically, allowing for flexibility and consistency in the loading process.\n• Visibility: The visibility principle dictates that classes loaded by a particular ClassLoader are visible to that ClassLoader and its children but not to its parent or sibling ClassLoaders. This ensures encapsulation and prevents unintended dependencies between classes loaded by different ClassLoaders, promoting modularity and maintainability in Java applications.\n• Uniqueness: Java ClassLoader maintains the principle of uniqueness, ensuring that each class loaded by a ClassLoader is unique within the JVM’s runtime environment. This prevents class duplication and ambiguity, enabling reliable and predictable behavior during class loading and execution.\n\nThese principles collectively define the behavior and functionality of Java ClassLoader, shaping the dynamic loading process and contributing to the robustness and stability of Java applications.\n• Bootstrap ClassLoader: This is the first ClassLoader that is responsible for loading core Java classes, such as those from the java.lang package, from the JDK's rt.jar file or equivalent. It is implemented in native code and is not written in Java. It forms the foundation upon which the Java runtime environment is built.\n• Extension ClassLoader: Also known as the “Extension ClassLoader,” it is responsible for loading classes from the extension directories ($JAVA_HOME/jre/lib/ext or any other directories specified by the java.ext.dirs system property). It loads classes required by Java extension libraries, which are packages that provide additional functionality to the core Java platform.\n• System ClassLoader: Also known as the “Application ClassLoader,” it is responsible for loading classes from the application classpath. It loads classes from directories and JAR files specified by the java.class.path system property. This ClassLoader is typically used for loading application-specific classes and resources.\n\nIn Java, the ClassLoader is a crucial component of the Java Runtime Environment (JRE) responsible for dynamically loading classes into memory during runtime. Here’s how the ClassLoader works in Java:\n• Class Loading: When a Java program is executed, the ClassLoader loads classes into memory as they are referenced or needed by the program. The process of loading a class involves locating the bytecode (compiled Java code) for the class and creating a corresponding object in memory.\n• Delegation Model: The ClassLoader follows a delegation model, where it delegates the task of loading classes to its parent ClassLoader before attempting to load them itself. This hierarchical structure ensures that classes are loaded systematically and consistently across the Java runtime environment.\n• Loading Strategy: The ClassLoader employs a loading strategy based on three principles: delegation, visibility, and uniqueness.\n• Class Resolution: Once a class is loaded into memory, the ClassLoader performs class resolution, which involves linking the class with its dependencies and verifying its integrity. This includes resolving symbolic references, initializing static variables, and performing other necessary tasks to prepare the class for execution.\n• ClassLoader Hierarchy: In Java, ClassLoaders are organized into a hierarchical structure, with each ClassLoader having a parent ClassLoader. The Bootstrap ClassLoader serves as the root of the hierarchy, and it is responsible for loading core Java classes. Extension ClassLoader and System ClassLoader are typically its children, responsible for loading classes from extension directories and the application classpath, respectively.\n• Custom ClassLoaders: Java allows developers to create custom ClassLoaders to extend the functionality of the built-in ClassLoaders or provide custom loading behavior for classes from non-standard sources. Custom ClassLoaders offer flexibility and control over the class loading process, enabling the implementation of advanced class loading strategies tailored to specific application requirements.\n\nThe -verbose:class option is employed to provide detailed information regarding the classes being loaded by the JVM. This feature becomes particularly valuable when utilizing a class loader for dynamically loading classes. The output generated by this option offers insights into the loading process, aiding in troubleshooting and understanding the flow of class loading within the application. The following illustration illustrates a sample output produced by this option.\n\nThis example demonstrates a simple custom class loader that loads class files from a specified directory. It extends the ClassLoader class and overrides the findClass() method to load class bytes from the file system and define the class using the defineClass() method. Finally, it demonstrates how to use the custom class loader to load and instantiate a class dynamically at runtime.\n\nReplace “/path/to/class/files” with the path to the directory containing your class files, and “com.example.MyClass” with the fully qualified name of the class you want to load.\n\nThis example demonstrates a simple custom class loader that loads class files from a specified directory. It extends the ClassLoader class and overrides the findClass() method to load class bytes from the file system and define the class using the defineClass() method. Finally, it demonstrates how to use the custom class loader to load and instantiate a class dynamically at runtime."
    },
    {
        "link": "https://stackoverflow.com/questions/1119740/loading-files-with-classloader",
        "document": "This problem has been bugging me for a while. I have to load a couple files in my java app, and the only way I got working so far looks like this:\n\nBut this is ugly and terrible. For a while I thought I had this working:\n\nBut that no longer works for some reason (I must have changed something and not noticed. It returns null.\n\nShould I be using getResource() instead of getSystemResource() (if so, why is getSystemResource() static but not getResource())?\n\nI am using eclipse and I have tried including the folder in the build path (classpath) and not including it, it doesn't seem to make a difference."
    },
    {
        "link": "https://blogs.oracle.com/javamagazine/post/how-the-jvm-locates-loads-and-runs-libraries",
        "document": ""
    }
]