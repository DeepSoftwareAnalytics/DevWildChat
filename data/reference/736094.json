[
    {
        "link": "https://github.com/tiangolo/fastapi/issues/3683",
        "document": ""
    },
    {
        "link": "https://fastapi.tiangolo.com/tutorial/handling-errors",
        "document": "There are many situations in which you need to notify an error to a client that is using your API.\n\nThis client could be a browser with a frontend, a code from someone else, an IoT device, etc.\n\nYou could need to tell the client that:\n• The client doesn't have enough privileges for that operation.\n• The client doesn't have access to that resource.\n• The item the client was trying to access doesn't exist.\n\nIn these cases, you would normally return an HTTP status code in the range of 400 (from 400 to 499).\n\nThis is similar to the 200 HTTP status codes (from 200 to 299). Those \"200\" status codes mean that somehow there was a \"success\" in the request.\n\nThe status codes in the 400 range mean that there was an error from the client.\n\nRemember all those \"404 Not Found\" errors (and jokes)?\n\nTo return HTTP responses with errors to the client you use .\n\nRaise an in your code¶\n\nis a normal Python exception with additional data relevant for APIs.\n\nBecause it's a Python exception, you don't it, you it.\n\nThis also means that if you are inside a utility function that you are calling inside of your path operation function, and you raise the from inside of that utility function, it won't run the rest of the code in the path operation function, it will terminate that request right away and send the HTTP error from the to the client.\n\nThe benefit of raising an exception over ing a value will be more evident in the section about Dependencies and Security.\n\nIn this example, when the client requests an item by an ID that doesn't exist, raise an exception with a status code of :\n\nIf the client requests (an ), that client will receive an HTTP status code of 200, and a JSON response of:\n\nBut if the client requests (a non-existent ), that client will receive an HTTP status code of 404 (the \"not found\" error), and a JSON response of:\n\nThere are some situations in where it's useful to be able to add custom headers to the HTTP error. For example, for some types of security.\n\nYou probably won't need to use it directly in your code.\n\nBut in case you needed it for an advanced scenario, you can add custom headers:\n\nYou can add custom exception handlers with the same exception utilities from Starlette.\n\nLet's say you have a custom exception that you (or a library you use) might .\n\nAnd you want to handle this exception globally with FastAPI.\n\nYou could add a custom exception handler with :\n\nHere, if you request , the path operation will a .\n\nBut it will be handled by the .\n\nSo, you will receive a clean error, with an HTTP status code of and a JSON content of:\n\nThese handlers are in charge of returning the default JSON responses when you an and when the request has invalid data.\n\nYou can override these exception handlers with your own.\n\nAnd it also includes a default exception handler for it.\n\nTo override it, import the and use it with to decorate the exception handler.\n\nThe exception handler will receive a and the exception.\n\nNow, if you go to , instead of getting the default JSON error with:\n\nyou will get a text version, with:\n\nFastAPI uses it so that, if you use a Pydantic model in , and your data has an error, you will see the error in your log.\n\nBut the client/user will not see it. Instead, the client will receive an \"Internal Server Error\" with an HTTP status code .\n\nIt should be this way because if you have a Pydantic in your response or anywhere in your code (not in the client's request), it's actually a bug in your code.\n\nAnd while you fix it, your clients/users shouldn't have access to internal information about the error, as that could expose a security vulnerability.\n\nThe same way, you can override the handler.\n\nFor example, you could want to return a plain text response instead of JSON for these errors:\n\nThe contains the it received with invalid data.\n\nYou could use it while developing your app to log the body and debug it, return it to the user, etc.\n\nNow try sending an invalid item like:\n\nYou will receive a response telling you that the data is invalid containing the received body:\n\nFastAPI has its own .\n\nThe only difference is that FastAPI's accepts any JSON-able data for the field, while Starlette's only accepts strings for it.\n\nSo, you can keep raising FastAPI's as normally in your code.\n\nBut when you register an exception handler, you should register it for Starlette's .\n\nThis way, if any part of Starlette's internal code, or a Starlette extension or plug-in, raises a Starlette , your handler will be able to catch and handle it.\n\nIn this example, to be able to have both s in the same code, Starlette's exceptions is renamed to :\n\nIf you want to use the exception along with the same default exception handlers from FastAPI, you can import and reuse the default exception handlers from :\n\nIn this example you are just ing the error with a very expressive message, but you get the idea. You can use the exception and then just reuse the default exception handlers."
    },
    {
        "link": "https://stackoverflow.com/questions/61596911/catch-exception-globally-in-fastapi",
        "document": "I am trying to catch unhandled exceptions at global level. So somewhere in file I have the below:\n\nBut the above method is never executed. However, if I write a custom exception and try to catch it (as shown below), it works just fine.\n\nI have gone through Catch exception type of Exception and process body request #575. But this bug talks about accessing request body. After seeing this bug, I feel it should be possible to catch . FastAPI version I am using is: .\n\nThere are multiple answers, I am thankful to all the readers and authors here. I was revisiting this solution in my application. Now I see that I needed to set , default it's , but I had it set to in\n\nIt seems that I missed it when @iedmrc commented on answer given by @Kavindu Dodanduwa."
    },
    {
        "link": "https://stackoverflow.com/questions/63048825/how-to-upload-file-using-fastapi",
        "document": "First, as per FastAPI documentation, you need to install —if you haven't already—as uploaded files are sent as \"form data\". For instance:\n\nThe examples below use the attribute of the object to get the actual Python file (i.e., ), which allows you to call the 's methods, such as and , without having to them. It is important, however, to define your endpoint with in this case—otherwise, if the endpoint was defined with , such operations would block the server until they are completed. In FastAPI, a normal endpoint is run in an external threadpool that is then ed, instead of being called directly (as it would block the server). I would highly suggest having a look at this answer, which explains the difference between and endpoints, as well as provides a number of solutions when one needs to run blocking operations inside endpoints.\n\nThe used by FastAPI/Starlette has the attribute set to 1 MB, meaning that the data are spooled in memory until the file size exceeds 1 MB, at which point the data are written to a temporary file on disk, under the OS's temp directory. Hence, if you uploaded a file larger than 1 MB, it wouldn't be stored in memory, and calling would actually read the data from disk into memory. Thus, if the file is too large to fit into your server's RAM, you should rather read the file in chunks and process one chunk at a time, as described in \"Read the File in chunks\" section below.\n\nAs explained above and in this answer as well, FastAPI/Starlette uses AnyIO threads to run blocking functions, such as endpoints defined with normal , in an external threadpool and then them (so that FastAPI would still work asynchronously), in order to prevent them from blocking the event loop (of the main thread), and hence, the entire server. Therefore, every time an HTTP request arrives at an endpoint defined with normal , a new thread will be spawned (or an idle thread will be used, if available), and thus, depending on the requirements of your project, the expected traffic (i.e., number of users simultaneously accessing your API), as well as any other blocking functions in your API that will eventually run in that threadpool (see the linked answers above for more details), you might need to adjust the maximum number of threads in that threadpool (see the linked answer above on how to do that).\n\nHowever, you should always aim at using asynchronous code (i.e., using / ), wherever is possible, as code runs directly in the event loop which runs in a single thread (in this case, the main thread). One option would be to define the endpoint with and use the asynchronous / / /etc. file methods provided by FastAPI, as demonstrated in this answer. You should, however, note that, as explained in this answer, FastAPI, behind the scenes, actually calls the corresponding synchronous Python File methods in a separate thread from the external threadpool described earlier. Thus, it might or might not make a big difference (always perform and compare tests before choosing one approach over the other).\n\nNote that in the bottom part of this answer, as well as in this answer, another approach is explained and demonstrated on how to upload large files in chunks, using Starlette's , which results in considerably minimizing the time required to upload files, as well as avoiding the use of threads from the external threadpool. Thus, I would highly recommend taking a look.\n\nAs described earlier and in this answer, if the file is too big to fit into memory—for instance, if you have 8GB of RAM, you can't load a 50GB file (not to mention that the available RAM will always be less than the total amount installed on your machine, as other applications will be using some of the RAM)—you should rather load the file into memory in chunks and process the data one chunk at a time. This method, however, may take longer to complete, depending on the chunk size you choose—in the example below, the chunk size is bytes (i.e., 1MB). You can adjust the chunk size as desired.\n\nAnother option would be to use , which is used to copy the contents of a object to another object (have a look at this answer too). By default, the data is read in chunks with the default buffer (chunk) size being 1MB (i.e., bytes) for Windows and 64KB for other platforms, as shown in the source code here. You can specify the buffer size by passing the optional parameter. Note: If negative value is passed, the entire contents of the file will be read instead—see as well, which uses under the hood (as can be seen in the source code here).\n\nFor an HTML example, see here.\n\nAs described earlier in this answer, if you expect some rather large file(s) and don't have enough RAM to accommodate all the data from the beginning to the end, you should rather load the file into memory in chunks, thus processing the data one chunk at a time (Note: adjust the chunk size as desired, below that is bytes).\n\nFor an HTML example, see here."
    },
    {
        "link": "https://github.com/tiangolo/fastapi/issues/3373",
        "document": ""
    },
    {
        "link": "https://pypi.org/project/pillow",
        "document": "A required part of this site couldn’t load. This may be due to a browser extension, network issues, or browser settings. Please check your connection, disable any ad blockers, or try using a different browser."
    },
    {
        "link": "https://pillow.readthedocs.io",
        "document": "Pillow is the friendly PIL fork by Jeffrey A. Clark and contributors. PIL is the Python Imaging Library by Fredrik Lundh and contributors.\n\nPillow for enterprise is available via the Tidelift Subscription. Learn more."
    },
    {
        "link": "https://pillow.readthedocs.io/en/stable/reference/Image.html",
        "document": "The module provides a class with the same name which is used to represent a PIL image. The module also provides a number of factory functions, including functions to load images from files, and to create new images.\n\nInstances of the class have the following attributes: The filename or path of the source file. Only images created with the factory function have a filename attribute. If the input is a file like object, the filename attribute is set to an empty string. The file format of the source file. For images created by the library itself (via a factory function, or by running a method on an existing image), this attribute is set to . Image mode. This is a string specifying the pixel format used by the image. Typical values are “1”, “L”, “RGB”, or “CMYK.” See Modes for a full list. Image size, in pixels. The size is given as a 2-tuple (width, height). Colour palette table, if any. If mode is “P” or “PA”, this should be an instance of the class. Otherwise, it should be set to . A dictionary holding data associated with the image. This dictionary is used by file handlers to pass on various non-image information read from the file. See documentation for the various file handlers for details. Most methods ignore the dictionary when returning new images; since the keys are not standardized, it’s not possible for a method to know if the operation affects the dictionary. If you need the information later on, keep a reference to the info dictionary returned from the open method. Unless noted elsewhere, this dictionary does not affect saving files. if this image has more than one frame, or otherwise. This attribute is only defined by image plugins that support animated images. Plugins may leave this attribute undefined if they don’t support loading animated images, even if the given format supports animated images. Given that this attribute is not present for all images use to check if Pillow is aware of multiple frames in an image regardless of its format. The number of frames in this image. This attribute is only defined by image plugins that support animated images. Plugins may leave this attribute undefined if they don’t support loading animated images, even if the given format supports animated images. Given that this attribute is not present for all images use to check the number of frames that Pillow is aware of in an image regardless of its format. Determine if an image has transparency data, whether in the form of an alpha channel, a palette with an alpha channel, or a “transparency” key in the info dictionary. Note the image might still appear solid, if all of the values shown within are opaque."
    },
    {
        "link": "https://readthedocs.org/projects/pillow/downloads/pdf/latest",
        "document": ""
    },
    {
        "link": "https://docs.python.org/3/contents.html",
        "document": ""
    }
]