[
    {
        "link": "https://legacy.reactjs.org/docs/hooks-reference.html",
        "document": "Hooks are a new addition in React 16.8. They let you use state and other React features without writing a class.\n\nThis page describes the APIs for the built-in Hooks in React.\n\nIf you’re new to Hooks, you might want to check out the overview first. You may also find useful information in the frequently asked questions section.\n\nReturns a stateful value, and a function to update it.\n\nDuring the initial render, the returned state ( ) is the same as the value passed as the first argument ( ).\n\nThe function is used to update the state. It accepts a new state value and enqueues a re-render of the component.\n\nDuring subsequent re-renders, the first value returned by will always be the most recent state after applying updates.\n\nIf the new state is computed using the previous state, you can pass a function to . The function will receive the previous value, and return an updated value. Here’s an example of a counter component that uses both forms of :\n\nThe ”+” and ”-” buttons use the functional form, because the updated value is based on the previous value. But the “Reset” button uses the normal form, because it always sets the count back to the initial value.\n\nIf your update function returns the exact same value as the current state, the subsequent rerender will be skipped completely.\n\nThe argument is the state used during the initial render. In subsequent renders, it is disregarded. If the initial state is the result of an expensive computation, you may provide a function instead, which will be executed only on the initial render:\n\nIf you update a State Hook to the same value as the current state, React will bail out without rendering the children or firing effects. (React uses the comparison algorithm.)\n\nNote that React may still need to render that specific component again before bailing out. That shouldn’t be a concern because React won’t unnecessarily go “deeper” into the tree. If you’re doing expensive calculations while rendering, you can optimize them with .\n\nReact may group several state updates into a single re-render to improve performance. Normally, this improves performance and shouldn’t affect your application’s behavior.\n\nBefore React 18, only updates inside React event handlers were batched. Starting with React 18, batching is enabled for all updates by default. Note that React makes sure that updates from several different user-initiated events — for example, clicking a button twice — are always processed separately and do not get batched. This prevents logical mistakes.\n\nIn the rare case that you need to force the DOM update to be applied synchronously, you may wrap it in . However, this can hurt performance so do this only where needed.\n\nMutations, subscriptions, timers, logging, and other side effects are not allowed inside the main body of a function component (referred to as React’s render phase). Doing so will lead to confusing bugs and inconsistencies in the UI.\n\nInstead, use . The function passed to will run after the render is committed to the screen. Think of effects as an escape hatch from React’s purely functional world into the imperative world.\n\nBy default, effects run after every completed render, but you can choose to fire them only when certain values have changed.\n\nOften, effects create resources that need to be cleaned up before the component leaves the screen, such as a subscription or timer ID. To do this, the function passed to may return a clean-up function. For example, to create a subscription:\n\nThe clean-up function runs before the component is removed from the UI to prevent memory leaks. Additionally, if a component renders multiple times (as they typically do), the previous effect is cleaned up before executing the next effect. In our example, this means a new subscription is created on every update. To avoid firing an effect on every update, refer to the next section.\n\nUnlike and , the function passed to fires after layout and paint, during a deferred event. This makes it suitable for the many common side effects, like setting up subscriptions and event handlers, because most types of work shouldn’t block the browser from updating the screen.\n\nHowever, not all effects can be deferred. For example, a DOM mutation that is visible to the user must fire synchronously before the next paint so that the user does not perceive a visual inconsistency. (The distinction is conceptually similar to passive versus active event listeners.) For these types of effects, React provides one additional Hook called . It has the same signature as , and only differs in when it is fired.\n\nAdditionally, starting in React 18, the function passed to will fire synchronously before layout and paint when it’s the result of a discrete user input such as a click, or when it’s the result of an update wrapped in . This behavior allows the result of the effect to be observed by the event system, or by the caller of .\n\nEven in cases where is deferred until after the browser has painted, it’s guaranteed to fire before any new renders. React will always flush a previous render’s effects before starting a new update.\n\nThe default behavior for effects is to fire the effect after every completed render. That way an effect is always recreated if one of its dependencies changes.\n\nHowever, this may be overkill in some cases, like the subscription example from the previous section. We don’t need to create a new subscription on every update, only if the prop has changed.\n\nTo implement this, pass a second argument to that is the array of values that the effect depends on. Our updated example now looks like this:\n\nNow the subscription will only be recreated when changes.\n\nThe array of dependencies is not passed as arguments to the effect function. Conceptually, though, that’s what they represent: every value referenced inside the effect function should also appear in the dependencies array. In the future, a sufficiently advanced compiler could create this array automatically.\n\nAccepts a context object (the value returned from ) and returns the current context value for that context. The current context value is determined by the prop of the nearest above the calling component in the tree.\n\nWhen the nearest above the component updates, this Hook will trigger a rerender with the latest context passed to that provider. Even if an ancestor uses or , a rerender will still happen starting at the component itself using .\n\nDon’t forget that the argument to must be the context object itself:\n\nA component calling will always re-render when the context value changes. If re-rendering the component is expensive, you can optimize it by using memoization.\n\nPutting it together with Context.Provider\n\nThis example is modified for hooks from a previous example in the Context Advanced Guide, where you can find more information about when and how to use Context.\n\nThe following Hooks are either variants of the basic ones from the previous section, or only needed for specific edge cases. Don’t stress about learning them up front.\n\nAn alternative to . Accepts a reducer of type , and returns the current state paired with a method. (If you’re familiar with Redux, you already know how this works.)\n\nis usually preferable to when you have complex state logic that involves multiple sub-values or when the next state depends on the previous one. also lets you optimize performance for components that trigger deep updates because you can pass down instead of callbacks.\n\nHere’s the counter example from the section, rewritten to use a reducer:\n\nThere are two different ways to initialize state. You may choose either one depending on the use case. The simplest way is to pass the initial state as a second argument:\n\nYou can also create the initial state lazily. To do this, you can pass an function as the third argument. The initial state will be set to .\n\nIt lets you extract the logic for calculating the initial state outside the reducer. This is also handy for resetting the state later in response to an action:\n\nIf you return the same value from a Reducer Hook as the current state, React will bail out without rendering the children or firing effects. (React uses the comparison algorithm.)\n\nNote that React may still need to render that specific component again before bailing out. That shouldn’t be a concern because React won’t unnecessarily go “deeper” into the tree. If you’re doing expensive calculations while rendering, you can optimize them with .\n\nPass an inline callback and an array of dependencies. will return a memoized version of the callback that only changes if one of the dependencies has changed. This is useful when passing callbacks to optimized child components that rely on reference equality to prevent unnecessary renders (e.g. ).\n\nPass a “create” function and an array of dependencies. will only recompute the memoized value when one of the dependencies has changed. This optimization helps to avoid expensive calculations on every render.\n\nRemember that the function passed to runs during rendering. Don’t do anything there that you wouldn’t normally do while rendering. For example, side effects belong in , not .\n\nIf no array is provided, a new value will be computed on every render.\n\nYou may rely on as a performance optimization, not as a semantic guarantee. In the future, React may choose to “forget” some previously memoized values and recalculate them on next render, e.g. to free memory for offscreen components. Write your code so that it still works without — and then add it to optimize performance.\n\nreturns a mutable ref object whose property is initialized to the passed argument ( ). The returned object will persist for the full lifetime of the component.\n\nA common use case is to access a child imperatively:\n\nEssentially, is like a “box” that can hold a mutable value in its property.\n\nYou might be familiar with refs primarily as a way to access the DOM. If you pass a ref object to React with , React will set its property to the corresponding DOM node whenever that node changes.\n\nHowever, is useful for more than the attribute. It’s handy for keeping any mutable value around similar to how you’d use instance fields in classes.\n\nThis works because creates a plain JavaScript object. The only difference between and creating a object yourself is that will give you the same ref object on every render.\n\nKeep in mind that doesn’t notify you when its content changes. Mutating the property doesn’t cause a re-render. If you want to run some code when React attaches or detaches a ref to a DOM node, you may want to use a callback ref instead.\n\ncustomizes the instance value that is exposed to parent components when using . As always, imperative code using refs should be avoided in most cases. should be used with :\n\nIn this example, a parent component that renders would be able to call .\n\nThe signature is identical to , but it fires synchronously after all DOM mutations. Use this to read layout from the DOM and synchronously re-render. Updates scheduled inside will be flushed synchronously, before the browser has a chance to paint.\n\nPrefer the standard when possible to avoid blocking visual updates.\n\ncan be used to display a label for custom hooks in React DevTools.\n\nFor example, consider the custom Hook described in “Building Your Own Hooks”:\n\nIn some cases formatting a value for display might be an expensive operation. It’s also unnecessary unless a Hook is actually inspected.\n\nFor this reason accepts a formatting function as an optional second parameter. This function is only called if the Hooks are inspected. It receives the debug value as a parameter and should return a formatted display value.\n\nFor example a custom Hook that returned a value could avoid calling the function unnecessarily by passing the following formatter:\n\naccepts a value and returns a new copy of the value that will defer to more urgent updates. If the current render is the result of an urgent update, like user input, React will return the previous value and then render the new value after the urgent render has completed.\n\nThis hook is similar to user-space hooks which use debouncing or throttling to defer updates. The benefits to using is that React will work on the update as soon as other work finishes (instead of waiting for an arbitrary amount of time), and like , deferred values can suspend without triggering an unexpected fallback for existing content.\n\nonly defers the value that you pass to it. If you want to prevent a child component from re-rendering during an urgent update, you must also memoize that component with or :\n\nMemoizing the children tells React that it only needs to re-render them when changes and not when changes. This caveat is not unique to , and it’s the same pattern you would use with similar hooks that use debouncing or throttling.\n\nReturns a stateful value for the pending state of the transition, and a function to start it.\n\nlets you mark updates in the provided callback as transitions:\n\nindicates when a transition is active to show a pending state:\n\nis a hook for generating unique IDs that are stable across the server and client, while avoiding hydration mismatches.\n\nFor a basic example, pass the directly to the elements that need it:\n\nFor multiple IDs in the same component, append a suffix using the same :\n\nThe following Hooks are provided for library authors to integrate libraries deeply into the React model, and are not typically used in application code.\n\nis a hook recommended for reading and subscribing from external data sources in a way that’s compatible with concurrent rendering features like selective hydration and time slicing.\n\nThis method returns the value of the store and accepts three arguments:\n• : function to register a callback that is called whenever the store changes.\n• : function that returns the current value of the store.\n• : function that returns the snapshot used during server rendering.\n\nThe most basic example simply subscribes to the entire store:\n\nHowever, you can also subscribe to a specific field:\n\nWhen server rendering, you must serialize the store value used on the server, and provide it to . React will use this snapshot during hydration to prevent server mismatches:\n\nThe signature is identical to , but it fires synchronously before all DOM mutations. Use this to inject styles into the DOM before reading layout in . Since this hook is limited in scope, this hook does not have access to refs and cannot schedule updates."
    },
    {
        "link": "https://react.dev/reference/react/useEffect",
        "document": "In this example, a cleanup function is not needed because the class manages only the DOM node that was passed to it. After the React component is removed from the tree, both the DOM node and the class instance will be automatically garbage-collected by the browser JavaScript engine. You can use an Effect to fetch data for your component. Note that if you use a framework, using your framework’s data fetching mechanism will be a lot more efficient than writing Effects manually. If you want to fetch data from an Effect manually, your code might look like this: Note the variable which is initialized to , and is set to during cleanup. This ensures your code doesn’t suffer from “race conditions”: network responses may arrive in a different order than you sent them.\n\nWriting data fetching directly in Effects gets repetitive and makes it difficult to add optimizations like caching and server rendering later. It’s easier to use a custom Hook—either your own or maintained by the community. What are good alternatives to data fetching in Effects? Writing calls inside Effects is a popular way to fetch data, especially in fully client-side apps. This is, however, a very manual approach and it has significant downsides:\n• Effects don’t run on the server. This means that the initial server-rendered HTML will only include a loading state with no data. The client computer will have to download all JavaScript and render your app only to discover that now it needs to load the data. This is not very efficient.\n• Fetching directly in Effects makes it easy to create “network waterfalls”. You render the parent component, it fetches some data, renders the child components, and then they start fetching their data. If the network is not very fast, this is significantly slower than fetching all data in parallel.\n• Fetching directly in Effects usually means you don’t preload or cache data. For example, if the component unmounts and then mounts again, it would have to fetch the data again.\n• It’s not very ergonomic. There’s quite a bit of boilerplate code involved when writing calls in a way that doesn’t suffer from bugs like race conditions. This list of downsides is not specific to React. It applies to fetching data on mount with any library. Like with routing, data fetching is not trivial to do well, so we recommend the following approaches:\n• If you use a framework, use its built-in data fetching mechanism. Modern React frameworks have integrated data fetching mechanisms that are efficient and don’t suffer from the above pitfalls.\n• Otherwise, consider using or building a client-side cache. Popular open source solutions include React Query, useSWR, and React Router 6.4+. You can build your own solution too, in which case you would use Effects under the hood but also add logic for deduplicating requests, caching responses, and avoiding network waterfalls (by preloading data or hoisting data requirements to routes). You can continue fetching data directly in Effects if neither of these approaches suit you. Notice that you can’t “choose” the dependencies of your Effect. Every reactive value used by your Effect’s code must be declared as a dependency. Your Effect’s dependency list is determined by the surrounding code: If either or change, your Effect will reconnect to the chat using the new values. Reactive values include props and all variables and functions declared directly inside of your component. Since and are reactive values, you can’t remove them from the dependencies. If you try to omit them and your linter is correctly configured for React, the linter will flag this as a mistake you need to fix: To remove a dependency, you need to “prove” to the linter that it doesn’t need to be a dependency. For example, you can move out of your component to prove that it’s not reactive and won’t change on re-renders: Now that is not a reactive value (and can’t change on a re-render), it doesn’t need to be a dependency. If your Effect’s code doesn’t use any reactive values, its dependency list should be empty ( ): An Effect with empty dependencies doesn’t re-run when any of your component’s props or state change. If you have an existing codebase, you might have some Effects that suppress the linter like this: When dependencies don’t match the code, there is a high risk of introducing bugs. By suppressing the linter, you “lie” to React about the values your Effect depends on. Instead, prove they’re unnecessary.\n\nNow that you create the object inside the Effect, the Effect itself only depends on the string. With this fix, typing into the input doesn’t reconnect the chat. Unlike an object which gets re-created, a string like doesn’t change unless you set it to another value. Read more about removing dependencies. If your Effect depends on an object or a function created during rendering, it might run too often. For example, this Effect re-connects after every render because the function is different for every render: By itself, creating a function from scratch on every re-render is not a problem. You don’t need to optimize that. However, if you use it as a dependency of your Effect, it will cause your Effect to re-run after every re-render. Avoid using a function created during rendering as a dependency. Instead, declare it inside the Effect:"
    },
    {
        "link": "https://react.dev/reference/react/useState",
        "document": "Suppose the is . This handler calls three times: However, after one click, will only be rather than ! This is because calling the function does not update the state variable in the already running code. So each call becomes . To solve this problem, you may pass an updater function to instead of the next state: Here, is your updater function. It takes the pending state and calculates the next state from it. React puts your updater functions in a queue. Then, during the next render, it will call them in the same order:\n• will receive as the pending state and return as the next state.\n• will receive as the pending state and return as the next state.\n• will receive as the pending state and return as the next state. There are no other queued updates, so React will store as the current state in the end. By convention, it’s common to name the pending state argument for the first letter of the state variable name, like for . However, you may also call it like or something else that you find clearer. React may call your updaters twice in development to verify that they are pure. You might hear a recommendation to always write code like if the state you’re setting is calculated from the previous state. There is no harm in it, but it is also not always necessary. In most cases, there is no difference between these two approaches. React always makes sure that for intentional user actions, like clicks, the state variable would be updated before the next click. This means there is no risk of a click handler seeing a “stale” at the beginning of the event handler. However, if you do multiple updates within the same event, updaters can be helpful. They’re also helpful if accessing the state variable itself is inconvenient (you might run into this when optimizing re-renders). If you prefer consistency over slightly more verbose syntax, it’s reasonable to always write an updater if the state you’re setting is calculated from the previous state. If it’s calculated from the previous state of some other state variable, you might want to combine them into one object and use a reducer.\n\nReact saves the initial state once and ignores it on the next renders. Although the result of is only used for the initial render, you’re still calling this function on every render. This can be wasteful if it’s creating large arrays or performing expensive calculations. To solve this, you may pass it as an initializer function to instead: Notice that you’re passing , which is the function itself, and not , which is the result of calling it. If you pass a function to , React will only call it during initialization. React may call your initializers twice in development to verify that they are pure.\n\nUsually, you will update state in event handlers. However, in rare cases you might want to adjust state in response to rendering — for example, you might want to change a state variable when a prop changes. In most cases, you don’t need this:\n• If the value you need can be computed entirely from the current props or other state, remove that redundant state altogether. If you’re worried about recomputing too often, the Hook can help.\n• If you want to reset the entire component tree’s state, pass a different to your component.\n• If you can, update all the relevant state in the event handlers. In the rare case that none of these apply, there is a pattern you can use to update state based on the values that have been rendered so far, by calling a function while your component is rendering. Here’s an example. This component displays the prop passed to it: Say you want to show whether the counter has increased or decreased since the last change. The prop doesn’t tell you this — you need to keep track of its previous value. Add the state variable to track it. Add another state variable called to hold whether the count has increased or decreased. Compare with , and if they’re not equal, update both and . Now you can show both the current count prop and how it has changed since the last render.\n\nNote that if you call a function while rendering, it must be inside a condition like , and there must be a call like inside of the condition. Otherwise, your component would re-render in a loop until it crashes. Also, you can only update the state of the currently rendering component like this. Calling the function of another component during rendering is an error. Finally, your call should still update state without mutation — this doesn’t mean you can break other rules of pure functions. This pattern can be hard to understand and is usually best avoided. However, it’s better than updating state in an effect. When you call the function during render, React will re-render that component immediately after your component exits with a statement, and before rendering the children. This way, children don’t need to render twice. The rest of your component function will still execute (and the result will be thrown away). If your condition is below all the Hook calls, you may add an early to restart rendering earlier. Calling the function does not change state in the running code: This is because states behaves like a snapshot. Updating state requests another render with the new state value, but does not affect the JavaScript variable in your already-running event handler. If you need to use the next state, you can save it in a variable before passing it to the function: React will ignore your update if the next state is equal to the previous state, as determined by an comparison. This usually happens when you change an object or an array in state directly: You mutated an existing object and passed it back to , so React ignored the update. To fix this, you need to ensure that you’re always replacing objects and arrays in state instead of mutating them: I’m getting an error: “Too many re-renders” You might get an error that says: Too many re-renders. React limits the number of renders to prevent an infinite loop. Typically, this means that you’re unconditionally setting state during render, so your component enters a loop: render, set state (which causes a render), render, set state (which causes a render), and so on. Very often, this is caused by a mistake in specifying an event handler: If you can’t find the cause of this error, click on the arrow next to the error in the console and look through the JavaScript stack to find the specific function call responsible for the error. In Strict Mode, React will call some of your functions twice instead of once: This is expected and shouldn’t break your code. This development-only behavior helps you keep components pure. React uses the result of one of the calls, and ignores the result of the other call. As long as your component, initializer, and updater functions are pure, this shouldn’t affect your logic. However, if they are accidentally impure, this helps you notice the mistakes. For example, this impure updater function mutates an array in state: Because React calls your updater function twice, you’ll see the todo was added twice, so you’ll know that there is a mistake. In this example, you can fix the mistake by replacing the array instead of mutating it: Now that this updater function is pure, calling it an extra time doesn’t make a difference in behavior. This is why React calling it twice helps you find mistakes. Only component, initializer, and updater functions need to be pure. Event handlers don’t need to be pure, so React will never call your event handlers twice. I’m trying to set state to a function, but it gets called instead You can’t put a function into state like this: Because you’re passing a function, React assumes that is an initializer function, and that is an updater function, so it tries to call them and store the result. To actually store a function, you have to put before them in both cases. Then React will store the functions you pass."
    },
    {
        "link": "https://legacy.reactjs.org/docs/hooks-effect.html",
        "document": "Hooks are a new addition in React 16.8. They let you use state and other React features without writing a class.\n\nThe Effect Hook lets you perform side effects in function components:\n\nThis snippet is based on the counter example from the previous page, but we added a new feature to it: we set the document title to a custom message including the number of clicks.\n\nData fetching, setting up a subscription, and manually changing the DOM in React components are all examples of side effects. Whether or not you’re used to calling these operations “side effects” (or just “effects”), you’ve likely performed them in your components before.\n\nThere are two common kinds of side effects in React components: those that don’t require cleanup, and those that do. Let’s look at this distinction in more detail.\n\nSometimes, we want to run some additional code after React has updated the DOM. Network requests, manual DOM mutations, and logging are common examples of effects that don’t require a cleanup. We say that because we can run them and immediately forget about them. Let’s compare how classes and Hooks let us express such side effects.\n\nIn React class components, the method itself shouldn’t cause side effects. It would be too early — we typically want to perform our effects after React has updated the DOM.\n\nThis is why in React classes, we put side effects into and . Coming back to our example, here is a React counter class component that updates the document title right after React makes changes to the DOM:\n\nNote how we have to duplicate the code between these two lifecycle methods in class.\n\nThis is because in many cases we want to perform the same side effect regardless of whether the component just mounted, or if it has been updated. Conceptually, we want it to happen after every render — but React class components don’t have a method like this. We could extract a separate method but we would still have to call it in two places.\n\nNow let’s see how we can do the same with the Hook.\n\nWe’ve already seen this example at the top of this page, but let’s take a closer look at it:\n\nWhat does do? By using this Hook, you tell React that your component needs to do something after render. React will remember the function you passed (we’ll refer to it as our “effect”), and call it later after performing the DOM updates. In this effect, we set the document title, but we could also perform data fetching or call some other imperative API.\n\nWhy is called inside a component? Placing inside the component lets us access the state variable (or any props) right from the effect. We don’t need a special API to read it — it’s already in the function scope. Hooks embrace JavaScript closures and avoid introducing React-specific APIs where JavaScript already provides a solution.\n\nDoes run after every render? Yes! By default, it runs both after the first render and after every update. (We will later talk about how to customize this.) Instead of thinking in terms of “mounting” and “updating”, you might find it easier to think that effects happen “after render”. React guarantees the DOM has been updated by the time it runs the effects.\n\nNow that we know more about effects, these lines should make sense:\n\nWe declare the state variable, and then we tell React we need to use an effect. We pass a function to the Hook. This function we pass is our effect. Inside our effect, we set the document title using the browser API. We can read the latest inside the effect because it’s in the scope of our function. When React renders our component, it will remember the effect we used, and then run our effect after updating the DOM. This happens for every render, including the first one.\n\nExperienced JavaScript developers might notice that the function passed to is going to be different on every render. This is intentional. In fact, this is what lets us read the value from inside the effect without worrying about it getting stale. Every time we re-render, we schedule a different effect, replacing the previous one. In a way, this makes the effects behave more like a part of the render result — each effect “belongs” to a particular render. We will see more clearly why this is useful later on this page.\n\nEarlier, we looked at how to express side effects that don’t require any cleanup. However, some effects do. For example, we might want to set up a subscription to some external data source. In that case, it is important to clean up so that we don’t introduce a memory leak! Let’s compare how we can do it with classes and with Hooks.\n\nIn a React class, you would typically set up a subscription in , and clean it up in . For example, let’s say we have a module that lets us subscribe to a friend’s online status. Here’s how we might subscribe and display that status using a class:\n\nNotice how and need to mirror each other. Lifecycle methods force us to split this logic even though conceptually code in both of them is related to the same effect.\n\nLet’s see how we could write this component with Hooks.\n\nYou might be thinking that we’d need a separate effect to perform the cleanup. But code for adding and removing a subscription is so tightly related that is designed to keep it together. If your effect returns a function, React will run it when it is time to clean up:\n\nWhy did we return a function from our effect? This is the optional cleanup mechanism for effects. Every effect may return a function that cleans up after it. This lets us keep the logic for adding and removing subscriptions close to each other. They’re part of the same effect!\n\nWhen exactly does React clean up an effect? React performs the cleanup when the component unmounts. However, as we learned earlier, effects run for every render and not just once. This is why React also cleans up effects from the previous render before running the effects next time. We’ll discuss why this helps avoid bugs and how to opt out of this behavior in case it creates performance issues later below.\n\nWe’ve learned that lets us express different kinds of side effects after a component renders. Some effects might require cleanup so they return a function:\n\nOther effects might not have a cleanup phase, and don’t return anything.\n\nThe Effect Hook unifies both use cases with a single API.\n\nIf you feel like you have a decent grasp on how the Effect Hook works, or if you feel overwhelmed, you can jump to the next page about Rules of Hooks now.\n\nWe’ll continue this page with an in-depth look at some aspects of that experienced React users will likely be curious about. Don’t feel obligated to dig into them now. You can always come back to this page to learn more details about the Effect Hook.\n\nOne of the problems we outlined in the Motivation for Hooks is that class lifecycle methods often contain unrelated logic, but related logic gets broken up into several methods. Here is a component that combines the counter and the friend status indicator logic from the previous examples:\n\nNote how the logic that sets is split between and . The subscription logic is also spread between and . And contains code for both tasks.\n\nSo, how can Hooks solve this problem? Just like you can use the State Hook more than once, you can also use several effects. This lets us separate unrelated logic into different effects:\n\nHooks let us split the code based on what it is doing rather than a lifecycle method name. React will apply every effect used by the component, in the order they were specified.\n\nIf you’re used to classes, you might be wondering why the effect cleanup phase happens after every re-render, and not just once during unmounting. Let’s look at a practical example to see why this design helps us create components with fewer bugs.\n\nEarlier on this page, we introduced an example component that displays whether a friend is online or not. Our class reads from , subscribes to the friend status after the component mounts, and unsubscribes during unmounting:\n\nBut what happens if the prop changes while the component is on the screen? Our component would continue displaying the online status of a different friend. This is a bug. We would also cause a memory leak or crash when unmounting since the unsubscribe call would use the wrong friend ID.\n\nIn a class component, we would need to add to handle this case:\n\nForgetting to handle properly is a common source of bugs in React applications.\n\nNow consider the version of this component that uses Hooks:\n\nIt doesn’t suffer from this bug. (But we also didn’t make any changes to it.)\n\nThere is no special code for handling updates because handles them by default. It cleans up the previous effects before applying the next effects. To illustrate this, here is a sequence of subscribe and unsubscribe calls that this component could produce over time:\n\nThis behavior ensures consistency by default and prevents bugs that are common in class components due to missing update logic.\n\nIn some cases, cleaning up or applying the effect after every render might create a performance problem. In class components, we can solve this by writing an extra comparison with or inside :\n\nThis requirement is common enough that it is built into the Hook API. You can tell React to skip applying an effect if certain values haven’t changed between re-renders. To do so, pass an array as an optional second argument to :\n\nIn the example above, we pass as the second argument. What does this mean? If the is , and then our component re-renders with still equal to , React will compare from the previous render and from the next render. Because all items in the array are the same ( ), React would skip the effect. That’s our optimization.\n\nWhen we render with updated to , React will compare the items in the array from the previous render to items in the array from the next render. This time, React will re-apply the effect because . If there are multiple items in the array, React will re-run the effect even if just one of them is different.\n\nThis also works for effects that have a cleanup phase:\n\nIn the future, the second argument might get added automatically by a build-time transformation.\n\nCongratulations! This was a long page, but hopefully by the end most of your questions about effects were answered. You’ve learned both the State Hook and the Effect Hook, and there is a lot you can do with both of them combined. They cover most of the use cases for classes — and where they don’t, you might find the additional Hooks helpful.\n\nWe’re also starting to see how Hooks solve problems outlined in Motivation. We’ve seen how effect cleanup avoids duplication in and , brings related code closer together, and helps us avoid bugs. We’ve also seen how we can separate effects by their purpose, which is something we couldn’t do in classes at all.\n\nAt this point you might be questioning how Hooks work. How can React know which call corresponds to which state variable between re-renders? How does React “match up” previous and next effects on every update? On the next page we will learn about the Rules of Hooks — they’re essential to making Hooks work."
    },
    {
        "link": "https://react.dev/reference/react/hooks",
        "document": "State lets a component “remember” information like user input. For example, a form component can use state to store the input value, while an image gallery component can use state to store the selected image index.\n\nTo add state to a component, use one of these Hooks:\n• declares a state variable that you can update directly.\n\nContext lets a component receive information from distant parents without passing it as props. For example, your app’s top-level component can pass the current UI theme to all components below, no matter how deep.\n\nRefs let a component hold some information that isn’t used for rendering, like a DOM node or a timeout ID. Unlike with state, updating a ref does not re-render your component. Refs are an “escape hatch” from the React paradigm. They are useful when you need to work with non-React systems, such as the built-in browser APIs.\n• declares a ref. You can hold any value in it, but most often it’s used to hold a DOM node.\n• lets you customize the ref exposed by your component. This is rarely used.\n\nEffects let a component connect to and synchronize with external systems. This includes dealing with network, browser DOM, animations, widgets written using a different UI library, and other non-React code.\n\nEffects are an “escape hatch” from the React paradigm. Don’t use Effects to orchestrate the data flow of your application. If you’re not interacting with an external system, you might not need an Effect.\n\nThere are two rarely used variations of with differences in timing:\n• fires before the browser repaints the screen. You can measure layout here.\n• fires before React makes changes to the DOM. Libraries can insert dynamic CSS here.\n\nA common way to optimize re-rendering performance is to skip unnecessary work. For example, you can tell React to reuse a cached calculation or to skip a re-render if the data has not changed since the previous render.\n\nTo skip calculations and unnecessary re-rendering, use one of these Hooks:\n• lets you cache the result of an expensive calculation.\n• lets you cache a function definition before passing it down to an optimized component.\n\nSometimes, you can’t skip re-rendering because the screen actually needs to update. In that case, you can improve performance by separating blocking updates that must be synchronous (like typing into an input) from non-blocking updates which don’t need to block the user interface (like updating a chart).\n\nTo prioritize rendering, use one of these Hooks:\n• lets you mark a state transition as non-blocking and allow other updates to interrupt it.\n• lets you defer updating a non-critical part of the UI and let other parts update first.\n\nThese Hooks are mostly useful to library authors and aren’t commonly used in the application code.\n• lets you customize the label React DevTools displays for your custom Hook.\n• lets a component associate a unique ID with itself. Typically used with accessibility APIs.\n• allows you to manage state of actions.\n\nYou can also define your own custom Hooks as JavaScript functions."
    },
    {
        "link": "https://redux-toolkit.js.org/api/createSlice",
        "document": "A function that accepts an initial state, an object of reducer functions, and a \"slice name\", and automatically generates action creators and action types that correspond to the reducers and state.\n\nThis API is the standard approach for writing Redux logic.\n\nInternally, it uses and , so you may also use Immer to write \"mutating\" immutable updates:\n\naccepts a single configuration object parameter, with the following options:\n\nThe initial state value for this slice of state.\n\nThis may also be a \"lazy initializer\" function, which should return an initial state value when called. This will be used whenever the reducer is called with as its state value, and is primarily useful for cases like reading initial state from .\n\nA string name for this slice of state. Generated action type constants will use this as a prefix.\n\nAn object containing Redux \"case reducer\" functions (functions intended to handle a specific action type, equivalent to a single case statement in a switch).\n\nThe keys in the object will be used to generate string action type constants, and these will show up in the Redux DevTools Extension when they are dispatched. Also, if any other part of the application happens to dispatch an action with the exact same type string, the corresponding reducer will be run. Therefore, you should give the functions descriptive names.\n\nThis object will be passed to , so the reducers may safely \"mutate\" the state they are given.\n\nIf you need to customize the creation of the payload value of an action creator by means of a , the value of the appropriate field of the argument object should be an object instead of a function. This object must contain two properties: and . The value of the field should be the case reducer function while the value of the field should be the prepare callback function:\n\nAlternatively, the field can be a callback which receives a \"create\" object.\n\nThe main benefit of this is that you can create async thunks as part of your slice (though for bundle size reasons, you need a bit of setup for this). Types are also slightly simplified for prepared reducers.\n• reducer The slice case reducer to use.\n• reducer The slice case reducer to use.\n\nThe action passed to the case reducer will be inferred from the prepare callback's return.\n\nCreates an async thunk instead of an action creator.\n\nThe configuration object can contain case reducers for each of the lifecycle actions ( , , and ), as well as a reducer that will run for both fulfilled and rejected actions (note that this will run after any provided / reducers. Conceptually it can be thought of like a block.).\n\nEach case reducer will be attached to the slice's object, e.g. .\n\nThe configuration object can also contain .\n\nConceptually, each slice reducer \"owns\" its slice of state. There's also a natural correspondence between the update logic defined inside , and the action types that are generated based on those.\n\nHowever, there are many times that a Redux slice may also need to update its own state in response to action types that were defined elsewhere in the application (such as clearing many different kinds of data when a \"user logged out\" action is dispatched). This can include action types defined by another call, actions generated by a , RTK Query endpoint matchers, or any other action. In addition, one of the key concepts of Redux is that many slice reducers can independently respond to the same action type.\n\nallows to respond and update its own state in response to other action types besides the types it has generated.\n\nAs with the field, each case reducer in is wrapped in Immer and may use \"mutating\" syntax to safely update the state inside.\n\nHowever, unlike the field, each individual case reducer inside of will not generate a new action type or action creator.\n\nIf two fields from and happen to end up with the same action type string, the function from will be used to handle that action type.\n\nSimilar to , the field uses a \"builder callback\" notation to define handlers for specific action types, matching against a range of actions, or handling a default case. This is conceptually similar to a switch statement, but with better TS support as it can infer the action type from the provided action creator. It's particularly useful for working with actions produced by and .\n\nSee the \"Builder Callback Notation\" section of the reference for details on how to use , , and\n\nIndicates a preference of where the slice should be located. Defaults to .\n\nThis is used by and the default generated .\n\nA set of selectors that receive the slice state as their first parameter, and any other parameters.\n\nEach selector will have a corresponding key in the resulting object.\n\nwill return an object that looks like:\n\nEach function defined in the argument will have a corresponding action creator generated using and included in the result's field using the same function name.\n\nThe generated function is suitable for passing to the Redux function as a \"slice reducer\".\n\nYou may want to consider destructuring the action creators and exporting them individually, for ease of searching for references in a larger codebase.\n\nThe functions passed to the parameter can be accessed through the return field. This can be particularly useful for testing or direct access to reducers created inline.\n\nResult's function provides access to the initial state value given to the slice. If a lazy state initializer was provided, it will be called and a fresh value returned.\n\ncreates an instance of the slice that is aware it's been injected - see .\n\nSlice selectors are written to expect the slice's state as their first parameter, but the slice may be located anywhere inside the store's root state.\n\nAs a result, there are two ways of getting final selectors:\n\nMost commonly, the slice is reliably mounted under its .\n\nFollowing this, the slice has a selector attached, which assumes that the slice is located under .\n\nthen uses this selector to wrap each of the selectors provided.\n\nis called with a single parameter, a callback. This function should receive the store root state (or whatever you expect to call the resulting selectors with) and return the slice state.\n\nIf no callback is passed, selectors will be returned as is - expecting the slice state as their first parameter (the same as calling )."
    },
    {
        "link": "https://redux-toolkit.js.org/usage/usage-guide",
        "document": "The Redux core library is deliberately unopinionated. It lets you decide how you want to handle everything, like store setup, what your state contains, and how you want to build your reducers.\n\nThis is good in some cases, because it gives you flexibility, but that flexibility isn't always needed. Sometimes we just want the simplest possible way to get started, with some good default behavior out of the box. Or, maybe you're writing a larger application and finding yourself writing some similar code, and you'd like to cut down on how much of that code you have to write by hand.\n\nAs described in the Quick Start page, the goal of Redux Toolkit is to help simplify common Redux use cases. It is not intended to be a complete solution for everything you might want to do with Redux, but it should make a lot of the Redux-related code you need to write a lot simpler (or in some cases, eliminate some of the hand-written code entirely).\n\nRedux Toolkit exports several individual functions that you can use in your application, and adds dependencies on some other packages that are commonly used with Redux (like Reselect and Redux-Thunk). This lets you decide how to use these in your own application, whether it be a brand new project or updating a large existing app.\n\nLet's look at some of the ways that Redux Toolkit can help make your Redux-related code better.\n\nEvery Redux app needs to configure and create a Redux store. This usually involves several steps:\n• Setting up middleware, likely including at least one middleware to handle asynchronous logic\n• Possibly altering some of the logic based on whether the application is being built for development or production\n\nThe following example from the Configuring Your Store page in the Redux docs shows a typical store setup process:\n\nThis example is readable, but the process isn't always straightforward:\n• The basic Redux function takes positional arguments: . Sometimes it's easy to forget which parameter is which.\n• The process of setting up middleware and enhancers can be confusing, especially if you're trying to add several pieces of configuration.\n• The Redux DevTools Extension docs initially suggest using some hand-written code that checks the global namespace to see if the extension is available. Many users copy and paste those snippets, which make the setup code harder to read.\n\nhelps with those issues by:\n• Having an options object with \"named\" parameters, which can be easier to read\n• Letting you provide arrays of middleware and enhancers you want to add to the store, and calling and for you automatically\n\nIn addition, adds some middleware by default, each with a specific goal:\n• is the most commonly used middleware for working with both synchronous and async logic outside of components\n• In development, middleware that check for common mistakes like mutating the state or using non-serializable values.\n\nThis means the store setup code itself is a bit shorter and easier to read, and also that you get good default behavior out of the box.\n\nThe simplest way to use it is to just pass the root reducer function as a parameter named :\n\nYou can also pass an object full of \"slice reducers\", and will call for you:\n\nNote that this only works for one level of reducers. If you want to nest reducers, you'll need to call yourself to handle the nesting.\n\nIf you need to customize the store setup, you can pass additional options. Here's what the hot reloading example might look like using Redux Toolkit:\n\nIf you provide the argument, will only use whatever middleware you've listed. If you want to have some custom middleware and the defaults all together, you can use the callback notation, call and include the results in the array you return.\n\nReducers are the most important Redux concept. A typical reducer function needs to:\n• Look at the field of the action object to see how it should respond\n• Update its state immutably, by making copies of the parts of the state that need to change and only modifying those copies\n\nWhile you can use any conditional logic you want in a reducer, the most common approach is a statement, because it's a straightforward way to handle multiple possible values for a single field. However, many people don't like switch statements. The Redux docs show an example of writing a function that acts as a lookup table based on action types, but leave it up to users to customize that function themselves.\n\nThe other common pain points around writing reducers have to do with updating state immutably. JavaScript is a mutable language, updating nested immutable data by hand is hard, and it's easy to make mistakes.\n\nSince the \"lookup table\" approach is popular, Redux Toolkit includes a function similar to the one shown in the Redux docs. However, our utility has some special \"magic\" that makes it even better. It uses the Immer library internally, which lets you write code that \"mutates\" some data, but actually applies the updates immutably. This makes it effectively impossible to accidentally mutate state in a reducer.\n\nIn general, any Redux reducer that uses a statement can be converted to use directly. Each in the switch becomes a key in the object passed to . Immutable update logic, like spreading objects or copying arrays, can probably be converted to direct \"mutation\". It's also fine to keep the immutable updates as-is and return the updated copies, too.\n\nHere's some examples of how you can use . We'll start with a typical \"todo list\" reducer that uses switch statements and immutable updates:\n\nNotice that we specifically call to return a copied array with the new todo entry, to return a copied array for the toggle case, and use the object spread operator to make a copy of the todo that needs to be updated.\n\nWith , we can shorten that example considerably:\n\nThe ability to \"mutate\" the state is especially helpful when trying to update deeply nested state. This complex and painful code:\n\nCan be simplified down to just:\n\nWhile the Redux Toolkit function can be really helpful, keep in mind that:\n• The \"mutative\" code only works correctly inside of our function\n• Immer won't let you mix \"mutating\" the draft state and also returning a new state value\n\nSee the API reference for more details.\n\nRedux encourages you to write \"action creator\" functions that encapsulate the process of creating an action object. While this is not strictly required, it's a standard part of Redux usage.\n\nMost action creators are very simple. They take some parameters, and return an action object with a specific field and the parameters inside the action. These parameters are typically put in a field called , which is part of the Flux Standard Action convention for organizing the contents of action objects. A typical action creator might look like:\n\nWriting action creators by hand can get tedious. Redux Toolkit provides a function called , which simply generates an action creator that uses the given action type, and turns its argument into the field:\n\nalso accepts a \"prepare callback\" argument, which allows you to customize the resulting field and optionally add a field. See the API reference for details on defining action creators with a prepare callback.\n\nRedux reducers need to look for specific action types to determine how they should update their state. Normally, this is done by defining action type strings and action creator functions separately. Redux Toolkit function make this easier, by defining the action type as a field on the action creator.\n\nThis means you don't have to write or use a separate action type variable, or repeat the name and value of an action type like .\n\nIf you want to use one of these action creators in a switch statement, you need to reference yourself:\n\nRedux state is typically organized into \"slices\", defined by the reducers that are passed to :\n\nIn this example, both and would be considered \"slices\". Both of the reducers:\n• \"Own\" a piece of state, including what the initial value is\n• Define how that state is updated\n\nThe common approach is to define a slice's reducer function in its own file, and the action creators in a second file. Because both functions need to refer to the same action types, those are usually defined in a third file and imported in both places:\n\nThe only truly necessary part here is the reducer itself. Consider the other parts:\n• We could have written the action types as inline strings in both places\n• The action creators are good, but they're not required to use Redux - a component could skip supplying a argument to , and just call itself\n• The only reason we're even writing multiple files is because it's common to separate code by what it does\n\nThe \"ducks\" file structure proposes putting all of your Redux-related logic for a given slice into a single file, like this:\n\nThat simplifies things because we don't need to have multiple files, and we can remove the redundant imports of the action type constants. But, we still have to write the action types and the action creators by hand.\n\nIn modern JavaScript, there are several legal ways to define both keys and functions in an object (and this isn't specific to Redux), and you can mix and match different key definitions and function definitions. For example, these are all legal ways to define a function inside an object:\n\nUsing the \"object literal function shorthand\" is probably the shortest code, but feel free to use whichever of those approaches you want.\n\nTo simplify this process, Redux Toolkit includes a function that will auto-generate the action types and action creators for you, based on the names of the reducer functions you provide.\n\nHere's how that posts example would look with :\n\nlooked at all of the functions that were defined in the field, and for every \"case reducer\" function provided, generates an action creator that uses the name of the reducer as the action type itself. So, the reducer became an action type of , and the action creator will return an action with that type.\n\nMost of the time, you'll want to define a slice, and export its action creators and reducers. The recommended way to do this is using ES6 destructuring and export syntax:\n\nYou could also just export the slice object itself directly if you prefer.\n\nSlices defined this way are very similar in concept to the \"Redux Ducks\" pattern for defining and exporting action creators and reducers. However, there are a couple potential downsides to be aware of when importing and exporting slices.\n\nFirst, Redux action types are not meant to be exclusive to a single slice. Conceptually, each slice reducer \"owns\" its own piece of the Redux state, but it should be able to listen to any action type and update its state appropriately. For example, many different slices might want to respond to a \"user logged out\" action by clearing data or resetting back to initial state values. Keep that in mind as you design your state shape and create your slices.\n\nSecond, JS modules can have \"circular reference\" problems if two modules try to import each other. This can result in imports being undefined, which will likely break the code that needs that import. Specifically in the case of \"ducks\" or slices, this can occur if slices defined in two different files both want to respond to actions defined in the other file.\n\nThis CodeSandbox example demonstrates the problem:\n\nIf you encounter this, you may need to restructure your code in a way that avoids the circular references. This will usually require extracting shared code to a separate common file that both modules can import and use. In this case, you might define some common action types in a separate file using , import those action creators into each slice file, and handle them using the argument.\n\nThe article How to fix circular dependency issues in JS has additional info and examples that can help with this issue.\n\nBy itself, a Redux store doesn't know anything about async logic. It only knows how to synchronously dispatch actions, update the state by calling the root reducer function, and notify the UI that something has changed. Any asynchronicity has to happen outside the store.\n\nBut, what if you want to have async logic interact with the store by dispatching or checking the current store state? That's where Redux middleware come in. They extend the store, and allow you to:\n• Execute extra logic when any action is dispatched (such as logging the action and state)\n• Write extra code that has access to and\n• Teach how to accept other values besides plain action objects, such as functions and promises, by intercepting them and dispatching real action objects instead\n\nThe most common reason to use middleware is to allow different kinds of async logic to interact with the store. This allows you to write code that can dispatch actions and check the store state, while keeping that logic separate from your UI.\n\nThere are many kinds of async middleware for Redux, and each lets you write your logic using different syntax. The most common async middleware are:\n• , which lets you write plain functions that may contain async logic directly\n• , which uses generator functions that return descriptions of behavior so they can be executed by the middleware\n• , which uses the RxJS observable library to create chains of functions that process actions\n\nEach of these libraries has different use cases and tradeoffs.\n\nIf you do need to write data fetching logic yourself, we recommend using the Redux Thunk middleware as the standard approach, as it is sufficient for most typical use cases (such as basic AJAX data fetching). In addition, use of the syntax in thunks makes them easier to read.\n\nThe Redux Toolkit function automatically sets up the thunk middleware by default, so you can immediately start writing thunks as part of your application code.\n\nRedux Toolkit does not currently provide any special APIs or syntax for writing thunk functions. In particular, they cannot be defined as part of a call. You have to write them separate from the reducer logic, exactly the same as with plain Redux code.\n\nMany Redux apps have structured their code using a \"folder-by-type\" approach. In that structure, thunk action creators are usually defined in an \"actions\" file, alongside the plain action creators.\n\nBecause we don't have separate \"actions\" files, it makes sense to write these thunks directly in our \"slice\" files. That way, they have access to the plain action creators from the slice, and it's easy to find where the thunk function lives.\n\nA typical slice file that includes thunks would look like this:\n• A \"start\" action is dispatched before the request to indicate that the request is in progress. This may be used to track loading state, to allow skipping duplicate requests, or show loading indicators in the UI.\n• Depending on the request result, the async logic dispatches either a \"success\" action containing the result data, or a \"failure\" action containing error details. The reducer logic clears the loading state in both cases, and either processes the result data from the success case, or stores the error value for potential display.\n\nThese steps are not required, but are recommended in the Redux tutorials as a suggested pattern.\n\nA typical implementation might look like:\n\nHowever, writing code using this approach is tedious. Each separate type of request needs repeated similar implementation:\n• Unique action types need to be defined for the three different cases\n• Each of those action types usually has a corresponding action creator function\n• A thunk has to be written that dispatches the correct actions in the right sequence\n\nabstracts this pattern by generating the action types and action creators and generating a thunk that dispatches those actions.\n\nAs a developer, you are probably most concerned with the actual logic needed to make an API request, what action type names show up in the Redux action history log, and how your reducers should process the fetched data. The repetitive details of defining the multiple action types and dispatching the actions in the right sequence aren't what matters.\n\nsimplifies this process - you only need to provide a string for the action type prefix and a payload creator callback that does the actual async logic and returns a promise with the result. In return, will give you a thunk that will take care of dispatching the right actions based on the promise you return, and action types that you can handle in your reducers:\n\nThe thunk action creator accepts a single argument, which will be passed as the first argument to your payload creator callback.\n\nThe payload creator will also receive a object containing the parameters that are normally passed to a standard Redux thunk function, as well as an auto-generated unique random request ID string and an object:\n\nYou can use any of these as needed inside the payload callback to determine what the final result should be.\n\nMost applications typically deal with data that is deeply nested or relational. The goal of normalizing data is to efficiently organize the data in your state. This is typically done by storing collections as objects with the key of an , while storing a sorted array of those . For a more in-depth explanation and further examples, there is a great reference in the Redux docs page on \"Normalizing State Shape\".\n\nNormalizing data doesn't require any special libraries. Here's a basic example of how you might normalize the response from a API request that returns data in the shape of , using some hand-written logic:\n\nAlthough we're capable of writing this code, it does become repetitive, especially if you're handling multiple types of data. In addition, this example only handles loading entries into the state, not updating them.\n\nis a popular existing library for normalizing data. You can use it on its own without Redux, but it is very commonly used with Redux. The typical usage is to format collections from an API response and then process them in your reducers.\n\nAs with the hand-written version, this doesn't handle adding additional entries into the state, or updating them later - it's just loading in everything that was received.\n\nRedux Toolkit's API provides a standardized way to store your data in a slice by taking a collection and putting it into the shape of . Along with this predefined state shape, it generates a set of reducer functions and selectors that know how to work with the data.\n\nYou can view the full code of this example usage on CodeSandbox\n\nIf you're already using or another normalization library, you could consider using it along with . To expand on the examples above, here is a demonstration of how we could use to format a payload, then leverage the utilities provides.\n\nBy default, the , , and CRUD methods expect an array of entities. However, they also allow you to pass in an object that is in the shape of as an alternative, which makes it easier to insert pre-normalized data.\n\nYou can view the full code of this example usage on CodeSandbox\n\nThe entity adapter provides a selector factory that generates the most common selectors for you. Taking the examples above, we can add selectors to our like this:\n\nYou could then use these selectors in a component like this:\n\nBy default, assumes that your data has unique IDs in an field. If your data set stores its ID in a different field, you can pass in a argument that returns the appropriate field.\n\nprovides a argument that you can leverage to sort the collection of in state. This can be very useful for when you want to guarantee a sort order and your data doesn't come presorted.\n\nOne of the core usage principles for Redux is that you should not put non-serializable values in state or actions.\n\nHowever, like most rules, there are exceptions. There may be occasions when you have to deal with actions that need to accept non-serializable data. This should be done very rarely and only if necessary, and these non-serializable payloads shouldn't ever make it into your application state through a reducer.\n\nThe serializability dev check middleware will automatically warn anytime it detects non-serializable values in your actions or state. We encourage you to leave this middleware active to help avoid accidentally making mistakes. However, if you do need to turnoff those warnings, you can customize the middleware by configuring it to ignore specific action types, or fields in actions and state:\n\nIf using Redux-Persist, you should specifically ignore all the action types it dispatches:\n\nAdditionally, you can purge any persisted state by adding an extra reducer to the specific slice that you would like to clear when calling persistor.purge(). This is especially helpful when you are looking to clear persisted state on a dispatched logout action.\n\nIt is also strongly recommended to blacklist any api(s) that you have configured with RTK Query. If the api slice reducer is not blacklisted, the api cache will be automatically persisted and restored which could leave you with phantom subscriptions from components that do not exist any more. Configuring this should look something like this:\n\nSee Redux Toolkit #121: How to use this with Redux-Persist? and Redux-Persist #988: non-serializable value error for further discussion.\n\nRRF includes timestamp values in most actions and state as of 3.x, but there are PRs that may improve that behavior as of 4.x.\n\nA possible configuration to work with that behavior could look like:"
    },
    {
        "link": "https://stackoverflow.com/questions/68421040/local-storage-using-redux-toolkit",
        "document": "Update October 2022: You can also use redux-toolkit's in versions 1.8 and up, as explained in this answer.\n\nChanging is a side-effect so you don't want to do it in your reducer. A reducer should always be free of side-effects. One way to handle this is with a custom middleware.\n\nOur middleware gets called after every action is dispatched. If the action is or then we will change the value. Otherwise we do nothing. Either way we pass the action off to the next middleware in the chain with .\n\nThe only difference in the middleware between redux-toolkit and vanilla redux is how we detect the and actions. With redux-toolkit the action creator functions include a helpful function that we can use rather than having to look at the . We know that an is a login action if is true. So our middleware might look like this:\n\nYou will add the middleware to your store in the function. Redux-toolkit includes some middleware by default with enables thunk, immutability checks, and serializability checks. Right now you are not setting the property on your store at all, so you are getting all of the defaults included. We want to make sure that we keep the defaults when we add our custom middleware.\n\nThe property can be defined as a function which gets called with the redux-toolkit function. This allows you to set options for the default middleware, if you want to, while also adding our own. We will follow the docs example and write this:\n\nDon't do this, as it will remove all default middleware\n\nWe could potentially streamline our middleware by matching all actions. We do that by using the method on the (similar to the examples in the docs section which use ).\n\nHere we find the next state by executing before we change . We set the value to the new state returned by the slice.\n\nOr you can use the redux-persist package, which does that for you."
    },
    {
        "link": "https://redux-toolkit.js.org/rtk-query/api/created-api/overview",
        "document": "When you call , it automatically generates and returns an API service \"slice\" object structure containing Redux logic you can use to interact with the endpoints you defined. This slice object includes a reducer to manage cached data, a middleware to manage cache lifetimes and subscriptions, and selectors and thunks for each endpoint. If you imported from the React-specific entry point, it also includes auto-generated React hooks for use in your components.\n\nThis section documents the contents of that API structure, with the different fields grouped by category. The API types and descriptions are listed on separate pages for each category.\n\nTypically, you should only have one API slice per base URL that your application needs to communicate with. For example, if your site fetches data from both and , you would have a single API slice with as the base URL, and separate endpoint definitions for and . This allows you to effectively take advantage of automated re-fetching by defining tag relationships across endpoints.\n• Automatic tag invalidation only works within a single API slice. If you have multiple API slices, the automatic invalidation won't work across them.\n• Every call generates its own middleware, and each middleware added to the store will run checks against every dispatched action. That has a perf cost that adds up. So, if you called 10 times and added 10 separate API middleware to the store, that will be noticeably slower perf-wise. For maintainability purposes, you may wish to split up endpoint definitions across multiple files, while still maintaining a single API slice which includes all of these endpoints. See code splitting for how you can use the property to inject API endpoints from other files into a single API slice definition.\n\nInternally, will call the Redux Toolkit API to generate a slice reducer and corresponding action creators with the appropriate logic for caching fetched data. It also automatically generates a custom Redux middleware that manages subscription counts and cache lifetimes.\n\nThe generated slice reducer and the middleware both need to be adding to your Redux store setup in in order to work correctly.\n\nThe API slice object will have an field inside. This section maps the endpoint names you provided to to the core Redux logic (thunks and selectors) used to trigger data fetches and read cached data for that endpoint. If you're using the React-specific version of , each endpoint definition will also contain the auto-generated React hooks for that endpoint.\n\nEach API slice allows additional endpoint definitions to be injected at runtime after the initial API slice has been defined. This can be beneficial for apps that may have many endpoints.\n\nThe individual API slice endpoint definitions can also be split across multiple files. This is primarily useful for working with API slices that were code-generated from an API schema file, allowing you to add additional custom behavior and configuration to a set of automatically-generated endpoint definitions.\n\nEach API slice object has and functions to support these use cases.\n\nThe field includes various utility functions that can be used to manage the cache, including manually updating query cache data, triggering pre-fetching of data, manually invalidating tags, and manually resetting the api state, as well as other utility functions that can be used in various scenarios, including SSR.\n\nThe field contains a set of additional thunks that are used for internal behavior, such as managing updates based on focus.\n\nThe core RTK Query method is UI-agnostic, in the same way that the Redux core library and Redux Toolkit are UI-agnostic. They are all plain JS logic that can be used anywhere.\n\nHowever, RTK Query also provides the ability to auto-generate React hooks for each of your endpoints. Since this specifically depends on React itself, RTK Query provides an alternate entry point that exposes a customized version of that includes that functionality:\n\nIf you have used the React-specific version of , the generated slice structure will also contain a set of React hooks. These endpoint hooks are available as or , matching how you defined that endpoint.\n\nThe same hooks are also added to the object itself, and given auto-generated names based on the endpoint name and query/mutation type.\n\nFor example, if you had endpoints for and , these options would be available:\n\nThe React-specific version of also generates a hook, attached to the object, which can be used to initiate fetching data ahead of time."
    },
    {
        "link": "https://github.com/reduxjs/redux-toolkit/issues/2003",
        "document": "This was originally \"1.8 planning\", but 1.8 ended up just having the listener middleware. So, keeping the issue around for both.\n\nWhat else would we want to get in?\n\nLooking through the issues, other candidates:\n• Could go in a 1.8.x:\n• None Using updateMany in adapter with custom sortComparer ignores several updates with same id /\n\nFor the record, I think this probably ought to be the last feature release before we look at doing RTK 2.0 and dropping IE11 compat ( ref: #958 )"
    },
    {
        "link": "https://axios-http.com/docs/intro",
        "document": "Promise based HTTP client for the browser and node.js\n\nAxios is a promise-based HTTP Client for and the browser. It is isomorphic (= it can run in the browser and nodejs with the same codebase). On the server-side it uses the native node.js module, while on the client (browser) it uses XMLHttpRequests.\n• Progress capturing for browsers and node.js with extra info (speed rate, remaining time)\n\nPrebuilt CommonJS modules for direct importing with require (if your module bundler failed to resolve them automatically)"
    },
    {
        "link": "https://axios-http.com/docs/api_intro",
        "document": "Requests can be made by passing the relevant config to .\n\nFor convenience aliases have been provided for all supported request methods.\n\nNOTE: When using the alias methods , , and properties don't need to be specified in config."
    },
    {
        "link": "https://axios-http.com/docs/req_config",
        "document": "These are the available config options for making requests. Only the is required. Requests will default to if is not specified."
    },
    {
        "link": "https://circleci.com/blog/making-http-requests-with-axios",
        "document": "Axios is a promise-based HTTP library that lets developers make requests to either their own server or a third-party server to fetch data. It offers different ways of making requests such as , , , and .\n\nIn this tutorial, you will learn how Axios interacts with applications, how Axios structures requests and responses, and how to use Axios to make requests to an API. You’ll also learn how to write tests for your Axios requests and how to automate them with CircleCI for fast, seamless feedback on your changes.\n\nTo follow along with the tutorial, make sure that you have:\n\nAxios helps developers make HTTP requests from NodeJS or XMLHttpRequests from a browser. If the request is successful, you will receive a with the data requested. If the request fails, you will get an error. You can also the requests and responses and transform or modify them. I will go into more detail about that later in this tutorial.\n\nThis diagram represents how Axios interacts with an application.\n\nAxios is able to determine whether the request is made from the browser or from NodeJS. Once this is established, it then identifies the proper way to make the API requests and returns a transformed response back to the client that made the request.\n\nMaking a basic request in Axios is easy because the only option required is the . However, you can configure other options depending on the kind of request that you want to make.\n\nHere is an example request:\n\nThe first example uses for a simple GET request where you can add additional configurations. The second example uses the full method, allowing you to specify more options such as the request method, URL, and parameters.\n\nAxios provides great flexibility to configure your requests. You can decide to call Axios with the JavaScript dot notation format. Or you can use the object literal format to bundle all the Axios request properties into an object that can be used as properties of making the Axios request.\n\nThere are several methods that Axios supports for making requests. They include:\n\nHere’s another code snippet that shows how to make a simple request sent to a sample API using Axios.\n\nOnce you send a request with Axios, you expect to have a response returned. This snippet shows the data structure of an Axios response:\n\nIn this response, you get an object of the data that you are expecting, the status code sent back by the server, a , response headers, the config object set by Axios, and the request object that was used to generate the response. You can then consume the responses on your client-side application depending on the data that you need.\n\nNow that you’ve mastered some of the background, move on to the next section where I will show you exactly how to make HTTP requests with Axios.\n\nIn this section, you will make and requests and observe concurrent requests. You will be using a free “fake” API: JSONPlaceholder.\n\nYou will also use an application that will help you make your requests and get a better view of what is happening under the hood.\n\nBefore you get started though, you need to clone the GitHub repository for the tutorial. Run these commands:\n\nNow you should have the files you need for this tutorial. Your next step is to install both Axios and Jest as dependencies. Run this command:\n\nOpen the file on the browser to review your Axios demo webpage.\n\nThere are three buttons for each request. Clicking a button should display a response after the Axios request has been made and data returned to the browser.\n\nIn the file of your cloned repository, there is an event listener that displays the data returned by Axios. This file also has functions you will use to make your requests. Get started by making your first request.\n\nA basic request to our sample API looks like this:\n\nThis code snippet sends a request to the JSON API. Because the request returns a promise, we use the block to handle the responses. We also need to use the method to log any errors to the console.\n\nThis code snippet is already in the function in the file.\n\nNow that you understand what is happening behind the scenes, go to the browser and click the button. Below it, new content should appear, displaying details of the response.\n\nThis response from the API is broken into a few sections based on the data we have from Axios. The sections of the received Axios response are:\n• The section, which displays the status code of the response. In this case it is , which means that the request was successful.\n• The section, which contains all the HTTP headers that the server responds with.\n• The section, which contains the payload or the information that was requested from the server. In this case, it is all the information about .\n• The section, which contains all the configuration that was passed to Axios for the request.\n\nAs shown in the request, Axios behaves like the traditional library. Considering that this is a request, you do not need to pass a body with a request. Next I will show you how to do that in a request using Axios.\n\nA request is a little different because you often need to pass some data in the request to the server. In the sample application, we have a request that creates a user and passes in details for that user. The code snippet for the request looks like this:\n\nThe Axios request uses an object after the request URL to define the properties you want to create for your user. Once the operation has been completed, there will be a response from the server. To verify that your code is working, go back to the application browser window and click the POST button. This snippet is part of the function in the file.\n• The section has a status code of , which means a resource has been created. In this case, a new user has been created.\n• The section has a property for the length of the data we sent. It also specifies where the data will be stored: .\n• The section contains the information that was sent to the server.\n• The section contains the configuration that was sent along with the request. This involves the , , and being sent.\n\nYou can verify that the data defined in your request is the exact response received from the server as a created resource.\n\nIn this section, you learned how to make an Axios request, and you explored the basic structure of an Axios request and its the expected responses. In the next section, you will learn how to use request interception to verify data before it is sent to Axios as a request.\n\nIn Axios, requests or responses can be intercepted before they are handled by the or blocks. For example, say you want to check that all the requests going through to a client have a valid JWT token. To do that, you can set up a request interceptor to make sure that all the calls made to the server have that valid token. If a call does not have a valid token, the users of the system would have to go back to the login page and be reauthenticated.\n\nIn the interest of time, I will lead you through a less complicated use case, writing a logger for your current application.\n\nThe logger will log when a request was made, the URL for the request, and the time when the request was triggered. This code snippet is what the sample application uses:\n\nAxios will access the section of your requests to display the request method, URL, and time. This code snippet is part of the file in the function of the sample project.\n\nTo observe the behavior of the Axios interceptor, open the Chrome browser console. Click the method that fetches the first user in the API.\n\nFor the interceptors to work, they need to be called as concurrent requests to the API. The next code snippet shows Axios methods that implement the requests and responses:\n\nThe Chrome DevTools image shows that when you make any request, you can modify or inspect it before it is sent by Axios to the API server. Axios interceptors are not only powerful, but they also give developers the ability to control requests and the behavior of their responses.\n\nNow you have learned how to use interceptors to modify or inspect your Axios requests and responses. Great work! Your next task is writing tests for your Axios implementation.\n\nSoftware testing is an integral process in the development of virtually every application. Tests help make sure your application works as intended and that quality is consistent throughout the development process. In this section of the tutorial, you will use the version of Axios. Since you already installed Jest while installing dependencies, you can start writing tests right away.\n\nIn the root directory, there are two files named and . We use for requests and for tests.\n\nIn the file, we use to make requests in . This method uses the same request structure as the browser method does:\n\nThis snippet makes a request to the same URL used earlier and then saves the response to the variable. It then returns the response to make it accessible to other methods or functions that may need it — like our tests. The snippet exports the method to make it accessible outside the file.\n\nTo write a test for this, we import the method into the test file. Then we write the test as shown here:\n\nUsing this test and the sample response object, you can verify that the data called from the Axios endpoint was in fact returned and that your API call was successful.\n\nIn the same file, we have all three tests:\n\nNow that you understand how the tests work, run them:\n\nNow that you have written Axios requests and tested them, you can build a continuous integration(CI) pipeline for them. Using a CI/CD tool like CircleCI keeps everyone informed when changes break the pipeline and cause the tests to fail. This kind of feedback loop provides the insight and transparency needed in a successful software development process.\n\nThe sample project contains a folder and inside it, a file named . This is CircleCI’s configuration file. In the file, we have the configuration for our project:\n\nThis configuration defines your , then tells CircleCI to use a Node image to execute your tests. Once that is set up, it checks for any stored cache for the project. If there is one, it needs to be restored before doing a new dependencies install. The cache is saved after installing new dependencies, tests are executed, and any artifacts that were generated are saved.\n\nTo run the project in CircleCI, it needs to exist as a repository on your GItHub. First, create an empty repository on GitHub. Next, change the origin URL to your repo:\n\nOnce this is done, log into the CircleCI dashboard. In the Organization homepage, click Create Project. Select GitHub, then pick your project and give it a meaningful name. Finally, click Create Project.\n\nCircleCI will automatically detect your configuration file, but it won’t run the pipeline. To trigger a pipeline build, push a small, meaningless commit.\n\nYou have a successful pipeline build! Review details by clicking Jobs then build.\n\nClick the steps you want more detail about; for example the step.\n\nCircleCI detects changes every time you push to the GitHub repository in your branch. The CircleCI pipeline will execute again and make sure that your test suite runs, ensuring a successful continuous integration process.\n\nI enjoyed creating this tutorial for you, and I hope you found it valuable. Until next time, keep coding!"
    },
    {
        "link": "https://blog.logrocket.com/http-requests-axios",
        "document": "Editor’s note: This article was last updated by Rahul Chhodde on 27 November 2024 to introduce Axios interceptors and how to use them to handle API error responses, as well as to cover how to post a file from a form using Axios.\n\nAxios is a client HTTP API based on the interface provided by browsers. In this tutorial, we’ll demonstrate how to make HTTP requests using Axios with clear examples, including how to make an Axios POST request with , how to send multiple requests simultaneously with , and much more.\n\nIf you’re more of a visual learner, check out the video tutorial below. Note that it is a few years old and may not reflect the most current information:\n\nThe most common way for frontend programs to communicate with servers is through the HTTP protocol. You are probably familiar with the Fetch API and the interface, which allows you to fetch resources and make HTTP requests.\n\nIf you’re using a JavaScript library, chances are it comes with a client HTTP API. jQuery’s function, for example, has been particularly popular with frontend developers. But as developers move away from such libraries in favor of native APIs, dedicated HTTP clients have emerged to fill the gap.\n\nAs with Fetch, Axios is promise-based. However, it provides a more powerful and flexible feature set. Why use Axios over the native Fetch API?\n\nYou can install Axios using the following command for npm, Yarn, and pnpm, respectively:\n\nTo install Axios using a content delivery network (CDN), run the following:\n\nHow to make an Axios POST request\n\nMaking an HTTP request is as easy as passing a config object to the function. You can make a POST request using Axios to “post” data to a given endpoint and trigger events. To perform an HTTP POST request in Axios, call .\n\nMaking a POST request in Axios requires two parameters: the URI of the service endpoint and an object that contains the properties you wish to send to the server.\n\nFor a simple Axios POST request, the config object must have a property. If no method is provided, will be used as the default value.\n\nLet’s look at a simple Axios POST example:\n\nThis should look familiar to those who have worked with jQuery’s function. This code instructs Axios to send a POST request to with an object of key-value pairs as its data. Axios will automatically convert the data to JSON and send it as the request body.\n\nAxios also provides a set of shorthand methods for performing different types of requests. The methods include:\n\nFor example, the following code shows how the previous example could be written using the method:\n\nOnce an HTTP POST request is made, Axios returns a promise that is either fulfilled or rejected, depending on the response from the backend service.\n\nTo handle the result, you can use the method, like this:\n\nIf the promise is fulfilled, the first argument of will be called; if the promise is rejected, the second argument will be called. According to the Axios documentation, the fulfillment value is an object containing the following properties:\n\nAs an example, here’s how the response looks when requesting data from the GitHub API:\n\nUsing Axios with and\n\nThe and syntax is syntactic sugar around the Promise API. It helps you write cleaner, more readable, and maintainable code. With and , your codebase feels synchronous and easier to think about.\n\nWhen using and , you invoke or one of its request methods inside an asynchronous function, like in the example below:\n\nWhen using the and syntax, it’s standard practice to wrap your code in a block. Doing so will ensure you appropriately handle errors and provide feedback for a better user experience.\n\nYou can use Axios with to make multiple requests in parallel by passing an iterable of promises to it. The static method returns a single promise object that fulfills only when all input promises have been fulfilled.\n\nHere’s a simple example of how to use to make simultaneous HTTP requests:\n\nThis code makes two requests to the GitHub API and then logs the value of the property of each response to the console. Keep in mind that if any of the input promises are rejected, the entire promise will immediately be rejected, returning the error from the first promise that encountered a rejection.\n\nSending custom headers with Axios is straightforward. Simply pass an object containing the headers as the last argument. For example:\n\nWhen making a network request to a server, it is not uncommon to experience delays when the server takes too long to respond. It is standard practice to timeout an operation and provide an appropriate error message if a response takes too long. This ensures a better user experience when the server is experiencing downtime or a higher load than usual.\n\nWith Axios, you can use the property of your object to set the waiting time before timing out a network request. Its value is the waiting duration in milliseconds. The request is aborted if Axios doesn’t receive a response within the timeout duration. The default value of the property is milliseconds (no timeout).\n\nYou can check for the error code and take appropriate action when the request times out:\n\nYou can also timeout a network request using the static method. It takes the timeout as an argument in milliseconds and returns an instance. You need to set it as the value of the property.\n\nThe network request aborts when the timeout expires. Axios sets the value of to and to :\n\nAxios automatically serializes JavaScript objects to JSON when passed to the function as the second parameter. This eliminates the need to serialize POST bodies to JSON.\n\nAxios also sets the header to . This enables web frameworks to automatically parse the data:\n\nIf you want to send a preserialized JSON string to JSON, you’ll need to make sure the header is set:\n\nAlthough Axios automatically converts requests and responses to JSON by default, it also allows you to override the default behavior and define a different transformation mechanism. This is particularly useful when working with an API that accepts only a specific data format, such as XML or CSV.\n\nTo change request data before sending it to the server, set the property in the config object. Note that this method only works for , , , and request methods.\n\nHere’s an example of how to use in Axios to transform JSON data into XML data and post it:\n\nTo modify the data before passing it to or , you can set the property. Leveraging both the and , here’s an example that transforms JSON data to CSV, posts it, and then turns the received response into JSON to use on the client:\n\nHTTP interception is a popular feature of Axios. With this feature, you can examine and change HTTP requests from your program to the server and vice versa, which is very useful for a variety of implicit tasks, such as logging and authentication.\n\nAxios interceptors are functions that can be executed before a request is sent or after a response is received through Axios. There are two types of interceptor methods in Axios: request and response.\n\nAt first glance, interceptors look very much like transforms, but they differ in one key way: unlike transforms, which only receive the data and headers as arguments, interceptors receive the entire response object or request config.\n\nYou can declare a request interceptor in Axios like this:\n\nThis code logs a message to the console whenever a request is sent and then waits until it gets a response from the server, at which point it prints the time the account was created at GitHub to the console. One advantage of using interceptors is that you no longer have to implement tasks for each HTTP request separately.\n\nAxios also provides a response interceptor, which allows you to transform the responses from a server on their way back to the application. For example, here’s how to catch errors in an interceptor with Axios:\n\nCross-site request forgery (or XSRF for short) is a method of attacking a web-hosted app in which the attacker disguises themself as a legal and trusted user to influence the interaction between the app and the user’s browser. There are many ways to execute such an attack, including .\n\nFortunately, Axios is designed to protect against XSRF by allowing you to embed additional authentication data when making requests. This enables the server to discover requests from unauthorized locations.\n\nHere’s how this can be done with Axios:\n\nAnother interesting feature of Axios is the ability to monitor request progress. This is especially useful when downloading or uploading large files. The example provided in the Axios documentation gives you a good idea of how that can be done. But for the sake of simplicity and style, we are going to use the Axios Progress Bar module in this tutorial.\n\nThe first thing we need to do to use this module is to include the related style and script:\n\nThen we can implement the progress bar like this:\n\nTo change the default styling of the progress bar, we can override the following style rules:\n\nIn some situations, you may no longer care about the result and want to cancel a request that’s already been sent. This can be done by using . You can create an instance and set its corresponding instance as the value of the property of the config object.\n\nAxios also has a built-in function for canceling requests. However, the built-in functionality is deprecated. You may still encounter it in legacy codebase, but it is not advisable to use it in new projects.\n\nBelow is a basic example:\n\nYou can also create a cancel token by passing an executor function to the constructor, as shown below:\n\nAn HTTP request may succeed or fail. Therefore, it is important to handle errors on the client side and provide appropriate feedback for a better user experience.\n\nPossible causes of error in a network request may include server errors, authentication errors, missing parameters, and requesting non-existent resources.\n\nAxios, by default, rejects any response with a status code that falls outside the successful 2xx range. However, you can modify this feature to specify what range of HTTP codes should throw an error using the config option, like in the example below:\n\nThe error object that Axios passes to the block has several properties, including the following:\n\nIn addition to the properties highlighted above, if the request was made and the server responded with a status code that falls outside the 2xx range, the error object will also have the object.\n\nOn the other hand, if the request was made but no response was received, the error object will have an object. Depending on the environment, the object is an instance of in the browser environment and an instance of in Node.\n\nYou need to check for and objects in your callback to determine the error you are dealing with so that you can take appropriate action:\n\nHow to use Axios interceptors to handle API error responses\n\nSometimes, duplicating the code above in the callback for each request can become tedious and time-consuming. You can instead intercept the error and handle it globally like so:\n\nA more granular, centralized error-handling approach is maintaining the API globally and managing all response and request errors with a dedicated handler function.\n\nLet’s understand it with a simple React app that shows toast messages when a request or response error occurs. Start by creating a file called in the directory of your React app and use the method to create a custom Axios instance.\n\nIn this example, I’m using a placeholder API to demonstrate and use one of its endpoints as the base URL of our Axios instance:\n\nNext, let’s define a handler function and call it in the same file. This function takes one argument — expected to be the error object when we implement this with Axios interceptors. With this error object, we can categorize errors based on their type (e.g., response, request, setup) and display appropriate user feedback using a React toast library:\n\nNow, we can add a response interceptor to our custom Axios instance to provide automatic success notifications for successful API responses and delegate error handling to the function:\n\nWe can then use this custom Axios instance in a component where we want to consume the API (the placeholder API in this case) and let it handle errors by itself. Here’s the complete setup of our React app with HTTP error feedback following a centralized error-handling approach.\n\nHow to post a file from a form with Axios\n\nWe can use Axios with the object to streamline a file upload. To simplify the demonstration, I’m using React again to create a file upload component with basic error handling.\n\nN.B., we are assuming that a backend API is available to support the file upload in this example. This will make more sense with a test backend API in your local development setup.\n\nLet’s use React’s Hook to manage the file selection and its upload status. Let’s also create a handler function ( ) to manage the file selection, which basically updates the state to the file chosen by the user:\n\nWe should now define a handler function ( ) for file upload, which creates a object if a file is selected. The selected file is then appended to this object, which will be sent in an Axios POST request. Uploading a file is a heavy operation, therefore this handler function should execute asynchronously to allow other operations to continue without blocking the UI thread.\n\nN.B., if your use case allows, you may also use an Axios PUT request to upload a file, which takes a similar approach but may also require you to add some additional steps.\n\nTo the same function, i.e., , we can add a block with a custom Axios instance pointing to our backend API’s endpoint, which is responsible for the file upload. Because it is a file upload, we must set the to to have our file properly parsed at the backend.\n\nWe may also reflect the upload progress in the frontend using the property of our custom Axios instance. If the request is successful, we set the to something positive, which we can also show through a toast message later. Otherwise, we set a negative message to the state:\n\nFinally, we should add some JSX to structure our file upload box and use the states, selection handlers, and file upload handlers appropriately, as shown below:\n\nAs an assignment, you may try adding previously discussed Axios interceptors-based error handling to this example. Find the code for this example in this StackBlitz demo.\n\nAxios’ rise in popularity among developers has resulted in a rich selection of third-party libraries that extend its functionality. From testers to loggers, there’s a library for almost any additional feature you may need when using Axios. Here are some libraries that are currently available:\n• axios-cache-plugin: Helps you cache GET requests when using Axios\n• axios-curlirize: Logs any Axios request as a curl command in the console\n• axios-mock-adapter: Axios adapter that allows you to easily mock requests\n• axios-debug-log: Axios interceptor of logging request and response with debug library\n• axiosist: Axios-based supertest that converts the Node.js request handler to an Axios adapter; used for Node.js server unit test\n\nThere’s a good reason Axios is so popular among developers: it’s packed with useful features. In this post, we took a look at several key features of Axios and learned how to use them in practice. But there are still many aspects of Axios that we haven’t discussed. Be sure to check out the Axios GitHub page to learn more.\n\nDo you have any tips on using Axios? Let us know in the comments!"
    }
]