[
    {
        "link": "https://docs.wxpython.org/events_overview.html",
        "document": "Like with all the other GUI frameworks, the control of flow in wxPython applications is event-based: the program normally performs most of its actions in response to the events generated by the user. These events can be triggered by using the input devices (such as keyboard, mouse, joystick) directly or, more commonly, by a standard control which synthesizes such input events into higher level events: for example, a wx.Button can generate a click event when the user presses the left mouse button on it and then releases it without pressing in the meanwhile. There are also events which don’t directly correspond to the user actions, such as wx.TimerEvent.\n\nBut in all cases wxPython represents these events in a uniform way and allows you to handle them in the same way wherever they originate from. And while the events are normally generated by wxPython itself, you can also do this, which is especially useful when using custom events (see Custom Event Summary).\n\nTo be more precise, each event is described by:\n• None Event type: this is simply a value of type EventType which uniquely identifies the type of the event. For example, clicking on a button, selecting an item from a list box and pressing a key on the keyboard all generate events with different event types.\n• None Event class: carried by the event: each event has some information associated with it and this data is represented by an object of a class derived from wx.Event. Events of different types can use the same event class, for example both button click and listbox selection events use wx.CommandEvent class (as do all the other simple control events), but the key press event uses wx.KeyEvent as the information associated with it is different.\n• None Event source: wx.Event stores the object which generated the event and, for windows, its identifier (see Window Identifiers). As it is common to have more than one object generating events of the same type (e.g. a typical window contains several buttons, all generating the same button click event), checking the event source object or its id allows to distinguish between them.\n\nLet us start by looking at the syntax: in any place in your code, but usually in the code of the class defining the handler itself, call its method like this: Event handlers can be bound at any moment. For example, it’s possible to do some initialization first and only bind the handlers if and when it succeeds. This can avoid the need to test that the object was properly initialized in the event handlers themselves. With they simply won’t be called if it wasn’t correctly initialized. As a slight extension of the above, the handlers can also be unbound at any time with (and maybe rebound later). Almost last but very, very far from least is the flexibility which allows to bind an event to:\n• None An ordinary function like a static method or a global function. Let us now look at more examples of how to use different event handlers using the two overloads of function: first one for the object methods and the other one for arbitrary functors (callable objects, including simple functions). In addition to using a method of the object generating the event itself, you can use a method from a completely different object as an event handler: Note that MyFrameHandler doesn’t need to derive from wx.EvtHandler.\n\nThe previous sections explain how to define event handlers but don’t address the question of how exactly wxPython finds the handler to call for the given event. This section describes the algorithm used in detail. When an event is received from the windowing system, wxPython calls on the first event handler object belonging to the window generating the event. The normal order of event table searching by is as follows, with the event processing stopping as soon as a handler is found (unless the handler calls in which case it doesn’t count as having handled the event and the search continues):\n• None Before anything else happens, is called. If it returns anything but -1 (default), the event handling stops immediately.\n• None If this event handler is disabled via a call to the next three steps are skipped and the event handler resumes at step (5).\n• None If the object is a wx.Window and has an associated validator, wx.Validator gets a chance to process the event.\n• None The list of dynamically bound event handlers, i.e., those for which was called, is consulted.\n• None The event table containing all the handlers defined using the event table macros in this class and its base classes is examined. Notice that this means that any event handler defined in a base class will be executed at this step.\n• None The event is passed to the next event handler, if any, in the event handler chain, i.e., the steps (1) to (4) are done for it. Usually there is no next event handler so the control passes to the next step but see Event Handlers Chain for how the next handler may be defined.\n• None If the object is a wx.Window and the event is set to propagate (by default only event types derived from wx.CommandEvent are set to propagate), then the processing restarts from the step (1) (and excluding the step (7)) for the parent window. If this object is not a window but the next handler exists, the event is passed to its parent if it is a window. This ensures that in a common case of (possibly several) non-window event handlers pushed on top of a window, the event eventually reaches the window parent.\n• None Finally, i.e., if the event is still not processed, the wx.App object itself (which derives from wx.EvtHandler) gets a last chance to process it. Please pay close attention to step 6! People often overlook or get confused by this powerful feature of the wxPython event processing system. The details of event propagation up the window hierarchy are described in the next section. As mentioned above, the events of the classes deriving from wx.CommandEvent are propagated by default to the parent window if they are not processed in this window itself. But although by default only the command events are propagated like this, other events can be propagated as well because the event handling code uses to check whether an event should be propagated. It is also possible to propagate the event only a limited number of times and not until it is processed (or a top level parent window is reached). Finally, there is another additional complication (which, in fact, simplifies life of wxPython programmers significantly): when propagating the command events up to the parent window, the event propagation stops when it reaches the parent dialog, if any. This means that you don’t risk getting unexpected events from the dialog controls (which might be left unprocessed by the dialog itself because it doesn’t care about them) when a modal dialog is popped up. The events do propagate beyond the frames, however. The rationale for this choice is that there are only a few frames in a typical application and their parent-child relation are well understood by the programmer while it may be difficult, if not impossible, to track down all the dialogs that may be popped up in a complex program (remember that some are created automatically by wxPython). If you need to specify a different behaviour for some reason, you can use ( ) explicitly to prevent the events from being propagated beyond the given window or unset this flag for the dialogs that have it on by default. Typically events that deal with a window as a window (size, motion, paint, mouse, keyboard, etc.) are sent only to the window. Events that have a higher level of meaning or are generated by the window itself (button click, menu select, tree expand, etc.) are command events and are sent up to the parent to see if it is interested in the event. More precisely, as said above, all event classes not deriving from wx.CommandEvent (see the wx.Event inheritance diagram) do not propagate upward. In some cases, it might be desired by the programmer to get a certain number of system events in a parent window, for example all key events sent to, but not used by, the native controls in a dialog. In this case, a special event handler will have to be written that will override in order to pass all events (or any selection of them) to the parent window. Step 4 of the event propagation algorithm checks for the next handler in the event handler chain. This chain can be formed using : (Referring to the image, if is called and it doesn’t handle the event, will be called and so on…). Additionally, in the case of wx.Window you can build a stack (implemented using wx.EvtHandler double-linked list) using : (Referring to the image, if is called, it immediately calls ; if nor A nor B handle the event, then the wx.Window itself is used – i.e. the dynamically bind event handlers and static event table entries of wx.Window are looked as the last possibility, after all pushed event handlers were tested). By default the chain is empty, i.e. there is no next handler."
    },
    {
        "link": "https://wxpython.org/Phoenix/docs/html/events_overview.html",
        "document": "Like with all the other GUI frameworks, the control of flow in wxPython applications is event-based: the program normally performs most of its actions in response to the events generated by the user. These events can be triggered by using the input devices (such as keyboard, mouse, joystick) directly or, more commonly, by a standard control which synthesizes such input events into higher level events: for example, a wx.Button can generate a click event when the user presses the left mouse button on it and then releases it without pressing in the meanwhile. There are also events which don’t directly correspond to the user actions, such as wx.TimerEvent.\n\nBut in all cases wxPython represents these events in a uniform way and allows you to handle them in the same way wherever they originate from. And while the events are normally generated by wxPython itself, you can also do this, which is especially useful when using custom events (see Custom Event Summary).\n\nTo be more precise, each event is described by:\n• None Event type: this is simply a value of type EventType which uniquely identifies the type of the event. For example, clicking on a button, selecting an item from a list box and pressing a key on the keyboard all generate events with different event types.\n• None Event class: carried by the event: each event has some information associated with it and this data is represented by an object of a class derived from wx.Event. Events of different types can use the same event class, for example both button click and listbox selection events use wx.CommandEvent class (as do all the other simple control events), but the key press event uses wx.KeyEvent as the information associated with it is different.\n• None Event source: wx.Event stores the object which generated the event and, for windows, its identifier (see Window Identifiers). As it is common to have more than one object generating events of the same type (e.g. a typical window contains several buttons, all generating the same button click event), checking the event source object or its id allows to distinguish between them.\n\nLet us start by looking at the syntax: in any place in your code, but usually in the code of the class defining the handler itself, call its method like this: Event handlers can be bound at any moment. For example, it’s possible to do some initialization first and only bind the handlers if and when it succeeds. This can avoid the need to test that the object was properly initialized in the event handlers themselves. With they simply won’t be called if it wasn’t correctly initialized. As a slight extension of the above, the handlers can also be unbound at any time with (and maybe rebound later). Almost last but very, very far from least is the flexibility which allows to bind an event to:\n• None An ordinary function like a static method or a global function. Let us now look at more examples of how to use different event handlers using the two overloads of function: first one for the object methods and the other one for arbitrary functors (callable objects, including simple functions). In addition to using a method of the object generating the event itself, you can use a method from a completely different object as an event handler: Note that MyFrameHandler doesn’t need to derive from wx.EvtHandler.\n\nThe previous sections explain how to define event handlers but don’t address the question of how exactly wxPython finds the handler to call for the given event. This section describes the algorithm used in detail. When an event is received from the windowing system, wxPython calls on the first event handler object belonging to the window generating the event. The normal order of event table searching by is as follows, with the event processing stopping as soon as a handler is found (unless the handler calls in which case it doesn’t count as having handled the event and the search continues):\n• None Before anything else happens, is called. If it returns anything but -1 (default), the event handling stops immediately.\n• None If this event handler is disabled via a call to the next three steps are skipped and the event handler resumes at step (5).\n• None If the object is a wx.Window and has an associated validator, wx.Validator gets a chance to process the event.\n• None The list of dynamically bound event handlers, i.e., those for which was called, is consulted.\n• None The event table containing all the handlers defined using the event table macros in this class and its base classes is examined. Notice that this means that any event handler defined in a base class will be executed at this step.\n• None The event is passed to the next event handler, if any, in the event handler chain, i.e., the steps (1) to (4) are done for it. Usually there is no next event handler so the control passes to the next step but see Event Handlers Chain for how the next handler may be defined.\n• None If the object is a wx.Window and the event is set to propagate (by default only event types derived from wx.CommandEvent are set to propagate), then the processing restarts from the step (1) (and excluding the step (7)) for the parent window. If this object is not a window but the next handler exists, the event is passed to its parent if it is a window. This ensures that in a common case of (possibly several) non-window event handlers pushed on top of a window, the event eventually reaches the window parent.\n• None Finally, i.e., if the event is still not processed, the wx.App object itself (which derives from wx.EvtHandler) gets a last chance to process it. Please pay close attention to step 6! People often overlook or get confused by this powerful feature of the wxPython event processing system. The details of event propagation up the window hierarchy are described in the next section. As mentioned above, the events of the classes deriving from wx.CommandEvent are propagated by default to the parent window if they are not processed in this window itself. But although by default only the command events are propagated like this, other events can be propagated as well because the event handling code uses to check whether an event should be propagated. It is also possible to propagate the event only a limited number of times and not until it is processed (or a top level parent window is reached). Finally, there is another additional complication (which, in fact, simplifies life of wxPython programmers significantly): when propagating the command events up to the parent window, the event propagation stops when it reaches the parent dialog, if any. This means that you don’t risk getting unexpected events from the dialog controls (which might be left unprocessed by the dialog itself because it doesn’t care about them) when a modal dialog is popped up. The events do propagate beyond the frames, however. The rationale for this choice is that there are only a few frames in a typical application and their parent-child relation are well understood by the programmer while it may be difficult, if not impossible, to track down all the dialogs that may be popped up in a complex program (remember that some are created automatically by wxPython). If you need to specify a different behaviour for some reason, you can use ( ) explicitly to prevent the events from being propagated beyond the given window or unset this flag for the dialogs that have it on by default. Typically events that deal with a window as a window (size, motion, paint, mouse, keyboard, etc.) are sent only to the window. Events that have a higher level of meaning or are generated by the window itself (button click, menu select, tree expand, etc.) are command events and are sent up to the parent to see if it is interested in the event. More precisely, as said above, all event classes not deriving from wx.CommandEvent (see the wx.Event inheritance diagram) do not propagate upward. In some cases, it might be desired by the programmer to get a certain number of system events in a parent window, for example all key events sent to, but not used by, the native controls in a dialog. In this case, a special event handler will have to be written that will override in order to pass all events (or any selection of them) to the parent window. Step 4 of the event propagation algorithm checks for the next handler in the event handler chain. This chain can be formed using : (Referring to the image, if is called and it doesn’t handle the event, will be called and so on…). Additionally, in the case of wx.Window you can build a stack (implemented using wx.EvtHandler double-linked list) using : (Referring to the image, if is called, it immediately calls ; if nor A nor B handle the event, then the wx.Window itself is used – i.e. the dynamically bind event handlers and static event table entries of wx.Window are looked as the last possibility, after all pushed event handlers were tested). By default the chain is empty, i.e. there is no next handler.\n\nWhile generically a wx.Event can be generated both by user actions (e.g., resize of a wx.Window) and by calls to functions (e.g., ), wxPython controls normally send wx.CommandEvent -derived events only for the user-generated events. The only exceptions to this rule are:\n• None : Use instead, as is deprecated can be used instead of but the other functions, such as or don’t have event-free equivalents. Window identifiers are integers, and are used to uniquely determine window identity in the event system (though you can use it for other purposes). In fact, identifiers do not need to be unique across your entire application as long they are unique within the particular context you’re interested in, such as a frame and its children. You may use the identifier, for example, on any number of dialogs as long as you don’t have several within the same dialog. If you pass or -1 to a window constructor, an identifier will be generated for you automatically by wxPython. This is useful when you don’t care about the exact identifier either because you’re not going to process the events from the control being created or because you process the events from all controls in one place (in which case you should specify in the call as well). The automatically generated identifiers are always negative and so will never conflict with the user-specified identifiers which must be always positive. See Standard event identifiers for the list of standard identifiers available. You can use to determine the number above which it is safe to define your own identifiers. Or, you can use identifiers below . Finally, you can allocate identifiers dynamically using function too. If you use consistently in your application, you can be sure that your identifiers don’t conflict accidentally."
    },
    {
        "link": "https://wxpython.org/pages/changes/index.html",
        "document": "The following deprecated items have been removed: wx.EventLoop is now implemented for wxMac. Added wxPython wrappers for the new wx.Treebook and wx.Toolbook classes. wx.DC.BeginDrawing and EndDrawing have been deprecated in the C++ code, so since they never really did anything before they are now just empty stubs in wxPython. Solved a problem that has been around for a very long time in how C++ methods are virtualized for overriding in derived Python classes. Previously we couldn't do it for methods that needed to also exist in the base class wrappers such that they could be called normally. (The reasons are long and complex, but suffice it to say that it was due to mixing C++'s dynamic dispatch, and Python's runtime lookup of the method attributes resulting in endless recursion of function calls.) Because of this problem I used a hack that I have always hated, and that is renaming the base class methods with a \"base_*\" prefix, for example wx.Printout.base_OnBeginDocument. Now that the problem has finally been solved I have replaced all the base_Whatever() methods with the real Whatever() method as well as a simple wrapper named base_Whatever that is marked as deprecated. So now instead of writing your overridden methods like this: def OnBeginDocument(self, start, end): # do something here return self.base_OnBeginDocument(start, end) You can now call the base class method the normal way, like this: def OnBeginDocument(self, start, end): # do something here return Printout.OnBeginDocument(self, start, end) Or like this with super(): def OnBeginDocument(self, start, end): # do something here return super(MyPrintout, self).OnBeginDocument(start, end) Note that the old way with the \"base_*\" function still works, but you will get a DeprecationWarning from calling base_OnBeginDocument. The classes affected by this are:\n• None wx.PyLog (also added the ability to override Flush)\n• None wx.PyApp (also added the ability to override ExitMainLoop) wxGTK: wx.ListBox and wx.CheckListBox are now using native GTK2 widgets. Bumped up to SWIG 1.3.29. This provides some more runtime performance boosts, gets rid of the dreaded Ptr classes, and some other nice new things. Added wx.Window.GetScreenPosition and GetScreenRect which returns the position of the window in screen coordinates, even if the window is not a top-level window. Added a GetReceivedFormat method to wx.DataObjectComposite. You can use this to find out what format of data object was recieved from the source of the clipboard or DnD operation, and then you'll know which of the component data objects to use to access the data. Changed how the stock objects (wx.RED, wx.RED_PEN, wx.RED_BRUSH, etc.) are initialized. They are now created as uninitialized instances using __new__. Then after the wx.App has been created, but before OnInit is called, the .this attribute of each object is initialized. This was needed because of some delayed initialization functionality that was implemented in wxWidgets, but the end result is cleaner for wxPython as well, and allowed me to remove some ugly code previously hidden under the covers. wx.ProgressDialog.Update now returns a tuple of two values. The first is a continue flag (what was returned before) and the second is a skip flag. If the dialog has the wx.PD_CAN_SKIP flag and if the Skip button is clicked, then the skip flag is set to True the next time Update is called. A DeprecationWarning is now issued when the old wxPython package is imported. If you are still using the old namespace please convert your code to use the new wx package instead. Added wrappers for Julian's new wxRichTextCtrl class, visible in wxPython as wx.richtext.RichTextCtrl window. It still needs some more work, but it is a great start. wx.lib.mixins.listctrl.TextEditMixin: Fixed the double END_LABEL_EDIT event problem in TextEditMixin by checking if the editor was already hidden before continuing with the CloseEditor method. Also added code to OpenEditor to send the BEGIN_LABEL_EDIT event and to not allow the opening of the editor to continue if the event handler doesn't allow it. wx.StaticBoxSizer now keeps better track of the wx.StaticBox, and it will destroy it if the sizer is destroyed before the parent window is. Added battery and power related functions and events (wxMSW only so far.) See wx.PowerEvent, wx.GetPowerType and wx.GetBatteryState. Added wx.ListCtrl.HitTestSubItem which returns the sub-item (i.e. the column in report mode) that was hit (if any) in addition to the item and flags. Added wrappers for the wxAUI classes, in the wx.aui module. Added the PseudoDC class from Paul Lanier. It provides a way to record operations on a DC and then play them back later. Added CanSetTransparent and SetTransparent methods to the wx.TopLevelWindow class, with implementations (so far) for wxMSW and wxMac. SetDefaultItem() and GetDefaultItem() are now members of wx.TopLevelWindow, not wx.Panel. wxGTK: Stock items (icons) will be used for menu items with stock IDs. Added wx.ImageFromBuffer, wx.BitmapFromBuffer and wx.BitmapFromBufferRGBA factory functions. They enable loading of an image or bitmap directly from a Python object that implements the buffer interface, such as strings, arrays, etc. Added wx.App.IsDisplayAvailable() which can be used to determine if a GUI can be created in the current environment. (Still need an implementation for wxMSW...) The wx.html.HTML_FONT_SIZE_x constants are no longer available as the default sizes are now calculated at runtime based on the size of the normal GUI font. wx.Colour now includes an alpha component, which defaults to wx.ALPHA_OPAQUE. This is in preparation for allowing various new alpha blening functionality using wx.Colour objects, such as drawing with pens and brushes on a wx.DC. Added wx.NativePixelBuffer, wx.AlphPixelBuffer and related iterator and accessor classes. They allow platform independent direct access to the platform specific pixel buffer inside of a wx.Bitmap object. The beginnings of support for RTL languages has been added, thanks to a Google SoC project. Added wx.lib.dragscroller from Riaan Booysen. It provides a helper class that can used to scroll a wx.ScrolledWindow in response to a mouse drag. wxMac: I've turned on the compile option for using the native toolbar on the Mac now that it supports hosting of controls. If the toolbar is managed by the frame via either CreateToolBar() or SetToolBar() then the native toolbar will be used. Additional toolbars, or toolbars that are not children of the frame, are managed by sizers or what-not will still use the emulated toolbar because of platform restrictions in how/where the native toolbar can be used. Added Python properties for many of the getter/setter methods of wx classes. In order for the names to be predicatble for somebody already familiar with wxPython the property names are simply the name of the getter with the \"Get\" dropped. For example, wx.Window has a property named \"Size\" that maps to GetSize and SetSize. So far there is only one known name conflict using this naming convention, and that is wx.KeyEvent.KeyCode, however since KeyCode was formerly a compatibility alias for GetKeyCode (and has been for a long time) it was decided to just switch it to a property. If you want to use the method then change your calls to event.KeyCode() to event.GetKeyCode(), otherwise you can use it as a property just by dropping the parentheses. Updated the C++ code for wx.gizmos.TreeListCtrl from the wxCode project. This has resulted in some minor API changes, most of which were worked around in the wrapper code. Added wx.lib.expando, a multi-line textctrl that expands as more lines are needed. wx.Image.Scale and Rescale methods now take an extra parameter specifying type of method to use for resampling the image. It defaults to the current behavior of just replicating pixels, if wx.IMAGE_QUALITY_HIGH is passed then it uses bicubic and box averaging resampling methods for upsampling and downsampling respectively. Added the wx.lib.buttonpanel module, which is a tweaked version of Andrea Gavana's FancyButtonPanel module. Renamed wx.FutureCall to wx.CallLater so it is named more like wx.CallAfter. wx.FutureCall is now an empty subclass of wx.CallLater for compatibility of older code. Added ChangeSelection to wx.BookCtrl (the base class for wx.Notebook and other book controls) that is the same as SetSelection but doesn't send the change events. Added wx.TextCtrl.ChangeValue() which is the same as SetValue() but doesn't send the text changed event. For consistency, all classes having an Ok() method now also have IsOk(), use of the latter form is preferred although the former hasn't been deprecated yet Added the wx.AboutBox() function and wx.AboutDialogInfo class. They provide a way to show a standard About box for the application, which will either be a native dialog or a generic one depending on what info is provided and if it can all be shown with the native dialog. The code in the animate contrib has been moved into the core wxWidgets library, and refactored a bit along the way. For wxPython it still exists in the wx.animate module, but has basically been reduced to two classes, wx.animate.Animation, and wx.animate.AnimationCtrl. You load the animated GIF (and hopefully there will be other supported formats in the near future) in the Animation object, and then give that to the AnimatedCtrl for display. See the demo for an example. There is also still a GIFAnimationCtrl class that provides some level of backwards compatibility with the old implementation. wxMac: The compile option that turns on the use of CoreGraphics (a.k.a Quartz) for wxDC is now turned on by default. This means that all drawing via wxDC is done using the new APIs from apple, instead of the old Quick Draw API. There are, however, a few places where Quartz and wxDC don't fit together very well, mainly the lack of support for logical drawing operations such as XOR, but there is work in progress to provide other ways to do the same sort of thing that will work with Quartz and also on the other platforms. The first parts of a new 2D drawing API has been added with the wx.GraphicsPath and wx.GraphicsContext classes. They wrap GDI+ on Windows, Cairo on wxGTK and CoreGraphics on OS X. They allow path-based drawing with alpha-blending and anti-aliasing, and use a floating point cooridnate system. Currently they can only target drawing to windows, but other wx.DC backends are forthcoming. The APIs may evolve a bit more before they are finalaized with the 2.8 release, but there is enough there now to get a good feel for how things will work. There is also a transitional wx.GCDC class that provides the wx.DC API on top of wx.GraphicsContext. Docs and a demo are still MIA. Added a wx.AutoBufferedPaintDC that is a subclass of wx.PaintDC on platforms that do double buffering by default, and a subclass of wx.BufferedPaintDC on the platforms that don't. You can use this class to help avoid the overhead of buffering when it is not needed. There is also a wx.AutoBufferedPaintDCFactory function that does a little more and actually tests if the window has double-buffering enabled and then decides whether to return a wx.PaintDC or wx.BufferedPaintDC. This uses the new wx.Window.IsDoubleBuffered method.\n\nwx.Sizer Add, Insert, and Prepend functions now return a reference to the wx.SizerItem that was added to the sizer, and the wx.SizerItem has a GetRect accessor to give the position of the item on the parent window. Added wx.Sizer.GetItem method which returns the wx.SizerItem for the given wx.Window, wx.Sizer or position index. wxMSW: wx.RadioButtons in the same group no longer have to be consecutive (there may be intervening controls). Without this fix, an out-of-sync assert is generated when clicking on a radio button and then calling GetValue(). Added wx.PasswordEntryDialog analagous to wx.TextEntryDialog, allows detecting entering an empty string vs. cancel unlike the wx.GetPasswordFromUser dialog function. Two simple problems found in the new python ogl code. First is the patch for _canvas.py. Essentially: was incorrect because (x,y) and (self._firstDragX, self._firstDragY) are both already in Logical coordinates. Therefore the difference between the two is also in logical coordinates, and the conversion call is an error. This bug surfaces when you have OGL on a scrollwin, and you are far from the origin of the canvas. The second change in _composit.py basically removes the assumption that the child is in both self._children and self._divisions. Causes many problems when it's not. ;) Fixed GetSaveData and SetSaveData in wx.lib.multisash to not depend on the default way that class objectss are converted to strings. Fixed problem in StyledTextCtrl.Set[HV]ScrollBar that could leave the internal scrollbar visible. Added wx.StandardPaths which provides methods for determining standard system paths for each platform. wxMSW: The window background is now only erased by default if the background colour or background mode has been changed. This better allows the default system themed behaviour to show through for uncustomized windows. Explicit support added for using the correct theme texture for wx.Notebook pages and their children. wx.Image: Added support for alpha channels in interpolated and non-interpolated image rotation. Added ConvertAlphaToMask helper method for turning shades of grey into shades of alpha and a colour. wxGTK2: Reimplemented DoDrawRotatedText() by way of a rotation of an alpha blended text bitmap. It would be better if Pango could draw directly into an wxImage (as FreeType can,) but that is for later... Added wrappers and a demo for the wx.MediaCtrl class, which can play various forms of audio/video media using native codecs install on the system. So far it is only implemented for Windows and OSX. Added \"gravity\" for splitter window (patch 1046105). Gravity is a floating-point factor between 0.0 and 1.0 which controls position of sash while resizing the wx.SplitterWindow. The gravity specifies how much the left/top window will grow while resizing. wxMSW: wx.Slider's C++ implementation rewritten to be more maintainable and hopefully less buggy. The position of the labels has also been changed in order to better comply with Microsoft's examples of how to use the control. wxMSW: Fix wx.TreeCtrl to end label editing if the control loses focus (a slightly modified patch 1084592.) Added wx.EXEC_NODISABLE flag for wx.Execute, which will prevent all the app's windows being disabled while a synchronous child process is running. wxMSW: Much work to correct painting (or leaving transparent) of control backgrounds, properly using background themes on XP, etc. Fixed a circular reference problem with wx.Timer. It will now completely cleanup after itself when the last reference to the timer is removed. If you were previously using timer.Destroy() to cleanup your timers it will no longer work. Instead you should hold a reference to the timer and then del the reference when you are finished with the timer. Updated to 1.3.24 of SWIG. All of my big patches have been applied to the main SWIG source tree, but unfortunatly there were also some bugs added that affected the wxPython build and a few details in my original patch were changed/removed, so we are still not free of patches. A new patch for SWIG is located in the wxPython/SWIG directory of the wxPython source tree. SWIG 1.3.24 plus this patch should be used by anyone who is making custom modifications to wxPython's .i files, or building their own extension modules or etc. that need to interact with the wxPython swigged types. For the morbidly curious, here are a few more details:\n• None Since it is now possible easily and simply share the SWIG type tables across modules I reverted to always using the stock SWIG runtime instead of my slightly hacked up version of it exported via the wxPython C API.\n• None The %name directive is now deprecated so I replaced most uses of it with a custom %Rename macro that uses %rename internally. These will evetually need to be replaced with a DocDecl macro when docstrings are added for those items.\n• None The \"this\" attribute of all SWIGged classes is no longer a string containing a \"swigified pointer\", but rather a custom built-in type that holds the real C pointer to the object and the type info. It can be converted to a string like the old value using str() or to the long integer value of the pointer using long(). Added SetDefaultPyEncoding and GetDefaultPyEncoding functions which will set/get the encoding used by wxPython to convert string or unicode objects to/from wxString objects. Previously the default Python encoding was always used, but unless the user had tweaked their sitecustomize.py file it is always \"ascii\", which would result in errors if the strings contained character codes >= 128. SetDefaultPyEncoding will now allow you to control which encoding will be used to do those conversions. The default encoding is set to the value of when wxPython is first imported. Please see http://www.alanwood.net/demos/charsetdiffs.html for information on the differences between the common latin/roman encodings. Added wxStdDialogButtonSizer, which is a a special sizer that knows how to order and position standard buttons in order to conform to the current platform's standards. You simply need to add each to the sizer, and be sure to create the buttons using the standard ID's. Then call and the sizer will take care of the rest. wxMSW Toolbar: pass correct tool id (and not always -1) to the EVT_TOOL_RCLICKED handler wxGTK: Applied patch for combo box SELECTED events (no longer get lots of surplus events) wxGTK: Commited scrollbar patch #1093339 which sends lineup, linedown events based on intercepting the mouse down events. wxGTK: Applied patch #1102789 which solved conflicts between wxWidgets and GTK+'s context menu code. wxGTK: Applied patch #1100327 for correct feedback from DND actions (not all actions are allowed). For efficiency reasons, text controls no longer set the string for each text updated event, but rather query for the string value only when GetString is called from an event handler. Added wx.SL_INVERSE style which will cause wx.Slider to invert the min and max ends of the slider. Several patches applied, such as #1111174, #1110252 and others, that make the generic wx.TreeCtrl (used on wxGTK and wxMac) be more conistent with the wxMSW native wx.TreeCtrl.\n• None Edit->Locate command (Ctrl-L) for quick selection of items. Works with event-handling controls (buttons, text fields) but not with labels/sizers.\n• None Some improvements: relative paths for files supplied as command- line argument work correctly, notebook panels are highlighted better. wxMac: Fixed a long-standing issue where wxSlider controls with a hardcoded size would misplace their labels behind the slider control. wx.HtmlListBox fixed so calling RefreshLine(s) will cause the data for that line to be refetched from the overridden methods in the derived class. The default DoGetBestSize now includes the difference (if any) between the client size and total size of the window, (such as the size of borders.) Code that sets the client size using the best size, or that added extra space to sizers to compensate for this bug may need to be changed. Can suppress themed notebook pages with the wxNB_NOPAGETHEME style or setting system option msw.notebook.themed-background to 0. Can now set the msw.window.no-clip-children system option to 1 to eliminate weird refresh behaviour (delays between a window being erased and repainted, giving a ghostly gradual-redraw effect). May be a temporary 'fix' until properly fixed before 2.6. wxMac: Toolbar is now more native looking with borderless toolbar buttons. wxMac: Switched wx.Bitmap to use newer Quartz object types and APIs internally. This results in faster display and better alpha support. Added wx.lib.gestures module from Daniel Pozmanter which supports using Mouse Gestures in an application. wxGTK2: ENTER and LEAVE mouse events are now sent for multi-line text controls. wxMSW: \"Alt\" key (VK_MENU) now results in WXK_ALT keyboard event, not WXK_MENU Added modules from Peter Yared and Morgan Hua that implement the wx Doc/View framework in pure Python code. See wx.lib.docview for the base implementation and wx.lib.pydocview for Python-specific extensions. There are also a couple sample applications located in samples/docview. wx.Sizer.AddWindow, AddSizer, AddSpacer and etc. have now been undeprecated at the request of Riaan Booysen, the Boa Constructor team lead. Boa needs them to help keep track of what kind of item is being managed by the sizer. They are now just simple compatibility aliases for Add, and etc. The old C++ version of the OGL lib is no longer built by default. Use the Python version in the wx.lib.ogl package instead. The wx.iewin module is no longer built by default. You can use the wx.lib.iewin version instead. Fixed wx.BufferedPaintDC for scrolled windows to work whether the buffer is covering only the client area or the full virtual area of the scrolled window. By default it will assume that only the client area is covered. This is different than the old behavior so to indicate that the entire virtual area is covered simply add a style=wx.BUFFER_VIRTUAL_AREA parameter.\n• None Corrected splitter sash size and look for different themes"
    },
    {
        "link": "https://stackoverflow.com/questions/69276871/wxpython-event-handling-button",
        "document": "When I'm running the following code, I received the error (image attached) I have a button called and when I add it to my right panel I cannot move its position, does anyone knows how can I do that? And another issue is that I'd like to call that specific button when I click on on the left panel, however I have no clue how to do this, I tried to put the button on the method but I wasn't able to make it work.\n\nThe whole code is down below so it's easier to copy-paste it.\n\nOne last question would be, do you know any resources other than the documentation to understand more in depth about this library? (Youtube videos, Udemy, etc)"
    },
    {
        "link": "https://docs.wxpython.org/wx.functions.html",
        "document": "The functions and macros defined in the wx module are described here: you can look up a function using the alphabetical listing of them.\n\nExecutes another program in Unix or Windows. In the overloaded versions of this function, if flags parameter contains flag (the default), flow of control immediately returns. If it contains , the current application waits until the other program has terminated. In the case of synchronous execution, the return value is the exit code of the process (which terminates by the moment the function returns) and will be -1 if the process couldn’t be started and typically 0 if the process terminated successfully. Also, while waiting for the process to terminate, will call . Because of this, by default this function disables all application windows to avoid unexpected reentrancies which could result from the users interaction with the program while the child process is running. If you are sure that it is safe to not disable the program windows, you may pass flag to prevent this automatic disabling from happening. For asynchronous execution, however, the return value is the process id and zero value indicates that the command could not be executed. As an added complication, the return value of -1 in this case indicates that we didn’t launch a new process, but connected to the running one (this can only happen when using under Windows for command execution). In particular, in this case only, the calling code will not get the notification about process termination. If callback isn’t and if execution is asynchronous, will be called when the process finishes. Specifying this parameter also allows you to redirect the standard input and/or output of the process being launched by calling . Under Windows, when launching a console process its console is shown by default but hidden if its is redirected. Both of these default behaviours may be overridden: if is specified, the console will never be shown. If is used, the console will be shown even if the child process is redirected. Neither of these flags affect non-console Windows applications or does anything under the other systems. Under Unix the flag may be used to ensure that the new process is a group leader (this will create a new session if needed). Calling passing will kill this process as well as all of its children (except those which have started their own session). Under MSW, this flag can be used with console processes only and corresponds to the native flag. The flag prevents processing of any events from taking place while the child process is running. It should be only used for very short-lived processes as otherwise the application windows risk becoming unresponsive from the users point of view. As this flag only makes sense with , equal to the sum of both of these flags is provided as a convenience.\n• None command (string) – The command to execute and any parameters to pass to it as a single string, i.e. “emacs file.txt”.\n• None flags (int) – Must include either or and can also include , , (in either case) or and or , which is equal to their combination, in case.\n• None env (ExecuteEnv) – An optional pointer to additional parameters for the child process, such as its initial working directory and environment variables. This parameter is available in wxWidgets 2.9.2 and later only."
    },
    {
        "link": "https://docs.python.org/3/library/time.html",
        "document": "This module provides various time-related functions. For related functionality, see also the and modules.\n\nAlthough this module is always available, not all functions are available on all platforms. Most of the functions defined in this module call platform C library functions with the same name. It may sometimes be helpful to consult the platform documentation, because the semantics of these functions varies among platforms.\n\nAn explanation of some terminology and conventions is in order.\n• None The epoch is the point where the time starts, the return value of . It is January 1, 1970, 00:00:00 (UTC) on all platforms.\n• None The term seconds since the epoch refers to the total number of elapsed seconds since the epoch, typically excluding leap seconds. Leap seconds are excluded from this total on all POSIX-compliant platforms.\n• None The functions in this module may not handle dates and times before the epoch or far in the future. The cut-off point in the future is determined by the C library; for 32-bit systems, it is typically in 2038.\n• None Function can parse 2-digit years when given format code. When 2-digit years are parsed, they are converted according to the POSIX and ISO C standards: values 69–99 are mapped to 1969–1999, and values 0–68 are mapped to 2000–2068.\n• None UTC is Coordinated Universal Time and superseded Greenwich Mean Time or GMT as the basis of international timekeeping. The acronym UTC is not a mistake but conforms to an earlier, language-agnostic naming scheme for time standards such as UT0, UT1, and UT2.\n• None DST is Daylight Saving Time, an adjustment of the timezone by (usually) one hour during part of the year. DST rules are magic (determined by local law) and can change from year to year. The C library has a table containing the local rules (often it is read from a system file for flexibility) and is the only source of True Wisdom in this respect.\n• None The precision of the various real-time functions may be less than suggested by the units in which their value or argument is expressed. E.g. on most Unix systems, the clock “ticks” only 50 or 100 times a second.\n• None On the other hand, the precision of and is better than their Unix equivalents: times are expressed as floating-point numbers, returns the most accurate time available (using Unix where available), and will accept a time with a nonzero fraction (Unix is used to implement this, where available).\n• None The time value as returned by , , and , and accepted by , and , is a sequence of 9 integers. The return values of , , and also offer attribute names for individual fields. See for a description of these objects. Changed in version 3.3: The type was extended to provide the and attributes when platform supports corresponding members. Changed in version 3.6: The attributes and are now available on all platforms.\n• None Use the following functions to convert between time representations:\n\nConvert a tuple or representing a time as returned by or to a string of the following form: . The day field is two characters long and is space padded if the day is a single digit, e.g.: . If t is not provided, the current time as returned by is used. Locale information is not used by . Unlike the C function of the same name, does not add a trailing newline. Return the clk_id of the thread-specific CPU-time clock for the specified thread_id. Use or the attribute of objects to get a suitable value for thread_id. Passing an invalid or expired thread_id may result in undefined behavior, such as segmentation fault. See the man page for pthread_getcpuclockid(3) for further information. Return the resolution (precision) of the specified clock clk_id. Refer to Clock ID Constants for a list of accepted values for clk_id. Return the time of the specified clock clk_id. Refer to Clock ID Constants for a list of accepted values for clk_id. Use to avoid the precision loss caused by the type. Similar to but return time as nanoseconds. Set the time of the specified clock clk_id. Currently, is the only accepted value for clk_id. Use to avoid the precision loss caused by the type. Similar to but set time with nanoseconds. Convert a time expressed in seconds since the epoch to a string of a form: representing local time. The day field is two characters long and is space padded if the day is a single digit, e.g.: . If secs is not provided or , the current time as returned by is used. is equivalent to . Locale information is not used by . Get information on the specified clock as a namespace object. Supported clock names and the corresponding functions to read their value are: The result has the following attributes:\n• None adjustable: if the clock can be changed automatically (e.g. by a NTP daemon) or manually by the system administrator, otherwise\n• None implementation: The name of the underlying C function used to get the clock value. Refer to Clock ID Constants for possible values.\n• None monotonic: if the clock cannot go backward, otherwise\n• None resolution: The resolution of the clock in seconds ( ) Convert a time expressed in seconds since the epoch to a in UTC in which the dst flag is always zero. If secs is not provided or , the current time as returned by is used. Fractions of a second are ignored. See above for a description of the object. See for the inverse of this function. Like but converts to local time. If secs is not provided or , the current time as returned by is used. The dst flag is set to when DST applies to the given time. may raise , if the timestamp is outside the range of values supported by the platform C or functions, and on or failure. It’s common for this to be restricted to years between 1970 and 2038. This is the inverse function of . Its argument is the or full 9-tuple (since the dst flag is needed; use as the dst flag if it is unknown) which expresses the time in local time, not UTC. It returns a floating-point number, for compatibility with . If the input value cannot be represented as a valid time, either or will be raised (which depends on whether the invalid value is caught by Python or the underlying C libraries). The earliest date for which it can generate a time is platform-dependent. Return the value (in fractional seconds) of a monotonic clock, i.e. a clock that cannot go backwards. The clock is not affected by system clock updates. The reference point of the returned value is undefined, so that only the difference between the results of two calls is valid. Use to avoid the precision loss caused by the type. Changed in version 3.5: The function is now always available and always system-wide. Changed in version 3.10: On macOS, the function is now system-wide. Similar to , but return time as nanoseconds. Return the value (in fractional seconds) of a performance counter, i.e. a clock with the highest available resolution to measure a short duration. It does include time elapsed during sleep and is system-wide. The reference point of the returned value is undefined, so that only the difference between the results of two calls is valid. CPython implementation detail: On CPython, use the same clock as and is a monotonic clock, i.e. a clock that cannot go backwards. Use to avoid the precision loss caused by the type. Changed in version 3.10: On Windows, the function is now system-wide. Changed in version 3.13: Use the same clock as . Similar to , but return time as nanoseconds. Return the value (in fractional seconds) of the sum of the system and user CPU time of the current process. It does not include time elapsed during sleep. It is process-wide by definition. The reference point of the returned value is undefined, so that only the difference between the results of two calls is valid. Use to avoid the precision loss caused by the type. Similar to but return time as nanoseconds. Suspend execution of the calling thread for the given number of seconds. The argument may be a floating-point number to indicate a more precise sleep time. If the sleep is interrupted by a signal and no exception is raised by the signal handler, the sleep is restarted with a recomputed timeout. The suspension time may be longer than requested by an arbitrary amount, because of the scheduling of other activity in the system. On Windows, if secs is zero, the thread relinquishes the remainder of its time slice to any other thread that is ready to run. If there are no other threads ready to run, the function returns immediately, and the thread continues execution. On Windows 8.1 and newer the implementation uses a high-resolution timer which provides resolution of 100 nanoseconds. If secs is zero, is used.\n• None Use if available (resolution: 1 nanosecond);\n• None Or use if available (resolution: 1 nanosecond); To emulate a “no-op”, use instead of . To voluntarily relinquish the CPU, specify a real-time scheduling policy and use instead. Changed in version 3.5: The function now sleeps at least secs even if the sleep is interrupted by a signal, except if the signal handler raises an exception (see PEP 475 for the rationale). Changed in version 3.11: On Unix, the and functions are now used if available. On Windows, a waitable timer is now used. Convert a tuple or representing a time as returned by or to a string as specified by the format argument. If t is not provided, the current time as returned by is used. format must be a string. is raised if any field in t is outside of the allowed range. 0 is a legal argument for any position in the time tuple; if it is normally illegal the value is forced to a correct one. The following directives can be embedded in the format string. They are shown without the optional field width and precision specification, and are replaced by the indicated characters in the result: Day of the month as a decimal number [01,31]. Day of the year as a decimal number [001,366]. Locale’s equivalent of either AM or PM. Week number of the year (Sunday as the first day of the week) as a decimal number [00,53]. All days in a new year preceding the first Sunday are considered to be in week 0. Day of the week (Monday is 1; Sunday is 7) as a decimal number [1, 7]. Week number of the year (Monday as the first day of the week) as a decimal number [00,53]. All days in a new year preceding the first Monday are considered to be in week 0. Time zone offset indicating a positive or negative time difference from UTC/GMT of the form +HHMM or -HHMM, where H represents decimal hour digits and M represents decimal minute digits [-23:59, +23:59]. Time zone name (no characters if no time zone exists). Deprecated. ISO 8601 year (similar to but follows the rules for the ISO 8601 calendar year). The year starts with the week that contains the first Thursday of the calendar year. ISO 8601 week number (as a decimal number [01,53]). The first week of the year is the one that contains the first Thursday of the year. Weeks start on Monday.\n• None The format directive only applies to , not to . However, see also and where the format directive applies to microseconds.\n• None When used with the function, the directive only affects the output hour field if the directive is used to parse the hour.\n• None The range really is to ; value is valid in timestamps representing leap seconds and value is supported for historical reasons.\n• None When used with the function, and are only used in calculations when the day of the week and the year are specified. Here is an example, a format for dates compatible with that specified in the RFC 2822 Internet email standard. Additional directives may be supported on certain platforms, but only the ones listed here have a meaning standardized by ANSI C. To see the full set of format codes supported on your platform, consult the strftime(3) documentation. On some platforms, an optional field width and precision specification can immediately follow the initial of a directive in the following order; this is also not portable. The field width is normally 2 except for where it is 3. Parse a string representing a time according to a format. The return value is a as returned by or . The format parameter uses the same directives as those used by ; it defaults to which matches the formatting returned by . If string cannot be parsed according to format, or if it has excess data after parsing, is raised. The default values used to fill in any missing data when more accurate values cannot be inferred are . Both string and format must be strings. Support for the directive is based on the values contained in and whether is true. Because of this, it is platform-specific except for recognizing UTC and GMT which are always known (and are considered to be non-daylight savings timezones). Only the directives specified in the documentation are supported. Because is implemented per platform it can sometimes offer more directives than those listed. But is independent of any platform and thus does not necessarily support all directives available that are not documented as supported. The type of the time value sequence returned by , , and . It is an object with a named tuple interface: values can be accessed by index and by attribute name. The following values are present: Note that unlike the C structure, the month value is a range of [1, 12], not [0, 11]. In calls to , may be set to 1 when daylight savings time is in effect, and 0 when it is not. A value of -1 indicates that this is not known, and will usually result in the correct state being filled in. When a tuple with an incorrect length is passed to a function expecting a , or having elements of the wrong type, a is raised. Return the time in seconds since the epoch as a floating-point number. The handling of leap seconds is platform dependent. On Windows and most Unix systems, the leap seconds are not counted towards the time in seconds since the epoch. This is commonly referred to as Unix time. Note that even though the time is always returned as a floating-point number, not all systems provide time with a better precision than 1 second. While this function normally returns non-decreasing values, it can return a lower value than a previous call if the system clock has been set back between the two calls. The number returned by may be converted into a more common time format (i.e. year, month, day, hour, etc…) in UTC by passing it to function or in local time by passing it to the function. In both cases a object is returned, from which the components of the calendar date may be accessed as attributes. Use to avoid the precision loss caused by the type. Similar to but returns time as an integer number of nanoseconds since the epoch. Return the value (in fractional seconds) of the sum of the system and user CPU time of the current thread. It does not include time elapsed during sleep. It is thread-specific by definition. The reference point of the returned value is undefined, so that only the difference between the results of two calls in the same thread is valid. Use to avoid the precision loss caused by the type. Similar to but return time as nanoseconds. Reset the time conversion rules used by the library routines. The environment variable specifies how this is done. It will also set the variables (from the environment variable), (non-DST seconds West of UTC), (DST seconds west of UTC) and (to 0 if this timezone does not have any daylight saving time rules, or to nonzero if there is a time, past, present or future when daylight saving time applies). Although in many cases, changing the environment variable may affect the output of functions like without calling , this behavior should not be relied on. The environment variable should contain no whitespace. The standard format of the environment variable is (whitespace added for clarity): Where the components are: Three or more alphanumerics giving the timezone abbreviations. These will be propagated into time.tzname The offset has the form: . This indicates the value added the local time to arrive at UTC. If preceded by a ‘-’, the timezone is east of the Prime Meridian; otherwise, it is west. If no offset follows dst, summer time is assumed to be one hour ahead of standard time. Indicates when to change to and back from DST. The format of the start and end dates are one of the following: The Julian day n (1 <= n <= 365). Leap days are not counted, so in all years February 28 is day 59 and March 1 is day 60. The zero-based Julian day (0 <= n <= 365). Leap days are counted, and it is possible to refer to February 29. The d’th day (0 <= d <= 6) of week n of month m of the year (1 <= n <= 5, 1 <= m <= 12, where week 5 means “the last d day in month m” which may occur in either the fourth or the fifth week). Week 1 is the first week in which the d’th day occurs. Day zero is a Sunday. has the same format as except that no leading sign (‘-’ or ‘+’) is allowed. The default, if time is not given, is 02:00:00. On many Unix systems (including *BSD, Linux, Solaris, and Darwin), it is more convenient to use the system’s zoneinfo (tzfile(5)) database to specify the timezone rules. To do this, set the environment variable to the path of the required timezone datafile, relative to the root of the systems ‘zoneinfo’ timezone database, usually located at . For example, , , or .\n\nThe offset of the local DST timezone, in seconds west of UTC, if one is defined. This is negative if the local DST timezone is east of UTC (as in Western Europe, including the UK). Only use this if is nonzero. See note below. Nonzero if a DST timezone is defined. See note below. The offset of the local (non-DST) timezone, in seconds west of UTC (negative in most of Western Europe, positive in the US, zero in the UK). See note below. A tuple of two strings: the first is the name of the local non-DST timezone, the second is the name of the local DST timezone. If no DST timezone is defined, the second string should not be used. See note below. For the above Timezone constants ( , , , and ), the value is determined by the timezone rules in effect at module load time or the last time is called and may be incorrect for times in the past. It is recommended to use the and results from to obtain timezone information. More object-oriented interface to dates and times. Internationalization services. The locale setting affects the interpretation of many format specifiers in and . General calendar-related functions. is the inverse of from this module."
    },
    {
        "link": "https://realpython.com/python-timer",
        "document": "A timer is a powerful tool for monitoring the performance of your Python code. By using the function, you can measure execution time with exceptional precision, making it ideal for benchmarking. Using a timer involves recording timestamps before and after a specific code block and calculating the time difference to determine how long your code took to run.\n\nIn this tutorial, you’ll explore three different approaches to implementing timers: classes, decorators, and context managers. Each method offers unique advantages, and you’ll learn when and how to use them to achieve optimal results. Plus, you’ll have a fully functional Python timer that can be applied to any program to measure execution time efficiently.\n\nBy the end of this tutorial, you’ll understand that:\n• is the best choice for accurate timing in Python due to its high resolution.\n• You can create custom timer classes to encapsulate timing logic and reuse it across multiple parts of your program.\n• Using decorators lets you seamlessly add timing functionality to existing functions without altering their code.\n• You can leverage context managers to neatly measure execution time in specific code blocks, improving both resource management and code clarity.\n\nAlong the way, you’ll gain deeper insights into how classes, decorators, and context managers work in Python. As you explore real-world examples, you’ll discover how these concepts can not only help you measure code performance but also enhance your overall Python programming skills.\n\nFirst, you’ll take a look at some example code that you’ll use throughout the tutorial. Later, you’ll add a Python timer to this code to monitor its performance. You’ll also learn some of the simplest ways to measure the running time of this example. If you check out the built-in module in Python, then you’ll notice several functions that can measure time: Python 3.7 introduced several new functions, like , as well as nanosecond versions of all the functions above, named with an suffix. For example, is the nanosecond version of . You’ll learn more about these functions later. For now, note what the documentation has to say about : Return the value (in fractional seconds) of a performance counter, i.e. a clock with the highest available resolution to measure a short duration. (Source) First, you’ll use to create a Python timer. Later, you’ll compare this with other Python timer functions and learn why is usually the best choice. To better compare the different ways that you can add a Python timer to your code, you’ll apply different Python timer functions to the same code example throughout this tutorial. If you already have code that you’d like to measure, then feel free to follow the examples with that instead. The example that you’ll use in this tutorial is a short function that uses the package to download the latest tutorials available here on Real Python. To learn more about the Real Python Reader and how it works, check out How to Publish an Open-Source Python Package to PyPI. You can install on your system with : Then, you can import the package as . You’ll store the example in a file named . The code consists of one function that downloads and prints the latest tutorial from Real Python: \"\"\"Download and print the latest tutorial from Real Python\"\"\" handles most of the hard work:\n• Line 1 imports from . This module contains functionality for downloading tutorials from the Real Python feed.\n• Line 5 downloads the latest tutorial from Real Python. The number is an offset, where means the most recent tutorial, is the previous tutorial, and so on.\n• Line 7 prints the tutorial to the console.\n• Line 9 calls when you run the script. When you run this example, your output will typically look something like this: python latest_tutorial.py Python Timer Functions: Three Ways to Monitor Your Code A timer is a powerful tool for monitoring the performance of your Python code. By using the `time.perf_counter()` function, you can measure execution time with exceptional precision, making it ideal for benchmarking. Using a timer involves recording timestamps before and after a specific code block and calculating the time difference to determine how long your code took to run. The code may take a little while to run depending on your network, so you might want to use a Python timer to monitor the performance of the script. Now you’ll add a bare-bones Python timer to the example with . Again, this is a performance counter that’s well-suited for timing parts of your code. measures the time in seconds from some unspecified moment in time, which means that the return value of a single call to the function isn’t useful. However, when you look at the difference between two calls to , you can figure out how many seconds passed between the two calls: In this example, you made two calls to almost 4 seconds apart. You can confirm this by calculating the difference between the two outputs: 32315.26 - 32311.49 = 3.77. You can now add a Python timer to the example code: Note that you call both before and after downloading the tutorial. You then print the time it took to download the tutorial by calculating the difference between the two calls. Note: In line 9, the before the string indicates that this is an f-string, which is a convenient way to format a text string. is a format specifier that says the number, , should be printed as a decimal number with four decimals. For more information about f-strings, check out Python’s F-String for String Interpolation and Formatting. Now, when you run the example, you’ll see the elapsed time before the tutorial: python latest_tutorial.py Python Timer Functions: Three Ways to Monitor Your Code That’s it! You’ve covered the basics of timing your own Python code. In the rest of the tutorial, you’ll learn how you can wrap a Python timer into a class, a context manager, and a decorator to make it more consistent and convenient to use.\n\nLook back at how you added the Python timer to the example above. Note that you need at least one variable ( ) to store the state of the Python timer before you download the tutorial. After studying the code a little, you might also note that the three highlighted lines are added only for timing purposes! Now, you’ll create a class that does the same as your manual calls to , but in a more readable and consistent manner. Throughout this tutorial, you’ll create and update , a class that you can use to time your code in several different ways. The final code with some additional features is also available on PyPI under the name . You can install this on your system like so: You can find more information about later on in this tutorial, in the section named The Python Timer Code. Classes are the main building blocks of object-oriented programming. A class is essentially a template that you can use to create objects. While Python doesn’t force you to program in an object-oriented manner, classes are everywhere in the language. For quick proof, investigate the module: returns the type of an object. Here you can see that modules are, in fact, objects created from a class. You can use the special attribute to get access to the class that defines an object. In fact, almost everything in Python is a class: In Python, classes are great when you need to model something that needs to keep track of a particular state. In general, a class is a collection of properties, called attributes, and behaviors, called methods. For more background on classes and object-oriented programming, check out Python Classes: The Power of Object-Oriented Programming, Object-Oriented Programming (OOP) in Python or the official documentation. Classes are good for tracking state. In a class, you want to keep track of when a timer starts and how much time has passed since then. For the first implementation of , you’ll add a attribute, as well as and methods. Add the following code to a file named : \"\"\"A custom exception used to report errors in use of Timer class\"\"\" \"Timer is running. Use .stop() to stop it\" \"\"\"Stop the timer, and report the elapsed time\"\"\" \"Timer is not running. Use .start() to start it\" A few different things are happening here, so take a moment to walk through the code step by step. In line 3, you define a class. The notation means that inherits from another class called . Python uses this built-in class for error handling. You don’t need to add any attributes or methods to , but having a custom error will give you more flexibility to handle problems inside . For more information, check out Python Exceptions: An Introduction. The definition of itself starts on line 6. When you first create or instantiate an object from a class, your code calls , one of Python’s special methods. In this first version of , you only initialize the attribute, which you’ll use to track the state of your Python timer. It has the value when the timer isn’t running. Once the timer is running, keeps track of when the timer started. Note: The underscore ( ) prefix of is a Python convention. It signals that is an internal attribute that users of the class shouldn’t manipulate. When you call to start a new Python timer, you first check that the timer isn’t already running. Then you store the current value of in . On the other hand, when you call , you first check that the Python timer is running. If it is, then you calculate the elapsed time as the difference between the current value of and the one that you stored in . Finally, you reset so that the timer can be restarted, and print the elapsed time. Here’s how you use : Compare this to the earlier example where you used directly. The structure of the code is fairly similar, but now the code is clearer, and this is one of the benefits of using classes. By carefully choosing your class, method, and attribute names, you can make your code very descriptive! Now apply to . You only need to make a few changes to your previous code: Notice that the code is very similar to what you used earlier. In addition to making the code more readable, takes care of printing the elapsed time to the console, which makes the logging of time spent more consistent. When you run the code, you’ll get pretty much the same output: python latest_tutorial.py Python Timer Functions: Three Ways to Monitor Your Code Printing the elapsed time from may be consistent, but it seems that this approach is not very flexible. In the next section, you’ll see how to customize your class. So far, you’ve learned that classes are suitable for when you want to encapsulate state and ensure consistent behavior in your code. In this section, you’ll add more convenience and flexibility to your Python timer:\n• Use adaptable text and formatting when reporting the time spent\n• Apply flexible logging, either to the screen, to a log file, or other parts of your program\n• Create a Python timer that can accumulate over several invocations First, see how you can customize the text used to report the time spent. In the previous code, the text is hard-coded into . You can add flexibility to classes using instance variables, whose values are normally passed as arguments to and stored as attributes. For convenience, you can also provide reasonable default values. To add as a instance variable, you’ll do something like this in : Note that the default text, , is given as a regular string, not as an f-string. You can’t use an f-string here because f-strings evaluate immediately, and when you instantiate , your code hasn’t yet calculated the elapsed time. Note: If you want to use an f-string to specify , then you need to use double curly braces to escape the curly braces that the actual elapsed time will replace. One example would be . If the value of is , then this f-string would be evaluated as . In , you use as a template and to populate the template: \"\"\"Stop the timer, and report the elapsed time\"\"\" \"Timer is not running. Use .start() to start it\" After this update to , you can change the text as follows: Next, assume that you don’t just want to print a message to the console. Maybe you want to save your time measurements so that you can store them in a database. You can do this by returning the value of from . Then, the calling code can choose to either ignore that return value or save it for later processing. Perhaps you want to integrate into your logging routines. To support logging or other outputs from , you need to change the call to so that the user can supply their own logging function. This can be done similarly to how you customized the text earlier: \"\"\"Stop the timer, and report the elapsed time\"\"\" \"Timer is not running. Use .start() to start it\" Instead of using directly, you create another instance variable in line 11, , that should refer to a function that takes a string as an argument. In addition to , you can use functions like or on file objects. Also note the test in line 23, which allows you to turn off printing completely by passing . Here are two examples that show the new functionality in action: When you run these examples in an interactive shell, Python prints the return value automatically. The third improvement that you’ll add is the ability to accumulate time measurements. You may want to do this, for example, when you’re calling a slow function in a loop. You’ll add a bit more functionality in the form of named timers with a dictionary that keeps track of every Python timer in your code. Assume that you’re expanding to a script that downloads and prints the ten latest tutorials from Real Python. The following is one possible implementation: The code loops over the numbers from 0 to 9 and uses those as offset arguments to . When you run the script, you’ll print a lot of information to your console: python latest_tutorials.py Python Timer Functions: Three Ways to Monitor Your Code [ ... The text of the tutorials ... ] One subtle issue with this code is that you’re measuring not only the time it takes to download the tutorials, but also the time Python spends printing the tutorials to your screen. This might not be that important because the time spent printing should be negligible compared to the time spent downloading. Still, it would be good to have a way to precisely time what you’re after in these kinds of situations. Note: The time spent downloading ten tutorials is about the same as the time spent downloading one tutorial. This isn’t a bug in your code! Instead, caches the Real Python feed the first time is called, and reuses the information on later invocations. There are several ways that you can work around this without changing the current implementation of However, supporting this use case will be quite useful, and you can do it with just a few lines of code. First, you’ll introduce a dictionary called as a class variable on , which means that all instances of will share it. You implement it by defining it outside any methods: Class variables can be accessed either directly on the class or through an instance of the class: In both cases, the code returns the same empty class dictionary. Next, you’ll add optional names to your Python timer. You can use the name for two different purposes:\n• Looking up the elapsed time later in your code\n• Accumulating timers with the same name To add names to your Python timer, you need to make two more changes to . First, should accept as a parameter. Second, the elapsed time should be added to when a timer stops: # Add new named timers to dictionary of timers \"\"\"Stop the timer, and report the elapsed time\"\"\" \"Timer is not running. Use .start() to start it\" Note that you use when adding the new Python timer to . This is a great feature that only sets the value if isn’t already defined in the dictionary. If is already used in , then the value is left untouched. This allows you to accumulate several timers: You can now revisit and make sure only the time spent on downloading the tutorials is measured: Rerunning the script will give output similar to earlier, although now you’re only timing the actual download of the tutorials: python latest_tutorials.py Python Timer Functions: Three Ways to Monitor Your Code [ ... The text of the tutorials ... ] The final improvement that you’ll make to is to make it more informative when you’re working with it interactively. Try the following: That last line is the default way that Python represents objects. While you can glean some information from it, it’s usually not very useful. Instead, it would be nice to see information like the name of , or how it’ll report on the timings. In Python 3.7, data classes were added to the standard library. These provide several conveniences to your classes, including a more informative representation string. You convert your Python timer to a data class using the decorator. You’ll learn more about decorators later in this tutorial. For now, you can think of this as a notation that tells Python that is a data class: # The rest of the code is unchanged This code replaces your earlier method. Note how data classes use syntax that looks similar to the class variable syntax that you saw earlier for defining all variables. In fact, is created automatically for data classes, based on annotated variables in the definition of the class. You need to annotate your variables to use a data class. You can use this annotation to add type hints to your code. If you don’t want to use type hints, then you can instead annotate all variables with , just like you did above. You’ll soon learn how to add actual type hints to your data class. Here are a few notes about the data class:\n• Line 9: The special annotation is necessary for data classes to specify that is a class variable.\n• Lines 10 to 12: , , and will be defined as attributes on , whose values can be specified when creating instances. They all have the given default values.\n• Line 13: Recall that is a special attribute that’s used to keep track of the state of the Python timer, but it should be hidden from the user. Using , you say that should be removed from and the representation of .\n• Lines 15 to 18: You can use the special method for any initialization that you need to do apart from setting the instance attributes. Here, you use it to add named timers to . Your new data class works just like your previous regular class, except that it now has a nice representation: Now you have a pretty neat version of that’s consistent, flexible, convenient, and informative! You can apply many of the improvements that you’ve made in this section to other types of classes in your projects as well. Before ending this section, revisit the complete source code of as it currently stands. You’ll notice the addition of type hints to the code for extra documentation: \"\"\"A custom exception used to report errors in use of Timer class\"\"\" \"\"\"Add timer to dict of timers after initialization\"\"\" \"Timer is running. Use .stop() to stop it\" \"\"\"Stop the timer, and report the elapsed time\"\"\" \"Timer is not running. Use .start() to start it\" Using a class to create a Python timer has several benefits:\n• Readability: Your code will read more naturally if you carefully choose class and method names.\n• Consistency: Your code will be easier to use if you encapsulate properties and behaviors into attributes and methods.\n• Flexibility: Your code will be reusable if you use attributes with default values instead of hard-coded values. This class is very flexible, and you can use it in almost any situation where you want to monitor the time it takes for code to run. However, in the next sections, you’ll learn about using context managers and decorators, which will be more convenient for timing code blocks and functions.\n\nYour Python class has come a long way! Compared with the first Python timer you created, your code has gotten quite powerful. However, there’s still a bit of boilerplate code necessary to use your :\n• Call before the code block that you want to time. Luckily, Python has a unique construct for calling functions before and after a block of code: the context manager. In this section, you’ll learn what context managers and Python’s statement are, and how you can create your own. Then you’ll expand so that it can work as a context manager as well. Finally, you’ll see how using as a context manager can simplify your code. Context managers have been a part of Python for a long time. They were introduced by PEP 343 in 2005, and first implemented in Python 2.5. You can recognize context managers in code by the use of the keyword: is some Python expression that returns a context manager. The context manager is optionally bound to the name . Finally, is any regular Python code block. The context manager will guarantee that your program calls some code before and some other code after executes. The latter will happen, even if raises an exception. The most common use of context managers is probably handling different resources, like files, locks, and database connections. The context manager is then used to free and clean up the resource after you’ve used it. The following example reveals the fundamental structure of by only printing lines that contain a colon. More importantly, it shows the common idiom for opening a file in Python: if self.name is not None: if self._start_time is not None: if self._start_time is None: Note that , the file pointer, is never explicitly closed because you used as a context manager. You can confirm that has closed automatically: In this example, is an expression that returns a context manager. That context manager is bound to the name . The context manager is in effect during the execution of . This one-line code block executes in the context of . What does it mean that is a context manager? Technically, it means that implements the context manager protocol. There are many different protocols underlying the Python language. You can think of a protocol as a contract that states what specific methods your code must implement. The context manager protocol consists of two methods:\n• Call when entering the context related to the context manager.\n• Call when exiting the context related to the context manager. In other words, to create a context manager yourself, you need to write a class that implements and . No more, no less. Try a Hello, World! context manager example: is a context manager because it implements the context manager protocol. You can use it like this: First, note how is called before you’re doing stuff, while is called after. In this simplified example, you’re not referencing the context manager. In such cases, you don’t need to give the context manager a name with . Next, notice how returns . The return value of is bound by . You usually want to return from when creating context managers. You can use that return value as follows: Finally, takes three arguments: , , and . These are used for error handling within the context manager, and they mirror the return values of . If an exception happens while the block is being executed, then your code calls with the type of the exception, an exception instance, and a traceback object. Often, you can ignore these in your context manager, in which case is called before the exception is reraised: You can see that \"See you later, Rascal\" is printed, even though there is an error in the code. Now you know what context managers are and how you can create your own. If you want to dive deeper, then check out in the standard library. It includes convenient ways for defining new context managers, as well as ready-made context managers that you can use to close objects, suppress errors, or even do nothing! For even more information, check out Context Managers and Python’s Statement. You’ve seen how context managers work in general, but how can they help with timing code? If you can run certain functions before and after a block of code, then you can simplify how your Python timer works. So far, you’ve needed to call and explicitly when timing your code, but a context manager can do this automatically. Again, for to work as a context manager, it needs to adhere to the context manager protocol. In other words, it must implement and to start and stop the Python timer. All the necessary functionality is already available, so there’s not much new code you need to write. Just add the following methods to your class: # The rest of the code is unchanged is now a context manager. The important part of the implementation is that calls to start a Python timer when the context is entered, and uses to stop the Python timer when the code leaves the context. Try it out: You should also note two more subtle details:\n• returns , the instance, which allows the user to bind the instance to a variable using . For example, will create the variable pointing to the object.\n• expects three arguments with information about any exception that occurred during the execution of the context. In your code, these arguments are packed into a tuple called and then ignored, which means that won’t attempt any exception handling. doesn’t do any error handling in this case. Still, one of the great features of context managers is that they’re guaranteed to call , no matter how the context exits. In the following example, you purposely create an error by dividing by zero: Note that prints out the elapsed time, even though the code crashed. It’s possible to inspect and suppress errors in . See the documentation for more information. Now you’ll learn how to use the context manager to time the download of Real Python tutorials. Recall how you used earlier: You’re timing the call to . You can use the context manager to make the code shorter, simpler, and more readable: This code does virtually the same as the code above. The main difference is that you don’t define the extraneous variable , which keeps your namespace cleaner. python latest_tutorial.py Python Timer Functions: Three Ways to Monitor Your Code There are a few advantages to adding context manager capabilities to your Python timer class:\n• Low effort: You only need one extra line of code to time the execution of a block of code.\n• Readability: Invoking the context manager is readable, and you can more clearly visualize the code block that you’re timing. Using as a context manager is almost as flexible as using and directly, while it has less boilerplate code. In the next section, you’ll learn how you can use as a decorator as well. This will make it easier to monitor the runtime of complete functions.\n\nYour class is now very versatile. However, there’s one use case where you could streamline it even further. Say that you want to track the time spent inside one given function in your codebase. Using a context manager, you have essentially two different options:\n• Use every time you call the function: If you call in many places, then this will become cumbersome and hard to maintain.\n• Wrap the code in your function inside a context manager: The only needs to be added in one place, but this adds a level of indentation to the whole definition of . A better solution is to use as a decorator. Decorators are powerful constructs that you use to modify the behavior of functions and classes. In this section, you’ll learn a little about how decorators work, how you can extend to be a decorator, and how that will simplify timing functions. For a more in-depth explanation of decorators, see Primer on Python Decorators. A decorator is a function that wraps another function to modify its behavior. This technique is possible because functions are first-class objects in Python. In other words, functions can be assigned to variables and used as arguments to other functions, just like any other object. This gives you a lot of flexibility and is the basis for several of Python’s most powerful features. As a first example, you’ll create a decorator that does nothing: First, note that is just a regular function. What makes this a decorator is that it takes a function as its only argument and returns a function. You can use to modify other functions, like this: The line decorates the print statement with the decorator. Effectively, it replaces with returned by . The lambda statement represents an anonymous function that does nothing except return . To define more interesting decorators, you need to know about inner functions. An inner function is a function that’s defined inside another function. One common use of inner functions is to create function factories: is an inner function, defined inside . Note that you have access to inside , while isn’t defined outside : File , line , in : name 'multiplier' is not defined Instead you use to create new multiplier functions, each based on a different factor: Similarly, you can use inner functions to create decorators. Remember, a decorator is a function that returns a function: is a decorator, because it’s a function that expects a function, , as its only argument and returns another function, . Note the structure of itself:\n• Line 1 starts the definition of and expects a function as an argument.\n• Lines 2 to 5 define the inner function . This pattern is prevalent for defining decorators. The interesting parts are those happening inside the inner function:\n• Line 2 starts the definition of . This function will replace whichever function decorates. The parameters are and , which collect whichever positional and keyword arguments you pass to the function. This gives you the flexibility to use on any function.\n• Line 3 prints out the name of the decorated function and notes that has been applied to it.\n• Line 4 calls , the function that has decorated. It passes on all arguments passed to .\n• Line 5 triples the return value of and returns it. Try it out! is a function that returns the word . See what happens if it’s tripled: Multiplying a text string by a number is a form of repetition, so repeats three times. The decoration happens at . It feels a bit clunky to keep repeating . Instead, PEP 318 introduced a more convenient syntax for applying decorators. The following definition of does the same as the one above: The symbol is used to apply decorators. In this case, means that is applied to the function defined just after it. One of the few decorators defined in the standard library is . This one is quite helpful when defining your own decorators. Because decorators effectively replace one function with another, they create a subtle issue with your functions: decorates , which is then replaced by the inner function, as the output above confirms. This will also replace the name, docstring, and other metadata. Often, this won’t have much effect, but it can make introspection difficult. Sometimes, decorated functions must have correct metadata. fixes exactly this issue: With this new definition of , metadata is preserved: Note that now keeps its proper name, even after being decorated. It’s good form to use whenever you define a decorator. A blueprint that you can use for most of your decorators is the following: To see more examples of how to define decorators, check out the examples listed in Primer on Python Decorators. In this section, you’ll learn how to extend your Python timer so that you can use it as a decorator as well. However, as a first exercise, you’ll create a Python timer decorator from scratch. Based on the blueprint above, you only need to decide what to do before and after you call the decorated function. This is similar to the considerations about what to do when entering and exiting the context manager. You want to start a Python timer before calling the decorated function, and stop the Python timer after the call finishes. You can define a decorator as follows: Note how much resembles the earlier pattern that you established for timing Python code. You can apply as follows: # Python Timer Functions: Three Ways to Monitor Your Code Recall that you can also apply a decorator to a previously defined function: Because applies when functions are defined, you need to use the more basic form in these cases. One advantage of using a decorator is that you only need to apply it once, and it’ll time the function every time: does the job. However, in a sense, you’re back to square one, since doesn’t have any of the flexibility or convenience of . Can you also make your class act like a decorator? So far, you’ve used decorators as functions applied to other functions, but that’s not entirely correct. Decorators must be callables. There are many callable types in Python. You can make your own objects callable by defining the special method in their class. The following function and class behave similarly: Here, is an instance that is callable and can square numbers, just like the function in the first example. This gives you a way of adding decorator capabilities to the existing class: # The rest of the code is unchanged uses the fact that is already a context manager to take advantage of the conveniences that you’ve already defined there. Make sure you also import at the top of . You can now use as a decorator: # Python Timer Functions: Three Ways to Monitor Your Code Before rounding out this section, know that there’s a more straightforward way of turning your Python timer into a decorator. You’ve already seen some of the similarities between context managers and decorators. They’re both typically used to do something before and after executing some given code. Based on these similarities, there’s a mixin class defined in the standard library called . You can add decorator abilities to your context manager classes simply by inheriting : When you use this way, there’s no need to implement yourself, so you can safely delete it from the class. Next up, you’ll redo the example one last time, using the Python timer as a decorator: If you compare this implementation with the original implementation without any timing, then you’ll notice that the only differences are the import of on line 1 and the application of on line 4. A significant advantage of using decorators is that they’re usually straightforward to apply, as you see here. However, the decorator still applies to the whole function. This means that your code is taking into account the time it takes to print the tutorial, in addition to the time it takes to download. Run the script one final time: python latest_tutorial.py Python Timer Functions: Three Ways to Monitor Your Code The location of the elapsed time output is a telltale sign that your code is considering the time it takes to print as well. As you see here, your code prints the elapsed time after the tutorial. When you use as a decorator, you’ll see similar advantages as you did with context managers:\n• Low effort: You only need one extra line of code to time the execution of a function.\n• Readability: When you add the decorator, you can note more clearly that your code will time the function.\n• Consistency: You only need to add the decorator when the function is defined. Your code will consistently time it every time it’s called. However, decorators are not as flexible as context managers. You can only apply them to complete functions. It’s possible to add decorators to already defined functions, but this is a bit clunky and less common.\n\nThere are many options for timing your code with Python. In this tutorial, you’ve learned how to create a flexible and convenient class that you can use in several different ways. A quick search on PyPI shows that there are already many projects available that offer Python timer solutions. In this section, you’ll first learn more about the different functions available in the standard library for measuring time, including why is preferable. Then, you’ll explore alternatives for optimizing your code, for which is not well-suited. You’ve been using throughout this tutorial to do the actual time measurements, but Python’s library comes with several other functions that also measure time. Here are some alternatives: One reason for having several functions is that Python represents time as a . Floating-point numbers are inaccurate by nature. You may have seen results like these before: Python’s follows the IEEE 754 Standard for Floating-Point Arithmetic, which tries to represent all floating-point numbers in 64 bits. Because there are infinitely many floating-point numbers, you can’t express them all with a finite number of bits. IEEE 754 prescribes a system where the density of numbers that you can represent varies. The closer you are to one, the more numbers you can represent. For larger numbers, there’s more space between the numbers that you can express. This has some consequences when you use a to represent time. Consider . The main purpose of this function is to represent the actual time right now. It does this as the number of seconds since a given point in time, called the epoch. The number returned by is quite big, which means that there are fewer numbers available, and the resolution suffers. Specifically, is not able to measure nanosecond differences: A nanosecond is one-billionth of a second. Note that adding a nanosecond to doesn’t affect the result. , on the other hand, uses some undefined point in time as its epoch, allowing it to work with smaller numbers and therefore obtain a better resolution: Here, you notice that adding a nanosecond to actually affects the outcome. For more information about how to work with , see A Beginner’s Guide to the Python time Module. The challenges with representing time as a are well known, so Python 3.7 introduced a new option. Each measurement function now has a corresponding function that returns the number of nanoseconds as an instead of the number of seconds as a . For instance, now has a nanosecond counterpart called : Integers are unbounded in Python, so this allows to give nanosecond resolution for all eternity. Similarly, is a nanosecond variant of : Because already provides nanosecond resolution, there are fewer advantages to using . Note: is only available in Python 3.7 and later. In this tutorial, you’ve used in your class. That way, you can use on older Python versions as well. For more information about the functions in , check out Cool New Features in Python 3.7. There are two functions in that do not measure the time spent sleeping. These are and , which are useful in some settings. However, for , you typically want to measure the full time spent. The final function in the list above is . The name alludes to this function being a monotonic timer, which is a Python timer that can never move backward. All these functions are monotonic except , which can go backward if the system time is adjusted. On some systems, is the same function as , and you can use them interchangeably. However, this is not always the case. You can use to get more information about a Python timer function: The results could be different on your system. PEP 418 describes some of the rationale behind introducing these functions. It includes the following short descriptions:\n• : timeout and scheduling, not affected by system clock updates As you can tell, is usually the best choice for your Python timer. Say you’re trying to squeeze the last bit of performance out of your code, and you’re wondering about the most effective way to convert a list to a set. You want to compare using and the set literal, . You can use your Python timer for this: This test seems to indicate that the set literal might be slightly faster. However, these results are quite uncertain, and if you rerun the code, you might get wildly different results. That’s because you’re only trying the code once. You could, for instance, get unlucky and run the script just as your computer is becoming busy with other tasks. A better way is to use the standard library. It’s designed precisely to measure the execution time of small code snippets. While you can import and call from Python as a regular function, it’s usually more convenient to use the command-line interface. You can time the two variants as follows: python -m timeit --setup 2000000 loops, best of 5: 163 nsec per loop python -m timeit --setup 2000000 loops, best of 5: 121 nsec per loop automatically calls your code many times to average out noisy measurements. The results from confirm that the set literal is faster than . Note: Be careful when you’re using on code that can download files or access databases. Since automatically calls your program several times, you could unintentionally end up spamming the server with requests! Finally, the IPython interactive shell and the Jupyter Notebook have extra support for this functionality with the magic command: set(numbers) 171 ns ± 0.748 ns per loop (mean ± std. dev. of 7 runs, 10000000 loops each) {*numbers} 147 ns ± 2.62 ns per loop (mean ± std. dev. of 7 runs, 10000000 loops each) Again, the measurements indicate that using a set literal is faster. In Jupyter Notebooks, you can also use the cell-magic to measure the time of running a whole cell. Finding Bottlenecks in Your Code With Profilers is excellent for benchmarking a particular snippet of code. However, it would be very cumbersome to use it to check all parts of your program and locate which sections take the most time. Instead, you can use a profiler. is a profiler that you can access at any time from the standard library. You can use it in several ways, although it’s usually most straightforward to use it as a command-line tool: This command runs with profiling turned on. You save the output from in , as specified by the option. The output data is in a binary format that needs a dedicated program to make sense of it. Again, Python has an option right in the standard library! Running the module on your file opens an interactive profile statistics browser: python -m pstats latest_tutorial.prof Welcome to the profile statistics browser. To use , you type commands at the prompt. Here you can see the integrated help system. Typically you’ll use the and commands. To get a cleaner output, can be useful: List reduced from 1443 to 10 due to restriction <10> This output shows that the total runtime was 0.586 seconds. It also lists the ten functions where your code spent most of its time. Here you’ve sorted by cumulative time ( ), which means that your code counts time when the given function has called another function. You can see that your code spends virtually all its time inside the module, and in particular, inside . While this might be useful confirmation of what you already know, it’s often more interesting to find where your code actually spends time. The total time ( ) column indicates how much time your code spent inside a function, excluding time in sub-functions. You can see that none of the functions above really spend any time doing this. To find where the code spent most of its time, issue another command: List reduced from 1443 to 10 due to restriction <10> You can now see that actually spends most of its time working with sockets or handling data inside . The latter is one of the dependencies of the Real Python Reader that’s used to parse the tutorial feed. You can use to get some idea of where your code is spending most of its time and then try to optimize any bottlenecks you find. You can also use the tool to understand the structure of your code better. For instance, the commands and will show you which functions call and are called by a given function. You can also investigate certain functions. Check how much overhead causes by filtering the results with the phrase : List reduced from 1443 to 8 due to restriction <'timer'> Luckily, causes only minimal overhead. Use to leave the browser when you’re done investigating. For a more powerful interface into profile data, check out KCacheGrind. It uses its own data format, but you can convert data from using : This command will convert and open KCacheGrind to analyze the data. The last option that you’ll try here for timing your code is . can tell you which functions your code spends the most time in, but it won’t give you insights into which lines inside that function are the slowest. That’s where can help you. Note: You can also profile the memory consumption of your code. This falls outside the scope of this tutorial. However, you can check out if you need to monitor the memory consumption of your programs. If you’d like to learn more about profiling, then Profiling in Python: How to Find Performance Bottlenecks is here to help. Note that line profiling takes time and adds a fair bit of overhead to your runtime. A normal workflow is first to use to identify which functions to investigate and then run on those functions. isn’t part of the standard library, so you should first follow the installation instructions to set it up. Before you run the profiler, you need to tell it which functions to profile. You do this by adding a decorator inside your source code. For example, to profile , you add the following inside : # The rest of the code is unchanged Note that you don’t import anywhere. Instead, it’s automatically added to the global namespace when you run the profiler. You need to delete the line when you’re done profiling, though. Otherwise, you’ll get a . Next, run the profiler using , which is part of the package: This command automatically saves the profiler data in a file called . You can see those results using : python -m line_profiler latest_tutorial.py.lprof Hits Time PrHit %Time Line Contents 37 \"\"\"Stop the timer, and report the elapsed time\"\"\" 38 1 1.0 1.0 6.2 if self._start_time is None: First, note that the time unit in this report is microseconds ( ). Usually, the most accessible number to look at is , which tells you the percentage of the total time your code spends inside a function at each line. In this example, you can see that your code spends almost 70 percent of the time on line 47, which is the line that formats and prints the result of the timer."
    },
    {
        "link": "https://influxdata.com/blog/python-time-module-how-to-guide",
        "document": "This post was written by Keshav Malik. Scroll down for the author’s bio.\n\nThe Python time module is a powerful tool for working with times and dates in both simple and complex ways, allowing you to easily manipulate dates, format strings, calculate durations, and more.\n\nYou can make your programming tasks much easier if you know how to use the time module effectively. In this guide, we’ll show you how to use it and provide examples of everyday tasks so that you can apply them to your own projects. Let’s get started!\n\nGetting started with the time module\n\nThe time module in Python provides various time-related methods that developers can use. You don’t have to install it externally as it’s part of the Python module (similar to other modules, such as os).\n\nThe time module provides a range of functions that allow users to perform tasks such as formatting strings, calculating durations, dealing with time zones, and more.\n\nTime and date are fundamental elements of programming in Python. By leveraging the range of available tools, developers can use time and date manipulation for various applications. Here are a few practical examples:\n• Scheduling tasks: With the aid of calendar libraries, developers can build applications that schedule tasks based on specific dates and times, such as alerts or event reminders. For instance, an app could remind users to complete certain activities before a particular date or send out emails at predetermined intervals.\n• Bank transactions: Developers can use Python’s time module to ensure accuracy when dealing with financial transactions, such as tracking payments and deposits. This is obviously important for any applications that deal with banking and finance.\n• User input validation: When accepting user input in the form of dates and times, developers typically use the POSIX timestamp representation so that it can be validated quickly and easily using functions like ‘strftime()’ in Python to check if a given value is valid or not.\n• Logging data: Storing timestamps with logging data is also standard practice when developing programs. It helps track activity throughout the system more effectively by providing valuable context as to what happened at particular times. This data can then be used to find patterns in user behavior, identify errors faster, and even implement predictive analytics to forecast outcomes based on past trends.\n• Game development: Many games require accurate representations of time values for various aspects, such as respawn timers, loading animations, and map rotations. All these elements are usually coded using timestamps for precision to run smoothly in real-time scenarios. Likewise, simple timing mechanisms like countdown clocks are often necessary during gameplay to add tension and create more dynamic gaming experiences without manually resetting timers every time the game restarts due to server issues or other complications.\n\nTime values in Python are typically represented as the number of seconds that have elapsed since the Unix epoch, which is a date and time reference point that starts on January 1, 1970 (00:00:00 UTC).\n\nThese timestamps represent the global standard for tracking time in computer systems. Through this system, any given moment can be represented using a simple integer value, making it easy to compare different points in time.\n\nUsing the time() method, developers can fetch the current time in seconds since the epoch.\n\nDevelopers can also create a more user-friendly date and time using the strftime time function. We will discuss this function in a later section.\n\nGetting the current day (of the week) using the time module\n\nYou can also find out what day of the week it is using the time module, but it’s a little complicated.\n\nAn optimal way is to use the datetime module.\n\nThe time module in Python provides several functions to format time values into strings. The most commonly used function is strftime(), which stands for “string format time”.\n\nThe strftime function allows developers to convert timestamps into different formats for easy storage and display. This function takes two parameters, the format string and the timestamp value (in UTC/GMT time) that you wish to convert.\n\nHere’s what these symbols (%Y, %m, etc.) mean:\n• %Y: Year with the century as a decimal number (e.g., 2023)\n• %d: Day of the month as a zero-padded decimal number (e.g., 18)\n• %H: Hour (24-hour clock) as a zero-padded decimal number (e.g., 08 for 8:00 a.m.)\n\nUntil now, we’ve only covered working with, creating, and formatting strings in your own program, but in some cases you’ll get time data from external sources. For example, you might use an integrated API that sends you weather data each minute. The API response might contain timestamps. If so, you have to parse the timestamp before you can use it in your application. The time module provides strptime() function, which can parse date/time strings into a time tuple.\n\nHere’s a code snippet that shows how this function works.\n\nThe code above prints a time tuple that contains the individual components of the date and time, such as the year, month, day, hour, minute, and second. You can use this data to perform various operations, such as date/time arithmetic and comparisons.\n\nMeasuring time intervals in Python involves calculating the difference between two given points in time. This is important when you’re creating scheduling apps, tracking user behavior, and analyzing performance data. To measure the time interval between two specific points in time, the time module provides a set of functions and modules that you can use together to achieve this result.\n\nIf you need a more accurate result, you can always use the perf_counter() function. This returns a floating-point value representing the time (in seconds) with greater precision than time() on most systems. Here’s an example:\n\nComparing time values in Python can be tricky as there is no universal standard for defining and storing time values. Let’s look at how you can compare time values in Python.\n\nComparing time values as seconds (since the beginning of the epoch):\n\nThe Python time module is an invaluable resource for any developer who’s working with date and time data. This tutorial covered the various functions available in the module and showed you how to use it. With this knowledge at your disposal, you’ll have the tools to build powerful applications related to dates and times. Whether you need to measure elapsed time or perform calculations on dates, the Python time module will help make these tasks much more accessible.\n\nThis post was written by Keshav Malik, a highly skilled and enthusiastic Security Engineer. Keshav has a passion for automation, hacking, and exploring different tools and technologies. With a love for finding innovative solutions to complex problems, Keshav is constantly seeking new opportunities to grow and improve as a professional. He is dedicated to staying ahead of the curve and is always on the lookout for the latest and greatest tools and technologies."
    },
    {
        "link": "https://builtin.com/articles/timing-functions-python",
        "document": "Have you ever wondered how long it takes for your Python code to run? Or have you wanted to compare the performance of different approaches to solving a problem?\n\nIf so, you’ll need to know how to time your Python functions.\n\nYou can time Python functions using the time module, the module and profiling tools.\n\nBy the end of this guide, you’ll have a good understanding of how to measure the elapsed time of your Python code, and you’ll be able to use the appropriate method for your specific needs.\n\nThere are four common methods to time a function in Python, including: , , and or . Let’s look at each one.\n\nThe function is a high-resolution timing function that uses the processor’s performance counter to measure time.\n\nIt’s suitable for measuring the time taken by a function and the time taken by small code blocks or individual statements.\n\nTo use this function, you can call before and after the code you want to time, subtracting the start time from the end time to get the elapsed time.\n\nOne advantage of is that it’s based on a monotonic clock, which always increments and never goes backward. This makes it more suitable for measuring the elapsed time of a process or event.\n\nThe function returns the current time in seconds since the epoch. The epoch is a predefined point in time, usually the beginning of the year 1970.\n\nIt’s not as precise as , but it can be useful for timing longer-running functions or scripts.\n\nOne potential disadvantage of is that it’s based on the system clock, which can be adjusted by the user or the system administrator, so the clock can go backward if the system time is changed.\n\nThe module provides a simple way to time the execution of small bits of Python code.\n\nIt can be used to time a single function by wrapping it in a object and calling the method.\n\nOne advantage of the module is that it allows you to specify the number of times the function should be run, which can help return more accurate timing results.\n\nIf you want to get more detailed information about the performance of your code, you can use a profiling tool such as or .\n\nThese tools can provide detailed statistics about the time taken by different parts of your code, the number of function calls and the amount of memory used.\n\nProfiling tools can be particularly useful for identifying bottlenecks in your code and optimizing the performance of your application.\n\nThere are still many other ways to time functions, using , , time. , etc, but we’ll focus on the above four for now.\n\nTiming Functions in Python With Example Code\n\nLet’s test the methods on the following function.\n\nBased on the output, tells us the function was called 21,891 times, the total time spent was 0.005, and the average time spent per call was 0.000 seconds.\n\nNow that you’ve seen the code samples, you’re probably wondering which method should you use?\n\nBest Method to Time a Function in Python\n\nWhen you’re deciding which method to use to time a function in Python, it’s important to consider the code and what you want to measure. Let’s take a look at when to use each of the methods.\n\nLet’s reiterate the differences between perf_counter() and time().\n• None uses the processor’s performance counter to measure time, while uses the system clock. In general, is more precise and has a higher resolution than , so it’s often the better choice for timing small code blocks or individual statements.\n• None is based on a monotonic clock, which means that it always increments and never goes backward. This makes it more suitable for measuring the elapsed time of a process or event. On the other hand, is based on the system clock, which can be adjusted by the user or the system administrator. So, the clock can go back if the system time is changed.\n\nIf you want to measure the elapsed time of a process or event and you need high precision and a monotonic clock, is the best choice.\n\nOn the other hand, if you need to measure the elapsed time of a longer-running script or function, and precision is not as important, may be sufficient.\n\nUse Timeit for Small Bits of Code\n\nYou might use the module when you want to quickly and easily time the execution of small bits of Python code. It’s particularly useful when you want to compare the performance of different approaches to solving a problem or when you want to optimize a specific piece of code.\n\nYou might use profiling tools when you want to get a detailed understanding of the performance of your code. Profiling tools can provide information about the time taken by different parts of your code, the number of function calls and the amount of memory used. This can help identify bottlenecks and optimize your code.\n\nFor example, suppose you have a large Python script that is running slowly, and you want to find out which parts of the code are taking the most time.\n\nThe output of will show you a breakdown of the time taken by each function in your script, as well as the number of times each function was called. You can use this information to identify which functions take the most time and focus your optimization efforts on those functions.\n\nMore on Python4 Ways to Insert a Python Variable in a String\n\nTo quickly time functions that you write, you can write a decorator that uses the function.\n\nThen for any function you define, you just have to include the and it will show how long it took to run that function.\n\nBelow, the decorator is defined, and is added to the function.\n\nThe function approximates the value of pi using the Monte Carlo method. It generates random points in a unit square and counts the number of points that fall inside the unit circle inscribed within the square. The value of pi is then calculated as the ratio of the number of points inside the circle to the total number of points, multiplied by four.\n\nAt the bottom, when we call , it shows us it took 0.7 seconds to run.\n\nTiming Python functions is a useful skill to have in your toolkit as a developer.\n\nWhether you’re optimizing code for performance or simply want to understand how long it takes for your code to run, several different methods are available to help you measure the elapsed time of your Python functions.\n\nWe’ve covered four of the most common methods in this guide: using the module, the module and profiling tools. Now, it’s your turn to put this knowledge into practice.\n\nTry timing some Python functions using the different methods we’ve discussed, and see how they compare."
    },
    {
        "link": "https://ioflood.com/blog/python-time",
        "document": "Are you finding it challenging to manage time in your Python scripts? You’re not alone. Many developers grapple with this task, but Python, like a precision watchmaker, offers powerful tools for handling time.\n\nWhether you’re scheduling tasks, timestamping events, or optimizing performance, understanding how to work with time in Python can significantly streamline your coding process.\n\nThis guide will walk you through Python’s time module, from basic usage to advanced techniques. We’ll cover everything from getting the current time, converting time to different formats, pausing script execution, to more complex uses such as measuring script execution time and working with time tuples.\n\nTL;DR: How Do I Work with Time in Python?\n\nHere’s a simple example of getting the current time:\n\nIn this example, we import the Python time module and use the function to get the current time. This function returns the current time in seconds since the epoch (January 1, 1970, 00:00:00 (UTC)). The output will vary depending on when you run the code.\n\nPython’s time module is a versatile tool with a range of functionalities. Let’s start with the basics, perfect for beginners and a good refresher for the more experienced.\n\nThe most basic use of the time module is getting the current time. Here’s how you can do it:\n\nIn this example, returns the current time in seconds since the epoch (January 1, 1970, 00:00:00 (UTC)). The output will vary depending on when you run the code.\n\nPython’s time module allows you to convert time into different formats using the function. Here’s an example:\n\nIn the above code, function takes two arguments: format and the time value. We used to convert the time in seconds since the epoch to local time. The output is the current local time formatted as ‘YYYY-MM-DD HH:MM:SS’.\n\nSometimes, you might want to pause or delay the execution of your Python script for a certain period. The function allows you to do this. Here’s an example:\n\nIn this example, pauses the script for 5 seconds. The ‘Start’ and ‘End’ messages are printed with a 5-second delay.\n\nThese are some of the basic uses of the Python time module. As you gain more experience, you’ll find that Python provides even more tools for advanced time handling. Stay tuned for the next section where we’ll delve into more complex uses!\n\nOnce you’ve mastered the basics of Python’s time module, you can start exploring its more advanced functionalities. Let’s delve into these now.\n\nPython’s time module can be used to measure the execution time of your script, which can be incredibly useful for optimizing your code. Here’s how to do it:\n\nIn this example, we record the time before and after the execution of a complex function and then subtract the start time from the end time to get the execution time.\n\nPython’s time module can also be used for benchmarking – comparing the performance of different pieces of code to determine which is more efficient. Here’s a simple example:\n\nIn this example, we measure the execution time of two functions and compare them. This way, you can determine which function is more efficient.\n\nPython’s time module represents time in tuples as well. These tuples are handy when you want to display time in a more human-readable format or when you want to extract specific details like year, month, day, hour, minute, etc. Here’s how to use it:\n\nIn this example, converts the time in seconds since the epoch to a time tuple in local time. You can then access specific attributes of the time tuple, such as the year and month.\n\nThese are just a few examples of the advanced uses of Python’s time module. With these tools in your arsenal, you’ll be well-equipped to handle a variety of time-related tasks in your Python projects.\n\nWhile Python’s time module is powerful and versatile, it’s not the only tool in Python’s arsenal for handling time. An alternative that offers even more functionality is the datetime module.\n\nThe datetime module in Python is used for manipulating dates and times. It offers classes for manipulating dates and times in both simple and complex ways.\n\nHere’s a simple example of getting the current date and time using the datetime module:\n\nIn this example, returns the current date and time. The output will vary depending on when you run the code.\n\nDifferences and Advantages of Using Datetime Over Time\n\nWhile both time and datetime modules can be used to handle time in Python, they have some key differences. The time module is best for dealing with time in terms of ticks (seconds since the epoch), while the datetime module is more high-level and provides more functionality.\n\nHere’s a comparison table highlighting the differences and advantages of using datetime over time:\n\nAs you can see, the datetime module provides all the functionality of the time module, plus additional features like working with date objects and calculating differences between dates. Therefore, depending on your needs, you might find the datetime module a more powerful and convenient tool for handling time in your Python scripts.\n\nEven with Python’s robust time and datetime modules, you may encounter some common issues. Let’s discuss these and their solutions.\n\nPython’s time module does not handle timezones by default. However, the datetime module provides a tzinfo class that can be used to work with timezones. Here’s how you can get the current time in a specific timezone:\n\nIn this example, we use the pytz library, which allows accurate and cross-platform timezone calculations. We get the current datetime in the ‘US/Eastern’ timezone.\n\nDaylight Saving Time (DST) can also pose challenges when working with time in Python. However, the pytz library can help handle DST transitions. Here’s how:\n\nIn this example, we’re trying to get the time for a date during the DST transition. Pytz automatically adjusts the time to account for the DST transition.\n\nLeap seconds can be another source of confusion when working with time in Python. Python’s time module does not account for leap seconds, meaning that there can be a discrepancy of up to a minute when comparing times across years. If precise time calculation is necessary for your application, consider using a library that accounts for leap seconds, such as astropy.\n\nWorking with time in Python can be tricky, but with these solutions and best practices, you can navigate common issues and handle time effectively in your Python scripts.\n\nTo fully grasp the functionality of Python’s time module, it’s essential to understand how time is represented in computers.\n\nThe Concept of Unix Time or Epoch Time\n\nUnix time, also known as Epoch time, is a system for tracking time that defines the time as the number of seconds that have passed since 00:00:00 Coordinated Universal Time (UTC), Thursday, 1 January 1970, minus the number of leap seconds.\n\nHere’s an example of getting the current Unix time in Python:\n\nIn this example, returns the current Unix time, or the number of seconds since the epoch. The output will vary depending on when you run the code.\n\nPython’s time module provides various time-related functions. It interfaces directly with the system’s time-related functions, providing you with a simple way to query and manipulate the system time.\n\nThe time module provides functions to get the current time ( ), convert time to different formats ( ), pause script execution ( ), and much more. It also provides a struct_time class for manipulating time in a more object-oriented way.\n\nUnderstanding these fundamentals of how time is represented in computers and how Python’s time module works under the hood will equip you with the knowledge you need to effectively handle time in your Python scripts.\n\nUnderstanding Python’s time module is not just about learning the syntax or getting your code to run without errors. It’s about knowing how to use these tools in real-world applications. Let’s explore a few of these applications now.\n\nOne common use of the time module in Python is scheduling tasks. This could be anything from running a function at a specific time every day to executing a script every few seconds.\n\nIn this example, we’re running a task every day. We use to pause the script for a day (86400 seconds).\n\nAnother common use is timestamping events. This could be useful for logging events, debugging, or any situation where you need to know when something happened.\n\nIn this example, we print a timestamp (the current Unix time) when an event occurs.\n\nPython’s time module can also be used for performance optimization. By measuring the execution time of your code, you can identify bottlenecks and find ways to make your code run faster.\n\nIn this example, we measure the execution time of a piece of code. This can help us identify parts of our code that are slowing down our program.\n\nIf you’re interested in going beyond the basics of Python’s time module, there are plenty of resources available. Here are a few recommendations:\n• None Python’s Official Documentation on the time module provides an overview of all the functions available in the time module.\n• None Python’s Official Documentation on the datetime module provides a detailed guide on the datetime module.\n• None Programiz’s Python time Module Tutorial provides an overview of Python’s time module, its functions, and how to format time output.\n\nWith these resources and the knowledge you’ve gained from this guide, you’re well on your way to mastering time handling in Python.\n\nIn this comprehensive guide, we’ve journeyed through the world of Python’s time module, exploring how to effectively handle and manipulate time in your Python scripts.\n\nWe began with the basics, learning how to get the current time, convert time to different formats, and pause script execution. We then ventured into more advanced territory, exploring complex uses of the time module, such as measuring script execution time, using time for benchmarking, and working with time tuples. Along the way, we tackled common challenges you might face when working with time in Python, such as dealing with timezones, handling daylight saving time, and addressing leap seconds, providing you with solutions and best practices for each issue.\n\nWe also looked at alternative approaches, diving into Python’s datetime module and comparing it with the time module. Here’s a quick comparison of these modules:\n\nWhether you’re a beginner just starting out with Python’s time module or an experienced Python developer looking to level up your time handling skills, we hope this guide has given you a deeper understanding of time in Python and its capabilities.\n\nWith its range of functionalities, Python’s time module is a powerful tool for handling time in your Python scripts. Happy coding!"
    }
]