[
    {
        "link": "https://vuejs.org/guide/essentials/template-refs",
        "document": "While Vue's declarative rendering model abstracts away most of the direct DOM operations for you, there may still be cases where we need direct access to the underlying DOM elements. To achieve this, we can use the special attribute:\n\nis a special attribute, similar to the attribute discussed in the chapter. It allows us to obtain a direct reference to a specific DOM element or child component instance after it's mounted. This may be useful when you want to, for example, programmatically focus an input on component mount, or initialize a 3rd party library on an element.\n\nTo obtain the reference with Composition API, we can use the helper: // the first argument must match the ref value in the template When using TypeScript, Vue's IDE support and will automatically infer the type of based on what element or component the matching attribute is used on. In versions before 3.5 where was not introduced, we need to declare a ref with a name that matches the template ref attribute's value: // the name must match template ref value If not using , make sure to also return the ref from :\n\nNote that you can only access the ref after the component is mounted. If you try to access in a template expression, it will be on the first render. This is because the element doesn't exist until after the first render!\n\nIt should be noted that the ref array does not guarantee the same order as the source array.\n\nInstead of a string key, the attribute can also be bound to a function, which will be called on each component update and gives you full flexibility on where to store the element reference. The function receives the element reference as the first argument:\n\nNote we are using a dynamic binding so we can pass it a function instead of a ref name string. When the element is unmounted, the argument will be . You can, of course, use a method instead of an inline function.\n\ncan also be used on a child component. In this case the reference will be that of a component instance:\n\nIf the child component is using Options API or not using , theThe referenced instance will be identical to the child component's , which means the parent component will have full access to every property and method of the child component. This makes it easy to create tightly coupled implementation details between the parent and the child, so component refs should be only used when absolutely needed - in most cases, you should try to implement parent / child interactions using the standard props and emit interfaces first.\n\nAn exception here is that components using are private by default: a parent component referencing a child component using won't be able to access anything unless the child component chooses to expose a public interface using the macro: // Compiler macros, such as defineExpose, don't need to be imported When a parent gets an instance of this component via template refs, the retrieved instance will be of the shape (refs are automatically unwrapped just like on normal instances). Note that defineExpose must be called before any await operation. Otherwise, properties and methods exposed after the await operation will not be accessible."
    },
    {
        "link": "https://stackoverflow.com/questions/71093658/how-to-get-refs-using-composition-api-in-vue3",
        "document": "I am trying to get $refs in Vue 3 using Composition API. This is my template that has two child components and I need to get reference to one child component instance:\n\nIn my code I use Template Refs: ref is a special attribute, that allows us to obtain a direct reference to a specific DOM element or child component instance after it's mounted.\n\nIf I use Options API then I don't have any problems:\n\nHowever, using Composition API I get error:\n\nCould anyone say how to do it using Composition API?"
    },
    {
        "link": "https://stackoverflow.com/questions/61600078/vue-3-composition-api-how-to-get-the-component-element-el-on-which-the-comp",
        "document": "In Vue 3, components are no longer limited to only 1 root element. Implicitly, this means you no longer have an .\n\nYou have to use to interact with any element in your template:\n\nIn the function, you should instantiate as .\n\nIn the Options API, you can just use in any method or hook, as long as it's after .\n\nAs pointed out by @AndrewSee in the comments, when using a render function (not a template), you can specify the desired in options:\n\nAnd you also have an example on how to a \"root\" element. Obviously, you don't need to name it root. Name it , if you prefer. However, doing so doesn't mean it will be available as , but as .\n\nIn Vue 3 you're no longer limited to only one root element in , so you have to specifically erence any element you want to interact with.\n\nUpdate, 2 years later.\n\n Specific syntaxes for various component styles (they are not different solutions, they are different ways of writing the same thing):"
    },
    {
        "link": "https://medium.com/@shuhan.chan08/basic-usage-of-vue-3-5-usetemplateref-4b8d7a89bf7d",
        "document": "Before Vue 3.5, we had to use the traditional API. This required manually defining the variable and explicitly setting its type using generics. Since the element doesn’t exist in the DOM until the component mounts, we needed to use optional chaining to prevent errors.\n\nIn versions prior to Vue 3.5, you had to manually define the variable and ensure it matches the name in the template. This could be confusing for beginners who might mistakenly believe they can directly bind the to a variable.\n\nIn Vue, even if you mistakenly write , there won’t be an error, which can mislead developers into thinking this is valid. However, this will always result in being , leading to functionality issues without obvious errors.\n\nIf you want to abstract the handling logic into a custom Hook, you can do it like this:\n\nIn this Hook, we define an variable and manipulate the input box in the function. Here’s how you can use this custom Hook in a Vue component:\n\nEven if you don’t directly use in the component template, you still need to import it from the Hook. Otherwise, won’t be bound to the DOM element. This is because Vue’s requires a variable to correctly bind to the corresponding DOM element. Without , the function won’t be able to find and interact with the DOM element."
    },
    {
        "link": "https://vuejs.org/guide/essentials/reactivity-fundamentals.html",
        "document": "With the Options API, we use the option to declare reactive state of a component. The option value should be a function that returns an object. Vue will call the function when creating a new component instance, and wrap the returned object in its reactivity system. Any top-level properties of this object are proxied on the component instance ( in methods and lifecycle hooks): // `mounted` is a lifecycle hook which we will explain later // `this` refers to the component instance. // data can be mutated as well These instance properties are only added when the instance is first created, so you need to ensure they are all present in the object returned by the function. Where necessary, use , or some other placeholder value for properties where the desired value isn't yet available. It is possible to add a new property directly to without including it in . However, properties added this way will not be able to trigger reactive updates. Vue uses a prefix when exposing its own built-in APIs via the component instance. It also reserves the prefix for internal properties. You should avoid using names for top-level properties that start with either of these characters. In Vue 3, data is made reactive by leveraging JavaScript Proxies. Users coming from Vue 2 should be aware of the following edge case: When you access after assigning it, the value is a reactive proxy of the original . Unlike in Vue 2, the original is left intact and will not be made reactive: make sure to always access reactive state as a property of .\n\nIn Composition API, the recommended way to declare reactive state is using the function: takes the argument and returns it wrapped within a ref object with a property: To access refs in a component's template, declare and return them from a component's function: // `setup` is a special hook dedicated for the Composition API. // expose the ref to the template Notice that we did not need to append when using the ref in the template. For convenience, refs are automatically unwrapped when used inside templates (with a few caveats). You can also mutate a ref directly in event handlers: For more complex logic, we can declare functions that mutate refs in the same scope and expose them as methods alongside the state: // .value is needed in JavaScript // don't forget to expose the function as well. Exposed methods can then be used as event handlers: Here's the example live on Codepen, without using any build tools. Manually exposing state and methods via can be verbose. Luckily, it can be avoided when using Single-File Components (SFCs). We can simplify the usage with : Top-level imports, variables and functions declared in are automatically usable in the template of the same component. Think of the template as a JavaScript function declared in the same scope - it naturally has access to everything declared alongside it. For the rest of the guide, we will be primarily using SFC + syntax for the Composition API code examples, as that is the most common usage for Vue developers. If you are not using SFC, you can still use Composition API with the option. You might be wondering why we need refs with the instead of plain variables. To explain that, we will need to briefly discuss how Vue's reactivity system works. When you use a ref in a template, and change the ref's value later, Vue automatically detects the change and updates the DOM accordingly. This is made possible with a dependency-tracking based reactivity system. When a component is rendered for the first time, Vue tracks every ref that was used during the render. Later on, when a ref is mutated, it will trigger a re-render for components that are tracking it. In standard JavaScript, there is no way to detect the access or mutation of plain variables. However, we can intercept the get and set operations of an object's properties using getter and setter methods. The property gives Vue the opportunity to detect when a ref has been accessed or mutated. Under the hood, Vue performs the tracking in its getter, and performs triggering in its setter. Conceptually, you can think of a ref as an object that looks like this: Another nice trait of refs is that unlike plain variables, you can pass refs into functions while retaining access to the latest value and the reactivity connection. This is particularly useful when refactoring complex logic into reusable code. The reactivity system is discussed in more details in the Reactivity in Depth section.\n\nTo add methods to a component instance we use the option. This should be an object containing the desired methods: // methods can be called in lifecycle hooks, or other methods! Vue automatically binds the value for so that it always refers to the component instance. This ensures that a method retains the correct value if it's used as an event listener or callback. You should avoid using arrow functions when defining , as that prevents Vue from binding the appropriate value: // BAD: no `this` access here! Just like all other properties of the component instance, the are accessible from within the component's template. Inside a template they are most commonly used as event listeners: In the example above, the method will be called when the is clicked.\n\nRefs can hold any value type, including deeply nested objects, arrays, or JavaScript built-in data structures like . A ref will make its value deeply reactive. This means you can expect changes to be detected even when you mutate nested objects or arrays: // these will work as expected. Non-primitive values are turned into reactive proxies via , which is discussed below. It is also possible to opt-out of deep reactivity with shallow refs. For shallow refs, only access is tracked for reactivity. Shallow refs can be used for optimizing performance by avoiding the observation cost of large objects, or in cases where the inner state is managed by an external library.\n\nWhen you mutate reactive state, the DOM is updated automatically. However, it should be noted that the DOM updates are not applied synchronously. Instead, Vue buffers them until the \"next tick\" in the update cycle to ensure that each component updates only once no matter how many state changes you have made.\n\nTo wait for the DOM update to complete after a state change, you can use the nextTick() global API:\n\nThere is another way to declare reactive state, with the API. Unlike a ref which wraps the inner value in a special object, makes an object itself reactive: Reactive objects are JavaScript Proxies and behave just like normal objects. The difference is that Vue is able to intercept the access and mutation of all properties of a reactive object for reactivity tracking and triggering. converts the object deeply: nested objects are also wrapped with when accessed. It is also called by internally when the ref value is an object. Similar to shallow refs, there is also the API for opting-out of deep reactivity. It is important to note that the returned value from is a Proxy of the original object, which is not equal to the original object: // proxy is NOT equal to the original. Only the proxy is reactive - mutating the original object will not trigger updates. Therefore, the best practice when working with Vue's reactivity system is to exclusively use the proxied versions of your state. To ensure consistent access to the proxy, calling on the same object always returns the same proxy, and calling on an existing proxy also returns that same proxy: // calling reactive() on the same object returns the same proxy This rule applies to nested objects as well. Due to deep reactivity, nested objects inside a reactive object are also proxies: The API has a few limitations:\n• None Limited value types: it only works for object types (objects, arrays, and collection types such as and ). It cannot hold primitive types such as , or .\n• None Cannot replace entire object: since Vue's reactivity tracking works over property access, we must always keep the same reference to the reactive object. This means we can't easily \"replace\" a reactive object because the reactivity connection to the first reference is lost: // the above reference ({ count: 0 }) is no longer being tracked\n• None Not destructure-friendly: when we destructure a reactive object's primitive type property into local variables, or when we pass that property into a function, we will lose the reactivity connection: // count is disconnected from state.count when destructured. // won't be able to track changes to state.count // we have to pass the entire object in to retain reactivity Due to these limitations, we recommend using as the primary API for declaring reactive state. A ref is automatically unwrapped when accessed or mutated as a property of a reactive object. In other words, it behaves like a normal property: If a new ref is assigned to a property linked to an existing ref, it will replace the old ref: // original ref is now disconnected from state.count Ref unwrapping only happens when nested inside a deep reactive object. It does not apply when it is accessed as a property of a shallow reactive object. Unlike reactive objects, there is no unwrapping performed when the ref is accessed as an element of a reactive array or a native collection type like : Ref unwrapping in templates only applies if the ref is a top-level property in the template render context. In the example below, and are top-level properties, but is not: Therefore, this expression works as expected: ...while this one does NOT: The rendered result will be because is not unwrapped when evaluating the expression and remains a ref object. To fix this, we can destructure into a top-level property: Now the render result will be . Another thing to note is that a ref does get unwrapped if it is the final evaluated value of a text interpolation (i.e. a tag), so the following will render : This is just a convenience feature of text interpolation and is equivalent to ."
    },
    {
        "link": "https://vuejs.org/guide/essentials/lifecycle",
        "document": "Each Vue component instance goes through a series of initialization steps when it's created - for example, it needs to set up data observation, compile the template, mount the instance to the DOM, and update the DOM when data changes. Along the way, it also runs functions called lifecycle hooks, giving users the opportunity to add their own code at specific stages.\n\nFor example, the hook can be used to run code after the component has finished the initial rendering and created the DOM nodes:\n\nThere are also other hooks which will be called at different stages of the instance's lifecycle, with the most commonly used being , , and . , , and .\n\nAll lifecycle hooks are called with their context pointing to the current active instance invoking it. Note this means you should avoid using arrow functions when declaring lifecycle hooks, as you won't be able to access the component instance via if you do so.\n\nWhen calling , Vue automatically associates the registered callback function with the current active component instance. This requires these hooks to be registered synchronously during component setup. For example, do not do this: Do note this doesn't mean that the call must be placed lexically inside or . can be called in an external function as long as the call stack is synchronous and originates from within .\n\nBelow is a diagram for the instance lifecycle. You don't need to fully understand everything going on right now, but as you learn and build more, it will be a useful reference.\n\nConsult the Lifecycle Hooks API referenceLifecycle Hooks API reference for details on all lifecycle hooks and their respective use cases."
    },
    {
        "link": "https://vuejs.org/api/composition-api-lifecycle",
        "document": "Registers a callback to be called after the component has been mounted.\n• None\n• None All of its synchronous child components have been mounted (does not include async components or components inside trees).\n• None Its own DOM tree has been created and inserted into the parent container. Note it only guarantees that the component's DOM tree is in-document if the application's root container is also in-document. This hook is typically used for performing side effects that need access to the component's rendered DOM, or for limiting DOM-related code to the client in a server-rendered application. This hook is not called during server-side rendering.\n\nRegisters a callback to be called after the component has updated its DOM tree due to a reactive state change.\n• None A parent component's updated hook is called after that of its child components. This hook is called after any DOM update of the component, which can be caused by different state changes, because multiple state changes can be batched into a single render cycle for performance reasons. If you need to access the updated DOM after a specific state change, use nextTick() instead. This hook is not called during server-side rendering. Do not mutate component state in the updated hook - this will likely lead to an infinite update loop!\n• None // text content should be the same as current `count.value`\n\nRegisters a callback to be called after the component has been unmounted.\n• None\n• None All of its child components have been unmounted.\n• None All of its associated reactive effects (render effect and computed / watchers created during ) have been stopped. Use this hook to clean up manually created side effects such as timers, DOM event listeners or server connections. This hook is not called during server-side rendering.\n\nRegisters a hook to be called right before the component is to be mounted.\n• None When this hook is called, the component has finished setting up its reactive state, but no DOM nodes have been created yet. It is about to execute its DOM render effect for the first time. This hook is not called during server-side rendering.\n\nRegisters a hook to be called right before the component is about to update its DOM tree due to a reactive state change.\n• None This hook can be used to access the DOM state before Vue updates the DOM. It is also safe to modify component state inside this hook. This hook is not called during server-side rendering.\n\nRegisters a hook to be called right before a component instance is to be unmounted.\n• None When this hook is called, the component instance is still fully functional. This hook is not called during server-side rendering.\n\nRegisters a hook to be called when an error propagating from a descendant component has been captured.\n• None Errors can be captured from the following sources: The hook receives three arguments: the error, the component instance that triggered the error, and an information string specifying the error source type. In production, the 3rd argument ( ) will be a shortened code instead of the full information string. You can find the code to string mapping in the Production Error Code Reference. You can modify component state in to display an error state to the user. However, it is important that the error state should not render the original content that caused the error; otherwise the component will be thrown into an infinite render loop. The hook can return to stop the error from propagating further. See error propagation details below.\n• None By default, all errors are still sent to the application-level if it is defined, so that these errors can still be reported to an analytics service in a single place.\n• None If multiple hooks exist on a component's inheritance chain or parent chain, all of them will be invoked on the same error, in the order of bottom to top. This is similar to the bubbling mechanism of native DOM events.\n• None If the hook itself throws an error, both this error and the original captured error are sent to .\n• None An hook can return to prevent the error from propagating further. This is essentially saying \"this error has been handled and should be ignored.\" It will prevent any additional hooks or from being invoked for this error.\n\nRegisters a debug hook to be called when a reactive dependency has been tracked by the component's render effect.\n\nThis hook is development-mode-only and not called during server-side rendering.\n• None See also Reactivity in Depth\n\nRegisters a debug hook to be called when a reactive dependency triggers the component's render effect to be re-run.\n\nThis hook is development-mode-only and not called during server-side rendering.\n• None See also Reactivity in Depth\n\nRegisters a callback to be called after the component instance is inserted into the DOM as part of a tree cached by .\n\nThis hook is not called during server-side rendering.\n• None See also Guide - Lifecycle of Cached Instance\n\nRegisters a callback to be called after the component instance is removed from the DOM as part of a tree cached by .\n\nThis hook is not called during server-side rendering.\n• None See also Guide - Lifecycle of Cached Instance\n\nRegisters an async function to be resolved before the component instance is to be rendered on the server.\n• None If the callback returns a Promise, the server renderer will wait until the Promise is resolved before rendering the component. This hook is only called during server-side rendering can be used to perform server-only data fetching.\n• None // component is rendered as part of the initial request // pre-fetch data on server as it is faster than on the client // if data is null on mount, it means the component // is dynamically rendered on the client. Perform a"
    },
    {
        "link": "https://medium.com/@hakanbudk0/exploring-the-lifecycle-hooks-in-vue-js-3-onmounted-onupdated-and-onunmounted-3c6c276de119",
        "document": "Hello everyone, I hope everyone is well. In Vue.js 3, the introduction of the Composition API brought a new way to manage component lifecycles through the onMounted(), onUpdated(), and onUnmounted() lifecycle Hooks. In this blog post, we will review these Hooks and discover how they can be used to develop your Vue.js applications.\n\nIn this blog post, we will explore the onMounted(), onUpdated(), and onUnmounted() Hooks in detail, understanding their purpose, benefits, and usage.\n• In the setup() function, we declare a reactive variable called using the ref() Hook and initialize it with a value of 0.\n• The onMounted() Hook is used to perform logic after the component is mounted. In this example, it logs a message to the console.\n• The onUpdated() Hook is used to execute logic after the component is updated. Here, it logs a message to the console whenever the component is re-rendered due to a data change.\n• The onUnmounted() Hook is used to perform cleanup operations before the component is unmounted. It logs a message to the console when the component is about to be destroyed.\n• The increment() method is defined to increment the value when the button is clicked.\n\nBy utilizing these lifecycle Hooks, we can execute specific logic at different stages of the component’s lifecycle. In this example, we log messages to the console to demonstrate the execution of the onMounted(), onUpdated(), and onUnmounted() Hooks."
    },
    {
        "link": "https://reddit.com/r/vuejs/comments/uofbs0/is_it_true_the_lifecycle_hooks_arent_important_in",
        "document": "I'm working on a project with someone who suggested in a discussion over a pull request today that lifecycle hooks are unimportant while using script setup in Vue 3 composition API. Should I concern myself with lifecycle hooks in Vue 3 script setup composition APi?\n\nI wanted to check for a value on the property of an injected reactive object during onMounted, but his proposed fix for \"efficiency\" was to place what would have been my callback for onMounted at the highest level of the script. Am I missing something here?\n\nVue things like lifecycle hooks, computed properties, etc. can't be that inefficient to have imported..."
    },
    {
        "link": "https://stackoverflow.com/questions/71372916/use-onmounted-hook",
        "document": "I'm using nuxt3 with vue3 for my website. But I have problem when using onMounted hook.\n\nhere is my vue page."
    }
]