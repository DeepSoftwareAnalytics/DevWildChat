[
    {
        "link": "https://docs.python.org/3/library/ssl.html",
        "document": "This module provides access to Transport Layer Security (often known as “Secure Sockets Layer”) encryption and peer authentication facilities for network sockets, both client-side and server-side. This module uses the OpenSSL library. It is available on all modern Unix systems, Windows, macOS, and probably additional platforms, as long as OpenSSL is installed on that platform.\n\nThis section documents the objects and functions in the module; for more general information about TLS, SSL, and certificates, the reader is referred to the documents in the “See Also” section at the bottom.\n\nThis module provides a class, , which is derived from the type, and provides a socket-like wrapper that also encrypts and decrypts the data going over the socket with SSL. It supports additional methods such as , which retrieves the certificate of the other side of the connection, , which retrieves the cipher being used for the secure connection or , which retrieves certificate chain.\n\nFor more sophisticated applications, the class helps manage settings and certificates, which can then be inherited by SSL sockets created through the method.\n\nSSL sockets provide the following methods of Socket Objects:\n• None , (but passing a non-zero argument is not allowed)\n• None , (with the same limitation) However, since the SSL (and TLS) protocol has its own framing atop of TCP, the SSL sockets abstraction can, in certain respects, diverge from the specification of normal, OS-level sockets. See especially the notes on non-blocking sockets. Instances of must be created using the method. Changed in version 3.5: The method was added. Changed in version 3.5: The does not reset the socket timeout each time bytes are received or sent. The socket timeout is now the maximum total duration of the shutdown. Deprecated since version 3.6: It is deprecated to create a instance directly, use to wrap a socket. Changed in version 3.7: instances must to created with . In earlier versions, it was possible to create instances directly. This was never documented or officially supported. Changed in version 3.10: Python now uses and internally. The functions support reading and writing of data larger than 2 GB. Writing zero-length data no longer fails with a protocol violation error. SSL sockets also have the following additional methods and attributes: Read up to len bytes of data from the SSL socket and return the result as a instance. If buffer is specified, then read into the buffer instead, and return the number of bytes read. Raise or if the socket is non-blocking and the read would block. As at any time a re-negotiation is possible, a call to can also cause write operations. Changed in version 3.5: The socket timeout is no longer reset each time bytes are received or sent. The socket timeout is now the maximum total duration to read up to len bytes. Deprecated since version 3.6: Use instead of . Write buf to the SSL socket and return the number of bytes written. The buf argument must be an object supporting the buffer interface. Raise or if the socket is non-blocking and the write would block. As at any time a re-negotiation is possible, a call to can also cause read operations. Changed in version 3.5: The socket timeout is no longer reset each time bytes are received or sent. The socket timeout is now the maximum total duration to write buf. Deprecated since version 3.6: Use instead of . The and methods are the low-level methods that read and write unencrypted, application-level data and decrypt/encrypt it to encrypted, wire-level data. These methods require an active SSL connection, i.e. the handshake was completed and was not called. Normally you should use the socket API methods like and instead of these methods. Changed in version 3.4: The handshake method also performs when the attribute of the socket’s is true. Changed in version 3.5: The socket timeout is no longer reset each time bytes are received or sent. The socket timeout is now the maximum total duration of the handshake. Changed in version 3.7: Hostname or IP address is matched by OpenSSL during handshake. The function is no longer used. In case OpenSSL refuses a hostname or IP address, the handshake is aborted early and a TLS alert message is sent to the peer. If there is no certificate for the peer on the other end of the connection, return . If the SSL handshake hasn’t been done yet, raise . If the parameter is , and a certificate was received from the peer, this method returns a instance. If the certificate was not validated, the dict is empty. If the certificate was validated, it returns a dict with several keys, amongst them (the principal for which the certificate was issued) and (the principal issuing the certificate). If a certificate contains an instance of the Subject Alternative Name extension (see RFC 3280), there will also be a key in the dictionary. The and fields are tuples containing the sequence of relative distinguished names (RDNs) given in the certificate’s data structure for the respective fields, and each RDN is a sequence of name-value pairs. Here is a real-world example: If the parameter is , and a certificate was provided, this method returns the DER-encoded form of the entire certificate as a sequence of bytes, or if the peer did not provide a certificate. Whether the peer provides a certificate depends on the SSL socket’s role:\n• None for a client SSL socket, the server will always provide a certificate, regardless of whether validation was required;\n• None for a server SSL socket, the client will only provide a certificate when requested by the server; therefore will return if you used (rather than or ). Changed in version 3.2: The returned dictionary includes additional items such as and . Changed in version 3.4: is raised when the handshake isn’t done. The returned dictionary includes additional X509v3 extension items such as , and URIs. Changed in version 3.9: IPv6 address strings no longer have a trailing new line. Returns verified certificate chain provided by the other end of the SSL channel as a list of DER-encoded bytes. If certificate verification was disabled method acts the same as . Returns raw certificate chain provided by the other end of the SSL channel as a list of DER-encoded bytes. Returns a three-value tuple containing the name of the cipher being used, the version of the SSL protocol that defines its use, and the number of secret bits being used. If no connection has been established, returns . Return the list of ciphers available in both the client and server. Each entry of the returned list is a three-value tuple containing the name of the cipher, the version of the SSL protocol that defines its use, and the number of secret bits the cipher uses. returns if no connection has been established or the socket is a client socket. Return the compression algorithm being used as a string, or if the connection isn’t compressed. If the higher-level protocol supports its own compression mechanism, you can use to disable SSL-level compression. Get channel binding data for current connection, as a bytes object. Returns if not connected or the handshake has not been completed. The cb_type parameter allow selection of the desired channel binding type. Valid channel binding types are listed in the list. Currently only the ‘tls-unique’ channel binding, defined by RFC 5929, is supported. will be raised if an unsupported channel binding type is requested. Return the protocol that was selected during the TLS handshake. If was not called, if the other party does not support ALPN, if this socket does not support any of the client’s proposed protocols, or if the handshake has not happened yet, is returned. Return the higher-level protocol that was selected during the TLS/SSL handshake. If was not called, or if the other party does not support NPN, or if the handshake has not yet happened, this will return . Deprecated since version 3.10: NPN has been superseded by ALPN Performs the SSL shutdown handshake, which removes the TLS layer from the underlying socket, and returns the underlying socket object. This can be used to go from encrypted operation over a connection to unencrypted. The returned socket should always be used for further communication with the other side of the connection, rather than the original socket. Requests post-handshake authentication (PHA) from a TLS 1.3 client. PHA can only be initiated for a TLS 1.3 connection from a server-side socket, after the initial TLS handshake and with PHA enabled on both sides, see . The method does not perform a cert exchange immediately. The server-side sends a CertificateRequest during the next write event and expects the client to respond with a certificate on the next read event. If any precondition isn’t met (e.g. not TLS 1.3, PHA not enabled), an is raised. Only available with OpenSSL 1.1.1 and TLS 1.3 enabled. Without TLS 1.3 support, the method raises . Return the actual SSL protocol version negotiated by the connection as a string, or if no secure connection is established. As of this writing, possible return values include , , , and . Recent OpenSSL versions may define more return values. Returns the number of already decrypted bytes available for read, pending on the connection. The object this SSL socket is tied to. A boolean which is for server-side sockets and for client-side sockets. Hostname of the server: type, or for server-side socket or if the hostname was not specified in the constructor. Changed in version 3.7: The attribute is now always ASCII text. When is an internationalized domain name (IDN), this attribute now stores the A-label form ( ), rather than the U-label form ( ). The for this SSL connection. The session is available for client and server side sockets after the TLS handshake has been performed. For client sockets the session can be set before has been called to reuse a session.\n\nCertificates in general are part of a public-key / private-key system. In this system, each principal, (which may be a machine, or a person, or an organization) is assigned a unique two-part encryption key. One part of the key is public, and is called the public key; the other part is kept secret, and is called the private key. The two parts are related, in that if you encrypt a message with one of the parts, you can decrypt it with the other part, and only with the other part. A certificate contains information about two principals. It contains the name of a subject, and the subject’s public key. It also contains a statement by a second principal, the issuer, that the subject is who they claim to be, and that this is indeed the subject’s public key. The issuer’s statement is signed with the issuer’s private key, which only the issuer knows. However, anyone can verify the issuer’s statement by finding the issuer’s public key, decrypting the statement with it, and comparing it to the other information in the certificate. The certificate also contains information about the time period over which it is valid. This is expressed as two fields, called “notBefore” and “notAfter”. In the Python use of certificates, a client or server can use a certificate to prove who they are. The other side of a network connection can also be required to produce a certificate, and that certificate can be validated to the satisfaction of the client or server that requires such validation. The connection attempt can be set to raise an exception if the validation fails. Validation is done automatically, by the underlying OpenSSL framework; the application need not concern itself with its mechanics. But the application does usually need to provide sets of certificates to allow this process to take place. Python uses files to contain certificates. They should be formatted as “PEM” (see RFC 1422), which is a base-64 encoded form wrapped with a header line and a footer line: The Python files which contain certificates can contain a sequence of certificates, sometimes called a certificate chain. This chain should start with the specific certificate for the principal who “is” the client or server, and then the certificate for the issuer of that certificate, and then the certificate for the issuer of that certificate, and so on up the chain till you get to a certificate which is self-signed, that is, a certificate which has the same subject and issuer, sometimes called a root certificate. The certificates should just be concatenated together in the certificate file. For example, suppose we had a three certificate chain, from our server certificate to the certificate of the certification authority that signed our server certificate, to the root certificate of the agency which issued the certification authority’s certificate: If you are going to require validation of the other side of the connection’s certificate, you need to provide a “CA certs” file, filled with the certificate chains for each issuer you are willing to trust. Again, this file just contains these chains concatenated together. For validation, Python will use the first chain it finds in the file which matches. The platform’s certificates file can be used by calling , this is done automatically with . Often the private key is stored in the same file as the certificate; in this case, only the parameter to needs to be passed. If the private key is stored with the certificate, it should come before the first certificate in the certificate chain: If you are going to create a server that provides SSL-encrypted connection services, you will need to acquire a certificate for that service. There are many ways of acquiring appropriate certificates, such as buying one from a certification authority. Another common practice is to generate a self-signed certificate. The simplest way to do this is with the OpenSSL package, using something like the following: The disadvantage of a self-signed certificate is that it is its own root certificate, and no one else will have it in their cache of known (and trusted) root certificates.\n\nTo test for the presence of SSL support in a Python installation, user code should use the following idiom: # do something that requires SSL support This example creates a SSL context with the recommended security settings for client sockets, including automatic certificate verification: If you prefer to tune security settings yourself, you might create a context from scratch (but beware that you might not get the settings right): The protocol configures the context for cert validation and hostname verification. is set to and is set to . All other protocols create SSL contexts with insecure defaults. When you use the context to connect to a server, and validate the server certificate: it ensures that the server certificate was signed with one of the CA certificates, checks the signature for correctness, and verifies other properties like validity and identity of the hostname: You may then fetch the certificate: Visual inspection shows that the certificate does identify the desired service (that is, the HTTPS host ): Now the SSL channel is established and the certificate verified, you can proceed to talk with the server: See the discussion of Security considerations below. For server operation, typically you’ll need to have a server certificate, and private key, each in a file. You’ll first create a context holding the key and the certificate, so that clients can check your authenticity. Then you’ll open a socket, bind it to a port, call on it, and start waiting for clients to connect: When a client connects, you’ll call on the socket to get the new socket from the other end, and use the context’s method to create a server-side SSL socket for the connection: Then you’ll read data from the and do something with it till you are finished with the client (or the client is finished with you): # empty data means the client is finished with us # when we're finished with client And go back to listening for new client connections (of course, a real server would probably handle each client connection in a separate thread, or put the sockets in non-blocking mode and use an event loop).\n\nEver since the SSL module was introduced in Python 2.6, the class has provided two related but distinct areas of functionality: The network IO API is identical to that provided by , from which also inherits. This allows an SSL socket to be used as a drop-in replacement for a regular socket, making it very easy to add SSL support to an existing application. Combining SSL protocol handling and network IO usually works well, but there are some cases where it doesn’t. An example is async IO frameworks that want to use a different IO multiplexing model than the “select/poll on a file descriptor” (readiness based) model that is assumed by and by the internal OpenSSL socket IO routines. This is mostly relevant for platforms like Windows where this model is not efficient. For this purpose, a reduced scope variant of called is provided. A reduced-scope variant of representing an SSL protocol instance that does not contain any network IO methods. This class is typically used by framework authors that want to implement asynchronous IO for SSL through memory buffers. This class implements an interface on top of a low-level SSL object as implemented by OpenSSL. This object captures the state of an SSL connection but does not provide any network IO itself. IO needs to be performed through separate “BIO” objects which are OpenSSL’s IO abstraction layer. This class has no public constructor. An instance must be created using the method. This method will create the instance and bind it to a pair of BIOs. The incoming BIO is used to pass data from Python to the SSL protocol instance, while the outgoing BIO is used to pass data the other way around. The following methods are available: When compared to , this object lacks the following features:\n• None Any form of network IO; and read and write only to the underlying buffers.\n• None There is no do_handshake_on_connect machinery. You must always manually call to start the handshake.\n• None There is no handling of suppress_ragged_eofs. All end-of-file conditions that are in violation of the protocol are reported via the exception.\n• None The method call does not return anything, unlike for an SSL socket where it returns the underlying socket.\n• None The server_name_callback callback passed to will get an instance instead of a instance as its first parameter. Some notes related to the use of :\n• None All IO on an is non-blocking. This means that for example will raise an if it needs more data than the incoming BIO has available. Changed in version 3.7: instances must be created with . In earlier versions, it was possible to create instances directly. This was never documented or officially supported. An SSLObject communicates with the outside world using memory buffers. The class provides a memory buffer that can be used for this purpose. It wraps an OpenSSL memory BIO (Basic IO) object: A memory buffer that can be used to pass data between Python and an SSL protocol instance. Return the number of bytes currently in the memory buffer. A boolean indicating whether the memory BIO is current at the end-of-file position. Read up to n bytes from the memory buffer. If n is not specified or negative, all bytes are returned. Write the bytes from buf to the memory BIO. The buf argument must be an object supporting the buffer protocol. The return value is the number of bytes written, which is always equal to the length of buf. Write an EOF marker to the memory BIO. After this method has been called, it is illegal to call . The attribute will become true after all data currently in the buffer has been read."
    },
    {
        "link": "https://geeksforgeeks.org/how-to-install-and-use-ssl-certificate-in-python",
        "document": "How to Install and use SSL Certificate In Python\n\nA secure Socket Layer (SSL) Certificate is a Digital certificate that can be used for the authentication of a website and it helps to establish an encrypted connection between the user and server. SSL is a secure layer that creates an encrypted link between a web server and a web browser. SSL keeps internet connections secure. When an SSL certificate is installed on the website it becomes HTTP to HTTPS, which is more secure. SSL is also called TLS.\n\nThere are different types of SSL certificates with different validation levels. The six main types are:\n• Authentication: An SSL certificate will verify that a user is connecting to the correct server.\n• Encryption: SSL will ensure that the connection between the user and the server must be encrypted.\n• HTTPS: It is a combination of the HTTP with the Secure Socket Layer (SSL)/Transport Layer Security (TLS) protocol.\n• TLS: It is an authentication and security protocol widely implemented in browsers and Web servers.\n\nPreinstalled Python environment can be downloaded from python.org. To install python on Windows/Mac/Linux refer to:\n\nStep 1: Press the Start button and then Type CMD to Select Command Prompt from the list. When we open the command prompt then a screen like this will appear on the computer.\n\nStep 2: Type the given below command on the command prompt and then press enter button.\n\nIn case the previous command will not work then type the given below command and then press enter button.\n\nStep 2: Type the given below command on the terminal and then press enter button.\n\nStep 3: In case if the previous command will not work then type the given below command and then press enter button.\n\nThe certifi.where() is a function that helps us find the information of the installed certificate authority (CA) in Python."
    },
    {
        "link": "https://python.readthedocs.io/fr/latest/library/ssl.html",
        "document": "This module provides access to Transport Layer Security (often known as “Secure Sockets Layer”) encryption and peer authentication facilities for network sockets, both client-side and server-side. This module uses the OpenSSL library. It is available on all modern Unix systems, Windows, Mac OS X, and probably additional platforms, as long as OpenSSL is installed on that platform.\n\nThis section documents the objects and functions in the module; for more general information about TLS, SSL, and certificates, the reader is referred to the documents in the “See Also” section at the bottom.\n\nThis module provides a class, , which is derived from the type, and provides a socket-like wrapper that also encrypts and decrypts the data going over the socket with SSL. It supports additional methods such as , which retrieves the certificate of the other side of the connection, and ,which retrieves the cipher being used for the secure connection.\n\nFor more sophisticated applications, the class helps manage settings and certificates, which can then be inherited by SSL sockets created through the method.\n• , (but passing a non-zero argument is not allowed) However, since the SSL (and TLS) protocol has its own framing atop of TCP, the SSL sockets abstraction can, in certain respects, diverge from the specification of normal, OS-level sockets. See especially the notes on non-blocking sockets. Usually, are not created directly, but using the method. Modifié dans la version 3.5: The method was added. Modifié dans la version 3.5: The does not reset the socket timeout each time bytes are received or sent. The socket timeout is now to maximum total duration of the shutdown. Obsolète depuis la version 3.6: It is deprecated to create a instance directly, use to wrap a socket. Read up to len bytes of data from the SSL socket and return the result as a instance. If buffer is specified, then read into the buffer instead, and return the number of bytes read. Raise or if the socket is non-blocking and the read would block. As at any time a re-negotiation is possible, a call to can also cause write operations. Modifié dans la version 3.5: The socket timeout is no more reset each time bytes are received or sent. The socket timeout is now to maximum total duration to read up to len bytes. Write buf to the SSL socket and return the number of bytes written. The buf argument must be an object supporting the buffer interface. Raise or if the socket is non-blocking and the write would block. As at any time a re-negotiation is possible, a call to can also cause read operations. Modifié dans la version 3.5: The socket timeout is no more reset each time bytes are received or sent. The socket timeout is now to maximum total duration to write buf. The and methods are the low-level methods that read and write unencrypted, application-level data and decrypt/encrypt it to encrypted, wire-level data. These methods require an active SSL connection, i.e. the handshake was completed and was not called. Normally you should use the socket API methods like and instead of these methods. Modifié dans la version 3.4: The handshake method also performs when the attribute of the socket’s is true. Modifié dans la version 3.5: The socket timeout is no more reset each time bytes are received or sent. The socket timeout is now to maximum total duration of the handshake. If there is no certificate for the peer on the other end of the connection, return . If the SSL handshake hasn’t been done yet, raise . If the parameter is , and a certificate was received from the peer, this method returns a instance. If the certificate was not validated, the dict is empty. If the certificate was validated, it returns a dict with several keys, amongst them (the principal for which the certificate was issued) and (the principal issuing the certificate). If a certificate contains an instance of the Subject Alternative Name extension (see RFC 3280), there will also be a key in the dictionary. The and fields are tuples containing the sequence of relative distinguished names (RDNs) given in the certificate’s data structure for the respective fields, and each RDN is a sequence of name-value pairs. Here is a real-world example: To validate a certificate for a particular service, you can use the function. If the parameter is , and a certificate was provided, this method returns the DER-encoded form of the entire certificate as a sequence of bytes, or if the peer did not provide a certificate. Whether the peer provides a certificate depends on the SSL socket’s role:\n• for a client SSL socket, the server will always provide a certificate, regardless of whether validation was required;\n• for a server SSL socket, the client will only provide a certificate when requested by the server; therefore will return if you used (rather than or ). Modifié dans la version 3.2: The returned dictionary includes additional items such as and . Modifié dans la version 3.4: is raised when the handshake isn’t done. The returned dictionary includes additional X509v3 extension items such as , and URIs. Returns a three-value tuple containing the name of the cipher being used, the version of the SSL protocol that defines its use, and the number of secret bits being used. If no connection has been established, returns . Return the list of ciphers shared by the client during the handshake. Each entry of the returned list is a three-value tuple containing the name of the cipher, the version of the SSL protocol that defines its use, and the number of secret bits the cipher uses. returns if no connection has been established or the socket is a client socket. Return the compression algorithm being used as a string, or if the connection isn’t compressed. If the higher-level protocol supports its own compression mechanism, you can use to disable SSL-level compression. Get channel binding data for current connection, as a bytes object. Returns if not connected or the handshake has not been completed. The cb_type parameter allow selection of the desired channel binding type. Valid channel binding types are listed in the list. Currently only the ‘tls-unique’ channel binding, defined by RFC 5929, is supported. will be raised if an unsupported channel binding type is requested. Return the protocol that was selected during the TLS handshake. If was not called, if the other party does not support ALPN, if this socket does not support any of the client’s proposed protocols, or if the handshake has not happened yet, is returned. Return the higher-level protocol that was selected during the TLS/SSL handshake. If was not called, or if the other party does not support NPN, or if the handshake has not yet happened, this will return . Performs the SSL shutdown handshake, which removes the TLS layer from the underlying socket, and returns the underlying socket object. This can be used to go from encrypted operation over a connection to unencrypted. The returned socket should always be used for further communication with the other side of the connection, rather than the original socket. Return the actual SSL protocol version negotiated by the connection as a string, or is no secure connection is established. As of this writing, possible return values include , , , and . Recent OpenSSL versions may define more return values. Returns the number of already decrypted bytes available for read, pending on the connection. The object this SSL socket is tied to. If the SSL socket was created using the top-level function (rather than ), this is a custom context object created for this SSL socket. A boolean which is for server-side sockets and for client-side sockets. Hostname of the server: type, or for server-side socket or if the hostname was not specified in the constructor. The for this SSL connection. The session is available for client and server side sockets after the TLS handshake has been performed. For client sockets the session can be set before has been called to reuse a session.\n\nAn SSL context holds various data longer-lived than single SSL connections, such as SSL configuration options, certificate(s) and private key(s). It also manages a cache of SSL sessions for server-side sockets, in order to speed up repeated connections from the same clients. Create a new SSL context. You may pass protocol which must be one of the constants defined in this module. is currently recommended for maximum interoperability and default value. lets the module choose security settings for a given purpose. Modifié dans la version 3.6: The context is created with secure default values. The options , , , , (except for ), and (except for ) are set by default. The initial cipher suite list contains only ciphers, no ciphers and no ciphers (except for ). Get statistics about quantities of loaded X.509 certificates, count of X.509 certificates flagged as CA certificates and certificate revocation lists as dictionary. Example for a context with one CA cert and one other cert: Load a private key and the corresponding certificate. The certfile string must be the path to a single file in PEM format containing the certificate as well as any number of CA certificates needed to establish the certificate’s authenticity. The keyfile string, if present, must point to a file containing the private key in. Otherwise the private key will be taken from certfile as well. See the discussion of Certificates for more information on how the certificate is stored in the certfile. The password argument may be a function to call to get the password for decrypting the private key. It will only be called if the private key is encrypted and a password is necessary. It will be called with no arguments, and it should return a string, bytes, or bytearray. If the return value is a string it will be encoded as UTF-8 before using it to decrypt the key. Alternatively a string, bytes, or bytearray value may be supplied directly as the password argument. It will be ignored if the private key is not encrypted and no password is needed. If the password argument is not specified and a password is required, OpenSSL’s built-in password prompting mechanism will be used to interactively prompt the user for a password. An is raised if the private key doesn’t match with the certificate. Load a set of default “certification authority” (CA) certificates from default locations. On Windows it loads CA certs from the and system stores. On other systems it calls . In the future the method may load CA certificates from other locations, too. The purpose flag specifies what kind of CA certificates are loaded. The default settings loads certificates, that are flagged and trusted for TLS web server authentication (client side sockets). loads CA certificates for client certificate verification on the server side. Load a set of “certification authority” (CA) certificates used to validate other peers’ certificates when is other than . At least one of cafile or capath must be specified. This method can also load certification revocation lists (CRLs) in PEM or DER format. In order to make use of CRLs, must be configured properly. The cafile string, if present, is the path to a file of concatenated CA certificates in PEM format. See the discussion of Certificates for more information about how to arrange the certificates in this file. The capath string, if present, is the path to a directory containing several CA certificates in PEM format, following an OpenSSL specific layout. The cadata object, if present, is either an ASCII string of one or more PEM-encoded certificates or a bytes-like object of DER-encoded certificates. Like with capath extra lines around PEM-encoded certificates are ignored but at least one certificate must be present. Get a list of loaded “certification authority” (CA) certificates. If the parameter is each list entry is a dict like the output of . Otherwise the method returns a list of DER-encoded certificates. The returned list does not contain certificates from capath unless a certificate was requested and loaded by a SSL connection. Certificates in a capath directory aren’t loaded unless they have been used at least once. Get a list of enabled ciphers. The list is in order of cipher priority. See . On OpenSSL 1.1 and newer the cipher dict contains additional fields: Load a set of default “certification authority” (CA) certificates from a filesystem path defined when building the OpenSSL library. Unfortunately, there’s no easy way to know whether this method succeeds: no error is returned if no certificates are to be found. When the OpenSSL library is provided as part of the operating system, though, it is likely to be configured properly. Set the available ciphers for sockets created with this context. It should be a string in the OpenSSL cipher list format. If no cipher can be selected (because compile-time options or other configuration forbids use of all the specified ciphers), an will be raised. when connected, the method of SSL sockets will give the currently selected cipher. Specify which protocols the socket should advertise during the SSL/TLS handshake. It should be a list of ASCII strings, like , ordered by preference. The selection of a protocol will happen during the handshake, and will play out according to RFC 7301. After a successful handshake, the method will return the agreed-upon protocol. This method will raise if is False. OpenSSL 1.1.0+ will abort the handshake and raise when both sides support ALPN but cannot agree on a protocol. Specify which protocols the socket should advertise during the SSL/TLS handshake. It should be a list of strings, like , ordered by preference. The selection of a protocol will happen during the handshake, and will play out according to the NPN draft specification. After a successful handshake, the method will return the agreed-upon protocol. This method will raise if is False. Register a callback function that will be called after the TLS Client Hello handshake message has been received by the SSL/TLS server when the TLS client specifies a server name indication. The server name indication mechanism is specified in RFC 6066 section 3 - Server Name Indication. Only one callback can be set per . If server_name_callback is then the callback is disabled. Calling this function a subsequent time will disable the previously registered callback. The callback function, server_name_callback, will be called with three arguments; the first being the , the second is a string that represents the server name that the client is intending to communicate (or if the TLS Client Hello does not contain a server name) and the third argument is the original . The server name argument is the IDNA decoded server name. A typical use of this callback is to change the ‘s attribute to a new object of type representing a certificate chain that matches the server name. Due to the early negotiation phase of the TLS connection, only limited methods and attributes are usable like and . , , and methods require that the TLS connection has progressed beyond the TLS Client Hello and therefore will not contain return meaningful values nor can they be called safely. The server_name_callback function must return to allow the TLS negotiation to continue. If a TLS failure is required, a constant can be returned. Other return values will result in a TLS fatal error with . If there is an IDNA decoding error on the server name, the TLS connection will terminate with an fatal TLS alert message to the client. If an exception is raised from the server_name_callback function the TLS connection will terminate with a fatal TLS alert message . This method will raise if the OpenSSL library had OPENSSL_NO_TLSEXT defined when it was built. Load the key generation parameters for Diffie-Helman (DH) key exchange. Using DH key exchange improves forward secrecy at the expense of computational resources (both on the server and on the client). The dhfile parameter should be the path to a file containing DH parameters in PEM format. This setting doesn’t apply to client sockets. You can also use the option to further improve security. Set the curve name for Elliptic Curve-based Diffie-Hellman (ECDH) key exchange. ECDH is significantly faster than regular DH while arguably as secure. The curve_name parameter should be a string describing a well-known elliptic curve, for example for a widely supported curve. This setting doesn’t apply to client sockets. You can also use the option to further improve security. This method is not available if is . Wrap an existing Python socket sock and return an object. sock must be a socket; other socket types are unsupported. The returned SSL socket is tied to the context, its settings and certificates. The parameters server_side, do_handshake_on_connect and suppress_ragged_eofs have the same meaning as in the top-level function. On client connections, the optional parameter server_hostname specifies the hostname of the service which we are connecting to. This allows a single server to host multiple SSL-based services with distinct certificates, quite similarly to HTTP virtual hosts. Specifying server_hostname will raise a if server_side is true. Modifié dans la version 3.5: Always allow a server_hostname to be passed, even if OpenSSL does not have SNI. Modifié dans la version 3.6: session argument was added. Create a new instance by wrapping the BIO objects incoming and outgoing. The SSL routines will read input data from the incoming BIO and write data to the outgoing BIO. The server_side, server_hostname and session parameters have the same meaning as in . Modifié dans la version 3.6: session argument was added. Get statistics about the SSL sessions created or managed by this context. A dictionary is returned which maps the names of each piece of information to their numeric values. For example, here is the total number of hits and misses in the session cache since the context was created: Whether to match the peer cert’s hostname with in . The context’s must be set to or , and you must pass server_hostname to in order to match the hostname. An integer representing the set of SSL options enabled on this context. The default value is , but you can specify other options such as by ORing them together. With versions of OpenSSL older than 0.9.8m, it is only possible to set options, not to clear them. Attempting to clear an option (by resetting the corresponding bits) will raise a . The protocol version chosen when constructing the context. This attribute is read-only. The flags for certificate verification operations. You can set flags like by ORing them together. By default OpenSSL does neither require nor verify certificate revocation lists (CRLs). Available only with openssl version 0.9.8+. Whether to try to verify other peers’ certificates and how to behave if verification fails. This attribute must be one of , or .\n\nCertificates in general are part of a public-key / private-key system. In this system, each principal, (which may be a machine, or a person, or an organization) is assigned a unique two-part encryption key. One part of the key is public, and is called the public key; the other part is kept secret, and is called the private key. The two parts are related, in that if you encrypt a message with one of the parts, you can decrypt it with the other part, and only with the other part. A certificate contains information about two principals. It contains the name of a subject, and the subject’s public key. It also contains a statement by a second principal, the issuer, that the subject is who he claims to be, and that this is indeed the subject’s public key. The issuer’s statement is signed with the issuer’s private key, which only the issuer knows. However, anyone can verify the issuer’s statement by finding the issuer’s public key, decrypting the statement with it, and comparing it to the other information in the certificate. The certificate also contains information about the time period over which it is valid. This is expressed as two fields, called “notBefore” and “notAfter”. In the Python use of certificates, a client or server can use a certificate to prove who they are. The other side of a network connection can also be required to produce a certificate, and that certificate can be validated to the satisfaction of the client or server that requires such validation. The connection attempt can be set to raise an exception if the validation fails. Validation is done automatically, by the underlying OpenSSL framework; the application need not concern itself with its mechanics. But the application does usually need to provide sets of certificates to allow this process to take place. Python uses files to contain certificates. They should be formatted as “PEM” (see RFC 1422), which is a base-64 encoded form wrapped with a header line and a footer line: The Python files which contain certificates can contain a sequence of certificates, sometimes called a certificate chain. This chain should start with the specific certificate for the principal who “is” the client or server, and then the certificate for the issuer of that certificate, and then the certificate for the issuer of that certificate, and so on up the chain till you get to a certificate which is self-signed, that is, a certificate which has the same subject and issuer, sometimes called a root certificate. The certificates should just be concatenated together in the certificate file. For example, suppose we had a three certificate chain, from our server certificate to the certificate of the certification authority that signed our server certificate, to the root certificate of the agency which issued the certification authority’s certificate: If you are going to require validation of the other side of the connection’s certificate, you need to provide a “CA certs” file, filled with the certificate chains for each issuer you are willing to trust. Again, this file just contains these chains concatenated together. For validation, Python will use the first chain it finds in the file which matches. The platform’s certificates file can be used by calling , this is done automatically with . Often the private key is stored in the same file as the certificate; in this case, only the parameter to and needs to be passed. If the private key is stored with the certificate, it should come before the first certificate in the certificate chain: If you are going to create a server that provides SSL-encrypted connection services, you will need to acquire a certificate for that service. There are many ways of acquiring appropriate certificates, such as buying one from a certification authority. Another common practice is to generate a self-signed certificate. The simplest way to do this is with the OpenSSL package, using something like the following: The disadvantage of a self-signed certificate is that it is its own root certificate, and no one else will have it in their cache of known (and trusted) root certificates.\n\nTo test for the presence of SSL support in a Python installation, user code should use the following idiom: This example creates a SSL context with the recommended security settings for client sockets, including automatic certificate verification: If you prefer to tune security settings yourself, you might create a context from scratch (but beware that you might not get the settings right): When you use the context to connect to a server, validates the server certificate: it ensures that the server certificate was signed with one of the CA certificates, and checks the signature for correctness: Visual inspection shows that the certificate does identify the desired service (that is, the HTTPS host ): Now the SSL channel is established and the certificate verified, you can proceed to talk with the server: For server operation, typically you’ll need to have a server certificate, and private key, each in a file. You’ll first create a context holding the key and the certificate, so that clients can check your authenticity. Then you’ll open a socket, bind it to a port, call on it, and start waiting for clients to connect: When a client connects, you’ll call on the socket to get the new socket from the other end, and use the context’s method to create a server-side SSL socket for the connection: Then you’ll read data from the and do something with it till you are finished with the client (or the client is finished with you): # empty data means the client is finished with us And go back to listening for new client connections (of course, a real server would probably handle each client connection in a separate thread, or put the sockets in non-blocking mode and use an event loop).\n\nEver since the SSL module was introduced in Python 2.6, the class has provided two related but distinct areas of functionality: The network IO API is identical to that provided by , from which also inherits. This allows an SSL socket to be used as a drop-in replacement for a regular socket, making it very easy to add SSL support to an existing application. Combining SSL protocol handling and network IO usually works well, but there are some cases where it doesn’t. An example is async IO frameworks that want to use a different IO multiplexing model than the “select/poll on a file descriptor” (readiness based) model that is assumed by and by the internal OpenSSL socket IO routines. This is mostly relevant for platforms like Windows where this model is not efficient. For this purpose, a reduced scope variant of called is provided. A reduced-scope variant of representing an SSL protocol instance that does not contain any network IO methods. This class is typically used by framework authors that want to implement asynchronous IO for SSL through memory buffers. This class implements an interface on top of a low-level SSL object as implemented by OpenSSL. This object captures the state of an SSL connection but does not provide any network IO itself. IO needs to be performed through separate “BIO” objects which are OpenSSL’s IO abstraction layer. An instance can be created using the method. This method will create the instance and bind it to a pair of BIOs. The incoming BIO is used to pass data from Python to the SSL protocol instance, while the outgoing BIO is used to pass data the other way around. When compared to , this object lacks the following features:\n• Any form of network IO incluging methods such as and .\n• There is no do_handshake_on_connect machinery. You must always manually call to start the handshake.\n• There is no handling of suppress_ragged_eofs. All end-of-file conditions that are in violation of the protocol are reported via the exception.\n• The method call does not return anything, unlike for an SSL socket where it returns the underlying socket.\n• The server_name_callback callback passed to will get an instance instead of a instance as its first parameter. Some notes related to the use of :\n• All IO on an is . This means that for example will raise an if it needs more data than the incoming BIO has available.\n• There is no module-level call like there is for . An is always created via an . An SSLObject communicates with the outside world using memory buffers. The class provides a memory buffer that can be used for this purpose. It wraps an OpenSSL memory BIO (Basic IO) object: A memory buffer that can be used to pass data between Python and an SSL protocol instance. Return the number of bytes currently in the memory buffer. A boolean indicating whether the memory BIO is current at the end-of-file position. Read up to n bytes from the memory buffer. If n is not specified or negative, all bytes are returned. Write the bytes from buf to the memory BIO. The buf argument must be an object supporting the buffer protocol. The return value is the number of bytes written, which is always equal to the length of buf. Write an EOF marker to the memory BIO. After this method has been called, it is illegal to call . The attribute will become true after all data currently in the buffer has been read."
    },
    {
        "link": "https://stackoverflow.com/questions/26851034/opening-a-ssl-socket-connection-in-python",
        "document": "I'm trying to establish a secure socket connection in Python, and i'm having a hard time with the SSL bit of it. I've found some code examples of how to establish a connection with SSL, but they all involve key files. The server i'm trying to connect with doesn't need to receive any keys or certificates. My question is how do I essentially wrap a python socket connection with SSL. I know for a fact that the cipher i'm suppose to use is , and the protocol is . This is what i've been trying:\n\nWhen I run this code, I don't get any errors, but I get a blank response. When trying to debug this code in the command line, by typing in in the terminal and pasting in code line by line, I get what i'm assuming is a status code when running . The integer response I get is . If anyone knows what this means, or can help in anyway it would be greatly appreciated."
    },
    {
        "link": "https://snyk.io/blog/implementing-tls-ssl-python",
        "document": "Nowadays, we do virtually everything online: book flights, pay for goods, transfer bank funds, message friends, store documents, and so on. Many things we do require giving out sensitive information like our credit card details and banking information. If a website uses an unsecured network, a malicious hacker can easily steal user information. This is why encryption is so important.\n\nThe transport layer security (TLS) protocol is the ultimate safeguard of user information on websites and web applications. TLS uses a hard-to-crack cryptographic algorithm that ensures that no one other than the web server and web client can read or modify transmitted data.\n\nIn this article, we’ll explore TLS and how to use Python to check for a website’s TLS certificate validity. Then, we’ll walk through the steps for adding TLS to your Python application on Linux.\n\nThe TLS protocol, the successor of the secure socket layer (SSL) protocol, protects data using encryption. When users send their information to a website, TLS encrypts it before sending it. Then, only the server with the same public key as the client can open the message. This rule also applies when the server sends information back to the client. Only the client with the corresponding key can read the data.\n\nFor a website to use TLS protocol, you must install a valid TLS/SSL certificate (often called an SSL certificate). When you install the certificate, it upgrades the website from HTTP to HTTPS, a more secure transfer protocol. The certificate is a data file that contains the website’s identity and the public key for opening payload messages.\n\nAn SSL certificate must be valid to work. This means that not only must a credible certificate authority (CA) sign it, but the certificate also must be active. Every certificate has an issuance date and an expiration date. A certificate is no longer valid after its expiration date.\n\nWebsites without a valid SSL certificate have few visible indicators. For one, the URL in the address bar uses the prefix instead of . Additionally, there is no lock icon — which browsers use to indicate a secure site — next to the URL. Be cautious about what you share if you notice either of these signs.\n\nNow that we’ve explored TLS-over-SSL (TLS/SSL), let’s see how to implement it using Python.\n\nWhen building a web server with Python, it’s crucial to know how to add TLS/SSL to our application. Before we learn how to do so, let’s see how to use Python to verify the validity of a website’s SSL certificate.\n\nIf we want to check the validity of a website’s SSL certificate, we can easily do so by running a Python script like this:\n\nThe code above imports the Python module and uses it to make a request to the Twitter website. (To run the script, you must install the module in Python using pip). We can replace Twitter’s URL with the URL of the website whose SSL certificate we want to verify. The variable stores the received value, which the code prints on the last line.\n\nWhen we execute the code, we get a message, meaning that the Twitter site is using a valid SSL certificate (as expected).\n\nNow, we execute a request to another website. This time we use a website that we know lacks a valid SSL certificate.\n\nThis time, we receive an error stating that the certificate verification process failed:\n\nWe use the Python SSL library to provide TLS encryption in socket-based communication between Python clients and servers. It uses cryptography and message digests to secure data and detect alteration attempts in the network. Digital certificates provide authentication.\n\nThe SSL library supports Windows, macOS, and other modern UNIX systems. It also requires OpenSSL to work.\n\nToward the end of this article, we’ll use the Python SSL library to wrap our connection-based socket with the SSL certificate we generate in the following section.\n\nNow that we know how to verify the validity of TLS/SSL on a website, let’s see how we can use it on a Python web server.\n\nWe can quickly generate and use a free self-signed certificate for local development. However, if we intend to deploy the site or app on the internet, we must purchase an SSL certificate from a trusted domain registrar (like GoDaddy and NameCheap).\n\nThe process of self-generating an SSL certificate for our local Python application has three steps:\n• None Sign the CSR request to create the certificate.\n\nAfter creating the SSL certificate, we’ll use it in a Python application when making API requests.\n\nAgain, always purchase an SSL certificate from an authorized certificate authority only. Many domain registrars include a free SSL certificate when you buy a domain from them.\n\nFor Linux users, likely, OpenSSLis already on your machine. However, if you don’t yet have it, then you can install it using your package manager. The following command installs OpenSSL in Debian and Ubuntu-based distributions:\n\nIf you're not sure if you already have OpenSSL installed on your machine, you can check by running the following command:\n\nIf you have it, you get the version number. But if you get an unrecognized command error after running the above command, you must install it.\n\nWe can create the private key with or without a protective passphrase. To add a passphrase, we simply use a cipher in the command, like .\n\nBoth options below are for generating a 2048-bit RSA private key, but the first option generates the key without a passphrase.\n\nCreating the CSR using the key\n\nIn this step, we use the private key generated in the previous step to generate a CSR. To do this, run the following command:\n\nYou must fill in some extra information about the certificate in the command line. Provide it, and press Enter when done.\n\nSigning the certificate with the key\n\nThe final step is to sign the request to create the certificate. Run the following command:\n\nHere, we're signing the certificate request with the same key used in creating it. This procedure explains why it’s called a “self-signed” certificate.\n\nYou can view the certificate details by running the following command:\n\nNow that we have successfully generated a self-signed certificate, we use it to create an HTTPS server that uses TLS encryption throughout its communication with a client.\n\nThe Python program below starts up an HTTPS server on your localhost at port 443.\n\nIn the code above, we imported the and . We then called the method on , passing in the server’s address and port number. Next, we wrapped the socket with SSL by specifying the path to our certificate in the method. Finally, we ran the server at the bottom of the file.\n\nTo connect a client, you can use the Python requests module to make a GET request to the server address:\n\nNote that the above code should be added to a different file from the server code. Running this should connect the client to the server and return a message:\n\nIn this article, we learned about TLS/SSL and the importance of having a valid digital certificate on our websites. We also saw how to verify SSL on a website by using the method.\n\nAfter that, we introduced the Python SSL library and walked through the process of creating and using a TLS/SSL secured web server in Python. We generated a self-signed certificate with OpenSSL and added the certificate to our HTTP socket connection before running the server.\n\nAs the volume of online transactions continues to grow, cybercrime will keep growing in scale and complexity. Using SSL certificates on our websites not only thwarts most attempts to hack your site but also helps make the site more trustworthy to visitors. Check out this article to learn more about why you should use HTTPS."
    },
    {
        "link": "https://docs.python.org/3/library/ssl.html",
        "document": "This module provides access to Transport Layer Security (often known as “Secure Sockets Layer”) encryption and peer authentication facilities for network sockets, both client-side and server-side. This module uses the OpenSSL library. It is available on all modern Unix systems, Windows, macOS, and probably additional platforms, as long as OpenSSL is installed on that platform.\n\nThis section documents the objects and functions in the module; for more general information about TLS, SSL, and certificates, the reader is referred to the documents in the “See Also” section at the bottom.\n\nThis module provides a class, , which is derived from the type, and provides a socket-like wrapper that also encrypts and decrypts the data going over the socket with SSL. It supports additional methods such as , which retrieves the certificate of the other side of the connection, , which retrieves the cipher being used for the secure connection or , which retrieves certificate chain.\n\nFor more sophisticated applications, the class helps manage settings and certificates, which can then be inherited by SSL sockets created through the method.\n\nSSL sockets provide the following methods of Socket Objects:\n• None , (but passing a non-zero argument is not allowed)\n• None , (with the same limitation) However, since the SSL (and TLS) protocol has its own framing atop of TCP, the SSL sockets abstraction can, in certain respects, diverge from the specification of normal, OS-level sockets. See especially the notes on non-blocking sockets. Instances of must be created using the method. Changed in version 3.5: The method was added. Changed in version 3.5: The does not reset the socket timeout each time bytes are received or sent. The socket timeout is now the maximum total duration of the shutdown. Deprecated since version 3.6: It is deprecated to create a instance directly, use to wrap a socket. Changed in version 3.7: instances must to created with . In earlier versions, it was possible to create instances directly. This was never documented or officially supported. Changed in version 3.10: Python now uses and internally. The functions support reading and writing of data larger than 2 GB. Writing zero-length data no longer fails with a protocol violation error. SSL sockets also have the following additional methods and attributes: Read up to len bytes of data from the SSL socket and return the result as a instance. If buffer is specified, then read into the buffer instead, and return the number of bytes read. Raise or if the socket is non-blocking and the read would block. As at any time a re-negotiation is possible, a call to can also cause write operations. Changed in version 3.5: The socket timeout is no longer reset each time bytes are received or sent. The socket timeout is now the maximum total duration to read up to len bytes. Deprecated since version 3.6: Use instead of . Write buf to the SSL socket and return the number of bytes written. The buf argument must be an object supporting the buffer interface. Raise or if the socket is non-blocking and the write would block. As at any time a re-negotiation is possible, a call to can also cause read operations. Changed in version 3.5: The socket timeout is no longer reset each time bytes are received or sent. The socket timeout is now the maximum total duration to write buf. Deprecated since version 3.6: Use instead of . The and methods are the low-level methods that read and write unencrypted, application-level data and decrypt/encrypt it to encrypted, wire-level data. These methods require an active SSL connection, i.e. the handshake was completed and was not called. Normally you should use the socket API methods like and instead of these methods. Changed in version 3.4: The handshake method also performs when the attribute of the socket’s is true. Changed in version 3.5: The socket timeout is no longer reset each time bytes are received or sent. The socket timeout is now the maximum total duration of the handshake. Changed in version 3.7: Hostname or IP address is matched by OpenSSL during handshake. The function is no longer used. In case OpenSSL refuses a hostname or IP address, the handshake is aborted early and a TLS alert message is sent to the peer. If there is no certificate for the peer on the other end of the connection, return . If the SSL handshake hasn’t been done yet, raise . If the parameter is , and a certificate was received from the peer, this method returns a instance. If the certificate was not validated, the dict is empty. If the certificate was validated, it returns a dict with several keys, amongst them (the principal for which the certificate was issued) and (the principal issuing the certificate). If a certificate contains an instance of the Subject Alternative Name extension (see RFC 3280), there will also be a key in the dictionary. The and fields are tuples containing the sequence of relative distinguished names (RDNs) given in the certificate’s data structure for the respective fields, and each RDN is a sequence of name-value pairs. Here is a real-world example: If the parameter is , and a certificate was provided, this method returns the DER-encoded form of the entire certificate as a sequence of bytes, or if the peer did not provide a certificate. Whether the peer provides a certificate depends on the SSL socket’s role:\n• None for a client SSL socket, the server will always provide a certificate, regardless of whether validation was required;\n• None for a server SSL socket, the client will only provide a certificate when requested by the server; therefore will return if you used (rather than or ). Changed in version 3.2: The returned dictionary includes additional items such as and . Changed in version 3.4: is raised when the handshake isn’t done. The returned dictionary includes additional X509v3 extension items such as , and URIs. Changed in version 3.9: IPv6 address strings no longer have a trailing new line. Returns verified certificate chain provided by the other end of the SSL channel as a list of DER-encoded bytes. If certificate verification was disabled method acts the same as . Returns raw certificate chain provided by the other end of the SSL channel as a list of DER-encoded bytes. Returns a three-value tuple containing the name of the cipher being used, the version of the SSL protocol that defines its use, and the number of secret bits being used. If no connection has been established, returns . Return the list of ciphers available in both the client and server. Each entry of the returned list is a three-value tuple containing the name of the cipher, the version of the SSL protocol that defines its use, and the number of secret bits the cipher uses. returns if no connection has been established or the socket is a client socket. Return the compression algorithm being used as a string, or if the connection isn’t compressed. If the higher-level protocol supports its own compression mechanism, you can use to disable SSL-level compression. Get channel binding data for current connection, as a bytes object. Returns if not connected or the handshake has not been completed. The cb_type parameter allow selection of the desired channel binding type. Valid channel binding types are listed in the list. Currently only the ‘tls-unique’ channel binding, defined by RFC 5929, is supported. will be raised if an unsupported channel binding type is requested. Return the protocol that was selected during the TLS handshake. If was not called, if the other party does not support ALPN, if this socket does not support any of the client’s proposed protocols, or if the handshake has not happened yet, is returned. Return the higher-level protocol that was selected during the TLS/SSL handshake. If was not called, or if the other party does not support NPN, or if the handshake has not yet happened, this will return . Deprecated since version 3.10: NPN has been superseded by ALPN Performs the SSL shutdown handshake, which removes the TLS layer from the underlying socket, and returns the underlying socket object. This can be used to go from encrypted operation over a connection to unencrypted. The returned socket should always be used for further communication with the other side of the connection, rather than the original socket. Requests post-handshake authentication (PHA) from a TLS 1.3 client. PHA can only be initiated for a TLS 1.3 connection from a server-side socket, after the initial TLS handshake and with PHA enabled on both sides, see . The method does not perform a cert exchange immediately. The server-side sends a CertificateRequest during the next write event and expects the client to respond with a certificate on the next read event. If any precondition isn’t met (e.g. not TLS 1.3, PHA not enabled), an is raised. Only available with OpenSSL 1.1.1 and TLS 1.3 enabled. Without TLS 1.3 support, the method raises . Return the actual SSL protocol version negotiated by the connection as a string, or if no secure connection is established. As of this writing, possible return values include , , , and . Recent OpenSSL versions may define more return values. Returns the number of already decrypted bytes available for read, pending on the connection. The object this SSL socket is tied to. A boolean which is for server-side sockets and for client-side sockets. Hostname of the server: type, or for server-side socket or if the hostname was not specified in the constructor. Changed in version 3.7: The attribute is now always ASCII text. When is an internationalized domain name (IDN), this attribute now stores the A-label form ( ), rather than the U-label form ( ). The for this SSL connection. The session is available for client and server side sockets after the TLS handshake has been performed. For client sockets the session can be set before has been called to reuse a session.\n\nCertificates in general are part of a public-key / private-key system. In this system, each principal, (which may be a machine, or a person, or an organization) is assigned a unique two-part encryption key. One part of the key is public, and is called the public key; the other part is kept secret, and is called the private key. The two parts are related, in that if you encrypt a message with one of the parts, you can decrypt it with the other part, and only with the other part. A certificate contains information about two principals. It contains the name of a subject, and the subject’s public key. It also contains a statement by a second principal, the issuer, that the subject is who they claim to be, and that this is indeed the subject’s public key. The issuer’s statement is signed with the issuer’s private key, which only the issuer knows. However, anyone can verify the issuer’s statement by finding the issuer’s public key, decrypting the statement with it, and comparing it to the other information in the certificate. The certificate also contains information about the time period over which it is valid. This is expressed as two fields, called “notBefore” and “notAfter”. In the Python use of certificates, a client or server can use a certificate to prove who they are. The other side of a network connection can also be required to produce a certificate, and that certificate can be validated to the satisfaction of the client or server that requires such validation. The connection attempt can be set to raise an exception if the validation fails. Validation is done automatically, by the underlying OpenSSL framework; the application need not concern itself with its mechanics. But the application does usually need to provide sets of certificates to allow this process to take place. Python uses files to contain certificates. They should be formatted as “PEM” (see RFC 1422), which is a base-64 encoded form wrapped with a header line and a footer line: The Python files which contain certificates can contain a sequence of certificates, sometimes called a certificate chain. This chain should start with the specific certificate for the principal who “is” the client or server, and then the certificate for the issuer of that certificate, and then the certificate for the issuer of that certificate, and so on up the chain till you get to a certificate which is self-signed, that is, a certificate which has the same subject and issuer, sometimes called a root certificate. The certificates should just be concatenated together in the certificate file. For example, suppose we had a three certificate chain, from our server certificate to the certificate of the certification authority that signed our server certificate, to the root certificate of the agency which issued the certification authority’s certificate: If you are going to require validation of the other side of the connection’s certificate, you need to provide a “CA certs” file, filled with the certificate chains for each issuer you are willing to trust. Again, this file just contains these chains concatenated together. For validation, Python will use the first chain it finds in the file which matches. The platform’s certificates file can be used by calling , this is done automatically with . Often the private key is stored in the same file as the certificate; in this case, only the parameter to needs to be passed. If the private key is stored with the certificate, it should come before the first certificate in the certificate chain: If you are going to create a server that provides SSL-encrypted connection services, you will need to acquire a certificate for that service. There are many ways of acquiring appropriate certificates, such as buying one from a certification authority. Another common practice is to generate a self-signed certificate. The simplest way to do this is with the OpenSSL package, using something like the following: The disadvantage of a self-signed certificate is that it is its own root certificate, and no one else will have it in their cache of known (and trusted) root certificates.\n\nTo test for the presence of SSL support in a Python installation, user code should use the following idiom: # do something that requires SSL support This example creates a SSL context with the recommended security settings for client sockets, including automatic certificate verification: If you prefer to tune security settings yourself, you might create a context from scratch (but beware that you might not get the settings right): The protocol configures the context for cert validation and hostname verification. is set to and is set to . All other protocols create SSL contexts with insecure defaults. When you use the context to connect to a server, and validate the server certificate: it ensures that the server certificate was signed with one of the CA certificates, checks the signature for correctness, and verifies other properties like validity and identity of the hostname: You may then fetch the certificate: Visual inspection shows that the certificate does identify the desired service (that is, the HTTPS host ): Now the SSL channel is established and the certificate verified, you can proceed to talk with the server: See the discussion of Security considerations below. For server operation, typically you’ll need to have a server certificate, and private key, each in a file. You’ll first create a context holding the key and the certificate, so that clients can check your authenticity. Then you’ll open a socket, bind it to a port, call on it, and start waiting for clients to connect: When a client connects, you’ll call on the socket to get the new socket from the other end, and use the context’s method to create a server-side SSL socket for the connection: Then you’ll read data from the and do something with it till you are finished with the client (or the client is finished with you): # empty data means the client is finished with us # when we're finished with client And go back to listening for new client connections (of course, a real server would probably handle each client connection in a separate thread, or put the sockets in non-blocking mode and use an event loop).\n\nEver since the SSL module was introduced in Python 2.6, the class has provided two related but distinct areas of functionality: The network IO API is identical to that provided by , from which also inherits. This allows an SSL socket to be used as a drop-in replacement for a regular socket, making it very easy to add SSL support to an existing application. Combining SSL protocol handling and network IO usually works well, but there are some cases where it doesn’t. An example is async IO frameworks that want to use a different IO multiplexing model than the “select/poll on a file descriptor” (readiness based) model that is assumed by and by the internal OpenSSL socket IO routines. This is mostly relevant for platforms like Windows where this model is not efficient. For this purpose, a reduced scope variant of called is provided. A reduced-scope variant of representing an SSL protocol instance that does not contain any network IO methods. This class is typically used by framework authors that want to implement asynchronous IO for SSL through memory buffers. This class implements an interface on top of a low-level SSL object as implemented by OpenSSL. This object captures the state of an SSL connection but does not provide any network IO itself. IO needs to be performed through separate “BIO” objects which are OpenSSL’s IO abstraction layer. This class has no public constructor. An instance must be created using the method. This method will create the instance and bind it to a pair of BIOs. The incoming BIO is used to pass data from Python to the SSL protocol instance, while the outgoing BIO is used to pass data the other way around. The following methods are available: When compared to , this object lacks the following features:\n• None Any form of network IO; and read and write only to the underlying buffers.\n• None There is no do_handshake_on_connect machinery. You must always manually call to start the handshake.\n• None There is no handling of suppress_ragged_eofs. All end-of-file conditions that are in violation of the protocol are reported via the exception.\n• None The method call does not return anything, unlike for an SSL socket where it returns the underlying socket.\n• None The server_name_callback callback passed to will get an instance instead of a instance as its first parameter. Some notes related to the use of :\n• None All IO on an is non-blocking. This means that for example will raise an if it needs more data than the incoming BIO has available. Changed in version 3.7: instances must be created with . In earlier versions, it was possible to create instances directly. This was never documented or officially supported. An SSLObject communicates with the outside world using memory buffers. The class provides a memory buffer that can be used for this purpose. It wraps an OpenSSL memory BIO (Basic IO) object: A memory buffer that can be used to pass data between Python and an SSL protocol instance. Return the number of bytes currently in the memory buffer. A boolean indicating whether the memory BIO is current at the end-of-file position. Read up to n bytes from the memory buffer. If n is not specified or negative, all bytes are returned. Write the bytes from buf to the memory BIO. The buf argument must be an object supporting the buffer protocol. The return value is the number of bytes written, which is always equal to the length of buf. Write an EOF marker to the memory BIO. After this method has been called, it is illegal to call . The attribute will become true after all data currently in the buffer has been read."
    },
    {
        "link": "https://stackoverflow.com/questions/26851034/opening-a-ssl-socket-connection-in-python",
        "document": "I'm trying to establish a secure socket connection in Python, and i'm having a hard time with the SSL bit of it. I've found some code examples of how to establish a connection with SSL, but they all involve key files. The server i'm trying to connect with doesn't need to receive any keys or certificates. My question is how do I essentially wrap a python socket connection with SSL. I know for a fact that the cipher i'm suppose to use is , and the protocol is . This is what i've been trying:\n\nWhen I run this code, I don't get any errors, but I get a blank response. When trying to debug this code in the command line, by typing in in the terminal and pasting in code line by line, I get what i'm assuming is a status code when running . The integer response I get is . If anyone knows what this means, or can help in anyway it would be greatly appreciated."
    },
    {
        "link": "https://stackoverflow.com/questions/23391850/python-requests-library-get-ssl-certificate-information",
        "document": "I'm looking for a way to get to the information about SSL certificate used by the remote site using requests (CA and CN would suffice).\n\nI can easily get those when I use for example socket + OpenSSL, but in my code I use a special resolver ( Python 'requests' library - define specific DNS? ), so I need to use Requests or urllib2 - so far I examined most of the requests code through inspect module, and I see no way of getting to these values.\n\nI'd appreciate any hints at this point, maybe I'm missing something obvious :)\n\nTo be more precise - I'm patching part of the requests lib (from 'socket' up to urllib2), to use a custom name resolver- it comes down to this:\n\nmy_opener.open(url) returns an urllib.addinfourl object - from which I would need to extract certificate info if that's at all posible.\n\nUnfortunately this is not the case for the question after which this one was marked as a duplicate."
    },
    {
        "link": "https://geeksforgeeks.org/how-to-install-and-use-ssl-certificate-in-python",
        "document": "How to Install and use SSL Certificate In Python\n\nA secure Socket Layer (SSL) Certificate is a Digital certificate that can be used for the authentication of a website and it helps to establish an encrypted connection between the user and server. SSL is a secure layer that creates an encrypted link between a web server and a web browser. SSL keeps internet connections secure. When an SSL certificate is installed on the website it becomes HTTP to HTTPS, which is more secure. SSL is also called TLS.\n\nThere are different types of SSL certificates with different validation levels. The six main types are:\n• Authentication: An SSL certificate will verify that a user is connecting to the correct server.\n• Encryption: SSL will ensure that the connection between the user and the server must be encrypted.\n• HTTPS: It is a combination of the HTTP with the Secure Socket Layer (SSL)/Transport Layer Security (TLS) protocol.\n• TLS: It is an authentication and security protocol widely implemented in browsers and Web servers.\n\nPreinstalled Python environment can be downloaded from python.org. To install python on Windows/Mac/Linux refer to:\n\nStep 1: Press the Start button and then Type CMD to Select Command Prompt from the list. When we open the command prompt then a screen like this will appear on the computer.\n\nStep 2: Type the given below command on the command prompt and then press enter button.\n\nIn case the previous command will not work then type the given below command and then press enter button.\n\nStep 2: Type the given below command on the terminal and then press enter button.\n\nStep 3: In case if the previous command will not work then type the given below command and then press enter button.\n\nThe certifi.where() is a function that helps us find the information of the installed certificate authority (CA) in Python."
    },
    {
        "link": "https://snyk.io/blog/implementing-tls-ssl-python",
        "document": "Nowadays, we do virtually everything online: book flights, pay for goods, transfer bank funds, message friends, store documents, and so on. Many things we do require giving out sensitive information like our credit card details and banking information. If a website uses an unsecured network, a malicious hacker can easily steal user information. This is why encryption is so important.\n\nThe transport layer security (TLS) protocol is the ultimate safeguard of user information on websites and web applications. TLS uses a hard-to-crack cryptographic algorithm that ensures that no one other than the web server and web client can read or modify transmitted data.\n\nIn this article, we’ll explore TLS and how to use Python to check for a website’s TLS certificate validity. Then, we’ll walk through the steps for adding TLS to your Python application on Linux.\n\nThe TLS protocol, the successor of the secure socket layer (SSL) protocol, protects data using encryption. When users send their information to a website, TLS encrypts it before sending it. Then, only the server with the same public key as the client can open the message. This rule also applies when the server sends information back to the client. Only the client with the corresponding key can read the data.\n\nFor a website to use TLS protocol, you must install a valid TLS/SSL certificate (often called an SSL certificate). When you install the certificate, it upgrades the website from HTTP to HTTPS, a more secure transfer protocol. The certificate is a data file that contains the website’s identity and the public key for opening payload messages.\n\nAn SSL certificate must be valid to work. This means that not only must a credible certificate authority (CA) sign it, but the certificate also must be active. Every certificate has an issuance date and an expiration date. A certificate is no longer valid after its expiration date.\n\nWebsites without a valid SSL certificate have few visible indicators. For one, the URL in the address bar uses the prefix instead of . Additionally, there is no lock icon — which browsers use to indicate a secure site — next to the URL. Be cautious about what you share if you notice either of these signs.\n\nNow that we’ve explored TLS-over-SSL (TLS/SSL), let’s see how to implement it using Python.\n\nWhen building a web server with Python, it’s crucial to know how to add TLS/SSL to our application. Before we learn how to do so, let’s see how to use Python to verify the validity of a website’s SSL certificate.\n\nIf we want to check the validity of a website’s SSL certificate, we can easily do so by running a Python script like this:\n\nThe code above imports the Python module and uses it to make a request to the Twitter website. (To run the script, you must install the module in Python using pip). We can replace Twitter’s URL with the URL of the website whose SSL certificate we want to verify. The variable stores the received value, which the code prints on the last line.\n\nWhen we execute the code, we get a message, meaning that the Twitter site is using a valid SSL certificate (as expected).\n\nNow, we execute a request to another website. This time we use a website that we know lacks a valid SSL certificate.\n\nThis time, we receive an error stating that the certificate verification process failed:\n\nWe use the Python SSL library to provide TLS encryption in socket-based communication between Python clients and servers. It uses cryptography and message digests to secure data and detect alteration attempts in the network. Digital certificates provide authentication.\n\nThe SSL library supports Windows, macOS, and other modern UNIX systems. It also requires OpenSSL to work.\n\nToward the end of this article, we’ll use the Python SSL library to wrap our connection-based socket with the SSL certificate we generate in the following section.\n\nNow that we know how to verify the validity of TLS/SSL on a website, let’s see how we can use it on a Python web server.\n\nWe can quickly generate and use a free self-signed certificate for local development. However, if we intend to deploy the site or app on the internet, we must purchase an SSL certificate from a trusted domain registrar (like GoDaddy and NameCheap).\n\nThe process of self-generating an SSL certificate for our local Python application has three steps:\n• None Sign the CSR request to create the certificate.\n\nAfter creating the SSL certificate, we’ll use it in a Python application when making API requests.\n\nAgain, always purchase an SSL certificate from an authorized certificate authority only. Many domain registrars include a free SSL certificate when you buy a domain from them.\n\nFor Linux users, likely, OpenSSLis already on your machine. However, if you don’t yet have it, then you can install it using your package manager. The following command installs OpenSSL in Debian and Ubuntu-based distributions:\n\nIf you're not sure if you already have OpenSSL installed on your machine, you can check by running the following command:\n\nIf you have it, you get the version number. But if you get an unrecognized command error after running the above command, you must install it.\n\nWe can create the private key with or without a protective passphrase. To add a passphrase, we simply use a cipher in the command, like .\n\nBoth options below are for generating a 2048-bit RSA private key, but the first option generates the key without a passphrase.\n\nCreating the CSR using the key\n\nIn this step, we use the private key generated in the previous step to generate a CSR. To do this, run the following command:\n\nYou must fill in some extra information about the certificate in the command line. Provide it, and press Enter when done.\n\nSigning the certificate with the key\n\nThe final step is to sign the request to create the certificate. Run the following command:\n\nHere, we're signing the certificate request with the same key used in creating it. This procedure explains why it’s called a “self-signed” certificate.\n\nYou can view the certificate details by running the following command:\n\nNow that we have successfully generated a self-signed certificate, we use it to create an HTTPS server that uses TLS encryption throughout its communication with a client.\n\nThe Python program below starts up an HTTPS server on your localhost at port 443.\n\nIn the code above, we imported the and . We then called the method on , passing in the server’s address and port number. Next, we wrapped the socket with SSL by specifying the path to our certificate in the method. Finally, we ran the server at the bottom of the file.\n\nTo connect a client, you can use the Python requests module to make a GET request to the server address:\n\nNote that the above code should be added to a different file from the server code. Running this should connect the client to the server and return a message:\n\nIn this article, we learned about TLS/SSL and the importance of having a valid digital certificate on our websites. We also saw how to verify SSL on a website by using the method.\n\nAfter that, we introduced the Python SSL library and walked through the process of creating and using a TLS/SSL secured web server in Python. We generated a self-signed certificate with OpenSSL and added the certificate to our HTTP socket connection before running the server.\n\nAs the volume of online transactions continues to grow, cybercrime will keep growing in scale and complexity. Using SSL certificates on our websites not only thwarts most attempts to hack your site but also helps make the site more trustworthy to visitors. Check out this article to learn more about why you should use HTTPS."
    }
]