[
    {
        "link": "https://docs.minecraftforge.net",
        "document": "This is the official documentation for MinecraftForge, the Minecraft modding API.\n\nThis documentation is only for Forge, this is not a Java tutorial.\n\nIf you would like to contribute to the docs, read Contributing to the Docs."
    },
    {
        "link": "https://nekoyue.github.io/ForgeJavaDocs-NG/javadoc/1.16.5/net/minecraftforge/client/event/RenderWorldLastEvent.html",
        "document": "JavaScript is disabled on your browser."
    },
    {
        "link": "https://docs.minecraftforge.net/en/1.16.x",
        "document": "This is the official documentation for MinecraftForge, the Minecraft modding API.\n\nThis documentation is only for Forge, this is not a Java tutorial.\n\nContribute to the docs at GitHub."
    },
    {
        "link": "https://reddit.com/r/feedthebeast/comments/4dsrfo/where_is_the_forge_documentation",
        "document": ""
    },
    {
        "link": "https://nekoyue.github.io/ForgeJavaDocs-NG/javadoc/1.16.5",
        "document": "JavaScript is disabled on your browser."
    },
    {
        "link": "http://jabelarminecraft.blogspot.com/p/minecraft-forge-172-quick-tips-gl11-and.html",
        "document": "How Models For Blocks And Items Load\n\nChanging (Overriding) The 3D Model Of An Item Based On A Property\n\nYou may find a situation where you want an item to look different depending on some property that changes. For example, you could have a bottle that fills up, or a wearable computer (like a FitBit) that displays different information and so forth.\n\nLike all modding, when trying to do something you should first look at something similar in vanilla Minecraft. In this case, a ItemCompass is a good example of an item that changes how it looks based on a property (in this case the \" \").\n\nThe general approach is as follows:\n\nIn your custom item class constructor, call the method that maps the property name to a new with an inline declaration that implements the method to return the valid set of property values.\n\nThe method takes in an , and parameter. In most cases you'll probably just look at the 's NBT data but for example the compass also checks to make sure the world is a surface world and also uses the entity (the entity passed in is the one holding the item stack) to calculate the angle.\n\nFor a simple example refer to which has a simple property for \" \" which is true or false. For a more complex example refer to the which has a large set of \" \" values.\n\n\n\n Create a master model JSON file placed in the item model resources folder. This JSON should use the \" \" parent and use the \" \" tag to map the properties to other JSON files containing the actual models. For example, the compass.json file contains:\n\nCreate the model JSON files for all the variations pointed to by the master model JSON. In the example above you'd create the and such. These can be any regular type of item model.\n\nStep 4 - Use The Property In Your Game\n\nChange the property value in the game as needed. Basically the method will be called automatically during rendering so you just need to make sure that the information necessary for the method is passed in.\n\nFor example, in the method checks the damage of the ItemStack to determine whether the property should return as \" \".\n\nthe method checks that the world is surface world and checks the entity direction to adjust the compass angle, including adding some \"wobble\" to the compass to make it more realistic.\n\nBasically, the method can take information from the passed in parameters (like NBT data on the ) but also access instance methods in your custom class as well as any other public methods. So you could change the item model based on configurations, entity capabilities, etc. Pretty much wide open! Have fun!\n\nGood Tutorial On How Transparency And Blending Works\n\nIt is common for modders to want to change the \"camera\" position. In other words, show a view from the world from a different position and/or angle. For example, you could add a \"roll\" effect while doing a flying mod, or you could shake the camera for an earthquake.\n\n\n\n Thanks to jajo_11 for this tip.\n\nIn this example, I'll create a sphere around a custom entity. The sphere will be partially transparent, and if you enter the sphere you'll be able to see it from the inside as well (this is important point because extra work is required to make that happen).\n\nSince in Minecraft rendering is client side only, it is good idea to make the sphere call lists in the client proxy.\n\nFirst we need to add two integer fields that will reference the id of the call list for the outside and inside of the sphere. Something like this in your client proxy class:\n\nThen, in your method that handles the init FML life cycle, you should have something like this to generate the call lists:\n\n \n\n\n\n\n\n Now, we'll be able to invoke these spheres during rendering. \n\n \n\n The texture you reference with the should generally be a solid square of color without any transparent portions, but you should try textures and patterns if you think it is better for your mod. I choose a purple color and just filled in a square then saved as PNG. You need to make sure you put the texture asset in the same place referenced in the .\n\n \n\n For a custom entity you should have a custom class registered for the entity. In that custom class, you can overrride the method which is intended for these extra rendering effects (it is automatically called for all entities). So something like this:\n\n \n\n\n\nEnsuring Custom Entity Renders If Partially Out Of View\n\nDraw The Texture Of An Item\n\n\n\n See my \n\n \n\n \n\n G11 works on a stack and so you can easily lose track of the applied methods if you forget to pop the stack, letting previous setting \"bleed\" into later code and causing unexpected effects. Therefore it can be useful to report all GL11 settings in effect at a given point in time.\n\n \n\n Here is a utility written by TheGreyGhost and previously posted on github (although link now shows file not found). Since he offered it before, I hope he doesn't mind if I post it here. The idea is simple, but credit to him for taking the time to type it all out.\n\n \n\n Tip: You can add this class to your mod and call the method at points in your code where you're debugging GL11.\n\n \n\n \n\n GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 \"Depth range near and far\" GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 \"Number of bits of subpixel precision in x and y\" GL11 \"See discussion in Texture Proxy in Chapter 9\" GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 \"True if left and right buffers exist\" GL11 GL11 GL11 GL11 GL11 \"Number of bits per red component in color buffers\" GL11 \"Number of bits per green component in color buffers\" GL11 \"Number of bits per blue component in color buffers\" GL11 \"Number of bits per alpha component in color buffers\" GL11 \"Number of bits per index in color buffers\" GL11 GL11 GL11 \"Number of bits per red component in the accumulation buffer\" GL11 \"Number of bits per green component in the accumulation buffer\" GL11 \"Number of bits per blue component in the accumulation buffer\" GL11 \"Number of bits per alpha component in the accumulation buffer\" GL11 GL11 \"Number of display list under construction; 0 if none\" GL11 \"Mode of display list under construction; undefined if none\" GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 GL11 i i instance i \n\n See my modding tips for Items G11 works on a stack and so you can easily lose track of the applied methods if you forget to pop the stack, letting previous setting \"bleed\" into later code and causing unexpected effects. Therefore it can be useful to report all GL11 settings in effect at a given point in time.Here is a utility written byand previously posted on github (although link now shows file not found). Since he offered it before, I hope he doesn't mind if I post it here. The idea is simple, but credit to him for taking the time to type it all out.: You can add this class to your mod and call themethod at points in your code where you're debugging GL11.\n\nLike all 3D games, there is a need for \"models\" that describe the shape of the various things that should be displayed, and \"renderers\" that actually convert the shape into something visible.Note thatuses Light-Weight Java Graphics Library (LWJGL) interface also called GL11, so inside rendering classes you can apply related operations and transformations to modify the rendering.Historically, there are various types of models and rendering options available. In the most original format, the models were simply a collection of cubes that could be rotated and textured to create the classicalblocky look. However, since then the approach has changed to allow more complex model formats (like those used by computer graphics programs), as well as animations and state-based rendering.I cover a few tips here, but it is a broad topic for which you may need to do further Googling.has a good explanation in his github documentation The block model format approach has changed over the various versions ofand this causes a great amount of work when upgrading your mod, and it greatly complicated making animated models. An explanation of the evolution of the block model approach is described well byin his Rendering Primer Thanks tofor this information.has an animation system for baked models in thepackage, though there's not a lot of documentation on it.briefly described the purpose of each class in the commit that introduced the system . They've also documented the grammar of the Animation State Machine files here.has a test mod for the system here This tutorial gives a thorough explanation of GL11 and alpha blending.See a detailed explanation: TheGreyGhost's Transparent Block Tutorial There is a good tutorial here: Schwarzeszeux's Modeling Tutorial In your entity model'sfunction you can use GL11 methods to scale the model before rendering. However, since the model origin is at 1.5 blocks above the ground, if you just scale the feet of your model will go into the ground if you scale bigger and will float above the ground if you scale smaller. So you need to also use GL11 to translate the method.Also, you need to create a GL11 matrix for this with themethod, and need to make sure tothe matrix when done.Putting it all together, the code should look something like this:In computer systems, color is often represented as \"RGB\" (Red-Green-Blue) which is the additive colors that can be used to combine to create all colors. In hexadecimal it is usually shown as an 8-digit number, with each two digits representing the amount of red, green and blue respectively. The higher the number the more of the color is present, and since the color is additive it also gets lighter. So black isis the way Java indicates a number is in hexadecimal format), white is, medium red is, and a brown might be. Check out this page of RGB colors to better understand.has a class calledthat is used within. Buffered image has a method calledwhere you specify the x and y coordinates (starting in top-left) and it returns the RGB int value.already has certain images and textures ininstances, but if you want to load a file into ayou can use thefunction where you pass theparameter which can be PNG, JPG, etc. Check out my tutorial on file and resources for more information.: Inmost texture information is only on the client side. If you want the server to react or control textures then you will need to use custom packets to communicate between client and server.To understand the code, it is best to read up on the G11 API The important methods to understand are the, which in this case we're making 3 times bigger than standard block. You can change the values to get the size you want.Theis blending white (meaning no change in color) with alpha (transparency) of. You can play with the alpha value to get the effect you want.You can see we usefor both the outside and inside sphere.It is very easy to get health bar. First, you should just have your mob implement tgeinterface (just put \"\" on your class declaration.Secondly, in the customclass for your mob, in themethod you should put \"\" where you replace \"\" with the field that represents the entity parameter passed to themethod.In computer graphics, it usually doesn't make sense to process things that are outside the field of view. The space that represents a clipped pyramid of view is called the \" frustum \". The process of deciding whether something is inside the frustum (and should be rendered) is called frustum culling.In, whether and entity is considered inside the frustum is based on the bounding box of the entity (in themethod in theclass). This causes a problem with large entities or unusual custom entities though because the model of an entity might extend well beyond the bounding box -- imagine a tail of a dinosaur that has the collision box just on its body. This causes a visual problem because if the entity goes to the edge of the view it will seem to suddenly disappear when the bounding box goes off screen even if other parts of the model could still be rendered on screen.Therefore, entities have a public boolean field called. This should be set tofor those entities that have models that extend significantly beyond the bounding box of the entity."
    },
    {
        "link": "https://forums.minecraftforge.net/topic/24213-some-things-behind-semi-transparent-model-render-strangely-17-unsolved",
        "document": "I am working on a pipe that will transport items (like ItemDucts or Buildcrafts pipes, I haven't actually got to the actual item transport part yet, I am just working on rendering today) and I have decided to make the sides transparent so that you can see the items inside. I have successfully achieved this, but unfortunately, there is some weird rendering of the world behind it. Full blocks are fine, but anything else (for some reason, excluding lava) isn't rendered, so this includes water, and any other models. Here are some screenshots to illustrate what I mean: As you can see, the water behind, and my wind turbine model aren't getting rendered behind the transparent part of the pipe. There are also some transparent bits inside the pipe when looked at as some angles (seen in pic 1) My current code for rendering this is this: This is only my renderTileEntityAt method, I do no other lighting, blending, or colouring stuff in any of the other methods being called. public void renderTileEntityAt(TileEntity tile, double x, double y, double z, float f) { int meta = 0; if (tile instanceof TileEntityCable) meta = tile.getBlockMetadata(); if (tile instanceof TileEntityPipe) meta = tile.getBlockMetadata() + 8; // add 8 because cables have 8 subtypes, and for the pipes, the first resource is 8 after the cables first resource. GL11.glPushMatrix(); GL11.glTranslated(x, y, z); GL11.glScalef(0.5F, 0.5F, 0.5F); GL11.glTranslatef(1.0F, 0.0F, 1.0F); GL11.glDisable(GL11.GL_LIGHTING); //Calling all the render methods from here with the model and texture specified above. if (this.resource[meta][4] != null) { this.bindTexture(resource[meta][4]); { GL11.glEnable(GL11.GL_BLEND); GL11.glColor4f(1.0F, 1.0F, 1.0F, 1.0F); GL11.glBlendFunc(GL11.GL_SRC_ALPHA, GL11.GL_ONE_MINUS_SRC_ALPHA); if (tile instanceof TileEntityCable) { TileEntityCable connectable = (TileEntityCable) tile; for (int i = 0; i < 6; i++) { //System.out.println(\"Connections \" + i + \" = \" + connectable.connections[i] + \" in Cable\"); } if ((!connectable.hasOppositeConnection(connectable.connections))) { if (this.model[meta][0] != null) this.drawCore(meta); } else if (this.model[meta][1] != null) { if (connectable.connections[0] != null) this.drawStraightCore(meta, ForgeDirection.UP); if (connectable.connections[2] != null) this.drawStraightCore(meta, ForgeDirection.NORTH); if (connectable.connections[4] != null) this.drawStraightCore(meta, ForgeDirection.WEST); } for (int i = 0; i < connectable.connections.length; i++) { if (connectable.connections[i] != null) { if (this.model[meta][3] != null) drawConnection(meta, connectable.connections[i], tile.xCoord, tile.yCoord, tile.zCoord, tile); //Drawing and rendering a new connection model for each connected side specified by the tileentity } } } if (tile instanceof TileEntityPipe) { TileEntityPipe connectable = (TileEntityPipe) tile; for (int i = 0; i < 6; i++) { //System.out.println(\"Connections \" + i + \" = \" + connectable.connections[i] + \" in Cable\"); } if ((!connectable.hasOppositeConnection(connectable.connections))) { if (this.model[meta][0] != null) this.drawCore(meta); } else if (this.model[meta][1] != null) { if (connectable.connections[0] != null) this.drawStraightCore(meta, ForgeDirection.UP); if (connectable.connections[2] != null) this.drawStraightCore(meta, ForgeDirection.NORTH); if (connectable.connections[4] != null) this.drawStraightCore(meta, ForgeDirection.WEST); } for (int i = 0; i < connectable.connections.length; i++) { if (connectable.connections[i] != null) { if (this.model[meta][3] != null) drawConnection(meta, connectable.connections[i], tile.xCoord, tile.yCoord, tile.zCoord, tile); //Drawing and rendering a new connection model for each connected side specified by the tileentity } } } GL11.glDisable(GL11.GL_BLEND); } } GL11.glEnable(GL11.GL_LIGHTING); GL11.glPopMatrix(); } Note: This renderer class does handle all of my connecting blocks, and the one that is transparent uses metadata 8, metadata 0 to 7 are all of my cables, and have no problems. Any suggestions on how to fix this? I ask complicated questions, and apparently like to write really long detailed posts. But I also help others when I can.\n\nIt looks to me like the ol' rendering-order-is-important-for-alpha-blended-blocks problem. Your alpha-blended pane is drawing before the water, and it is also writing to the depth buffer. So when the water is drawn afterwards, it is behind the pane and gets culled. You can turn off writing to the depth buffer while rendering your pane, using GL11.glDepthMask(false);, but that probably won't help much because then the water will render over the top of your pane which will probably look rather strange. The only way to correct this properly is to make sure that your panes are rendered last. Unfortunately this will only work when the pipe is the closest alpha-blended object to the player, so you will need to hope that your pipes are never placed behind another alpha-blended object. There may not be an easy answer unfortunately. It is for sure possible if you grasp deep into the rendering code to sort all the pass 1 rendering by depth. I'd suggest trying the depth mask fix or the render-last fix and seeing if you can live with one of them.\n\nTheGreyGhost already explained it. If you think about it, for the graphics engine to calculate the picture when there are transparent things in the background, the only trustworthy way is to draw the stuff in the background first then blend the transparent stuff on top. Imagine you were painting something and you did a light wash of color first (i.e. the transparent part) and then painted over it with thick paint, versus doing it the other way around -- doing a wash of color over thick paint. The results are not the same: the order matters. If you leave depth mask as true, then when it comes time to render the transparent stuff there is a chance that it has will be \"painted\" in the scene before something in the background and then when the background is checked it is considered \"behind\" the transparent part so is not rendered at all (this is called culling). If you disable depth mask with false, then it will render everything even if it was supposed to be behind. This can screw things up. The fundamental problem is that Minecraft should ideally render things in order based on depth, but instead does several passes. So your entity may be rendered before water, even if the water is farther back in the background. There isn't really an easy solution to this. You can however control the order of depth and rendering within your own rendering code. I don't know how your pipes are rendered, but you could theoretically draw the transparent parts and solid parts with and without depth checking as needed. Check out my tutorials here: http://jabelarminecraft.blogspot.com/\n\nOkay, I have solved the problem of things behind getting culled, or rendering on top of the pipe. SanAndreasP's suggestion worked, with some tweaking of my GL11 methods too. I also removed the getRenderPass() method from my block class. This is my updated renderTileEntityAt method: public void renderTileEntityAt(TileEntity tile, double x, double y, double z, float f) { int meta = 0; if (tile instanceof TileEntityCable) meta = tile.getBlockMetadata(); if (tile instanceof TileEntityPipe) meta = tile.getBlockMetadata() + 8; // add 8 because cables have 8 subtypes, and for the pipes, the first resource is 8 after the cables first resource. GL11.glPushMatrix(); GL11.glTranslated(x, y, z); GL11.glScalef(0.5F, 0.5F, 0.5F); GL11.glTranslatef(1.0F, 0.0F, 1.0F); GL11.glDisable(GL11.GL_LIGHTING); //Calling all the render methods from here with the model and texture specified above. //if (this.resource[meta][4] != null) { if (tile instanceof TileEntityCable) { TileEntityCable connectable = (TileEntityCable) tile; for (int i = 0; i < 6; i++) { //System.out.println(\"Connections \" + i + \" = \" + connectable.connections[i] + \" in Cable\"); } if (resource[meta][4] != null) this.bindTexture(resource[meta][4]); if ((!connectable.hasOppositeConnection(connectable.connections))) { if (this.model[meta][0] != null) this.drawCore(meta); } else if (this.model[meta][1] != null) { if (connectable.connections[0] != null) this.drawStraightCore(meta, ForgeDirection.UP); if (connectable.connections[2] != null) this.drawStraightCore(meta, ForgeDirection.NORTH); if (connectable.connections[4] != null) this.drawStraightCore(meta, ForgeDirection.WEST); } for (int i = 0; i < connectable.connections.length; i++) { if (connectable.connections[i] != null) { if (this.model[meta][3] != null) drawConnection(meta, connectable.connections[i], tile.xCoord, tile.yCoord, tile.zCoord, tile); //Drawing and rendering a new connection model for each connected side specified by the tileentity } } } if (tile instanceof TileEntityPipe) { TileEntityPipe connectable = (TileEntityPipe) tile; for (int i = 0; i < 6; i++) { //System.out.println(\"Connections \" + i + \" = \" + connectable.connections[i] + \" in Cable\"); } if (connectable.renderPass == 1) { GL11.glEnable(GL11.GL_BLEND); GL11.glEnable(GL11.GL_DEPTH_TEST); //System.out.println(\"test\"); GL11.glDepthMask(true); GL11.glColor4f(1.0F, 1.0F, 1.0F, 1.0F); this.renderTravelingItem(connectable, (float)x, (float)y, (float)z); GL11.glShadeModel(GL11.GL_SMOOTH); if (resource[meta][4] != null) this.bindTexture(resource[meta][4]); if ((!connectable.hasOppositeConnection(connectable.connections))) { if (this.model[meta][0] != null) this.drawCore(meta); } else if (this.model[meta][1] != null) { if (connectable.connections[0] != null) this.drawStraightCore(meta, ForgeDirection.UP); if (connectable.connections[2] != null) this.drawStraightCore(meta, ForgeDirection.NORTH); if (connectable.connections[4] != null) this.drawStraightCore(meta, ForgeDirection.WEST); } for (int i = 0; i < connectable.connections.length; i++) { if (connectable.connections[i] != null) { if (this.model[meta][3] != null) drawConnection(meta, connectable.connections[i], tile.xCoord, tile.yCoord, tile.zCoord, tile); //Drawing and rendering a new connection model for each connected side specified by the tileentity } } GL11.glEnable(GL11.GL_CULL_FACE); GL11.glDepthMask(false); GL11.glDisable(GL11.GL_BLEND); } } //} GL11.glEnable(GL11.GL_LIGHTING); GL11.glPopMatrix(); } Again, relevant code starts from \"if (tile instanceof TileEntityPipe)\", the rest is for my cables. This is now what it looks like: So, the water, and other things in the background look fine, they're rendered behind the pipe as they should be. Now there is another problem. You can also see in the screenshot, that the inside of the pipe itself looks slightly strange, there are bits of the inside that are missing, and this is only from certain angles, the missing bits move when looked at from another angle. I think they are getting culled, but I am not sure what by, and disabling culling makes it look weird again. Also, another problem, you can see in my code, I have commented out the line this.renderTravelingItem. This was also causing some of the rendering issues, the item renders fine, without any transparency issues, but is rendered behind the pipe. This is what happens when renderTravelingItem isn't commented out: The iron ingot is positioned inside the pipe, but is rendered behind the pipe. This is my travelling item method: public void renderTravelingItem(TileEntityPipe pipe, float x, float y, float z) { GL11.glPushMatrix(); GL11.glDisable(GL11.GL_LIGHTING); GL11.glDisable(GL11.GL_CULL_FACE); TravelingItem itemToRender1 = new TravelingItem(new ItemStack(Items.iron_ingot, 5), 0.0F, 0.0F, 0.0F, 0.05F); //Testing with an item TravelingItem itemToRender2 = new TravelingItem(new ItemStack(Blocks.stone, 5), 0.0F, 0.0F, 0.0F, 0.05F); //Testing with a block //List<TravelingItem> items = new ArrayList<TravelingItem>(); /*for (ItemStack s : pipe.getStoredItems()) { TravelingItem item = new TravelingItem(s, 0.0F, 0.0F, 0.0F, 0.05F); items.add(item); }*/ float scale = 1.25F; this.renderTravelingItem(itemToRender1, x, y, z, 0.05F, scale); GL11.glEnable(GL11.GL_CULL_FACE); GL11.glEnable(GL11.GL_LIGHTING); GL11.glPopMatrix(); } public void renderTravelingItem(TravelingItem item, float x, float y, float z, float speed, float scale) { //TravelingItem item = new TravelingItem(stack, x, y, z, speed); if (item == null || item.getStack() == null) { return; } ItemStack stack = item.getStack(); GL11.glPushMatrix(); GL11.glTranslatef(x, y, z); GL11.glTranslatef(0.5F, 0.9F, 0.5F); GL11.glScalef(scale, scale, scale); fakeItem.setEntityItemStack(stack); renderItem.doRender(fakeItem, 0.0D, 0.0D, 0.0D, 0.0F, 0.0F); GL11.glPopMatrix(); } And the TravelingItem class just stores the ItemStack, its position, and I will soon make it also store NBT data. So, one major problem is solved, but now there are two annoying problems to solve. I ask complicated questions, and apparently like to write really long detailed posts. But I also help others when I can.\n\n>Now there is another problem. You can also see in the screenshot, that the inside of the pipe itself looks slightly strange, there are bits of the inside that are missing, and this is only from certain angles, the missing bits move when looked at from another angle. This is probably the same rendering-order problem again. When you render your TileEntity, draw the rearmost faces first, i.e. the face that is furthest from the player. As the player moves around the pipe, the \"rearmost\" face will change. This might be difficult with a model; you may need to split the model into the six flat faces. > the item renders fine, without any transparency issues, but is rendered behind the pipe That's because you have turned off writing to the depth buffer during rendering of the item (GL11.glDepthMask(false); ), so when you draw the model, it draws over the top of your item since the depth buffer doesn't know the item is there. Just to check - do you understand the difference between"
    },
    {
        "link": "https://forums.minecraftforge.net/topic/16746-gl11-methods-to-create-lines",
        "document": "Does anyone know if there are any GL11 methods to create coloured lines that look somewhat like lasers?\n\nIf not how would i make one that looks like the build craft lasers?\n\nIm hoping its just say a gl11 draw line method or something."
    },
    {
        "link": "https://minecraftforum.net/forums/mapping-and-modding-java-edition/minecraft-mods/modification-development/2231761-opengl-calls-glstatemanager",
        "document": "1.8 (not beta!) adds a GlStateManager class, through which Minecraft now does all it's basic OpenGL calls. For example, instead of\n\n \n\n GL11.glBlendFunc(GL11.GL_SRC_ALPHA, GL11.GL_ONE_MINUS_SRC_ALPHA);\n\n Minecraft now calls\n\n GlStateManager.blendFunc(GL11.GL_SRC_ALPHA, GL11.GL_ONE_MINUS_SRC_ALPHA);\n\n \n\n What's the point? blendFunc() checks if the parameters are different from the last time it was called, and only actually makes the OpenGL call if the values are different. So if two calls to blendFunc have the same values, only one OpenGL call gets made.\n\n \n\n I'm not really sure that skipping the OpenGL call (one that doesn't actually change any values no less) saves more time than the conditional TBH, and if the states different, now instead of doing an OpenGL call, you are doing an OpenGL call PLUS a conditional, so in those cases it's actually more expensive. I hope they roll this back, and here's why :\n\nthis actually makes a good difference in CPU usage. See these two graphs highlighting CPU usage in the FontRenderer (as called in this instance from VoxelMap's in-game waypoint renderer) -\n\nyou can clearly see the benefit of the State Manager in 1.8 with the way glBindTexture is called so much less (it's not being called once per letter in every string)\n\nHow this affects modders\n\n \n\n If your mod is making OpenGL calls directly, you can leave Minecraft's GlStateManager in an inconsistent state and cause visual artifacts. Example: Minecraft calls GlStateManager.enableBlend(). Later you call GL11.glDisable(GL11.GL_BLEND). Then Minecraft calls GlStateManager.enableBlend(). According to the state manager, blend is already enabled, so GlStateManager does not make the OpenGL call, leaving blending disabled. Congratulations, you just broke Minecraft!\n\n \n\n That's an easy fix right? Instead of calling OpenGL directly, run your stuff through GlStateManager like Minecraft does! I'll call this \"playing nice\". The problem with that though, is if some other mod continues to make direct OpenGL calls (\"not playing nice\") now YOUR MOD can be the one that's messed up by the GlStateManager being in an inconsistent state! If you play nice, mods that don't play nice can mess you up.\n\n \n\n How to play nice with Minecraft while protecting yourself from other mods that don't play nice? I can see two possibilities:\n• For each OpenGL call you want to make, do it both directly (to protect yourself from mods that don't play nice) AND make the call through GlStateManager to make sure the state manager stays consistent. This is of course throwing away the benefit of the State Manager (being able to skip unneeded calls)\n• or at the entrance to your code, store all OpenGL states yourself, make direct calls, and make sure your changes are reverted before you leave your code. In other words, make your own state manager: a complete waste since Minecraft already has one (and you are still throwing away its benefits)\n\nSo, anyone porting stuff to 1.8, be aware of this. If you are seeing weird effects, this is a likely cause. Ideally I guess, if GlStateManager is here to stay, everyone would switch to using it. I don't trust everyone to do that though, so to be safe, I'll either be making all calls twice (once directly, once through Minecraft's state manager) I'll just be using the State Manager, and encouraging everyone else to do so as well.\n\nThis isn't super pretty, but inspired by Mumfrey, I wrote a wrapper\n\nUsing that (feel free to take it wholesale, or just copy bits), one can simply replace every instance of GL11/GL13 etc. in his code with GLShim. It wraps calls to the State Manager with the familiar old syntax. GL11.glDisable(GL11.GL_ALPHA_TEST) becomes GLShim.glDisable(GLShim.GL_ALPHA_TEST) which calls GlStateManager.disableAlpha() behind the scenes. You just have to find/replace some GL11. Easier still if you are using static imports. You don't HAVE to do that, you can call the state manager directly yourself, but I was happy to make this shim to make the switchover quicker for me.\n\nAlso there may be bits that aren't wrapped yet, that's just the stuff I use. Feel free to add to it"
    },
    {
        "link": "https://mbsoftworks.sk/tutorials/opengl4/013-blending-pt1",
        "document": "Hello guys and welcome to the 13th tutorial of my OpenGL4 tutorial series! This one is going to be a shorter one and will teach you a thing or two about blending - that is mixing colors. With a good understanding of blending, we can achieve effects like transparent objects, as you may also see in this tutorial. We will also learn about possible pitfalls and how to overcome them. So let's go and learn something new !\n\nGenerally spoken, blending is simply mixing of two colors to get another one. Like if you mix same amounts of black and white color, you can get approximately gray color. Simple as that . When we're speaking about blending in OpenGL, it's the same thing, but there are also some other terms, which I have to explain. In OpenGL, we are not mixing color one and color two to get color three, but we are mixing source color with destination color using source and destination factors. It may sound a bit weird and not so intuitive, but it's actually really simple.\n\nDestination color is simply the color, that is already there - like what you rendered a while before, what is already in the framebuffer. The source color is the color you are about to render. So if I have a red quad already drawn in the scene and I want to draw a green 50% transparent quad over it, the red quad represents destination color (what is already drawn) and green quad represents source color. For a clearer image, have a look at the picture below:\n\nThe image should make everything pretty clear, but you might have noticed (and also in the previous tutorial), that we are not using just RGB colors, but RGBA instead. What does this mean? That last component is so called alpha color component, which is normally used to represent transparency - that means if alpha is 0.5, we want the object to be 50% transparent. Buut the thing is, that OpenGL allows you to use this number in many ways, but this one is like the most intuitive - the 0.0 alpha will mean invisible object and 1.0 alpha means completely opaque object .\n\nNow back to our example with two quads. To make our quad really look like 50% transparent object, we have to mix the colors properly. In other words, we should achieve effect like this:\n\nHow did we achieve this mathematically speaking? As you can see, originally we've had 1.0 as alpha in that red quad (destination color). When we're trying to blend this red quad with the green one, alpha of which is 0.5, that basically means, we have to take 0.5 of the green quad and (1.0-0.5)=0.5 of the red quad. To generalize this, we have to define a way how we mix those two colors. For that purpose, we can define two factors (or multipliers) - one, that we'll multiply destination color with and one, that we'll multiply source color with. Let's call them generally srcFactor for source color and dstFactor for destination color. The equation to calculate final color then looks like this:\n\nThe only thing left is to calculate the two factors. And that's up to us to tell OpenGL, how to calculate those two factors. In my example, the factor for source color is simply the alpha value of the source color (the 50% transparency, or 0.5 in our example) and the destination factor is 1.0 minus the alpha of source color (that is like the complement to the alpha, so that together the sum of those two factors is 1.0).\n\nLet's have a look at the code snippet, how to tell this to OpenGL:\n\nAs you can see, the very first step is telling OpenGL, that we want to enable and use blending. The glBlendFunc line tells OpenGL, what factors we want to use with source and destination colors. It requires got two parameters as you might expect - source and destination factor. In our case, we put there GL_SRC_ALPHA for source factor (so basically transparency of our render objects), and GL_ONE_MINUS_SRC_ALPHA for destination factor (then take the complement from destination color). If you put those two factors into our equations above, you will indeed get that orange color, which creates a transparency effect!\n\nBy calling glBlendFunc, we are defining a way to calculate factors for all 4 color components (RGBA). OpenGL however provides a way to define this separately for every color component using glBlendFuncSeparate function. I can't think of any use of it now, but I bet there is some cool effect achieved using this function .\n\nAnother function for altering blending settings is glBlendEquation. As you can see, in this example we were adding source and destination components together, but what if we wanted to subtract them instead? This is what one may set with this function, among with reverse subtract, taking minimum or taking maximum of values. In our example, calling this function is not necessary, because default blending equation is the addition, and that's what we need. There is a sibling of this function, glBlendEquationSeparate, with which we can define equation for all color components separately.\n\nThere is one more important matter, that requires attention in this tutorial and that's depth mask. The thing with rendering transparent objects is a bit more complicated than it looks like. The problem is, that when rendering transparent objects, we don't want to hide objects behind them, in other words, we have to turn writing to the depth buffer off. Moreover, we should first render fully opaque objects first and after that turn the writing to the depth buffer off and render transparent objects. When rendering transparent objects, we don't want to write values to depth buffer, because if there are two transparent objects behind each other, second transparent object behind the first would not pass Z-test after altering the depth buffer values with the first transparent object and thus wouldn't be rendered at all. But because these objects are at least partially transparent, the second object should be visible as well (you can see through two transparent glasses).\n\nTo turn writing to the depth buffer on or off, we can use function glDepthMask. It takes one GLboolean parameter - GL_FALSE (or simply number 0) to turn the writing to the depth buffer off or GL_TRUE (or simply number 1) to turn the writing to the depth buffer back on (which is also by default).\n\nThis solution is the simplest one, but it's still not perfect. In my tutorial, you can change turning depth writing on or off using F4 key to see the difference - try to walk with camera close to the pyramids, so you see multiple diamonds pyramids one after another. Without turning writing to the depth buffer off, you can see the pyramids dissapear:\n\nThis solution could also be improved not by turning the writing to the depth buffer off, but rather calculating the distance of the transparent objects from the camera and rendering them from the furthest to the closest (depth sorting). There are however even more modern and advanced techniques, which I will cover later, how to overcome this problem. For curious people, the keywords to search for is Order Independent Transparency .\n\nPutting it all together\n\nArmed with all the information, let's look at the code, that renders the whole scene:\n\nShort summary - first we render opaque objects, in our case rotating crates. Then, we set the color to render with to white, but with 0.5 only as alpha component and we render all the diamond pyramids. There is one bool variable you can control turning writing to the depth buffer off and on (with F4 key), so that you can see the difference for yourself .\n\nI would say that result is really nice, taken that the amount of code to achieve that was rather short:\n\nIt is far from perfect, but we could achieve the great effects with a little effort! As I said, I will cover more advanced techniques later, but for the start it's more than enough . Once again, I hope that you've enjoyed this tutorial and I hope that not much time will pass by before I come with more advanced blending techniques tutorial!"
    }
]