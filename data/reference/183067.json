[
    {
        "link": "https://ftp.gnu.org/old-gnu/Manuals/gdb/html_node/gdb_55.html",
        "document": "You can use the command (for \"examine\") to examine memory in any of several formats, independently of your program's data types.\n\n, , and are all optional parameters that specify how much memory to display and how to format it; is an expression giving the address where you want to start displaying memory. If you use defaults for , you need not type the slash . Several commands set convenient defaults for .\n\nFor example, is a request to display three halfwords ( ) of memory, formatted as unsigned decimal integers ( ), starting at address . prints the four words ( ) of memory above the stack pointer (here, ; see section Registers) in hexadecimal ( ).\n\nSince the letters indicating unit sizes are all distinct from the letters specifying output formats, you do not have to remember whether unit size or format comes first; either order works. The output specifications and mean exactly the same thing. (However, the count must come first; does not work.)\n\nEven though the unit size is ignored for the formats and , you might still want to use a count ; for example, specifies that you want to see three machine instructions, including any operands. The command gives an alternative way of inspecting machine instructions; see section Source and machine code.\n\nAll the defaults for the arguments to are designed to make it easy to continue scanning memory with minimal specifications each time you use . For example, after you have inspected three machine instructions with , you can inspect the next seven with just . If you use to repeat the command, the repeat count is used again; the other arguments default as for successive uses of .\n\nThe addresses and contents printed by the command are not saved in the value history because there is often too much of them and they would get in the way. Instead, GDB makes these values available for subsequent use in expressions as values of the convenience variables and . After an command, the last address examined is available for use in expressions in the convenience variable . The contents of that address, as examined, are available in the convenience variable .\n\nIf the command has a repeat count, the address and contents saved are from the last memory unit printed; this is not the same as the last address printed if several units were printed on the last line of output.\n\nGo to the first, previous, next, last section, table of contents."
    },
    {
        "link": "https://sourceware.org/gdb/current/onlinedocs/gdb.html/Memory.html",
        "document": "You can use the command (for “examine”) to examine memory in any of several formats, independently of your program’s data types.\n\n, , and are all optional parameters that specify how much memory to display and how to format it; is an expression giving the address where you want to start displaying memory. If you use defaults for , you need not type the slash ‘ ’. Several commands set convenient defaults for .\n\nThe repeat count is a decimal integer; the default is 1. It specifies how much memory (counting by units ) to display. If a negative number is specified, memory is examined backward from . The display format is one of the formats used by (‘ ’, ‘ ’, ‘ ’, ‘ ’, ‘ ’, ‘ ’, ‘ ’, ‘ ’, ‘ ’), ‘ ’ (for machine instructions) and ‘ ’ (for displaying memory tags). The default is ‘ ’ (hexadecimal) initially. The default changes each time you use either or . Words (four bytes). This is the initial default. Each time you specify a unit size with , that size becomes the default unit the next time you use . For the ‘ ’ format, the unit size is ignored and is normally not written. For the ‘ ’ format, the unit size defaults to ‘ ’, unless it is explicitly given. Use to display 16-bit char strings and to display 32-bit strings. The next use of will again display 8-bit strings. Note that the results depend on the programming language of the current compilation unit. If the language is C, the ‘ ’ modifier will use the UTF-16 encoding while ‘ ’ will use UTF-32. The encoding is set by the programming language and cannot be altered. is the address where you want GDB to begin displaying memory. The expression need not have a pointer value (though it may); it is always interpreted as an integer address of a byte of memory. See Expressions, for more information on expressions. The default for is usually just after the last address examined—but several other commands also set the default address: (to the address of the last breakpoint listed), (to the starting address of a line), and (if you use it to display a value from memory).\n\nFor example, ‘ ’ is a request to display three halfwords ( ) of memory, formatted as unsigned decimal integers (‘ ’), starting at address . ‘ ’ prints the four words (‘ ’) of memory above the stack pointer (here, ‘ ’; see Registers) in hexadecimal (‘ ’).\n\nYou can also specify a negative repeat count to examine memory backward from the given address. For example, ‘ ’ prints three halfwords ( ) at , , and .\n\nSince the letters indicating unit sizes are all distinct from the letters specifying output formats, you do not have to remember whether unit size or format comes first; either order works. The output specifications ‘ ’ and ‘ ’ mean exactly the same thing. (However, the count must come first; ‘ ’ does not work.)\n\nEven though the unit size is ignored for the formats ‘ ’ and ‘ ’, you might still want to use a count ; for example, ‘ ’ specifies that you want to see three machine instructions, including any operands. For convenience, especially when used with the command, the ‘ ’ format also prints branch delay slot instructions, if any, beyond the count specified, which immediately follow the last instruction that is within the count. The command gives an alternative way of inspecting machine instructions; see Source and Machine Code.\n\nIf a negative repeat count is specified for the formats ‘ ’ or ‘ ’, the command displays null-terminated strings or instructions before the given address as many as the absolute value of the given number. For the ‘ ’ format, we use line number information in the debug info to accurately locate instruction boundaries while disassembling backward. If line info is not available, the command stops examining memory with an error message.\n\nAll the defaults for the arguments to are designed to make it easy to continue scanning memory with minimal specifications each time you use . For example, after you have inspected three machine instructions with ‘ ’, you can inspect the next seven with just ‘ ’. If you use to repeat the command, the repeat count is used again; the other arguments default as for successive uses of .\n\nWhen examining machine instructions, the instruction at current program counter is shown with a marker. For example:\n\nIf the architecture supports memory tagging, the tags can be displayed by using ‘ ’. See Memory Tagging.\n\nThe information will be displayed once per granule size (the amount of bytes a particular memory tag covers). For example, AArch64 has a granule size of 16 bytes, so it will display a tag every 16 bytes.\n\nDue to the way GDB prints information with the command (not aligned to a particular boundary), the tag information will refer to the initial address displayed on a particular line. If a memory tag boundary is crossed in the middle of a line displayed by the command, it will be displayed on the next line.\n\nThe ‘ ’ format doesn’t affect any other specified formats that were passed to the command.\n\nThe addresses and contents printed by the command are not saved in the value history because there is often too much of them and they would get in the way. Instead, GDB makes these values available for subsequent use in expressions as values of the convenience variables and . After an command, the last address examined is available for use in expressions in the convenience variable . The contents of that address, as examined, are available in the convenience variable .\n\nIf the command has a repeat count, the address and contents saved are from the last memory unit printed; this is not the same as the last address printed if several units were printed on the last line of output.\n\nMost targets have an addressable memory unit size of 8 bits. This means that to each memory address are associated 8 bits of data. Some targets, however, have other addressable memory unit sizes. Within GDB and this document, the term addressable memory unit (or memory unit for short) is used when explicitly referring to a chunk of data of that size. The word byte is used to refer to a chunk of data of 8 bits, regardless of the addressable memory unit size of the target. For most systems, addressable memory unit is a synonym of byte.\n\nWhen you are debugging a program running on a remote target machine (see Remote Debugging), you may wish to verify the program’s image in the remote machine’s memory against the executable file you downloaded to the target. Or, on any target, you may want to check whether the program has corrupted its own read-only sections. The command is provided for such situations."
    },
    {
        "link": "https://cs.brown.edu/courses/cs033/docs/guides/gdb.pdf",
        "document": ""
    },
    {
        "link": "https://bob.cs.sonoma.edu/testing/sec-gdb1.html",
        "document": "Now that we have started writing programs, you need to learn how to use the GNU debugger, . It may seem premature at this point. The programs are so simple, they hardly require debugging. Well, it is better to learn how to use the debugger on a simple example than on a complicated program that does not work. In other words, tackle one problem at a time.\n\nThere is a better reason for learning how to use now. You will find that it is a very valuable tool for learning the material in this book, even when you write bug-free programs.\n\nhas a large number of commands. The few here will be sufficient to get you started. You will see more in Section 8.5.\n• None — Set a breakpoint at the specified in the source file, . Control will return to when the line number is encountered.\n• None command — Help on how to use command.\n• None — Show the contents of the registers (“info registers”).\n• None LineNumber — List ten lines of the source code, centered at the line number specified by LineNumber.\n• None Expression — Evaluate Expression and print the value.\n• None \"format\", var1, var2,… — Display the values of var1, var2,…. The \"format\" string follows the same rules as the in the C Standard Library.\n• None — Begin execution of a program that has been loaded under control of .\n• None nfs MemoryAddress — Display (examine) n values in memory in format f of size s starting at MemoryAddress.\n\nLet us walk through an example of using to explore the concepts covered in this book. I will use the program in Listing 2.9.1. I recommend that you get on your Raspberry Pi and follow along as you read this. I will describe the purpose of the commands as we walk through this terminal interaction. The addresses you see on your Raspberry Pi will probably be different than those in this example.\n\nThe “ ” option is required to tell the compiler to include debugger information in the executable program.\n\nThe command lists ten lines of source code. Control returns to the program as shown by the prompt. Simply pushing the key will repeat the previous command, and is smart enough to display the next (up to) ten lines.\n\nI set a breakpoint at line 12. When the program is executing, if it ever gets to this statement, execution will pause before the statement is executed, and control will return to .\n\nThe command causes the program to start execution from the beginning. When it reaches our breakpoint, control returns to , which displays the program statement that is ready to be executed.\n\nThe command displays the value currently stored in the named variable. There is a round off error in the float value. As mentioned above, this will be explained in Chapter 16.\n\nThe command can be used to format the displayed values. The formatting string is essentially the same as for the function in the C Standard Library.\n\nTake a moment and convert the hexadecimal values to decimal. The value of is correct, but the value of is \\(19088_{10}\\text{.}\\) The reason for this odd behavior is that the formatting character causes the function to first convert the value to an , then display that in hexadecimal. In C/C++, conversion from to truncates the fractional part.\n\nFortunately, provides another command for examining the contents of memory directly—that is, the actual bit patterns. In order to use this command, we need to determine the actual memory addresses where the and variables are stored.\n\nThe address-of operator ( ) can be used to print the address of a variable. Notice that the addresses are very large.\n\nThe command is used to examine memory. Its help message is very brief, but it tells you everything you need to know.\n\nThe command can be used to display the values in their stored data type. Read the help message carefully, and you will see that I commanded to display one decimal (integer) word at the address .\n\nAnd this time I commanded to display one float (in decimal) word at the address . Be careful not to confuse “decimal” and “float” here.\n\nThe display of the variable in hexadecimal, which is located at memory address \\(\\hex{7efff194}\\text{,}\\) looks good.\n\nThe second command displays the bytes separately. The first byte (the one that contains \\(\\hex{67}\\)) is located at the address shown on the left of the row. The next byte in the row is at the subsequent address (\\(\\hex{7efff195}\\)). So this row displays each of the bytes stored at the four memory addresses \\(\\hex{7efff194}\\text{,}\\) \\(\\hex{7efff195}\\text{,}\\) \\(\\hex{7efff196}\\text{,}\\) and \\(\\hex{7efff197}\\text{,}\\) reading from left to right, that make up the variable, .\n\nHowever, when displaying these same four bytes separately, the least significant byte appears first in memory. This is called storage order, which will be explained below.\n\nThe display of the variable in hexadecimal simply looks wrong. This is due to the storage format of s, which is very different from s. It will be explained in Chapter 16.\n\nThe byte-by-byte display of the variable in hexadecimal also shows that it is stored in little endian order.\n\nFinally, I continue to the end of the program. Notice that is still running and I have to quit it.\n\nThis example illustrates a concept know as :\n\nLook again at the display of the four bytes beginning at \\(\\hex{7efff194}\\) above. We can rearrange this display to show the bit patterns at each of the four locations:\n\nYet when we look at the entire 32-bit value in hexadecimal the bytes seem to be arranged in the proper order:\n\nWhen we examine memory one byte at a time, each byte is displayed in numerically ascending addresses. At first glance, the value appears to be stored backwards, but it is correct for the endianess of our environment.\n\nOur environment is configured in little-endian, but the ARM can be configured in either little- or big-endian. In the vast majority of programming situations, endianess is not an issue. However, you need to know about it because:\n• None It can be confusing when examining individual memory locations in memory.\n• None Using the contents of a variable with a data type other than the one used to store the contents often causes a programming error.\n• None Mixing environments, for example, reading a file that was created in another environment, may cause errors."
    },
    {
        "link": "https://sourceware.org/gdb/current/onlinedocs/gdb",
        "document": "This is the Tenth Edition, of for GDB (GDB) Version 17.0.50.20250323-git.\n\nPermission is granted to copy, distribute and/or modify this document under the terms of the GNU Free Documentation License, Version 1.3 or any later version published by the Free Software Foundation; with the Invariant Sections being “Free Software” and “Free Software Needs Free Documentation”, with the Front-Cover Texts being “A GNU Manual,” and with the Back-Cover Texts as in (a) below.\n\n(a) The FSF’s Back-Cover Text is: “You are free to copy and modify this GNU Manual. Buying copies from GNU Press supports the FSF in developing GNU and promoting software freedom.”\n\nThis is the Tenth Edition, for GDB (GDB) Version 17.0.50.20250323-git.\n\nThis edition of the GDB manual is dedicated to the memory of Fred Fish. Fred was a long-standing contributor to GDB and to Free software in general. We will miss him.\n\nThe purpose of a debugger such as GDB is to allow you to see what is going on “inside” another program while it executes—or what another program was doing at the moment it crashed.\n\nGDB can do four main kinds of things (plus other things in support of these) to help you catch bugs in the act:\n• Start your program, specifying anything that might affect its behavior.\n• Make your program stop on specified conditions.\n• Examine what has happened, when your program has stopped.\n• Change things in your program, so you can experiment with correcting the effects of one bug and go on to learn about another.\n\nYou can use GDB to debug programs written in C and C . For more information, see Supported Languages. For more information, see C and C++.\n\nSupport for D is partial. For information on D, see D.\n\nSupport for Modula-2 is partial. For information on Modula-2, see Modula-2.\n\nSupport for OpenCL C is partial. For information on OpenCL C, see OpenCL C.\n\nDebugging Pascal programs which use sets, subranges, file variables, or nested functions does not currently work. GDB does not support entering expressions, printing values, or similar features using Pascal syntax.\n\nGDB can be used to debug programs written in Fortran, although it may be necessary to refer to some variables with a trailing underscore.\n\nGDB can be used to debug programs written in Objective-C, using either the Apple/NeXT or the GNU Objective-C runtime.\n\nGDB is free software, protected by the GNU General Public License (GPL). The GPL gives you the freedom to copy or adapt a licensed program—but every person getting a copy also gets with it the freedom to modify that copy (which means that they must get access to the source code), and the freedom to distribute further copies. Typical software companies use copyrights to limit your freedoms; the Free Software Foundation uses the GPL to preserve these freedoms.\n\nFundamentally, the General Public License is a license which says that you have these freedoms and that you cannot take these freedoms away from anyone else.\n\nThe biggest deficiency in the free software community today is not in the software—it is the lack of good free documentation that we can include with the free software. Many of our most important programs do not come with free reference manuals and free introductory texts. Documentation is an essential part of any software package; when an important free software package does not come with a free manual and a free tutorial, that is a major gap. We have many such gaps today.\n\nConsider Perl, for instance. The tutorial manuals that people normally use are non-free. How did this come about? Because the authors of those manuals published them with restrictive terms—no copying, no modification, source files not available—which exclude them from the free software world.\n\nThat wasn’t the first time this sort of thing happened, and it was far from the last. Many times we have heard a GNU user eagerly describe a manual that he is writing, his intended contribution to the community, only to learn that he had ruined everything by signing a publication contract to make it non-free.\n\nFree documentation, like free software, is a matter of freedom, not price. The problem with the non-free manual is not that publishers charge a price for printed copies—that in itself is fine. (The Free Software Foundation sells printed copies of manuals, too.) The problem is the restrictions on the use of the manual. Free manuals are available in source code form, and give you permission to copy and modify. Non-free manuals do not allow this.\n\nThe criteria of freedom for a free manual are roughly the same as for free software. Redistribution (including the normal kinds of commercial redistribution) must be permitted, so that the manual can accompany every copy of the program, both on-line and on paper.\n\nPermission for modification of the technical content is crucial too. When people modify the software, adding or changing features, if they are conscientious they will change the manual too—so they can provide accurate and clear documentation for the modified program. A manual that leaves you no choice but to write a new manual to document a changed version of the program is not really available to our community.\n\nSome kinds of limits on the way modification is handled are acceptable. For example, requirements to preserve the original author’s copyright notice, the distribution terms, or the list of authors, are ok. It is also no problem to require modified versions to include notice that they were modified. Even entire sections that may not be deleted or changed are acceptable, as long as they deal with nontechnical topics (like this one). These kinds of restrictions are acceptable because they don’t obstruct the community’s normal use of the manual.\n\nHowever, it must be possible to modify all the technical content of the manual, and then distribute the result in all the usual media, through all the usual channels. Otherwise, the restrictions obstruct the use of the manual, it is not free, and we need another manual to replace it.\n\nPlease spread the word about this issue. Our community continues to lose manuals to proprietary publishing. If we spread the word that free software needs free reference manuals and free tutorials, perhaps the next person who wants to contribute by writing documentation will realize, before it is too late, that only free manuals contribute to the free software community.\n\nIf you are writing documentation, please insist on publishing it under the GNU Free Documentation License or another free documentation license. Remember that this decision requires your approval—you don’t have to let the publisher decide. Some commercial publishers will use a free license if you insist, but they will not propose the option; it is up to you to raise the issue and say firmly that this is what you want. If the publisher you are dealing with refuses, please try other publishers. If you’re not sure whether a proposed license is free, write to licensing@gnu.org.\n\nYou can encourage commercial publishers to sell more free, copylefted manuals and tutorials by buying them, and particularly by buying copies from the publishers that paid for their writing or for major improvements. Meanwhile, try to avoid buying non-free documentation at all. Check the distribution terms of a manual before you buy it, and insist that whoever seeks your business must respect your freedom. Check the history of the book, and try to reward the publishers that have paid or pay the authors to work on it.\n\nThe Free Software Foundation maintains a list of free documentation published by other publishers, at http://www.fsf.org/doc/other-free-books.html.\n\nRichard Stallman was the original author of GDB, and of many other GNU programs. Many others have contributed to its development. This section attempts to credit major contributors. One of the virtues of free software is that everyone is free to contribute to it; with regret, we cannot actually acknowledge everyone here. The file in the GDB distribution approximates a blow-by-blow account.\n\nChanges much prior to version 2.0 are lost in the mists of time.\n\nSo that they may not regard their many labors as thankless, we particularly thank those who shepherded GDB through major releases: Andrew Cagney (releases 6.3, 6.2, 6.1, 6.0, 5.3, 5.2, 5.1 and 5.0); Jim Blandy (release 4.18); Jason Molenda (release 4.17); Stan Shebs (release 4.14); Fred Fish (releases 4.16, 4.15, 4.13, 4.12, 4.11, 4.10, and 4.9); Stu Grossman and John Gilmore (releases 4.8, 4.7, 4.6, 4.5, and 4.4); John Gilmore (releases 4.3, 4.2, 4.1, 4.0, and 3.9); Jim Kingdon (releases 3.5, 3.4, and 3.3); and Randy Smith (releases 3.2, 3.1, and 3.0).\n\nRichard Stallman, assisted at various times by Peter TerMaat, Chris Hanson, and Richard Mlynarik, handled releases through 2.8.\n\nMichael Tiemann is the author of most of the GNU C support in GDB, with significant additional contributions from Per Bothner and Daniel Berlin. James Clark wrote the GNU C demangler. Early work on C was by Peter TerMaat (who also did much general update work leading to release 3.0).\n\nGDB uses the BFD subroutine library to examine multiple object-file formats; BFD was a joint project of David V. Henkel-Wallace, Rich Pixley, Steve Chamberlain, and John Gilmore.\n\nDavid Johnson wrote the original COFF support; Pace Willison did the original support for encapsulated COFF.\n\nAdam de Boor and Bradley Davis contributed the ISI Optimum V support. Per Bothner, Noboyuki Hikichi, and Alessandro Forin contributed MIPS support. Jean-Daniel Fekete contributed Sun 386i support. Chris Hanson improved the HP9000 support. Noboyuki Hikichi and Tomoyuki Hasei contributed Sony/News OS 3 support. David Johnson contributed Encore Umax support. Jyrki Kuoppala contributed Altos 3068 support. Jeff Law contributed HP PA and SOM support. Keith Packard contributed NS32K support. Doug Rabson contributed Acorn Risc Machine support. Bob Rusk contributed Harris Nighthawk CX-UX support. Chris Smith contributed Convex support (and Fortran debugging). Jonathan Stone contributed Pyramid support. Michael Tiemann contributed SPARC support. Tim Tucker contributed support for the Gould NP1 and Gould Powernode. Pace Willison contributed Intel 386 support. Jay Vosburgh contributed Symmetry support. Marko Mlinar contributed OpenRISC 1000 support.\n\nRich Schaefer and Peter Schauer helped with support of SunOS shared libraries.\n\nJay Fenlason and Roland McGrath ensured that GDB and GAS agree about several machine instruction sets.\n\nPatrick Duval, Ted Goldstein, Vikram Koka and Glenn Engel helped develop remote debugging. Intel Corporation, Wind River Systems, AMD, and ARM contributed remote debugging modules for the i960, VxWorks, A29K UDI, and RDI targets, respectively.\n\nBrian Fox is the author of the readline libraries providing command-line editing and command history.\n\nAndrew Beers of SUNY Buffalo wrote the language-switching code, the Modula-2 support, and contributed the Languages chapter of this manual.\n\nFred Fish wrote most of the support for Unix System Vr4. He also enhanced the command-completion support to cover C overloaded symbols.\n\nHitachi America (now Renesas America), Ltd. sponsored the support for H8/300, H8/500, and Super-H processors.\n\nNEC sponsored the support for the v850, Vr4xxx, and Vr5xxx processors.\n\nMitsubishi (now Renesas) sponsored the support for D10V, D30V, and M32R/D processors.\n\nToshiba sponsored the support for the TX39 Mips processor.\n\nMatsushita sponsored the support for the MN10200 and MN10300 processors.\n\nFujitsu sponsored the support for SPARClite and FR30 processors.\n\nJim Kingdon, Peter Schauer, Ian Taylor, and Stu Grossman made nearly innumerable bug fixes and cleanups throughout GDB.\n\nThe following people at the Hewlett-Packard Company contributed support for the PA-RISC 2.0 architecture, HP-UX 10.20, 10.30, and 11.0 (narrow mode), HP’s implementation of kernel threads, HP’s aC compiler, and the Text User Interface (nee Terminal User Interface): Ben Krepp, Richard Title, John Bishop, Susan Macchia, Kathy Mann, Satish Pai, India Paul, Steve Rehrauer, and Elena Zannoni. Kim Haase provided HP-specific information in this manual.\n\nDJ Delorie ported GDB to MS-DOS, for the DJGPP project. Robert Hoehne made significant contributions to the DJGPP port.\n\nCygnus Solutions has sponsored GDB maintenance and much of its development since 1991. Cygnus engineers who have worked on GDB fulltime include Mark Alexander, Jim Blandy, Per Bothner, Kevin Buettner, Edith Epstein, Chris Faylor, Fred Fish, Martin Hunt, Jim Ingham, John Gilmore, Stu Grossman, Kung Hsu, Jim Kingdon, John Metzler, Fernando Nasser, Geoffrey Noer, Dawn Perchik, Rich Pixley, Zdenek Radouch, Keith Seitz, Stan Shebs, David Taylor, and Elena Zannoni. In addition, Dave Brolley, Ian Carmichael, Steve Chamberlain, Nick Clifton, JT Conklin, Stan Cox, DJ Delorie, Ulrich Drepper, Frank Eigler, Doug Evans, Sean Fagan, David Henkel-Wallace, Richard Henderson, Jeff Holcomb, Jeff Law, Jim Lemke, Tom Lord, Bob Manson, Michael Meissner, Jason Merrill, Catherine Moore, Drew Moseley, Ken Raeburn, Gavin Romig-Koch, Rob Savoye, Jamie Smith, Mike Stump, Ian Taylor, Angela Thomas, Michael Tiemann, Tom Tromey, Ron Unrau, Jim Wilson, and David Zuhn have made contributions both large and small.\n\nAndrew Cagney, Fernando Nasser, and Elena Zannoni, while working for Cygnus Solutions, implemented the original GDB/MI interface.\n\nJim Blandy added support for preprocessor macros, while working for Red Hat.\n\nAndrew Cagney designed GDB’s architecture vector. Many people including Andrew Cagney, Stephane Carrez, Randolph Chung, Nick Duffek, Richard Henderson, Mark Kettenis, Grace Sainsbury, Kei Sakamoto, Yoshinori Sato, Michael Snyder, Andreas Schwab, Jason Thorpe, Corinna Vinschen, Ulrich Weigand, and Elena Zannoni, helped with the migration of old architectures to this new framework.\n\nAndrew Cagney completely re-designed and re-implemented GDB’s unwinder framework, this consisting of a fresh new design featuring frame IDs, independent frame sniffers, and the sentinel frame. Mark Kettenis implemented the DWARF 2 unwinder, Jeff Johnston the libunwind unwinder, and Andrew Cagney the dummy, sentinel, tramp, and trad unwinders. The architecture-specific changes, each involving a complete rewrite of the architecture’s frame code, were carried out by Jim Blandy, Joel Brobecker, Kevin Buettner, Andrew Cagney, Stephane Carrez, Randolph Chung, Orjan Friberg, Richard Henderson, Daniel Jacobowitz, Jeff Johnston, Mark Kettenis, Theodore A. Roth, Kei Sakamoto, Yoshinori Sato, Michael Snyder, Corinna Vinschen, and Ulrich Weigand.\n\nChristian Zankel, Ross Morley, Bob Wilson, and Maxim Grigoriev from Tensilica, Inc. contributed support for Xtensa processors. Others who have worked on the Xtensa port of GDB in the past include Steve Tjiang, John Newlin, and Scott Foehner.\n\nMichael Eager and staff of Xilinx, Inc., contributed support for the Xilinx MicroBlaze architecture.\n\nInitial support for the FreeBSD/mips target and native configuration was developed by SRI International and the University of Cambridge Computer Laboratory under DARPA/AFRL contract FA8750-10-C-0237 (\"CTSRD\"), as part of the DARPA CRASH research programme.\n\nInitial support for the FreeBSD/riscv target and native configuration was developed by SRI International and the University of Cambridge Computer Laboratory (Department of Computer Science and Technology) under DARPA contract HR0011-18-C-0016 (\"ECATS\"), as part of the DARPA SSITH research programme.\n\nThe original port to the OpenRISC 1000 is believed to be due to Alessandro Forin and Per Bothner. More recent ports have been the work of Jeremy Bennett, Franck Jullien, Stefan Wallentowitz and Stafford Horne.\n\nWeimin Pan, David Faust and Jose E. Marchesi contributed support for the Linux kernel BPF virtual architecture. This work was sponsored by Oracle.\n\nYou can use this manual at your leisure to read all about GDB. However, a handful of commands are enough to get started using the debugger. This chapter illustrates those commands.\n\nOne of the preliminary versions of GNU (a generic macro processor) exhibits the following bug: sometimes, when we change its quote strings from the default, the commands used to capture one macro definition within another stop working. In the following short session, we define a macro which expands to ; we then use the built-in to define as the same thing. However, when we change the open quote string to and the close quote string to , the same procedure fails to define a new synonym :\n\nLet us use GDB to try to see what is going on.\n\nGDB reads only enough symbol data to know where to find the rest when needed; as a result, the first prompt comes up very quickly. We now tell GDB to use a narrower display width than usual, so that examples fit in this manual.\n\nWe need to see how the built-in works. Having looked at the source, we know the relevant subroutine is , so we set a breakpoint there with the GDB command.\n\nUsing the command, we start running under GDB control; as long as control does not reach the subroutine, the program runs as usual:\n\nTo trigger the breakpoint, we call . GDB suspends execution of , displaying information about the context where it stops.\n\nNow we use the command ( ) to advance execution to the next line of the current function.\n\nlooks like a promising subroutine. We can go into it by using the command ( ) instead of . goes to the next line to be executed in any subroutine, so it steps into .\n\nThe display that shows the subroutine where is now suspended (and its arguments) is called a stack frame display. It shows a summary of the stack. We can use the command (which can also be spelled ), to see where we are in the stack as a whole: the command displays a stack frame for each active subroutine.\n\nWe step through a few more lines to see what happens. The first two times, we can use ‘ ’; the next two times we use to avoid falling into the subroutine.\n\nThe last line displayed looks a little odd; we can examine the variables and to see if they are in fact the new left and right quotes we specified. We use the command ( ) to see their values.\n\nand are indeed the new left and right quotes. To look at some context, we can display ten lines of source surrounding the current line with the ( ) command.\n\nLet us step past the two lines that set and , and then examine the values of those variables.\n\nThat certainly looks wrong, assuming and are meant to be the lengths of and respectively. We can set them to better values using the command, since it can print the value of any expression—and that expression can include subroutine calls and assignments.\n\nIs that enough to fix the problem of using the new quotes with the built-in ? We can allow to continue executing with the ( ) command, and then try the example that caused trouble initially:\n\nSuccess! The new quotes now work just as well as the default ones. The problem seems to have been just the two typos defining the wrong lengths. We allow exit by giving it an EOF as input:\n\nThe message ‘ ’ is from GDB; it indicates has finished executing. We can end our GDB session with the GDB command.\n\n2 Getting In and Out of GDB\n\nThis chapter discusses how to start GDB, and how to get out of it. The essentials are:\n\nInvoke GDB by running the program . Once started, GDB reads commands from the terminal until you tell it to exit.\n\nYou can also run with a variety of arguments and options, to specify more of your debugging environment at the outset.\n\nThe command-line options described here are designed to cover a variety of situations; in some environments, some of these options may effectively be unavailable.\n\nThe most usual way to start GDB is with one argument, specifying an executable program:\n\nYou can also start with both an executable program and a core file specified:\n\nYou can, instead, specify a process ID as a second argument or use option , if you want to debug a running process:\n\nwould attach GDB to process . With option you can omit the filename.\n\nTaking advantage of the second command-line argument requires a fairly complete operating system; when you use GDB as a remote debugger attached to a bare board, there may not be any notion of “process”, and there is often no way to get a core dump. GDB will warn you if it is unable to attach or to read core dumps.\n\nYou can optionally have pass any arguments after the executable file to the inferior using . This option stops option processing.\n\nThis will cause to debug , and to set ’s command-line arguments (see Arguments) to ‘ ’.\n\nYou can run without printing the front material, which describes GDB’s non-warranty, by specifying (or / ):\n\nYou can further control how GDB starts up by using command-line options. GDB itself can remind you of the options available.\n\nto display all available options and briefly describe their use (‘ ’ is a shorter equivalent).\n\nAll options and command line arguments you give are processed in sequential order. The order makes a difference when the ‘ ’ option is used.\n\nWhen GDB starts, it reads any arguments other than options as specifying an executable file and core file (or process ID). This is the same as if the arguments were specified by the ‘ ’ and ‘ ’ (or ‘ ’) options respectively. (GDB reads the first argument that does not have an associated option flag as equivalent to the ‘ ’ option followed by that argument; and the second argument that does not have an associated option flag, if any, as equivalent to the ‘ ’/‘ ’ option followed by that argument.) If the second argument begins with a decimal digit, GDB will first attempt to attach to it as a process, and if that fails, attempt to open it as a corefile. If you have a corefile whose name begins with a digit, you can prevent GDB from treating it as a pid by prefixing it with , e.g. .\n\nIf GDB has not been configured to included core file support, such as for most embedded targets, then it will complain about a second argument and ignore it.\n\nFor the ‘ ’, ‘ ’, and ‘ ’ options, and their long form equivalents, the method used to search the file system for the symbol and/or executable file is the same as that used by the command. See file.\n\nMany options have both long and short forms; both are shown in the following list. GDB also recognizes the long forms if you truncate them, so long as enough of the option is present to be unambiguous. (If you prefer, you can flag option arguments with ‘ ’ rather than ‘ ’, though we illustrate the more usual convention.)\n\nYou can run GDB in various alternative modes—for example, in batch mode or quiet mode.\n\n2.1.3 What GDB Does During Startup\n\nHere’s the description of what GDB does during session startup:\n• Reads commands from the early initialization file (if any) in your home directory. Only a restricted set of commands can be placed into an early initialization file, see Initialization Files, for details.\n• Executes commands and command files specified by the ‘ ’ and ‘ ’ command line options in their specified order. Only a restricted set of commands can be used with ‘ ’ and ‘ ’, see Initialization Files, for details.\n• Sets up the command interpreter as specified by the command line (see interpreter).\n• Reads the system wide initialization file and the files from the system wide initialization directory, see System Wide Init Files.\n• Reads the initialization file (if any) in your home directory and executes all the commands in that file, see Home Directory Init File.\n• Executes commands and command files specified by the ‘ ’ and ‘ ’ options in their specified order. Usually you should use the ‘ ’ and ‘ ’ options instead, but this way you can apply settings before GDB init files get executed and before inferior gets loaded.\n• Reads and executes the commands from the initialization file (if any) in the current working directory as long as ‘ ’ is set to ‘ ’ (see Init File in the Current Directory). This is only done if the current directory is different from your home directory. Thus, you can have more than one init file, one generic in your home directory, and another, specific to the program you are debugging, in the directory where you invoke GDB. See Init File in the Current Directory during Startup.\n• If the command line specified a program to debug, or a process to attach to, or a core file, GDB loads any auto-loaded scripts provided for the program or for its loaded shared libraries. See Auto-loading. If you wish to disable the auto-loading during startup, you must do something like the following: Option ‘ ’ does not work because the auto-loading is then turned off too late.\n• Executes commands and command files specified by the ‘ ’ and ‘ ’ options in their specified order. See Command Files, for more details about GDB command files.\n• Reads the command history recorded in the history file. See Command History, for more details about the command history and the files where GDB records it.\n\nDuring startup (see Startup) GDB will execute commands from several initialization files. These initialization files use the same syntax as command files (see Command Files) and are processed by GDB in the same way.\n\nTo display the list of initialization files loaded by GDB at startup, in the order they will be loaded, you can use .\n\nThe early initialization file is loaded very early in GDB’s initialization process, before the interpreter (see Interpreters) has been initialized, and before the default target (see Targets) is initialized. Only or commands should be placed into an early initialization file, and the only commands that can be used are those that control how GDB starts up.\n\nCommands that can be placed into an early initialization file will be documented as such throughout this manual. Any command that is not documented as being suitable for an early initialization file should instead be placed into a general initialization file. Command files passed to or are also early initialization files, with the same command restrictions. Only commands that can appear in an early initialization file should be passed to or .\n\nIn contrast, the general initialization files are processed later, after GDB has finished its own internal initialization process, any valid command can be used in these files.\n\nThroughout the rest of this document the term initialization file refers to one of the general initialization files, not the early initialization file. Any discussion of the early initialization file will specifically mention that it is the early initialization file being discussed.\n\nAs the system wide and home directory initialization files are processed before most command line options, changes to settings (e.g. ‘ ’) can affect subsequent processing of command line options and operands.\n\nThe following sections describe where GDB looks for the early initialization and initialization files, and the order that the files are searched for.\n\nGDB initially looks for an early initialization file in the users home directory1. There are a number of locations that GDB will search in the home directory, these locations are searched in order and GDB will load the first file that it finds, and subsequent locations will not be checked.\n\nOn non-macOS hosts the locations searched are:\n• The file within the directory pointed to by the environment variable , if it is defined.\n• The file within the directory pointed to by the environment variable , if it is defined.\n• The file within the directory pointed to by the environment variable , if it is defined.\n\nBy contrast, on macOS hosts the locations searched are:\n• The file within the directory pointed to by the environment variable , if it is defined.\n• The file within the directory pointed to by the environment variable , if it is defined.\n\nIt is possible to prevent the home directory early initialization file from being loaded using the ‘ ’ or ‘ ’ command line options, see Choosing Modes.\n\nThere are two locations that are searched for system wide initialization files. Both of these locations are always checked:\n\nIt is possible to prevent the system wide initialization files from being loaded using the ‘ ’ command line option, see Choosing Modes.\n\nAfter loading the system wide initialization files GDB will look for an initialization file in the users home directory2. There are a number of locations that GDB will search in the home directory, these locations are searched in order and GDB will load the first file that it finds, and subsequent locations will not be checked.\n\nOn non-Apple hosts the locations searched are:\n\nWhile on Apple hosts the locations searched are:\n\nIt is possible to prevent the home directory initialization file from being loaded using the ‘ ’ or ‘ ’ command line options, see Choosing Modes.\n\nThe DJGPP port of GDB uses the name instead of or , due to the limitations of file names imposed by DOS filesystems. The Windows port of GDB uses the standard name, but if it finds a file in your home directory, it warns you about that and suggests to rename the file to the standard name.\n\nGDB will check the current directory for a file called . It is loaded last, after command line options other than ‘ ’ and ‘ ’ have been processed. The command line options ‘ ’ and ‘ ’ are processed last, after has been loaded, see Choosing Files.\n\nIf the file in the current directory was already loaded as the home directory initialization file then it will not be loaded a second time.\n\nIt is possible to prevent the local directory initialization file from being loaded using the ‘ ’ command line option, see Choosing Modes.\n\nAn interrupt (often ) does not exit from GDB, but rather terminates the action of any GDB command that is in progress and returns to GDB command level. It is safe to type the interrupt character at any time because GDB does not allow it to take effect until a time when it is safe.\n\nIf you have been using GDB to control an attached process or device, you can release it with the command (see Debugging an Already-running Process).\n\nIf you need to execute occasional shell commands during your debugging session, there is no need to leave or suspend GDB; you can just use the command.\n\nYou may also invoke shell commands from expressions, using the convenience function. See $_shell convenience function.\n\nThe utility is often needed in development environments. You do not have to use the command for this purpose in GDB:\n\nThe convenience variables and can be used to examine the exit status of the last shell command launched by , , and . See Convenience Variables.\n\nYou may want to save the output of GDB commands to a file. There are several commands to control GDB’s logging.\n\nYou can also redirect the output of a GDB command to a shell command. See pipe.\n\nYou can abbreviate a GDB command to the first few letters of the command name, if that abbreviation is unambiguous; and you can repeat certain GDB commands by typing just . You can also use the key to get GDB to fill out the rest of a word in a command (or to show you the alternatives available, if there is more than one possibility).\n\nA GDB command is a single line of input. There is no limit on how long it can be. It starts with a command name, which is followed by arguments whose meaning depends on the command name. For example, the command accepts an argument which is the number of times to step, as in ‘ ’. You can also use the command with no arguments. Some commands do not allow any arguments.\n\nGDB command names may always be truncated if that abbreviation is unambiguous. Other possible command abbreviations are listed in the documentation for individual commands. In some cases, even ambiguous abbreviations are allowed; for example, is specially defined as equivalent to even though there are other commands whose names start with . You can test abbreviations by using them as arguments to the command.\n\nA blank line as input to GDB (typing just ) means to repeat the previous command. Certain commands (for example, ) will not repeat this way; these are commands whose unintentional repetition might cause trouble and which you are unlikely to want to repeat. User-defined commands can disable this feature; see dont-repeat.\n\nThe and commands, when you repeat them with , construct new arguments rather than repeating exactly as typed. This permits easy scanning of source or memory.\n\nGDB can also use in another way: to partition lengthy output, in a way similar to the common utility (see Screen Size). Since it is easy to press one too many in this situation, GDB disables command repetition after any command that generates this sort of display.\n\nAny text from a to the end of the line is a comment; it does nothing. This is useful mainly in command files (see Command Files).\n\nThe binding is useful for repeating a complex sequence of commands. This command accepts the current line, like , and then fetches the next line relative to the current line from the history for editing.\n\nMany commands change their behavior according to command-specific variables or settings. These settings can be changed with the subcommands. For example, the command (see Examining Data) prints arrays differently depending on settings changeable with the commands and , among others.\n\nYou can change these settings to your preference in the gdbinit files loaded at GDB startup. See Startup.\n\nThe settings can also be changed interactively during the debugging session. For example, to change the limit of array elements to print, you can do the following:\n\nThe above command changes the number of elements to print from the default of 200 to 10. If you only intend this limit of 10 to be used for printing , then you must restore the limit back to 200, with .\n\nSome commands allow overriding settings with command options. For example, the command supports a number of options that allow overriding relevant global print settings as set by subcommands. See print options. The example above could be rewritten as:\n\nAlternatively, you can use the command to change a setting temporarily, for the duration of a command invocation.\n\nGDB can fill in the rest of a word in a command for you, if there is only one possibility; it can also show you what the valid possibilities are for the next word in a command, at any time. This works for GDB commands, GDB subcommands, command options, and the names of symbols in your program.\n\nPress the key whenever you want GDB to fill out the rest of a word. If there is only one possibility, GDB fills in the word, and waits for you to finish the command (or press to enter it). For example, if you type\n\nGDB fills in the rest of the word ‘ ’, since that is the only subcommand beginning with ‘ ’:\n\nYou can either press at this point, to run the command, or backspace and enter something else, if ‘ ’ does not look like the command you expected. (If you were sure you wanted in the first place, you might as well just type immediately after ‘ ’, to exploit command abbreviations rather than command completion).\n\nIf there is more than one possibility for the next word when you press , GDB sounds a bell. You can either supply more characters and try again, or just press a second time; GDB displays all the possible completions for that word. For example, you might want to set a breakpoint on a subroutine whose name begins with ‘ ’, but when you type GDB just sounds the bell. Typing again displays all the function names in your program that begin with those characters, for example:\n\nAfter displaying the available possibilities, GDB copies your partial input (‘ ’ in the example) so you can finish the command.\n\nIf the command you are trying to complete expects either a keyword or a number to follow, then ‘ ’ will be shown among the available completions, for example:\n\nHere, the option expects a number (e.g., ), not literal . Such metasyntactical arguments are always presented in uppercase.\n\nIf you just want to see the list of alternatives in the first place, you can press rather than pressing twice. means . You can type this either by holding down a key designated as the shift on your keyboard (if there is one) while typing , or as followed by .\n\nIf the number of possible completions is large, GDB will print as much of the list as it has collected, as well as a message indicating that the list may be truncated.\n\nThis behavior can be controlled with the following commands:\n\nSometimes the string you need, while logically a “word”, may contain parentheses or other characters that GDB normally excludes from its notion of a word. To permit word completion to work in this situation, you may enclose words in (single quote marks) in GDB commands.\n\nA likely situation where you might need this is in typing an expression that involves a C symbol name with template parameters. This is because when completing expressions, GDB treats the ‘ ’ character as word delimiter, assuming that it’s the less-than comparison operator (see C and C Operators).\n\nFor example, when you want to call a C template function interactively using the or commands, you may need to distinguish whether you mean the version of that was specialized for , , or the version that was specialized for , . To use the word-completion facilities in this situation, type a single quote at the beginning of the function name. This alerts GDB that it may need to consider more information than usual when you press or to request word completion:\n\nWhen setting breakpoints however (see Location Specifications), you don’t usually need to type a quote before the function name, because GDB understands that you want to set a breakpoint on a function:\n\nThis is true even in the case of typing the name of C overloaded functions (multiple definitions of the same function, distinguished by argument type). For example, when you want to set a breakpoint you don’t need to distinguish whether you mean the version of that takes an parameter, , or the version that takes a parameter, .\n\nSee quoting names for a description of other scenarios that require quoting.\n\nFor more information about overloaded functions, see C Expressions. You can use the command to disable overload resolution; see GDB Features for C .\n\nWhen completing in an expression which looks up a field in a structure, GDB also tries3 to limit completions to the field names available in the type of the left-hand-side:\n\nThis is because the is a variable of the type that is defined in GDB sources as follows:\n\nWhen passing filenames (or directory names) as arguments to a command, if the filename argument does not include any whitespace, double quotes, or single quotes, then for all commands the filename can be written as a simple string, for example:\n\nIf the filename does include whitespace, double quotes, or single quotes, then GDB has two approaches for how these filenames should be formatted; which format to use depends on which command is being used.\n\nMost GDB commands don’t require, or support, quoting and escaping. These commands treat any text after the command name, that is not a command option (see Command Options), as the filename, even if the filename contains whitespace or quote characters. In the following example the user is adding to the auto-load safe-path (see add-auto-load-safe-path):\n\nA small number of commands require that filenames containing whitespace or quote characters are either quoted, or have the special characters escaped with a backslash. Commands that support this style are marked as such in the manual, any command not marked as accepting quoting and escaping of its filename argument, does not accept this filename argument style.\n\nFor example, to load the file with the command (see Commands to Specify Files), you can escape the whitespace characters with a backslash:\n\nAlternatively the entire filename can be wrapped in either single or double quotes, in which case no backlsashes are needed, for example:\n\nIt is possible to include a quote character within a quoted filename by escaping it with a backslash, for example, within a filename surrounded by double quotes, a double quote character should be escaped with a backslash, but a single quote character should not be escaped. Within a single quoted string a single quote character needs to be escaped, but a double quote character does not.\n\nA literal backslash character can also be included by escaping it with a backslash.\n\nSome commands accept options starting with a leading dash. For example, . Similarly to command names, you can abbreviate a GDB option to the first few letters of the option name, if that abbreviation is unambiguous, and you can also use the key to get GDB to fill out the rest of a word in an option (or to show you the alternatives available, if there is more than one possibility).\n\nSome commands take raw input as argument. For example, the print command processes arbitrary expressions in any of the languages supported by GDB. With such commands, because raw input may start with a leading dash that would be confused with an option or any of its abbreviations, e.g. (short for or printing negative ?), if you specify any command option, then you must use a double-dash ( ) delimiter to indicate the end of options.\n\nSome options are described as accepting an argument which can be either or . These are known as boolean options. Similarly to boolean settings commands— and are the typical values, but any of , and can also be used as “true” value, and any of , and can also be used as “false” value. You can also omit a “true” value, as it is implied by default.\n\nFor example, these are equivalent:\n\nYou can discover the set of options some command accepts by completing on after the command name. For example:\n\nCompletion will in some cases guide you with a suggestion of what kind of argument an option expects. For example:\n\nHere, the option expects a number (e.g., ), not literal . Such metasyntactical arguments are always presented in uppercase.\n\nYou can always ask GDB itself for information on its commands, using the command .\n\nIn addition to , you can use the GDB commands and to inquire about the state of your program, or the state of GDB itself. Each command supports many topics of inquiry; this manual introduces each of them in the appropriate context. The listings under and under in the Command, Variable, and Function Index point to all the sub-commands. See Command and Variable Index.\n\nHere are several miscellaneous subcommands, all of which are exceptional in lacking corresponding commands:\n\nWhen you run a program under GDB, you must first generate debugging information when you compile it.\n\nYou may start GDB with its arguments, if any, in an environment of your choice. If you are doing native debugging, you may redirect your program’s input and output, debug an already running process, or kill a child process.\n\nIn order to debug a program effectively, you need to generate debugging information when you compile it. This debugging information is stored in the object file; it describes the data type of each variable or function and the correspondence between source line numbers and addresses in the executable code.\n\nTo request debugging information, specify the ‘ ’ option when you run the compiler.\n\nPrograms that are to be shipped to your customers are compiled with optimizations, using the ‘ ’ compiler option. However, some compilers are unable to handle the ‘ ’ and ‘ ’ options together. Using those compilers, you cannot generate optimized executables containing debugging information.\n\nGCC, the GNU C/C compiler, supports ‘ ’ with or without ‘ ’, making it possible to debug optimized code. We recommend that you always use ‘ ’ whenever you compile a program. You may think your program is correct, but there is no sense in pushing your luck. For more information, see Optimized Code.\n\nOlder versions of the GNU C compiler permitted a variant option ‘ ’ for debugging information. GDB no longer supports this format; if your GNU C compiler has this option, do not use it.\n\nGDB knows about preprocessor macros and can show you their expansion (see Macros). Most compilers do not include information about preprocessor macros in the debugging information if you specify the flag alone. Version 3.1 and later of GCC, the GNU C compiler, provides macro information if you are using the DWARF debugging format, and specify the option .\n\nSee Options for Debugging Your Program or GCC in , for more information on GCC options affecting debug information.\n\nYou will have the best debugging experience if you use the latest version of the DWARF debugging format that your compiler supports. DWARF is currently the most expressive and best supported debugging format in GDB.\n\nIf you are running your program in an execution environment that supports processes, creates an inferior process and makes that process run your program. In some environments without processes, jumps to the start of your program. Other targets, like ‘ ’, are always running. If you get an error message like this one:\n\nthen use to run your program. You may need first (see load).\n\nThe execution of a program is affected by certain information it receives from its superior. GDB provides ways to specify this information, which you must do before starting your program. (You can change it after starting your program, but such changes only affect your program the next time you start it.) This information may be divided into four categories:\n\nWhen you issue the command, your program begins to execute immediately. See Stopping and Continuing, for discussion of how to arrange for your program to stop. Once your program has stopped, you may call functions in your program, using the or commands. See Examining Data.\n\nIf the modification time of your symbol file has changed since the last time GDB read its symbols, GDB discards its symbol table, and reads it again. When it does this, GDB tries to retain your current breakpoints.\n\nThe arguments to your program can be specified by the arguments of the command. They are passed to a shell, which expands wildcard characters and performs redirection of I/O, and thence to your program. Your environment variable (if it exists) specifies what shell GDB uses. If you do not define , GDB uses the default shell ( on Unix).\n\nOn non-Unix systems, the program is usually invoked directly by GDB, which emulates I/O redirection via the appropriate system calls, and the wildcard characters are expanded by the startup code of the program, not by the shell.\n\nwith no arguments uses the same arguments used by the previous , or those set by the command.\n\nThe environment consists of a set of environment variables and their values. Environment variables conventionally record such things as your user name, your home directory, your terminal type, and your search path for programs to run. Usually you set up environment variables with the shell and they are inherited by all the other programs you run. When debugging, it can be useful to try running your program with a modified environment without having to start GDB over again.\n\nWarning: On Unix systems, GDB runs your program using the shell indicated by your environment variable if it exists (or if not). If your variable names a shell that runs an initialization file when started non-interactively—such as for C-shell, $ for the Z shell, or the file specified in the environment variable for BASH—any variables you set in that file affect your program. You may wish to move setting of environment variables to files that are only run when you sign on, such as or .\n\nEach time you start your program with , the inferior will be initialized with the current working directory specified by the command. If no directory has been specified by this command, then the inferior will inherit GDB’s current working directory as its working directory if native debugging, or it will inherit the remote server’s current working directory if remote debugging.\n\nIt is generally impossible to find the current working directory of the process being debugged (since a program can change its directory during its run). If you work on a system where GDB supports the command (see Process Information), you can use the command to find out the current working directory of the debuggee.\n\nBy default, the program you run under GDB does input and output to the same terminal that GDB uses. GDB switches the terminal to its own terminal modes to interact with you, but it records the terminal modes your program was using and switches back to them when you continue running your program.\n\nYou can redirect your program’s input and/or output using shell redirection with the command. For example,\n\nstarts your program, diverting its output to the file .\n\nAnother way to specify where your program should do input and output is with the command. This command accepts a file name as argument, and causes this file to be the default for future commands. It also resets the controlling terminal for the child process, for future commands. For example,\n\ndirects that processes started with subsequent commands default to do input and output on the terminal and have that as their controlling terminal.\n\nAn explicit redirection in overrides the command’s effect on the input/output device, but not its effect on the controlling terminal.\n\nWhen you use the command or redirect input in the command, only the input for your program is affected. The input for GDB still comes from your terminal. is an alias for .\n\nYou can use the command to tell GDB to display the name of the terminal that will be used for future runs of your program.\n\nTo use , your program must be running in an environment which supports processes; for example, does not work for programs on bare-board targets that lack an operating system. You must also have permission to send the process a signal.\n\nWhen you use , the debugger finds the program running in the process first by looking in the current working directory, then (if the program is not found) by using the source file search path (see Specifying Source Directories). You can also use the command to load the program. See Commands to Specify Files.\n\nIf the debugger can determine that the executable file running in the process it is attaching to does not match the current exec-file loaded by GDB, the option specifies how to handle the mismatch. GDB tries to compare the files by comparing their build IDs (see build ID), if available.\n\nThe first thing GDB does after arranging to debug the specified process is to stop it. You can examine and modify an attached process with all the GDB commands that are ordinarily available when you start processes with . You can insert breakpoints; you can step and continue; you can modify storage. If you would rather the process continue running, you may use the command after attaching GDB to the process.\n\nIf you exit GDB while you have an attached process, you detach that process. If you use the command, you kill that process. By default, GDB asks for confirmation if you try to do either of these things; you can control whether or not you need to confirm by using the command (see Optional Warnings and Messages).\n\nThis command is useful if you wish to debug a core dump instead of a running process. GDB ignores any core dump file while your program is running.\n\nOn some operating systems, a program cannot be executed outside GDB while you have breakpoints set on it inside GDB. You can use the command in this situation to permit running your program outside the debugger.\n\nThe command is also useful if you wish to recompile and relink your program, since on many systems it is impossible to modify an executable file while it is running in a process. In this case, when you next type , GDB notices that the file has changed, and reads the symbol table again (while trying to preserve your current breakpoint settings).\n\nGDB lets you run and debug multiple programs in a single session. In addition, GDB on some systems may let you run several programs simultaneously (otherwise you have to exit from one before starting another). On some systems GDB may even let you debug several programs simultaneously on different remote systems. In the most general case, you can have multiple threads of execution in each of multiple processes, launched from multiple executables, running on different machines.\n\nGDB represents the state of each program execution with an object called an inferior. An inferior typically corresponds to a process, but is more general and applies also to targets that do not have processes. Inferiors may be created before a process runs, and may be retained after a process exits. Inferiors have unique identifiers that are different from process ids. Usually each inferior will also have its own distinct address space, although some embedded targets may have several inferiors running in different parts of a single address space. Each inferior may in turn have multiple threads running in it.\n\nThe commands and , which will be introduced below, accept a space-separated ID list as their argument specifying one or more elements on which to operate. A list element can be either a single non-negative number, like ‘ ’, or an ascending range of such numbers, like ‘ ’. A list can consist of any combination of such elements, even duplicates or overlapping ranges are valid. E.g. ‘ ’ or ‘ ’.\n\nTo find out what inferiors exist at any moment, use :\n\nTo get information about the current inferior, use :\n\nTo find out what open target connections exist at any moment, use :\n\nTo switch focus between inferiors, use the command:\n\nThe debugger convenience variable ‘ ’ contains the number of the current inferior. You may find this useful in writing breakpoint conditional expressions, command scripts, and so forth. See Convenience Variables, for general information on convenience variables.\n\nYou can get multiple executables into a debugging session via the and commands. On some systems GDB can add inferiors to the debug session automatically by following calls to and . To remove inferiors from the debugging session use the command.\n\nTo quit debugging one of the running inferiors that is not the current inferior, you can either detach from it by using the command (allowing it to run independently), or kill it using the command:\n\nAfter the successful completion of a command such as , , or , or after a normal process exit, the inferior is still valid and listed with , ready to be restarted.\n\nTo be notified when inferiors are started or exit under GDB’s control use :\n\nMany commands will work the same with multiple programs as with a single program: e.g., will simply display the value of in the current inferior.\n\nOccasionally, when debugging GDB itself, it may be useful to get more info about the relationship of inferiors, programs, address spaces in a debug session. You can do that with the command.\n\nWhen debugging multiple inferiors, you can choose whether to set breakpoints for all inferiors, or for a particular inferior.\n\nInferior-specific breakpoints are automatically deleted when the corresponding inferior is removed from GDB. For example:\n\nA breakpoint can’t be both inferior-specific and thread-specific (see Thread-Specific Breakpoints), or task-specific (see Ada Tasks); using more than one of the , , or keywords when creating a breakpoint will give an error.\n\nIn some operating systems, such as GNU/Linux and Solaris, a single program may have more than one thread of execution. The precise semantics of threads differ from one operating system to another, but in general the threads of a single program are akin to multiple processes—except that they share one address space (that is, they can all examine and modify the same variables). On the other hand, each thread has its own registers and execution stack, and perhaps private memory.\n\nGDB provides these facilities for debugging multi-thread programs:\n• ‘ ’, a command to apply a command to a list of threads\n• ‘ ’, which controls printing of messages on thread start and exit.\n• ‘ ’, which lets the user specify which to use if the default choice isn’t compatible with the program.\n\nThe GDB thread debugging facility allows you to observe all threads while your program runs—but whenever GDB takes control, one thread in particular is always the focus of debugging. This thread is called the current thread. Debugging commands show program information from the perspective of the current thread.\n\nWhenever GDB detects a new thread in your program, it displays the target system’s identification for the thread with a message in the form ‘ ’, where is a thread identifier whose form varies depending on the particular system. For example, on GNU/Linux, you might see\n\nwhen GDB notices a new thread. In contrast, on other systems, the is simply something like ‘ ’, with no further qualifier.\n\nFor debugging purposes, GDB associates its own thread number —always a single integer—with each thread of an inferior. This number is unique between all threads of an inferior, but not unique between threads of different inferiors.\n\nYou can refer to a given thread in an inferior using the qualified . syntax, also known as qualified thread ID, with being the inferior number and being the thread number of the given inferior. For example, thread refers to thread number 3 of inferior 2. If you omit (e.g., ), then GDB infers you’re referring to a thread of the current inferior.\n\nUntil you create a second inferior, GDB does not show the part of thread IDs, even though you can always use the full . form to refer to threads of inferior 1, the initial inferior.\n\nSome commands accept a space-separated thread ID list as argument. A list element can be:\n• A thread ID as shown in the first field of the ‘ ’ display, with or without an inferior qualifier. E.g., ‘ ’ or ‘ ’.\n• A range of thread numbers, again with or without an inferior qualifier, as in . - or - . E.g., ‘ ’ or ‘ ’.\n• All threads of an inferior, specified with a star wildcard, with or without an inferior qualifier, as in . (e.g., ‘ ’) or . The former refers to all threads of the given inferior, and the latter form without an inferior qualifier refers to all threads of the current inferior.\n\nFor example, if the current inferior is 1, and inferior 7 has one thread with ID 7.1, the thread list ‘ ’ includes threads 1 to 3 of inferior 1, thread 5 of inferior 4, threads 7 to 9 of inferior 6 and all threads of inferior 7. That is, in expanded qualified form, the same as ‘ ’.\n\nIn addition to a per-inferior number, each thread is also assigned a unique global number, also known as global thread ID, a single integer. Unlike the thread number component of the thread ID, no two threads have the same global ID, even when you’re debugging multiple inferiors.\n\nFrom GDB’s perspective, a process always has at least one thread. In other words, GDB assigns a thread number to the program’s “main thread” even if the program is not multi-threaded.\n\nThe debugger convenience variables ‘ ’ and ‘ ’ contain, respectively, the per-inferior thread number and the global thread number of the current thread. You may find this useful in writing breakpoint conditional expressions, command scripts, and so forth. The convenience variable ‘ ’ contains the number of live threads in the current inferior. See Convenience Variables, for general information on convenience variables.\n\nWhen running in non-stop mode (see Non-Stop Mode), where new threads can be created, and existing threads exit, at any time, ‘ ’ could return a different value each time it is evaluated.\n\nIf GDB detects the program is multi-threaded, it augments the usual message about stopping at a breakpoint with the ID and name of the thread that hit the breakpoint.\n\nIf you’re debugging multiple inferiors, GDB displays thread IDs using the qualified . format. Otherwise, only is shown.\n\nIf you specify the ‘ ’ option, GDB displays a column indicating each thread’s global thread ID:\n\nOn Solaris, you can display more information about user threads with a Solaris-specific command:\n\nSee Stopping and Starting Multi-thread Programs, for more information about how GDB behaves when you stop and start programs with multiple threads.\n\nSee Setting Watchpoints, for information about watchpoints in programs with multiple threads.\n\nOn most systems, GDB has no special support for debugging programs which create additional processes using the function. When a program forks, GDB will continue to debug the parent process and the child process will run unimpeded. If you have set a breakpoint in any code which the child then executes, the child will get a signal which (unless it catches the signal) will cause it to terminate.\n\nHowever, if you want to debug the child process there is a workaround which isn’t too painful. Put a call to in the code which the child process executes after the fork. It may be useful to sleep only if a certain environment variable is set, or a certain file exists, so that the delay need not occur when you don’t want to run GDB on the child. While the child is sleeping, use the program to get its process ID. Then tell GDB (a new invocation of GDB if you are also debugging the parent process) to attach to the child process (see Attach). From that point on you can debug the child process just like any other process which you attached to.\n\nOn some systems, GDB provides support for debugging programs that create additional processes using the or functions. On GNU/Linux platforms, this feature is supported with kernel version 2.5.46 and later.\n\nThe fork debugging commands are supported in native mode and when connected to in either mode or mode.\n\nBy default, when a program forks, GDB will continue to debug the parent process and the child process will run unimpeded.\n\nIf you want to follow the child process instead of the parent process, use the command .\n\nOn Linux, if you want to debug both the parent and child processes, use the command .\n\nIf you choose to set ‘ ’ mode off, then GDB will retain control of all forked processes (including nested forks). You can list the forked processes under the control of GDB by using the command, and switch from one fork to another by using the command (see Debugging Multiple Inferiors Connections and Programs).\n\nTo quit debugging one of the forked processes, you can either detach from it by using the command (allowing it to run independently), or kill it using the command. See Debugging Multiple Inferiors Connections and Programs.\n\nIf you ask to debug a child process and a is followed by an , GDB executes the new target up to the first breakpoint in the new target. If you have a breakpoint set on in your original program, the breakpoint will also be set on the child process’s .\n\nOn some systems, when a child process is spawned by , you cannot debug the child or parent until an call completes.\n\nIf you issue a command to GDB after an call executes, the new target restarts. To restart the parent process, use the command with the parent executable name as its argument. By default, after an call executes, GDB discards the symbols of the previous executable image. You can change this behavior with the command.\n\nis supported in native mode and mode.\n\nYou can use the command to make GDB stop whenever a , , or call is made. See Setting Catchpoints.\n\n4.12 Setting a Bookmark to Return to Later\n\nOn certain operating systems4, GDB is able to save a snapshot of a program’s state, called a checkpoint, and come back to it later.\n\nReturning to a checkpoint effectively undoes everything that has happened in the program since the was saved. This includes changes in memory, registers, and even (within some limits) system state. Effectively, it is like going back in time to the moment when the checkpoint was saved.\n\nThus, if you’re stepping through a program and you think you’re getting close to the point where things go wrong, you can save a checkpoint. Then, if you accidentally go too far and miss the critical statement, instead of having to restart your program from the beginning, you can just go back to the checkpoint and start again from there.\n\nThis can be especially useful if it takes a lot of time or steps to reach the point where you think the bug occurs.\n\nTo use the / method of debugging:\n\nReturning to a previously saved checkpoint will restore the user state of the program being debugged, plus a significant subset of the system (OS) state, including file pointers. It won’t “un-write” data from a file, but it will rewind the file pointer to the previous location, so that the previously written data can be overwritten. For files opened in read mode, the pointer will also be restored so that the previously read data can be read again.\n\nOf course, characters that have been sent to a printer (or other external device) cannot be “snatched back”, and characters received from eg. a serial device can be removed from internal program buffers, but they cannot be “pushed back” into the serial pipeline, ready to be received again. Similarly, the actual contents of files that have been changed cannot be restored (at this time).\n\nHowever, within those constraints, you actually can “rewind” your program to a previously saved point in time, and begin debugging it again — and you can change the course of events so as to debug a different execution path this time.\n\nFinally, there is one bit of internal program state that will be different when you return to a checkpoint — the program’s process id. Each checkpoint will have a unique process id (or ), and each will be different from the program’s original . If your program has saved a local copy of its process id, this could potentially pose a problem.\n\nOn some systems such as GNU/Linux, address space randomization is performed on new processes for security reasons. This makes it difficult or impossible to set a breakpoint, or watchpoint, on an absolute address if you have to restart the program, since the absolute location of a symbol will change from one execution to the next.\n\nA checkpoint, however, is an identical copy of a process. Therefore if you create a checkpoint at (eg.) the start of main, and simply return to that checkpoint instead of restarting the process, you can avoid the effects of address randomization and your symbols will all stay in the same place.\n\nThe principal purposes of using a debugger are so that you can stop your program before it terminates; or so that, if your program runs into trouble, you can investigate and find out why.\n\nInside GDB, your program may stop for any of several reasons, such as a signal, a breakpoint, or reaching a new line after a GDB command such as . You may then examine and change variables, set new breakpoints or remove old ones, and then continue execution. Usually, the messages shown by GDB provide ample explanation of the status of your program—but you can also explicitly request this information at any time.\n\nA breakpoint makes your program stop whenever a certain point in the program is reached. For each breakpoint, you can add conditions to control in finer detail whether your program stops. You can set breakpoints with the command and its variants (see Setting Breakpoints), to specify the place where your program should stop by line number, function name or exact address in the program.\n\nOn some systems, you can set breakpoints in shared libraries before the executable is run.\n\nA watchpoint is a special breakpoint that stops your program when the value of an expression changes. The expression may be a value of a variable, or it could involve values of one or more variables combined by operators, such as ‘ ’. This is sometimes called data breakpoints. You must use a different command to set watchpoints (see Setting Watchpoints), but aside from that, you can manage a watchpoint like any other breakpoint: you enable, disable, and delete both breakpoints and watchpoints using the same commands.\n\nYou can arrange to have values from your program displayed automatically whenever GDB stops at a breakpoint. See Automatic Display.\n\nA catchpoint is another special breakpoint that stops your program when a certain kind of event occurs, such as the throwing of a C exception or the loading of a library. As with watchpoints, you use a different command to set a catchpoint (see Setting Catchpoints), but aside from that, you can manage a catchpoint like any other breakpoint. (To stop when your program receives a signal, use the command; see Signals.)\n\nGDB assigns a number to each breakpoint, watchpoint, or catchpoint when you create it; these numbers are successive integers starting with one. In many of the commands for controlling various features of breakpoints you use the breakpoint number to say which breakpoint you want to change. Each breakpoint may be enabled or disabled; if disabled, it has no effect on your program until you enable it again.\n\nSome GDB commands accept a space-separated list of breakpoints on which to operate. A list element can be either a single breakpoint number, like ‘ ’, or a range of such numbers, like ‘ ’. When a breakpoint list is given to a command, all breakpoints in that list are operated on.\n\nBreakpoints are set with the command (abbreviated ). The debugger convenience variable ‘ ’ records the number of the breakpoint you’ve set most recently:\n\nA breakpoint may be mapped to multiple code locations for example with inlined functions, Ada generics, C templates or overloaded function names. GDB then indicates the number of code locations in the breakpoint command output:\n\nWhen your program stops on a breakpoint, the convenience variables ‘ ’ and ‘ ’ are respectively set to the number of the encountered breakpoint and the number of the breakpoint’s code location:\n\nNote that ‘ ’ and ‘ ’ are not equivalent: ‘ ’ is set to the breakpoint number last hit, while ‘ ’ is set to the breakpoint number last set.\n\nIf the encountered breakpoint has only one code location, ‘ ’ is set to 1:\n\nThe ‘ ’ and ‘ ’ variables can typically be used in a breakpoint command list. (see Breakpoint Command Lists). For example, as part of the breakpoint command list, you can disable completely the encountered breakpoint using or disable the specific encountered breakpoint location using . If a breakpoint has only one location, ‘ ’ is set to 1 and the commands and both disable the breakpoint.\n\nYou can also define aliases to easily disable the last hit location or last hit breakpoint:\n\nGDB allows you to set any number of breakpoints at the same place in your program. There is nothing silly or meaningless about this. When the breakpoints are conditional, this is even useful (see Break Conditions).\n\nIt is possible that a single logical breakpoint is set at several code locations in your program. See Location Specifications, for examples.\n\nA breakpoint with multiple code locations is displayed in the breakpoint table using several rows—one header row, followed by one row for each code location. The header row has ‘ ’ in the address column. Each code location row contains the actual address, source file, source line and function of its code location. The number column for a code location is of the form . .\n\nYou cannot delete the individual locations from a breakpoint. However, each location can be individually enabled or disabled by passing . as argument to the and commands. It’s also possible to and a range of locations using a and two s, in increasing order, separated by a hyphen, like , in which case GDB acts on all the locations in the range (inclusive). Disabling or enabling the parent breakpoint (see Disabling) affects all of the locations that belong to that breakpoint.\n\nLocations that are enabled while their parent breakpoint is disabled won’t trigger a break, and are denoted by in the column. For example:\n\nIt’s quite common to have a breakpoint inside a shared library. Shared libraries can be loaded and unloaded explicitly, and possibly repeatedly, as the program is executed. To support this use case, GDB updates breakpoint locations whenever any shared library is loaded or unloaded. Typically, you would set a breakpoint in a shared library at the beginning of your debugging session, when the library is not loaded, and when the symbols from the library are not available. When you try to set breakpoint, GDB will ask you if you want to set a so called pending breakpoint—breakpoint whose address is not yet resolved.\n\nAfter the program is run, whenever a new shared library is loaded, GDB reevaluates all the breakpoints. When a newly loaded shared library contains the symbol or line referred to by some pending breakpoint, that breakpoint is resolved and becomes an ordinary breakpoint. When a library is unloaded, all breakpoints that refer to its symbols or source lines become pending again.\n\nThis logic works for breakpoints with multiple locations, too. For example, if you have a breakpoint in a C template function, and a newly loaded shared library has an instantiation of that template, a new location is added to the list of locations for the breakpoint.\n\nExcept for having unresolved address, pending breakpoints do not differ from regular breakpoints. You can set conditions or commands, enable and disable them and perform other breakpoint operations.\n\nGDB provides some additional commands for controlling what happens when the ‘ ’ command cannot resolve the location spec to any code location in your program (see Location Specifications):\n\nThe settings above only affect the command and its variants. Once a breakpoint is set, it will be automatically updated as shared libraries are loaded and unloaded.\n\nFor some targets, GDB can automatically decide if hardware or software breakpoints should be used, depending on whether the breakpoint address is read-only or read-write. This applies to breakpoints set with the command as well as to internal breakpoints set by commands like and . For breakpoints set with , GDB will always use hardware breakpoints.\n\nYou can control this automatic behavior with the following commands:\n\nGDB normally implements breakpoints by replacing the program code at the breakpoint address with a special instruction, which, when executed, given control to the debugger. By default, the program code is so modified only when the program is resumed. As soon as the program stops, GDB restores the original instructions. This behavior guards against leaving breakpoints inserted in the target should gdb abrubptly disconnect. However, with slow remote targets, inserting and removing breakpoint can reduce the performance. This behavior can be controlled with the following commands::\n\nGDB handles conditional breakpoints by evaluating these conditions when a breakpoint breaks. If the condition is true, then the process being debugged stops, otherwise the process is resumed.\n\nIf the target supports evaluating conditions on its end, GDB may download the breakpoint, together with its conditions, to it.\n\nThis feature can be controlled via the following commands:\n\nGDB itself sometimes sets breakpoints in your program for special purposes, such as proper handling of (in C programs). These internal breakpoints are assigned negative numbers, starting with ; ‘ ’ does not display them. You can see these breakpoints with the GDB maintenance command ‘ ’ (see maint info breakpoints).\n\nYou can use a watchpoint to stop execution whenever the value of an expression changes, without having to predict a particular place where this may happen. (This is sometimes called a data breakpoint.) The expression may be as simple as the value of a single variable, or as complex as many variables combined by operators. Examples include:\n• A reference to the value of a single variable.\n• An address cast to an appropriate data type. For example, ‘ ’ will watch a 4-byte region at the specified address (assuming an occupies 4 bytes).\n• An arbitrarily complex expression, such as ‘ ’. The expression can use any operators valid in the program’s native language (see Languages).\n\nYou can set a watchpoint on an expression even if the expression can not be evaluated yet. For instance, you can set a watchpoint on ‘ ’ before ‘ ’ is initialized. GDB will stop when your program sets ‘ ’ and the expression produces a valid value. If the expression becomes valid in some other way than changing a variable (e.g. if the memory pointed to by ‘ ’ becomes readable as the result of a call), GDB may not stop until the next time the expression changes.\n\nDepending on your system, watchpoints may be implemented in software or hardware. GDB does software watchpointing by single-stepping your program and testing the variable’s value each time, which is hundreds of times slower than normal execution. (But this may still be worth it, to catch errors where you have no clue what part of your program is the culprit.)\n\nOn some systems, such as most PowerPC or x86-based targets, GDB includes support for hardware watchpoints, which do not slow down the running of your program.\n\nIf you watch for a change in a numerically entered address you need to dereference it, as the address itself is just a constant number which will never change. GDB refuses to create a watchpoint that watches a never-changing value:\n\nGDB sets a hardware watchpoint if possible. Hardware watchpoints execute very quickly, and the debugger reports a change in value at the exact instruction where the change occurs. If GDB cannot set a hardware watchpoint, it sets a software watchpoint, which executes more slowly and reports the change in value at the next statement, not the instruction, after the change occurs.\n\nYou can force GDB to use only software watchpoints with the command. With this variable set to zero, GDB will never try to use hardware watchpoints, even if the underlying system supports them. (Note that hardware-assisted watchpoints that were set before setting to zero will still use the hardware mechanism of watching expression values.)\n\nFor remote targets, you can restrict the number of hardware watchpoints GDB will use, see set remote hardware-breakpoint-limit.\n\nWhen you issue the command, GDB reports\n\nif it was able to set a hardware watchpoint.\n\nCurrently, the and commands can only set hardware watchpoints, because accesses to data that don’t change the value of the watched expression cannot be detected without examining every instruction as it is being executed, and GDB does not do that currently. If GDB finds that it is unable to set a hardware breakpoint with the or command, it will print a message like this:\n\nSometimes, GDB cannot set a hardware watchpoint because the data type of the watched expression is wider than what a hardware watchpoint on the target machine can handle. For example, some systems can only watch regions that are up to 4 bytes wide; on such systems you cannot set hardware watchpoints for an expression that yields a double-precision floating-point number (which is typically 8 bytes wide). As a work-around, it might be possible to break the large region into a series of smaller ones and watch them with separate watchpoints.\n\nIf you set too many hardware watchpoints, GDB might be unable to insert all of them when you resume the execution of your program. Since the precise number of active watchpoints is unknown until such time as the program is about to be resumed, GDB might not be able to warn you about this when you set the watchpoints, and the warning will be printed only when the program is resumed:\n\nIf this happens, delete or disable some of the watchpoints.\n\nWatching complex expressions that reference many variables can also exhaust the resources available for hardware-assisted watchpoints. That’s because GDB needs to watch every variable in the expression with separately allocated resources.\n\nIf you call a function interactively using or , any watchpoints you have set will be inactive until GDB reaches another kind of breakpoint or the call completes.\n\nGDB automatically deletes watchpoints that watch local (automatic) variables, or expressions that involve such variables, when they go out of scope, that is, when the execution leaves the block in which these variables were defined. In particular, when the program being debugged terminates, all local variables go out of scope, and so only watchpoints that watch global variables remain set. If you rerun the program, you will need to set all such watchpoints again. One way of doing that would be to set a code breakpoint at the entry to the function and when it breaks, set all the watchpoints.\n\nIn multi-threaded programs, watchpoints will detect changes to the watched expression from every thread.\n\nYou can use catchpoints to cause the debugger to stop for certain kinds of program events, such as C exceptions or the loading of a shared library. Use the command to set a catchpoint.\n\nUse the command to list the current catchpoints.\n\nIt is often necessary to eliminate a breakpoint, watchpoint, or catchpoint once it has done its job and you no longer want your program to stop there. This is called deleting the breakpoint. A breakpoint that has been deleted no longer exists; it is forgotten.\n\nWith the command you can delete breakpoints according to where they are in your program. With the command you can delete individual breakpoints, watchpoints, or catchpoints by specifying their breakpoint numbers.\n\nIt is not necessary to delete a breakpoint to proceed past it. GDB automatically ignores breakpoints on the first instruction to be executed when you continue execution without changing the execution address.\n\nRather than deleting a breakpoint, watchpoint, or catchpoint, you might prefer to disable it. This makes the breakpoint inoperative as if it had been deleted, but remembers the information on the breakpoint so that you can enable it again later.\n\nYou disable and enable breakpoints, watchpoints, tracepoints, and catchpoints with the and commands, optionally specifying one or more breakpoint numbers as arguments. Use to print a list of all breakpoints, watchpoints, tracepoints, and catchpoints if you do not know which numbers to use.\n\nDisabling and enabling a breakpoint that has multiple locations affects all of its locations.\n\nA breakpoint, watchpoint, or catchpoint can have any of several different states of enablement:\n• Enabled. The breakpoint stops your program. A breakpoint set with the command starts out in this state.\n• Disabled. The breakpoint has no effect on your program.\n• Enabled once. The breakpoint stops your program, but then becomes disabled.\n• Enabled for a count. The breakpoint stops your program for the next N times, then becomes disabled.\n• Enabled for deletion. The breakpoint stops your program, but immediately after it does so it is deleted permanently. A breakpoint set with the command starts out in this state.\n\nYou can use the following commands to enable or disable breakpoints, watchpoints, tracepoints, and catchpoints:\n\nExcept for a breakpoint set with (see Setting Breakpoints), breakpoints that you set are initially enabled; subsequently, they become disabled or enabled only when you use one of the commands above. (The command can set and delete a breakpoint of its own, but it does not change the state of your other breakpoints; see Continuing and Stepping.)\n\nThe simplest sort of breakpoint breaks every time your program reaches a specified place. You can also specify a condition for a breakpoint. A condition is just a Boolean expression in your programming language (see Expressions). A breakpoint with a condition evaluates the expression each time your program reaches it, and your program stops only if the condition is true.\n\nThis is the converse of using assertions for program validation; in that situation, you want to stop when the assertion is violated—that is, when the condition is false. In C, if you want to test an assertion expressed by the condition , you should set the condition ‘ ’ on the appropriate breakpoint.\n\nConditions are also accepted for watchpoints; you may not need them, since a watchpoint is inspecting the value of an expression anyhow—but it might be simpler, say, to just set a watchpoint on a variable name, and specify a condition that tests whether the new value is an interesting one.\n\nBreak conditions can have side effects, and may even call functions in your program. This can be useful, for example, to activate functions that log program progress, or to use your own print functions to format special data structures. The effects are completely predictable unless there is another enabled breakpoint at the same address. (In that case, GDB might see the other breakpoint first and stop your program without checking the condition of this one.) Note that breakpoint commands are usually more convenient and flexible than break conditions for the purpose of performing side effects when a breakpoint is reached (see Breakpoint Command Lists).\n\nBreakpoint conditions can also be evaluated on the target’s side if the target supports it. Instead of evaluating the conditions locally, GDB encodes the expression into an agent expression (see Agent Expressions) suitable for execution on the target, independently of GDB. Global variables become raw memory locations, locals become stack accesses, and so forth.\n\nIn this case, GDB will only be notified of a breakpoint trigger when its condition evaluates to true. This mechanism may provide faster response times depending on the performance characteristics of the target since it does not need to keep GDB informed about every breakpoint trigger, even those with false conditions.\n\nBreak conditions can be specified when a breakpoint is set, by using ‘ ’ in the arguments to the command. See Setting Breakpoints. They can also be changed at any time with the command.\n\nYou can also use the keyword with the command. The command does not recognize the keyword; is the only way to impose a further condition on a catchpoint.\n\nA special case of a breakpoint condition is to stop only when the breakpoint has been reached a certain number of times. This is so useful that there is a special way to do it, using the ignore count of the breakpoint. Every breakpoint has an ignore count, which is an integer. Most of the time, the ignore count is zero, and therefore has no effect. But if your program reaches a breakpoint whose ignore count is positive, then instead of stopping, it just decrements the ignore count by one and continues. As a result, if the ignore count value is , the breakpoint does not stop the next times your program reaches it.\n\nYou can give any breakpoint (or watchpoint or catchpoint) a series of commands to execute when your program stops due to that breakpoint. For example, you might want to print the values of certain expressions, or enable other breakpoints.\n\nPressing as a means of repeating the last GDB command is disabled within a .\n\nInside a command list, you can use the command to disable the encountered breakpoint.\n\nIf your breakpoint has several code locations, the command will disable the specific breakpoint code location encountered. If the breakpoint has only one location, this command will disable the encountered breakpoint.\n\nYou can use breakpoint commands to start your program up again. Simply use the command, or , or any other command that resumes execution.\n\nAny other commands in the command list, after a command that resumes execution, are ignored. This is because any time you resume execution (even with a simple or ), you may encounter another breakpoint—which could have its own command list, leading to ambiguities about which list to execute.\n\nIf the first command you specify in a command list is , the usual message about stopping at a breakpoint is not printed. This may be desirable for breakpoints that are to print a specific message and then continue. If none of the remaining commands print anything, you see no sign that the breakpoint was reached. is meaningful only at the beginning of a breakpoint command list.\n\nThe commands , , and allow you to print precisely controlled output, and are often useful in silent breakpoints. See Commands for Controlled Output.\n\nFor example, here is how you could use breakpoint commands to print the value of at entry to whenever is positive.\n\nOne application for breakpoint commands is to compensate for one bug so you can test for another. Put a breakpoint just after the erroneous line of code, give it a condition to detect the case in which something erroneous has been done, and give it commands to assign correct values to any variables that need them. End with the command so that your program does not stop, and start with the command so that no output is produced. Here is an example:\n\nThe dynamic printf command combines a breakpoint with formatted printing of your program’s data to give you the effect of inserting calls into your program on-the-fly, without having to recompile it.\n\nIn its most basic form, the output goes to the GDB console. However, you can set the variable for alternate handling. For instance, you can ask to format the output by calling your program’s function. This has the advantage that the characters go to the program’s output device, so they can recorded in redirects to files and so forth.\n\nIf you are doing remote debugging with a stub or agent, you can also ask to have the printf handled by the remote agent. In addition to ensuring that the output goes to the remote program’s device along with any other output the program might produce, you can also ask that the dprintf remain active even after disconnecting from the remote target. Using the stub/agent is also more efficient, as it can do everything without needing to communicate with GDB.\n\nGDB does not check the validity of function and channel, relying on you to supply values that are meaningful for the contexts in which they are being used. For instance, the function and channel may be the values of local variables, but if that is the case, then all enabled dynamic prints must be at locations within the scope of those locals. If evaluation fails, GDB will report an error.\n\n5.1.9 How to save breakpoints to a file\n\nTo save breakpoint definitions to a file use the command.\n\nGDB supports SDT probes in the code. stands for Statically Defined Tracing, and the probes are designed to have a tiny runtime code and data footprint, and no dynamic relocations.\n\nCurrently, the following types of probes are supported on ELF-compatible systems:\n• (http://sourceware.org/systemtap/) probes5. probes are usable from assembly, C and C languages6.\n• (http://oss.oracle.com/projects/DTrace) probes. probes are usable from C and C languages.\n\nSome probes have an associated semaphore variable; for instance, this happens automatically if you defined your probe using a DTrace-style file. If your probe has a semaphore, GDB will automatically enable it when you specify a breakpoint using the ‘ ’ notation. But, if you put a breakpoint at a probe’s location by some other method (e.g., ), then GDB will not automatically set the semaphore. probes do not support semaphores.\n\nYou can examine the available static static probes using , with optional arguments:\n\nSome probe points can be enabled and/or disabled. The effect of enabling or disabling a probe depends on the type of probe being handled. Some probes can be enabled or disabled, but probes cannot be disabled.\n\nYou can enable (or disable) one or more probes using the following commands, with optional arguments:\n\nA probe may specify up to twelve arguments. These are available at the point at which the probe is defined—that is, when the current PC is at the probe’s location. The arguments are available using the convenience variables (see Convenience Vars) … . In probes each probe argument is an integer of the appropriate size; types are not preserved. In probes types are preserved provided that they are recognized as such by GDB; otherwise the value of the probe argument will be a long integer. The convenience variable holds the number of arguments at the current probe point.\n\nThese variables are always available, but attempts to access them at any location other than a probe point will cause GDB to give an error message.\n\nIf you request too many active hardware-assisted breakpoints and watchpoints, you will see this error message:\n\nThis message is printed when you attempt to resume the program, since only then GDB knows exactly how many hardware breakpoints and watchpoints it needs to insert.\n\nWhen this message is printed, you need to disable or remove some of the hardware-assisted breakpoints and watchpoints, and then continue.\n\nSome processor architectures place constraints on the addresses at which breakpoints may be placed. For architectures thus constrained, GDB will attempt to adjust the breakpoint’s address to comply with the constraints dictated by the architecture.\n\nOne example of such an architecture is the Fujitsu FR-V. The FR-V is a VLIW architecture in which a number of RISC-like instructions may be bundled together for parallel execution. The FR-V architecture constrains the location of a breakpoint instruction within such a bundle to the instruction with the lowest address. GDB honors this constraint by adjusting a breakpoint’s address to the first in the bundle.\n\nIt is not uncommon for optimized code to have bundles which contain instructions from different source statements, thus it may happen that a breakpoint’s address will be adjusted from one source statement to another. Since this adjustment may significantly alter GDB’s breakpoint related behavior from what the user expects, a warning is printed when the breakpoint is first set and also when the breakpoint is hit.\n\nA warning like the one below is printed when setting a breakpoint that’s been subject to address adjustment:\n\nSuch warnings are printed both for user settable and GDB’s internal breakpoints. If you see one of these warnings, you should verify that a breakpoint set at the adjusted address will have the desired affect. If not, the breakpoint in question may be removed and other breakpoints may be set which will have the desired behavior. E.g., it may be sufficient to place the breakpoint at a later instruction. A conditional breakpoint may also be useful in some cases to prevent the breakpoint from triggering too often.\n\nGDB will also issue a warning when stopping at one of these adjusted breakpoints:\n\nWhen this warning is encountered, it may be too late to take remedial action except in cases where the breakpoint is hit earlier or more frequently than expected.\n\nContinuing means resuming program execution until your program completes normally. In contrast, stepping means executing just one more “step” of your program, where “step” may mean either one line of source code, or one machine instruction (depending on what particular command you use). Either when continuing or when stepping, your program may stop even sooner, due to a breakpoint or a signal. (If it stops due to a signal, you may want to use , or use ‘ ’ to resume execution (see Signals), or you may step into the signal’s handler (see stepping and signal handlers).)\n\nTo resume execution at a different place, you can use (see Returning from a Function) to go back to the calling function; or (see Continuing at a Different Address) to go to an arbitrary location in your program.\n\nA typical technique for using stepping is to set a breakpoint (see Breakpoints; Watchpoints; and Catchpoints) at the beginning of the function or the section of your program where a problem is believed to lie, run your program until it stops at that breakpoint, and then step through the suspect area, examining the variables that are interesting, until you see the problem happen.\n\nBy default, and if available, GDB makes use of target-assisted range stepping. In other words, whenever you use a stepping command (e.g., , ), GDB tells the target to step the corresponding range of instruction addresses instead of issuing multiple single-steps. This speeds up line stepping, particularly for remote targets. Ideally, there should be no reason you would want to turn range stepping off. However, it’s possible that a bug in the debug info, a bug in the remote stub (for remote targets), or even a bug in GDB could make line stepping behave incorrectly when target-assisted range stepping is enabled. You can use the following command to turn off range stepping if necessary:\n\nThe program you are debugging may contain some functions which are uninteresting to debug. The command lets you tell GDB to skip a function, all functions in a file or a particular function in a particular file when stepping.\n\nFor example, consider the following C function:\n\nSuppose you wish to step into the functions and , but you are not interested in stepping through . If you run at line 103, you’ll enter , but if you run , you’ll step over both and !\n\nOne solution is to into and use the command to immediately exit it. But this can become tedious if is called from many places.\n\nA more flexible solution is to execute . This instructs GDB never to step into . Now when you execute at line 103, you’ll step over and directly into .\n\nFunctions may be skipped by providing either a function name, linespec (see Location Specifications), regular expression that matches the function’s name, file name or a -style pattern that matches the file name.\n\nOn Posix systems the form of the regular expression is “Extended Regular Expressions”. See for example ‘ ’ on GNU/Linux systems. On non-Posix systems the form of the regular expression is whatever is provided by the function of the underlying system. See for example ‘ ’ on GNU/Linux systems for a description of -style patterns.\n\nSkips can be listed, deleted, disabled, and enabled, much like breakpoints. These are the commands for managing your list of skips:\n\nA signal is an asynchronous event that can happen in a program. The operating system defines the possible kinds of signals, and gives each kind a name and a number. For example, in Unix is the signal a program gets when you type an interrupt character (often ); is the signal a program gets from referencing a place in memory far away from all the areas in use; occurs when the alarm clock timer goes off (which happens only if your program has requested an alarm).\n\nSome signals, including , are a normal part of the functioning of your program. Others, such as , indicate errors; these signals are fatal (they kill your program immediately) if the program has not specified in advance some other way to handle the signal. does not indicate an error in your program, but it is normally fatal so it can carry out the purpose of the interrupt: to kill the program.\n\nGDB has the ability to detect any occurrence of a signal in your program. You can tell GDB in advance what to do for each kind of signal, apart from SIGKILL, which has its usual effect regardless.\n\nWhen specifying a signal by number, GDB translates the number to the target platform according to the corresponding signal name. For example, GDB always treats signal 1 as . So, when specifying ‘ ’ as a signal, GDB will translate this to the target’s , whatever that might be.\n\nNumbers may only be used for signals 1 through 15. GDB uses this mapping:\n\nNormally, GDB is set up to let the non-erroneous signals like be silently passed to your program (so as not to interfere with their role in the program’s functioning) but to stop your program immediately whenever an error signal happens. You can change these settings with the command.\n\nThe keywords allowed by the command can be abbreviated. Their full names are:\n\nWhen a signal stops your program, the signal is not visible to the program until you continue. Your program sees the signal then, if is in effect for the signal in question at that time. In other words, after GDB reports a signal, you can use the command with or to control whether your program sees that signal when you continue.\n\nThe default is set to , , for non-erroneous signals such as , and , and to , , for the erroneous signals.\n\nYou can also use the command to prevent your program from seeing a signal, or cause it to see a signal it normally would not see, or to give it any signal at any time. For example, if your program stopped due to some sort of memory reference error, you might store correct values into the erroneous variables and continue, hoping to see more execution; but your program would probably terminate immediately as a result of the fatal signal once it saw the signal. To prevent this, you can continue with ‘ ’. See Giving your Program a Signal.\n\nGDB optimizes for stepping the mainline code. If a signal that has and set arrives while a stepping command (e.g., , , ) is in progress, GDB lets the signal handler run and then resumes stepping the mainline code once the signal handler returns. In other words, GDB steps over the signal handler. This prevents signals that you’ve specified as not interesting (with ) from changing the focus of debugging unexpectedly. Note that the signal handler itself may still hit a breakpoint, stop for another signal that has in effect, or for any other event that normally results in stopping the stepping command sooner. Also note that GDB still informs you that the program received a signal if is set.\n\nIf you set for a signal, and your program sets up a handler for it, then issuing a stepping command, such as or , when your program is stopped due to the signal will step into the signal handler (if the target supports that).\n\nLikewise, if you use the command to queue a signal to be delivered to the current thread when execution of the thread resumes (see Giving your Program a Signal), then a stepping command will step into the signal handler.\n\nHere’s an example, using to step to the first instruction of ’s handler:\n\nThe same, but using instead of waiting for the program to receive the signal first:\n\nOn some targets, GDB can inspect extra signal information associated with the intercepted signal, before it is actually delivered to the program being debugged. This information is exported by the convenience variable , and consists of data that is passed by the kernel to the signal handler at the time of the receipt of a signal. The data type of the information itself is target dependent. You can see the data type using the command. On Unix systems, it typically corresponds to the standard type, as defined in the system header.\n\nHere’s an example, on a GNU/Linux system, printing the stray referenced address that raised a segmentation fault.\n\nDepending on target support, may also be writable.\n\nGDB supports debugging programs with multiple threads (see Debugging Programs with Multiple Threads). There are two modes of controlling execution of your program within the debugger. In the default mode, referred to as all-stop mode, when any thread in your program stops (for example, at a breakpoint or while being stepped), all other threads in the program are also stopped by GDB. On some targets, GDB also supports non-stop mode, in which other threads can continue to run freely while you examine the stopped thread in the debugger.\n\nIn all-stop mode, whenever your program stops under GDB for any reason, all threads of execution stop, not just the current thread. This allows you to examine the overall state of the program, including switching between threads, without worrying that things may change underfoot.\n\nConversely, whenever you restart the program, all threads start executing. This is true even when single-stepping with commands like or .\n\nIn particular, GDB cannot single-step all threads in lockstep. Since thread scheduling is up to your debugging target’s operating system (not controlled by GDB), other threads may execute more than one statement while the current thread completes a single step. Moreover, in general other threads stop in the middle of a statement, rather than at a clean statement boundary, when the program stops.\n\nYou might even find your program stopped in another thread after continuing or even single-stepping. This happens whenever some other thread runs into a breakpoint, a signal, or an exception before the first thread completes whatever you requested.\n\nWhenever GDB stops your program, due to a breakpoint or a signal, it automatically selects the thread where that breakpoint or signal happened. GDB alerts you to the context switch with a message such as ‘ ’ to identify the thread.\n\nOn some OSes, you can modify GDB’s default behavior by locking the OS scheduler to allow only a single thread to run.\n\nBy default, when you issue one of the execution commands such as , or , GDB allows only threads of the current inferior to run. For example, if GDB is attached to two inferiors, each with two threads, the command resumes only the two threads of the current inferior. This is useful, for example, when you debug a program that forks and you want to hold the parent stopped (so that, for instance, it doesn’t run to exit), while you debug the child. In other situations, you may not be interested in inspecting the current state of any of the processes GDB is attached to, and you may want to resume them all until some breakpoint is hit. In the latter case, you can instruct GDB to allow all threads of all the inferiors to run with the command.\n\nFor some multi-threaded targets, GDB supports an optional mode of operation in which you can examine stopped program threads in the debugger while other threads continue to execute freely. This minimizes intrusion when debugging live systems, such as programs where some threads have real-time constraints or must continue to respond to external events. This is referred to as non-stop mode.\n\nIn non-stop mode, when a thread stops to report a debugging event, only that thread is stopped; GDB does not stop other threads as well, in contrast to the all-stop mode behavior. Additionally, execution commands such as and apply by default only to the current thread in non-stop mode, rather than all threads as in all-stop mode. This allows you to control threads explicitly in ways that are not possible in all-stop mode — for example, stepping one thread while allowing others to run freely, stepping one thread while holding all others stopped, or stepping several threads independently and simultaneously.\n\nTo enter non-stop mode, use this sequence of commands before you run or attach to your program:\n\nYou can use these commands to manipulate the non-stop mode setting:\n\nNote these commands only reflect whether non-stop mode is enabled, not whether the currently-executing program is being run in non-stop mode. In particular, the preference is only consulted when GDB starts or connects to the target program, and it is generally not possible to switch modes once debugging has started. Furthermore, since not all targets support non-stop mode, even when you have enabled non-stop mode, GDB may still fall back to all-stop operation by default.\n\nIn non-stop mode, all execution commands apply only to the current thread by default. That is, only continues one thread. To continue all threads, issue or .\n\nYou can use GDB’s background execution commands (see Background Execution) to run some threads in the background while you continue to examine or step others from GDB. The MI execution commands (see GDB/MI Program Execution) are always executed asynchronously in non-stop mode.\n\nSuspending execution is done with the command when running in the background, or during foreground execution. In all-stop mode, this stops the whole process; but in non-stop mode the interrupt applies only to the current thread. To stop the whole program, use .\n\nOther execution commands do not currently support the option.\n\nIn non-stop mode, when a thread stops, GDB doesn’t automatically make that thread current, as it does in all-stop mode. This is because the thread stop notifications are asynchronous with respect to GDB’s command interpreter, and it would be confusing if GDB unexpectedly changed to a different thread just as you entered a command to operate on the previously current thread.\n\nGDB’s execution commands have two variants: the normal foreground (synchronous) behavior, and a background (asynchronous) behavior. In foreground execution, GDB waits for the program to report that some thread has stopped before prompting for another command. In background execution, GDB immediately gives a command prompt so that you can issue other commands while your program runs.\n\nIf the target doesn’t support async mode, GDB issues an error message if you attempt to use the background execution commands.\n\nTo specify background execution, add a to the command. For example, the background form of the command is , or just . The execution commands that accept background execution are:\n\nBackground execution is especially useful in conjunction with non-stop mode for debugging programs with multiple threads; see Non-Stop Mode. However, you can also use these commands in the normal all-stop mode with the restriction that you cannot issue another execution command until the previous one finishes. Examples of commands that are valid in all-stop mode while the program is running include and .\n\nYou can interrupt your program while it is running in the background by using the command.\n\nWhen your program has multiple threads (see Debugging Programs with Multiple Threads), you can choose whether to set breakpoints on all threads, or on a particular thread.\n\nThread-specific breakpoints are automatically deleted when GDB detects the corresponding thread is no longer in the thread list. For example:\n\nThere are several ways for a thread to disappear, such as a regular thread exit, but also when you detach from the process with the command (see Debugging an Already-running Process), or if GDB loses the remote connection (see Remote Debugging), etc. Note that with some targets, GDB is only able to detect a thread has exited when the user explicitly asks for the thread list with the command.\n\nA breakpoint can’t be both thread-specific and inferior-specific (see Inferior-Specific Breakpoints), or task-specific (see Ada Tasks); using more than one of the , , or keywords when creating a breakpoint will give an error.\n\nThere is an unfortunate side effect when using GDB to debug multi-threaded programs. If one thread stops for a breakpoint, or for some other reason, and another thread is blocked in a system call, then the system call may return prematurely. This is a consequence of the interaction between multiple threads and the signals that GDB uses to implement breakpoints and other events that stop execution.\n\nTo handle this problem, your program should check the return value of each system call and react appropriately. This is good programming style anyways.\n\nFor example, do not write code like this:\n\nThe call to will return early if a different thread stops at a breakpoint or for some other reason.\n\nA system call is allowed to return early, so the system is still conforming to its specification. But GDB does cause your multi-threaded program to behave differently than it would without GDB.\n\nAlso, GDB uses internal breakpoints in the thread library to monitor certain events such as thread creation and thread destruction. When such an event happens, a system call in another thread may return prematurely, even though your program does not appear to stop.\n\nIf you want to build on non-stop mode and observe program behavior without any chance of disruption by GDB, you can set variables to disable all of the debugger’s attempts to modify state, whether by writing memory, inserting breakpoints, etc. These operate at a low level, intercepting operations from all commands.\n\nWhen all of these are set to , then GDB is said to be observer mode. As a convenience, the variable can be set to disable these, plus enable non-stop mode.\n\nNote that GDB will not prevent you from making nonsensical combinations of these settings. For instance, if you have enabled but disabled , then breakpoints that work by writing trap instructions into the code stream will still not be able to be placed.\n\nWhen you are debugging a program, it is not unusual to realize that you have gone too far, and some event of interest has already happened. If the target environment supports it, GDB can allow you to “rewind” the program by running it backward.\n\nA target environment that supports reverse execution should be able to “undo” the changes in machine state that have taken place as the program was executing normally. Variables, registers etc. should revert to their previous values. Obviously this requires a great deal of sophistication on the part of the target environment; not all target environments can support reverse execution.\n\nWhen a program is executed in reverse, the instructions that have most recently been executed are “un-executed”, in reverse order. The program counter runs backward, following the previous thread of execution in reverse. As each instruction is “un-executed”, the values of memory and/or registers that were changed by that instruction are reverted to their previous states. After executing a piece of source code in reverse, all side effects of that code should be “undone”, and all variables should be returned to their prior values7.\n\nOn some platforms, GDB has built-in support for reverse execution, activated with the or commands. See Process Record and Replay. Some remote targets, typically full system emulators, support reverse execution directly without requiring any special command.\n\nIf you are debugging in a target environment that supports reverse execution, GDB provides the following commands.\n\nOn some platforms, GDB provides a special process record and replay target that can record a log of the process execution, and replay it later with both forward and reverse execution commands.\n\nWhen this target is in use, if the execution log includes the record for the next instruction, GDB will debug in replay mode. In the replay mode, the inferior does not really execute code instructions. Instead, all the events that normally happen during code execution are taken from the execution log. While code is not really executed in replay mode, the values of registers (including the program counter register) and the memory of the inferior are still changed as they normally would. Their contents are taken from the execution log.\n\nIf the record for the next instruction is not in the execution log, GDB will debug in record mode. In this mode, the inferior executes normally, and GDB records the execution log for future replay.\n\nThe process record and replay target supports reverse execution (see Reverse Execution), even if the platform on which the inferior runs does not. However, the reverse execution is limited in this case by the range of the instructions recorded in the execution log. In other words, reverse execution on platforms that don’t support it directly can only be done in the replay mode.\n\nWhen debugging in the reverse direction, GDB will work in replay mode as long as the execution log includes the record for the previous instruction; otherwise, it will work in record mode, if the platform supports reverse execution, or stop if not.\n\nCurrently, process record and replay is supported on ARM, Aarch64, LoongArch, Moxie, PowerPC, PowerPC64, S/390, and x86 (i386/amd64) running GNU/Linux. Process record and replay can be used both when native debugging, and when remote debugging via .\n\nWhen recording an inferior, GDB may print auxiliary information during stepping commands and commands displaying the execution history.\n\nFor architecture environments that support process record and replay, GDB provides the following commands:\n\nWhen your program has stopped, the first thing you need to know is where it stopped and how it got there.\n\nEach time your program performs a function call, information about the call is generated. That information includes the location of the call in your program, the arguments of the call, and the local variables of the function being called. The information is saved in a block of data called a stack frame. The stack frames are allocated in a region of memory called the call stack.\n\nWhen your program stops, the GDB commands for examining the stack allow you to see all of this information.\n\nOne of the stack frames is selected by GDB and many GDB commands refer implicitly to the selected frame. In particular, whenever you ask GDB for the value of a variable in your program, the value is found in the selected frame. There are special GDB commands to select whichever frame you are interested in. See Selecting a Frame.\n\nWhen your program stops, GDB automatically selects the currently executing frame and describes it briefly, similar to the command (see Information about a Frame).\n\nThe call stack is divided up into contiguous pieces called stack frames, or frames for short; each frame is the data associated with one call to one function. The frame contains the arguments given to the function, the function’s local variables, and the address at which the function is executing.\n\nWhen your program is started, the stack has only one frame, that of the function . This is called the initial frame or the outermost frame. Each time a function is called, a new frame is made. Each time a function returns, the frame for that function invocation is eliminated. If a function is recursive, there can be many frames for the same function. The frame for the function in which execution is actually occurring is called the innermost frame. This is the most recently created of all the stack frames that still exist.\n\nInside your program, stack frames are identified by their addresses. A stack frame consists of many bytes, each of which has its own address; each kind of computer has a convention for choosing one byte whose address serves as the address of the frame. Usually this address is kept in a register called the frame pointer register (see $fp) while execution is going on in that frame.\n\nGDB labels each existing stack frame with a level, a number that is zero for the innermost frame, one for the frame that called it, and so on upward. These level numbers give you a way of designating stack frames in GDB commands. The terms frame number and frame level can be used interchangeably to describe this number.\n\nSome compilers provide a way to compile functions so that they operate without stack frames. (For example, the GCC option\n\ngenerates functions without a frame.) This is occasionally done with heavily used library functions to save the frame setup time. GDB has limited facilities for dealing with these function invocations. If the innermost function invocation has no stack frame, GDB nevertheless regards it as though it had a separate frame, which is numbered zero as usual, allowing correct tracing of the function call chain. However, GDB has no provision for frameless functions elsewhere in the stack.\n\nA backtrace is a summary of how your program got where it is. It shows one line per frame, for many frames, starting with the currently executing frame (frame zero), followed by its caller (frame one), and on up the stack.\n\nTo print a backtrace of the entire stack, use the command, or its alias . This command will print one line per frame for frames in the stack. By default, all stack frames are printed. You can stop the backtrace at any time by typing the system interrupt character, normally .\n\nThe names and (abbreviated ) are additional aliases for .\n\nIn a multi-threaded program, GDB by default shows the backtrace only for the current thread. To display the backtrace for several or all of the threads, use the command (see thread apply). For example, if you type , GDB will display the backtrace for all the threads; this is handy when you debug a core dump of a multi-threaded program.\n\nEach line in the backtrace shows the frame number and the function name. The program counter value is also shown—unless you use . The backtrace also shows the source file name and line number, as well as the arguments to the function. The program counter value is omitted if it is at the beginning of the code for that line number.\n\nHere is an example of a backtrace. It was made with the command ‘ ’, so it shows the innermost three frames.\n\nThe display for frame zero does not begin with a program counter value, indicating that your program has stopped at the beginning of the code for line of .\n\nThe value of parameter in frame 1 has been replaced by . By default, GDB prints the value of a parameter only if it is a scalar (integer, pointer, enumeration, etc). See command in Print Settings for more details on how to configure the way function parameter values are printed. The command (see Print Settings) controls what frame information is printed.\n\nIf your program was compiled with optimizations, some compilers will optimize away arguments passed to functions if those arguments are never used after the call. Such optimizations generate code that passes arguments through registers, but doesn’t store those arguments in the stack frame. GDB has no way of displaying such arguments in stack frames other than the innermost one. Here’s what such a backtrace might look like:\n\nThe values of arguments that were not saved in their stack frames are shown as ‘ ’.\n\nIf you need to display the values of such optimized-out arguments, either deduce that from other variables whose values depend on the one you are interested in, or recompile without optimizations.\n\nMost programs have a standard user entry point—a place where system libraries and startup code transition into user code. For C this is 9. When GDB finds the entry function in a backtrace it will terminate the backtrace, to avoid tracing into highly system-specific (and generally uninteresting) code.\n\nIf you need to examine the startup code, or limit the number of levels in a backtrace, you can change this behavior:\n\nYou can control how file names are displayed.\n\nMost commands for examining the stack and other data in your program work on whichever stack frame is selected at the moment. Here are the commands for selecting a stack frame; all of them finish by printing a brief description of the stack frame just selected.\n\nAll of these commands end by printing two lines of output describing the frame. The first line shows the frame number, the function name, the arguments, and the source file and line number of execution in that frame. The second line shows the text of that source line.\n\nAfter such a printout, the command with no arguments prints ten lines centered on the point of execution in the frame. You can also edit the program at the point of execution with your favorite editing program by typing . See Printing Source Lines, for details.\n\nThere are several other commands to print information about the selected stack frame.\n\nFrame filters are Python based utilities to manage and decorate the output of frames. See Frame Filter API, for further information.\n\nManaging frame filters is performed by several commands available within GDB, detailed here.\n\nGDB can print parts of your program’s source, since the debugging information recorded in the program tells GDB what source files were used to build it. When your program stops, GDB spontaneously prints the line where it stopped. Likewise, when you select a stack frame (see Selecting a Frame), GDB prints the line where execution in that frame has stopped. You can print other portions of source files by explicit command.\n\nIf you use GDB through its GNU Emacs interface, you may prefer to use Emacs facilities to view source; see Using GDB under GNU Emacs.\n\nTo print lines from a source file, use the command (abbreviated ). By default, ten lines are printed. There are several ways to specify what part of the file you want to print; see Location Specifications, for the full list.\n\nHere are the forms of the command most commonly used:\n\nBy default, GDB prints ten source lines with any of these forms of the command. You can change this using :\n\nRepeating a command with discards the argument, so it is equivalent to typing just . This is more useful than listing the same lines again. An exception is made for an argument of ‘ ’; that argument is preserved in repetition so that each repetition moves up in the source file.\n\nIn general, the command expects you to supply zero, one or two location specs. These location specs are interpreted to resolve to source code lines; there are several ways of writing them (see Location Specifications), but the effect is always to resolve to some source lines to display.\n\nHere is a complete description of the possible arguments for :\n\nSeveral GDB commands accept arguments that specify a location or locations of your program’s code. Many times locations are specified using a source line number, but they can also be specified by a function name, an address, a label, etc. The different forms of specifying a location that GDB recognizes are collectively known as forms of location specification, or location spec. This section documents the forms of specifying locations that GDB recognizes.\n\nWhen you specify a location, GDB needs to find the place in your program, known as code location, that corresponds to the given location spec. We call this process of finding actual code locations corresponding to a location spec location resolution.\n\nA concrete code location in your program is uniquely identifiable by a set of several attributes: its source line number, the name of its source file, the fully-qualified and prototyped function in which it is defined, and an instruction address. Because each inferior has its own address space, the inferior number is also a necessary part of these attributes.\n\nBy contrast, location specs you type will many times omit some of these attributes. For example, it is customary to specify just the source line number to mean a line in the current source file, or specify just the basename of the file, omitting its directories. In other words, a location spec is usually incomplete, a kind of blueprint, and GDB needs to complete the missing attributes by using the implied defaults, and by considering the source code and the debug information available to it. This is what location resolution is about.\n\nThe resolution of an incomplete location spec can produce more than a single code location, if the spec doesn’t allow distinguishing between them. Here are some examples of situations that result in a location spec matching multiple code locations in your program:\n• The location spec specifies a function name, and there are several functions in the program which have that name. (To distinguish between them, you can specify a fully-qualified and prototyped function name, such as instead of just .)\n• The location spec specifies a source file name, and there are several source files in the program that share the same name, for example several files with the same basename in different subdirectories. (To distinguish between them, specify enough leading directories with the file name.)\n• For a C constructor, the GCC compiler generates several instances of the function body, used in different cases, but their source-level names are identical.\n• For a C template function, a given line in the function can correspond to any number of instantiations.\n• For an inlined function, a given source line can correspond to several actual code locations with that function’s inlined code.\n\nResolution of a location spec can also fail to produce a complete code location, or even fail to produce any code location. Here are some examples of such situations:\n• Some parts of the program lack detailed enough debug info, so the resolved code location lacks some attributes, like source file name and line number, leaving just the instruction address and perhaps also a function name. Such an incomplete code location is only usable in contexts that work with addresses and/or function names. Some commands can only work with complete code locations.\n• The location spec specifies a function name, and there are no functions in the program by that name, or they only exist in a yet-unloaded shared library.\n• The location spec specifies a source file name, and there are no source files in the program by that name, or they only exist in a yet-unloaded shared library.\n• The location spec specifies both a source file name and a source line number, and even though there are source files in the program that match the file name, none of those files has the specified line number.\n\nLocations may be specified using three different formats: linespec locations, explicit locations, or address locations. The following subsections describe these formats.\n\nA linespec is a colon-separated list of source location parameters such as file name, function name, etc. Here are all the different ways of specifying a linespec:\n\nExplicit locations allow the user to directly specify the source location’s parameters using option-value pairs.\n\nExplicit locations are useful when several functions, labels, or file names have the same name (base name for files) in the program’s sources. In these cases, explicit locations point to the source line you meant more accurately and unambiguously. Also, using explicit locations might be faster in large programs.\n\nFor example, the linespec ‘ ’ may refer to a function defined in the file named or the label in a function named . GDB must search either the file system or the symbol table to know.\n\nThe list of valid explicit location options is summarized in the following table:\n\nExplicit location options may be abbreviated by omitting any non-unique trailing characters from the option name, e.g., .\n\nAddress locations indicate a specific program address. They have the generalized form * .\n\nFor line-oriented commands, such as and , this specifies a source line that contains . For and other breakpoint-oriented commands, this can be used to set breakpoints in parts of your program which do not have debugging information or source files.\n\nHere may be any expression valid in the current working language (see working language) that specifies a code address. In addition, as a convenience, GDB extends the semantics of expressions used in locations to cover several situations that frequently occur during debugging. Here are the various forms of :\n\nTo edit the lines in a source file, use the command. The editing program of your choice is invoked with the current line set to the active line in the program. Alternatively, there are several ways to specify what part of the file you want to print if you want to see other parts of the program:\n\nYou can customize GDB to use any editor you want 10. By default, it is , but you can change this by setting the environment variable before using GDB. For example, to configure GDB to use the editor, you could use these commands with the shell:\n\nor in the shell,\n\nThere are two commands for searching through the current source file for a regular expression.\n\nExecutable programs sometimes do not record the directories of the source files from which they were compiled, just the names. Even when they do, the directories could be moved between the compilation and your debugging session. GDB has a list of directories to search for source files; this is called the source path. Each time GDB wants a source file, it tries all the directories in the list, in the order they are present in the list, until it finds a file with the desired name.\n\nFor example, suppose an executable references the file , does not record a compilation directory, and the source path is . GDB would look for the source file in the following locations:\n\nIf the source file is not present at any of the above locations then an error is printed. GDB does not look up the parts of the source file name, such as . Likewise, the subdirectories of the source path are not searched: if the source path is , and the binary refers to , GDB would not find it under .\n\nPlain file names, relative file names with leading directories, file names containing dots, etc. are all treated as described above, except that non-absolute file names are not looked up literally. If the source path is , the source file is recorded as , and no compilation directory is recorded, then GDB will search in the following locations:\n\nThe source path will always include two special entries ‘ ’ and ‘ ’, these refer to the compilation directory (if one is recorded) and the current working directory respectively.\n\n‘ ’ causes GDB to search within the compilation directory, if one is recorded in the debug information. If no compilation directory is recorded in the debug information then ‘ ’ is ignored.\n\n‘ ’ is not the same as ‘ ’—the former tracks the current working directory as it changes during your GDB session, while the latter is immediately expanded to the current directory at the time you add an entry to the source path.\n\nIf a compilation directory is recorded in the debug information, and GDB has not found the source file after the first search using source path, then GDB will combine the compilation directory and the filename, and then search for the source file again using the source path.\n\nFor example, if the executable records the source file as , the compilation directory is recorded as , and the source path is while the current working directory of the GDB session is , then GDB will search for the source file in the following locations:\n\nIf the file name in the previous example had been recorded in the executable as a relative path rather than an absolute path, then the first look up would not have occurred, but all of the remaining steps would be similar.\n\nWhen searching for source files on MS-DOS and MS-Windows, where absolute paths start with a drive letter (e.g. ), GDB will remove the drive letter from the file name before appending it to a search directory from source path; for instance if the executable references the source file and source path is set to , then GDB will search in the following locations for the source file:\n\nNote that the executable search path is not used to locate the source files.\n\nWhenever you reset or rearrange the source path, GDB clears out any information it has cached about where source files are found and where each line is in the file.\n\nWhen you start GDB, its source path includes only ‘ ’ and ‘ ’, in that order. To add other directories, use the command.\n\nThe search path is used to find both program source files and GDB script files (read using the ‘ ’ option and ‘ ’ command).\n\nIn addition to the source path, GDB provides a set of commands that manage a list of source path substitution rules. A substitution rule specifies how to rewrite source directories stored in the program’s debug information in case the sources were moved to a different directory between compilation and debugging. A rule is made of two strings, the first specifying what needs to be rewritten in the path, and the second specifying how it should be rewritten. In set substitute-path, we name these two parts and respectively. GDB does a simple string replacement of with at the start of the directory part of the source file name, and uses that result instead of the original file name to look up the sources.\n\nUsing the previous example, suppose the tree has been moved from to , then you can tell GDB to replace in all source path names with . The first lookup will then be in place of the original location of . To define a source path substitution rule, use the command (see set substitute-path).\n\nTo avoid unexpected substitution results, a rule is applied only if the part of the directory name ends at a directory separator. For instance, a rule substituting into will be applied to but not to . And because the substitution is applied only at the beginning of the directory name, this rule will not be applied to either.\n\nIn many cases, you can achieve the same result using the command. However, can be more efficient in the case where the sources are organized in a complex tree with multiple subdirectories. With the command, you need to add each subdirectory of your project. If you moved the entire tree while preserving its internal organization, then allows you to direct the debugger to all the sources with one single command.\n\nis also more than just a shortcut command. The source path is only used if the file at the original location no longer exists. On the other hand, modifies the debugger behavior to look at the rewritten location instead. So, if for any reason a source file that is not relevant to your executable is located at the original location, a substitution rule is the only method available to point GDB at the new location.\n\nYou can configure a default source path substitution rule by configuring GDB with the ‘ ’ option. The should be the name of a directory under GDB’s configured prefix (set with ‘ ’ or ‘ ’), and directory names in debug information under will be adjusted automatically if the installed GDB is moved to a new location. This is useful if GDB, libraries or executables with debug information and corresponding source code are being moved together.\n\nIf your source path is cluttered with directories that are no longer of interest, GDB may sometimes cause confusion by finding the wrong versions of source. You can correct the situation as follows:\n• Use with no argument to reset the source path to its default value.\n• Use with suitable arguments to reinstall the directories you want in the source path. You can add all the directories in one command.\n\nYou can use the command to map source lines to program addresses (and vice versa), and the command to display a range of addresses as machine instructions. You can use the command to set whether to disassemble next source line when execution stops. When run under GNU Emacs mode, the command causes the arrow to point to the line specified. Also, prints addresses in symbolic form as well as hex.\n\nFor example, we can use to discover the location of the object code for the first line of function :\n\nWe can also inquire, using as the form for , what source line covers a particular address :\n\nAfter , the default address for the command is changed to the starting address of the line, so that ‘ ’ is sufficient to begin examining the machine code (see Examining Memory). Also, this address is saved as the value of the convenience variable (see Convenience Variables).\n\nAfter , using again without specifying a location will display information about the next source line.\n\nThe following example shows the disassembly of a range of addresses of HP PA-RISC 2.0 code:\n\nThe following two examples are for RISC-V, and demonstrates the difference between the and modifiers. First with , the bytes of the instruction are printed, in hex, in memory order:\n\nIn contrast, with the bytes of the instruction are displayed in the instruction order, for RISC-V this means that the bytes have been swapped to little-endian order:\n\nHere is an example showing mixed source+assembly for Intel x86 with or , when the program is stopped just after function prologue in a non-optimized function with no inline code.\n\nThe option is deprecated as its output is not useful when there is either inlined code or re-ordered code. The option is the preferred choice. Here is an example for AMD x86-64 showing the difference between output and output. This example has one inline function defined in a header file, and the code is compiled with ‘ ’ optimization. Note how the output is missing the disassembly of several instructions that are present in the output.\n\nHere is another example showing raw instructions in hex for AMD x86-64,\n\nNote that the ‘ ’ command’s address arguments are specified using expressions in your programming language (see Expressions), not location specs (see Location Specifications). So, for example, if you want to disassemble function in file , you must type ‘ ’ and not ‘ ’.\n\nSome architectures have more than one commonly-used set of instruction mnemonics or other syntax.\n\nFor programs that were dynamically linked and use shared libraries, instructions that call functions or branch to locations in the shared libraries might show a seemingly bogus location—it’s actually a location of the relocation table. On some architectures, GDB might be able to resolve these to actual function names.\n\nIn some cases it can be desirable to prevent GDB from accessing source code files. One case where this might be desirable is if the source code files are located over a slow network connection.\n\nThe following command can be used to control whether GDB should access source code files or not:\n\nThe usual way to examine data in your program is with the command (abbreviated ), or its synonym . It evaluates and prints the value of an expression of the language your program is written in (see Using GDB with Different Languages). It may also print the expression using a Python-based pretty-printer (see Pretty Printing).\n\nIf the architecture supports memory tagging, the command will display pointer/memory tag mismatches if what is being printed is a pointer or reference type. See Memory Tagging.\n\nA more low-level way of examining data is with the command. It examines data in memory at a specified address and prints it in a specified format. See Examining Memory.\n\nIf you are interested in information about types, or about how the fields of a struct or a class are declared, use the command rather than . See Examining the Symbol Table.\n\nAnother way of examining values of expressions and type information is through the Python extension command (available only if the GDB build is configured with ). It offers an interactive way to start at the highest level (or, the most abstract level) of the data type of an expression (or, the data type itself) and explore all the way down to leaf scalar values/fields embedded in the higher level data types.\n\nThe working of the command can be illustrated with an example. If a data type is defined in your C program as\n\nfollowed by variable declarations as\n\nthen, the value of the variable can be explored using the command as follows.\n\nSince the fields of are not scalar values, you are being prompted to chose the field you want to explore. Let’s say you choose the field by entering . Then, since this field is a pointer, you will be asked if it is pointing to a single value. From the declaration of above, it is indeed pointing to a single value, hence you enter . If you enter , then you will be asked if it were pointing to an array of values, in which case this field will be explored as if it were an array.\n\nIf the field of was chosen for exploration by entering earlier, then since it is as array, you will be prompted to enter the index of the element in the array that you want to explore.\n\nIn general, at any stage of exploration, you can go deeper towards the leaf values by responding to the prompts appropriately, or hit the return key to return to the enclosing data structure (the higher level data structure).\n\nSimilar to exploring values, you can use the command to explore types. Instead of specifying a value (which is typically a variable name or an expression valid in the current context of the program being debugged), you specify a type name. If you consider the same example as above, your can explore the type by passing the argument to the command.\n\nBy responding to the prompts appropriately in the subsequent interactive session, you can explore the type in a manner similar to how the value was explored in the above example.\n\nThe command also has two sub-commands, and . The former sub-command is a way to explicitly specify that value exploration of the argument is being invoked, while the latter is a way to explicitly specify that type exploration of the argument is being invoked.\n\nand many other GDB commands accept an expression and compute its value. Any kind of constant, variable or operator defined by the programming language you are using is valid in an expression in GDB. This includes conditional expressions, function calls, casts, and string constants. It also includes preprocessor macros, if you compiled your program to include this information; see Compilation.\n\nGDB supports array constants in expressions input by the user. The syntax is { , …}. For example, you can use the command to create an array of three integers. If you pass an array to a function or assign it to a program variable, GDB copies the array to memory that is ed in the target program.\n\nBecause C is so widespread, most of the expressions shown in examples in this manual are in C. See Using GDB with Different Languages, for information on how to use expressions in other languages.\n\nIn this section, we discuss operators that may be available in GDB expressions in addition to those of your programming language. However, they are not necessarily available in all working languages.\n\nCasts are supported in all languages, not just in C, because it is so useful to cast a number into a pointer in order to examine a structure at that address in memory.\n\nGDB supports these operators, in addition to those common to programming languages:\n\nExpressions can sometimes contain some ambiguous elements. For instance, some programming languages (notably Ada, C and Objective-C) permit a single function name to be defined several times, for application in different contexts. This is called overloading. Another example involving Ada is generics. A generic package is similar to C templates and is typically instantiated several times, resulting in the same function name being defined in different contexts.\n\nIn some cases and depending on the language, it is possible to adjust the expression to remove the ambiguity. For instance in C , you can specify the signature of the function you want to break on, as in . In Ada, using the fully qualified name of your function often makes the expression unambiguous as well.\n\nWhen an ambiguity that needs to be resolved is detected, the debugger has the capability to display a menu of numbered choices for each possibility, and then waits for the selection with the prompt ‘ ’. The first option is always ‘ ’, and typing aborts the current command. If the command in which the expression was used allows more than one choice to be selected, the next option in the menu is ‘ ’, and typing selects all possible choices.\n\nFor example, the following session excerpt shows an attempt to set a breakpoint at the overloaded symbol . We choose three particular definitions of that function name:\n\nThe most common kind of expression to use is the name of a variable in your program.\n\nVariables in expressions are understood in the selected stack frame (see Selecting a Frame); they must be either:\n• visible according to the scope rules of the programming language from the point of execution in that frame\n\nThis means that in the function\n\nyou can examine and use the variable whenever your program is executing within the function , but you can only use or examine the variable while your program is executing inside the block where is declared.\n\nThere is an exception: you can refer to a variable or function whose scope is a single source file even if the current execution point is not in this file. But it is possible to have more than one such variable or function with the same name (in different source files). If that happens, referring to that name has unpredictable effects. If you wish, you can specify a static variable in a particular function or file by using the colon-colon ( ) notation (this may not be supported for all languages, see Expressions):\n\nHere or is the name of the context for the static . In the case of file names, you can use quotes to make sure GDB parses the file name as a single word—for example, to print a global value of defined in :\n\nThe notation is normally used for referring to static variables, since you typically disambiguate uses of local variables in functions by selecting the appropriate frame and using the simple name of the variable. However, you may also use this notation to refer to local variables in frames enclosing the selected frame:\n\nFor example, if there is a breakpoint at the commented line, here is what you might see when the program stops after executing the call :\n\nThese uses of ‘ ’ are very rarely in conflict with the very similar use of the same notation in C . When they are in conflict, the C meaning takes precedence; however, this can be overridden by quoting the file or function name with single quotes.\n\nFor example, suppose the program is stopped in a method of a class that has a field named , and there is also an include file named that defines a variable, .\n\nYou may see this problem when you are stepping by machine instructions. This is because, on most machines, it takes more than one instruction to set up a stack frame (including local variable definitions); if you are stepping by machine instructions, variables may appear to have the wrong values until the stack frame is completely built. On exit, it usually also takes more than one machine instruction to destroy a stack frame; after you begin stepping through that group of instructions, local variable definitions may be gone.\n\nThis may also happen when the compiler does significant optimizations. To be sure of always seeing accurate values, turn off all optimization when compiling.\n\nAnother possible effect of compiler optimizations is to optimize unused variables out of existence, or assign variables to registers (as opposed to memory addresses). Depending on the support for such cases offered by the debug info format used by the compiler, GDB might not be able to display values for such local variables. If that happens, GDB will print a message like this:\n\nTo solve such problems, either recompile without optimizations, or use a different debug info format, if the compiler supports several such formats. See Compilation, for more information on choosing compiler options. See C and C , for more information about debug info formats that are best suited to C programs.\n\nIf you ask to print an object whose contents are unknown to GDB, e.g., because its data type is not completely specified by the debug information, GDB will say ‘ ’. See incomplete type, for more about this.\n\nIf you try to examine or use the value of a (global) variable for which GDB has no type information, e.g., because the program includes no debug information, GDB displays an error message. See unknown type, for more about unknown types. If you cast the variable to its declared type, GDB gets the variable’s value using the cast-to type as the variable’s type. For example, in a C program:\n\nIf you append string to a function parameter name you get its value at the time the function got called. If the value is not available an error message is printed. Entry values are available only with some compilers. Entry values are normally also printed at the function parameter list according to set print entry-values.\n\nStrings are identified as arrays of values without specified signedness. Arrays of either or get printed as arrays of 1 byte sized integers. or GCC options have no effect as GDB defines literal string type as without a sign. For program code\n\nYou get during debugging\n\nIt is often useful to print out several successive objects of the same type in memory; a section of an array, or an array of dynamically determined size for which only a pointer exists in the program.\n\nYou can do this by referring to a contiguous span of memory as an artificial array, using the binary operator ‘ ’. The left operand of ‘ ’ should be the first element of the desired array and be an individual object. The right operand should be the desired length of the array. The result is an array value whose elements are all of the type of the left argument. The first element is actually the left argument; the second element comes from bytes of memory immediately following those that hold the first element, and so on. Here is an example. If a program says\n\nyou can print the contents of with\n\nThe left operand of ‘ ’ must reside in memory. Array values made with ‘ ’ in this way behave just like other arrays in terms of subscripting, and are coerced to pointers when used in expressions. Artificial arrays most often appear in expressions via the value history (see Value History), after printing one out.\n\nAnother way to create an artificial array is to use a cast. This re-interprets a value as if it were an array. The value need not be in memory:\n\nAs a convenience, if you leave the array length out (as in ‘ ’) GDB calculates the size to fill the value (as ‘ ’:\n\nSometimes the artificial array mechanism is not quite enough; in moderately complex data structures, the elements of interest may not actually be adjacent—for example, if you are interested in the values of pointers in an array. One useful work-around in this situation is to use a convenience variable (see Convenience Variables) as a counter in an expression that prints the first interesting value, and then repeat that expression via . For instance, suppose you have an array of pointers to structures, and you are interested in the values of a field in each structure. Here is an example of what you might type:\n\nBy default, GDB prints a value according to its data type. Sometimes this is not what you want. For example, you might want to print a number in hex, or a pointer in decimal. Or you might want to view data in memory at a certain address as a character string or as an instruction. To do these things, specify an output format when you print a value.\n\nThe simplest use of output formats is to say how to print a value already computed. This is done by starting the arguments of the command with a slash and a format letter. The format letters supported are:\n\nFor example, to print the program counter in hex (see Registers), type\n\nNote that no space is required before the slash; this is because command names in GDB cannot contain a slash.\n\nTo reprint the last value in the value history with a different format, you can use the command with just a format and no expression. For example, ‘ ’ reprints the last value in hex.\n\nYou can use the command (for “examine”) to examine memory in any of several formats, independently of your program’s data types.\n\n, , and are all optional parameters that specify how much memory to display and how to format it; is an expression giving the address where you want to start displaying memory. If you use defaults for , you need not type the slash ‘ ’. Several commands set convenient defaults for .\n\nFor example, ‘ ’ is a request to display three halfwords ( ) of memory, formatted as unsigned decimal integers (‘ ’), starting at address . ‘ ’ prints the four words (‘ ’) of memory above the stack pointer (here, ‘ ’; see Registers) in hexadecimal (‘ ’).\n\nYou can also specify a negative repeat count to examine memory backward from the given address. For example, ‘ ’ prints three halfwords ( ) at , , and .\n\nSince the letters indicating unit sizes are all distinct from the letters specifying output formats, you do not have to remember whether unit size or format comes first; either order works. The output specifications ‘ ’ and ‘ ’ mean exactly the same thing. (However, the count must come first; ‘ ’ does not work.)\n\nEven though the unit size is ignored for the formats ‘ ’ and ‘ ’, you might still want to use a count ; for example, ‘ ’ specifies that you want to see three machine instructions, including any operands. For convenience, especially when used with the command, the ‘ ’ format also prints branch delay slot instructions, if any, beyond the count specified, which immediately follow the last instruction that is within the count. The command gives an alternative way of inspecting machine instructions; see Source and Machine Code.\n\nIf a negative repeat count is specified for the formats ‘ ’ or ‘ ’, the command displays null-terminated strings or instructions before the given address as many as the absolute value of the given number. For the ‘ ’ format, we use line number information in the debug info to accurately locate instruction boundaries while disassembling backward. If line info is not available, the command stops examining memory with an error message.\n\nAll the defaults for the arguments to are designed to make it easy to continue scanning memory with minimal specifications each time you use . For example, after you have inspected three machine instructions with ‘ ’, you can inspect the next seven with just ‘ ’. If you use to repeat the command, the repeat count is used again; the other arguments default as for successive uses of .\n\nWhen examining machine instructions, the instruction at current program counter is shown with a marker. For example:\n\nIf the architecture supports memory tagging, the tags can be displayed by using ‘ ’. See Memory Tagging.\n\nThe information will be displayed once per granule size (the amount of bytes a particular memory tag covers). For example, AArch64 has a granule size of 16 bytes, so it will display a tag every 16 bytes.\n\nDue to the way GDB prints information with the command (not aligned to a particular boundary), the tag information will refer to the initial address displayed on a particular line. If a memory tag boundary is crossed in the middle of a line displayed by the command, it will be displayed on the next line.\n\nThe ‘ ’ format doesn’t affect any other specified formats that were passed to the command.\n\nThe addresses and contents printed by the command are not saved in the value history because there is often too much of them and they would get in the way. Instead, GDB makes these values available for subsequent use in expressions as values of the convenience variables and . After an command, the last address examined is available for use in expressions in the convenience variable . The contents of that address, as examined, are available in the convenience variable .\n\nIf the command has a repeat count, the address and contents saved are from the last memory unit printed; this is not the same as the last address printed if several units were printed on the last line of output.\n\nMost targets have an addressable memory unit size of 8 bits. This means that to each memory address are associated 8 bits of data. Some targets, however, have other addressable memory unit sizes. Within GDB and this document, the term addressable memory unit (or memory unit for short) is used when explicitly referring to a chunk of data of that size. The word byte is used to refer to a chunk of data of 8 bits, regardless of the addressable memory unit size of the target. For most systems, addressable memory unit is a synonym of byte.\n\nWhen you are debugging a program running on a remote target machine (see Remote Debugging), you may wish to verify the program’s image in the remote machine’s memory against the executable file you downloaded to the target. Or, on any target, you may want to check whether the program has corrupted its own read-only sections. The command is provided for such situations.\n\nMemory tagging is a memory protection technology that uses a pair of tags to validate memory accesses through pointers. The tags are integer values usually comprised of a few bits, depending on the architecture.\n\nThere are two types of tags that are used in this setup: logical and allocation. A logical tag is stored in the pointers themselves, usually at the higher bits of the pointers. An allocation tag is the tag associated with particular ranges of memory in the physical address space, against which the logical tags from pointers are compared.\n\nThe pointer tag (logical tag) must match the memory tag (allocation tag) for the memory access to be valid. If the logical tag does not match the allocation tag, that will raise a memory violation.\n\nAllocation tags cover multiple contiguous bytes of physical memory. This range of bytes is called a memory tag granule and is architecture-specific. For example, AArch64 has a tag granule of 16 bytes, meaning each allocation tag spans 16 bytes of memory.\n\nIf the underlying architecture supports memory tagging, like AArch64 MTE or SPARC ADI do, GDB can make use of it to validate pointers against memory allocation tags.\n\nThe (see Data) and (see Memory) commands will display tag information when appropriate, and a command prefix of gives access to the various memory tagging commands.\n\nThe commands are the following:\n\nIf you find that you want to print the value of an expression frequently (to see how it changes), you might want to add it to the automatic display list so that GDB prints its value each time your program stops. Each expression added to the list is given a number to identify it; to remove an expression from the list, you specify that number. The automatic display looks like this:\n\nThis display shows item numbers, expressions and their current values. As with displays you request manually using or , you can specify the output format you prefer; in fact, decides whether to use or depending your format specification—it uses if you specify either the ‘ ’ or ‘ ’ format, or a unit size; otherwise it uses .\n\nFor example, ‘ ’ can be helpful, to see the machine instruction about to be executed each time execution stops (‘ ’ is a common name for the program counter; see Registers).\n\nIf a display expression refers to local variables, then it does not make sense outside the lexical context for which it was set up. Such an expression is disabled when execution enters a context where one of its variables is not defined. For example, if you give the command while inside a function with an argument , GDB displays this argument while your program continues to stop inside that function. When it stops elsewhere—where there is no variable —the display is disabled automatically. The next time your program stops where is meaningful, you can enable the display expression once again.\n\nGDB provides the following ways to control how arrays, structures, and symbols are printed.\n\nThese settings are useful for debugging programs in any language:\n\nWhen GDB prints a symbolic address, it normally prints the closest earlier symbol plus an offset. If that symbol does not uniquely identify the address (for example, it is a name whose scope is a single source file), you may need to clarify. One way to do this is with , for example ‘ ’. Alternately, you can set GDB to print the source file and line number when it prints a symbolic address:\n\nAnother situation where it is helpful to show symbol filenames and line numbers is when disassembling code; GDB shows you the line number and source file that corresponds to each instruction.\n\nAlso, you may wish to see the symbolic form only if the address being printed is reasonably close to the closest earlier symbol:\n\nIf you have a pointer and you are not sure where it points, try ‘ ’. Then you can determine the name and source file location of the variable where it points, using ‘ ’. This interprets the address in symbolic form. For example, here GDB shows that a variable points at another variable , defined in :\n\nYou can also enable ‘ ’-like formatting all the time using ‘ ’:\n\nOther settings control how different kinds of objects are printed:\n\nThese settings are of interest when debugging C programs:\n\nGDB provides a mechanism to allow pretty-printing of values using Python code. It greatly simplifies the display of complex objects. This mechanism works for both MI and the CLI.\n\nWhen GDB prints a value, it first sees if there is a pretty-printer registered for the value. If there is then GDB invokes the pretty-printer to print the value. Otherwise the value is printed normally.\n\nPretty-printers are normally named. This makes them easy to manage. The ‘ ’ command will list all the installed pretty-printers with their names. If a pretty-printer can handle multiple data types, then its subprinters are the printers for the individual data types. Each such subprinter has its own name. The format of the name is ; .\n\nPretty-printers are installed by registering them with GDB. Typically they are automatically loaded and registered when the corresponding debug information is loaded, thus making them available without having to do anything special.\n\nThere are three places where a pretty-printer can be registered.\n• Pretty-printers registered globally are available when debugging all inferiors.\n• Pretty-printers registered with a program space are available only when debugging that program. See Progspaces In Python, for more details on program spaces in Python.\n• Pretty-printers registered with an objfile are loaded and unloaded with the corresponding objfile (e.g., shared library). See Objfiles In Python, for more details on objfiles in Python.\n\nSee Selecting Pretty-Printers, for further information on how pretty-printers are selected,\n\nSee Writing a Pretty-Printer, for implementing pretty printers for new types.\n\nHere is how a C looks without a pretty-printer:\n\nWith a pretty-printer for only the contents are printed:\n\nSuppose we have three pretty-printers installed: one from library1.so named that prints objects of type , and another from library2.so named that prints two types of objects, and .\n\nNote that for the entire printer can be disabled, as can each individual subprinter.\n\nPrinting values and frame arguments is done by default using the enabled pretty printers.\n\nThe print option and GDB setting (see set print raw-values) can be used to print values without applying the enabled pretty printers.\n\nSimilarly, the backtrace option and GDB setting (see set print raw-frame-arguments) can be used to ignore the enabled pretty printers when printing frame argument values.\n\nValues printed by the command are saved in the GDB value history. This allows you to refer to them in other expressions. Values are kept until the symbol table is re-read or discarded (for example with the or commands). When the symbol table changes, the value history is discarded, since the values may contain pointers back to the types defined in the symbol table.\n\nThe values printed are given history numbers by which you can refer to them. These are successive integers starting with one. shows you the history number assigned to a value by printing ‘ ’ before the value; here is the history number.\n\nTo refer to any previous value, use ‘ ’ followed by the value’s history number. The way labels its output is designed to remind you of this. Just refers to the most recent value in the history, and refers to the value before that. refers to the th value from the end; is the value just prior to , is equivalent to , and is equivalent to .\n\nFor example, suppose you have just printed a pointer to a structure and want to see the contents of the structure. It suffices to type\n\nIf you have a chain of structures where the component points to the next one, you can print the contents of the next one with this:\n\nYou can print successive links in the chain by repeating this command—which you can do by just typing .\n\nNote that the history records values, not expressions. If the value of is 4 and you type these commands:\n\nthen the value recorded in the value history by the command remains 4 even though the value of has changed.\n\nPressing to repeat has exactly the same effect as ‘ ’.\n\nGDB provides convenience variables that you can use within GDB to hold on to a value and refer to it later. These variables exist entirely within GDB; they are not part of your program, and setting a convenience variable has no direct effect on further execution of your program. That is why you can use them freely.\n\nConvenience variables are prefixed with ‘ ’. Any name preceded by ‘ ’ can be used for a convenience variable, unless it is one of the predefined machine-specific register names (see Registers). (Value history references, in contrast, are numbers preceded by ‘ ’. See Value History.)\n\nYou can save a value in a convenience variable with an assignment expression, just as you would set a variable in your program. For example:\n\nwould save in the value contained in the object pointed to by .\n\nUsing a convenience variable for the first time creates it, but its value is until you assign a new value. You can alter the value with another assignment at any time.\n\nConvenience variables have no fixed types. You can assign a convenience variable any type of value, including structures and arrays, even if that variable already has a value of a different type. The convenience variable, when used as an expression, has the type of its current value.\n\nOne of the ways to use a convenience variable is as a counter to be incremented or a pointer to be advanced. For example, to print a field from successive elements of an array of structures:\n\nSome convenience variables are created automatically by GDB and given values likely to be useful.\n\nGDB also supplies some convenience functions. These have a syntax similar to convenience variables. A convenience function can be used in an expression just like an ordinary function; however, a convenience function is implemented internally to GDB.\n\nThese functions do not require GDB to be configured with support, which means that they are always available.\n\nThe following functions require GDB to be configured with support.\n\nGDB provides the ability to list and get help on convenience functions.\n\nYou can refer to machine register contents, in expressions, as variables with names starting with ‘ ’. The names of registers are different for each machine; use to see the names used on your machine.\n\nGDB has four “standard” register names that are available (in expressions) on most machines—whenever they do not conflict with an architecture’s canonical mnemonics for registers. The register names and are used for the program counter register and the stack pointer. is used for a register that contains a pointer to the current stack frame, and is used for a register that contains the processor status. For example, you could print the program counter in hex with\n\nor print the instruction to be executed next with\n\nor add four to the stack pointer12 with\n\nWhenever possible, these four standard register names are available on your machine even though the machine has different canonical mnemonics, so long as there is no conflict. The command shows the canonical names. For example, on the SPARC, displays the processor status register as but you can also refer to it as ; and on x86-based machines is an alias for the EFLAGS register.\n\nGDB always considers the contents of an ordinary register as an integer when the register is examined in this way. Some machines have special registers which can hold nothing but floating point; these registers are considered to have floating point values. There is no way to refer to the contents of an ordinary register as floating point value (although you can print it as a floating point value with ‘ ’).\n\nSome registers have distinct “raw” and “virtual” data formats. This means that the data format in which the register contents are saved by the operating system is not the same one that your program normally sees. For example, the registers of the 68881 floating point coprocessor are always saved in “extended” (raw) format, but all C programs expect to work with “double” (virtual) format. In such cases, GDB normally works with the virtual format only (the format that makes sense for your program), but the command prints the data in both formats.\n\nSome machines have special registers whose contents can be interpreted in several different ways. For example, modern x86-based machines have SSE and MMX registers that can hold several values packed together in several different formats. GDB refers to such registers in notation:\n\nTo set values of such registers, you need to tell GDB which view of the register you wish to change, as if you were assigning value to a member:\n\nNormally, register values are relative to the selected stack frame (see Selecting a Frame). This means that you get the value that the register would contain if all stack frames farther in were exited and their saved registers restored. In order to see the true contents of hardware registers, you must select the innermost frame (with ‘ ’).\n\nUsually ABIs reserve some registers as not needed to be saved by the callee (a.k.a.: “caller-saved”, “call-clobbered” or “volatile” registers). It may therefore not be possible for GDB to know the value a register had before the call (in other words, in the outer frame), if the register value has since been changed by the callee. GDB tries to deduce where the inner frame saved (“callee-saved”) registers, from the debug info, unwind info, or the machine code generated by your compiler. If some register is not saved, and GDB knows the register is “caller-saved” (via its own knowledge of the ABI, or because the debug/unwind info explicitly says the register’s value is undefined), GDB displays ‘ ’ as the register’s value. With targets that GDB has no knowledge of the register saving convention, if a register was not saved by the callee, then its value and location in the outer frame are assumed to be the same of the inner frame. This is usually harmless, because if the register is call-clobbered, the caller either does not care what is in the register after the call, or has code to restore the value that it does care about. Note, however, that if you change such a register in the outer frame, you may also be affecting the inner frame. Also, the more “outer” the frame is you’re looking at, the more likely a call-clobbered register’s value is to be wrong, in the sense that it doesn’t actually represent the value the register had just before the call.\n\nDepending on the configuration, GDB may be able to give you more information about the status of the floating point hardware.\n\nDepending on the configuration, GDB may be able to give you more information about the status of the vector unit.\n\nGDB provides interfaces to useful OS facilities that can help you debug your program.\n\nSome operating systems supply an auxiliary vector to programs at startup. This is akin to the arguments and environment that you specify for a program, but contains a system-dependent variety of binary values that tell system libraries important details about the hardware, operating system, and process. Each value’s purpose is identified by an integer tag; the meanings are well-known but system-specific. Depending on the configuration and operating system facilities, GDB may be able to show you this information. For remote targets, this functionality may further depend on the remote stub’s support of the ‘ ’ packet, see qXfer auxiliary vector read.\n\nOn some targets, GDB can access operating system-specific information and show it to you. The types of information available will differ depending on the type of operating system running on the target. The mechanism used to fetch the data is described in Operating System Information. For remote targets, this functionality depends on the remote stub’s support of the ‘ ’ packet, see qXfer osdata read.\n\nMemory region attributes allow you to describe special handling required by regions of your target’s memory. GDB uses attributes to determine whether to allow certain types of memory accesses; whether to use specific width accesses; and whether to cache target memory. By default the description of memory regions is fetched from the target (if the current target supports this), but the user can override the fetched regions.\n\nDefined memory regions can be individually enabled and disabled. When a memory region is disabled, GDB uses the default attributes when accessing memory in that region. Similarly, if no memory regions have been defined, GDB uses the default attributes when accessing all memory.\n\nWhen a memory region is defined, it is given a number to identify it; to enable, disable, or remove a memory region, you specify that number.\n\nThe access mode attributes set whether GDB may make read or write accesses to a memory region.\n\nWhile these attributes prevent GDB from performing invalid memory accesses, they do nothing to prevent the target system, I/O DMA, etc. from accessing memory.\n\nThe access size attribute tells GDB to use specific sized accesses in the memory region. Often memory mapped device registers require specific sized accesses. If no access size attribute is specified, GDB may use accesses of any size.\n\nThe data cache attributes set whether GDB will cache target memory. While this generally improves performance by reducing debug protocol overhead, it can lead to incorrect results because GDB does not know about volatile variables or memory mapped device registers.\n\nGDB can be instructed to refuse accesses to memory that is not explicitly described. This can be useful if accessing such regions has undesired effects for a specific target, or to provide better error checking. The following commands control this behavior.\n\nYou can use the commands , , and to copy data between target memory and a file. The and commands write data to a file, and the command reads data from a file back into the inferior’s memory. Files may be in binary, Motorola S-record, Intel hex, Tektronix Hex, or Verilog Hex format; however, GDB can only append to binary files, and cannot read from Verilog Hex files.\n\n10.20 How to Produce a Core File from Your Program\n\nA core file or core dump is a file that records the memory image of a running process and its process status (register values etc.). Its primary use is post-mortem debugging of a program that crashed while it ran outside a debugger. A program that crashes automatically produces a core file, unless this feature is disabled by the user. See Files, for information on invoking GDB in the post-mortem debugging mode.\n\nOccasionally, you may wish to produce a core file of the program you are debugging in order to preserve a snapshot of its state. GDB has a special command for that.\n\nIf the program you are debugging uses a different character set to represent characters and strings than the one GDB uses itself, GDB can automatically translate between the character sets for you. The character set GDB uses we call the host character set; the one the inferior program uses we call the target character set.\n\nFor example, if you are running GDB on a GNU/Linux system, which uses the ISO Latin 1 character set, but you are using GDB’s remote protocol (see Remote Debugging) to debug a program running on an IBM mainframe, which uses the EBCDIC character set, then the host character set is Latin-1, and the target character set is EBCDIC. If you give GDB the command , then GDB translates between EBCDIC and Latin 1 as you print character or string values, or use character and string literals in expressions.\n\nGDB has no way to automatically recognize which character set the inferior program uses; you must tell it, using the command, described below.\n\nHere are the commands for controlling GDB’s character set support:\n\nHere is an example of GDB’s character set support in action. Assume that the following source code has been placed in the file :\n\nIn this program, and are arrays containing the string ‘ ’ followed by a newline, encoded in the ASCII and IBM1047 character sets.\n\nWe compile the program, and invoke the debugger on it:\n\nWe can use the command to see what character sets GDB is currently using to interpret and display characters and strings:\n\nFor the sake of printing this manual, let’s use ASCII as our initial character set:\n\nLet’s assume that ASCII is indeed the correct character set for our host system — in other words, let’s assume that if GDB prints characters using the ASCII character set, our terminal will display them properly. Since our current target character set is also ASCII, the contents of print legibly:\n\nGDB uses the target character set for character and string literals you use in expressions:\n\nThe ASCII character set uses the number 43 to encode the ‘ ’ character.\n\nGDB relies on the user to tell it which character set the target program uses. If we print while our target character set is still ASCII, we get jibberish:\n\nIf we invoke the followed by , GDB tells us the character sets it supports:\n\nWe can select IBM1047 as our target character set, and examine the program’s strings again. Now the ASCII string is wrong, but GDB translates the contents of from the target character set, IBM1047, to the host character set, ASCII, and they display correctly:\n\nAs above, GDB uses the target character set for character and string literals you use in expressions:\n\nThe IBM1047 character set uses the number 78 to encode the ‘ ’ character.\n\nGDB caches data exchanged between the debugger and a target. Each cache is associated with the address space of the inferior. See Inferiors Connections and Programs, about inferior and address space. Such caching generally improves performance in remote debugging (see Remote Debugging), because it reduces the overhead of the remote protocol by bundling memory reads and writes into large chunks. Unfortunately, simply caching everything would lead to incorrect results, since GDB does not necessarily know anything about volatile values, memory-mapped I/O addresses, etc. Furthermore, in non-stop mode (see Non-Stop Mode) memory can be changed while a gdb command is executing. Therefore, by default, GDB only caches data known to be on the stack13 or in the code segment. Other regions of memory can be explicitly marked as cacheable; see Memory Region Attributes.\n\nMemory can be searched for a particular sequence of bytes with the command.\n\nand are optional parameters. They may be specified in either order, apart or together.\n\nYou can use strings as search values. Quote them with double-quotes ( ). The string value is copied into the search pattern byte by byte, regardless of the endianness of the target and the size specification.\n\nThe address of each match found is printed as well as a count of the number of matches found.\n\nThe address of the last value found is stored in convenience variable ‘ ’. A count of the number of matches is stored in ‘ ’.\n\nFor example, if stopped at the in this function:\n\nyou get during debugging:\n\nWhenever GDB prints a value memory will be allocated within GDB to hold the contents of the value. It is possible in some languages with dynamic typing systems, that an invalid program may indicate a value that is incorrectly large, this in turn may cause GDB to try and allocate an overly large amount of memory.\n\nAlmost all compilers support optimization. With optimization disabled, the compiler generates assembly code that corresponds directly to your source code, in a simplistic way. As the compiler applies more powerful optimizations, the generated assembly code diverges from your original source code. With help from debugging information generated by the compiler, GDB can map from the running program back to constructs from your original source.\n\nGDB is more accurate with optimization disabled. If you can recompile without optimization, it is easier to follow the progress of your program during debugging. But, there are many cases where you may need to debug an optimized version.\n\nWhen you debug a program compiled with ‘ ’, remember that the optimizer has rearranged your code; the debugger shows you what is really there. Do not be too surprised when the execution path does not exactly match your source file! An extreme example: if you define a variable, but never use it, GDB never sees that variable—because the compiler optimizes it out of existence.\n\nSome things do not work as well with ‘ ’ as with just ‘ ’, particularly on machines with instruction scheduling. If in doubt, recompile with ‘ ’ alone, and if this fixes the problem, please report it to us as a bug (including a test case!). See Variables, for more information about debugging optimized code.\n\nInlining is an optimization that inserts a copy of the function body directly at each call site, instead of jumping to a shared routine. GDB displays inlined functions just like non-inlined functions. They appear in backtraces. You can view their arguments and local variables, step into them with , skip them with , and escape from them with . You can check whether a function was inlined by using the command.\n\nFor GDB to support inlined functions, the compiler must record information about inlining in the debug information — GCC using the DWARF 2 format does this, and several other compilers do also. GDB only supports inlined functions when using DWARF 2. Versions of GCC before 4.1 do not emit two required attributes (‘ ’ and ‘ ’); GDB does not display inlined function calls with earlier versions of GCC. It instead displays the arguments and local variables of inlined functions as local variables in the caller.\n\nThe body of an inlined function is directly included at its call site; unlike a non-inlined function, there are no instructions devoted to the call. GDB still pretends that the call site and the start of the inlined function are different instructions. Stepping to the call site shows the call site, and then stepping again shows the first line of the inlined function, even though no additional instructions are executed.\n\nThis makes source-level debugging much clearer; you can see both the context of the call and then the effect of the call. Only stepping by a single instruction using or does not do this; single instruction steps always show the inlined body.\n\nThere are some ways that GDB does not pretend that inlined function calls are the same as normal calls:\n• Setting breakpoints at the call site of an inlined function may not work, because the call site does not contain any code. GDB may incorrectly move the breakpoint to the next line of the enclosing function, after the call. This limitation will be removed in a future version of GDB; until then, set a breakpoint on an earlier line or inside the inlined function instead.\n• GDB cannot locate the return value of inlined calls after using the command. This is a limitation of compiler-generated debugging information; after , you can step to the next line and print a variable where your program stored the return value.\n\nFunction can call function in its very last statement. In unoptimized compilation the call of is immediately followed by return instruction at the end of code. Optimizing compiler may replace the call and return in function into one jump to function instead. Such use of a jump instruction is called tail call.\n\nDuring execution of function , there will be no indication in the function call stack frames that it was tail-called from . If function regularly calls function which tail-calls function , then GDB will see as the caller of . However, in some cases GDB can determine that was tail-called from , and it will then create fictitious call frame for that, with the return address set up as if called normally.\n\nThis functionality is currently supported only by DWARF 2 debugging format and the compiler has to produce ‘ ’ tags. With GCC, you need to specify during compilation, to get this information.\n\ncommand (see Frame Info) will indicate the tail call frame kind by text such as in this sample GDB output:\n\nThe detection of all the possible code path executions can find them ambiguous. There is no execution history stored (possible Reverse Execution is never used for this purpose) and the last known caller could have reached the known callee by multiple different jump sequences. In such case GDB still tries to show at least all the unambiguous top tail callers and all the unambiguous bottom tail callees, if any.\n\nThe analysis messages for tail calls can for example show why the virtual tail call frame for function has not been recognized (due to the indirect reference by variable ):\n\nAnother possibility is an ambiguous virtual tail call frames resolution:\n\nFrames #0 and #2 are real, #1 is a virtual tail call frame. The code can have possible execution paths or , GDB cannot find which one from the inferior state.\n\nstate shows some random possible calling sequence GDB has found. It then finds another possible calling sequence - that one is prefixed by . The non-ambiguous intersection of these two is printed as the calling sequence. That one could have many further and statements as long as there remain any non-ambiguous sequence entries.\n\nFor the frame of function in both cases there are different possible values ( or ), therefore this frame is also ambiguous. The only non-ambiguous frame is the one for function , therefore this one is displayed to the user while the ambiguous frames are omitted.\n\nThere can be also reasons why printing of frame argument values at function entry may fail:\n\nGDB cannot find out from the inferior state if and how many times did function call itself (via function ) as these calls would be tail calls. Such tail calls would modify the variable, therefore GDB cannot be sure the value it knows would be right - GDB prints instead.\n\nSome languages, such as C and C , provide a way to define and invoke “preprocessor macros” which expand into strings of tokens. GDB can evaluate expressions containing macro invocations, show the result of macro expansion, and show a macro’s definition, including where it was defined.\n\nYou may need to compile your program specially to provide GDB with information about preprocessor macros. Most compilers do not include macros in their debugging information, even when you compile with the flag. See Compilation.\n\nA program may define a macro at one point, remove that definition later, and then provide a different definition after that. Thus, at different points in the program, a macro may have different definitions, or have no definition at all. If there is a current stack frame, GDB uses the macros in scope at that frame’s source code line. Otherwise, GDB uses the macros in scope at the current listing location; see List.\n\nWhenever GDB evaluates an expression, it always expands any macro invocations present in the expression. GDB also provides the following commands for working with macros explicitly.\n\nHere is a transcript showing the above commands in action. First, we show our source files:\n\nNow, we compile the program using the GNU C compiler, GCC. We pass the 14 and flags to ensure the compiler includes information about preprocessor macros in the debugging information.\n\nNow, we start GDB on our sample program:\n\nWe can expand macros and examine their definitions, even when the program is not running. GDB uses the current listing position to decide which macro definitions are in scope:\n\nIn the example above, note that expands only the macro invocation explicit in the original text — the invocation of — but does not expand the invocation of the macro , which was introduced by .\n\nOnce the program is running, GDB uses the macro definitions in force at the source line of the current stack frame:\n\nAt line 10, the definition of the macro at line 9 is in force:\n\nAs we step over directives that remove ’s definition, and then give it a new definition, GDB finds the definition (or lack thereof) in force at each point:\n\nIn addition to source files, macros can be defined on the compilation command line using the syntax. For macros defined in such a way, GDB displays the location of their definition as line zero of the source file submitted to the compiler.\n\nIn some applications, it is not feasible for the debugger to interrupt the program’s execution long enough for the developer to learn anything helpful about its behavior. If the program’s correctness depends on its real-time behavior, delays introduced by a debugger might cause the program to change its behavior drastically, or perhaps fail, even when the code itself is correct. It is useful to be able to observe the program’s behavior without interrupting it.\n\nUsing GDB’s and commands, you can specify locations in the program, called tracepoints, and arbitrary expressions to evaluate when those tracepoints are reached. Later, using the command, you can examine the values those expressions had when the program hit the tracepoints. The expressions may also denote objects in memory—structures or arrays, for example—whose values GDB should record; while visiting a particular tracepoint, you may inspect those objects as if they were in memory at that moment. However, because GDB records these values without interacting with you, it can do so quickly and unobtrusively, hopefully not disturbing the program’s behavior.\n\nThe tracepoint facility is currently available only for remote targets. See Targets. In addition, your remote target must know how to collect trace data. This functionality is implemented in the remote stub; however, none of the stubs distributed with GDB support tracepoints as of this writing. The format of the remote packets used to implement tracepoints are described in Tracepoint Packets.\n\nIt is also possible to get trace data from a file, in a manner reminiscent of corefiles; you specify the filename, and use to search through the file. See Trace Files, for more details.\n\nThis chapter describes the tracepoint commands and features.\n\nBefore running such a trace experiment, an arbitrary number of tracepoints can be set. A tracepoint is actually a special type of breakpoint (see Set Breaks), so you can manipulate it using standard breakpoint commands. For instance, as with breakpoints, tracepoint numbers are successive integers starting from one, and many of the commands associated with tracepoints take the tracepoint number as their argument, to identify which tracepoint to work on.\n\nFor each tracepoint, you can specify, in advance, some arbitrary set of data that you want the target to collect in the trace buffer when it hits that tracepoint. The collected data can include registers, local variables, or global data. Later, you can use GDB commands to examine the values these data had at the time the tracepoint was hit.\n\nTracepoints do not support every breakpoint feature. Ignore counts on tracepoints have no effect, and tracepoints cannot run GDB commands when they are hit. Tracepoints may not be thread-specific either.\n\nSome targets may support fast tracepoints, which are inserted in a different way (such as with a jump instead of a trap), that is faster but possibly restricted in where they may be installed.\n\nRegular and fast tracepoints are dynamic tracing facilities, meaning that they can be used to insert tracepoints at (almost) any location in the target. Some targets may also support controlling static tracepoints from GDB. With static tracing, a set of instrumentation points, also known as markers, are embedded in the target program, and can be activated or deactivated by name or address. These are usually placed at locations which facilitate investigating what the target is actually doing. GDB’s support for static tracing includes being able to list instrumentation points, and attach them with GDB defined high level tracepoints that expose the whole range of convenience of GDB’s tracepoints support. Namely, support for collecting registers values and values of global or local (to the instrumentation point) variables; tracepoint conditions and trace state variables. The act of installing a GDB static tracepoint on an instrumentation point, or marker, is referred to as probing a static tracepoint marker.\n\nsupports tracepoints on some target systems. See Tracepoints support in .\n\nThis section describes commands to set tracepoints and associated conditions and actions.\n\nThese commands are deprecated; they are equivalent to plain and .\n\nThe simplest sort of tracepoint collects data every time your program reaches a specified place. You can also specify a condition for a tracepoint. A condition is just a Boolean expression in your programming language (see Expressions). A tracepoint with a condition evaluates the expression each time your program reaches it, and data collection happens only if the condition is true.\n\nTracepoint conditions can be specified when a tracepoint is set, by using ‘ ’ in the arguments to the command. See Setting Tracepoints. They can also be set or changed at any time with the command, just as with breakpoints.\n\nUnlike breakpoint conditions, GDB does not actually evaluate the conditional expression itself. Instead, GDB encodes the expression into an agent expression (see Agent Expressions) suitable for execution on the target, independently of GDB. Global variables become raw memory locations, locals become stack accesses, and so forth.\n\nFor instance, suppose you have a function that is usually called frequently, but should not be called after an error has occurred. You could use the following tracepoint command to collect data about calls of that function that happen while the error code is propagating through the program; an unconditional tracepoint could end up collecting thousands of useless trace frames that you would have to search through.\n\nA trace state variable is a special type of variable that is created and managed by target-side code. The syntax is the same as that for GDB’s convenience variables (a string prefixed with “$”), but they are stored on the target. They must be created explicitly, using a command. They are always 64-bit signed integers.\n\nTrace state variables are remembered by GDB, and downloaded to the target along with tracepoint information when the trace experiment starts. There are no intrinsic limits on the number of trace state variables, beyond memory limitations of the target.\n\nAlthough trace state variables are managed by the target, you can use them in print commands and expressions as if they were convenience variables; GDB will get the current value from the target while the trace experiment is running. Trace state variables share the same namespace as other “$” variables, which means that you cannot have trace state variables with names like or , nor can you have a trace state variable and a convenience variable with the same name.\n\nHere is an example of the commands we described so far:\n\nYou can choose to continue running the trace experiment even if GDB disconnects from the target, voluntarily or involuntarily. For commands such as , the debugger will ask what you want to do with the trace. But for unexpected terminations (GDB crash, network outage), it would be unfortunate to lose hard-won trace data, so the variable lets you decide whether the trace should continue running without GDB.\n\nWhen you reconnect to the target, the trace experiment may or may not still be running; it might have filled the trace buffer in the meantime, or stopped for one of the other reasons. If it is running, it will continue after reconnection.\n\nUpon reconnection, the target will upload information about the tracepoints in effect. GDB will then compare that information to the set of tracepoints currently defined, and attempt to match them up, allowing for the possibility that the numbers may have changed due to creation and deletion in the meantime. If one of the target’s tracepoints does not match any in GDB, the debugger will create a new tracepoint, so that you have a number with which to specify that tracepoint. This matching-up process is necessarily heuristic, and it may result in useless tracepoints being created; you may simply delete them if they are of no use.\n\nIf your target agent supports a circular trace buffer, then you can run a trace experiment indefinitely without filling the trace buffer; when space runs out, the agent deletes already-collected trace frames, oldest first, until there is enough room to continue collecting. This is especially useful if your tracepoints are being hit too often, and your trace gets terminated prematurely because the buffer is full. To ask for a circular trace buffer, simply set ‘ ’ to on. You can set this at any time, including during tracing; if the agent can do it, it will change buffer handling on the fly, otherwise it will not take effect until the next run.\n\nThere are a number of restrictions on the use of tracepoints. As described above, tracepoint data gathering occurs on the target without interaction from GDB. Thus the full capabilities of the debugger are not available during data gathering, and then at data examination time, you will be limited by only having what was collected. The following items describe some common problems, but it is not exhaustive, and you may run into additional difficulties not mentioned here.\n• Tracepoint expressions are intended to gather objects (lvalues). Thus the full flexibility of GDB’s expression evaluator is not available. You cannot call functions, cast objects to aggregate types, access convenience variables or modify values (except by assignment to trace state variables). Some language features may implicitly call functions (for instance Objective-C fields with accessors), and therefore cannot be collected either.\n• Collection of local variables, either individually or in bulk with or , during may behave erratically. The stepping action may enter a new scope (for instance by stepping into a function), or the location of the variable may change (for instance it is loaded into a register). The tracepoint data recorded uses the location information for the variables that is correct for the tracepoint location. When the tracepoint is created, it is not possible, in general, to determine where the steps of a sequence will advance the program—particularly if a conditional branch is stepped.\n• Collection of an incompletely-initialized or partially-destroyed object may result in something that GDB cannot display, or displays in a misleading way.\n• When GDB displays a pointer to character it automatically dereferences the pointer to also display characters of the string being pointed to. However, collecting the pointer during tracing does not automatically collect the string. You need to explicitly dereference the pointer and provide size information if you want to collect not only the pointer, but the memory pointed to. For example, can be used to collect the 50 element array pointed to by .\n• It is not possible to collect a complete stack backtrace at a tracepoint. Instead, you may collect the registers and a few hundred bytes from the stack pointer with something like (adjust to use the name of the actual stack pointer register on your target architecture, and the amount of stack you wish to capture). Then the command will show a partial backtrace when using a trace frame. The number of stack frames that can be examined depends on the sizes of the frames in the collected stack. Note that if you ask for a block so large that it goes past the bottom of the stack, the target agent may report an error trying to read from an invalid address.\n• If you do not collect registers at a tracepoint, GDB can infer that the value of must be the same as the address of the tracepoint and use that when you are looking at a trace frame for that tracepoint. However, this cannot work if the tracepoint has multiple locations (for instance if it was set in a function that was inlined), or if it has a loop. In those cases GDB will warn you that it can’t infer , and default it to zero.\n\nAfter the tracepoint experiment ends, you use GDB commands for examining the trace data. The basic idea is that each tracepoint collects a trace snapshot every time it is hit and another snapshot every time it single-steps. All these snapshots are consecutively numbered from zero and go into a buffer, and you can examine them later. The way you examine them is to focus on a specific trace snapshot. When the remote stub is focused on a trace snapshot, it will respond to all GDB requests for memory and registers by reading from the buffer which belongs to that snapshot, rather than from real memory or registers of the program being debugged. This means that all GDB commands ( , , , etc.) will behave as if we were currently debugging the program state as it was when the tracepoint occurred. Any requests for data that are not in the buffer will fail.\n\nThe basic command for selecting a trace snapshot from the buffer is , which finds trace snapshot number , counting from zero. If no argument is given, the next snapshot is selected.\n\nHere are the various forms of using the command.\n\nThe default arguments for the commands are specifically designed to make it easy to scan through the trace buffer. For instance, with no argument selects the next trace snapshot, and with no argument selects the previous trace snapshot. So, by giving one command, and then simply hitting repeatedly you can examine all the trace snapshots in order. Or, by saying and then hitting repeatedly you can examine the snapshots in reverse order. The command with no argument selects the snapshot for the next source line executed. The command with no argument selects the next snapshot with the same program counter (PC) as the current frame. The command with no argument selects the next trace snapshot collected by the same tracepoint as the current one.\n\nIn addition to letting you scan through the trace buffer manually, these commands make it easy to construct GDB scripts that scan through the trace buffer and print out whatever collected data you are interested in. Thus, if we want to examine the PC, FP, and SP registers from each trace frame in the buffer, we can say this:\n\nOr, if we want to examine the variable at each source line in the buffer:\n\nThis command takes no arguments. It prints all the data collected at the current trace snapshot.\n\nworks by scanning the tracepoint’s current collection actions and printing the value of each expression listed. So can fail, if after a run, you change the tracepoint’s actions to mention variables that were not collected during the run.\n\nAlso, for tracepoints with loops, uses the collected value of to distinguish between trace frames that were collected at the tracepoint hit, and frames that were collected while stepping. This allows it to correctly choose whether to display the basic list of collections, or the collections from the body of the while-stepping loop. However, if was not collected, then will always attempt to dump using the basic collection list, and may fail if a while-stepping frame does not include all the same data that is collected at the tracepoint hit.\n\nThis command saves all current tracepoint definitions together with their actions and passcounts, into a file suitable for use in a later debugging session. To read the saved tracepoint definitions, use the command (see Command Files). The command is a deprecated alias for\n\nNote: is not suitable for use in , use instead.\n\nHere’s a simple example of using these convenience variables for stepping through all the trace snapshots and printing some of their data. Note that these are not the same as trace state variables, which are managed by the target.\n\nIn some situations, the target running a trace experiment may no longer be available; perhaps it crashed, or the hardware was needed for a different activity. To handle these cases, you can arrange to dump the trace data into a file, and later use that file as a source of trace data, via the command.\n\nIf your program is too large to fit completely in your target system’s memory, you can sometimes use overlays to work around this problem. GDB provides some support for debugging programs that use overlays.\n\nSuppose you have a computer whose instruction address space is only 64 kilobytes long, but which has much more memory which can be accessed by other means: special instructions, segment registers, or memory management hardware, for example. Suppose further that you want to adapt a program which is larger than 64 kilobytes to run on this system.\n\nOne solution is to identify modules of your program which are relatively independent, and need not call each other directly; call these modules overlays. Separate the overlays from the main program, and place their machine code in the larger memory. Place your main program in instruction memory, but leave at least enough space there to hold the largest overlay as well.\n\nNow, to call a function located in an overlay, you must first copy that overlay’s machine code from the large memory into the space set aside for it in the instruction memory, and then jump to its entry point there.\n\nThe diagram (see A code overlay) shows a system with separate data and instruction address spaces. To map an overlay, the program copies its code from the larger address space to the instruction address space. Since the overlays shown here all use the same mapped address, only one may be mapped at a time. For a system with a single address space for data and instructions, the diagram would be similar, except that the program variables and heap would share an address space with the main program and the overlay area.\n\nAn overlay loaded into instruction memory and ready for use is called a mapped overlay; its mapped address is its address in the instruction memory. An overlay not present (or only partially present) in instruction memory is called unmapped; its load address is its address in the larger memory. The mapped address is also called the virtual memory address, or VMA; the load address is also called the load memory address, or LMA.\n\nUnfortunately, overlays are not a completely transparent way to adapt a program to limited instruction memory. They introduce a new set of global constraints you must keep in mind as you design your program:\n• Before calling or returning to a function in an overlay, your program must make sure that overlay is actually mapped. Otherwise, the call or return will transfer control to the right address, but in the wrong overlay, and your program will probably crash.\n• If the process of mapping an overlay is expensive on your system, you will need to choose your overlays carefully to minimize their effect on your program’s performance.\n• The executable file you load onto your system must contain each overlay’s instructions, appearing at the overlay’s load address, not its mapped address. However, each overlay’s instructions must be relocated and its symbols defined as if the overlay were at its mapped address. You can use GNU linker scripts to specify different load and relocation addresses for pieces of your program; see Overlay Description in .\n• The procedure for loading executable files onto your system must be able to load their contents into the larger address space as well as the instruction and data spaces.\n\nThe overlay system described above is rather simple, and could be improved in many ways:\n• If your system has suitable bank switch registers or memory management hardware, you could use those facilities to make an overlay’s load area contents simply appear at their mapped address in instruction space. This would probably be faster than copying the overlay to its mapped area in the usual way.\n• If your overlays are small enough, you could set aside more than one overlay area, and have more than one overlay mapped at a time.\n• You can use overlays to manage data, as well as instructions. In general, data overlays are even less transparent to your design than code overlays: whereas code overlays only require care when you call or return to functions, data overlays require care every time you access the data. Also, if you change the contents of a data overlay, you must copy its contents back out to its load address before you can copy a different data overlay into the same mapped area.\n\nTo use GDB’s overlay support, each overlay in your program must correspond to a separate section of the executable file. The section’s virtual memory address and load memory address must be the overlay’s mapped and load addresses. Identifying overlays with sections allows GDB to determine the appropriate address of a function or variable, depending on whether the overlay is mapped or not.\n\nGDB’s overlay commands all start with the word ; you can abbreviate this as or . The commands are:\n\nNormally, when GDB prints a code address, it includes the name of the function the address falls in:\n\nWhen overlay debugging is enabled, GDB recognizes code in unmapped overlays, and prints the names of unmapped functions with asterisks around them. For example, if is a function in an unmapped overlay, GDB prints it this way:\n\nWhen ’s overlay is mapped, GDB prints the function’s name normally:\n\nWhen overlay debugging is enabled, GDB can find the correct address for functions and variables in an overlay, whether or not the overlay is mapped. This allows most GDB commands, like and , to work normally, even on unmapped code. However, GDB’s breakpoint support has some limitations:\n• You can set breakpoints in functions in unmapped overlays, as long as GDB can write to the overlay at its load address.\n• GDB can not set hardware or simulator-based breakpoints in unmapped overlays. However, if you set a breakpoint at the end of your overlay manager (and tell GDB which overlays are now mapped, if you are using manual overlay management), GDB will re-set its breakpoints properly.\n\nGDB can automatically track which overlays are mapped and which are not, given some simple co-operation from the overlay manager in the inferior. If you enable automatic overlay debugging with the command (see Overlay Commands), GDB looks in the inferior’s memory for certain variables describing the current state of the overlays.\n\nHere are the variables your overlay manager must define to support GDB’s automatic overlay debugging:\n\nTo decide whether a particular overlay is mapped or not, GDB looks for an entry in whose and members equal the VMA and LMA of the overlay’s section in the executable file. When GDB finds a matching entry, it consults the entry’s member to determine whether the overlay is currently mapped.\n\nIn addition, your overlay manager may define a function called . If this function is defined, GDB will silently set a breakpoint there. If the overlay manager then calls this function whenever it has changed the overlay table, this will enable GDB to accurately keep track of which overlays are in program memory, and update any breakpoints that may be set in overlays. This will allow breakpoints to work even if the overlays are kept in ROM or other non-writable memory while they are not being executed.\n\nWhen linking a program which uses overlays, you must place the overlays at their load addresses, while relocating them to run at their mapped addresses. To do this, you must write a linker script (see Overlay Description in ). Unfortunately, since linker scripts are specific to a particular host system, target architecture, and target memory layout, this manual cannot provide portable sample code demonstrating GDB’s overlay support.\n\nHowever, the GDB source distribution does contain an overlaid program, with linker scripts for a few systems, as part of its test suite. The program consists of the following files from :\n\nYou can build the test program using the GCC cross-compiler like this:\n\nThe build process is identical for any other architecture, except that you must substitute the appropriate compiler and linker script for the target system for and .\n\n15 Using GDB with Different Languages\n\nAlthough programming languages generally have common aspects, they are rarely expressed in the same manner. For instance, in ANSI C, dereferencing a pointer is accomplished by , but in Modula-2, it is accomplished by . Values can also be represented (and displayed) differently. Hex numbers in C appear as ‘ ’, while in Modula-2 they appear as ‘ ’.\n\nLanguage-specific information is built into GDB for some languages, allowing you to express operations like the above in your program’s native language, and allowing GDB to output values in a manner consistent with the syntax of your program’s native language. The language you use to build expressions is called the working language.\n\nThere are two ways to control the working language—either have GDB set it automatically, or select it manually yourself. You can use the command for either purpose. On startup, GDB defaults to setting the language automatically. The working language is used to determine how expressions you type are interpreted, how values are printed, etc.\n\nIn addition to the working language, every source file that GDB knows about has its own working language. For some object file formats, the compiler might indicate which language a particular source file is in. However, most of the time GDB infers the language from the name of the file. The language of a source file controls whether C names are demangled—this way can show each frame appropriately for its own language. There is no way to set the language of a source file from within GDB, but you can set the language associated with a filename extension. See Displaying the Language.\n\nThis is most commonly a problem when you use a program, such as or , that generates C but is written in another language. In that case, make the program use directives in its C output; that way GDB will know the correct language of the source code of the original program, and will display that source code, not the generated C code.\n\nIf a source file name ends in one of the following extensions, then GDB infers that its language is the one indicated.\n\nIn addition, you may set the language associated with a filename extension. See Displaying the Language.\n\nIf you allow GDB to set the language automatically, expressions are interpreted the same way in your debugging session and your program.\n\nIf you wish, you may set the language manually. To do this, issue the command ‘ ’, where is the name of a language, such as or . For a list of the supported languages, type ‘ ’.\n\nSetting the language manually prevents GDB from updating the working language automatically. This can lead to confusion if you try to debug a program when the working language is not the same as the source language, when an expression is acceptable to both languages—but means different things. For instance, if the current source file were written in C, and GDB was parsing Modula-2, a command such as:\n\nmight not have the effect you intended. In C, this means to add and and place the result in . The result printed would be the value of . In Modula-2, this means to compare to the result of , yielding a value.\n\nTo have GDB set the working language automatically, use ‘ ’ or ‘ ’. GDB then infers the working language. That is, when your program stops in a frame (usually by encountering a breakpoint), GDB sets the working language to the language recorded for the function in that frame. If the language for a frame is unknown (that is, if the function or block corresponding to the frame was defined in a source file that does not have a recognized extension), the current working language is not changed, and GDB issues a warning.\n\nThis may not seem necessary for most programs, which are written entirely in one source language. However, program modules and libraries written in one source language can be used by a main program written in a different source language. Using ‘ ’ in this case frees you from having to set the working language manually.\n\nThe warning is enabled by default, but it can be controlled via a setting:\n\nThe following commands help you find out which language is the working language, and also what language source files were written in.\n\nIn unusual circumstances, you may have source files with extensions not in the standard list. You can then set the extension associated with a language explicitly:\n\nSome languages are designed to guard you against making seemingly common errors through a series of compile- and run-time checks. These include checking the type of arguments to functions and operators and making sure mathematical overflows are caught at run time. Checks such as these help to ensure a program’s correctness once it has been compiled by eliminating type mismatches and providing active checks for range errors when your program is running.\n\nBy default GDB checks for these errors according to the rules of the current source language. Although GDB does not check the statements in your program, it can check expressions entered directly into GDB for evaluation via the command, for example.\n\nSome languages, such as C and C , are strongly typed, meaning that the arguments to operators and functions have to be of the correct type, otherwise an error occurs. These checks prevent type mismatch errors from ever causing any run-time problems. For example,\n\nThe second example fails because in C the integer constant ‘ ’ is not type-compatible with the pointer parameter type.\n\nFor the expressions you use in GDB commands, you can tell GDB to not enforce strict type checking or to treat any mismatches as errors and abandon the expression; When type checking is disabled, GDB successfully evaluates expressions like the second example above.\n\nEven if type checking is off, there may be other reasons related to type that prevent GDB from evaluating an expression. For instance, GDB does not know how to add an and a . These particular type errors have nothing to do with the language in use and usually arise from expressions which make little sense to evaluate anyway.\n\nGDB provides some additional commands for controlling type checking:\n\nIn some languages (such as Modula-2), it is an error to exceed the bounds of a type; this is enforced with run-time checks. Such range checking is meant to ensure program correctness by making sure computations do not overflow, or indices on an array element access do not exceed the bounds of the array.\n\nFor expressions you use in GDB commands, you can tell GDB to treat range errors in one of three ways: ignore them, always treat them as errors and abandon the expression, or issue warnings but evaluate the expression anyway.\n\nA range error can result from numerical overflow, from exceeding an array index bound, or when you type a constant that is not a member of any type. Some languages, however, do not treat overflows as an error. In many implementations of C, mathematical overflow causes the result to “wrap around” to lower values—for example, if is the largest integer value, and is the smallest, then\n\nThis, too, is specific to individual languages, and in some cases specific to individual compilers or machines. See Supported Languages, for further details on specific languages.\n\nGDB provides some additional commands for controlling the range checker:\n\nGDB supports C, C , D, Go, Objective-C, Fortran, OpenCL C, Pascal, Rust, assembly, Modula-2, and Ada. Some GDB features may be used in expressions regardless of the language you use: the GDB and operators, and the ‘ ’ construct (see Expressions) can be used with the constructs of any supported language.\n\nThe following sections detail to what degree each source language is supported by GDB. These sections are not meant to be language tutorials or references, but serve only as a reference guide to what the GDB expression parser accepts, and what input and output formats should look like for different languages. There are many good books written on each of these languages; please look to these for a language reference or tutorial.\n\n15.4.1 C and C\n\nSince C and C are so closely related, many features of GDB apply to both languages. Whenever this is the case, we discuss those languages together.\n\nThe C debugging facilities are jointly implemented by the C compiler and GDB. Therefore, to debug your C code effectively, you must compile your C programs with a supported C compiler, such as GNU , or the HP ANSI C compiler ( ).\n\n15.4.1.1 C and C Operators\n\nOperators must be defined on values of specific types. For instance, is defined on numbers, but not on structures. Operators are often defined on groups of types.\n\nFor the purposes of C and C , the following definitions hold:\n• Integral types include with any of its storage-class specifiers; ; ; and, for C , .\n• Floating-point types include , , and (if supported by the target platform).\n• Scalar types include all of the above.\n\nThe following operators are supported. They are listed here in order of increasing precedence:\n\nIf an operator is redefined in the user code, GDB usually attempts to invoke the redefined version instead of using the operator’s predefined meaning.\n\n15.4.1.2 C and C Constants\n\nGDB allows you to express the constants of C and C in the following ways:\n• Integer constants are a sequence of digits. Octal constants are specified by a leading ‘ ’ (i.e. zero), and hexadecimal constants by a leading ‘ ’ or ‘ ’. Constants may also end with a letter ‘ ’, specifying that the constant should be treated as a value.\n• Floating point constants are a sequence of digits, followed by a decimal point, followed by a sequence of digits, and optionally followed by an exponent. An exponent is of the form: ‘ ’, where is another sequence of digits. The ‘ ’ is optional for positive exponents. A floating-point constant may also end with a letter ‘ ’ or ‘ ’, specifying that the constant should be treated as being of the (as opposed to the default ) type; or with a letter ‘ ’ or ‘ ’, which specifies a constant.\n• Enumerated constants consist of enumerated identifiers, or their integral equivalents.\n• Character constants are a single character surrounded by single quotes ( ), or a number—the ordinal value of the corresponding character (usually its ASCII value). Within quotes, the single character may be represented by a letter or by escape sequences, which are of the form ‘ ’, where is the octal representation of the character’s ordinal value; or of the form ‘ ’, where ‘ ’ is a predefined special character—for example, ‘ ’ for newline. Wide character constants can be written by prefixing a character constant with ‘ ’, as in C. For example, ‘ ’ is the wide form of ‘ ’. The target wide character set is used when computing the value of this constant (see Character Sets).\n• String constants are a sequence of character constants surrounded by double quotes ( ). Any valid character constant (as described above) may appear. Double quotes within the string must be preceded by a backslash, so for instance ‘ ’ is a string of five characters. Wide string constants can be written by prefixing a string constant with ‘ ’, as in C. The target wide character set is used when computing the value of this constant (see Character Sets).\n• Pointer constants are an integral value. You can also write pointers to constants using the C operator ‘ ’.\n• Array constants are comma-separated lists surrounded by braces ‘ ’ and ‘ ’; for example, ‘ ’ is a three-element array of integers, ‘ ’ is a three-by-two array, and ‘ ’ is a three-element array of pointers.\n\nGDB expression handling can interpret most C expressions.\n• Member function calls are allowed; you can use expressions like\n• While a member function is active (in the selected stack frame), your expressions have the same namespace available as the member function; that is, GDB allows implicit references to the class instance pointer following the same rules as C . declarations in the current scope are also respected by GDB.\n• You can call overloaded functions; GDB resolves the function call to the right definition, with some restrictions. GDB does not perform overload resolution involving user-defined type conversions, calls to constructors, or instantiations of templates that do not exist in the program. It also cannot handle ellipsis argument lists or default arguments. It does perform integral conversions and promotions, floating-point promotions, arithmetic conversions, pointer conversions, conversions of class objects to base classes, and standard conversions such as those of functions or arrays to pointers; it requires an exact match on the number of function arguments. Overload resolution is always performed, unless you have specified . See GDB Features for C . You must specify in order to use an explicit function signature to call an overloaded function, as in The GDB command-completion facility can simplify this; see Command Completion.\n• GDB understands variables declared as C lvalue or rvalue references; you can use them in expressions just as you do in C source—they are automatically dereferenced. In the parameter list shown when GDB displays a frame, the values of reference variables are not displayed (unlike other variables); this avoids clutter, since references are often used for large structures. The address of a reference variable is always shown, unless you have specified ‘ ’.\n• GDB supports the C name resolution operator —your expressions can use it just as expressions in your program do. Since one scope may be defined in another, you can use repeatedly if necessary, for example in an expression like ‘ ’. GDB also allows resolving name scope by reference to source files, in both C and C debugging (see Program Variables).\n• GDB performs argument-dependent lookup, following the C specification.\n\n15.4.1.4 C and C Defaults\n\nIf you allow GDB to set range checking automatically, it defaults to whenever the working language changes to C or C . This happens regardless of whether you or GDB selects the working language.\n\nIf you allow GDB to set the language automatically, it recognizes source files whose names end with , , or , etc, and when GDB enters code compiled from one of these files, it sets the working language to C or C . See Having GDB Infer the Source Language, for further details.\n\n15.4.1.5 C and C Type and Range Checks\n\nBy default, when GDB parses C or C expressions, strict type checking is used. However, if you turn type checking off, GDB will allow certain non-standard conversions, such as promoting integer constants to pointers.\n\nRange checking, if turned on, is done on mathematical operations. Array indices are not checked, since they are often used to index a pointer that is not itself an array.\n\nThe and commands apply to the type. When set to ‘ ’, any that is inside a or is also printed. Otherwise, it appears as ‘ ’.\n\nThe operator aids in the debugging of dynamic arrays, formed with pointers and a memory allocation function. See Expressions.\n\nSome GDB commands are particularly useful with C , and some are designed specifically for use with C . Here is a summary:\n\nGDB can examine, set and perform computations with numbers in decimal floating point format, which in the C language correspond to the , and types as specified by the extension to support decimal floating-point arithmetic.\n\nThere are two encodings in use, depending on the architecture: BID (Binary Integer Decimal) for x86 and x86-64, and DPD (Densely Packed Decimal) for PowerPC and S/390. GDB will use the appropriate encoding for the configured target.\n\nBecause of a limitation in , the library used by GDB to manipulate decimal floating point numbers, it is not possible to convert (using a cast, for example) integers wider than 32-bit to decimal float.\n\nIn addition, in order to imitate GDB’s behavior with binary floating point computations, error checking in decimal float operations ignores underflow, overflow and divide by zero exceptions.\n\nIn the PowerPC architecture, GDB provides a set of pseudo-registers to inspect values stored in floating point registers. See PowerPC for more details.\n\nGDB can be used to debug programs written in D and compiled with GDC, LDC or DMD compilers. Currently GDB supports only one D specific feature — dynamic arrays.\n\nGDB can be used to debug programs written in Go and compiled with or compilers.\n\nHere is a summary of the Go-specific features and restrictions:\n\nThis section provides information about some commands and command options that are useful for debugging Objective-C code. See also info classes, and info selectors, for a few more commands specific to Objective-C support.\n\nThe following commands have been extended to accept Objective-C method names as line specifications:\n\nA fully qualified Objective-C method name is specified as\n\nwhere the minus sign is used to indicate an instance method and a plus sign (not shown) is used to indicate a class method. The class name and method name are enclosed in brackets, similar to the way messages are specified in Objective-C source code. For example, to set a breakpoint at the instance method of class in the program currently being debugged, enter:\n\nTo list ten program lines around the class method, enter:\n\nIn the current version of GDB, the plus or minus sign is required. In future versions of GDB, the plus or minus sign will be optional, but you can use it to narrow the search. It is also possible to specify just a method name:\n\nYou must specify the complete method name, including any colons. If your program’s source files contain more than one method, you’ll be presented with a numbered list of classes that implement that method. Indicate your choice by number, or type ‘ ’ to exit if none apply.\n\nAs another example, to clear a breakpoint established at the method of the class, enter:\n\nThe print command has also been extended to accept methods. For example:\n\nwill tell GDB to send the message to and print the result. Also, an additional command has been added, or for short, which is meant to print the description of an object. However, this command may only work with certain Objective-C libraries that have a particular hook function, , defined.\n\nThis section provides information about GDBs OpenCL C support.\n\nGDB supports the builtin scalar and vector datatypes specified by OpenCL 1.1. In addition the half- and double-precision floating point data types of the and OpenCL extensions are also known to GDB.\n\nGDB supports accesses to vector components including the access as lvalue where possible. Since OpenCL C is based on C99 most C expressions supported by GDB can be used as well.\n\nGDB supports the operators specified by OpenCL 1.1 for scalar and vector data types.\n\nGDB can be used to debug programs written in Fortran. Note, that not all Fortran language features are available yet.\n\nSome Fortran compilers (GNU Fortran 77 and Fortran 95 compilers among them) append an underscore to the names of variables and functions. When you debug programs compiled by those compilers, you will need to refer to variables and functions with a trailing underscore.\n\nFortran symbols are usually case-insensitive, so GDB by default uses case-insensitive matching for Fortran symbols. You can change that with the ‘ ’ command, see Symbols, for the details.\n\nIn Fortran the primitive data-types have an associated type parameter, written as ‘ ’, ‘ ’, or in the GDB-only dialect ‘ ’. A concrete example would be ‘ ’, ‘ ’, and ‘ ’. The kind of a type can be retrieved by using the intrinsic function , see Fortran Intrinsics.\n\nGenerally, the actual implementation of the type parameter is compiler specific. In GDB the kind parameter is implemented in accordance with its use in the GNU compiler. Here, the kind parameter for a given specifies its size in memory — a Fortran or would be an integer type occupying 4 bytes of memory. An exception to this rule is the type for which the kind of the type does not specify its entire size, but the size of each of the two ’s it is composed of. A would thus consist of two s and occupy 8 bytes of memory.\n\nFor every type there is also a default kind associated with it, e.g. in GDB will internally be an (see the table below for default types). The default types are the same as in GNU compilers but note, that the GNU default types can actually be changed by compiler flags such as and .\n\nNot every kind parameter is valid for every type and in GDB the following type kinds are available.\n\nOperators must be defined on values of specific types. For instance, is defined on numbers, but not on characters or other non- arithmetic types. Operators are often defined on groups of types.\n\nFortran provides a large set of intrinsic procedures. GDB implements an incomplete subset of those procedures and their overloads. Some of these procedures take an optional parameter, see Fortran Types.\n\nGDB has some commands to support Fortran-specific features, such as displaying common blocks.\n\nDebugging Pascal programs which use sets, subranges, file variables, or nested functions does not currently work. GDB does not support entering expressions, printing values, or similar features using Pascal syntax.\n\nThe Pascal-specific command controls whether static members of Pascal objects are displayed. See pascal_static-members.\n\nGDB supports the Rust Programming Language. Type- and value-printing, and expression parsing, are reasonably complete. However, there are a few peculiarities and holes to be aware of.\n• Linespecs (see Location Specifications) are never relative to the current crate. Instead, they act as if there were a global namespace of crates, somewhat similar to the way behaves. That is, if GDB is stopped at a breakpoint in a function in crate ‘ ’, module ‘ ’, then will attempt to set a breakpoint in a function named ‘ ’ in a crate named ‘ ’. As a consequence of this approach, linespecs also cannot refer to items using ‘ ’ or ‘ ’.\n• Because GDB implements Rust name-lookup semantics in expressions, it will sometimes prepend the current crate to a name. For example, if GDB is stopped at a breakpoint in the crate ‘ ’, then will try to find the symbol ‘ ’. However, since it is useful to be able to refer to other crates when debugging, GDB provides the extension to circumvent this. To use the extension, just put before a path expression to refer to the otherwise unavailable “global” scope. In the above example, if you wanted to refer to the symbol ‘ ’ in the crate ‘ ’, you would use .\n• The Rust expression evaluator does not support “statement-like” expressions such as or , or lambda expressions.\n• The Rust expression evaluator does not currently implement the trait. Objects that may be created by the evaluator will never be destroyed.\n• GDB does not implement type inference for generics. In order to call generic functions or otherwise refer to generic items, you will have to specify the type parameters manually.\n• GDB currently uses the C demangler for Rust. In most cases this does not cause any problems. However, in an expression context, completing a generic function name will give syntactically invalid results. This happens because Rust requires the ‘ ’ operator between the function name and its generic arguments. For example, GDB might provide a completion like , where the parser would require .\n• As of this writing, the Rust compiler (version 1.8) has a few holes in the debugging information it generates. These holes prevent certain features from being implemented by GDB:\n• Method calls cannot be made via traits.\n• When debugging in a monomorphized function, you cannot use the generic type names.\n• The type is not available.\n• statements are not available, so some names may not be available in the crate.\n\nThe extensions made to GDB to support Modula-2 only support output from the GNU Modula-2 compiler (which is currently being developed). Other Modula-2 compilers are not currently supported, and attempting to debug executables produced by them is most likely to give an error as GDB reads in the executable’s symbol table.\n\nOperators must be defined on values of specific types. For instance, is defined on numbers, but not on structures. Operators are often defined on groups of types. For the purposes of Modula-2, the following definitions hold:\n• Integral types consist of , , and their subranges.\n• Character types consist of and its subranges.\n• Pointer types consist of anything declared as .\n• Scalar types consist of all of the above.\n\nThe following operators are supported, and appear in order of increasing precedence:\n\nModula-2 also makes available several built-in procedures and functions. In describing these, the following metavariables are used:\n\nAll Modula-2 built-in procedures also return a result, described below.\n\nGDB allows you to express the constants of Modula-2 in the following ways:\n• Integer constants are simply a sequence of digits. When used in an expression, a constant is interpreted to be type-compatible with the rest of the expression. Hexadecimal integers are specified by a trailing ‘ ’, and octal integers by a trailing ‘ ’.\n• Floating point constants appear as a sequence of digits, followed by a decimal point and another sequence of digits. An optional exponent can then be specified, in the form ‘ ’, where ‘ ’ is the desired exponent. All of the digits of the floating point constant must be valid decimal (base 10) digits.\n• Character constants consist of a single character enclosed by a pair of like quotes, either single ( ) or double ( ). They may also be expressed by their ordinal value (their ASCII value, usually) followed by a ‘ ’.\n• String constants consist of a sequence of characters enclosed by a pair of like quotes, either single ( ) or double ( ). Escape sequences in the style of C are also allowed. See C and C Constants, for a brief explanation of escape sequences.\n• Boolean constants consist of the identifiers and .\n• Set constants are not yet supported.\n\nCurrently GDB can print the following data types in Modula-2 syntax: array types, record types, set types, pointer types, procedure types, enumerated types, subrange types and base types. You can also print the contents of variables declared using these type. This section gives a number of simple source code examples together with sample GDB sessions.\n\nThe first example contains the following section of code:\n\nand you can request GDB to interrogate the type and value of and .\n\nLikewise if your source code declares as:\n\nthen you may query the type of by:\n\nNote that at present you cannot interactively manipulate set expressions using the debugger.\n\nThe following example shows how you might declare an array in Modula-2 and how you can interact with GDB to print its type and contents:\n\nNote that the array handling is not yet complete and although the type is printed correctly, expression handling still assumes that all arrays have a lower bound of zero and not as in the example above.\n\nHere are some more type related Modula-2 examples:\n\nThe GDB interaction shows how you can query the data type and value of a variable.\n\nIn this example a Modula-2 array is declared and its contents displayed. Observe that the contents are written in the same way as their counterparts.\n\nThe Modula-2 language interface to GDB also understands pointer types as shown in this example:\n\nand you can request that GDB describes the type of .\n\nGDB handles compound types as we can see in this example. Here we combine array types, record types, pointer types and subrange types:\n\nand you can ask GDB to describe the type of as shown below.\n\nIf type and range checking are set automatically by GDB, they both default to whenever the working language changes to Modula-2. This happens regardless of whether you or GDB selected the working language.\n\nIf you allow GDB to set the language automatically, then entering code compiled from a file whose name ends with sets the working language to Modula-2. See Having GDB Infer the Source Language, for further details.\n\nA few changes have been made to make Modula-2 programs easier to debug. This is done primarily via loosening its type strictness:\n• Unlike in standard Modula-2, pointer constants can be formed by integers. This allows you to modify pointer variables during debugging. (In standard Modula-2, the actual address contained in a pointer variable is hidden from you; it can only be modified through direct assignment to another pointer variable or expression that returned a pointer.)\n• C escape sequences can be used in strings and characters to represent non-printable characters. GDB prints out strings with these escape sequences embedded. Single non-printable characters are printed using the ‘ ’ format.\n• The assignment operator ( ) returns the value of its right-hand argument.\n• All built-in procedures both modify and return their argument.\n• They are of types that have been declared equivalent via a statement\n• They have been declared on the same line. (Note: This is true of the GNU Modula-2 compiler, but it may not be true of other compilers.)\n\nAs long as type checking is enabled, any attempt to combine variables whose types are not equivalent is an error.\n\nRange checking is done on all mathematical operations, assignment, array index bounds, and all built-in functions and procedures.\n\nThere are a few subtle differences between the Modula-2 scope operator ( ) and the GDB scope operator ( ). The two have similar syntax:\n\nwhere is the name of a module or a procedure, the name of a module, and is any declared identifier within your program, except another module.\n\nUsing the operator makes GDB search the scope specified by for the identifier . If it is not found in the specified scope, then GDB searches all scopes enclosing the one specified by .\n\nUsing the operator makes GDB search the current scope for the identifier specified by that was imported from the definition module specified by . With this operator, it is an error if the identifier was not imported from definition module , or if is not an identifier in .\n\nSome GDB commands have little use when debugging Modula-2 programs. Five subcommands of and apply specifically to C and C : ‘ ’, ‘ ’, ‘ ’, ‘ ’, and ‘ ’. The first four apply to C , and the last to the C type, which has no direct analogue in Modula-2.\n\nThe operator (see Expressions), while available with any language, is not useful with Modula-2. Its intent is to aid the debugging of dynamic arrays, which cannot be created in Modula-2 as they can in C or C . However, because an address can be specified by an integral constant, the construct ‘ ’ is still useful.\n\nIn GDB scripts, the Modula-2 inequality operator is interpreted as the beginning of a comment. Use instead.\n\nThe extensions made to GDB for Ada only support output from the GNU Ada (GNAT) compiler. Other Ada compilers are not currently supported, and attempting to debug executables produced by them is most likely to be difficult.\n\nThe Ada mode of GDB supports a fairly large subset of Ada expression syntax, with some extensions. The philosophy behind the design of this subset is\n• That GDB should provide basic literals and access to operations for arithmetic, dereferencing, field selection, indexing, and subprogram calls, leaving more sophisticated computations to subprograms written into the program (which therefore may be called from GDB).\n• That type safety and strict adherence to Ada language restrictions are not particularly important to the GDB user.\n• That brevity is important to the GDB user.\n\nThus, for brevity, the debugger acts as if all names declared in user-written packages are directly visible, even if they are not visible according to Ada rules, thus making it unnecessary to fully qualify most names with their packages, regardless of context. Where this causes ambiguity, GDB asks the user’s intent.\n\nThe debugger will start in Ada mode if it detects an Ada main program. As for other languages, it will enter Ada mode when stopped in a program that was translated from an Ada source file.\n\nWhile in Ada mode, you may use ‘ ’ for comments. This is useful mostly for documenting command files. The standard GDB comment (‘ ’) still works at the beginning of a line in Ada mode, but not in the middle (to allow based literals).\n\nHere are the notable omissions from the subset:\n• Only a subset of the attributes are supported:\n• - , , and on array objects (not on types and subtypes).\n• - on array objects (not subtypes), but only as the right operand of the membership ( ) operator.\n• - is available for objects (not types).\n• - is available, but not for indefinite types.\n• The names in are not available.\n• Equality tests (‘ ’ and ‘ ’) on arrays test for bitwise equality of representations. They will generally work correctly for strings and arrays whose elements have integer or enumeration types. They may not work correctly for arrays whose element types have user-defined equality, for arrays of real values (in particular, IEEE-conformant floating point, because of negative zeroes and NaNs), and for arrays whose elements contain unused bits with indeterminate values.\n• The other component-by-component array operations ( , , , , and relational tests other than equality) are not implemented.\n• There is limited support for array and record aggregates. They are permitted only on the right sides of assignments, as in these examples: Changing a discriminant’s value by assigning an aggregate has an undefined effect if that discriminant is used within the record. However, you can first modify discriminants by directly assigning to them (which normally would not be allowed in Ada), and then performing an aggregate assignment. For example, given a variable declared to have a type such as: you can assign a value with a different size of with two assignments: As this example also illustrates, GDB is very loose about the usual rules concerning aggregates. You may leave out some of the components of an array or record aggregate (such as the component in the assignment to above); they will retain their original values upon assignment. You may freely use dynamic values as indices in component associations. You may even use overlapping or redundant component associations, although which component values are assigned in such cases is not defined.\n• Calls to dispatching subprograms are not implemented.\n• The overloading algorithm is much more limited (i.e., less selective) than that of real Ada. It makes only limited use of the context in which a subexpression appears to resolve its meaning, and it is much looser in its rules for allowing type matches. As a result, some function calls will be ambiguous, and the user will be asked to choose the proper resolution.\n• The operator is not implemented.\n• Aside from printing, arithmetic operations on the native VAX floating-point formats are not supported.\n• It is not possible to slice a packed array.\n• The names and , when not part of a qualified name, are interpreted as if implicitly prefixed by , regardless of context. Should your program redefine these names in a package or procedure (at best a dubious practice), you will have to use fully qualified names to access their new definitions.\n\nAs it does for other languages, GDB makes certain generic extensions to Ada (see Expressions):\n• If the expression is a variable residing in memory (typically a local variable or array element) and is a positive integer, then displays the values of and the -1 adjacent variables following it in memory as an array. In Ada, this operator is generally not necessary, since its prime use is in displaying parts of an array, and slicing will usually do this in Ada. However, there are occasional uses when debugging programs in which certain debugging information has been optimized away.\n• means “the variable named that appears in function or file .” When is a file name, you must typically surround it in single quotes.\n• The expression means “the variable of type that appears at address .”\n• A name starting with ‘ ’ is a convenience variable (see Convenience Vars) or a machine register (see Registers).\n\nIn addition, GDB provides a few other shortcuts and outright additions specific to Ada:\n• The assignment statement is allowed as an expression, returning its right-hand operand as its value. Thus, you may enter\n• The semicolon is allowed as an “operator,” returning as its value the value of its right-hand operand. This allows, for example, complex conditional breaks:\n• An extension to based literals can be used to specify the exact byte contents of a floating-point literal. After the base, you can use from zero to two ‘ ’ characters, followed by an ‘ ’. The number of ‘ ’ characters controls the width of the resulting real constant: zero means is used, one means , and two means .\n• Rather than use catenation and symbolic character names to introduce special characters into strings, one may instead use a special bracket notation, which is also used to print strings. A sequence of characters of the form ‘ ’ within a string or character literal denotes the (single) character whose numeric encoding is in hexadecimal. The sequence of characters ‘ ’ also denotes a single quotation mark in strings. For example, contains an ASCII newline character ( ) after each period.\n• The subtype used as a prefix for the attributes , , and is optional (and is ignored in any case). For example, it is valid to write\n• When printing arrays, GDB uses positional notation when the array has a lower bound of 1, and uses a modified named notation otherwise. For example, a one-dimensional array of three integers with a lower bound of 3 might print as That is, in contrast to valid Ada, only the first component has a clause.\n• You may abbreviate attributes in expressions with any unique, multi-character subsequence of their names (an exact match gets preference). For example, you may use , , or in place of .\n• Since Ada is case-insensitive, the debugger normally maps identifiers you type to lower case. The GNAT compiler uses upper-case characters for some of its internal identifiers, which are normally of no interest to users. For the rare occasions when you actually have to look at them, enclose them in angle brackets to avoid the lower-case mapping. For example,\n• Printing an object of class-wide type or dereferencing an access-to-class-wide value will display all the components of the object’s specific type (as indicated by its run-time tag). Likewise, component selection on such a value will operate on the specific type of the object.\n\nThe debugger supports limited overloading. Given a subprogram call in which the function symbol has multiple definitions, it will use the number of actual parameters and some information about their types to attempt to narrow the set of definitions. It also makes very limited use of context, preferring procedures to functions in the context of the command, and functions to procedures elsewhere.\n\nIf, after narrowing, the set of matching definitions still contains more than one definition, GDB will display a menu to query which one it should use, for instance:\n\nIn this case, just select one menu entry either to cancel expression evaluation (type and press ) or to continue evaluation with a specific instance (type the corresponding number and press ).\n\nHere are a couple of commands to customize GDB’s behavior in this case:\n\n15.4.10.5 Stopping at the Very Beginning\n\nIt is sometimes necessary to debug the program during elaboration, and before reaching the main procedure. As defined in the Ada Reference Manual, the elaboration code is invoked from a procedure called . To run your program up to the beginning of elaboration, simply use the following two commands: and .\n\nA command is provided to list all Ada exceptions:\n\nBelow is a small example, showing how the command can be used, first without argument, and next with a regular expression passed as an argument.\n\nIt is also possible to ask GDB to stop your program’s execution when an exception is raised. For more details, see Set Catchpoints.\n\nSupport for Ada tasks is analogous to that for threads (see Threads). GDB provides the following task-related commands:\n\nWhen inspecting a core file, as opposed to debugging a live program, tasking support may be limited or even unavailable, depending on the platform being used. For instance, on x86-linux, the list of tasks is available, but task switching is not supported.\n\nOn certain platforms, the debugger needs to perform some memory writes in order to provide Ada tasking support. When inspecting a core file, this means that the core file must be opened with read-write privileges, using the command ‘ ’ (see Patching). Under these circumstances, you should make a backup copy of the core file before inspecting it with GDB.\n\n15.4.10.9 Tasking Support when using the Ravenscar Profile\n\nThe Ravenscar Profile is a subset of the Ada tasking features, specifically designed for systems with safety-critical real-time requirements.\n\nWhen Ravenscar task-switching is enabled, Ravenscar tasks are announced by GDB as if they were threads:\n\nBoth Ravenscar tasks and the underlying CPU threads will show up in the output of :\n\nOne known limitation of the Ravenscar support in GDB is that it isn’t currently possible to single-step through the runtime initialization sequence. If you need to debug this code, you should use .\n\nThe GNAT compiler supports a number of character sets for source files. See (gnat_ugn)Character Set Control. GDB includes support for this as well.\n\nBesides the omissions listed previously (see Omissions from Ada), we know of several problems with and limitations of Ada mode in GDB, some of which will be fixed with planned future releases of the debugger and the GNU Ada compiler.\n• Static constants that the compiler chooses not to materialize as objects in storage are invisible to the debugger.\n• Named parameter associations in function argument lists are ignored (the argument lists are treated as positional).\n• Many useful library packages are currently invisible to the debugger.\n• Fixed-point arithmetic, conversions, input, and output is carried out using floating-point arithmetic, and may give results that only approximate those on the host machine.\n• The GNAT compiler never generates the prefix for any of the standard symbols defined by the Ada language. GDB knows about this: it will strip the prefix from names when you use it, and will never look for a name you have so qualified among local symbols, nor match against symbols in other packages or subprograms. If you have defined entities anywhere in your program other than parameters and local variables whose simple names match names in , GNAT’s lack of qualification here can cause confusion. When this happens, you can usually resolve the confusion by qualifying the problematic names with package explicitly.\n\nOlder versions of the compiler sometimes generate erroneous debugging information, resulting in the debugger incorrectly printing the value of affected entities. In some cases, the debugger is able to work around an issue automatically. In other cases, the debugger is able to work around the issue, but the work-around has to be specifically enabled.\n\nInternally, the debugger also relies on the compiler following a number of conventions known as the ‘ ’, all documented in in the GCC sources. This encoding describes how the debugging information should be generated for certain types. In particular, this convention makes use of descriptive types, which are artificial types generated purely to help the debugger.\n\nThese encodings were defined at a time when the debugging information format used was not powerful enough to describe some of the more complex types available in Ada. Since DWARF allows us to express nearly all Ada features, the long-term goal is to slowly replace these descriptive types by their pure DWARF equivalent. To facilitate that transition, a new maintenance option is available to force the debugger to ignore those descriptive types. It allows the user to quickly evaluate how well GDB works without them.\n\nIn addition to the other fully-supported programming languages, GDB also provides a pseudo-language, called . It does not represent a real programming language, but provides a set of capabilities close to what the C or assembly languages provide. This should allow most simple operations to be performed while debugging an application that uses a language currently not supported by GDB.\n\nIf the language is set to , GDB will automatically select this language if the current frame corresponds to an unsupported language.\n\nThe commands described in this chapter allow you to inquire about the symbols (names of variables, functions and types) defined in your program. This information is inherent in the text of your program and does not change as your program executes. GDB finds it in your program’s symbol table, in the file indicated when you started GDB (see Choosing Files), or by one of the file-management commands (see Commands to Specify Files).\n\nOccasionally, you may need to refer to symbols that contain unusual characters, which GDB ordinarily treats as word delimiters. The most frequent case is in referring to static variables in other source files (see Program Variables). File names are recorded in object files as debugging symbols, but GDB would ordinarily parse a typical file name, like , as the three words ‘ ’ ‘ ’ ‘ ’. To allow GDB to recognize ‘ ’ as a single symbol, enclose it in single quotes; for example,\n\nlooks up the value of in the scope of the file .\n\nOnce you think you have found an error in your program, you might want to find out for certain whether correcting the apparent error would lead to correct results in the rest of the run. You can find the answer by experiment, using the GDB features for altering execution of the program.\n\nFor example, you can store new values into variables or memory locations, give your program a signal, restart it at a different address, or even return prematurely from a function.\n\nTo alter the value of a variable, evaluate an assignment expression. See Expressions. For example,\n\nstores the value 4 into the variable , and then prints the value of the assignment expression (which is 4). See Using GDB with Different Languages, for more information on operators in supported languages.\n\nIf you are not interested in seeing the value of the assignment, use the command instead of the command. is really the same as except that the expression’s value is not printed and is not put in the value history (see Value History). The expression is evaluated only for its effects.\n\nIf the beginning of the argument string of the command appears identical to a subcommand, use the command instead of just . This command is identical to except for its lack of subcommands. For example, if your program has a variable , you get an error if you try to set a new value with just ‘ ’, because GDB has the command :\n\nThe invalid expression, of course, is ‘ ’. In order to actually set the program’s variable , use\n\nBecause the command has many subcommands that can conflict with the names of program variables, it is a good idea to use the command instead of just . For example, if your program has a variable , you run into problems if you try to set a new value with just ‘ ’, because GDB has the command , abbreviated :\n\nThe program variable did not change, and you silently set the to an invalid value. In order to set the variable , use\n\nGDB allows more implicit conversions in assignments than C; you can freely store an integer value into a pointer variable or vice versa, and you can convert any structure to any other structure that is the same length or shorter.\n\nTo store values into arbitrary places in memory, use the ‘ ’ construct to generate a value of specified type at a specified address (see Expressions). For example, refers to memory location as an integer (which implies a certain size and representation in memory), and\n\nstores the value 4 into that memory location.\n\nOrdinarily, when you continue your program, you do so at the place where it stopped, with the command. You can instead continue at an address of your own choosing, with the following commands:\n\nOn many systems, you can get much the same effect as the command by storing a new value into the register . The difference is that this does not start your program running; it only changes the address of where it will run when you continue. For example,\n\nmakes the next command or stepping command execute at address , rather than at the address where your program stopped. See Continuing and Stepping.\n\nHowever, writing directly to will only change the value of the program-counter register, while using will ensure that any additional auxiliary state is also updated. For example, on SPARC, will update both and registers prior to resuming execution. When using the approach of writing directly to it is your job to also update the register.\n\nThe most common occasion to use the command is to back up—perhaps with more breakpoints set—over a portion of a program that has already executed, in order to examine its execution in more detail.\n\nSee stepping into signal handlers, for information on how stepping commands behave when the thread has a signal queued.\n\nWhen you use , GDB discards the selected stack frame (and all frames within it). You can think of this as making the discarded frame return prematurely. If you wish to specify a value to be returned, give that value as the argument to .\n\nThis pops the selected stack frame (see Selecting a Frame), and any other frames inside of it, leaving its caller as the innermost remaining frame. That frame becomes selected. The specified value is stored in the registers used for returning values of functions.\n\nThe command does not resume execution; it leaves the program stopped in the state that would exist if the function had just returned. In contrast, the command (see Continuing and Stepping) resumes execution until the selected stack frame returns naturally.\n\nGDB needs to know how the argument should be set for the inferior. The concrete registers assignment depends on the OS ABI and the type being returned by the selected stack frame. For example it is common for OS ABI to return floating point values in FPU registers while integer values in CPU registers. Still some ABIs return even floating point values in CPU registers. Larger integer widths (such as ) also have specific placement rules. GDB already knows the OS ABI from its current target so it needs to find out also the type being returned to make the assignment into the right register(s).\n\nNormally, the selected stack frame has debug info. GDB will always use the debug info instead of the implicit type of when the debug info is available. For example, if you type , and the function in the current stack frame is declared to return a , GDB transparently converts the implicit value of -1 into a :\n\nHowever, if the selected stack frame does not have a debug info, e.g., if the function was compiled without debug info, GDB has to find out the type to return from user. Specifying a different type by mistake may set the value in different inferior registers than the caller code expects. For example, typing with its implicit type would set only a part of a result for a debug info less function (on 32-bit architectures). Therefore the user is required to specify the return type by an appropriate cast explicitly:\n\nIt is possible for the function you call via the or command to generate a signal (e.g., if there’s a bug in the function, or if you passed it incorrect arguments). What happens in that case is controlled by the command.\n\nSimilarly, with a C program it is possible for the function you call via the or command to generate an exception that is not handled due to the constraints of the dummy frame. In this case, any exception that is raised in the frame, but has an out-of-frame exception handler will not be found. GDB builds a dummy-frame for the inferior function call, and the unwinder cannot seek for exception handlers outside of this dummy-frame. What happens in that case is controlled by the command.\n\nWhen calling a function within a program, it is possible that the program could enter a state from which the called function may never return. If this happens then it is possible to interrupt the function call by typing the interrupt character (often ).\n\nIf a called function is interrupted for any reason, including hitting a breakpoint, or triggering a watchpoint, and the stack is not unwound due to , , or (see stack unwind settings), then the dummy-frame, created by GDB to facilitate the call to the program function, will be visible in the backtrace, for example frame in the following backtrace:\n\nAt this point it is possible to examine the state of the inferior just like any other stop.\n\nDepending on why the function was interrupted then it may be possible to resume the inferior (using commands like , , etc). In this case, when the inferior finally returns to the dummy-frame, GDB will once again halt the inferior.\n\nOn targets that support asynchronous execution (see Background Execution) GDB can place a timeout on any functions called from GDB. If the timeout expires and the function call is still ongoing, then GDB will interrupt the program.\n\nIf a function called from GDB is interrupted by a timeout, then by default the inferior is left in the frame where the timeout occurred, this behavior can be adjusted with ‘ ’ (see set unwind-on-timeout).\n\nFor targets that don’t support asynchronous execution (see Background Execution) then timeouts for functions called from GDB are not supported, the timeout settings described below will be treated as , meaning GDB will wait indefinitely for function call to complete, unless interrupted by the user using .\n\nIt is also possible to call functions within the program from the condition of a conditional breakpoint (see Break Conditions). A different setting controls the timeout used for function calls made from a breakpoint condition.\n\nSometimes, a function you wish to call is missing debug information. In such case, GDB does not know the type of the function, including the types of the function’s parameters. To avoid calling the inferior function incorrectly, which could result in the called function functioning erroneously and even crash, GDB refuses to call the function unless you tell it the type of the function.\n\nFor prototyped (i.e. ANSI/ISO style) functions, there are two ways to do that. The simplest is to cast the call to the function’s declared return type. For example:\n\nCasting the return type of a no-debug function is equivalent to casting the function to a pointer to a prototyped function that has a prototype that matches the types of the passed-in arguments, and calling that. I.e., the call above is equivalent to:\n\nand given this prototyped C or C++ function with float parameters:\n\nIf the function you wish to call is declared as unprototyped (i.e. old K&R style), you must use the cast-to-function-pointer syntax, so that GDB knows that it needs to apply default argument promotions (promote float arguments to double). See float promotion. For example, given this unprototyped C function with float parameters, and no debug info:\n\nyou call it like this:\n\nBy default, GDB opens the file containing your program’s executable code (or the corefile) read-only. This prevents accidental alterations to machine code; but it also prevents you from intentionally patching your program’s binary.\n\nIf you’d like to be able to patch the binary, you can specify that explicitly with the command. For example, you might want to turn on internal debugging flags, or even to make emergency repairs.\n\nGDB supports on-demand compilation and code injection into programs running under GDB. GCC 5.0 or higher built with must be installed for this functionality to be enabled. This functionality is implemented with the following commands.\n\nThe process of compiling and injecting the code can be inspected using:\n\nGDB needs to specify the right compilation options for the code to be injected, in part to make its ABI compatible with the inferior and in part to make the injected code compatible with GDB’s injecting process.\n\nThe options used, in increasing precedence:\n\nYou can override compilation options using the following command:\n\n17.7.2 Caveats when using the command\n\nThere are a few caveats to keep in mind when using the command. As the caveats are different per language, the table below highlights specific issues on a per language basis.\n\nGDB needs to find GCC for the inferior being debugged which may not be obvious for remote targets of different architecture than where GDB is running. Environment variable on GDB host is searched for GCC binary matching the target architecture and operating system. This search can be overridden by GDB command below. is taken from shell that executed GDB, it is not the value set by GDB command ). See Environment.\n\nSpecifically is searched for binaries matching regular expression according to the inferior target being debugged. is processor name — multiarch is supported, so for example both and targets look for pattern and both and targets look for pattern . is currently supported only for pattern .\n\nOn Posix hosts the compiler driver GDB needs to find also shared library from the compiler. It is searched in default shared library search path (overridable with usual environment variable ), unrelated to or settings. Contrary to it is found according to the installation of the found compiler — as possibly specified by the command.\n\nGDB needs to know the file name of the program to be debugged, both in order to read its symbol table and in order to start your program. To debug a core dump of a previous run, you must also tell GDB the name of the core dump file.\n\nYou may want to specify executable and core dump file names. The usual way to do this is at start-up time, using the arguments to GDB’s start-up commands (see Getting In and Out of GDB).\n\nOccasionally it is necessary to change to a different file during a GDB session. Or you may run GDB and forget to specify a file you want to use. Or you are debugging a remote target via (see Using the Program). In these situations the GDB commands to specify new files are useful.\n\nAll file-specifying commands allow both absolute and relative file names as arguments. GDB always converts the file name to an absolute file name and remembers it that way.\n\nOn MS-Windows GDB must be linked with the Expat library to support shared libraries. See Expat.\n\nGDB automatically loads symbol definitions from shared libraries when you use the command, or when you examine a core file. (Before you issue the command, GDB does not understand references to a function in a shared library, however—unless you are debugging a core file).\n\nThere are times, however, when you may wish to not automatically load symbol definitions from shared libraries, such as when they are particularly large or there are many of them.\n\nTo control the automatic loading of shared library symbols, use the commands:\n\nTo explicitly load shared library symbols, use the command:\n\nSometimes you may wish that GDB stops and gives you control when any of shared library events happen. The best way to do this is to use and (see Set Catchpoints).\n\nGDB also supports the command for this. This command exists for historical reasons. It is less useful than setting a catchpoint, because it does not allow for conditions or commands as a catchpoint does.\n\nShared libraries are also supported in many cross or remote debugging configurations. GDB needs to have access to the target’s libraries; this can be accomplished either by providing copies of the libraries on the host system, or by asking GDB to automatically retrieve the libraries from the target. If copies of the target libraries are provided, they need to be the same as the target libraries, although the copies on the target can be stripped as long as the copies on the host are not.\n\nFor remote debugging, you need to tell GDB where the target libraries are, so that it can load the correct copies—otherwise, it may try to load the host’s libraries. GDB has two variables to specify the search directories for target libraries.\n\nWhen processing file names provided by the user, GDB frequently needs to compare them to the file names recorded in the program’s debug info. Normally, GDB compares just the base names of the files as strings, which is reasonably fast even for very large programs. (The base name of a file is the last portion of its name, after stripping all the leading directories.) This shortcut in comparison is based upon the assumption that files cannot have more than one base name. This is usually true, but references to files that use symlinks or similar filesystem facilities violate that assumption. If your program records files using such facilities, or if you provide file names to GDB using symlinks etc., you can set to to instruct GDB to completely canonicalize each pair of file names it needs to compare. This will make file-name comparisons accurate, but at a price of a significant slowdown.\n\nTo speed up file loading, and reduce memory usage, GDB will reuse the objects used to track open files. See BFD in . The following commands allow visibility and control of the caching behavior.\n\nGDB allows you to put a program’s debugging information in a file separate from the executable itself, in a way that allows GDB to find and load the debugging information automatically. Since debugging information can be very large—sometimes larger than the executable code itself—some systems distribute debugging information for their executables in separate files, which users can install only when they need to debug a problem.\n\nGDB supports two ways of specifying the separate debug info file:\n• The executable contains a debug link that specifies the name of the separate debug info file. The separate debug file’s name is usually , where is the name of the corresponding executable file without leading directories (e.g., for ). In addition, the debug link specifies a 32-bit Cyclic Redundancy Check (CRC) checksum for the debug file, which GDB uses to validate that the executable and the debug file came from the same build.\n• The executable contains a build ID, a unique bit string that is also present in the corresponding debug info file. (This is supported only on some operating systems, when using the ELF or PE file formats for binary files and the GNU Binutils.) For more details about this feature, see the description of the command-line option in Command Line Options in . The debug info file’s name is not specified explicitly by the build ID, but can be computed from the build ID, see below.\n\nDepending on the way the debug info file is specified, GDB uses two different methods of looking for the debug file:\n• For the “debug link” method, GDB looks up the named file in the directory of the executable file, then in a subdirectory of that directory named , and finally under each one of the global debug directories, in a subdirectory whose name is identical to the leading directories of the executable’s absolute file name. (On MS-Windows/MS-DOS, the drive letter of the executable’s leading directories is converted to a one-letter subdirectory, i.e. is converted to , because Windows filesystems disallow colons in file names.)\n• For the “build ID” method, GDB looks in the subdirectory of each one of the global debug directories for a file named , where are the first 2 hex characters of the build ID bit string, and are the rest of the bit string. (Real build ID strings are 32 or more hex characters, not 10.) GDB can automatically query servers using build IDs in order to download separate debug files that cannot be found locally. For more information see Debuginfod.\n\nSo, for example, suppose you ask GDB to debug , which has a debug link that specifies the file , and a build ID whose value in hex is . If the list of the global debug directories includes , then GDB will look for the following debug information files, in the indicated order:\n\nIf the debug file still has not been found and (see Debuginfod) is enabled, GDB will attempt to download the file from servers.\n\nGlobal debugging info directories default to what is set by GDB configure option and augmented by the colon-separated list of directories provided via GDB configure option . During GDB run you can also set the global debugging info directories, and view the list GDB is currently using.\n\nA debug link is a special section of the executable file named . The section must contain:\n• A filename, with any leading directory components removed, followed by a zero byte,\n• zero to three bytes of padding, as needed to reach the next four-byte boundary within the section, and\n• a four-byte CRC checksum, stored in the same endianness used for the executable file itself. The checksum is computed on the debugging information file’s full contents by the function given below, passing zero as the argument.\n\nAny executable file format can carry a debug link, as long as it can contain a section named with the contents described above.\n\nThe build ID is a special section in the executable file (and in other ELF binary files that GDB may consider). This section is often named , but that name is not mandatory. It contains unique identification for the built files—the ID remains the same across multiple builds of the same build tree. The default algorithm SHA1 produces 160 bits (40 hexadecimal characters) of the content for the build ID string. The same section with an identical value is present in the original built binary with symbols, in its stripped variant, and in the separate debugging information file.\n\nThe debugging information file itself should be an ordinary executable, containing a full set of linker symbols, sections, and debugging information. The sections of the debugging information file should have the same names, addresses, and sizes as the original file, but they need not contain any data—much like a section in an ordinary executable.\n\nThe GNU binary utilities (Binutils) package includes the ‘ ’ utility that can produce the separated executable / debugging information file pairs using the following commands:\n\nThese commands remove the debugging information from the executable file and place it in the file . You can use the first, second or both methods to link the two files:\n• The debug link method needs the following additional command to also leave behind a debug link in : Ulrich Drepper’s package, starting with version 0.53, contains a version of the command such that the command has the same functionality as the two commands and the command above, together.\n• Build ID gets embedded into the main executable using or the GCC counterpart . Build ID support plus compatibility fixes for debug files separation are present in GNU binary utilities (Binutils) package since version 2.18.\n\nThe CRC used in is the CRC-32 defined in IEEE 802.3 using the polynomial:\n\nThe function is computed byte at a time, taking the least significant bit of each byte first. The initial pattern is used, to ensure leading zeros affect the CRC and the final result is inverted to ensure trailing zeros also affect the CRC.\n\nNote: This is the same CRC polynomial as used in handling the Remote Serial Protocol packet (see qCRC packet). However in the case of the Remote Serial Protocol, the CRC is computed most significant bit first, and the result is not inverted, so trailing zeros have no effect on the CRC value.\n\nTo complete the description, we show below the code of the function which produces the CRC used in . Inverting the initially supplied argument means that an initial call to this function passing in zero will start computing the CRC using .\n\nThis computation does not apply to the “build ID” method.\n\nSome systems ship pre-built executables and libraries that have a special ‘ ’ section. This feature is called MiniDebugInfo. This section holds an LZMA-compressed object and is used to supply extra symbols for backtraces.\n\nThe intent of this section is to provide extra minimal debugging information for use in simple backtraces. It is not intended to be a replacement for full separate debugging information (see Separate Debug Files). The example below shows the intended use; however, GDB does not currently put restrictions on what sort of debugging information might be included in the section.\n\nGDB has support for this extension. If the section exists, then it is used provided that no other source of debugging information can be found, and that GDB was configured with LZMA support.\n\nThis section can be easily created using and other standard utilities:\n\nWhen GDB finds a symbol file, it scans the symbols in the file in order to construct an internal symbol table. This lets most GDB operations work quickly—at the cost of a delay early on. For large programs, this delay can be quite lengthy, so GDB provides a way to build an index, which speeds up startup.\n\nFor convenience, GDB comes with a program, , which can be used to add the index to a symbol file. It takes the symbol file as its only argument:\n\nIt is also possible to do the work manually. Here is what does behind the curtains.\n\nThe index is stored as a section in the symbol file. GDB can write the index to a file, then you can put it into the symbol file using .\n\nTo create an index file, use the command:\n\nOnce you have created an index file you can merge it into your symbol file, here named , using :\n\nGDB will normally ignore older versions of sections that have been deprecated. Usually they are deprecated because they are missing a new feature or have performance issues. To tell GDB to use a deprecated index section anyway specify . The default is . This can speed up startup, but may result in some functionality being lost. See Index Section Format.\n\nWarning: Setting to must be done before gdb reads the file. The following will not work:\n\nInstead you must do, for example,\n\nIndices only work when using DWARF debugging information, not stabs.\n\nIt is possible for GDB to automatically save a copy of this index in a cache on disk and retrieve it from there when loading the same binary in the future. This feature can be turned on with . The following commands can be used to tweak the behavior of the index cache.\n\nThe GNU linker can write the index at link time into the resulting ELF file, by passing the flag to .\n\nThis is especially helpful if you intend to build a program and immediately run it under GDB. You may find that it is faster overall for the linker to write the index while it has the relevant information in memory anyways, rather than re-reloading the data from disk with , or debugging the program without an index at all, especially for large programs.\n\nThe DWARF specification documents an optional index section called ‘ ’. GDB can both read and create this section. However, in order to work with GDB, some extensions were necessary.\n\nGDB uses an augmentation string to specify which extensions are in use and to allow support of backwards-incompatible changes in this functionality. The augmentation string has the form ‘ ’, where is an integral version number of the extensions, which is incremented when the extensions are added or modified. The smallest is 2; earlier versions of GDB used just ‘ ’ with no version number, but these versions of the index are no longer supported.\n\nHere is a list of augmentation string versions along with the changes introduced with each version, compared to the previous version.\n\nGDB can read indexes with augmentation strings ‘ ’ or ‘ ’. GDB does not support reading indexes with any other augmentation strings.\n\nGDB does not use the specified hash table. Therefore, because this hash table is optional, GDB also does not write it.\n\nGDB generates and uses the following non-standard index attributes:\n\nWhile reading a symbol file, GDB occasionally encounters problems, such as symbol types it does not recognize, or known bugs in compiler output. By default, GDB does not notify you of such problems, since they are relatively common and primarily of interest to people debugging compilers. If you are interested in seeing information about ill-constructed symbol tables, you can either ask GDB to print only one message about each such type of problem, no matter how many times the problem occurs; or you can ask GDB to print more messages, to see how many times the problems occur, with the command (see Optional Warnings and Messages).\n\nThe messages currently printed, and their meanings, include:\n\nGDB will sometimes read an auxiliary data file. These files are kept in a directory known as the data directory.\n\nYou can set the data directory’s name, and view the name GDB is currently using.\n\nYou can set the default data directory by using the configure-time ‘ ’ option. If the data directory is inside GDB’s configured binary prefix (set with ‘ ’ or ‘ ’), then the default data directory will be updated automatically if the installed GDB is moved to a new location.\n\nThe data directory may also be specified with the command line option. See Mode Options.\n\nA target is the execution environment occupied by your program.\n\nOften, GDB runs in the same host environment as your program; in that case, the debugging target is specified as a side effect when you use the or commands. When you need more flexibility—for example, running GDB on a physically separate host, or controlling a standalone system over a serial port or a realtime system over a TCP/IP connection—you can use the command to specify one of the target types configured for GDB (see Commands for Managing Targets).\n\nIt is possible to build GDB for several different target architectures. When GDB is built like that, you can choose one of the available architectures with the command.\n\nThere are multiple classes of targets such as: processes, executable files or recording sessions. Core files belong to the process class, making core file and process mutually exclusive. Otherwise, GDB can work concurrently on multiple active targets, one in each class. This allows you to (for example) start a process and inspect its activity, while still having access to the executable file after the process finishes. Or if you start process recording (see Reverse Execution) and there, you are presented a virtual layer of the recording target, while the process target remains stopped at the chronologically last point of the process execution.\n\nUse the and commands to select a new core file or executable target (see Commands to Specify Files). To specify as a target a process that is already running, use the command (see Debugging an Already-running Process).\n\nHere are some common targets (available, or not, depending on the GDB configuration):\n\nDifferent targets are available on different configurations of GDB; your configuration may have more or fewer targets.\n\nMany remote targets require you to download the executable’s code once you’ve successfully established a connection. You may wish to control various aspects of this process.\n\nSome types of processors, such as the , PowerPC, and Renesas SH, offer the ability to run either big-endian or little-endian byte orders. Usually the executable or symbol will include a bit to designate the endian-ness, and you will not need to worry about which to use. However, you may still find it useful to adjust GDB’s idea of processor endian-ness manually.\n\nIf the mode is in effect and no executable has been selected, then the endianness used is the last one chosen either by one of the and commands or by inferring from the last executable used. If no endianness has been previously chosen, then the default for this mode is inferred from the target GDB has been built for, and is if the name of the target CPU has an suffix and otherwise.\n\nNote that these commands merely adjust interpretation of symbolic data on the host, and that they have absolutely no effect on the target system.\n\nIf you are trying to debug a program running on a machine that cannot run GDB in the usual way, it is often useful to use remote debugging. For example, you might use remote debugging on an operating system kernel, or on a small system which does not have a general purpose operating system powerful enough to run a full-featured debugger.\n\nSome configurations of GDB have special serial or TCP/IP interfaces to make this work with particular debugging targets. In addition, GDB comes with a generic serial protocol (specific to GDB, but not specific to any particular target system) which you can use if you write the remote stubs—the code that runs on the remote system to communicate with GDB.\n\nOther remote targets may be available in your configuration of GDB; use to list them.\n\nThis section describes how to connect to a remote target, including the types of connections and their differences, how to set up executable and symbol files on the host and target, and the commands used for connecting to and disconnecting from the remote target.\n\nGDB supports two types of remote connections, mode and mode. Note that many remote targets support only mode. There are several major differences between the two types of connections, enumerated here:\n\nGDB, running on the host, needs access to symbol and debugging information for your program running on the target. This requires access to an unstripped copy of your program, and possibly any associated symbol files. Note that this section applies equally to both mode and mode.\n\nSome remote targets (see qXfer executable filename read, and see Host I/O Packets) allow GDB to access program files over the same connection used to communicate with GDB. With such a target, if the remote program is unstripped, the only command you need is (or ).\n\nIf the remote program is stripped, or the target does not support remote program file access, start up GDB using the name of the local unstripped copy of your program as the first argument, or use the command. Use to specify the location (on the host) of target libraries (unless your GDB was compiled with the correct sysroot using ). Alternatively, you may use to specify how GDB locates target libraries.\n\nThe symbol file and target libraries must exactly match the executable and libraries on the target, with one exception: the files on the host system should not be stripped, even if the files on the target system are. Mismatched or missing files will lead to confusing results during debugging. On GNU/Linux targets, mismatched or missing files may also prevent from debugging multi-threaded programs.\n\nGDB can communicate with the target over a serial line, a local Unix domain socket, or over an network using or . In each case, GDB uses the same protocol for debugging your program; only the medium carrying the debugging packets varies. The and commands establish a connection to the target. Both commands accept the same arguments, which indicate the medium to use:\n\nWhenever GDB is waiting for the remote program, if you type the interrupt character (often ), GDB attempts to stop the program. This may or may not succeed, depending in part on the hardware and the serial drivers the remote system uses. If you type the interrupt character once again, GDB displays this prompt:\n\nIn mode, if you type , GDB abandons the remote debugging session. (If you decide you want to try again later, you can use again to connect once more.) If you type , GDB goes back to waiting.\n\nIn mode, typing will leave GDB connected to the target.\n\nSome remote targets offer the ability to transfer files over the same connection used to communicate with GDB. This is convenient for targets accessible through other means, e.g. GNU/Linux systems running over a network interface. For other targets, e.g. embedded devices with only a single serial port, this may be the only way to upload or download files.\n\nNot all remote targets support these commands.\n\nis a control program for Unix-like systems, which allows you to connect your program with a remote GDB via or —but without linking in the usual debugging stub.\n\nis not a complete replacement for the debugging stubs, because it requires essentially the same operating-system facilities that GDB itself does. In fact, a system that can run to connect to a remote GDB could also run GDB locally! is sometimes useful nevertheless, because it is a much smaller program than GDB itself. It is also easier to port than all of GDB, so you may be able to get started more quickly on a new system by using . Finally, if you develop code for real-time systems, you may find that the tradeoffs involved in real-time operation make it more convenient to do as much development work as possible on another system, for example by cross-compiling. You can use to make a similar choice for debugging.\n\nGDB and communicate via either a serial line or a TCP connection, using the standard GDB remote serial protocol.\n\nRun on the target system. You need a copy of the program you want to debug, including any libraries it requires. does not need your program’s symbol table, so you can strip the program if necessary to save space. GDB on the host system does all the symbol handling.\n\nTo use the server, you must tell it how to communicate with GDB; the name of your program; and the arguments for your program. The usual syntax is:\n\nis either a device name (to use a serial line), or a TCP hostname and portnumber, or or to use stdin/stdout of . For example, to debug Emacs with the argument ‘ ’ and communicate with GDB over the serial port :\n\nwaits passively for the host GDB to communicate with it.\n\nTo use a TCP connection instead of a serial line:\n\nThe only difference from the previous example is the first argument, specifying that you are communicating with the host GDB via TCP. The ‘ ’ argument means that is to expect a TCP connection from machine ‘ ’ to local TCP port 2345. (Currently, the ‘ ’ part is ignored.) You can choose any number you want for the port number as long as it does not conflict with any TCP ports already in use on the target system (for example, is reserved for ).16 You must use the same port number with the host GDB command.\n\nThe connection is useful when starting with ssh:\n\nThe ‘ ’ option to ssh is provided because we don’t need a remote pty, and we don’t want escape-character handling. Ssh does this by default when a command is provided, the flag is provided to make it explicit. You could elide it if you want to.\n\nPrograms started with stdio-connected gdbserver have for , and , are sent back to gdb for display through a pipe connected to gdbserver. Both and use the same pipe.\n\nOn some targets, can also attach to running programs. This is accomplished via the argument. The syntax is:\n\nis the process ID of a currently running process. It isn’t necessary to point at a binary for the running process.\n\nIn mode, you can also attach using the GDB attach command (see Attaching in Types of Remote Connections).\n\nYou can debug processes by name instead of process ID if your target has the utility:\n\nIn case more than one copy of is running, or has multiple threads, most versions of support the option to only return the first process ID.\n\nThis section applies only when is run to listen on a TCP port.\n\nnormally terminates after all of its debugged processes have terminated in mode. On the other hand, for , stays running even with no processes left. GDB normally terminates the spawned debugged process on its exit, which normally also terminates in the mode. Therefore, when the connection drops unexpectedly, and GDB cannot ask to kill its debugged processes, stays running even in the mode.\n\nWhen stays running, GDB can connect to it again later. Such reconnecting is useful for features like disconnected tracing. For completeness, at most one GDB can be connected at a time.\n\nBy default, keeps the listening TCP port open, so that subsequent connections are possible. However, if you start with the option, it will stop listening for any further connection attempts after connecting to the first GDB session. This means no further connections to will be possible after the first one. It also means will terminate after the first connection with remote GDB has closed, even for unexpectedly closed connections and even in the mode. The option allows reusing the same port number for connecting to multiple instances of running on the same host, since each instance closes its port after the first connection.\n\nYou can use the option to start without specifying a program to debug or a process to attach to. Then you can attach in mode and run or attach to a program. For more information, see --multi Option in Types of Remote Connections.\n\nThe option tells to display extra diagnostic information about the debugging process. The options ( , , etc) control for which areas of additional information will be displayed, possible values are:\n\nIf no options are passed to then this is treated as equivalent to . This could change in future releases of . The options passed to are processed left to right, and individual options can be prefixed with the (minus) character to disable diagnostic output from this area, so it is possible to use:\n\nIn order to enable all diagnostic output except that for the event-loop.\n\nThe option tells to write any debug output to the given . These options are intended for development and for bug reports to the developers.\n\nThe option tells to include additional information in each output. Possible options are:\n\nOptions are processed in order. Thus, for example, if appears last then no additional information is added to debugging output.\n\nThe option specifies a wrapper to launch programs for debugging. The option should be followed by the name of the wrapper, then any command-line arguments to pass to the wrapper, then indicating the end of the wrapper arguments.\n\nruns the specified wrapper program with a combined command line including the wrapper arguments, then the name of the program to debug, then any arguments to the program. The wrapper runs until it executes your program, and then GDB gains control.\n\nYou can use any program that eventually calls with its arguments as a wrapper. Several standard Unix utilities do this, e.g. and . Any Unix shell script ending with will also work.\n\nFor example, you can use to pass an environment variable to the debugged program, without setting the variable in ’s environment:\n\nThe option runs the self tests in :\n\nThese tests are disabled in release.\n\nThe basic procedure for connecting to the remote target is:\n• Make sure you have the necessary symbol files (see Host and target files). Load symbols for your application using the command before you connect. Use to locate target libraries (unless your GDB was compiled with the correct sysroot using ).\n• Connect to your target (see Connecting to a Remote Target). For TCP connections, you must start up prior to using the command. Otherwise you may get an error whose text depends on the host system, but which usually looks something like ‘ ’. Don’t use the command in GDB when using mode, since the program is already on the target.\n\nDuring a GDB session using , you can use the command to send special requests to . Here are the available commands.\n\nOn some targets, supports tracepoints and fast tracepoints.\n\nFor fast tracepoints to work, a special library called the in-process agent (IPA), must be loaded in the inferior process. This library is built and distributed as an integral part of .\n\nThere are several ways to load the in-process agent in your program:\n\nOn systems that have a userspace dynamic loader, like most Unix systems, when you connect to using , you’ll find that the program is stopped at the dynamic loader’s entry point, and no shared library has been loaded in the program’s address space yet, including the in-process agent. In that case, before being able to use any of the fast or static tracepoints features, you need to let the loader run and load the shared libraries. The simplest way to do that is to run the program to the main procedure. E.g., if debugging a C or C program, start like so:\n\nStart GDB and connect to like so, and run to main:\n\nThe in-process tracing agent library should now be loaded into the process; you can confirm it with the command, which will list as loaded in the process. You are now ready to install fast tracepoints, list static tracepoint markers, probe static tracepoints markers, and start tracing.\n\nThis section documents the configuration options available when debugging remote programs. For the options related to the File I/O extensions of the remote protocol, see system-call-allowed.\n\nThe GDB remote protocol autodetects the packets supported by your debugging stub. If you need to override the autodetection, you can use these commands to enable or disable individual packets. Each packet can be set to ‘ ’ (the remote target supports this packet), ‘ ’ (the remote target does not support this packet), or ‘ ’ (detect remote target support for this packet). They all default to ‘ ’. For more information about each packet, see Remote Protocol.\n\nDuring normal use, you should not have to use any of these commands. If you do, that may be a bug in your remote debugging stub, or a bug in GDB. You may want to report the problem to the GDB developers.\n\nFor each packet , the command to enable or disable the packet is . If you configure a packet, the configuration will apply for all future remote targets if no target is selected. In case there is a target selected, only the configuration of the current target is changed. All other existing remote targets’ features are not affected. The command to print the current configuration of a packet is . It displays the current remote target’s configuration. If no remote target is selected, the default configuration for future connections is shown. The available settings are:\n\nThe number of bytes per memory-read or memory-write packet for a remote target can be configured using the commands and . If set to ‘ ’ (zero) the default packet size will be used. The actual limit is further reduced depending on the target. Specify ‘ ’ to disable the target-dependent restriction and ‘ ’ to enable it. Similar to the enabling and disabling of remote packets, the command applies to the currently selected target (if available). If no remote target is selected, it applies to all future remote connections. The configuration of the selected target can be displayed using the commands and . If no remote target is selected, the default configuration for future connections is shown.\n\nThe stub files provided with GDB implement the target side of the communication protocol, and the GDB side is implemented in the GDB source file . Normally, you can simply allow these subroutines to communicate, and ignore the details. (If you’re implementing your own stub file, you can still ignore the details: start with one of the existing stub files. is the best organized, and therefore the easiest to read.)\n\nTo debug a program running on another machine (the debugging target machine), you must first arrange for all the usual prerequisites for the program to run by itself. For example, for a C program, you need:\n• A startup routine to set up the C runtime environment; these usually have a name like . The startup routine may be supplied by your hardware supplier, or you may have to write your own.\n• A C subroutine library to support your program’s subroutine calls, notably managing input and output.\n• A way of getting your program to the other machine—for example, a download program. These are often supplied by the hardware manufacturer, but you may have to write your own from hardware documentation.\n\nThe next step is to arrange for your program to use a serial port to communicate with the machine where GDB is running (the host machine). In general terms, the scheme looks like this:\n\nThe debugging stub is specific to the architecture of the remote machine; for example, use to debug programs on SPARC boards.\n\nThese working remote stubs are distributed with GDB:\n\nThe file in the GDB distribution may list other recently added stubs.\n\n20.5.1 What the Stub Can Do for You\n\nThe debugging stub for your architecture supplies these three subroutines:\n\n20.5.2 What You Must Do for the Stub\n\nThe debugging stubs that come with GDB are set up for a particular chip architecture, but they have no information about the rest of your debugging target machine.\n\nFirst of all you need to tell the stub how to communicate with the serial port.\n\nIf you want GDB to be able to stop your program while it is running, you need to use an interrupt-driven serial driver, and arrange for it to stop when it receives a (‘ ’, the control-C character). That is the character which GDB uses to tell the remote system to stop.\n\nGetting the debugging target to return the proper status to GDB probably requires changes to the standard stub; one quick and dirty way is to just execute a breakpoint instruction (the “dirty” part is that GDB reports a instead of a ).\n\nOther routines you need to supply are:\n\nYou must also make sure this library routine is available:\n\nIf you do not use the GNU C compiler, you may need other standard library subroutines as well; this varies from one stub to another, but in general the stubs are likely to use any of the common library subroutines which generates as inline code.\n\n20.5.3 Putting it All Together\n\nIn summary, when your program is ready to debug, you must follow these steps.\n• Make sure you have defined the supporting low-level routines (see What You Must Do for the Stub):\n• Insert these lines in your program’s startup code, before the main procedure is called: On some machines, when a breakpoint trap is raised, the hardware automatically makes the PC point to the instruction after the breakpoint. If your machine doesn’t do that, you may need to adjust to arrange for it to return to the instruction after the breakpoint on this first invocation, so that your program doesn’t keep hitting the initial breakpoint instead of making progress.\n• For the 680x0 stub only, you need to provide a variable called . Normally you just use: but if before calling , you set it to point to a function in your program, that function is called when continues after stopping on a trap (for example, bus error). The function indicated by is called with one parameter: an which is the exception number.\n• Compile and link together: your program, the GDB debugging stub for your target architecture, and the supporting subroutines.\n• Make sure you have a serial connection between your target machine and the GDB host, and identify the serial port on the host.\n• Download your program to your target machine (or get it there by whatever means the manufacturer provides), and start it.\n• Start GDB on the host, and connect to the target (see Connecting to a Remote Target).\n\nWhile nearly all GDB commands are available for all native and cross versions of the debugger, there are some exceptions. This chapter describes things that are only available in certain configurations.\n\nThere are three major categories of configurations: native configurations, where the host and target are the same, embedded operating system configurations, which are usually the same for several different processor architectures, and bare embedded processors, which are quite different from each other.\n\nThis section describes details specific to particular native configurations.\n\nBSD-derived systems (FreeBSD/NetBSD/OpenBSD) have a kernel memory interface that provides a uniform interface for accessing kernel virtual memory images, including live systems and crash dumps. GDB uses this interface to allow you to debug live kernels and kernel crash dumps on many native BSD configurations. This is implemented as a special debugging target. For debugging a live system, load the currently running kernel into GDB and connect to the target:\n\nFor debugging crash dumps, provide the file name of the crash dump as an argument:\n\nOnce connected to the target, the following commands are available:\n\nSome operating systems provide interfaces to fetch additional information about running processes beyond memory and per-thread register state. If GDB is configured for an operating system with a supported interface, the command is available to report information about the process running your program, or about any process running on your system.\n\nOne supported interface is a facility called ‘ ’ that can be used to examine the image of a running process using file-system subroutines. This facility is supported on GNU/Linux and Solaris systems.\n\nOn FreeBSD and NetBSD systems, system control nodes are used to query process information.\n\nIn addition, some systems may provide additional process information in core files. Note that a core file may include a subset of the information available from a live process. Process information is currently available from cores created on GNU/Linux and FreeBSD systems.\n\nDJGPP is a port of the GNU development tools to MS-DOS and MS-Windows. DJGPP programs are 32-bit protected-mode programs that use the DPMI (DOS Protected-Mode Interface) API to run on top of real-mode DOS systems and their emulations.\n\nGDB supports native debugging of DJGPP programs, and defines a few commands specific to the DJGPP port. This subsection describes those commands.\n\nIn addition to native debugging, the DJGPP port supports remote debugging via a serial data link. The following commands are specific to remote serial debugging in the DJGPP port of GDB.\n\nGDB supports native debugging of MS Windows programs, including DLLs with and without symbolic debugging information.\n\nMS-Windows programs that call to switch off the special meaning of the ‘ ’ keystroke cannot be interrupted by typing . For this reason, GDB on MS-Windows supports as an alternative interrupt key sequence, which can be used to interrupt the debuggee even if it ignores .\n\nThere are various additional Cygwin-specific commands, described in this section. Working with DLLs that have no debugging symbols is described in Non-debug DLL Symbols.\n\nVery often on windows, some of the DLLs that your program relies on do not include symbolic debugging information (for example, ). When GDB doesn’t recognize any debugging symbols in a DLL, it relies on the minimal amount of symbolic information contained in the DLL’s export table. This section describes working with such symbols, known internally to GDB as “minimal symbols”.\n\nNote that before the debugged program has started execution, no DLLs will have been loaded. The easiest way around this problem is simply to start the program — either by setting a breakpoint or letting the program run once to completion.\n\nIn keeping with the naming conventions used by the Microsoft debugging tools, DLL export symbols are made available with a prefix based on the DLL name, for instance . The plain name is also entered into the symbol table, so is often sufficient. In some cases there will be name clashes within a program (particularly if the executable itself includes full debugging symbols) necessitating the use of the fully qualified name when referring to the contents of the DLL. Use single-quotes around the name to avoid the exclamation mark (“!”) being interpreted as a language operator.\n\nNote that the internal name of the DLL may be all upper-case, even though the file name of the DLL is lower-case, or vice-versa. Since symbols within GDB are case-sensitive this may cause some confusion. If in doubt, try the and commands or even (see Symbols). Here’s an example:\n\nSymbols extracted from a DLL’s export table do not contain very much type information. All that GDB can do is guess whether a symbol refers to a function or variable depending on the linker section that contains the symbol. Also note that the actual contents of the memory contained in a DLL are not available unless the program is running. This means that you cannot examine the contents of a variable or disassemble a function within a DLL without a running program.\n\nVariables are generally treated as pointers and dereferenced automatically. For this reason, it is often necessary to prefix a variable name with the address-of operator (“&”) and provide explicit type information in the command. Here’s an example of the type of problem:\n\nAnd two possible solutions:\n\nSetting a break point within a DLL is possible even before the program starts execution. However, under these circumstances, GDB can’t examine the initial instructions of the function in order to skip the function’s frame set-up code. You can work around this by using “*&” to set the breakpoint at a raw memory address:\n\nThe author of these extensions is not entirely convinced that setting a break point within a shared DLL like is completely safe.\n\nThis subsection describes GDB commands specific to the GNU Hurd native debugging.\n\nGDB provides the following commands specific to the Darwin target:\n\nWhen the ABI of a system call is changed in the FreeBSD kernel, this is implemented by leaving a compatibility system call using the old ABI at the existing number and allocating a new system call number for the version using the new ABI. As a convenience, when a system call is caught by name (see catch syscall), compatibility system calls are also caught.\n\nFor example, FreeBSD 12 introduced a new variant of the system call and catching the system call by name catches both variants:\n\nThis section describes configurations involving the debugging of embedded operating systems that are available for several different architectures.\n\nGDB includes the ability to debug programs running on various real-time operating systems.\n\nThis section goes into details specific to particular embedded configurations.\n\nWhenever a specific embedded processor has a simulator, GDB allows to send an arbitrary command to the simulator.\n\nGDB provides the following ARC-specific commands:\n\nGDB provides the following ARM-specific commands:\n\nThe MicroBlaze is a soft-core processor supported on various Xilinx FPGAs, such as Spartan or Virtex series. Boards with these processors usually have JTAG ports which connect to a host system running the Xilinx Embedded Development Kit (EDK) or Software Development Kit (SDK). This host system is used to download the configuration bitstream to the target FPGA. The Xilinx Microprocessor Debugger (XMD) program communicates with the target board using the JTAG interface and presents a interface to the board. By default uses port . (While it is possible to change this default port, it requires the use of undocumented commands. Contact Xilinx support if you need to do this.)\n\nUse these GDB commands to connect to the MicroBlaze target processor.\n\nThe OpenRISC 1000 provides a free RISC instruction set architecture. It is mainly provided as a soft-core which can run on Xilinx, Altera and other FPGA’s.\n\nGDB for OpenRISC supports the below commands when connecting to a target:\n\nGDB supports using the DVC (Data Value Compare) register to implement in hardware simple hardware watchpoint conditions of the form:\n\nThe DVC register will be automatically used when GDB detects such pattern in a condition expression, and the created watchpoint uses one debug register (either the option is on and the variable is scalar, or the variable has a length of one byte). This feature is available in native GDB running on a Linux kernel version 2.6.34 or newer.\n\nWhen running on PowerPC embedded processors, GDB automatically uses ranged hardware watchpoints, unless the option is on, in which case watchpoints using only one debug register are created when watching variables of scalar types.\n\nYou can create an artificial array to watch an arbitrary memory region using one of the following commands (see Expressions):\n\nPowerPC embedded processors support masked watchpoints. See the discussion about the argument in Set Watchpoints.\n\nPowerPC embedded processors support hardware accelerated ranged breakpoints. A ranged breakpoint stops execution of the inferior whenever it executes an instruction at any address within the range it was set at. To set a ranged breakpoint in GDB, use the command.\n\nGDB provides the following PowerPC-specific commands:\n\nWhen configured for debugging the Atmel AVR, GDB supports the following AVR-specific commands:\n\nWhen configured for debugging CRIS, GDB provides the following CRIS-specific commands:\n\nFor the Renesas Super-H processor, GDB provides these commands:\n\nThis section describes characteristics of architectures that affect all uses of GDB with the architecture, both native and cross.\n\nWhen GDB is debugging the AArch64 architecture, it provides the following special commands:\n\nWhen GDB is debugging the AArch64 architecture, if the Scalable Vector Extension (SVE) is present, then GDB will provide the vector registers through , vector predicate registers through , and the register. In addition, the pseudo register will be provided. This is the vector granule for the current thread and represents the number of 64-bit chunks in an SVE register.\n\nIf the vector length changes, then the register will be updated, but the lengths of the and registers will not change. This is a known limitation of GDB and does not affect the execution of the target process.\n\nFor SVE, the following definitions are used throughout GDB’s source code and in this document:\n• : The vector length, in bytes. It defines the size of each register.\n• : The number of 128 bit units in . This is mostly used internally by GDB and the Linux Kernel.\n• : The number of 64 bit units in . This is mostly used internally by GDB and the Linux Kernel.\n\nThe Scalable Matrix Extension ( ) is an AArch64 architecture extension that expands on the concept of the Scalable Vector Extension ( ) by providing a 2-dimensional register , which is a square matrix of variable size, just like SVE provides a group of vector registers of variable size.\n\nSimilarly to SVE, where the size of each register is directly related to the vector length ( for short), the matrix register’s size is directly related to the streaming vector length ( for short). See vl. See svl.\n\nThe register state can be either active or inactive, if it is not in use.\n\nalso introduces a new execution mode called streaming mode (streaming mode for short). When streaming mode is enabled, the program supports execution of instructions and the registers will have vector length . When streaming mode is disabled, the SVE registers have vector length .\n\nFor more information about and , please refer to official architecture documentation.\n\nThe following definitions are used throughout GDB’s source code and in this document:\n• : The streaming vector length, in bytes. It defines the size of each dimension of the 2-dimensional square matrix. The total size of is therefore by . When streaming mode is enabled, it defines the size of the registers as well.\n• : The number of 128 bit units in , also known as streaming vector granule. This is mostly used internally by GDB and the Linux Kernel.\n• : The number of 64 bit units in . This is mostly used internally by GDB and the Linux Kernel.\n\nWhen GDB is debugging the AArch64 architecture, if the Scalable Matrix Extension ( ) is present, then GDB will make the register available. GDB will also make the register and pseudo-register available.\n\nThe register is a 2-dimensional square by matrix of bytes. To simplify the representation and access to the register in GDB, it is defined as a vector of x bytes.\n\nIf the user wants to index the register as a matrix, it is possible to reference as , where is the row number and is the column number.\n\nThe register always contains the streaming vector granule ( ) for the current thread. From the value of register we can easily derive the value.\n\nThe pseudo-register (streaming vector control register) is a status register that holds two state bits: SM in bit 0 and ZA in bit 1.\n\nIf the SM bit is 1, it means the current thread is in streaming mode, and the registers will use for their sizes. If the SM bit is 0, the current thread is not in streaming mode, and the registers will use for their sizes. See vl.\n\nIf the ZA bit is 1, it means the register is being used and has meaningful contents. If the ZA bit is 0, the register is unavailable and its contents are undefined.\n\nFor convenience and simplicity, if the ZA bit is 0, the register and all of its pseudo-registers will read as zero.\n\nIf changes during the execution of a program, then the register size and the bits in the pseudo-register will be updated to reflect it.\n\nIt is possible for users to change during the execution of a program by modifying the register value.\n\nWhenever the register is modified with a new value, the following will be observed:\n• The ZA and SM bits will be cleared in the pseudo-register.\n• The register will have a new size and its state will be cleared, forcing its contents and the contents of all of its pseudo-registers back to zero.\n• If the SM bit was 1, the registers will be reset to having their sizes based on as opposed to . If the SM bit was 0 prior to modifying the register, there will be no observable effect on the registers.\n\nThe possible values for the register are 2, 4, 8, 16, 32. These numbers correspond to streaming vector length ( ) values of 16 bytes, 32 bytes, 64 bytes, 128 bytes and 256 bytes respectively.\n\nThe minimum size of the register is 16 x 16 (256) bytes, and the maximum size is 256 x 256 (65536) bytes. In streaming mode, with bit SM set, the size of the register is the size of all the SVE registers combined.\n\nThe register can also be accessed using tiles and tile slices.\n\nTile pseudo-registers are square, 2-dimensional sub-arrays of elements within the register.\n\nThe tile pseudo-registers have the following naming pattern: .\n\nThere is a total of 31 tile pseudo-registers. They are , through , through , through and through .\n\nTile slice pseudo-registers are vectors of horizontally or vertically contiguous elements within the register.\n\nThe tile slice pseudo-registers have the following naming pattern: .\n\nThere are up to 16 tiles (0 ~ 15), the direction can be either (vertical) or (horizontal), the qualifiers can be (byte), (halfword), (word), (doubleword) and (quadword) and there are up to 256 slices (0 ~ 255) depending on the value of . The number of slices is the same as the value of .\n\nThe number of available tile slice pseudo-registers can be large. For a minimum of 16 bytes, there are 5 (number of qualifiers) x 2 (number of directions) x 16 ( ) pseudo-registers. For the maximum of 256 bytes, there are 5 x 2 x 256 pseudo-registers.\n\nWhen listing all the available registers, users will see the currently-available pseudo-registers. Pseudo-registers that don’t exist for a given value will not be displayed.\n\nFor more information on and its terminology, please refer to the Arm Architecture Reference Manual Supplement, The Scalable Matrix Extension ( ), for Armv9-A.\n\nSome features are still under development and rely on ACLE and ABI definitions, so there are known limitations to the current support in GDB.\n\nOne such example is calling functions in the program being debugged by GDB. Such calls are not -aware and thus don’t take into account the pseudo-register bits nor the register contents. See Calling.\n\nThe lazy saving scheme involving the register is not yet supported by GDB, though the register is known and supported by GDB.\n\nLastly, an important limitation for is its inability to communicate changes to GDB. This means , even though it is capable of adjusting its internal caches to reflect a change in the value of mid-execution, will operate with a potentially different value compared to GDB. This can lead to GDB showing incorrect values for the register and incorrect values for SVE registers (when in streaming mode).\n\nThis is the same limitation we have for the registers, and there are plans to address this limitation going forward.\n\nThe Scalable Matrix Extension 2 is an AArch64 architecture extension that further expands the extension with the following:\n• The ability to address the array through groups of one-dimensional array vectors, as opposed to tiles with 2 dimensions.\n• Instructions to operate on groups of registers and array vectors.\n\nWhen GDB is debugging the AArch64 architecture, if the Scalable Matrix Extension 2 ( ) is present, then GDB will make the register available.\n\nThe register is only considered active when the register state is active, therefore when the ZA bit of the is 1.\n\nWhen the ZA bit of is 0, that means the register state is not active, which means the register state is also not active.\n\nWhen is not active, it is comprised of zeroes, just like .\n\nSimilarly to the register, if the state is not active and the user attempts to modify its value such that any of its bytes is non-zero, then GDB will initialize the register state as well, which means the ZA bit gets set to 1.\n\nFor more information about , please refer to the official architecture documentation.\n\nWhen GDB is debugging the AArch64 architecture, and the program is using the v8.3-A feature Pointer Authentication (PAC), then whenever the link register is pointing to an PAC function its value will be masked. When GDB prints a backtrace, any addresses that required unmasking will be postfixed with the marker [PAC]. When using the MI, this is printed as part of the field.\n\nWhen GDB is debugging the AArch64 architecture, the program is using the v8.5-A feature Memory Tagging Extension (MTE) and there is support in the kernel for MTE, GDB will make memory tagging functionality available for inspection and editing of logical and allocation tags. See Memory Tagging.\n\nTo aid debugging, GDB will output additional information when SIGSEGV signals are generated as a result of memory tag failures.\n\nIf the tag violation is synchronous, the following will be shown:\n\nIf the tag violation is asynchronous, the fault address is not available. In this case GDB will show the following:\n\nA special register, , is made available through the feature. This register exposes some options that can be controlled at runtime and emulates the option . For further information, see the documentation in the Linux kernel.\n\nGDB supports dumping memory tag data to core files through the command and reading memory tag data from core files generated by the command or the Linux kernel.\n\nWhen a process uses memory-mapped pages protected by memory tags (for example, AArch64 MTE), this additional information will be recorded in the core file in the event of a crash or if GDB generates a core file from the current process state.\n\nThe memory tag data will be used so developers can display the memory tags from a particular memory region (using the ‘ ’ modifier to the command, using the command or using the various subcommands.\n\nIn the case of a crash, GDB will attempt to retrieve the memory tag information automatically from the core file, and will show one of the above messages depending on whether the synchronous or asynchronous mode is selected. See Memory Tagging. See Memory.\n\nGDB provides access to the x87 state through the following registers:\n\nSee the following section.\n\nAlpha- and -based computers use an unusual stack frame, which sometimes requires GDB to search backward in the object code to find the beginning of a function.\n\nTo improve response time (especially for embedded applications, where GDB may be restricted to a slow serial line for this search) you may want to limit the size of this search, using one of these commands:\n\nThese commands are available only when GDB is configured for debugging programs on Alpha or processors.\n\nSeveral -specific commands are available when debugging programs:\n\nWhen GDB is debugging the HP PA architecture, it provides the following special commands:\n\nWhen GDB is debugging the PowerPC architecture, it provides a set of pseudo-registers to enable inspection of 128-bit wide Decimal Floating Point numbers stored in the floating point registers. These values must be stored in two consecutive registers, always starting at an even register like or .\n\nThe pseudo-registers go from through , and are formed by joining the even/odd register pairs and for , and for and so on.\n\nFor POWER7 processors, GDB provides a set of pseudo-registers, the 64-bit wide Extended Floating Point Registers (‘ ’ through ‘ ’).\n\nThe M7 processor supports an Application Data Integrity (ADI) feature that detects invalid data accesses. When software allocates memory and enables ADI on the allocated memory, it chooses a 4-bit version number, sets the version in the upper 4 bits of the 64-bit pointer to that data, and stores the 4-bit version in every cacheline of that data. Hardware saves the latter in spare bits in the cache and memory hierarchy. On each load and store, the processor compares the upper 4 VA (virtual address) bits to the cacheline’s version. If there is a mismatch, the processor generates a version mismatch trap which can be either precise or disrupting. The trap is an error condition which the kernel delivers to the process as a SIGSEGV signal.\n\nNote that only 64-bit applications can use ADI and need to be built with ADI-enabled.\n\nValues of the ADI version tags, which are in granularity of a cacheline (64 bytes), can be viewed or modified.\n\nWhen GDB is debugging the S12Z architecture, it provides the following special command:\n\nGDB supports debugging programs offloaded to devices using the platform. GDB presents host threads alongside GPU wavefronts, allowing debugging both the host and device parts of the program simultaneously.\n\nThe list of architectures supported by GDB depends on the version of the AMD Debugger API library used. See its documentation for more details.\n\nGDB requires a compatible device driver to be installed. A warning message is displayed if either the device driver version or the version of the debug support it implements is unsupported. GDB will continue to function except no debugging will be possible.\n\nGDB requires each agent to have compatible firmware installed by the device driver. A warning message is displayed if unsupported firmware is detected. GDB will continue to function except no debugging will be possible on the agent.\n\nGDB requires a compatible runtime to be loaded in order to detect code objects and wavefronts. A warning message is displayed if an unsupported runtime is detected, or there is an error or restriction that prevents debugging. GDB will continue to function except no debugging will be possible.\n\nAn wavefront is represented in GDB as a thread.\n\nNote that some architectures may have restrictions on providing information about wavefronts created when GDB is not attached (see Attaching Restrictions).\n\nWhen scheduler-locking is in effect (see set scheduler-locking), new wavefronts created by the resumed thread (either CPU thread or GPU wavefront) are held in the halt state.\n\nThe ‘ ’ command will show the code objects as file or memory URIs, together with the host’s shared libraries. For example:\n\nFor a ‘ ’ URI, the path portion is the file on disk containing the code object. The parameter is a 0-based offset in this file, to the start of the code object. If omitted, it defaults to 0. The parameter is the size of the code object in bytes. If omitted, it defaults to the size of the file.\n\nFor a ‘ ’ URI, the path portion is the process id of the process owning the memory containing the code object. The parameter is the memory address where the code object is found, and the parameter is its size in bytes.\n\ncode objects are loaded into each device separately. The ‘ ’ command may therefore show the same code object loaded multiple times. As a consequence, setting a breakpoint in code will result in multiple breakpoint locations if there are multiple devices.\n\nThe entities have the following target identifier formats:\n\nFor wavefronts, GDB maps target conditions to stop signals in the following way:\n\nIf a single instruction raises more than one signal, they will be reported one at a time each time the wavefront is continued.\n\nA wavefront can report memory violation events. However, the program location at which they are reported may be after the machine instruction that caused them. This can result in the reported source statement being incorrect. The following commands can be used to control this behavior:\n\nThe ‘ ’ command can be used to enable diagnostic messages in the ‘ ’ target. The ‘ ’ command displays the current setting. See set debug amd-dbgapi.\n\nThe ‘ ’ command can be used to enable diagnostic messages from the ‘ ’ library (which GDB uses under the hood). The ‘ ’ command displays the current ‘ ’ library log level. See set debug amd-dbgapi-lib.\n• When in non-stop mode, wavefronts may not hit breakpoints inserted while not stopped, nor see memory updates made while not stopped, until the wavefront is next stopped. Memory updated by non-stopped wavefronts may not be visible until the wavefront is next stopped.\n• The HIP runtime performs deferred code object loading by default. code objects are not loaded until the first kernel is launched. Before then, all breakpoints have to be set as pending breakpoints. If source line positions are used that only correspond to source lines in unloaded code objects, then GDB may not set pending breakpoints, and instead set breakpoints on the next following source line that maps to host code. This can result in unexpected breakpoint hits being reported. When the code object containing the source lines is loaded, the incorrect breakpoints will be removed and replaced by the correct ones. This problem can be avoided by only setting breakpoints in unloaded code objects using symbol or function names. Setting the environment variable to can be used to disable deferred code object loading by the HIP runtime. This ensures all code objects will be loaded when the inferior reaches the beginning of the function.\n• If no CPU thread is running, then ‘ ’ is not able to stop threads. This can happen for example if you enable after the whole program stopped, and then resume an thread. The only way to unblock the situation is to kill the GDB process.\n• By default, for some architectures, the device driver causes all wavefronts created when GDB is not attached to be unable to report the dispatch associated with the wavefront, or the wavefront’s work-group position. The ‘ ’ command will display this missing information with a ‘ ’. This does not affect wavefronts created while GDB is attached which are always capable of reporting this information. If the environment variable is set to ‘ ’ when the runtime is initialized, then this information will be available for all architectures even for wavefronts created when GDB was not attached.\n\nWhen GDB is debugging a RISC-V architecture, it provides the following special commands:\n\nYou can alter the way GDB interacts with you by using the command. For commands controlling how GDB displays data, see Print Settings. Other settings are described here.\n\nGDB indicates its readiness to read a command by printing a string called the prompt. This string is normally ‘ ’. You can change the prompt string with the command. For instance, when debugging GDB with GDB, it is useful to change the prompt in one of the GDB sessions so that you can always tell which one you are talking to.\n\nNote: does not add a space for you after the prompt you set. This allows you to set a prompt which ends in a space or a prompt that does not.\n\nVersions of GDB that ship with Python scripting enabled have prompt extensions. The commands for interacting with these extensions are:\n\nGDB reads its input commands via the Readline interface. This GNU library provides consistent behavior for programs which provide a command line interface to the user. Advantages are GNU Emacs-style or vi-style inline editing of commands, -like history substitution, and a storage and recall of command history across debugging sessions.\n\nYou may control the behavior of command line editing in GDB with the command .\n\nSee Command Line Editing, for more details about the Readline interface. Users unfamiliar with GNU Emacs or are encouraged to read that chapter.\n\nGDB sets the Readline application name to ‘ ’. This is useful for conditions in .\n\nGDB defines a bindable Readline command, . This is bound to by default. This command accepts the current line for execution and fetches the next line relative to the current line from the history for editing. Any argument is ignored.\n\nIt is possible to discover which version of Readline GDB is using with the command (see show configuration).\n\nGDB can keep track of the commands you type during your debugging sessions, so that you can be certain of precisely what happened. Use these commands to manage the GDB command history facility.\n\nGDB uses the GNU History library, a part of the Readline package, to provide the history facility. See Using History Interactively, for the detailed description of the History library.\n\nTo issue a command to GDB without affecting certain aspects of the state which is seen by users, prefix it with ‘ ’ (see Server Prefix). This means that this command will not affect the command history, nor will it affect GDB’s notion of which command to repeat if is pressed on a line by itself.\n\nThe server prefix does not affect the recording of values into the value history; to print a value without recording it into the value history, use the command instead of the command.\n\nHere is the description of GDB commands related to command history.\n\nHistory expansion assigns special meaning to the character . See Event Designators, for more details.\n\nSince is also the logical not operator in C, history expansion is off by default. If you decide to enable history expansion with the command, you may sometimes need to follow (when it is used as logical not, in an expression) with a space or a tab to prevent it from being expanded. The readline history facilities do not attempt substitution on the strings and , even when history expansion is enabled.\n\nThe commands to control history expansion are:\n\nCertain commands to GDB may produce large amounts of information output to the screen. To help you read all of it, GDB pauses and asks you for input at the end of each page of output. Type when you want to see one more page of output, to discard the remaining output, or to continue without paging for the rest of the current command. Also, the screen width setting determines when to wrap lines of output. Depending on what is being printed, GDB tries to break the line at a readable place, rather than simply letting it overflow onto the following line.\n\nNormally GDB knows the size of the screen from the terminal driver software. For example, on Unix GDB uses the termcap data base together with the value of the environment variable and the and settings. If this is not correct, you can override it with the and commands:\n\nGDB can style its output on a capable terminal. This is enabled by default on most systems, but disabled by default when in batch mode (see Mode Options). Various style settings are available; and styles can also be disabled entirely.\n\nSubcommands of control specific forms of styling. These subcommands all follow the same pattern: each style-able object can be styled with a foreground color, a background color, and an intensity.\n\nFor example, the style of file names can be controlled using the group of commands:\n\nThe command and its subcommands are styling a style name in their output using its own style. So, use to see the complete list of styles, their characteristics and the visual aspect of each style.\n\nYou can always enter numbers in octal, decimal, or hexadecimal in GDB by the usual conventions: octal numbers begin with ‘ ’, decimal numbers end with ‘ ’, and hexadecimal numbers begin with ‘ ’. Numbers that neither begin with ‘ ’ or ‘ ’, nor end with a ‘ ’ are, by default, entered in base 10; likewise, the default display for numbers—when no particular format is specified—is base 10. You can change the default base for both input and output with the commands described below.\n\nGDB can determine the ABI (Application Binary Interface) of your application automatically. However, sometimes you need to override its conclusions. Use these commands to manage GDB’s view of the current ABI.\n\nOne GDB configuration can debug binaries for multiple operating system targets, either via remote debugging or native emulation. GDB will autodetect the OS ABI (Operating System ABI) in use, but you can override its conclusion using the command. One example where this is useful is in debugging of binaries which use an alternate C library (e.g. UCLIBC for GNU/Linux) which does not have the same identifying marks that the standard C library for your platform provides.\n\nWhen GDB is debugging the AArch64 architecture, it provides a “Newlib” OS ABI. This is useful for handling and when debugging binaries that use the NEWLIB C library. The “Newlib” OS ABI can be selected by .\n\nGenerally, the way that an argument of type is passed to a function depends on whether the function is prototyped. For a prototyped (i.e. ANSI/ISO style) function, arguments are passed unchanged, according to the architecture’s convention for . For unprototyped (i.e. K&R style) functions, arguments are first promoted to type and then passed.\n\nUnfortunately, some forms of debug information do not reliably indicate whether a function is prototyped. If GDB calls a function that is not marked as prototyped, it consults .\n\nGDB needs to know the ABI used for your program’s C objects. The correct C ABI depends on which C compiler was used to build your application. GDB only fully supports programs with a single C ABI; if your program contains code using multiple C ABI’s or if GDB can not identify your program’s ABI correctly, you can tell GDB which ABI to use. Currently supported ABI’s include “gnu-v2”, for versions before 3.0, “gnu-v3”, for versions 3.0 and later, and “hpaCC” for the HP ANSI C compiler. Other C compilers may use the “gnu-v2” or “gnu-v3” ABI’s as well. The default setting is “auto”.\n\nGDB sometimes reads files with commands and settings automatically, without being explicitly told so by the user. We call this feature auto-loading. While auto-loading is useful for automatically adapting GDB to the needs of your project, it can sometimes produce unexpected results or introduce security risks (e.g., if the file comes from untrusted sources).\n\nThere are various kinds of files GDB can automatically load. In addition to these files, GDB supports auto-loading code written in various extension languages. See Auto-loading extensions.\n\nNote that loading of these associated files (including the local file) requires accordingly configured (see Auto-loading safe path).\n\nFor these reasons, GDB includes commands and options to let you control when to auto-load files and which files should be auto-loaded.\n\nThese are GDB control commands for the auto-loading:\n\nBy default, GDB reads and executes the canned sequences of commands from init file (if any) in the current working directory, see Init File in the Current Directory during Startup.\n\nNote that loading of this local file also requires accordingly configured (see Auto-loading safe path).\n\nThis feature is currently present only on GNU/Linux native hosts.\n\nGDB reads in some cases thread debugging library from places specific to the inferior (see set libthread-db-search-path).\n\nThe special ‘ ’ entry ‘ ’ is processed without checking this ‘ ’ switch as system libraries have to be trusted in general. In all other cases of ‘ ’ entries GDB checks first if ‘ ’ is enabled before trying to open such thread debugging library.\n\nNote that loading of this debugging library also requires accordingly configured (see Auto-loading safe path).\n\nAs the files of inferior can come from untrusted source (such as submitted by an application user) GDB does not always load any files automatically. GDB provides the ‘ ’ setting to list directories trusted for loading files not explicitly requested by user. Each directory can also be a shell wildcard pattern.\n\nIf the path is not set properly you will see a warning and the file will not get loaded:\n\nTo instruct GDB to go ahead and use the init files anyway, invoke GDB like this:\n\nThe list of trusted directories is controlled by the following commands:\n\nThis variable defaults to what has been configured to (see with-auto-load-dir). and substitution applies the same as for set auto-load scripts-directory. The default value can be also overridden by GDB configuration option .\n\nSetting this variable to disables this security protection, corresponding GDB configuration option is . This variable is supposed to be set to the system directories writable by the system superuser only. Users can add their source directories in init files in their home directories (see Home Directory Init File). See also deprecated init file in the current directory (see Init File in the Current Directory during Startup).\n\nTo force GDB to load the files it declined to load in the previous example, you could use one of the following ways:\n\nOn the other hand you can also explicitly forbid automatic files loading which also suppresses any such warning messages:\n\nThis setting applies to the file names as entered by user. If no entry matches GDB tries as a last resort to also resolve all the file names into their canonical form (typically resolving symbolic links) and compare the entries again. GDB already canonicalizes most of the filenames on its own before starting the comparison so a canonical form of directories is recommended to be entered.\n\nFor better visibility of all the file locations where you can place scripts to be auto-loaded with inferior — or to protect yourself against accidental execution of untrusted scripts — GDB provides a feature for printing all the files attempted to be loaded. Both existing and non-existing files may be printed.\n\nFor example the list of directories from which it is safe to auto-load files (see Auto-loading safe path) applies also to canonicalized filenames which may not be too obvious while setting it up.\n\nBy default, GDB is silent about its inner workings. If you are running on a slow machine, you may want to use the command. This makes GDB tell you when it does a lengthy internal operation, so you will not think it has crashed.\n\nCurrently, the messages controlled by are those which announce that the symbol table for a source file is being read; see in Commands to Specify Files.\n\nBy default, if GDB encounters bugs in the symbol table of an object file, it is silent; but if you are debugging a compiler, you may find this information useful (see Errors Reading Symbol Files).\n\nBy default, GDB is cautious, and asks what sometimes seems to be a lot of stupid questions to confirm certain commands. For example, if you try to run a program which is already running:\n\nIf you are willing to unflinchingly face the consequences of your own commands, you can disable this “feature”:\n\nIf you need to debug user-defined commands or sourced files you may find it useful to enable command tracing. In this mode each command will be printed as it is executed, prefixed with one or more ‘ ’ symbols, the quantity denoting the call depth of each command.\n\nGDB has commands that enable optional debugging messages from various GDB subsystems; normally these commands are of interest to GDB maintainers, or when reporting a bug. This section documents those commands.\n\nGDB provides several mechanisms for extension. GDB also provides the ability to automatically load extensions when it reads a file for debugging. This allows the user to automatically customize GDB for the program being debugged.\n\nTo facilitate the use of extension languages, GDB is capable of evaluating the contents of a file. When doing so, GDB can recognize which extension language is being used by looking at the filename extension. Files with an unrecognized filename extension are always treated as a GDB Command Files. See Command files.\n\nYou can control how GDB evaluates these files with the following setting:\n\nAside from breakpoint commands (see Breakpoint Command Lists), GDB provides two ways to store sequences of commands for execution as a unit: user-defined commands and command files.\n\nA user-defined command is a sequence of GDB commands to which you assign a new name as a command. This is done with the command.\n\nUser commands may accept an unlimited number of arguments separated by whitespace. Arguments are accessed within the user command via . The arguments are text substitutions, so they may reference variables, use complex expressions, or even perform inferior functions calls. Note, however, that this textual substitution means that working with certain arguments is difficult. For example, there is no way for the user to pass an argument containing a space; and while stringifying an argument can be done using an expression like , this will fail if the argument contains a quote. For more complicated and robust commands, we recommend writing them in Python; see CLI Commands In Python.\n\nTo execute the command use:\n\nThis defines the command , which prints the sum of its three arguments.\n\nIn addition, may be used to find out how many arguments have been passed.\n\nCombining with the command (see eval) makes it easier to process a variable number of arguments:\n\nIn addition to the above commands, user-defined commands frequently use control flow commands, described in Command Files.\n\nWhen user-defined commands are executed, the commands of the definition are not printed. An error in any command stops execution of the user-defined command.\n\nIf used interactively, commands that would ask for confirmation proceed without asking when used inside a user-defined command. Many GDB commands that normally print messages to say what they are doing omit the messages when used in a user-defined command.\n\nYou may define hooks, which are a special kind of user-defined command. Whenever you run the command ‘ ’, if the user-defined command ‘ ’ exists, it is executed (with no arguments) before that command.\n\nA hook may also be defined which is run after the command you executed. Whenever you run the command ‘ ’, if the user-defined command ‘ ’ exists, it is executed (with no arguments) after that command. Post-execution hooks may exist simultaneously with pre-execution hooks, for the same command.\n\nIt is valid for a hook to call the command which it hooks. If this occurs, the hook is not re-executed, thereby avoiding infinite recursion.\n\nIn addition, a pseudo-command, ‘ ’ exists. Defining (‘ ’) makes the associated commands execute every time execution stops in your program: before breakpoint commands are run, displays are printed, or the stack frame is printed.\n\nFor example, to ignore signals while single-stepping, but treat them normally during normal execution, you could define:\n\nAs a further example, to hook at the beginning and end of the command, and to add extra text to the beginning and end of the message, you could define:\n\nYou can define a hook for any single-word command in GDB, but not for command aliases; you should define a hook for the basic command name, e.g. rather than . You can hook a multi-word command by adding or to the last word of the command, e.g. ‘ ’ to add a hook to ‘ ’.\n\nIf an error occurs during the execution of your hook, execution of GDB commands stops and GDB issues a prompt (before the command that you actually typed had a chance to run).\n\nIf you try to define a hook which does not match any known command, you get a warning from the command.\n\nA command file for GDB is a text file made of lines that are GDB commands. Comments (lines starting with ) may also be included. An empty line in a command file does nothing; it does not mean to repeat the last command, as it would from the terminal.\n\nYou can request the execution of a command file with the command. Note that the command is also used to evaluate scripts that are not Command Files. The exact behavior can be configured using the setting. See Extending GDB.\n\nThe lines in a command file are generally executed sequentially, unless the order of execution is changed by one of the flow-control commands described below. The commands are not printed as they are executed. An error in any command terminates execution of the command file and control is returned to the console.\n\nGDB first searches for in the current directory. If the file is not found there, and does not specify a directory, then GDB also looks for the file on the source search path (specified with the ‘ ’ command); except that is not searched because the compilation directory is not relevant to scripts.\n\nIf is specified, then GDB searches for on the search path even if specifies a directory. The search is done by appending to each element of the search path. So, for example, if is and the search path contains then GDB will look for the script . The search is also done if is an absolute path. For example, if is and the search path contains then GDB will look for the script . For DOS-like systems, if contains a drive specification, it is stripped before concatenation. For example, if is and the search path contains then GDB will look for the script .\n\nIf , for verbose mode, is given then GDB displays each command as it is executed. The option must be given before , and is interpreted as part of the filename anywhere else.\n\nCommands that would ask for confirmation if used interactively proceed without asking when used in a command file. Many GDB commands that normally print messages to say what they are doing omit the messages when called from command files.\n\nGDB also accepts command input from standard input. In this mode, normal output goes to standard output and error output goes to standard error. Errors in a command file supplied on standard input do not terminate execution of the command file—execution continues with the next command.\n\n(The syntax above will vary depending on the shell used.) This example will execute commands from the file . All output and errors would be directed to .\n\nSince commands stored on command files tend to be more general than commands typed interactively, they frequently need to deal with complicated situations, such as different or unexpected values of variables and symbols, changes in how the program being debugged is built, etc. GDB provides a set of flow-control commands to deal with these complexities. Using these commands, you can write complex scripts that loop over data structures, execute commands conditionally, etc.\n\nDuring the execution of a command file or a user-defined command, normal GDB output is suppressed; the only output that appears is what is explicitly printed by the commands in the definition. This section describes three commands useful for generating exactly the output you want.\n\nWhen a new object file is read (for example, due to the command, or because the inferior has loaded a shared library), GDB will look for the command file . See Auto-loading extensions.\n\nAuto-loading can be enabled or disabled, and the list of auto-loaded scripts can be printed.\n\nIf is supplied only canned sequences of commands scripts with matching names are printed.\n\nAliases allow you to define alternate spellings for existing commands. For example, if a new GDB command defined in Python (see Python) has a long name, it is handy to have an abbreviated version of it that involves less typing.\n\nGDB itself uses aliases. For example ‘ ’ is an alias of the ‘ ’ command even though it is otherwise an ambiguous abbreviation of other commands like ‘ ’ and ‘ ’.\n\nAliases are also used to provide shortened or more common versions of multi-word commands. For example, GDB provides the ‘ ’ alias of the ‘ ’ command.\n\nYou can define a new alias with the ‘ ’ command.\n\nspecifies the name of the new alias. Each word of must consist of letters, numbers, dashes and underscores.\n\nspecifies the name of an existing command that is being aliased.\n\ncan also be the name of an existing alias. In this case, cannot be an alias that has default arguments.\n\nThe ‘ ’ option specifies that the new alias is an abbreviation of the command. Abbreviations are not used in command completion.\n\nThe ‘ ’ option specifies the end of options, and is useful when begins with a dash.\n\nYou can specify for your alias. These will be automatically added before the alias arguments typed explicitly on the command line.\n\nFor example, the below defines an alias that shows all local variables and all frame arguments:\n\nFor more information about , see Default Arguments.\n\nHere is a simple example showing how to make an abbreviation of a command so that there is less to type. Suppose you were tired of typing ‘ ’, the current shortest unambiguous abbreviation of the ‘ ’ command and you wanted an even shorter version named ‘ ’. The following will accomplish this.\n\nNote that aliases are different from user-defined commands. With a user-defined command, you also need to write documentation for it with the ‘ ’ command. An alias automatically picks up the documentation of the existing command.\n\nHere is an example where we make ‘ ’ an abbreviation of ‘ ’ in the ‘ ’ command. This is to show that you can make an abbreviation of any part of a command.\n\nNote that if you are defining an alias of a ‘ ’ command, and you want to have an alias for the corresponding ‘ ’ command, then you need to define the latter separately.\n\nUnambiguously abbreviated commands are allowed in and , just as they are normally.\n\nFinally, here is an example showing the creation of a one word alias for a more complex command. This creates alias ‘ ’ of the command ‘ ’.\n\nYou can tell GDB to always prepend some default arguments to the list of arguments provided explicitly by the user when using a user-defined alias.\n\nIf you repeatedly use the same arguments or options for a command, you can define an alias for this command and tell GDB to automatically prepend these arguments or options to the list of arguments you type explicitly when using the alias17.\n\nFor example, if you often use the command specifying to work on the threads in ascending order and to continue in case it encounters an error, you can tell GDB to automatically prepend the and options by using:\n\nOnce you have defined this alias with its default args, any time you type the followed by , GDB will execute thread apply all -ascending -c some arguments .\n\nTo have even less to type, you can also define a one word alias:\n\nAs usual, unambiguous abbreviations can be used for and .\n\nThe different aliases of a command do not share their default args. For example, you define a new alias showing all possible information and another alias showing very limited information using:\n\nDefault args are not limited to the arguments and options of , but can specify nested commands if accepts such a nested command as argument. For example, the below defines that lists the frames having locals of a certain type, together with the matching local vars:\n\nThis is also very useful to define an alias for a set of nested commands to have a particular combination of temporary settings. For example, the below defines the alias that pretty prints an expression argument, with a maximum of 10 elements if the expression is a string or an array:\n\nThis defines the alias as being a sequence of 3 commands. The first part temporarily activates the setting , then launches the command that follows the separator . The command following the first part is also a command that temporarily changes the setting to 10, then launches the command that follows the second separator . The third part is the command the alias will launch, using the temporary values of the settings and the arguments explicitly given by the user. For more information about the command usage, see Command Settings.\n\nBy default, asking the help for an alias shows the documentation of the aliased command. When the alias is a set of nested commands, of an alias shows the documentation of the first command. This help is not particularly useful for an alias such as . For such an alias, it is useful to give a specific documentation using the command (see document).\n\nYou can extend GDB using the Python programming language. This feature is available only if GDB was configured using .\n\nPython scripts used by GDB should be installed in , where is the data directory as determined at GDB startup (see Data Files). This directory, known as the python directory, is automatically added to the Python Search Path in order to allow the Python interpreter to locate all scripts installed at this location.\n\nAdditionally, GDB commands and convenience functions which are written in Python and are located in the or directories are automatically imported when GDB starts.\n\nGDB provides two commands for accessing the Python interpreter, and one related setting:\n\nIt is also possible to execute a Python script from the GDB interpreter:\n\nThe following commands are intended to help debug GDB itself:\n\nYou can get quick online help for GDB’s Python API by issuing the command .\n\nFunctions and methods which have two or more optional arguments allow them to be specified using keyword syntax. This allows passing some optional arguments while skipping others. Example: .\n\nAt startup, GDB overrides Python’s and to print using GDB’s output-paging streams. A Python program which outputs to one of these streams may have its output interrupted by the user (see Screen Size). In this situation, a Python exception is thrown.\n\nSome care must be taken when writing Python code to run in GDB. Two things worth noting in particular:\n• GDB installs handlers for and . Python code must not override these, or even change the options using . If your program changes the handling of these signals, GDB will most likely stop working correctly. Note that it is unfortunately common for GUI toolkits to install a handler. When creating a new Python thread, you can use or to handle this correctly; see Threading in GDB.\n• GDB takes care to mark its internal file descriptors as close-on-exec. However, this cannot be done in a thread-safe way on all platforms. Your Python programs should be aware of this and should both create new file descriptors with the close-on-exec flag set and arrange to close unneeded file descriptors before starting a child process.\n\nGDB introduces a new Python module, named . All methods and classes added by GDB are placed in this module. GDB automatically s the module for use in all scripts evaluated by the command.\n\nSome types of the module come with a textual representation (accessible through the or functions). These are offered for debugging purposes only, expect them to change over time.\n\nGDB is not thread-safe. If your Python program uses multiple threads, you must be careful to only call GDB-specific functions in the GDB thread. GDB provides some functions to help with this.\n\nWhen executing the command, Python exceptions uncaught within the Python code are translated to calls to GDB error-reporting mechanism. If the command that called does not handle the error, GDB will terminate it and print an error message. Exactly what will be printed depends on (see Python Commands). Example:\n\nGDB errors that happen in GDB commands invoked by Python code are converted to Python exceptions. The type of the Python exception depends on the error.\n\nIn all cases, your exception handler will see the GDB error message as its value and the Python call stack backtrace at the Python statement closest to where the GDB error occurred as the traceback.\n\nWhen implementing GDB commands in Python via , or functions via , it is useful to be able to throw an exception that doesn’t cause a traceback to be printed. For example, the user may have invoked the command incorrectly. GDB provides a special exception class that can be used for this purpose.\n\nGDB provides values it obtains from the inferior program in an object of type . GDB uses this object for its internal bookkeeping of the inferior’s values, and for fetching values when necessary.\n\nInferior values that are simple scalars can be used directly in Python expressions that are valid for the value’s data type. Here’s an example for an integer or floating-point value :\n\nAs result of this, will also be a object whose values are of the same type as those of . Valid Python operations can also be performed on objects representing a or object. For such cases, the overloaded operator (if present), is used to perform the operation. For example, if and are objects representing instances of a which overloads the operator, then one can use the operator in their Python script as follows:\n\nThe result of the operation is also a object corresponding to the value returned by the overloaded operator. In general, overloaded operators are invoked for the following operations: (binary addition), (binary subtraction), (multiplication), , , , , , , .\n\nInferior values that are structures or instances of some class can be accessed using the Python dictionary syntax. For example, if is a instance holding a structure, you can access its element with:\n\nAgain, will also be a object. Structure elements can also be accessed by using objects as subscripts (see Types In Python, for more information on objects). For example, if is a object corresponding to element of the above structure, then can also be accessed as follows:\n\nIf a has array or pointer type, an integer index can be used to access elements.\n\nA that represents a function can be executed via inferior function call. Any arguments provided to the call must match the function’s prototype, and must be provided in the order specified by that prototype.\n\nFor example, is a instance representing a function that takes two integers as arguments. To execute this function, call it like so:\n\nAny values returned from a function call will be stored as a .\n\nThe following attributes are provided:\n\nThe following methods are provided:\n\nGDB represents types from the inferior using the class .\n\nThe following type-related functions are available in the module:\n\nInteger types can be found without looking them up by name. See Architectures In Python, for the method.\n\nIf the type is a structure or class type, or an enum type, the fields of that type can be accessed using the Python dictionary syntax. For example, if is a instance holding a structure type, you can access its field with:\n\nwill be a object; see below under the description of the method for a description of the class.\n\nAn instance of has the following attributes:\n\nThe following methods are provided:\n\nEach type has a code, which indicates what category this type falls into. The available type categories are represented by constants defined in the module:\n\nFurther support for types is provided in the Python module (see gdb.types).\n\nA pretty-printer is just an object that holds a value and implements a specific interface, defined here. An example output is provided (see Pretty Printing).\n\nBecause GDB did not document extensibility for pretty-printers, by default GDB will assume that only the basic pretty-printer methods may be available. The basic methods are marked as such, below.\n\nTo allow extensibility, GDB provides the base class. This class does not provide any attributes or behavior, but instead serves as a tag that can be recognized by GDB. For such printers, GDB reserves all attributes starting with a lower-case letter. That is, in the future, GDB may add a new method or attribute to the pretty-printer protocol, and -based printers are expected to handle this gracefully. A simple way to do this would be to use a leading underscore (or two, following the Python name-mangling scheme) to any attributes local to the implementation.\n\nGDB provides a function which can be used to look up the default pretty-printer for a :\n\nNormally, a pretty-printer can respect the user’s print settings (including temporarily applied settings, such as ‘ ’) simply by calling (see Values From Inferior). However, these settings can also be queried directly:\n\nGDB provides several ways to register a pretty-printer: globally, per program space, and per objfile. When choosing how to register your pretty-printer, a good rule is to register it with the smallest scope possible: that is prefer a specific objfile first, then a program space, and only register a printer globally as a last resort.\n\nEach contains a attribute. Each also contains a attribute.\n\nEach function on these lists is passed a single argument and should return a pretty-printer object conforming to the interface definition above (see Pretty Printing API). If a function cannot create a pretty-printer for the value, it should return .\n\nGDB first checks the attribute of each in the current program space and iteratively calls each enabled lookup routine in the list for that until it receives a pretty-printer object. If no pretty-printer is found in the objfile lists, GDB then searches the pretty-printer list of the current program space, calling each enabled function until an object is returned. After these lists have been exhausted, it tries the global list, again calling each enabled function until an object is returned.\n\nThe order in which the objfiles are searched is not specified. For a given list, functions are always invoked from the head of the list, and iterated over sequentially until the end of the list, or a printer object is returned.\n\nFor various reasons a pretty-printer may not work. For example, the underlying data structure may have changed and the pretty-printer is out of date.\n\nThe consequences of a broken pretty-printer are severe enough that GDB provides support for enabling and disabling individual printers. For example, if is on, a backtrace can become highly illegible if any argument is printed with a broken printer.\n\nPretty-printers are enabled and disabled by attaching an attribute to the registered function or callable object. If this attribute is present and its value is , the printer is disabled, otherwise the printer is enabled.\n\nA pretty-printer consists of two parts: a lookup function to detect if the type is supported, and the printer itself.\n\nHere is an example showing how a printer might be written. See Pretty Printing API, for details on the API this class must provide. Note that this example uses the base class, and is careful to use a leading underscore for its local state.\n\nAnd here is an example showing how a lookup function for the printer example above might be written.\n\nThe example lookup function extracts the value’s type, and attempts to match it to a type that it can pretty-print. If it is a type the printer can pretty-print, it will return a printer object. If not, it returns .\n\nWe recommend that you put your core pretty-printers into a Python package. If your pretty-printers are for use with a library, we further recommend embedding a version number into the package name. This practice will enable GDB to load multiple versions of your pretty-printers at the same time, because they will have different names.\n\nYou should write auto-loaded code (see Python Auto-loading) such that it can be evaluated multiple times without changing its meaning. An ideal auto-load file will consist solely of s of your printer modules, followed by a call to a register pretty-printers with the current objfile.\n\nTaken as a whole, this approach will scale nicely to multiple inferiors, each potentially using a different library version. Embedding a version number in the Python package name will ensure that GDB is able to load both sets of printers simultaneously. Then, because the search for pretty-printers is done by objfile, and because your auto-loaded code took care to register your library’s printers with a specific objfile, GDB will find the correct printers for the specific version of the library used by each inferior.\n\nTo continue the example (see Pretty Printing API), this code might appear in :\n\nAnd then the corresponding contents of the auto-load file would be:\n\nThe previous example illustrates a basic pretty-printer. There are a few things that can be improved on. The printer doesn’t have a name, making it hard to identify in a list of installed printers. The lookup function has a name, but lookup functions can have arbitrary, even identical, names.\n\nSecond, the printer only handles one type, whereas a library typically has several types. One could install a lookup function for each desired type in the library, but one could also have a single lookup function recognize several types. The latter is the conventional way this is handled. If a pretty-printer can handle multiple data types, then its subprinters are the printers for the individual data types.\n\nThe module provides a formal way of solving these problems (see gdb.printing). Here is another example that handles multiple types.\n\nThese are the types we are going to pretty-print:\n\nHere are the printers:\n\nThis example doesn’t need a lookup function, that is handled by the module. Instead a function is provided to build up the object that handles the lookup.\n\nAnd here is the autoload support:\n\nFinally, when this printer is loaded into GDB, here is the corresponding output of ‘ ’:\n\nGDB provides a way for Python code to customize type display. This is mainly useful for substituting canonical typedef names for types.\n\nA type printer is just a Python object conforming to a certain protocol. A simple base class implementing the protocol is provided; see gdb.types. A type printer must supply at least:\n\nWhen displaying a type, say via the command, GDB will compute a list of type recognizers. This is done by iterating first over the per-objfile type printers (see Objfiles In Python), followed by the per-progspace type printers (see Progspaces In Python), and finally the global type printers.\n\nGDB will call the method of each enabled type printer. If this method returns , then the result is ignored; otherwise, it is appended to the list of recognizers.\n\nThen, when GDB is going to display a type name, it iterates over the list of recognizers. For each one, it calls the recognition function, stopping if the function returns a non- value. The recognition function is defined as:\n\nGDB uses this two-pass approach so that type printers can efficiently cache information without holding on to it too long. For example, it can be convenient to look up type information in a type printer and hold it for a recognizer’s lifetime; if a single pass were done then type printers would have to make use of the event system in order to avoid holding information that could become stale as the inferior changed.\n\nFrame filters are Python objects that manipulate the visibility of a frame or frames when a backtrace (see Backtrace) is printed by GDB.\n\nOnly commands that print a backtrace, or, in the case of GDB/MI commands (see GDB/MI), those that return a collection of frames are affected. The commands that work with frame filters are:\n\n(see The backtrace command), (see The -stack-list-frames command), (see The -stack-list-variables command), see The -stack-list-arguments command) and (see The -stack-list-locals command).\n\nA frame filter works by taking an iterator as an argument, applying actions to the contents of that iterator, and returning another iterator (or, possibly, the same iterator it was provided in the case where the filter does not perform any operations). Typically, frame filters utilize tools such as the Python’s module to work with and create new iterators from the source iterator. Regardless of how a filter chooses to apply actions, it must not alter the underlying GDB frame or frames, or attempt to alter the call-stack within GDB. This preserves data integrity within GDB. Frame filters are executed on a priority basis and care should be taken that some frame filters may have been executed before, and that some frame filters will be executed after.\n\nAn important consideration when designing frame filters, and well worth reflecting upon, is that frame filters should avoid unwinding the call stack if possible. Some stacks can run very deep, into the tens of thousands in some cases. To search every frame when a frame filter executes may be too expensive at that step. The frame filter cannot know how many frames it has to iterate over, and it may have to iterate through them all. This ends up duplicating effort as GDB performs this iteration when it prints the frames. If the filter can defer unwinding frames until frame decorators are executed, after the last filter has executed, it should. See Frame Decorator API, for more information on decorators. Also, there are examples for both frame decorators and filters in later chapters. See Writing a Frame Filter, for more information.\n\nThe Python dictionary contains key/object pairings that comprise a frame filter. Frame filters in this dictionary are called frame filters, and they are available when debugging all inferiors. These frame filters must register with the dictionary directly. In addition to the dictionary, there are other dictionaries that are loaded with different inferiors via auto-loading (see Python Auto-loading). The two other areas where frame filter dictionaries can be found are: which contains a dictionary attribute, and each object which also contains a dictionary attribute.\n\nWhen a command is executed from GDB that is compatible with frame filters, GDB combines the , and all dictionaries currently loaded. All of the dictionaries are combined, as several frames, and thus several object files, might be in use. GDB then prunes any frame filter whose attribute is . This pruned list is then sorted according to the attribute in each filter.\n\nOnce the dictionaries are combined, pruned and sorted, GDB creates an iterator which wraps each frame in the call stack in a object, and calls each filter in order. The output from the previous filter will always be the input to the next filter, and so on.\n\nFrame filters have a mandatory interface which each frame filter must implement, defined here:\n\nFrame decorators are sister objects to frame filters (see Frame Filter API). Frame decorators are applied by a frame filter and can only be used in conjunction with frame filters.\n\nThe purpose of a frame decorator is to customize the printed content of each in commands where frame filters are executed. This concept is called decorating a frame. Frame decorators decorate a with Python code contained within each API call. This separates the actual data contained in a from the decorated data produced by a frame decorator. This abstraction is necessary to maintain integrity of the data contained in each .\n\nGDB already contains a frame decorator called . This contains substantial amounts of boilerplate code to decorate the content of a . It is recommended that other frame decorators inherit and extend this object, and only to override the methods needed.\n\nis defined in the Python module , so your code can import it like:\n\nThere are three basic elements that a frame filter must implement: it must correctly implement the documented interface (see Frame Filter API), it must register itself with GDB, and finally, it must decide if it is to work on the data provided by GDB. In all cases, whether it works on the iterator or not, each frame filter must return an iterator. A bare-bones frame filter follows the pattern in the following example.\n\nThe frame filter in the example above implements the three requirements for all frame filters. It implements the API, self registers, and makes a decision on the iterator (in this case, it just returns the iterator untouched).\n\nThe first step is attribute creation and assignment, and as shown in the comments the filter assigns the following attributes: , and whether the filter should be enabled with the attribute.\n\nThe second step is registering the frame filter with the dictionary or dictionaries that the frame filter has interest in. As shown in the comments, this filter just registers itself with the global dictionary . As noted earlier, is a dictionary that is initialized in the module when GDB starts. What dictionary a filter registers with is an important consideration. Generally, if a filter is specific to a set of code, it should be registered either in the or dictionaries as they are specific to the program currently loaded in GDB. The global dictionary is always present in GDB and is never unloaded. Any filters registered with the global dictionary will exist until GDB exits. To avoid filters that may conflict, it is generally better to register frame filters against the dictionaries that more closely align with the usage of the filter currently in question. See Python Auto-loading, for further information on auto-loading Python scripts.\n\nGDB takes a hands-off approach to frame filter registration, therefore it is the frame filter’s responsibility to ensure registration has occurred, and that any exceptions are handled appropriately. In particular, you may wish to handle exceptions relating to Python dictionary key uniqueness. It is mandatory that the dictionary key is the same as frame filter’s attribute. When a user manages frame filters (see Frame Filter Management), the names GDB will display are those contained in the attribute.\n\nThe final step of this example is the implementation of the method. As shown in the example comments, we define the method and note that the method must take an iterator, and also must return an iterator. In this bare-bones example, the frame filter is not very useful as it just returns the iterator untouched. However this is a valid operation for frame filters that have the attribute set, but decide not to operate on any frames.\n\nIn the next example, the frame filter operates on all frames and utilizes a frame decorator to perform some work on the frames. See Frame Decorator API, for further information on the frame decorator interface.\n\nThis example works on inlined frames. It highlights frames which are inlined by tagging them with an “[inlined]” tag. By applying a frame decorator to all frames with the Python method, the example defers actions to the frame decorator. Frame decorators are only processed when GDB prints the backtrace.\n\nThis introduces a new decision making topic: whether to perform decision making operations at the filtering step, or at the printing step. In this example’s approach, it does not perform any filtering decisions at the filtering step beyond mapping a frame decorator to each frame. This allows the actual decision making to be performed when each frame is printed. This is an important consideration, and well worth reflecting upon when designing a frame filter. An issue that frame filters should avoid is unwinding the stack if possible. Some stacks can run very deep, into the tens of thousands in some cases. To search every frame to determine if it is inlined ahead of time may be too expensive at the filtering step. The frame filter cannot know how many frames it has to iterate over, and it would have to iterate through them all. This ends up duplicating effort as GDB performs this iteration when it prints the frames.\n\nIn this example decision making can be deferred to the printing step. As each frame is printed, the frame decorator can examine each frame in turn when GDB iterates. From a performance viewpoint, this is the most appropriate decision to make as it avoids duplicating the effort that the printing step would undertake anyway. Also, if there are many frame filters unwinding the stack during filtering, it can substantially delay the printing of the backtrace which will result in large memory usage, and a poor user experience.\n\nThis frame filter is somewhat similar to the earlier example, except that the method applies a frame decorator object called to each element in the iterator. The Python method is light-weight. It does not proactively iterate over the iterator, but rather creates a new iterator which wraps the existing one.\n\nBelow is the frame decorator for this example.\n\nThis frame decorator only defines and overrides the method. It lets the supplied , which is shipped with GDB, perform the other work associated with printing this frame.\n\nThe combination of these two objects create this output from a backtrace:\n\nSo in the case of this example, a frame decorator is applied to all frames, regardless of whether they may be inlined or not. As GDB iterates over the iterator produced by the frame filters, GDB executes each frame decorator which then makes a decision on what to print in the callback. Using a strategy like this is a way to defer decisions on the frame content to printing time.\n\nIt might be that the above example is not desirable for representing inlined frames, and a hierarchical approach may be preferred. If we want to hierarchically represent frames, the frame decorator interface might be preferable.\n\nThis example approaches the issue with the method. This example is quite long, but very simplistic. It is out-of-scope for this section to write a complete example that comprehensively covers all approaches of finding and printing inlined frames. However, this example illustrates the approach an author might use.\n\nThis example comprises of three sections.\n\nThis frame filter is very similar to the other examples. The only difference is this frame filter is wrapping the iterator provided to it ( ) with a custom iterator called . This again defers actions to when GDB prints the backtrace, as the iterator is not traversed until printing.\n\nThe iterator for this example is as follows. It is in this section of the example where decisions are made on the content of the backtrace.\n\nThis iterator implements the Python iterator protocol. When the function is called (when GDB prints each frame), the iterator checks if this frame decorator, , is wrapping an inlined frame. If it is not, it returns the existing frame decorator untouched. If it is wrapping an inlined frame, it assumes that the inlined frame was contained within the next oldest frame, , which it fetches. It then creates and returns a frame decorator, , which contains both the elided frame, and the eliding frame.\n\nThis frame decorator overrides one function and returns the inlined frame in the method. As before it lets do the rest of the work involved in printing this frame. This produces the following output.\n\nIn that output, which has been inlined into is printed hierarchically. Another approach would be to combine the method, and the method to both print a marker in the inlined frame, and also show the hierarchical relationship.\n\nIn GDB terminology “unwinding” is the process of finding the previous frame (that is, caller’s) from the current one. An unwinder has three methods. The first one checks if it can handle given frame (“sniff” it). For the frames it can sniff an unwinder provides two additional methods: it can return frame’s ID, and it can fetch registers from the previous frame. A running GDB maintains a list of the unwinders and calls each unwinder’s sniffer in turn until it finds the one that recognizes the current frame. There is an API to register an unwinder.\n\nThe unwinders that come with GDB handle standard frames. However, mixed language applications (for example, an application running Java Virtual Machine) sometimes use frame layouts that cannot be handled by the GDB unwinders. You can write Python code that can handle such custom frames.\n\nYou implement a frame unwinder in Python as a class with which has two attributes, and , with obvious meanings, and a single method , which examines a given frame and returns an object (an instance of describing it. If an unwinder does not recognize a frame, it should return . The code in GDB that enables writing unwinders in Python uses this object to return frame’s ID and previous frame registers when GDB core asks for them.\n\nAn unwinder should do as little work as possible. Some otherwise innocuous operations can cause problems (even crashes, as this code is not well-hardened yet). For example, making an inferior call from an unwinder is unadvisable, as an inferior call will reset GDB’s stack unwinding process, potentially causing re-entrant unwinding.\n\nAn object passed to an unwinder (a instance) provides a method to read frame’s registers:\n\nIt also provides a factory method to create a instance to be returned to GDB:\n\nUse method described above to create a instance. Use the following method to specify caller registers that have been saved in this frame:\n\nGDB comes with a module which contains the following classes:\n\nObject files and program spaces can have unwinders registered with them. In addition, you can register unwinders globally.\n\nThe module provides the function to register an unwinder:\n\nHere is an example of how to structure a user created unwinder:\n\nGDB defines 3 commands to manage registered unwinders. These are:\n\nXmethods are additional methods or replacements for existing methods of a C class. This feature is useful for those cases where a method defined in C source code could be inlined or optimized out by the compiler, making it unavailable to GDB. For such cases, one can define an xmethod to serve as a replacement for the method defined in the C source code. GDB will then invoke the xmethod, instead of the C method, to evaluate expressions. One can also use xmethods when debugging with core files. Moreover, when debugging live programs, invoking an xmethod need not involve running the inferior (which can potentially perturb its state). Hence, even if the C method is available, it is better to use its replacement xmethod if one is defined.\n\nThe xmethods feature in Python is available via the concepts of an xmethod matcher and an xmethod worker. To implement an xmethod, one has to implement a matcher and a corresponding worker for it (more than one worker can be implemented, each catering to a different overloaded instance of the method). Internally, GDB invokes the method of a matcher to match the class type and method name. On a match, the method returns a list of matching worker objects. Each worker object typically corresponds to an overloaded instance of the xmethod. They implement a method which returns a sequence of types corresponding to the arguments the xmethod requires. GDB uses this sequence of types to perform overload resolution and picks a winning xmethod worker. A winner is also selected from among the methods GDB finds in the C source code. Next, the winning xmethod worker and the winning C method are compared to select an overall winner. In case of a tie between a xmethod worker and a C method, the xmethod worker is selected as the winner. That is, if a winning xmethod worker is found to be equivalent to the winning C method, then the xmethod worker is treated as a replacement for the C method. GDB uses the overall winner to invoke the method. If the winning xmethod worker is the overall winner, then the corresponding xmethod is invoked via the method of the worker object.\n\nIf one wants to implement an xmethod as a replacement for an existing C method, then they have to implement an equivalent xmethod which has exactly the same name and takes arguments of exactly the same type as the C method. If the user wants to invoke the C method even though a replacement xmethod is available for that method, then they can disable the xmethod.\n\nSee Xmethod API, for API to implement xmethods in Python. See Writing an Xmethod, for implementing xmethods in Python.\n\nThe GDB Python API provides classes, interfaces and functions to implement, register and manipulate xmethods. See Xmethods In Python.\n\nAn xmethod matcher should be an instance of a class derived from defined in the module , or an object with similar interface and attributes. An instance of has the following attributes:\n\nThe class has the following methods:\n\nAn xmethod worker should be an instance of a class derived from defined in the module , or support the following interface:\n\nFor GDB to lookup xmethods, the xmethod matchers should be registered using the following function defined in the module :\n\nImplementing xmethods in Python will require implementing xmethod matchers and xmethod workers (see Xmethods In Python). Consider the following C class:\n\nLet us define two xmethods for the class , one replacing the method , and another adding an overloaded flavor of which takes a argument (the C code above already has an overloaded which takes an argument). The xmethod matcher can be defined as follows:\n\nNotice that the method of returns a worker object of type for the method, and a worker object of type for the method. This is done indirectly via helper classes derived from . One does not need to use the attribute in a matcher as it is optional. However, if a matcher manages more than one xmethod, it is a good practice to list the xmethods in the attribute of the matcher. This will then facilitate enabling and disabling individual xmethods via the commands. Notice also that a worker object is returned only if the corresponding entry in the attribute of the matcher is enabled.\n\nThe implementation of the worker classes returned by the matcher setup above is as follows:\n\nFor GDB to actually lookup a xmethod, it has to be registered with it. The matcher defined above is registered with GDB globally as follows:\n\nIf an object of type is initialized in C code as follows:\n\nthen, after loading the Python script defining the xmethod matchers and workers into GDB, invoking the method or using the operator on will invoke the xmethods defined above:\n\nConsider another example with a C++ template class:\n\nLet us implement an xmethod for the above class which serves as a replacement for the method. The full code listing of the xmethod workers and xmethod matchers is as follows:\n\nNotice that, in this example, we have not used the attribute of the matcher as the matcher manages only one xmethod. The user can enable/disable this xmethod by enabling/disabling the matcher itself.\n\nPrograms which are being run under GDB are called inferiors (see Inferiors Connections and Programs). Python scripts can access information about and manipulate inferiors controlled by GDB via objects of the class.\n\nThe following inferior-related functions are available in the module:\n\nA object has the following attributes:\n\nA object has the following methods:\n\nThe environment that will be passed to the inferior can be changed from Python by using the following methods. These methods only take effect when the inferior is started – they will not affect an inferior that is already executing.\n\nOne may add arbitrary attributes to objects in the usual Python way. This is useful if, for example, one needs to do some extra record keeping associated with the inferior.\n\nWhen selecting a name for a new attribute, avoid starting the new attribute name with a lower case letter; future attributes added by GDB will start with a lower case letter. Additionally, avoid starting attribute names with two underscore characters, as these could clash with Python builtin attribute names.\n\nIn this contrived example we record the time when an inferior last stopped:\n\nGDB provides a general event facility so that Python code can be notified of various state changes, particularly changes that occur in the inferior.\n\nAn event is just an object that describes some state change. The type of the object and its attributes will vary depending on the details of the change. All the existing events are described below.\n\nIn order to be notified of an event, you must register an event handler with an event registry. An event registry is an object in the module which dispatches particular events. A registry provides methods to register and unregister event handlers:\n\nHere is an example:\n\nIn the above example we connect our handler to the registry . Once connected, gets called when the inferior exits. The argument event in this example is of type . As you can see in the example the object has an attribute which indicates the exit code of the inferior.\n\nSome events can be thread specific when GDB is running in non-stop mode. When represented in Python, these events all extend . This event is a base class and is never emitted directly; instead, events which are emitted by this or other modules might extend this event. Examples of these events are and . holds the following attributes:\n\nThe following is a listing of the event registries that are available and details of the events they emit:\n\nPython scripts can access information about, and manipulate inferior threads controlled by GDB, via objects of the class.\n\nThe following thread-related functions are available in the module:\n\nTo get the list of threads for an inferior, use the method. See Inferiors In Python.\n\nA object has the following attributes:\n\nA object has the following methods:\n\nOne may add arbitrary attributes to objects in the usual Python way. This is useful if, for example, one needs to do some extra record keeping associated with the thread.\n\nSee choosing attribute names, for guidance on selecting a suitable name for new attributes.\n\nIn this contrived example we record the time when a thread last stopped:\n\nThe following recordings-related functions (see Process Record and Replay) are available in the module:\n\nA object has the following attributes:\n\nA object has the following methods:\n\nThe common class that recording method specific instruction objects inherit from, has the following attributes:\n\nAdditionally has the following attributes:\n\nIf an error occurred during recording or decoding a recording, this error is represented by a object in the instruction list. It has the following attributes:\n\nSome GDB features write auxiliary information into the execution history. This information is represented by a object in the instruction list. It has the following attributes:\n\nA object has the following attributes:\n\nThe following example demonstrates the usage of these objects and functions to create a function that will rewind a record to the last time a function in a different file was executed. This would typically be used to track the execution of user provided callback functions in a library which typically are not visible in a back trace.\n\nAnother possible application is to write a function that counts the number of code executions in a given line range. This line range can contain parts of functions or span across several functions and is not limited to be contiguous.\n\nYou can implement new GDB CLI commands in Python. A CLI command is implemented using an instance of the class, most commonly using a subclass.\n\nWhen a new command is registered, it must be declared as a member of some general class of commands. This is used to classify top-level commands in the on-line help system; note that prefix commands are not listed under their own category but rather that of their top-level command. The available classifications are represented by constants defined in the module:\n\nA new command can use a predefined completion function, either by specifying it via an argument at initialization, or by returning it from the method. These predefined completion constants are all defined in the module:\n\nThe following code snippet shows how a trivial CLI command can be implemented in Python:\n\nThe last line instantiates the class, and is necessary to trigger the registration of the command with GDB. Depending on how the Python code is read into GDB, you may need to import the module explicitly.\n\nIt is possible to add GDB/MI (see GDB/MI) commands implemented in Python. A GDB/MI command is implemented using an instance of the class, most commonly using a subclass.\n\nAn instance of has the following attributes:\n\nThe following code snippet shows how some trivial MI commands can be implemented in Python:\n\nThe last three lines instantiate the class three times, creating three new GDB/MI commands , , and . Each time a subclass of is instantiated, the new command is automatically registered with GDB.\n\nDepending on how the Python code is read into GDB, you may need to import the module explicitly.\n\nThe following example shows a GDB session in which the above commands have been added:\n\nConversely, it is possible to execute GDB/MI commands from Python, with the results being a Python object and not a specially-formatted string. This is done with the function.\n\nHere is how this works using the commands from the example above:\n\nIt is possible to emit GDB/MI notifications from Python. Use the function to do that.\n\nWhile using existing notification names (see GDB/MI Async Records) with is allowed, users are encouraged to prefix user-defined notification with a hyphen ( ) to avoid possible conflict. GDB will never introduce notification starting with hyphen.\n\nHere is how to emit whenever a connection to remote GDB server is closed (see Connections In Python):\n\nThen, each time a connection is closed, there will be a notification on MI channel:\n\nYou can implement new GDB parameters using Python. A new parameter is implemented as an instance of the class.\n\nParameters are exposed to the user via the and commands. See Help.\n\nThere are many parameters that already exist and can be set in GDB. Two examples are: and . Setting these parameters influences certain behavior in GDB. Similarly, you can define parameters that can be used to influence behavior in custom Python scripts and commands.\n\nThere are two methods that may be implemented in any class. These are:\n\nWhen a new parameter is defined, its type must be specified. The available types are represented by constants defined in the module:\n\nYou can implement new convenience functions (see Convenience Vars) in Python. A convenience function is an instance of a subclass of the class .\n\nThe following code snippet shows how a trivial convenience function can be implemented in Python:\n\nThe last line instantiates the class, and is necessary to trigger the registration of the function with GDB. Depending on how the Python code is read into GDB, you may need to import the module explicitly.\n\nNow you can use the function in an expression:\n\nA program space, or progspace, represents a symbolic view of an address space. It consists of all of the objfiles of the program. See Objfiles In Python. See program spaces, for more details about program spaces.\n\nThe following progspace-related functions are available in the module:\n\nEach progspace is represented by an instance of the class.\n\nA program space has the following methods:\n\nOne may add arbitrary attributes to objects in the usual Python way. This is useful if, for example, one needs to do some extra record keeping associated with the program space.\n\nSee choosing attribute names, for guidance on selecting a suitable name for new attributes.\n\nIn this contrived example, we want to perform some processing when an objfile with a certain symbol is loaded, but we only want to do this once because it is expensive. To achieve this we record the results with the program space because we can’t predict when the desired objfile will be loaded.\n\nGDB loads symbols for an inferior from various symbol-containing files (see Files). These include the primary executable file, any shared libraries used by the inferior, and any separate debug info files (see Separate Debug Files). GDB calls these symbol-containing files objfiles.\n\nThe following objfile-related functions are available in the module:\n\nEach objfile is represented by an instance of the class.\n\nOne may add arbitrary attributes to objects in the usual Python way. This is useful if, for example, one needs to do some extra record keeping associated with the objfile.\n\nSee choosing attribute names, for guidance on selecting a suitable name for new attributes.\n\nIn this contrived example we record the time when GDB loaded the objfile.\n\nA object has the following methods:\n\nWhen the debugged program stops, GDB is able to analyze its call stack (see Stack frames). The class represents a frame in the stack. A object is only valid while its corresponding frame exists in the inferior’s stack. If you try to use an invalid frame object, GDB will throw a exception (see Exception Handling).\n\nTwo objects can be compared for equality with the operator, like:\n\nThe following frame-related functions are available in the module:\n\nA object has the following methods:\n\nIn GDB, symbols are stored in blocks. A block corresponds roughly to a scope in the source code. Blocks are organized hierarchically, and are represented individually in Python as a . Blocks rely on debugging information being available.\n\nA frame has a block. Please see Frames In Python, for a more in-depth discussion of frames.\n\nThe outermost block is known as the global block. The global block typically holds public global variables and functions.\n\nThe block nested just inside the global block is the static block. The static block typically holds file-scoped variables and functions.\n\nGDB provides a method to get a block’s superblock, but there is currently no way to examine the sub-blocks of a block, or to iterate over all the blocks in a symbol table (see Symbol Tables In Python).\n\nHere is a short example that should help explain blocks:\n\nA is iterable. The iterator returns the symbols (see Symbols In Python) local to the block. Python programs should not assume that a specific block object will always contain a given symbol, since changes in GDB features and infrastructure may cause symbols move across blocks in a symbol table. You can also use Python’s dictionary syntax to access variables in this block, e.g.:\n\nThe following block-related functions are available in the module:\n\nA object has the following methods:\n\nA object has the following attributes:\n\nGDB represents every variable, function and type as an entry in a symbol table. See Examining the Symbol Table. Similarly, Python represents these symbols in GDB with the object.\n\nThe following symbol-related functions are available in the module:\n\nA object has the following attributes:\n\nA object has the following methods:\n\nThe available domain categories in are represented as constants in the module:\n\nWhen searching for a symbol, the desired domain constant can be passed verbatim to the lookup function. For example:\n\nFor more complex searches, there is a corresponding set of constants, each named after one of the preceding constants, but with the ‘ ’ prefix replacing the ‘ ’ prefix; for example, . These may be or’d together to form a search constant, e.g.:\n\nThe available address class categories in are represented as constants in the module:\n\nAccess to symbol table data maintained by GDB on the inferior is exposed to Python via two objects: and . Symbol table and line data for a frame is returned from the method in object. See Frames In Python.\n\nFor more information on GDB’s symbol table management, see Examining the Symbol Table, for more information.\n\nA object has the following attributes:\n\nA object has the following methods:\n\nA object has the following attributes:\n\nA object has the following methods:\n\nPython code can request and inspect line table information from a symbol table that is loaded in GDB. A line table is a mapping of source lines to their executable locations in memory. To acquire the line table information for a particular symbol table, use the function (see Symbol Tables In Python).\n\nA is iterable. The iterator returns objects that correspond to the source line and address for each line table entry. objects have the following attributes:\n\nAs there can be multiple addresses for a single source line, you may receive multiple objects with matching attributes, but with different attributes. The iterator is sorted in ascending order. Here is a small example illustrating iterating over a line table.\n\nThis will have the following output:\n\nIn addition to being able to iterate over a , it also has the following direct access methods:\n\nPython code can manipulate breakpoints via the class.\n\nA breakpoint can be created using one of the two forms of the constructor. The first one accepts a string like one would pass to the (see Setting Breakpoints) and (see Setting Watchpoints) commands, and can be used to create both breakpoints and watchpoints. The second accepts separate Python arguments similar to Explicit Locations, and can only be used to create breakpoints.\n\nThe available types are represented by constants defined in the module:\n\nThe available watchpoint types are represented by constants defined in the module:\n\nA breakpoint location is one of the actual places where a breakpoint has been set, represented in the Python API by the type. This type is never instantiated by the user directly, but is retrieved from which returns a list of breakpoint locations where it is currently set. Breakpoint locations can become invalid if new symbol files are loaded or dynamically loaded libraries are closed. Accessing the attributes of an invalidated breakpoint location will throw a exception. Access the attribute again to retrieve the new and valid breakpoints location list.\n\nA finish breakpoint is a temporary breakpoint set at the return address of a frame, based on the command. extends . The underlying breakpoint will be disabled and deleted when the execution will run out of the breakpoint scope (i.e. or triggered). Finish breakpoints are thread specific and must be create with the right thread selected.\n\nA lazy string is a string whose contents is not retrieved or encoded until it is needed.\n\nA is represented in GDB as an that points to a region of memory, an that will be used to encode that region of memory, and a to delimit the region of memory that represents the string. The difference between a and a string wrapped within a is that a will only be retrieved and encoded during printing, while a wrapping a string is immediately retrieved and encoded on creation.\n\nA can be created using the method (see Values From Inferior).\n\nA object has the following functions:\n\nYou can assign instance of to the of a instance created with .\n\nmay refer to an index from color palette or contain components of a color from some colorspace.\n\nWhen color is initialized, its color space must be specified. The available color spaces are represented by constants defined in the module:\n\nGDB uses architecture specific parameters and artifacts in a number of its various computations. An architecture is represented by an instance of the class.\n\nA class has the following methods:\n\nPython code can request from a information about the set of registers available (see ). The register information is returned as a , which is an iterator that in turn returns objects.\n\nA does not provide the value of a register (see for reading a register’s value), instead the is a way to discover which registers are available for a particular architecture.\n\nA has the following read-only properties:\n\nIt is also possible to lookup a register descriptor based on its name using the following function:\n\nPython code can also request from a information about the set of register groups available on a given architecture (see ).\n\nEvery register can be a member of zero or more register groups. Some register groups are used internally within GDB to control things like which registers must be saved when calling into the program being debugged (see Calling Program Functions). Other register groups exist to allow users to easily see related sets of registers in commands like (see ).\n\nThe register groups information is returned as a , which is an iterator that in turn returns objects.\n\nA object has the following read-only properties:\n\nGDB lets you run and debug multiple programs in a single session. Each program being debugged has a connection, the connection describes how GDB controls the program being debugged. Examples of different connection types are ‘ ’ and ‘ ’. See Inferiors Connections and Programs.\n\nConnections in GDB are represented as instances of , or as one of its sub-classes. To get a list of all connections use (see gdb.connections).\n\nTo get the connection for a single read its attribute (see gdb.Inferior.connection).\n\nCurrently there is only a single sub-class of , , however, additional sub-classes may be added in future releases of GDB. As a result you should avoid writing code like:\n\nas this may fail when more connection types are added. Instead, you should write:\n\nA has the following method:\n\nA has the following read-only properties:\n\nThe class is a sub-class of , and is used to represent ‘ ’ and ‘ ’ connections. In addition to the attributes and methods available from the base class, a has the following method:\n\nNew TUI (see TUI) windows can be implemented in Python.\n\nAs mentioned above, when a factory function is called, it is passed an object of type . This object has these methods and attributes:\n\nThe factory function that you supply should return an object conforming to the TUI window protocol. These are the methods that can be called on this object, which is referred to below as the “window object”. The methods documented below are optional; if the object does not implement one of these methods, GDB will not attempt to call it. Additional new methods may be added to the window protocol in the future. GDB guarantees that they will begin with a lower-case letter, so you can start implementation methods with upper-case letters or underscore to avoid any future conflicts.\n\nGDB’s builtin disassembler can be extended, or even replaced, using the Python API. The disassembler related features are contained within the module:\n\nThe following table lists all of the disassembler styles that are available. GDB maps these style constants onto its style settings (see Output Styling). In some cases, several style constants produce the same style settings, and thus will produce the same visual effect on the screen. This could change in future releases of GDB, so care should be taken to select the correct style constant to ensure correct output styling in future releases of GDB.\n\nThe following functions are also contained in the module:\n\nHere is an example that registers a global disassembler. The new disassembler invokes the builtin disassembler, and then adds a comment, , to each line of disassembly output:\n\nThe following example creates a sub-class of in order to intercept the calls, within any bytes read from memory have the two 4-bit nibbles swapped around. This isn’t a very useful adjustment, but serves as an example.\n\nWhen GDB encounters a new objfile (see Objfiles In Python), e.g. the primary executable, or any shared libraries used by the inferior, GDB will attempt to load the corresponding debug information for that objfile. The debug information might be found within the objfile itself, or within a separate objfile which GDB will automatically locate and load.\n\nSometimes though, GDB might not find any debug information for an objfile, in this case the debugging experience will be restricted.\n\nIf GDB fails to locate any debug information for a particular objfile, there is an opportunity for a Python extension to step in. A Python extension can potentially locate the missing debug information using some platform- or project-specific steps, and inform GDB of its location. Or a Python extension might provide some platform- or project-specific advice to the user about how to obtain the missing debug information.\n\nA missing debug information Python extension consists of a handler object which has the and attributes, and implements the method. When GDB encounters an objfile for which it is unable to find any debug information, it invokes the method. Full details of how handlers are written can be found below.\n\nGDB comes with a module which contains the following class and global function:\n\nWhen GDB opens a core file, for example with the command (see core-file command), GDB will attempt to load the corresponding executable and shared libraries. Often these files can be found on the local machine, but sometimes these files cannot be found, in which case the debugging experience will be restricted.\n\nIf GDB fails to locate a particular file then there is an opportunity for a Python extension to step in. A Python extension can potentially locate the missing file using some platform- or project-specific steps, and inform GDB of its location. Or a Python extension might provide some platform- or project-specific advice to the user about how to obtain the missing file.\n\nA missing-objfile Python extension consists of a handler object which has the and attributes, and implements the method. When GDB encounters a situation where a file cannot be found, but the build-id (see build ID) for the missing file is known, then the method is invoked to try and find the file. Full details of how handlers are written can be found below.\n\nGDB comes with a module which contains the following class and global function:\n\nGDB defines the following commands to manage registered missing-objfile handlers:\n\nWhen a new object file is read (for example, due to the command, or because the inferior has loaded a shared library), GDB will look for Python support scripts in several ways: and section. See Auto-loading extensions.\n\nThe auto-loading feature is useful for supplying application-specific debugging commands and scripts.\n\nAuto-loading can be enabled or disabled, and the list of auto-loaded scripts can be printed.\n\nWhen reading an auto-loaded file or script, GDB sets the current objfile. This is available via the function (see Objfiles In Python). This can be useful for registering objfile-specific pretty-printers and frame-filters.\n\nGDB comes with several modules to assist writing Python code.\n\nThis module provides a collection of utilities for working with pretty-printers.\n\nThis module provides a collection of utilities for working with objects.\n\nThis module provides a method for prompt value-substitution.\n\nThis module provides additional functionality for recording programs that make use of the instruction. is a x86 instruction that allows to write values into the Intel Processor Trace (see Process Record and Replay). The GCC intrinsics for it are:\n\nIf an inferior uses the instruction, GDB by default inserts the raw payload value as auxiliary information into the execution history. Auxiliary information is by default printed during , , and all stepping commands, and is accessible in Python as a object (see Recordings In Python).\n\nGDB output after recording the sample program in pt format:\n\nThe module allows customizing the default output of auxiliary information. A custom Python function can be registered as the filter function. This function will be called with the payload and PC as arguments during trace decoding. The function can return a string, which will be printed by GDB during the aforementioned commands, or , resulting in no output. To register such a filter function, the user needs to provide a filter factory function, which returns a new filter function object to be called by GDB.\n\nThis GDB feature is dependent on hardware and operating system support and requires the Intel Processor Trace decoder library in version 2.0.0 or newer.\n\nYou can extend GDB using the Guile implementation of the Scheme programming language. This feature is available only if GDB was configured using .\n\nGuile is an implementation of the Scheme programming language and is the GNU project’s official extension language.\n\nGuile support in GDB follows the Python support in GDB reasonably closely, so concepts there should carry over. However, some things are done differently where it makes sense.\n\nGuile scripts used by GDB should be installed in , where is the data directory as determined at GDB startup (see Data Files). This directory, known as the guile directory, is automatically added to the Guile Search Path in order to allow the Guile interpreter to locate all scripts installed at this location.\n\nGDB provides two commands for accessing the Guile interpreter:\n\nIt is also possible to execute a Guile script from the GDB interpreter:\n\nYou can get quick online help for GDB’s Guile API by issuing the command , or by issuing the command from an interactive Guile session. Furthermore, most Guile procedures provided by GDB have doc strings which can be obtained with or from the Guile interactive prompt.\n\nAt startup, GDB overrides Guile’s and to print using GDB’s output-paging streams. A Guile program which outputs to one of these streams may have its output interrupted by the user (see Screen Size). In this situation, a Guile exception is thrown with value .\n\nGuile’s history mechanism uses the same naming as GDB’s, namely the user of dollar-variables (e.g., $1, $2, etc.). The results of evaluations in Guile and in GDB are counted separately, in Guile is not the same value as in GDB.\n\nGDB is not thread-safe. If your Guile program uses multiple threads, you must be careful to only call GDB-specific functions in the GDB thread.\n\nSome care must be taken when writing Guile code to run in GDB. Two things are worth noting in particular:\n• GDB installs handlers for and . Guile code must not override these, or even change the options using . If your program changes the handling of these signals, GDB will most likely stop working correctly. Note that it is unfortunately common for GUI toolkits to install a handler.\n• GDB takes care to mark its internal file descriptors as close-on-exec. However, this cannot be done in a thread-safe way on all platforms. Your Guile programs should be aware of this and should both create new file descriptors with the close-on-exec flag set and arrange to close unneeded file descriptors before starting a child process.\n\nGDB introduces a new Guile module, named . All methods and classes added by GDB are placed in this module. GDB does not automatically the module, scripts must do this themselves. There are various options for how to import a module, so GDB leaves the choice of how the module is imported to the user. To simplify interactive use, it is recommended to add one of the following to your ~/.gdbinit.\n\nWhich one to choose depends on your preference. The second one adds as a prefix to all module functions and variables.\n\nThe rest of this manual assumes the module has been imported without any prefix. See the Guile documentation for for more information (see Using Guile Modules in ).\n\nThe module provides these basic Guile functions.\n\nGDB provides these Scheme functions to access various configuration parameters.\n\nThe values exposed by GDB to Guile are known as GDB objects. There are several kinds of GDB object, and each is disjoint from all other types known to Guile.\n\nThe following GDB objects are managed internally so that the Scheme function may be applied to them.\n\nWhen executing the command, Guile exceptions uncaught within the Guile code are translated to calls to the GDB error-reporting mechanism. If the command that called does not handle the error, GDB will terminate it and report the error according to the setting of the parameter.\n\nThe parameter has three settings:\n\nGDB errors that happen in GDB commands invoked by Guile code are converted to Guile exceptions. The type of the Guile exception depends on the error.\n\nGuile procedures provided by GDB can throw the standard Guile exceptions like and .\n\nUser interrupt (via or by typing at a pagination prompt) is translated to a Guile exception with value .\n\nGDB Guile procedures can also throw these exceptions:\n\nThe following exception-related procedures are provided by the module.\n\nGDB provides values it obtains from the inferior program in an object of type . GDB uses this object for its internal bookkeeping of the inferior’s values, and for fetching values when necessary.\n\nGDB does not memoize objects. always returns a fresh object.\n\nA that represents a function can be executed via inferior function call with . Any arguments provided to the call must match the function’s prototype, and must be provided in the order specified by that prototype.\n\nFor example, is a instance representing a function that takes two integers as arguments. To execute this function, call it like so:\n\nAny values returned from a function call are objects.\n\nNote: Unlike Python scripting in GDB, inferior values that are simple scalars cannot be used directly in Scheme expressions that are valid for the value’s data type. For example, does not work. And inferior values that are structures or instances of some class cannot be accessed using any special syntax, instead must be used.\n\nThe following value-related procedures are provided by the module.\n\nThe module provides several functions for performing arithmetic on objects. The arithmetic is performed as if it were done by the target, and therefore has target semantics which are not necessarily those of Scheme. For example operations work with a fixed precision, not the arbitrary precision of Scheme.\n\nWherever a function takes an integer or pointer as an operand, GDB will convert appropriate Scheme values to perform the operation.\n\nScheme does not provide a function, and thus Guile support in GDB does not either.\n\nGDB represents types from the inferior in objects of type .\n\nThe following type-related procedures are provided by the module.\n\nEach type has a code, which indicates what category this type falls into. The available type categories are represented by constants defined in the module:\n\nFurther support for types is provided in the Guile module (see Guile Types Module).\n\nEach field is represented as an object of type .\n\nThe following field-related procedures are provided by the module:\n\nAn example output is provided (see Pretty Printing).\n\nA pretty-printer is represented by an object of type <gdb:pretty-printer>. Pretty-printer objects are created with .\n\nThe following pretty-printer-related procedures are provided by the module:\n\nGDB provides a function which can be used to look up the default pretty-printer for a :\n\nThere are three sets of pretty-printers that GDB searches:\n• Per-objfile list of pretty-printers (see Objfiles In Guile).\n• Per-progspace list of pretty-printers (see Progspaces In Guile).\n• The global list of pretty-printers (see Guile Pretty Printing API). These printers are available when debugging any inferior.\n\nPretty-printer lookup is done by passing the value to be printed to the lookup function of each enabled object in turn. Lookup stops when a lookup function returns a non- value or when the list is exhausted. Lookup functions must return either a object or . Otherwise an exception is thrown.\n\nGDB first checks the result of of each in the current program space and iteratively calls each enabled lookup function in the list for that until a non- object is returned. If no pretty-printer is found in the objfile lists, GDB then searches the result of of the current program space, calling each enabled function until a non- object is returned. After these lists have been exhausted, it tries the global pretty-printers list, obtained with , again calling each enabled function until a non- object is returned.\n\nThe order in which the objfiles are searched is not specified. For a given list, functions are always invoked from the head of the list, and iterated over sequentially until the end of the list, or a object is returned.\n\nFor various reasons a pretty-printer may not work. For example, the underlying data structure may have changed and the pretty-printer is out of date.\n\nThe consequences of a broken pretty-printer are severe enough that GDB provides support for enabling and disabling individual printers. For example, if is on, a backtrace can become highly illegible if any argument is printed with a broken printer.\n\nPretty-printers are enabled and disabled from Scheme by calling . See Guile Pretty Printing API.\n\nA pretty-printer consists of two basic parts: a lookup function to determine if the type is supported, and the printer itself.\n\nHere is an example showing how a printer might be written. See Guile Pretty Printing API, for details.\n\nAnd here is an example showing how a lookup function for the printer example above might be written.\n\nThen to register this printer in the global printer list:\n\nThe example lookup function extracts the value’s type, and attempts to match it to a type that it can pretty-print. If it is a type the printer can pretty-print, it will return a <gdb:pretty-printer-worker> object. If not, it returns .\n\nWe recommend that you put your core pretty-printers into a Guile package. If your pretty-printers are for use with a library, we further recommend embedding a version number into the package name. This practice will enable GDB to load multiple versions of your pretty-printers at the same time, because they will have different names.\n\nYou should write auto-loaded code (see Guile Auto-loading) such that it can be evaluated multiple times without changing its meaning. An ideal auto-load file will consist solely of s of your printer modules, followed by a call to a register pretty-printers with the current objfile.\n\nTaken as a whole, this approach will scale nicely to multiple inferiors, each potentially using a different library version. Embedding a version number in the Guile package name will ensure that GDB is able to load both sets of printers simultaneously. Then, because the search for pretty-printers is done by objfile, and because your auto-loaded code took care to register your library’s printers with a specific objfile, GDB will find the correct printers for the specific version of the library used by each inferior.\n\nTo continue the example, this code might appear in :\n\nAnd then the corresponding contents of the auto-load file would be:\n\nThe previous example illustrates a basic pretty-printer. There are a few things that can be improved on. The printer only handles one type, whereas a library typically has several types. One could install a lookup function for each desired type in the library, but one could also have a single lookup function recognize several types. The latter is the conventional way this is handled. If a pretty-printer can handle multiple data types, then its subprinters are the printers for the individual data types.\n\nThe module provides a formal way of solving this problem (see Guile Printing Module). Here is another example that handles multiple types.\n\nThese are the types we are going to pretty-print:\n\nHere are the printers:\n\nThis example doesn’t need a lookup function, that is handled by the module. Instead a function is provided to build up the object that handles the lookup.\n\nAnd here is the autoload support:\n\nFinally, when this printer is loaded into GDB, here is the corresponding output of ‘ ’:\n\nYou can implement new GDB CLI commands in Guile. A CLI command object is created with the Guile function, and added to GDB with the Guile function. This two-step approach is taken to separate out the side-effect of adding the command to GDB from .\n\nThere is no support for multi-line commands, that is commands that consist of multiple lines and are terminated with .\n\nWhen a new command is registered, it will have been declared as a member of some general class of commands. This is used to classify top-level commands in the on-line help system; note that prefix commands are not listed under their own category but rather that of their top-level command. The available classifications are represented by constants defined in the module:\n\nA new command can use a predefined completion function, either by specifying it via an argument at initialization, or by returning it from the procedure. These predefined completion constants are all defined in the module:\n\nThe following code snippet shows how a trivial CLI command can be implemented in Guile:\n\nYou can implement new GDB parameters using Guile 19.\n\nThere are many parameters that already exist and can be set in GDB. Two examples are: and . Setting these parameters influences certain behavior in GDB. Similarly, you can define parameters that can be used to influence behavior in custom Guile scripts and commands.\n\nA new parameter is defined with the Guile function, and added to GDB with the Guile function. This two-step approach is taken to separate out the side-effect of adding the parameter to GDB from .\n\nParameters are exposed to the user via the and commands. See Help.\n\nWhen a new parameter is defined, its type must be specified. The available types are represented by constants defined in the module:\n\nA program space, or progspace, represents a symbolic view of an address space. It consists of all of the objfiles of the program. See Objfiles In Guile. See program spaces, for more details about program spaces.\n\nEach progspace is represented by an instance of the smob. See GDB Scheme Data Types.\n\nThe following progspace-related functions are available in the module:\n\nGDB loads symbols for an inferior from various symbol-containing files (see Files). These include the primary executable file, any shared libraries used by the inferior, and any separate debug info files (see Separate Debug Files). GDB calls these symbol-containing files objfiles.\n\nEach objfile is represented as an object of type .\n\nThe following objfile-related procedures are provided by the module:\n\nWhen the debugged program stops, GDB is able to analyze its call stack (see Stack frames). The class represents a frame in the stack. A object is only valid while its corresponding frame exists in the inferior’s stack. If you try to use an invalid frame object, GDB will throw a exception (see Guile Exception Handling).\n\nTwo objects can be compared for equality with the function, like:\n\nThe following frame-related procedures are provided by the module:\n\nIn GDB, symbols are stored in blocks. A block corresponds roughly to a scope in the source code. Blocks are organized hierarchically, and are represented individually in Guile as an object of type . Blocks rely on debugging information being available.\n\nA frame has a block. Please see Frames In Guile, for a more in-depth discussion of frames.\n\nThe outermost block is known as the global block. The global block typically holds public global variables and functions.\n\nThe block nested just inside the global block is the static block. The static block typically holds file-scoped variables and functions.\n\nGDB provides a method to get a block’s superblock, but there is currently no way to examine the sub-blocks of a block, or to iterate over all the blocks in a symbol table (see Symbol Tables In Guile).\n\nHere is a short example that should help explain blocks:\n\nThe following block-related procedures are provided by the module:\n\nGDB represents every variable, function and type as an entry in a symbol table. See Examining the Symbol Table. Guile represents these symbols in GDB with the object.\n\nThe following symbol-related procedures are provided by the module:\n\nThe available domain categories in are represented as constants in the module:\n\nThe available address class categories in are represented as constants in the module:\n\nWhen searching for a symbol, the desired domain constant can be passed verbatim to the lookup function.\n\nFor more complex searches, there is a corresponding set of constants, each named after one of the preceding constants, but with the ‘ ’ prefix replacing the ‘ ’ prefix; for example, . These may be or’d together to form a search constant.\n\nAccess to symbol table data maintained by GDB on the inferior is exposed to Guile via two objects: (symtab-and-line) and . Symbol table and line data for a frame is returned from the procedure. See Frames In Guile.\n\nFor more information on GDB’s symbol table management, see Examining the Symbol Table.\n\nThe following symtab-related procedures are provided by the module:\n\nThe following symtab-and-line-related procedures are provided by the module:\n\nBreakpoints in Guile are represented by objects of type . New breakpoints can be created with the Guile function, and then added to GDB with the Guile function. This two-step approach is taken to separate out the side-effect of adding the breakpoint to GDB from .\n\nSupport is also provided to view and manipulate breakpoints created outside of Guile.\n\nThe following breakpoint-related procedures are provided by the module:\n\nA lazy string is a string whose contents is not retrieved or encoded until it is needed.\n\nA is represented in GDB as an that points to a region of memory, an that will be used to encode that region of memory, and a to delimit the region of memory that represents the string. The difference between a and a string wrapped within a is that a will be treated differently by GDB when printing. A is retrieved and encoded during printing, while a wrapping a string is immediately retrieved and encoded on creation.\n\nThe following lazy-string-related procedures are provided by the module:\n\nGDB uses architecture specific parameters and artifacts in a number of its various computations. An architecture is represented by an instance of the class.\n\nThe following architecture-related procedures are provided by the module:\n\nEach architecture provides a set of predefined types, obtained by the following functions.\n\nThe disassembler can be invoked from Scheme code. Furthermore, the disassembler can take a Guile port as input, allowing one to disassemble from any source, and not just target memory.\n\nGDB provides a interface to target memory. This allows Guile code to read/write target memory using Guile’s port and bytevector functionality. The main routine is which returns a port object. One can then read/write memory using that object.\n\nA memory port is closed like any other port, with .\n\nCombined with Guile’s , memory ports provide a lot of utility. For example, to fill a buffer of 10 integers in memory, one can do something like the following.\n\nA simple iterator facility is provided to allow, for example, iterating over the set of program symbols without having to first construct a list of all of them. A useful contribution would be to add support for SRFI 41 and SRFI 45.\n\nThese functions are provided by the module to assist in using iterators.\n\nYou can assign instance of to the value of a object created with .\n\nmay refer to an index from color palette or contain components of a color from some colorspace.\n\nWhen color is initialized, its color space must be specified. The available color spaces are represented by constants defined in the module:\n\nWhen a new object file is read (for example, due to the command, or because the inferior has loaded a shared library), GDB will look for Guile support scripts in two ways: and the section. See Auto-loading extensions.\n\nThe auto-loading feature is useful for supplying application-specific debugging commands and scripts.\n\nAuto-loading can be enabled or disabled, and the list of auto-loaded scripts can be printed.\n\nWhen reading an auto-loaded file, GDB sets the current objfile. This is available via the procedure (see Objfiles In Guile). This can be useful for registering objfile-specific pretty-printers.\n\nGDB comes with several modules to assist writing Guile code.\n\nThis module provides a collection of utilities for working with pretty-printers.\n\nThis module provides a collection of utilities for working with objects.\n\nGDB provides two mechanisms for automatically loading extensions when a new object file is read (for example, due to the command, or because the inferior has loaded a shared library): (see The file) and the section of modern file formats like ELF (see The section). For a discussion of the differences between these two approaches see Which flavor to choose?.\n\nThe auto-loading feature is useful for supplying application-specific debugging commands and features.\n\nAuto-loading can be enabled or disabled, and the list of auto-loaded scripts can be printed. See the ‘ ’ section of each extension language for more information. For GDB command files see Auto-loading sequences. For Python files see Python Auto-loading.\n\nNote that loading of this script file also requires accordingly configured (see Auto-loading safe path).\n\nWhen a new object file is read, GDB looks for a file named (we call it below), where is the object file’s name and where is the file extension for the extension language:\n\nis formed by ensuring that the file name of is absolute, following all symlinks, and resolving and components, and appending the suffix. If this file exists and is readable, GDB will evaluate it as a script in the specified extension language.\n\nIf this file does not exist, then GDB will look for file in all of the directories as specified below. (On MS-Windows/MS-DOS, the drive letter of the executable’s leading directories is converted to a one-letter subdirectory, i.e. is converted to , because Windows filesystems disallow colons in file names.)\n\nNote that loading of these files requires an accordingly configured (see Auto-loading safe path).\n\nFor object files using suffix GDB tries to load first the scripts normally according to its filename. But if no scripts are found GDB also tries script filenames matching the object file without its suffix. This stripping is case insensitive and it is attempted on any platform. This makes the script filenames compatible between Unix and MS-Windows hosts.\n\nGDB does not track which files it has already auto-loaded this way. GDB will load the associated script every time the corresponding is opened. So your file should be careful to avoid errors if it is evaluated more than once.\n\nFor systems using file formats like ELF and COFF, when GDB loads a new object file it will look for a special section named . If this section exists, its contents is a list of null-terminated entries specifying scripts to load. Each entry begins with a non-null prefix byte that specifies the kind of entry, typically the extension language and whether the script is in a file or inlined in .\n\nThe following entries are supported:\n\nIf the entry specifies a file, GDB will look for the file first in the current directory and then along the source search path (see Specifying Source Directories), except that is not searched, since the compilation directory is not relevant to scripts.\n\nFile entries can be placed in section with, for example, this GCC macro for Python scripts.\n\nFor Guile scripts, replace with . Then one can reference the macro in a header or source file like this:\n\nThe script name may include directories if desired.\n\nNote that loading of this script file also requires accordingly configured (see Auto-loading safe path).\n\nIf the macro invocation is put in a header, any application or library using this header will get a reference to the specified script, and with the use of attributes on the section, the linker will remove duplicates.\n\nScript text entries allow to put the executable script in the entry itself instead of loading it from a file. The first line of the entry, everything after the prefix byte and up to the first newline ( ) character, is the script name, and must not contain any kind of space character, e.g., spaces or tabs. The rest of the entry, up to the trailing null byte, is the script to execute in the specified language. The name needs to be unique among all script names, as GDB executes each script only once based on its name.\n\nHere is an example from file in the GDB testsuite.\n\nLoading of inlined scripts requires a properly configured (see Auto-loading safe path). The path to specify in is the path of the file containing the section.\n\nGiven the multiple ways of auto-loading extensions, it might not always be clear which one to choose. This section provides some guidance.\n\nBenefits of the way:\n• Can be used with file formats that don’t support multiple sections.\n• Ease of finding scripts for public libraries. Scripts specified in the section are searched for in the source search path. For publicly installed libraries, e.g., , there typically isn’t a source directory in which to find the script.\n\nBenefits of the way:\n• Works with static linking. Scripts for libraries done the way require an objfile to trigger their loading. When an application is statically linked the only objfile available is the executable, and it is cumbersome to attach all the scripts from all the input libraries to the executable’s script.\n• Works with classes that are entirely inlined. Some classes can be entirely inlined, and thus there may not be an associated shared library to attach a script to.\n• Scripts needn’t be copied out of the source tree. In some circumstances, apps can be built out of large collections of internal libraries, and the build infrastructure necessary to install the scripts in a place where GDB can find them is cumbersome. It may be easier to specify the scripts in the section as relative paths, and add a path to the top of the source tree to the source search path.\n\nThe Guile and Python extension languages do not share any state, and generally do not interfere with each other. There are some things to be aware of, however.\n\nPython was GDB’s first extension language, and to avoid breaking existing behavior Python comes first. This is generally solved by the “first one wins” principle. GDB maintains a list of enabled extension languages, and when it makes a call to an extension language, (say to pretty-print a value), it tries each in turn until an extension language indicates it has performed the request (e.g., has returned the pretty-printed form of a value). This extends to errors while performing such requests: If an error happens while, for example, trying to pretty-print an object then the error is reported and any following extension languages are not tried.\n\nGDB supports multiple command interpreters, and some command infrastructure to allow users or user interface writers to switch between interpreters or run commands in other interpreters.\n\nGDB currently supports two command interpreters, the console interpreter (sometimes called the command-line interpreter or CLI) and the machine interface interpreter (or GDB/MI). This manual describes both of these interfaces in great detail.\n\nBy default, GDB will start with the console interpreter. However, the user may choose to start GDB with another interpreter by specifying the or startup options. Defined interpreters include:\n\nYou may execute commands in any interpreter from the current interpreter using the appropriate command. If you are running the console interpreter, simply use the command:\n\nGDB/MI has a similar command, although it is only available in versions of GDB which support GDB/MI version 2 (or greater).\n\nNote that only changes the interpreter for the duration of the specified command. It does not change the interpreter permanently.\n\nAlthough you may only choose a single interpreter at startup, it is possible to run an independent interpreter on a specified input/output device (usually a tty).\n\nFor example, consider a debugger GUI or IDE that wants to provide a GDB console view. It may do so by embedding a terminal emulator widget in its GUI, starting GDB in the traditional command-line mode with stdin/stdout/stderr redirected to that terminal, and then creating an MI interpreter running on a specified input/output device. The console interpreter created by GDB at startup handles commands the user types in the terminal widget, while the GUI controls and synchronizes state with GDB using the separate MI interpreter.\n\nTo start a new secondary user interface running MI, use the command:\n\nThe parameter specifies the interpreter to run. This accepts the same values as the command. For example, ‘ ’, ‘ ’, ‘ ’, etc. The parameter specifies the name of the bidirectional file the interpreter uses for input/output, usually the name of a pseudoterminal slave on Unix systems. For example:\n\nThe GDB Text User Interface (TUI) is a terminal interface which uses the library to show the source file, the assembly output, the program registers and GDB commands in separate text windows. The TUI mode is supported only on platforms where a suitable version of the library is available.\n\nThe TUI mode is enabled by default when you invoke GDB as ‘ ’. You can also switch in and out of TUI mode while GDB runs by using various TUI commands and key bindings, such as or . See TUI Commands, and TUI Key Bindings.\n\nIn TUI mode, GDB can display several text windows:\n\nThe source and assembly windows show the current program position by highlighting the current line and marking it with a ‘ ’ marker. By default, source and assembly code styling is disabled for the highlighted text, but you can enable it with the command. See Output Styling.\n\nBreakpoints are indicated with two markers. The first marker indicates the breakpoint type:\n\nThe second marker indicates whether the breakpoint is enabled or not:\n\nThe source, assembly and register windows are updated when the current thread changes, when the frame changes, or when the program counter changes.\n\nThese windows are not all visible at the same time. The command window is always visible. The others can be arranged in several layouts:\n\nThese are the standard layouts, but other layouts can be defined.\n\nA status line above the command window shows the following information:\n\nThe TUI installs several key bindings in the readline keymaps (see Command Line Editing). The following key bindings are installed for both TUI mode and the GDB standard mode.\n\nThe following key bindings only work in the TUI mode:\n\nBecause the arrow keys scroll the active window in the TUI mode, they are not available for their normal use by readline unless the command window has the focus. When another window is active, you must use other readline key bindings such as , , and to control the command window.\n\nThe TUI also provides a SingleKey mode, which binds several frequently used GDB commands to single keys. Type to switch into this mode, where the following key bindings are used:\n\nOther keys temporarily switch to the GDB command prompt. The key that was pressed is inserted in the editing buffer so that it is possible to type most GDB commands without interaction with the TUI SingleKey mode. Once the command is entered the TUI SingleKey mode is restored. The only way to permanently leave this mode is by typing or .\n\nIf GDB was built with Readline 8.0 or later, the TUI SingleKey keymap will be named ‘ ’. This can be used in to add additional bindings to this keymap.\n\nIf the curses library supports the mouse, the TUI supports mouse actions.\n\nThe mouse wheel scrolls the appropriate window under the mouse cursor.\n\nThe TUI itself does not directly support copying/pasting with the mouse. However, on Unix terminals, you can typically press and hold the key on your keyboard to temporarily bypass GDB’s TUI and access the terminal’s native mouse copy/paste functionality (commonly, click-drag-release or double-click to select text, middle-click to paste). This copy/paste works with the terminal’s selection buffer, as opposed to the TUI’s buffer. Alternatively, to disable mouse support in the TUI entirely and give the terminal control over mouse clicks, turn off the setting (see set tui mouse-events).\n\nPython extensions can react to mouse clicks (see Window.click).\n\nThe TUI has specific commands to control the text windows. These commands are always available, even when GDB is not in the TUI mode. When GDB is in the standard mode, most of these commands will automatically switch to the TUI mode.\n\nNote that if GDB’s is not connected to a terminal, or GDB has been started with the machine interface interpreter (see The GDB/MI Interface), most of these commands will fail with an error, because it would not be possible or desirable to enable curses window management.\n\nSeveral configuration variables control the appearance of TUI windows.\n\nNote that the colors of the TUI borders can be controlled using the appropriate commands. See Output Styling.\n\nA special interface allows you to use GNU Emacs to view (and edit) the source files for the program you are debugging with GDB.\n\nTo use this interface, use the command in Emacs. Give the executable file you want to debug as an argument. This command starts GDB as a subprocess of Emacs, with input and output through a newly created Emacs buffer.\n\nRunning GDB under Emacs can be just like running GDB normally except for two things:\n• All “terminal” input and output goes through an Emacs buffer, called the GUD buffer. This applies both to GDB commands and their output, and to the input and output done by the program you are debugging. This is useful because it means that you can copy the text of previous commands and input them again; you can even use parts of the output in this way. All the facilities of Emacs’ Shell mode are available for interacting with your program. In particular, you can send signals the usual way—for example, for an interrupt, for a stop.\n• GDB displays source code through Emacs. Each time GDB displays a stack frame, Emacs automatically finds the source file for that frame and puts an arrow (‘ ’) at the left margin of the current line. Emacs uses a separate buffer for source display, and splits the screen to show both your GDB session and the source. Explicit GDB or search commands still produce output as usual, but you probably have no reason to use them from Emacs.\n\nWe call this text command mode. Emacs 22.1, and later, also uses a graphical mode, enabled by default, which provides further buffers that can control the execution and describe the state of your program. See GDB Graphical Interface in .\n\nIf you specify an absolute file name when prompted for the argument, then Emacs sets your current working directory to where your program resides. If you only specify the file name, then Emacs sets your current working directory to the directory associated with the previous buffer. In this case, GDB may find your program by searching your environment’s variable, but on some operating systems it might not find the source. So, although the GDB input and output session proceeds normally, the auxiliary buffer does not display the current source and line of execution.\n\nThe initial working directory of GDB is printed on the top line of the GUD buffer and this serves as a default for the commands that specify files for GDB to operate on. See Commands to Specify Files.\n\nBy default, calls the program called . If you need to call GDB by a different name (for example, if you keep several configurations around, with different names) you can customize the Emacs variable to run the one you want.\n\nIn the GUD buffer, you can use these special Emacs commands in addition to the standard Shell mode commands:\n\nIn any source file, the Emacs command ( ) tells GDB to set a breakpoint on the source line point is on.\n\nIn text command mode, if you type , Emacs displays a separate frame which shows a backtrace when the GUD buffer is current. Move point to any frame in the stack and type to make it become the current frame and display the associated source in the source buffer. Alternatively, click to make the selected frame become the current one. In graphical mode, the speedbar displays watch expressions.\n\nIf you accidentally delete the source-display buffer, an easy way to get it back is to type the command in the GDB buffer, to request a frame display; when you run under Emacs, this recreates the source buffer if necessary to show you the context of the current frame.\n\nThe source files displayed in Emacs are in ordinary Emacs buffers which are visiting the source files in the usual way. You can edit the files with these buffers if you wish; but keep in mind that GDB communicates with Emacs in terms of line numbers. If you add or delete lines from the text, the line numbers that GDB knows cease to correspond properly with the code.\n\nA more detailed description of Emacs’ interaction with GDB is given in the Emacs manual (see Debuggers in ).\n\nGDB/MI is a line based machine oriented text interface to GDB and is activated by specifying using the command line option (see Mode Options). It is specifically intended to support the development of systems which use the debugger as just one small component of a larger system.\n\nThis chapter is a specification of the GDB/MI interface. It is written in the form of a reference manual.\n\nNote that GDB/MI is still under construction, so some of the features described below are incomplete and subject to change (see GDB/MI Development and Front Ends).\n\nThis chapter uses the following notation:\n• indicates that is optional: it may or may not be given.\n• means that inside the parentheses may repeat zero or more times.\n• means that inside the parentheses may repeat one or more times.\n• means that inside the parentheses occurs exactly once.\n\nInteraction of a GDB/MI frontend with GDB involves three parts—commands sent to GDB, responses to those commands and notifications. Each command results in exactly one response, indicating either successful completion of the command, or an error. For the commands that do not resume the target, the response contains the requested information. For the commands that resume the target, the response only indicates whether the target was successfully resumed. Notifications is the mechanism for reporting changes in the state of the target, or in GDB state, that cannot conveniently be associated with a command and reported as part of that command response.\n\nThe important examples of notifications are:\n• Exec notifications. These are used to report changes in target state—when a target is resumed, or stopped. It would not be feasible to include this information in response of resuming commands, because one resume commands can result in multiple events in different threads. Also, quite some time may pass before any event happens in the target, while a frontend needs to know whether the resuming command itself was successfully executed.\n• Console output, and status notifications. Console output notifications are used to report output of CLI commands, as well as diagnostics for other commands. Status notifications are used to report the progress of a long-running operation. Naturally, including this information in command response would mean no output is produced until the command is finished, which is undesirable.\n• General notifications. Commands may have various side effects on the GDB or target state beyond their official purpose. For example, a command may change the selected thread. Although such changes can be included in command response, using notification allows for more orthogonal frontend design.\n\nThere’s no guarantee that whenever an MI command reports an error, GDB or the target are in any specific state, and especially, the state is not reverted to the state before the MI command was processed. Therefore, whenever an MI command results in an error, we recommend that the frontend refreshes all the information shown in the user interface.\n\nIn most cases when GDB accesses the target, this access is done in context of a specific thread and frame (see Frames). Often, even when accessing global data, the target requires that a thread be specified. The CLI interface maintains the selected thread and frame, and supplies them to target on each command. This is convenient, because a command line user would not want to specify that information explicitly on each command, and because user interacts with GDB via a single terminal, so no confusion is possible as to what thread and frame are the current ones.\n\nIn the case of MI, the concept of selected thread and frame is less useful. First, a frontend can easily remember this information itself. Second, a graphical frontend can have more than one window, each one used for debugging a different thread, and the frontend might want to access additional threads for internal purposes. This increases the risk that by relying on implicitly selected thread, the frontend may be operating on a wrong one. Therefore, each MI command should explicitly specify which thread and frame to operate on. To make it possible, each MI command accepts the ‘ ’ and ‘ ’ options, the value to each is GDB global identifier for thread and frame to operate on.\n\nUsually, each top-level window in a frontend allows the user to select a thread and a frame, and remembers the user selection for further operations. However, in some cases GDB may suggest that the current thread or frame be changed. For example, when stopping on a breakpoint it is reasonable to switch to the thread where breakpoint is hit. For another example, if the user issues the CLI ‘ ’ or ‘ ’ commands via the frontend, it is desirable to change the frontend’s selection to the one specified by user. GDB communicates the suggestion to change current thread and frame using the ‘ ’ notification.\n\nNote that historically, MI shares the selected thread with CLI, so frontends used the to execute commands in the right context. However, getting this to work right is cumbersome. The simplest way is for frontend to emit command before every command. This doubles the number of commands that need to be sent. The alternative approach is to suppress if the selected thread in GDB is supposed to be identical to the thread the frontend wants to operate on. However, getting this optimization right can be tricky. In particular, if the frontend sends several commands to GDB, and one of the commands changes the selected thread, then the behavior of subsequent commands will change. So, a frontend should either wait for response from such problematic commands, or explicitly add for all subsequent commands. No frontend is known to do this exactly right, so it is suggested to just always pass the ‘ ’ and ‘ ’ options.\n\nThe execution of several commands depends on which language is selected. By default, the current language (see show language) is used. But for commands known to be language-sensitive, it is recommended to use the ‘ ’ option. This option takes one argument, which is the name of the language to use while executing the command. For instance:\n\nThe valid language names are the same names accepted by the ‘ ’ command (see Manually), excluding ‘ ’, ‘ ’ or ‘ ’.\n\nOn some targets, GDB is capable of processing MI commands even while the target is running. This is called asynchronous command execution (see Background Execution). The frontend may specify a preference for asynchronous execution using the command, which should be emitted before either running the executable or attaching to the target. After the frontend has started the executable or attached to the target, it can find if asynchronous execution is enabled using the command.\n\nNote: In GDB version 7.7 and earlier, this option was called instead of , and it had the effect of both putting MI in asynchronous mode and making CLI background commands possible. CLI background commands are now always possible “out of the box” if the target supports them. The old spelling is kept as a deprecated alias for backwards compatibility.\n\nEven if GDB can accept a command while target is running, many commands that access the target do not work when the target is running. Therefore, asynchronous command execution is most useful when combined with non-stop mode (see Non-Stop Mode). Then, it is possible to examine the state of one thread, while other threads are running.\n\nWhen a given thread is running, MI commands that try to access the target in the context of that thread may not work, or may work only on some targets. In particular, commands that try to operate on thread’s stack will not work, on any target. Commands that read memory, or modify breakpoints, may work or not work, depending on the target. Note that even commands that operate on global state, such as , , and breakpoint commands, still access the target in the context of a specific thread, so frontend should try to find a stopped thread and perform the operation on that thread (using the ‘ ’ option).\n\nWhich commands will work in the context of a running thread is highly target dependent. However, the two commands , to stop a thread, and , to find the state of a thread, will always work.\n\nGDB may be used to debug several processes at the same time. On some platforms, GDB may support debugging of several hardware systems, each one having several cores with several different processes running on each core. This section describes the MI mechanism to support such debugging scenarios.\n\nThe key observation is that regardless of the structure of the target, MI can have a global list of threads, because most commands that accept the ‘ ’ option do not need to know what process that thread belongs to. Therefore, it is not necessary to introduce neither additional ‘ ’ option, nor an notion of the current process in the MI interface. The only strictly new feature that is required is the ability to find how the threads are grouped into processes.\n\nTo allow the user to discover such grouping, and to support arbitrary hierarchy of machines/cores/processes, MI introduces the concept of a thread group. Thread group is a collection of threads and other thread groups. A thread group always has a string identifier, a type, and may have additional attributes specific to the type. A new command, , returns the list of top-level thread groups, which correspond to processes that GDB is debugging at the moment. By passing an identifier of a thread group to the command, it is possible to obtain the members of specific thread group.\n\nTo allow the user to easily discover processes, and other objects, he wishes to debug, a concept of available thread group is introduced. Available thread group is an thread group that GDB is not debugging, but that can be attached to, using the command. The list of available top-level thread groups can be obtained using ‘ ’. In general, the content of a thread group may be only retrieved only after attaching to that thread group.\n\nThread groups are related to inferiors (see Inferiors Connections and Programs). Each inferior corresponds to a thread group of a special type ‘ ’, and some additional operations are permitted on such thread groups.\n• The CLI commands are still handled by the MI interpreter; their output is described below.\n• The , when present, is passed back when the command finishes.\n• Some MI commands accept optional arguments as part of the parameter list. Each option is identified by a leading ‘ ’ (dash) and may be followed by an optional argument parameter. Options occur first in the parameter list and can be delimited from normal parameters using ‘ ’ (this is useful when some parameters begin with a dash).\n• We want easy access to the existing CLI syntax (for debugging).\n• We want it to be easy to spot a MI operation.\n\nThe output from GDB/MI consists of zero or more out-of-band records followed, optionally, by a single result record. This result record is for the most recent command. The sequence of output records is terminated by ‘ ’.\n\nIf an input command was prefixed with a then the corresponding output for that command will also be prefixed by that same .\n• All output sequences end in a single line containing a period.\n• The is from the corresponding request. Note that for all async output, while the token is allowed by the grammar and may be output by future versions of GDB for select async output messages, it is generally omitted. Frontends should treat all async output as reporting general changes in the state of the target and there should be no need to associate async output to any prior command.\n• contains on-going status information about the progress of a slow operation. It can be discarded. All status output is prefixed by ‘ ’.\n• contains asynchronous state change on the target (stopped, started, disappeared). All async output is prefixed by ‘ ’.\n• contains supplementary information that the client should handle (e.g., a new breakpoint information). All notify output is prefixed by ‘ ’.\n• is output that should be displayed as is in the console. It is the textual response to a CLI command. All the console output is prefixed by ‘ ’.\n• is the output produced by the target program. All the target output is prefixed by ‘ ’.\n• is output text coming from GDB’s internals, for instance messages that should be displayed as part of an error log. All the log output is prefixed by ‘ ’.\n• New GDB/MI commands should only output containing .\n\nSee GDB/MI Stream Records, for more details about the various output records.\n\nFor the developers convenience CLI commands can be entered directly, but there may be some unexpected behavior. For example, commands that query the user will behave as if the user replied yes, breakpoint command lists are not executed and some CLI commands, such as , and , prompt for further input with ‘ ’, which is not valid MI output.\n\nThis feature may be removed at some stage in the future and it is recommended that front ends use the command (see -interpreter-exec).\n\nThe application which takes the MI output and presents the state of the program being debugged to the user is called a front end.\n\nSince GDB/MI is used by a variety of front ends to GDB, changes to the MI interface may break existing usage. This section describes how the protocol changes and how to request previous version of the protocol when it does.\n\nSome changes in MI need not break a carefully designed front end, and for these the MI version will remain unchanged. The following is a list of changes that may occur within one level, so front ends should parse MI output in a way that can handle them:\n• New MI commands may be added.\n• New fields may be added to the output of any MI command.\n• The range of values for fields with specified values, e.g., (see -var-update) may be extended.\n\nIf the changes are likely to break front ends, the MI version level will be increased by one. The new versions of the MI protocol are not compatible with the old versions. Old versions of MI remain available, allowing front ends to keep using them until they are modified to use the latest MI version.\n\nSince always points to the latest MI version, it is recommended that front ends request a specific version of MI when launching GDB (e.g. ) to make sure they get an interpreter with the MI version they expect.\n\nThe following table gives a summary of the released versions of the MI interface: the version number, the version of GDB in which it first appeared and the breaking changes compared to the previous version.\n\nIf your front end cannot yet migrate to a more recent version of the MI protocol, you can nevertheless selectively enable specific features available in those recent MI versions, using the following commands:\n\nThe best way to avoid unexpected changes in MI that might break your front end is to make your project known to GDB developers and follow development on gdb@sourceware.org and gdb-patches@sourceware.org.\n\nIn addition to a number of out-of-band notifications, the response to a GDB/MI command includes one of the following result indications:\n\nGDB internally maintains a number of output streams: the console, the target, and the log. The output intended for each of these streams is funneled through the GDB/MI interface using stream records.\n\nEach stream record begins with a unique prefix character which identifies its stream (see GDB/MI Output Syntax). In addition to the prefix, each stream record contains a . This is either raw text (with an implicit new line) or a quoted C string (which does not contain an implicit newline).\n\nAsync records are used to notify the GDB/MI client of additional changes that have occurred. Those changes can either be a consequence of GDB/MI commands (e.g., a breakpoint modified) or a result of target activity (e.g., target stopped).\n\nThe following is the list of possible async records:\n\nWhen GDB reports information about a breakpoint, a tracepoint, a watchpoint, or a catchpoint, it uses a tuple with the following fields:\n\nA location in a multi-location breakpoint is represented as a tuple with the following fields:\n\nFor example, here is what the output of (see GDB/MI Breakpoint Commands) might be:\n\nResponse from many MI commands includes an information about stack frame. This information is a tuple that may have the following fields:\n\nWhenever GDB has to report an information about a thread, it uses a tuple with the following fields. The fields are always present unless stated otherwise.\n\nWhenever a record is emitted because the program stopped after hitting an exception catchpoint (see Set Catchpoints), GDB provides the name of the exception that was raised via the field. Also, for exceptions that were raised with an exception message, GDB provides that message via the field.\n\nThis subsection presents several simple examples of interaction using the GDB/MI interface. In these examples, ‘ ’ means that the following line is passed to GDB/MI as input, while ‘ ’ means the output received from GDB/MI.\n\nNote the line breaks shown in the examples are here only for readability, they don’t appear in the real output.\n\nSetting a breakpoint generates synchronous output which contains detailed information of the breakpoint.\n\nProgram execution generates asynchronous records and MI gives the reason that execution stopped.\n\nPlease note that ‘ ’ is printed immediately, but it might take some time for GDB to actually exit. During that time, GDB performs necessary cleanups, including killing programs being debugged or disconnecting from debug hardware, so the frontend should wait till GDB exits and should only forcibly kill GDB if it fails to exit in reasonable time.\n\nHere’s what happens if you pass a non-existent command:\n\nThe remaining sections describe blocks of commands. Each block of commands is laid out in a fashion similar to this section.\n\nThe motivation for this collection of commands.\n\nA brief introduction to this collection of commands as a whole.\n\nFor each command in the block, the following is described:\n\nThe corresponding GDB CLI command(s), if any.\n\nExample(s) formatted for readability. Some of the described commands have not been implemented yet and these are labeled N.A. (not available).\n\nThe breakpoint number is not in effect until it has been hit times. To see how this is reflected in the output of the ‘ ’ command, see the description of the ‘ ’ command below.\n\nThe corresponding GDB command is ‘ ’.\n\nSpecifies the CLI commands that should be executed when breakpoint is hit. The parameters to are the commands. If no command is specified, any previously-set commands are cleared. See Break Commands. Typical use of this functionality is tracing a program, that is, printing of values of some variables whenever breakpoint is hit and then continuing.\n\nThe corresponding GDB command is ‘ ’.\n\nBreakpoint will stop the program only if the condition in is true. The condition becomes part of the ‘ ’ output (see the description of the ‘ ’ command below). If the ‘ ’ flag is passed, the condition is forcibly defined even when it is invalid for all locations of breakpoint . If the argument is omitted, breakpoint becomes unconditional.\n\nThe corresponding GDB command is ‘ ’.\n\nDelete the breakpoint(s) whose number(s) are specified in the argument list. This is obviously reflected in the breakpoint list.\n\nThe corresponding GDB command is ‘ ’.\n\nDisable the named (s). The field ‘ ’ in the break list is now set to ‘ ’ for the named (s).\n\nThe corresponding GDB command is ‘ ’.\n\nThe corresponding GDB command is ‘ ’.\n\nThe result is a table of breakpoints. See GDB/MI Breakpoint Information, for details on the format of each breakpoint in the table.\n\nThe corresponding GDB command is ‘ ’.\n\nIf specified, , can be one of:\n\nThe possible optional parameters of this command are:\n\nSee GDB/MI Breakpoint Information, for details on the format of the resulting breakpoint.\n\nNote: this format is open to change.\n\nThe corresponding GDB commands are ‘ ’, ‘ ’, ‘ ’, and ‘ ’.\n\nInsert a new dynamic print breakpoint at the given location. See Dynamic Printf. is the format to use, and any remaining arguments are passed as expressions to substitute.\n\nIf supplied, and may be specified the same way as for the command. See -break-insert.\n\nThe possible optional parameters of this command are:\n\nSee GDB/MI Breakpoint Information, for details on the format of the resulting breakpoint.\n\nThe corresponding GDB command is ‘ ’.\n\nDisplays the list of inserted breakpoints, showing the following fields:\n\nIf there are no breakpoints, watchpoints, tracepoints, or catchpoints, the field is an empty list.\n\nThe corresponding GDB command is ‘ ’.\n\nHere’s an example of the result when there are no breakpoints:\n\nSet the passcount for tracepoint to . If the breakpoint referred to by is not a tracepoint, error is emitted. This corresponds to CLI command ‘ ’.\n\nCreate a watchpoint. With the ‘ ’ option it will create an access watchpoint, i.e., a watchpoint that triggers either on a read from or on a write to the memory location. With the ‘ ’ option, the watchpoint created is a read watchpoint, i.e., it will trigger only when the memory location is accessed for reading. Without either of the options, the watchpoint created is a regular watchpoint, i.e., it will trigger when the memory location is accessed for writing. See Setting Watchpoints.\n\nNote that ‘ ’ will report a single list of watchpoints and breakpoints inserted.\n\nThe corresponding GDB commands are ‘ ’, ‘ ’, and ‘ ’.\n\nSetting a watchpoint on a variable in the function:\n\nSetting a watchpoint on a variable local to a function. GDB will stop the program execution twice: first for the variable changing value, then for the watchpoint going out of scope.\n\nListing breakpoints and watchpoints, at different points in the program execution. Note that once the watchpoint goes out of scope, it is deleted.\n\nAdd a catchpoint for library load events. If the ‘ ’ option is used, the catchpoint is a temporary one (see Setting Breakpoints). If the ‘ ’ option is used, the catchpoint is created in a disabled state. The ‘ ’ argument is a regular expression used to match the name of the loaded library.\n\nThe corresponding GDB command is ‘ ’.\n\nAdd a catchpoint for library unload events. If the ‘ ’ option is used, the catchpoint is a temporary one (see Setting Breakpoints). If the ‘ ’ option is used, the catchpoint is created in a disabled state. The ‘ ’ argument is a regular expression used to match the name of the unloaded library.\n\nThe corresponding GDB command is ‘ ’.\n\nThe following GDB/MI commands can be used to create catchpoints that stop the execution when Ada exceptions are being raised.\n\nThe possible optional parameters for this command are:\n\nThe corresponding GDB command is ‘ ’.\n\nAdd a catchpoint stopping when Ada exceptions are raised. By default, the command stops the program when any Ada exception gets raised. But it is also possible, by using some of the optional parameters described below, to create more selective catchpoints.\n\nThe possible optional parameters for this command are:\n\nThe corresponding GDB commands are ‘ ’ and ‘ ’.\n\nAdd a catchpoint stopping when Ada exceptions are handled. By default, the command stops the program when any Ada exception gets handled. But it is also possible, by using some of the optional parameters described below, to create more selective catchpoints.\n\nThe possible optional parameters for this command are:\n\nThe corresponding GDB command is ‘ ’.\n\nThe following GDB/MI commands can be used to create catchpoints that stop the execution when C exceptions are being throw, rethrown, or caught.\n\nStop when the debuggee throws a C exception. If is given, then only exceptions whose type matches the regular expression will be caught.\n\nIf ‘ ’ is given, then the catchpoint is enabled only for one stop, the catchpoint is automatically deleted after stopping once for the event.\n\nThe corresponding GDB commands are ‘ ’ and ‘ ’ (see Set Catchpoints).\n\nStop when a C exception is re-thrown. If is given, then only exceptions whose type matches the regular expression will be caught.\n\nIf ‘ ’ is given, then the catchpoint is enabled only for one stop, the catchpoint is automatically deleted after the first event is caught.\n\nThe corresponding GDB commands are ‘ ’ and ‘ ’ (see Set Catchpoints).\n\nStop when the debuggee catches a C exception. If is given, then only exceptions whose type matches the regular expression will be caught.\n\nIf ‘ ’ is given, then the catchpoint is enabled only for one stop, the catchpoint is automatically deleted after the first event is caught.\n\nThe corresponding GDB commands are ‘ ’ and ‘ ’ (see Set Catchpoints).\n\nSet the inferior program arguments, to be used in the next ‘ ’.\n\nThe corresponding GDB command is ‘ ’.\n\nThe corresponding GDB command is ‘ ’.\n\nAdd directories to beginning of search path for source files. If the ‘ ’ option is used, the search path is reset to the default search path. If directories are supplied in addition to the ‘ ’ option, the search path is first reset and then addition occurs as normal. Multiple directories may be specified, separated by blanks. Specifying multiple directories in a single command results in the directories added to the beginning of the search path in the same order they were presented in the command. If blanks are needed as part of a directory name, double-quotes should be used around the name. In the command output, the path will show up separated by the system directory-separator character. The directory-separator character must not be used in any directory name. If no directories are specified, the current search path is displayed.\n\nThe corresponding GDB command is ‘ ’.\n\nAdd directories to beginning of search path for object files. If the ‘ ’ option is used, the search path is reset to the original search path that existed at gdb start-up. If directories are supplied in addition to the ‘ ’ option, the search path is first reset and then addition occurs as normal. Multiple directories may be specified, separated by blanks. Specifying multiple directories in a single command results in the directories added to the beginning of the search path in the same order they were presented in the command. If blanks are needed as part of a directory name, double-quotes should be used around the name. In the command output, the path will show up separated by the system directory-separator character. The directory-separator character must not be used in any directory name. If no directories are specified, the current path is displayed.\n\nThe corresponding GDB command is ‘ ’.\n\nThe corresponding GDB command is ‘ ’.\n\nReports information about either a specific thread, if the parameter is present, or about all threads. is the thread’s global thread ID. When printing information about all threads, also reports the global ID of the current thread.\n\nThe ‘ ’ command prints the same information about all threads.\n\nThe result contains the following attributes:\n\nProduces a list of the currently known global GDB thread ids. At the end of the list it also prints the total number of such threads.\n\nThis command is retained for historical reasons, the command should be used instead.\n\nPart of ‘ ’ supplies the same information.\n\nMake thread with global thread number the current thread. It prints the number of the new current thread, and the topmost frame for that thread.\n\nThis command is deprecated in favor of explicitly using the ‘ ’ option to each command.\n\nThe corresponding GDB command is ‘ ’.\n\nReports information about either a specific Ada task, if the parameter is present, or about all Ada tasks.\n\nThe ‘ ’ command prints the same information about all Ada tasks (see Ada Tasks).\n\nThe result is a table of Ada tasks. The following columns are defined for each Ada task:\n\nThese are the asynchronous commands which generate the out-of-band record ‘ ’. Currently GDB only really executes asynchronously with remote targets and this interaction is mimicked in other cases.\n\nResumes the execution of the inferior program, which will continue to execute until it reaches a debugger stop event. If the ‘ ’ option is specified, execution resumes in reverse until it reaches a stop event. Stop events may include\n• the end of the process (or its beginning under ‘ ’)\n• the end or beginning of a replay log if one is being used.\n\nIn all-stop mode (see All-Stop Mode), may resume only one thread, or all threads, depending on the value of the ‘ ’ variable. If ‘ ’ is specified, all threads (in all inferiors) will be resumed. The ‘ ’ option is ignored in all-stop mode. If the ‘ ’ options is specified, then all threads in that thread group are resumed.\n\nThe corresponding GDB corresponding is ‘ ’.\n\nFor a ‘ ’ stopped reason, when the breakpoint encountered has multiple locations, the field ‘ ’ is followed by the field ‘ ’.\n\nResumes the execution of the inferior program until the current function is exited. Displays the results returned by the function. If the ‘ ’ option is specified, resumes the reverse execution of the inferior program until the point where current function was called.\n\nThe corresponding GDB command is ‘ ’.\n\nFunction returning other than . The name of the internal GDB variable storing the result is printed, together with the value itself.\n\nInterrupts the background execution of the target. Note how the token associated with the stop message is the one for the execution command that has been interrupted. The token for the interrupt itself only appears in the ‘ ’ output. If the user is trying to interrupt a non-running program, an error message will be printed.\n\nNote that when asynchronous execution is enabled, this command is asynchronous just like other execution commands. That is, first the ‘ ’ response will be printed, and the target stop will be reported after that using the ‘ ’ notification.\n\nIn non-stop mode, only the context thread is interrupted by default. All threads (in all inferiors) will be interrupted if the ‘ ’ option is specified. If the ‘ ’ option is specified, all threads in that group will be interrupted.\n\nThe corresponding GDB command is ‘ ’.\n\nResumes execution of the inferior program at the address to which resolves. See Location Specifications, for a description of the different forms of .\n\nThe corresponding GDB command is ‘ ’.\n\nResumes execution of the inferior program, stopping when the beginning of the next source line is reached.\n\nIf the ‘ ’ option is specified, resumes reverse execution of the inferior program, stopping at the beginning of the previous source line. If you issue this command on the first line of a function, it will take you back to the caller of that function, to the source line where the function was called.\n\nThe corresponding GDB command is ‘ ’.\n\nExecutes one machine instruction. If the instruction is a function call, continues until the function returns. If the program stops at an instruction in the middle of a source line, the address will be printed as well.\n\nIf the ‘ ’ option is specified, resumes reverse execution of the inferior program, stopping at the previous instruction. If the previously executed instruction was a return from another function, it will continue to execute in reverse until the call to that function (from the current stack frame) is reached.\n\nThe corresponding GDB command is ‘ ’.\n\nMakes current function return immediately. Doesn’t execute the inferior. Displays the new current frame.\n\nThe corresponding GDB command is ‘ ’.\n\nStarts execution of the inferior from the beginning. The inferior executes until either a breakpoint is encountered or the program exits. In the latter case the output will include an exit code, if the program has exited exceptionally.\n\nWhen neither the ‘ ’ nor the ‘ ’ option is specified, the current inferior is started. If the ‘ ’ option is specified, it should refer to a thread group of type ‘ ’, and that thread group will be started. If the ‘ ’ option is specified, then all inferiors will be started.\n\nUsing the ‘ ’ option instructs the debugger to stop the execution at the start of the inferior’s main subprogram, following the same behavior as the command (see Starting).\n\nThe corresponding GDB command is ‘ ’.\n\nAnother way the program can terminate is if it receives a signal such as . In this case, GDB/MI displays this:\n\nResumes execution of the inferior program, stopping when the beginning of the next source line is reached, if the next source line is not a function call. If it is, stop at the first instruction of the called function. If the ‘ ’ option is specified, resumes reverse execution of the inferior program, stopping at the beginning of the previously executed source line.\n\nThe corresponding GDB command is ‘ ’.\n\nResumes the inferior which executes one machine instruction. If the ‘ ’ option is specified, resumes reverse execution of the inferior program, stopping at the previously executed instruction. The output, once GDB has stopped, will vary depending on whether we have stopped in the middle of a source line or not. In the former case, the address at which the program stopped will be printed as well.\n\nThe corresponding GDB command is ‘ ’.\n\nExecutes the inferior until it reaches the address to which resolves. If there is no argument, the inferior executes until it reaches a source line greater than the current one. The reason for stopping in this case will be ‘ ’.\n\nThe corresponding GDB command is ‘ ’.\n\nGDB allows Python-based frame filters to affect the output of the MI commands relating to stack traces. As there is no way to implement this in a fully backward-compatible way, a front end must request that this functionality be enabled.\n\nOnce enabled, this feature cannot be disabled.\n\nNote that if Python support has not been compiled into GDB, this command will still succeed (and do nothing).\n\nGet info on the selected frame.\n\nThe corresponding GDB command is ‘ ’ or ‘ ’ (without arguments).\n\nReturn the depth of the stack. If the integer argument is specified, do not count beyond frames.\n\nFor a stack with frame levels 0 through 11:\n\nDisplay a list of the arguments for the frames between and (inclusive). If and are not provided, list the arguments for the whole call stack. If the two arguments are equal, show the single frame at the corresponding level. It is an error if is larger than the actual number of frames. On the other hand, may be larger than the actual number of frames, in which case only existing frames will be returned.\n\nIf is 0 or , print only the names of the variables; if it is 1 or , print also their values; and if it is 2 or , print the name, type and value for simple data types, and the name and type for arrays, structures and unions. If the option is supplied, then Python frame filters will not be executed.\n\nIf the option is specified, arguments that are not available are not listed. Partially available arguments are still displayed, however.\n\nUse of this command to obtain arguments in a single frame is deprecated in favor of the ‘ ’ command.\n\nGDB does not have an equivalent command. has a ‘ ’ command which partially overlaps with the functionality of ‘ ’.\n\nList the frames currently on the stack. For each frame it displays the following info:\n\nIf invoked without arguments, this command prints a backtrace for the whole stack. If given two integer arguments, it shows the frames whose levels are between the two arguments (inclusive). If the two arguments are equal, it shows the single frame at the corresponding level. It is an error if is larger than the actual number of frames. On the other hand, may be larger than the actual number of frames, in which case only existing frames will be returned. If the option is supplied, then Python frame filters will not be executed.\n\nThe corresponding GDB commands are ‘ ’ and ‘ ’.\n\nDisplay the local variable names for the selected frame. If is 0 or , print only the names of the variables; if it is 1 or , print also their values; and if it is 2 or , print the name, type and value for simple data types, and the name and type for arrays, structures and unions. In this last case, a frontend can immediately display the value of simple data types and create variable objects for other data types when the user wishes to explore their values in more detail. If the option is supplied, then Python frame filters will not be executed.\n\nIf the option is specified, local variables that are not available are not listed. Partially available local variables are still displayed, however.\n\nThis command is deprecated in favor of the ‘ ’ command.\n\nDisplay the names of local variables and function arguments for the selected frame. If is 0 or , print only the names of the variables; if it is 1 or , print also their values; and if it is 2 or , print the name, type and value for simple data types, and the name and type for arrays, structures and unions. If the option is supplied, then Python frame filters will not be executed.\n\nIf the option is specified, local variables and arguments that are not available are not listed. Partially available arguments and local variables are still displayed, however.\n\nChange the selected frame. Select a different frame on the stack.\n\nThis command in deprecated in favor of passing the ‘ ’ option to every command.\n\nThe corresponding GDB commands are ‘ ’, ‘ ’, ‘ ’, ‘ ’, ‘ ’, and ‘ ’.\n\nVariable objects are \"object-oriented\" MI interface for examining and changing values of expressions. Unlike some other MI interfaces that work with expressions, variable objects are specifically designed for simple and efficient presentation in the frontend. A variable object is identified by string name. When a variable object is created, the frontend specifies the expression for that variable object. The expression can be a simple variable, or it can be an arbitrary complex expression, and can even involve CPU registers. After creating a variable object, the frontend can invoke other variable object operations—for example to obtain or change the value of a variable object, or to change display format.\n\nVariable objects have hierarchical tree structure. Any variable object that corresponds to a composite type, such as structure in C, has a number of child variable objects, for example corresponding to each element of a structure. A child variable object can itself have children, recursively. Recursion ends when we reach leaf variable objects, which always have built-in types. Child variable objects are created only by explicit request, so if a frontend is not interested in the children of a particular variable object, no child will be created.\n\nFor a leaf variable object it is possible to obtain its value as a string, or set the value from a string. String value can be also obtained for a non-leaf variable object, but it’s generally a string that only indicates the type of the object, and does not list its contents. Assignment to a non-leaf variable object is not allowed.\n\nA frontend does not need to read the values of all variable objects each time the program stops. Instead, MI provides an update command that lists all variable objects whose values has changed since the last update operation. This considerably reduces the amount of data that must be transferred to the frontend. As noted above, children variable objects are created on demand, and only leaf variable objects have a real value. As result, gdb will read target memory only for leaf variables that frontend has created.\n\nThe automatic update is not always desirable. For example, a frontend might want to keep a value of some expression for future reference, and never update it. For another example, fetching memory is relatively slow for embedded targets, so a frontend might want to disable automatic update for the variables that are either not visible on the screen, or “closed”. This is possible using so called “frozen variable objects”. Such variable objects are never implicitly updated.\n\nVariable objects can be either fixed or floating. For the fixed variable object, the expression is parsed when the variable object is created, including associating identifiers to specific variables. The meaning of expression never changes. For a floating variable object the values of variables whose names appear in the expressions are re-evaluated every time in the context of the current frame. Consider this example:\n\nIf a fixed variable object for the variable is created in this function, and we enter the recursive call, the variable object will report the value of in the top-level invocation. On the other hand, a floating variable object will report the value of in the current frame.\n\nIf an expression specified when creating a fixed variable object refers to a local variable, the variable object becomes bound to the thread and frame in which the variable object is created. When such variable object is updated, GDB makes sure that the thread/frame combination the variable object is bound to still exists, and re-evaluates the variable object in context of that thread/frame.\n\nThe following is the complete set of GDB/MI operations defined to access this functionality:\n\nIn the next subsection we describe each operation in detail and suggest how it can be used.\n\nDescription And Use of Operations on Variable Objects\n\nGDB allows Python-based visualizers to affect the output of the MI variable object commands. However, because there was no way to implement this in a fully backward-compatible way, a front end must request that this functionality be enabled.\n\nOnce enabled, this feature cannot be disabled.\n\nNote that if Python support has not been compiled into GDB, this command will still succeed (and do nothing).\n\nThis operation creates a variable object, which allows the monitoring of a variable, the result of an expression, a memory cell or a CPU register.\n\nThe parameter is the string by which the object can be referenced. It must be unique. If ‘ ’ is specified, the varobj system will generate a string “varNNNNNN” automatically. It will be unique provided that one does not specify of that format. The command fails if a duplicate name is found.\n\nThe frame under which the expression should be evaluated can be specified by . A ‘ ’ indicates that the current frame should be used. A ‘ ’ indicates that a floating variable object must be created.\n\nis any expression valid on the current language set (must not begin with a ‘ ’), or one of the following:\n• ‘ ’, where is the address of a memory cell\n\nA varobj’s contents may be provided by a Python-based pretty-printer. In this case the varobj is known as a dynamic varobj. Dynamic varobjs have slightly different semantics in some cases. If the command is not sent, then GDB will never create a dynamic varobj. This ensures backward compatibility for existing clients.\n\nThis operation returns attributes of the newly-created varobj. These are:\n\nTypical output will look like this:\n\nDeletes a previously created variable object and all of its children. With the ‘ ’ option, just deletes the children.\n\nReturns an error if the object is not found.\n\nSets the output format for the value of the object to be .\n\nThe syntax for the is as follows:\n\nThe natural format is the default format chosen automatically based on the variable type (like decimal for an , hex for pointers, etc.).\n\nThe zero-hexadecimal format has a representation similar to hexadecimal but with padding zeroes to the left of the value. For example, a 32-bit hexadecimal value of 0x1234 would be represented as 0x00001234 in the zero-hexadecimal format.\n\nFor a variable with children, the format is set only on the variable itself, and the children are not affected.\n\nReturns the format used to display the value of the object .\n\nReturns the number of children of a variable object :\n\nNote that this number is not completely reliable for a dynamic varobj. It will return the current number of children, but more children may be available.\n\nReturn a list of the children of the specified variable object and create variable objects for them, if they do not already exist. With a single argument or if has a value of 0 or , print only the names of the variables; if is 1 or , also print their values; and if it is 2 or print the name and value for simple data types and just the name for arrays, structures and unions.\n\nand , if specified, indicate the range of children to report. If or is less than zero, the range is reset and all children will be reported. Otherwise, children starting at (zero-based) and up to and excluding will be reported.\n\nIf a child range is requested, it will only affect the current call to , but not future calls to . For this, you must instead use . The intent of this approach is to enable a front end to implement any update approach it likes; for example, scrolling a view may cause the front end to request more children with , and then the front end could call with a different range to ensure that future updates are restricted to just the visible items.\n\nFor each child the following results are returned:\n\nThe result may have its own attributes:\n\nReturns the type of the specified variable . The type is returned as a string in the same format as it is output by the GDB CLI:\n\nReturns a string that is suitable for presenting this variable object in user interface. The string is generally not valid expression in the current language, and cannot be evaluated.\n\nFor example, if is an array, and variable object was created for , then we’ll get this output:\n\nHere, the value of is the language name, which can be found in Supported Languages.\n\nNote that the output of the command also includes those expressions, so the command is of limited use.\n\nReturns an expression that can be evaluated in the current context and will yield the same value that a variable object has. Compare this with the command, which result can be used only for UI presentation. Typical use of the command is creating a watchpoint from a variable object.\n\nThis command is currently not valid for children of a dynamic varobj, and will give an error when invoked on one.\n\nFor example, suppose is a C class, derived from class , and that the class has a member called . Assume a variable is has the type of and a variable object was created for variable . Then, we’ll get this output:\n\nList attributes of the specified variable object :\n\nEvaluates the expression that is represented by the specified variable object and returns its value as a string. The format of the string can be specified with the ‘ ’ option. The possible values of this option are the same as for (see -var-set-format). If the ‘ ’ option is not specified, the current display format will be used. The current display format can be changed using the command.\n\nNote that one must invoke for a variable before the value of a child variable can be evaluated.\n\nAssigns the value of to the variable object specified by . The object must be ‘ ’. If the variable’s value is altered by the assign, the variable will show up in any subsequent list.\n\nReevaluate the expressions corresponding to the variable object and all its direct and indirect children, and return the list of variable objects whose values have changed; must be a root variable object. Here, “changed” means that the result of before and after the is different. If ‘ ’ is used as the variable object names, all existing variable objects are updated, except for frozen ones (see -var-set-frozen). The option determines whether both names and values, or just names are printed. The possible values of this option are the same as for (see -var-list-children). It is recommended to use the ‘ ’ option, to reduce the number of MI commands needed on each program stop.\n\nWith the ‘ ’ parameter, if a variable object is bound to a currently running thread, it will not be updated, without any diagnostic.\n\nIf was previously used on a varobj, then only the selected range of children will be reported.\n\nreports all the changed varobjs in a tuple named ‘ ’.\n\nEach item in the change list is itself a tuple holding:\n\nSet the frozenness flag on the variable object . The parameter should be either ‘ ’ to make the variable frozen or ‘ ’ to make it unfrozen. If a variable object is frozen, then neither itself, nor any of its children, are implicitly updated by of a parent variable or by . Only of the variable itself will update its value and values of its children. After a variable object is unfrozen, it is implicitly updated by all subsequent operations. Unfreezing a variable does not update it, only subsequent does.\n\nSet the range of children to be returned by future invocations of .\n\nand indicate the range of children to report. If or is less than zero, the range is reset and all children will be reported. Otherwise, children starting at (zero-based) and up to and excluding will be reported.\n\nis the visualizer to use. The special value ‘ ’ means to disable any visualizer in use.\n\nIf not ‘ ’, must be a Python expression. This expression must evaluate to a callable object which accepts a single argument. GDB will call this object with the value of the varobj as an argument (this is done so that the same Python pretty-printing code can be used for both the CLI and MI). When called, this object must return an object which conforms to the pretty-printing interface (see Pretty Printing API).\n\nThe pre-defined function may be used to select a visualizer by following the built-in process (see Selecting Pretty-Printers). This is done automatically when a varobj is created, and so ordinarily is not needed.\n\nThis feature is only available if Python support is enabled. The MI command (see GDB/MI Support Commands) can be used to check this.\n\nSuppose is a visualizer class. A lambda expression can be used to instantiate this class for a varobj:\n\nThis section describes the GDB/MI commands that manipulate data: examine memory and registers, evaluate expressions, etc.\n\nFor details about what an addressable memory unit is, see addressable memory unit.\n\nThe can only be used with 0. Passing this option will include the source code in the disassembly result as if 4 or 5 had been used.\n\nThe result of the command will be a list named ‘ ’, the contents of this list depend on the options used with the command.\n\nFor modes 0 and 2, and when the option is not used, the ‘ ’ list contains tuples with the following fields:\n\nFor modes 1, 3, 4 and 5, or when the option is used, the ‘ ’ list contains tuples named ‘ ’, each of which has the following fields:\n\nNote that whatever included in the ‘ ’ field, is not manipulated directly by GDB/MI, i.e., it is not possible to adjust its format.\n\nThe corresponding GDB command is ‘ ’.\n\nDisassemble from the current value of to :\n\nDisassemble the whole function. Line 32 is part of .\n\nDisassemble 3 instructions from the start of :\n\nDisassemble 3 instructions from the start of in mixed mode:\n\nEvaluate as an expression. The expression could contain an inferior function call. The function call will execute synchronously. If the expression contains spaces, it must be enclosed in double quotes.\n\nThe corresponding GDB commands are ‘ ’, ‘ ’, and ‘ ’. In only, there’s a corresponding ‘ ’ command.\n\nIn the following example, the numbers that precede the commands are the tokens described in GDB/MI Command Syntax. Notice how GDB/MI returns the same tokens in its output.\n\nDisplay a list of the registers that have changed.\n\nGDB doesn’t have a direct analog for this command; has the corresponding command ‘ ’.\n\nShow a list of register names for the current target. If no arguments are given, it shows a list of the names of all the registers. If integer numbers are given as arguments, it will print a list of the names of the registers corresponding to the arguments. To ensure consistency between a register name and its number, the output list may include empty register names.\n\nGDB does not have a command which corresponds to ‘ ’. In there is a corresponding command ‘ ’.\n\nDisplay the registers’ contents. The format according to which the registers’ contents are to be returned is given by , followed by an optional list of numbers specifying the registers to display. A missing list of numbers indicates that the contents of all the registers must be returned. The option indicates that only the available registers are to be returned.\n\nThe corresponding GDB commands are ‘ ’, ‘ ’, and (in ) ‘ ’.\n\nFor a PPC MBX board (note: line breaks are for readability only, they don’t appear in the actual output):\n\nThis command is deprecated, use instead.\n\nThis command displays memory contents as a table of by words, each word being bytes. In total, bytes are read (returned as ‘ ’). Should less than the requested number of bytes be returned by the target, the missing words are identified using ‘ ’. The number of bytes read from the target is returned in ‘ ’ and the starting address used to read memory in ‘ ’.\n\nThe address of the next/previous row or page is available in ‘ ’ and ‘ ’, ‘ ’ and ‘ ’.\n\nThe corresponding GDB command is ‘ ’. has ‘ ’ memory read command.\n\nRead six bytes of memory starting at but then offset by bytes. Format as three rows of two columns. One byte per word. Display each word in hex.\n\nRead two bytes of memory starting at address and display as a single word formatted in decimal.\n\nRead thirty two bytes of memory starting at and format as eight rows of four columns. Include a string encoding with ‘ ’ used as the non-printable character.\n\nThis command attempts to read all accessible memory regions in the specified range. First, all regions marked as unreadable in the memory map (if one is defined) will be skipped. See Memory Region Attributes. Second, GDB will attempt to read the remaining regions. For each one, if reading full region results in an errors, GDB will try to read a subset of the region.\n\nIn general, every single memory unit in the region may be readable or not, and the only way to read every readable unit is to try a read at every address, which is not practical. Therefore, GDB will attempt to read all accessible memory units at either beginning or the end of the region, using a binary division scheme. This heuristic works well for reading across a memory map boundary. Note that if a region has a readable range that is neither at the beginning or the end, GDB will not read it.\n\nThe result record (see GDB/MI Result Records) that is output of the command includes a field named ‘ ’ whose content is a list of tuples. Each tuple represent a successfully read memory block and has the following fields:\n\nThe corresponding GDB command is ‘ ’.\n\nThe commands defined in this section implement MI support for tracepoints. For detailed introduction, see Tracepoints.\n\nFind a trace frame using criteria defined by and . The following table lists permissible modes and their parameters. For details of operation, see tfind.\n\nIf ‘ ’ was passed as , the response does not have fields. Otherwise, the response may have the following fields:\n\nThe corresponding GDB command is ‘ ’.\n\nCreate trace variable if it does not exist. If is specified, sets the initial value of the specified trace variable to that value. Note that the should start with the ‘ ’ character.\n\nThe corresponding GDB command is ‘ ’.\n\nThis command returns the set of collected objects, register names, trace state variable names, memory ranges and computed expressions that have been collected at a particular trace frame. The optional parameters to the command affect the output format in different ways. See the output description table below for more details.\n\nThe reported names can be used in the normal manner to create varobjs and inspect the objects themselves. The items returned by this command are categorized so that it is clear which is a variable, which is a register, which is a trace state variable, which is a memory range and which is a computed expression.\n\nFor instance, if the actions were\n\nthe object collected in its entirety would be . The object would be partially collected, because only the element at index would be collected. The remaining objects would be computed expressions.\n\nAn example output would be:\n\nThere is no corresponding GDB command.\n\nReturn a table of all defined trace variables. Each element of the table has the following fields:\n\nThe corresponding GDB command is ‘ ’.\n\nSaves the collected trace data to . Without the ‘ ’ option, the data is downloaded from the target and saved in a local file. With the ‘ ’ option the target is asked to perform the save.\n\nBy default, this command will save the trace in the tfile format. You can supply the optional ‘ ’ argument to save it the CTF format. See Trace Files for more information about CTF.\n\nThe corresponding GDB command is ‘ ’.\n\nStarts a tracing experiment. The result of this command does not have any fields.\n\nThe corresponding GDB command is ‘ ’.\n\nObtains the status of a tracing experiment. The result may include the following fields:\n\nThe corresponding GDB command is ‘ ’.\n\nStops a tracing experiment. The result of this command has the same fields as , except that the ‘ ’ and ‘ ’ fields are not output.\n\nThe corresponding GDB command is ‘ ’.\n\nReturn a list containing the names and types for all global functions taken from the debug information. The functions are grouped by source file, and shown with the line number on which each function is defined.\n\nThe option causes the output to include code symbols from the symbol table.\n\nThe options and allow the symbols returned to be filtered based on either the name of the function, or the type signature of the function.\n\nThe option restricts the command to return no more than results. If exactly results are returned then there might be additional results available if a higher limit is used.\n\nThe corresponding GDB command is ‘ ’.\n\nReturn a list containing the names of all known functions within all know Fortran modules. The functions are grouped by source file and containing module, and shown with the line number on which each function is defined.\n\nThe option only returns results for modules matching . The option only returns functions whose name matches , and only returns functions whose type matches .\n\nThe corresponding GDB command is ‘ ’.\n\nReturn a list containing the names of all known variables within all know Fortran modules. The variables are grouped by source file and containing module, and shown with the line number on which each variable is defined.\n\nThe option only returns results for modules matching . The option only returns variables whose name matches , and only returns variables whose type matches .\n\nThe corresponding GDB command is ‘ ’.\n\nReturn a list containing the names of all known Fortran modules. The modules are grouped by source file, and shown with the line number on which each modules is defined.\n\nThe option allows the modules returned to be filtered based the name of the module.\n\nThe option restricts the command to return no more than results. If exactly results are returned then there might be additional results available if a higher limit is used.\n\nThe corresponding GDB command is ‘ ’.\n\nReturn a list of all defined types. The types are grouped by source file, and shown with the line number on which each user defined type is defined. Some base types are not defined in the source code but are added to the debug information by the compiler, for example , , etc.; these types do not have an associated line number.\n\nThe option allows the list of types returned to be filtered by name.\n\nThe option restricts the command to return no more than results. If exactly results are returned then there might be additional results available if a higher limit is used.\n\nThe corresponding GDB command is ‘ ’.\n\nReturn a list containing the names and types for all global variables taken from the debug information. The variables are grouped by source file, and shown with the line number on which each variable is defined.\n\nThe option causes the output to include data symbols from the symbol table.\n\nThe options and allow the symbols returned to be filtered based on either the name of the variable, or the type of the variable.\n\nThe option restricts the command to return no more than results. If exactly results are returned then there might be additional results available if a higher limit is used.\n\nThe corresponding GDB command is ‘ ’.\n\nPrint the list of lines that contain code and their associated program addresses for the given source filename. The entries are sorted in ascending PC order.\n\nThere is no corresponding GDB command.\n\nThis section describes the GDB/MI commands to specify executable file names and to read in and obtain symbol table information.\n\nSpecify the executable file to be debugged. This file is the one from which the symbol table is also read. If no file is specified, the command clears the executable and symbol information. If breakpoints are set when using this command with no arguments, GDB will produce error messages. Otherwise, no output is produced, except a completion notification.\n\nThe corresponding GDB command is ‘ ’.\n\nSpecify the executable file to be debugged. Unlike ‘ ’, the symbol table is not read from this file. If used without argument, GDB clears the information about the executable file. No output is produced, except a completion notification.\n\nThe corresponding GDB command is ‘ ’.\n\nList the line number, the current source file, and the absolute path to the current source file for the current executable. The macro information field has a value of ‘ ’ or ‘ ’ depending on whether or not the file includes preprocessor macro information.\n\nThis command returns information about the source files GDB knows about, it will output both the filename and fullname (absolute file name) of a source file, though the fullname can be elided if this information is not known to GDB.\n\nWith no arguments this command returns a list of source files. Each source file is represented by a tuple with the fields; , , and . The is the display name for the file, while is the absolute name of the file. The field can be elided if the absolute name of the source file can’t be computed. The field will be a string, either or . When , this indicates the full debug information for the compilation unit describing this file has been read in. When , the full debug information has not yet been read in. While reading in the full debug information it is possible that GDB could become aware of additional source files.\n\nThe optional can be used to filter the list of source files returned. The will be matched against the full source file name. The matching is case-sensitive, except on operating systems that have case-insensitive filesystem (e.g., MS-Windows). ‘ ’ can be used before to prevent GDB interpreting as a command option (e.g. if starts with ‘ ’).\n\nIf is provided, then is matched only against the directory name of each source file. If is provided, then is matched against the basename of each source file. Only one of or may be given, and if either is given then is required.\n\nIf is used then the format of the results is changed. The results will now be a list of tuples, with each tuple representing an object file (executable or shared library) loaded into GDB. The fields of these tuples are; , , and . The is the absolute name of the object file, is a string with one of the following values:\n\nThe is a list or tuples, with each tuple describing a single source file with the same fields as described previously. The list can be empty for object files that have no debug information.\n\nThe GDB equivalent is ‘ ’. has an analogous command ‘ ’.\n\nList the shared libraries in the program. With a regular expression , only those libraries whose names match are listed.\n\nThe corresponding GDB command is ‘ ’. The fields have a similar meaning to the notification. The field specifies the multiple segments belonging to this library. Each range has the following fields:\n\nRead symbol table info from the specified argument. When used without arguments, clears GDB’s symbol table info. No output is produced, except for a completion notification.\n\nThe corresponding GDB command is ‘ ’.\n\nAttach to a process or a file outside of GDB, or a thread group . If attaching to a thread group, the id previously returned by ‘ ’ must be used.\n\nThe corresponding GDB command is ‘ ’.\n\nDetach from the remote target which normally resumes its execution. If either or is specified, detaches from either the specified process, or specified thread group. There’s no output.\n\nThe corresponding GDB command is ‘ ’.\n\nDisconnect from the remote target. There’s no output and the target is generally not resumed.\n\nThe corresponding GDB command is ‘ ’.\n\nLoads the executable onto the remote target. It prints out an update message every half second, which includes the fields:\n\nEach message is sent as status record (see GDB/MI Output Syntax).\n\nIn addition, it prints the name and size of the sections, as they are downloaded. These messages include the following fields:\n\nAt the end, a summary is printed.\n\nThe corresponding GDB command is ‘ ’.\n\nNote: each status message appears on a single line. Here the messages have been broken down so that they can fit onto a page.\n\nErases all known flash memory regions on the target.\n\nThe corresponding GDB command is ‘ ’.\n\nThe output is a list of flash regions that have been erased, with starting addresses and memory region sizes.\n\nConnect GDB to the remote target. This command takes two args:\n\nThe output is a connection notification, followed by the address at which the target program is, in the following form:\n\nThe corresponding GDB command is ‘ ’.\n\nCopy file from the host system (the machine running GDB) to on the target system.\n\nThe corresponding GDB command is ‘ ’.\n\nCopy file from the target system to on the host system.\n\nThe corresponding GDB command is ‘ ’.\n\nThe corresponding GDB command is ‘ ’.\n\nList all Ada exceptions defined within the program being debugged. With a regular expression , only those exceptions whose names match are listed.\n\nThe corresponding GDB command is ‘ ’.\n\nThe result is a table of Ada exceptions. The following columns are defined for each exception:\n\nThe commands describing how to ask GDB to stop when a program raises an exception are described at Ada Exception GDB/MI Catchpoint Commands.\n\nSince new commands and features get regularly added to GDB/MI, some commands are available to help front-ends query the debugger about support for these capabilities. Similarly, it is also possible to query GDB about target support of certain features.\n\nNote that the dash ( ) starting all GDB/MI commands is technically not part of the command name (see GDB/MI Input Syntax), and thus should be omitted in . However, for ease of use, this command also accepts the form with the leading dash.\n\nThere is no corresponding GDB command.\n\nThe result is a tuple. There is currently only one field:\n\nHere is an example where the GDB/MI command does not exist:\n\nAnd here is an example where the GDB/MI command is known to the debugger:\n\nReturns a list of particular features of the MI protocol that this version of gdb implements. A feature can be a command, or a new field in an output of some command, or even an important bugfix. While a frontend can sometimes detect presence of a feature at runtime, it is easier to perform detection at debugger startup.\n\nThe command returns a list of strings, with each string naming an available feature. Each returned string is just a name, it does not have any internal structure. The list of possible feature names is given below.\n\nThe current list of features is:\n\nReturns a list of particular features that are supported by the target. Those features affect the permitted MI commands, but unlike the features reported by the command, the features depend on which target GDB is using at the moment. Whenever a target can change, due to commands such as , or , the list of target features may change, and the frontend should obtain it again. Example output:\n\nThe current list of features is:\n\nThe corresponding GDB command is ‘ ’.\n\nShow the current value of a GDB variable.\n\nThe corresponding GDB command is ‘ ’.\n\nShow version information for GDB. Used mostly in testing.\n\nThe GDB equivalent is ‘ ’. GDB by default shows this information when you start an interactive session.\n\nLists thread groups (see Thread groups). When a single thread group is passed as the argument, lists the children of that group. When several thread group are passed, lists information about those thread groups. Without any parameters, lists information about all top-level thread groups.\n\nNormally, thread groups that are being debugged are reported. With the ‘ ’ option, GDB reports thread groups available on the target.\n\nThe output of this command may have either a ‘ ’ result or a ‘ ’ result. The ‘ ’ result has a list of tuples as value, with each tuple describing a thread (see GDB/MI Thread Information). The ‘ ’ result has a list of tuples as value, each tuple describing a thread group. If top-level groups are requested (that is, no parameter is passed), or when several groups are passed, the output always has a ‘ ’ result. The format of the ‘ ’ result is described below.\n\nTo reduce the number of roundtrips it’s possible to list thread groups together with their children, by passing the ‘ ’ option and the recursion depth. Presently, only recursion depth of 1 is permitted. If this option is present, then every reported thread group will also include its children, either as ‘ ’ or ‘ ’ field.\n\nIn general, any combination of option and parameters is permitted, with the following caveats:\n• When a single thread group is passed, the output will typically be the ‘ ’ result. Because threads may not contain anything, the ‘ ’ option will be ignored.\n• When the ‘ ’ option is passed, limited information may be available. In particular, the list of threads of a process might be inaccessible. Further, specifying specific thread groups might not give any performance advantage over listing all thread groups. The frontend should assume that ‘ ’ is always an expensive operation and cache the results.\n\nThe ‘ ’ result is a list of tuples, where each tuple may have the following fields:\n\nIf no argument is supplied, the command returns a table of available operating-system-specific information types. If one of these types is supplied as an argument , then the command returns a table of data of that type.\n\nThe types of information available depend on the target operating system.\n\nThe corresponding GDB command is ‘ ’.\n\nWhen run on a GNU/Linux system, the output will look something like this:\n\nCreates a new inferior (see Inferiors Connections and Programs). The created inferior is not associated with any executable. Such association may be established with the ‘ ’ command (see GDB/MI File Commands).\n\nBy default, the new inferior begins connected to the same target connection as the current inferior. For example, if the current inferior was connected to with , then the new inferior will be connected to the same instance. The ‘ ’ option starts the new inferior with no connection yet. You can then for example use the command to connect to some other instance, use to spawn a local program, etc.\n\nThe command response always has a field, , whose value is the identifier of the thread group corresponding to the new inferior.\n\nAn additional section field, , is optional. This field will only exist if the new inferior has a target connection. If this field exists, then its value will be a tuple containing the following fields:\n\nThe corresponding GDB command is ‘ ’ (see ‘ ’).\n\nRemoves an inferior (see Inferiors Connections and Programs). Only inferiors that have exited can be removed. The is the inferior to be removed, and should be the same id string as returned by the ‘ ’ command.\n\nWhen an inferior is successfully removed a notification (see GDB/MI Async Records) is emitted, the field of which contains the for the removed inferior.\n\nThe corresponding GDB command is ‘ ’ (see ‘ ’).\n\nExecute the specified in the given .\n\nThe corresponding GDB command is ‘ ’.\n\nSet terminal for future runs of the program being debugged.\n\nThe corresponding GDB command is ‘ ’ /dev/pts/1.\n\nShow terminal for future runs of program being debugged.\n\nThe corresponding GDB command is ‘ ’.\n\nToggle the printing of the wallclock, user and system times for an MI command as a field in its output. This command is to help frontend developers optimize the performance of their code. No argument is equivalent to ‘ ’.\n\nThis command is intended for GDB/MI frontends that cannot use two separate CLI and MI channels — for example: because of lack of PTYs like on Windows or because GDB is used remotely via a SSH connection.\n\nThe result consists of two or three fields:\n\nThe corresponding GDB command is ‘ ’.\n\nThis chapter describes annotations in GDB. Annotations were designed to interface GDB to graphical user interfaces or other similar programs which want to interact with GDB at a relatively high level.\n\nThe annotation mechanism has largely been superseded by GDB/MI (see GDB/MI).\n\n28.1 What is an Annotation?\n\nAnnotations start with a newline character, two ‘ ’ characters, and the name of the annotation. If there is no additional information associated with this annotation, the name of the annotation is followed immediately by a newline. If there is additional information, the name of the annotation is followed by a space, the additional information, and a newline. The additional information cannot contain newline characters.\n\nAny output not beginning with a newline and two ‘ ’ characters denotes literal output from GDB. Currently there is no need for GDB to output a newline followed by two ‘ ’ characters, but if there was such a need, the annotations could be extended with an ‘ ’ annotation which means those three characters as output.\n\nThe annotation , which is specified using the command line option (see Mode Options), controls how much information GDB prints together with its prompt, values of expressions, source lines, and other types of output. Level 0 is for no annotations, level 1 is for use when GDB is run as a subprocess of GNU Emacs, level 3 is the maximum annotation suitable for programs that control GDB, and level 2 annotations have been made obsolete (see Limitations of the Annotation Interface in ).\n\nA simple example of starting up GDB with annotations is:\n\nHere ‘ ’ is input to GDB; the rest is output from GDB. The three lines beginning ‘ ’ (where ‘ ’ denotes a ‘ ’ character) are annotations; the rest is output from GDB.\n\nIf you prefix a command with ‘ ’ then it will not affect the command history, nor will it affect GDB’s notion of which command to repeat if is pressed on a line by itself. This means that commands can be run behind a user’s back by a front-end in a transparent manner.\n\nThe prefix does not affect the recording of values into the value history; to print a value without recording it into the value history, use the command instead of the command.\n\nUsing this prefix also disables confirmation requests (see confirmation requests).\n\nWhen GDB prompts for input, it annotates this fact so it is possible to know when to send output, when the output from a given command is over, etc.\n\nDifferent kinds of input each have a different input type. Each input type has three annotations: a annotation, which denotes the beginning of any prompt which is being output, a plain annotation, which denotes the end of the prompt, and then a annotation which denotes the end of any echo which may (or may not) be associated with the input. For example, the input type features the following annotations:\n\nThis annotation occurs right before GDB responds to an interrupt.\n\nThis annotation occurs right before GDB responds to an error.\n\nQuit and error annotations indicate that any annotations which GDB was in the middle of may end abruptly. For example, if a annotation is followed by a , one cannot expect to receive the matching . One cannot expect not to receive it either, however; an error annotation does not necessarily mean that GDB is immediately returning all the way to the top level.\n\nA quit or error annotation may be preceded by\n\nAny output between that and the quit or error annotation is the error message.\n\nWarning messages are not yet annotated.\n\nThe following annotations say that certain pieces of state may have changed.\n\nWhen the program starts executing due to a GDB command such as or ,\n\nis output. When the program stops,\n\nis output. Before the annotation, a variety of annotations describe how the program stopped.\n\nThe following annotation is used instead of displaying source code:\n\nwhere is an absolute file name indicating which source file, is the line number within that file (where 1 is the first line in the file), is the character position within the file (where 0 is the first character in the file) (for most debug formats this will necessarily point to the beginning of a line), is ‘ ’ if is in the middle of the line, or ‘ ’ if is at the beginning of the line, and is the address in the target program associated with the source which is being displayed. The is in the form ‘ ’ followed by one or more lowercase hex digits (note that this does not depend on the language).\n\nThe Debugger Adapter Protocol is a generic API that is used by some IDEs to communicate with debuggers. It is documented at https://microsoft.github.io/debug-adapter-protocol/.\n\nGenerally, GDB implements the Debugger Adapter Protocol as written. However, in some cases, extensions are either needed or even expected.\n\nGDB defines some parameters that can be passed to the request:\n\nGDB defines some parameters that can be passed to the request. Either or must be specified, but if both are specified then will be ignored.\n\nIn response to the request, DAP allows the client to return the bytes of each instruction in an implementation-defined format. GDB implements this by sending a string with the bytes encoded in hex, like .\n\nWhen the context is used for the request, GDB evaluates the provided expression as a CLI command.\n\nEvaluation in general can cause the inferior to continue execution. For example, evaluating the command could do this, as could evaluating an expression that involves an inferior function call.\n\nevaluation can also cause GDB to appear to stop responding to requests, for example if a CLI script does a lengthy computation.\n\nEvaluations like this can be interrupted using the DAP request. (In fact, should work for any request, but it is unlikely to be useful for most of them.)\n\nGDB provides a couple of logging settings that can be used in DAP mode. These can be set on the command line using the option (see File Options).\n\nThis chapter documents GDB’s just-in-time (JIT) compilation interface. A JIT compiler is a program or library that generates native executable code at runtime and executes it, usually in order to achieve good performance while maintaining platform independence.\n\nPrograms that use JIT compilation are normally difficult to debug because portions of their code are generated at runtime, instead of being loaded from object files, which is where GDB normally finds the program’s symbols and debug information. In order to debug programs that use JIT compilation, GDB has an interface that allows the program to register in-memory symbol files with GDB at runtime.\n\nIf you are using GDB to debug a program that uses this interface, then it should work transparently so long as you have not stripped the binary. If you are developing a JIT compiler, then the interface is documented in the rest of this chapter. At this time, the only known client of this interface is the LLVM JIT.\n\nBroadly speaking, the JIT interface mirrors the dynamic loader interface. The JIT compiler communicates with GDB by writing data into a global variable and calling a function at a well-known symbol. When GDB attaches, it reads a linked list of symbol files from the global variable to find existing code, and puts a breakpoint in the function so that it can find out about additional code.\n\nThese are the relevant struct declarations that a C program should include to implement the interface:\n\nIf the JIT is multi-threaded, then it is important that the JIT synchronize any modifications to this global data properly, which can easily be done by putting a global mutex around modifications to these structures.\n\nTo register code with GDB, the JIT should follow this protocol:\n• Generate an object file in memory with symbols and other desired debug information. The file must include the virtual addresses of the sections.\n• Create a code entry for the file, which gives the start and size of the symbol file.\n• Add it to the linked list in the JIT descriptor.\n• Point the relevant_entry field of the descriptor at the entry.\n\nWhen GDB is attached and the breakpoint fires, GDB uses the pointer so it doesn’t have to walk the list looking for new code. However, the linked list must still be maintained in order to allow GDB to attach to a running process and still find the symbol files.\n\nIf code is freed, then the JIT should use the following protocol:\n• Remove the code entry corresponding to the code from the linked list.\n• Point the field of the descriptor at the code entry.\n\nIf the JIT frees or recompiles code without unregistering it, then GDB and the JIT will leak the memory used for the associated symbol files.\n\nGenerating debug information in platform-native file formats (like ELF or COFF) may be an overkill for JIT compilers; especially if all the debug info is used for is displaying a meaningful backtrace. The issue can be resolved by having the JIT writers decide on a debug info format and also provide a reader that parses the debug info generated by the JIT compiler. This section gives a brief overview on writing such a parser. More specific details can be found in the source file , which is also installed as a header at for easy inclusion.\n\nThe reader is implemented as a shared object (so this functionality is not available on platforms which don’t allow loading shared objects at runtime). Two GDB commands, and are provided, to be used to load and unload the readers from a preconfigured directory. Once loaded, the shared object is used the parse the debug information emitted by the JIT compiler.\n\nReaders can be loaded and unloaded using the and commands.\n\nAs mentioned, a reader is essentially a shared object conforming to a certain ABI. This ABI is described in .\n\ndefines the structures, macros and functions required to write a reader. It is installed (along with GDB), in where is the system include directory.\n\nReaders need to be released under a GPL compatible license. A reader can be declared as released under such a license by placing the macro in a source file.\n\nThe entry point for readers is the symbol , which is expected to be a function with the prototype\n\ncontains a set of pointers to callback functions. These functions are executed to read the debug info generated by the JIT compiler ( ), to unwind stack frames ( ) and to create canonical frame IDs ( ). It also has a callback that is called when the reader is being unloaded ( ). The struct looks like this\n\nThe callbacks are provided with another set of callbacks by GDB to do their job. For , these callbacks are passed in a and for and , in a . has callbacks to create new object files and new symbol tables inside those object files. has callbacks to read registers off the current frame and to write out the values of the registers in the previous frame. Both have a callback ( ) to read bytes off the target’s address space.\n\nThe traditional debugging model is conceptually low-speed, but works fine, because most bugs can be reproduced in debugging-mode execution. However, as multi-core or many-core processors are becoming mainstream, and multi-threaded programs become more and more popular, there should be more and more bugs that only manifest themselves at normal-mode execution, for example, thread races, because debugger’s interference with the program’s timing may conceal the bugs. On the other hand, in some applications, it is not feasible for the debugger to interrupt the program’s execution long enough for the developer to learn anything helpful about its behavior. If the program’s correctness depends on its real-time behavior, delays introduced by a debugger might cause the program to fail, even when the code itself is correct. It is useful to be able to observe the program’s behavior without interrupting it.\n\nTherefore, traditional debugging model is too intrusive to reproduce some bugs. In order to reduce the interference with the program, we can reduce the number of operations performed by debugger. The In-Process Agent, a shared library, is running within the same process with inferior, and is able to perform some debugging operations itself. As a result, debugger is only involved when necessary, and performance of debugging can be improved accordingly. Note that interference with program can be reduced but can’t be removed completely, because the in-process agent will still stop or slow down the program.\n\nThe in-process agent can interpret and execute Agent Expressions (see Agent Expressions) during performing debugging operations. The agent expressions can be used for different purposes, such as collecting data in tracepoints, and condition evaluation in breakpoints.\n\nYou can control whether the in-process agent is used as an aid for debugging with the following commands:\n\nThe in-process agent is able to communicate with both GDB and GDBserver (see In-Process Agent). This section documents the protocol used for communications between GDB or GDBserver and the IPA. In general, GDB or GDBserver sends commands (see IPA Protocol Commands) and data to in-process agent, and then in-process agent replies back with the return result of the command, or some other information. The data sent to in-process agent is composed of primitive data types, such as 4-byte or 8-byte type, and composite types, which are called objects (see IPA Protocol Objects).\n\nThe commands sent to and results received from agent may contain some complex data types called objects.\n\nThe in-process agent is running on the same machine with GDB or GDBserver, so it doesn’t have to handle as much differences between two ends as remote protocol (see Remote Protocol) tries to handle. However, there are still some differences of two ends in two processes:\n• word size. On some 64-bit machines, GDB or GDBserver can be compiled as a 64-bit executable, while in-process agent is a 32-bit one.\n• ABI. Some machines may have multiple types of ABI, GDB or GDBserver is compiled with one, and in-process agent is compiled with the other one.\n\nHere are the IPA Protocol Objects:\n• agent expression object. It represents an agent expression (see Agent Expressions).\n• tracepoint action object. It represents a tracepoint action (see Tracepoint Action Lists) to collect registers, memory, static trace data and to evaluate expression.\n\nThe following table describes important attributes of each IPA protocol object:\n\nThe spaces in each command are delimiters to ease reading this commands specification. They don’t exist in real commands.\n\nYour bug reports play an essential role in making GDB reliable.\n\nReporting a bug may help you by bringing a solution to your problem, or it may not. But in any case the principal function of a bug report is to help the entire community by making the next version of GDB work better. Bug reports are your contribution to the maintenance of GDB.\n\nIn order for a bug report to serve its purpose, you must include the information that enables us to fix the bug.\n\nIf you are not sure whether you have found a bug, here are some guidelines:\n• If the debugger gets a fatal signal, for any input whatever, that is a GDB bug. Reliable debuggers never crash.\n• If GDB produces an error message for valid input, that is a bug. (Note that if you’re cross debugging, the problem may also be somewhere in the connection to the target.)\n• If GDB does not produce an error message for invalid input, that is a bug. However, you should note that your idea of “invalid input” might be our idea of “an extension” or “support for traditional practice”.\n• If you are an experienced user of debugging tools, your suggestions for improvement of GDB are welcome in any case.\n\nA number of companies and individuals offer support for GNU products. If you obtained GDB from a support organization, we recommend you contact that organization first.\n\nYou can find contact information for many support companies and individuals in the file in the GNU Emacs distribution.\n\nIn any event, we also recommend that you submit bug reports for GDB to https://www.gnu.org/software/gdb/bugs/.\n\nThe fundamental principle of reporting bugs usefully is this: report all the facts. If you are not sure whether to state a fact or leave it out, state it!\n\nOften people omit facts because they think they know what causes the problem and assume that some details do not matter. Thus, you might assume that the name of the variable you use in an example does not matter. Well, probably it does not, but one cannot be sure. Perhaps the bug is a stray memory reference which happens to fetch from the location where that name is stored in memory; perhaps, if the name were different, the contents of that location would fool the debugger into doing the right thing despite the bug. Play it safe and give a specific, complete example. That is the easiest thing for you to do, and the most helpful.\n\nKeep in mind that the purpose of a bug report is to enable us to fix the bug. It may be that the bug has been reported previously, but neither you nor we can know that unless your bug report is complete and self-contained.\n\nSometimes people give a few sketchy facts and ask, “Does this ring a bell?” Those bug reports are useless, and we urge everyone to refuse to respond to them except to chide the sender to report bugs properly.\n\nTo enable us to fix the bug, you should include all these things:\n• The version of GDB. GDB announces it if you start with no arguments; you can also print it at any time using . Without this, we will not know whether there is any point in looking for the bug in the current version of GDB.\n• The type of machine you are using, and the operating system name and version number.\n• The details of the GDB build-time configuration. GDB shows these details if you invoke it with the command-line option, or if you type at GDB’s prompt.\n• What compiler (and its version) was used to compile GDB—e.g. “gcc–2.8.1”.\n• What compiler (and its version) was used to compile the program you are debugging—e.g. “gcc–2.8.1”, or “HP92453-01 A.10.32.03 HP C Compiler”. For GCC, you can say to get this information; for other compilers, see the documentation for those compilers.\n• The command arguments you gave the compiler to compile your example and observe the bug. For example, did you use ‘ ’? To guarantee you will not omit something important, list them all. A copy of the Makefile (or the output from make) is sufficient. If we were to try to guess the arguments, we would probably guess wrong and then we might not encounter the bug.\n• A complete input script, and all necessary source files, that will reproduce the bug.\n• A description of what behavior you observe that you believe is incorrect. For example, “It gets a fatal signal.” Of course, if the bug is that GDB gets a fatal signal, then we will certainly notice it. But if the bug is incorrect output, we might not notice unless it is glaringly wrong. You might as well not give us a chance to make a mistake. Even if the problem you experience is a fatal signal, you should still say so explicitly. Suppose something strange is going on, such as, your copy of GDB is out of synch, or you have encountered a bug in the C library on your system. (This has happened!) Your copy might crash and ours would not. If you told us to expect a crash, then when ours fails to crash, we would know that the bug was not happening for us. If you had not told us to expect a crash, then we would not be able to draw any conclusion from our observations. To collect all this information, you can use a session recording program such as , which is available on many Unix systems. Just run your GDB session inside and then include the file with your bug report. Another way to record a GDB session is to run GDB inside Emacs and then save the entire buffer to a file.\n• If you wish to suggest changes to the GDB source, send us context diffs. If you even discuss something in the GDB source, refer to it by context, not by line number. The line numbers in our development sources will not match those in your sources. Your line numbers would convey no useful information to us.\n\nHere are some things that are not necessary:\n• A description of the envelope of the bug. Often people who encounter a bug spend a lot of time investigating which changes to the input file will make the bug go away and which changes will not affect it. This is often time consuming and not very useful, because the way we will find the bug is by running a single example under the debugger with breakpoints, not by pure deduction from a series of examples. We recommend that you save your time for something else. Of course, if you can find a simpler example to report instead of the original one, that is a convenience for us. Errors in the output will be easier to spot, running under the debugger will take less time, and so on. However, simplification is not vital; if you do not want to do this, report the bug anyway and send us the entire test case you used.\n• A patch for the bug. A patch for the bug does help us if it is a good one. But do not omit the necessary information, such as the test case, on the assumption that a patch is all we need. We might see problems with your patch and decide to fix the problem another way, or we might not understand it at all. Sometimes with a program as complicated as GDB it is very hard to construct an example that will make the program follow a certain path through the code. If you do not send us the example, we will not be able to construct one, so we will not be able to verify that the bug is fixed. And if we cannot understand what bug you are trying to fix, or why your patch should be an improvement, we will not install it. A test case will help us to understand.\n• A guess about what the bug is or what it depends on. Such guesses are usually wrong. Even we cannot guess right about such things without first using the debugger to find the facts.\n\nThis chapter describes the basic features of the GNU command line editing interface.\n\nThe following paragraphs describe the notation used to represent keystrokes.\n\nThe text is read as ‘Control-K’ and describes the character produced when the key is pressed while the Control key is depressed.\n\nThe text is read as ‘Meta-K’ and describes the character produced when the Meta key (if you have one) is depressed, and the key is pressed. The Meta key is labeled on many keyboards. On keyboards with two keys labeled (usually to either side of the space bar), the on the left side is generally set to work as a Meta key. The key on the right may also be configured to work as a Meta key or may be configured as some other modifier, such as a Compose key for typing accented characters.\n\nIf you do not have a Meta or key, or another key working as a Meta key, the identical keystroke can be generated by typing first, and then typing . Either process is known as metafying the key.\n\nThe text is read as ‘Meta-Control-k’ and describes the character produced by metafying .\n\nIn addition, several keys have their own names. Specifically, , , , , , and all stand for themselves when seen in this text, or in an init file (see Readline Init File). If your keyboard lacks a key, typing will produce the desired character. The key may be labeled or on some keyboards.\n\nOften during an interactive session you type in a long line of text, only to notice that the first word on the line is misspelled. The Readline library gives you a set of commands for manipulating the text as you type it in, allowing you to just fix your typo, and not forcing you to retype the majority of the line. Using these editing commands, you move the cursor to the place that needs correction, and delete or insert the text of the corrections. Then, when you are satisfied with the line, you simply press . You do not have to be at the end of the line to press ; the entire line is accepted regardless of the location of the cursor within the line.\n\nIn order to enter characters into the line, simply type them. The typed character appears where the cursor was, and then the cursor moves one space to the right. If you mistype a character, you can use your erase character to back up and delete the mistyped character.\n\nSometimes you may mistype a character, and not notice the error until you have typed several other characters. In that case, you can type to move the cursor to the left, and then correct your mistake. Afterwards, you can move the cursor to the right with .\n\nWhen you add text in the middle of a line, you will notice that characters to the right of the cursor are ‘pushed over’ to make room for the text that you have inserted. Likewise, when you delete text behind the cursor, characters to the right of the cursor are ‘pulled back’ to fill in the blank space created by the removal of the text. A list of the bare essentials for editing the text of an input line follows.\n\nThe above table describes the most basic keystrokes that you need in order to do editing of the input line. For your convenience, many other commands have been added in addition to , , , and . Here are some commands for moving more rapidly about the line.\n\nNotice how moves forward a character, while moves forward a word. It is a loose convention that control keystrokes operate on characters while meta keystrokes operate on words.\n\nKilling text means to delete the text from the line, but to save it away for later use, usually by yanking (re-inserting) it back into the line. (‘Cut’ and ‘paste’ are more recent jargon for ‘kill’ and ‘yank’.)\n\nIf the description for a command says that it ‘kills’ text, then you can be sure that you can get the text back in a different (or the same) place later.\n\nWhen you use a kill command, the text is saved in a kill-ring. Any number of consecutive kills save all of the killed text together, so that when you yank it back, you get it all. The kill ring is not line specific; the text that you killed on a previously typed line is available to be yanked back later, when you are typing another line.\n\nHere is the list of commands for killing text.\n\nHere is how to yank the text back into the line. Yanking means to copy the most-recently-killed text from the kill buffer.\n\nYou can pass numeric arguments to Readline commands. Sometimes the argument acts as a repeat count, other times it is the sign of the argument that is significant. If you pass a negative argument to a command which normally acts in a forward direction, that command will act in a backward direction. For example, to kill text back to the start of the line, you might type ‘ ’.\n\nThe general way to pass numeric arguments to a command is to type meta digits before the command. If the first ‘digit’ typed is a minus sign (‘ ’), then the sign of the argument will be negative. Once you have typed one meta digit to get the argument started, you can type the remainder of the digits, and then the command. For example, to give the command an argument of 10, you could type ‘ ’, which will delete the next ten characters on the input line.\n\n33.2.5 Searching for Commands in the History\n\nReadline provides commands for searching through the command history for lines containing a specified string. There are two search modes: incremental and non-incremental.\n\nIncremental searches begin before the user has finished typing the search string. As each character of the search string is typed, Readline displays the next entry from the history matching the string typed so far. An incremental search requires only as many characters as needed to find the desired history entry. To search backward in the history for a particular string, type . Typing searches forward through the history. The characters present in the value of the variable are used to terminate an incremental search. If that variable has not been assigned a value, the and characters will terminate an incremental search. will abort an incremental search and restore the original line. When the search is terminated, the history entry containing the search string becomes the current line.\n\nTo find other matching entries in the history list, type or as appropriate. This will search backward or forward in the history for the next entry matching the search string typed so far. Any other key sequence bound to a Readline command will terminate the search and execute that command. For instance, a will terminate the search and accept the line, thereby executing the command from the history list. A movement command will terminate the search, make the last line found the current line, and begin editing.\n\nReadline remembers the last incremental search string. If two s are typed without any intervening characters defining a new search string, any remembered search string is used.\n\nNon-incremental searches read the entire search string before starting to search for matching history lines. The search string may be typed by the user or be part of the contents of the current line.\n\nAlthough the Readline library comes with a set of Emacs-like keybindings installed by default, it is possible to use a different set of keybindings. Any user can customize programs that use Readline by putting commands in an inputrc file, conventionally in their home directory. The name of this file is taken from the value of the environment variable . If that variable is unset, the default is . If that file does not exist or cannot be read, the ultimate default is .\n\nWhen a program which uses the Readline library starts up, the init file is read, and the key bindings are set.\n\nIn addition, the command re-reads this init file, thus incorporating any changes that you might have made to it.\n\nThere are only a few basic constructs allowed in the Readline init file. Blank lines are ignored. Lines beginning with a ‘ ’ are comments. Lines beginning with a ‘ ’ indicate conditional constructs (see Conditional Init Constructs). Other lines denote variable settings and key bindings.\n\nReadline implements a facility similar in spirit to the conditional compilation features of the C preprocessor which allows key bindings and variable settings to be performed as the result of tests. There are four parser directives used.\n\nHere is an example of an file. This illustrates key binding, variable assignment, and conditional syntax.\n\nThis section describes Readline commands that may be bound to key sequences. Command names without an accompanying key sequence are unbound by default.\n\nIn the following descriptions, point refers to the current cursor position, and mark refers to a cursor position saved by the command. The text between the point and mark is referred to as the region.\n\nWhile the Readline library does not have a full set of editing functions, it does contain enough to allow simple editing of the line. The Readline mode behaves as specified in the POSIX standard.\n\nIn order to switch interactively between and editing modes, use the command (bound to emacs-editing-mode when in mode and to vi-editing-mode in mode). The Readline default is mode.\n\nWhen you enter a line in mode, you are already placed in ‘insertion’ mode, as if you had typed an ‘ ’. Pressing switches you into ‘command’ mode, where you can edit the text of the line with the standard movement keys, move to previous history lines with ‘ ’ and subsequent lines with ‘ ’, and so forth.\n\nThis chapter describes how to use the GNU History Library interactively, from a user’s standpoint. It should be considered a user’s guide. For information on using the GNU History Library in your own programs, see Programming with GNU History in .\n\nThe History library provides a history expansion feature that is similar to the history expansion provided by . This section describes the syntax used to manipulate the history information.\n\nHistory expansions introduce words from the history list into the input stream, making it easy to repeat commands, insert the arguments to a previous command into the current input line, or fix errors in previous commands quickly.\n\nHistory expansion takes place in two parts. The first is to determine which line from the history list should be used during substitution. The second is to select portions of that line for inclusion into the current one. The line selected from the history is called the event, and the portions of that line that are acted upon are called words. Various modifiers are available to manipulate the selected words. The line is broken into words in the same fashion that Bash does, so that several words surrounded by quotes are considered one word. History expansions are introduced by the appearance of the history expansion character, which is ‘ ’ by default.\n\nHistory expansion implements shell-like quoting conventions: a backslash can be used to remove the special handling for the next character; single quotes enclose verbatim sequences of characters, and can be used to inhibit history expansion; and characters enclosed within double quotes may be subject to history expansion, since backslash can escape the history expansion character, but single quotes may not, since they are not treated specially within double quotes.\n\nAn event designator is a reference to a command line entry in the history list. Unless the reference is absolute, events are relative to the current position in the history list.\n\nWord designators are used to select desired words from the event. A ‘ ’ separates the event specification from the word designator. It may be omitted if the word designator begins with a ‘ ’, ‘ ’, ‘ ’, ‘ ’, or ‘ ’. Words are numbered from the beginning of the line, with the first word being denoted by 0 (zero). Words are inserted into the current line separated by single spaces.\n\nHere are the word designators:\n\nIf a word designator is supplied without an event specification, the previous command is used as the event.\n\nAfter the optional word designator, you can add a sequence of one or more of the following modifiers, each preceded by a ‘ ’. These modify, or edit, the word or words selected from the history event.\n\nThe GDB project mourns the loss of the following long-time contributors:\n\nBeyond their technical contributions to the project, they were also enjoyable members of the Free Software Community. We will miss them.\n\nThe GDB 4 release includes an already-formatted reference card, ready for printing with PostScript or Ghostscript, in the subdirectory of the main source directory20. If you can use PostScript or Ghostscript with your printer, you can print the reference card immediately with .\n\nThe release also includes the source for the reference card. You can format it, using TeX, by typing:\n\nThe GDB reference card is designed to print in landscape mode on US “letter” size paper; that is, on a sheet 11 inches wide by 8.5 inches high. You will need to specify this form of printing as an option to your DVI output program.\n\nAll the documentation for GDB comes as part of the machine-readable distribution. The documentation is written in Texinfo format, which is a documentation system that uses a single source file to produce both on-line information and a printed manual. You can use one of the Info formatting commands to create the on-line version of the documentation and TeX (or ) to typeset the printed version.\n\nGDB includes an already formatted copy of the on-line Info version of this manual in the subdirectory. The main Info file is , and it refers to subordinate files matching ‘ ’ in the same directory. If necessary, you can print out these files, or read them with any editor; but they are easier to read using the subsystem in GNU Emacs or the standalone program, available as part of the GNU Texinfo distribution.\n\nIf you want to format these Info files yourself, you need one of the Info formatting programs, such as or .\n\nIf you have installed, and are in the top level GDB source directory ( , in the case of version 17.0.50.20250323-git), you can make the Info file by typing:\n\nIf you want to typeset and print copies of this manual, you need TeX, a program to print its DVI output files, and , the Texinfo definitions file.\n\nTeX is a typesetting program; it does not print files directly, but produces output files called DVI files. To print a typeset document, you need a program to print DVI files. If your system has TeX installed, chances are it has such a program. The precise command to use depends on your system; is common; another (for PostScript devices) is . The DVI print command may require a file name without any extension or a ‘ ’ extension.\n\nTeX also requires a macro definitions file called . This file tells TeX how to typeset a document written in Texinfo format. On its own, TeX cannot either read or typeset a Texinfo file. is distributed with GDB and is located in the directory.\n\nIf you have TeX and a DVI printer program installed, you can typeset and print this manual. First switch to the subdirectory of the main source directory (for example, to ) and type:\n\nThen give to your DVI printing program.\n\nBuilding GDB requires various tools and packages to be available. Other packages will be used only if they are found.\n\nThe tools/packages and libraries listed below are optional; GDB can be build without them, at the expense of some run-time functionality that will be missing. As above, we list the home sites for each package/library, and the command-line options supported by the script to specify their installation directories if they are non-standard. In addition, for each package you can use the option to force GDB to be compiled with the named , and to disable building with it even if it is available. See Configure Options, for detailed description of the options to .\n\nGDB comes with a script that automates the process of preparing GDB for installation; you can then use to build the program.\n\nThe GDB distribution includes all the source code you need for GDB in a single directory, whose name is usually composed by appending the version number to ‘ ’.\n\nFor example, the GDB version 17.0.50.20250323-git distribution is in the directory. That directory contains:\n\nThere may be other subdirectories as well.\n\nThe simplest way to configure and build GDB is to run from the source directory, which in this example is the directory.\n\nFirst switch to the source directory if you are not already in it; then run . Pass the identifier for the platform on which GDB will run as an argument.\n\nRunning ‘ ’ and then running builds the included supporting libraries, then itself. The configured source files, and the binaries, are left in the corresponding source directories.\n\nis a Bourne-shell ( ) script; if your system does not recognize this automatically when you run a different shell, you may need to run on it explicitly:\n\nYou should run the script from the top directory in the source tree, the directory. If you run from one of the subdirectories, you will configure only that subdirectory. That is usually not what you want. In particular, if you run the first from the subdirectory of the directory, you will omit the configuration of , , and other sibling directories of the subdirectory. This leads to build errors about missing include files such as .\n\nYou can install anywhere. The best way to do this is to pass the option to , and then install it with .\n\nIf you want to run GDB versions for several host or target machines, you need a different compiled for each combination of host and target. is designed to make this easy by allowing you to generate each configuration in a separate subdirectory, rather than in the source directory. If your program handles the ‘ ’ feature (GNU does), running in each of these directories builds the program specified there.\n\nTo build in a separate directory, run with the ‘ ’ option to specify where to find the source. (You also need to specify a path to find itself from your working directory. If the path to would be the same as the argument to ‘ ’, you can leave out the ‘ ’ option; it is assumed.)\n\nFor example, with version 17.0.50.20250323-git, you can build GDB in a separate directory for a Sun 4 like this:\n\nWhen builds a configuration using a remote source directory, it creates a tree for the binaries with the same structure (and using the same names) as the tree under the source directory. In the example, you’d find the Sun 4 library in the directory , and GDB itself in .\n\nMake sure that your path to the script has just one instance of in it. If your path to looks like , you are configuring only one subdirectory of GDB, not the whole package. This leads to build errors about missing include files such as .\n\nOne popular reason to build several GDB configurations in separate directories is to configure GDB for cross-compiling (where GDB runs on one machine—the host—while debugging programs that run on another machine—the target). You specify a cross-debugging target by giving the ‘ ’ option to .\n\nWhen you run to build a program or library, you must run it in a configured directory—whatever directory you were in when you called (or one of its subdirectories).\n\nThe that generates in each source directory also runs recursively. If you type in a source directory such as (or in a separate configured directory configured with ‘ ’), you will build all the required libraries, and then build GDB.\n\nWhen you have multiple hosts or targets configured in separate directories, you can run on them in parallel (for example, if they are NFS-mounted on each of the hosts); they will not interfere with each other.\n\nC.4 Specifying Names for Hosts and Targets\n\nThe specifications used for hosts and targets in the script are based on a three-part naming scheme, but some short predefined aliases are also supported. The full naming scheme encodes three pieces of information in the following pattern:\n\nFor example, you can use the alias as a argument, or as the value for in a option. The equivalent full name is ‘ ’.\n\nThe script accompanying GDB does not provide any query facility to list all supported host and target names or aliases. calls the Bourne shell script to map abbreviations to full names; you can read the script, if you wish, or you can use it to test your guesses on abbreviations—for example:\n\nis also distributed in the GDB source directory ( , for version 17.0.50.20250323-git).\n\nHere is a summary of the options and arguments that are most often useful for building GDB. also has several other options not listed here. See (autoconf)Running configure Scripts, for a full explanation of .\n\nYou may introduce options with a single ‘ ’ rather than ‘ ’ if you prefer; but you may abbreviate option names if you use ‘ ’.\n\nThere are many other options that are specific to GDB. This lists just the most common ones; there are some very specialized options not described here.\n\nGDB can be configured to have a system-wide init file and a system-wide init file directory; this file and files in that directory (if they have a recognized file extension) will be read and executed at startup (see What GDB does during startup).\n\nHere are the corresponding configure options:\n\nIf GDB has been configured with the option , they may be subject to relocation. Two possible cases:\n• If the default location of this init file/directory contains , it will be subject to relocation. Suppose that the configure options are ; if GDB is moved from to , the system init file is looked for as instead of .\n• By contrast, if the default location does not contain the prefix, it will not be relocated. E.g. if GDB has been configured with , then GDB will always look for , wherever GDB is installed.\n\nIf the configured location of the system-wide init file (as given by the option at configure time) is in the data-directory (as specified by at configure time) or in one of its subdirectories, then GDB will look for the system-wide init file in the directory specified by the command-line option. Note that the system-wide init file is only read once, during GDB initialization. If the data-directory is changed after GDB has started with the command, the file will not be reread.\n\nThis applies similarly to the system-wide directory specified in .\n\nAny supported scripting language can be used for these init files, as long as the file extension matches the scripting language. To be interpreted as regular GDB commands, the files needs to have a extension.\n\nThe directory, located inside the data-directory (as specified by at configure time) contains a number of scripts which can be used as system-wide init files. To automatically source those scripts at startup, GDB should be configured with . Otherwise, any user should be able to source them by hand as needed.\n\nThe following scripts are currently available:\n• This script is useful when debugging a program on an ELinOS target. It takes advantage of the environment variables defined in a standard ELinOS environment in order to determine the location of the system shared libraries, and then sets the ‘ ’ and ‘ ’ variables appropriately.\n• This script is useful when debugging a program on a target running Wind River Linux. It expects the to be set to the host-side sysroot used by the target system.\n\nIn addition to commands intended for GDB users, GDB includes a number of commands intended for GDB developers, that are not documented elsewhere in this manual. These commands are provided here for reference. (For commands that turn on debugging messages, see Debugging Output.)\n\nThe following command is useful for non-interactive invocations of GDB, such as in the test suite.\n\nThere may be occasions when you need to know something about the protocol—for example, if there is only one serial port to your target machine, you might want your program to do something special if it recognizes a packet meant for GDB.\n\nIn the examples below, ‘ ’ and ‘ ’ are used to indicate transmitted and received data, respectively.\n\nAll GDB commands and responses (other than acknowledgments and notifications, see Notification Packets) are sent as a . A is introduced with the character ‘ ’, the actual , and the terminating character ‘ ’ followed by a two-digit :\n\nThe two-digit is computed as the modulo 256 sum of all characters between the leading ‘ ’ and the trailing ‘ ’ (an eight bit unsigned checksum).\n\nImplementors should note that prior to GDB 5.0 the protocol specification also included an optional two-digit :\n\nThat was appended to the acknowledgment. GDB has never output s. Stubs that handle packets added since GDB 5.0 must not accept .\n\nWhen either the host or the target machine receives a packet, the first response expected is an acknowledgment: either ‘ ’ (to indicate the package was received correctly) or ‘ ’ (to request retransmission):\n\nThe ‘ ’/‘ ’ acknowledgments can be disabled once a connection is established. See Packet Acknowledgment, for details.\n\nThe host (GDB) sends s, and the target (the debugging stub incorporated in your program) sends a . In the case of step and continue s, the response is only sent when the operation has completed, and the target has again stopped all threads in all attached processes. This is the default all-stop mode behavior, but the remote protocol also supports GDB’s non-stop execution mode; see Remote Non-Stop, for details.\n\nconsists of a sequence of characters with the exception of ‘ ’ and ‘ ’ (see ‘ ’ packet for additional exceptions).\n\nFields within the packet should be separated using ‘ ’ ‘ ’ or ‘ ’. Except where otherwise noted all numbers are represented in HEX with leading zeros suppressed.\n\nImplementors should note that prior to GDB 5.0, the character ‘ ’ could not appear as the third character in a packet (as it would potentially conflict with the ).\n\nBinary data in most packets is encoded as two hexadecimal digits per byte of binary data. This allowed the traditional remote protocol to work over connections which were only seven-bit clean. Some packets designed more recently assume an eight-bit clean connection, and use a more efficient encoding to send and receive binary data.\n\nThe binary data representation uses (ASCII ‘ ’) as an escape character. Any escaped byte is transmitted as the escape character followed by the original character XORed with . For example, the byte would be transmitted as the two bytes . The bytes (ASCII ‘ ’), (ASCII ‘ ’), and (ASCII ‘ ’) must always be escaped. Responses sent by the stub must also escape (ASCII ‘ ’), so that it is not interpreted as the start of a run-length encoded sequence (described next).\n\nResponse can be run-length encoded to save space. Run-length encoding replaces runs of identical characters with one instance of the repeated character, followed by a ‘ ’ and a repeat count. The repeat count is itself sent encoded, to avoid binary characters in : a value of is sent as . For a repeat count greater or equal to 3, this produces a printable ASCII character, e.g. a space (ASCII code 32) for a repeat count of 3. (This is because run-length encoding starts to win for counts 3 or more.) Thus, for example, ‘ ’ is a run-length encoding of “0000”: the space character after ‘ ’ means repeat the leading more times.\n\nThe printable characters ‘ ’ and ‘ ’ or with a numeric value greater than 126 must not be used. Runs of six repeats (‘ ’) or seven repeats (‘ ’) can be expanded using a repeat count of only five (‘ ’). For example, ‘ ’ can be encoded as ‘ ’.\n\nSee Standard Replies, for standard error responses, and how to respond indicating a command is not supported.\n\nIn describing packets (commands and responses), each description has a template showing the overall syntax, followed by an explanation of the packet’s meaning. We include spaces in some of the templates for clarity; these are not part of the packet’s syntax. No GDB packet uses spaces to separate its components. For example, a template like ‘ ’ describes a packet beginning with the three ASCII bytes ‘ ’, followed by a , followed directly by a . GDB does not transmit a space character between the ‘ ’ and the , or between the and the .\n\nWe place optional portions of a packet in [square brackets]; for example, a template like ‘ ’ describes a packet beginning with the single ASCII character ‘ ’, possibly followed by an .\n\nAt a minimum, a stub is required to support the ‘ ’ command to tell GDB the reason for halting, ‘ ’ and ‘ ’ commands for register access, and the ‘ ’ and ‘ ’ commands for memory access. Stubs that only control single-threaded targets can implement run control with the ‘ ’ (continue) command, and if the target architecture supports hardware-assisted single-stepping, the ‘ ’ (step) command. Stubs that support multi-threading targets should support the ‘ ’ command. All other commands are optional.\n\nThe remote protocol specifies a few standard replies. All commands support these, except as noted in the individual command descriptions.\n\nThe following table provides a complete list of all currently defined s and their corresponding response . See File-I/O Remote Protocol Extension, for details about the File I/O extension of the remote protocol.\n\nEach packet’s description has a template showing the packet’s overall syntax, followed by an explanation of the packet’s meaning. We include spaces in some of the templates for clarity; these are not part of the packet’s syntax. No GDB packet uses spaces to separate its components. For example, a template like ‘ ’ describes a packet beginning with the three ASCII bytes ‘ ’, followed by a , followed directly by a . GDB does not transmit a space character between the ‘ ’ and the , or between the and the .\n\nSeveral packets and replies include a field to identify a thread. Normally these are positive numbers with a target-specific interpretation, formatted as big-endian hex strings. A can also be a literal ‘ ’ to indicate all threads, or ‘ ’ to pick any thread.\n\nIn addition, the remote protocol supports a multiprocess feature in which the syntax is extended to optionally include both process and thread ID fields, as ‘ ’. The (process) and (thread) components each have the format described above: a positive number with target-specific interpretation formatted as a big-endian hex string, literal ‘ ’ to indicate all processes or threads (respectively), or ‘ ’ to indicate an arbitrary process or thread. Specifying just a process, as ‘ ’, is equivalent to ‘ ’. It is an error to specify all processes but a specific thread, such as ‘ ’. Note that the ‘ ’ prefix is not used for those packets and replies explicitly documented to include a process ID, rather than a .\n\nThe multiprocess syntax extensions are only used if both GDB and the stub report support for the ‘ ’ feature using ‘ ’. See multiprocess extensions, for more information.\n\nNote that all packet forms beginning with an upper- or lower-case letter, other than those described here, are reserved for future use.\n\nHere are the packet descriptions.\n\nThe ‘ ’, ‘ ’, ‘ ’, ‘ ’, ‘ ’, ‘ ’, ‘ ’, ‘ ’, and ‘ ’ packets can receive any of the below as a reply. Except for ‘ ’ and ‘ ’, that reply is only returned when the target halts. In the below the exact meaning of signal number is defined by the header in the GDB source code.\n\nIn non-stop mode, the server will simply reply ‘ ’ to commands such as ‘ ’; any stop will be the subject of a future notification. See Remote Non-Stop.\n\nAs in the description of request packets, we include spaces in the reply templates for clarity; these are not part of the reply packet’s syntax. No GDB stop reply packet uses spaces to separate its components.\n\nPackets starting with ‘ ’ are general query packets; packets starting with ‘ ’ are general set packets. General query and set packets are a semi-unified form for retrieving and sending information to and from the stub.\n\nThe initial letter of a query or set packet is followed by a name indicating what sort of thing the packet applies to. For example, GDB may use a ‘ ’ packet to exchange symbol definitions with the stub. These packet names follow some conventions:\n• The name must not contain commas, colons or semicolons.\n• Most GDB query and set packets have a leading upper case letter.\n• The names of custom vendor packets should use a company prefix, in lower case, followed by a period. For example, packets designed at the Acme Corporation might begin with ‘ ’ (for querying foos) or ‘ ’ (for setting bars).\n\nThe name of a query or set packet should be separated from any parameters by a ‘ ’; the parameters themselves should be separated by ‘ ’ or ‘ ’. Stubs must be careful to match the full packet name, and check for a separator or the end of the packet, in case two packet names share a common prefix. New packets should not begin with ‘ ’, ‘ ’, or ‘ ’21.\n\nLike the descriptions of the other packets, each description here has a template showing the packet’s overall syntax, followed by an explanation of the packet’s meaning. We include spaces in some of the templates for clarity; these are not part of the packet’s syntax. No GDB packet uses spaces to separate its components.\n\nHere are the currently defined query and set packets:\n\nThis section describes how the remote protocol is applied to specific target architectures. Also see Standard Target Features, for details of XML target descriptions for each architecture.\n\nThese breakpoint kinds are defined for the ‘ ’ and ‘ ’ packets.\n\nThese memory tag types are defined for the ‘ ’ and ‘ ’ packets.\n\nThe following / packets have previously been defined. In the below, some thirty-two bit registers are transferred as sixty-four bits. Those registers should be zero/sign extended (which?) to fill the space allocated. Register bytes are transferred in target byte order. The two nibbles within a register byte are transferred most-significant – least-significant.\n\nThese breakpoint kinds are defined for the ‘ ’ and ‘ ’ packets.\n\nHere we describe the packets GDB uses to implement tracepoints (see Tracepoints).\n\nWhen installing fast tracepoints in memory, the target may need to relocate the instruction currently at the tracepoint address to a different address in memory. For most instructions, a simple copy is enough, but, for example, call instructions that implicitly push the return address on the stack, and relative branches or other PC-relative instructions require offset adjustment, so that the effect of executing the instruction at a different address is the same as if it had executed in the original location.\n\nIn response to several of the tracepoint packets, the target may also respond with a number of intermediate ‘ ’ request packets before the final result packet, to have GDB handle this relocation operation. If a packet supports this mechanism, its documentation will explicitly say so. See for example the above descriptions for the ‘ ’ and ‘ ’ packets. The format of the request is:\n\nThe Host I/O packets allow GDB to perform I/O operations on the far side of a remote link. For example, Host I/O is used to upload and download files to a remote target with its own filesystem. Host I/O uses the same constant values and data structure layout as the target-initiated File-I/O protocol. However, the Host I/O packets are structured differently. The target-initiated protocol relies on target memory to store parameters and buffers. Host I/O requests are initiated by GDB, and the target’s memory is not involved. See File-I/O Remote Protocol Extension, for more details on the target-initiated protocol.\n\nThe Host I/O request packets all encode a single operation along with its arguments. They have this format:\n\nThe valid responses to Host I/O packets are:\n\nThese are the supported Host I/O operations:\n\nIn all-stop mode, when a program on the remote target is running, GDB may attempt to interrupt it by sending a ‘ ’, or a followed by , control of which is specified via GDB’s ‘ ’.\n\nThe precise meaning of is defined by the transport mechanism and may, in fact, be undefined. GDB does not currently define a mechanism for any of the network interfaces except for TCP, in which case GDB sends the BREAK sequence.\n\n‘ ’, on the other hand, is defined and implemented for all transport mechanisms. It is represented by sending the single byte without any of the usual packet overhead described in the Overview section (see Overview). When a byte is transmitted as part of a packet, it is considered to be packet data and does not represent an interrupt. E.g., an ‘ ’ packet (see X packet), used for binary downloads, may include an unescaped as part of its packet.\n\nfollowed by is also known as Magic SysRq g. When Linux kernel receives this sequence from serial port, it stops execution and connects to gdb.\n\nIn non-stop mode, because packet resumptions are asynchronous (see vCont packet), GDB is always free to send a remote command to the remote stub, even when the target is running. For that reason, GDB instead sends a regular packet (see vCtrlC packet) with the usual packet framing instead of the single byte .\n\nStubs are not required to recognize these interrupt mechanisms and the precise meaning associated with receipt of the interrupt is implementation defined. If the target supports debugging of multiple threads and/or processes, it should attempt to interrupt all currently-executing threads and processes. If the stub is successful at interrupting the running program, it should send one of the stop reply packets (see Stop Reply Packets) to GDB as a result of successfully stopping the program in all-stop mode, and a stop reply for each stopped thread in non-stop mode. Interrupts received while the program is stopped are queued and the program will be interrupted when it is resumed next time.\n\nThe GDB remote serial protocol includes notifications, packets that require no acknowledgment. Both the GDB and the stub may send notifications (although the only notifications defined at present are sent by the stub). Notifications carry information without incurring the round-trip latency of an acknowledgment, and so are useful for low-impact communications where occasional packet loss is not a problem.\n\nA notification packet has the form ‘ ’, where is the content of the notification, and is a checksum of , computed and formatted as for ordinary GDB packets. A notification’s never contains ‘ ’, ‘ ’ or ‘ ’ characters. Upon receiving a notification, the recipient sends no ‘ ’ or ‘ ’ to acknowledge the notification’s receipt or to report its corruption.\n\nEvery notification’s begins with a name, which contains no colon characters, followed by a colon character.\n\nRecipients should silently ignore corrupted notifications and notifications they do not understand. Recipients should restart timeout periods on receipt of a well-formed notification, whether or not they understand it.\n\nSenders should only send the notifications described here when this protocol description specifies that they are permitted. In the future, we may extend the protocol to permit existing notifications in new contexts; this rule helps older senders avoid confusing newer recipients.\n\nEach notification is comprised of three parts:\n\nThe purpose of an asynchronous notification mechanism is to report to GDB that something interesting happened in the remote stub.\n\nThe remote stub may send notification : at any time, but GDB acknowledges the notification when appropriate. The notification event is pending before GDB acknowledges. Only one notification at a time may be pending; if additional events occur before GDB has acknowledged the previous notification, they must be queued by the stub for later synchronous transmission in response to packets from GDB. Because the notification mechanism is unreliable, the stub is permitted to resend a notification if it believes GDB may not have received it.\n\nSpecifically, notifications may appear when GDB is not otherwise reading input from the stub, or when GDB is expecting to read a normal synchronous response or a ‘ ’/‘ ’ acknowledgment to a packet it has sent. Notification packets are distinct from any other communication from the stub so there is no ambiguity.\n\nAfter receiving a notification, GDB shall acknowledge it by sending a packet as a regular, synchronous request to the stub. Such acknowledgment is not required to happen immediately, as GDB is permitted to send other, unrelated packets to the stub first, which the stub should process normally.\n\nUpon receiving a packet, if the stub has other queued events to report to GDB, it shall respond by sending a normal . GDB shall then send another packet to solicit further responses; again, it is permitted to send other, unrelated packets as well which the stub should process normally.\n\nIf the stub receives a packet and there are no additional to report, the stub shall return an ‘ ’ response. At this point, GDB has finished processing a notification and the stub has completed sending any queued events. GDB won’t accept any new notifications until the final ‘ ’ is received . If further notification events occur, the stub shall send a new notification, GDB shall accept the notification, and the process shall be repeated.\n\nThe process of asynchronous notification can be illustrated by the following example:\n\nThe following notifications are defined:\n\nGDB’s remote protocol supports non-stop debugging of multi-threaded programs, as described in Non-Stop Mode. If the stub supports non-stop mode, it should report that to GDB by including ‘ ’ in its ‘ ’ response (see qSupported).\n\nGDB typically sends a ‘ ’ packet only when establishing a new connection with the stub. Entering non-stop mode does not alter the state of any currently-running threads, but targets must stop all threads in any already-attached processes when entering all-stop mode. GDB uses the ‘ ’ packet as necessary to probe the target state after a mode change.\n\nIn non-stop mode, when an attached process encounters an event that would otherwise be reported with a stop reply, it uses the asynchronous notification mechanism (see Notification Packets) to inform GDB. In contrast to all-stop mode, where all threads in all processes are stopped when a stop reply is sent, in non-stop mode only the thread reporting the stop event is stopped. That is, when reporting a ‘ ’ or ‘ ’ response to indicate completion of a step operation, hitting a breakpoint, or a fault, only the affected thread is stopped; any other still-running threads continue to run. When reporting a ‘ ’ or ‘ ’ response, all running threads belonging to other attached processes continue to run.\n\nIn non-stop mode, the target shall respond to the ‘ ’ packet as follows. First, any incomplete stop reply notification/‘ ’ sequence in progress is abandoned. The target must begin a new sequence reporting stop events for all stopped threads, whether or not it has previously reported those events to GDB. The first stop reply is sent as a synchronous reply to the ‘ ’ packet, and subsequent stop replies are sent as responses to ‘ ’ packets using the mechanism described above. The target must not send asynchronous stop reply notifications until the sequence is complete. If all threads are running when the target receives the ‘ ’ packet, or if the target is not attached to any process, it shall respond ‘ ’.\n\nIf the stub supports non-stop mode, it should also support the ‘ ’ stop reason if software breakpoints are supported, and the ‘ ’ stop reason if hardware breakpoints are supported (see swbreak stop reason). This is because given the asynchronous nature of non-stop mode, between the time a thread hits a breakpoint and the time the event is finally processed by GDB, the breakpoint may have already been removed from the target. Due to this, GDB needs to be able to tell whether a trap stop was caused by a delayed breakpoint event, which should be ignored, as opposed to a random trap signal, which should be reported to the user. Note the ‘ ’ feature implies that the target is responsible for adjusting the PC when a software breakpoint triggers, if necessary, such as on the x86 architecture.\n\nBy default, when either the host or the target machine receives a packet, the first response expected is an acknowledgment: either ‘ ’ (to indicate the package was received correctly) or ‘ ’ (to request retransmission). This mechanism allows the GDB remote protocol to operate over unreliable transport mechanisms, such as a serial line.\n\nIn cases where the transport mechanism is itself reliable (such as a pipe or TCP connection), the ‘ ’/‘ ’ acknowledgments are redundant. It may be desirable to disable them in that case to reduce communication overhead, or for other reasons. This can be accomplished by means of the ‘ ’ packet; see QStartNoAckMode.\n\nWhen in no-acknowledgment mode, neither the stub nor GDB shall send or expect ‘ ’/‘ ’ protocol acknowledgments. The packet and response format still includes the normal checksum, as described in Overview, but the checksum may be ignored by the receiver.\n\nIf the stub supports ‘ ’ and prefers to operate in no-acknowledgment mode, it should report that to GDB by including ‘ ’ in its response to ‘ ’; see qSupported. If GDB also supports ‘ ’ and it has not been disabled via the command (see Remote Configuration), GDB may then send a ‘ ’ packet to the stub. Only then may the stub actually turn off packet acknowledgments. GDB sends a final ‘ ’ acknowledgment of the stub’s ‘ ’ response, which can be safely ignored by the stub.\n\nNote that command only affects negotiation between GDB and the stub when subsequent connections are made; it does not affect the protocol acknowledgment state for any current connection. Since ‘ ’/‘ ’ acknowledgments are enabled by default when a new connection is established, there is also no protocol request to re-enable the acknowledgments for the current connection, once disabled.\n\nExample sequence of a target being re-started. Notice how the restart does not get any direct output:\n\nExample sequence of a target being stepped by a single instruction:\n\nThe File I/O remote protocol extension (short: File-I/O) allows the target to use the host’s file system and console I/O to perform various system calls. System calls on the target system are translated into a remote protocol packet to the host system, which then performs the needed actions and returns a response packet to the target system. This simulates file system operations even on targets that lack file systems.\n\nThe protocol is defined to be independent of both the host and target systems. It uses its own internal representation of datatypes and values. Both GDB and the target’s GDB stub are responsible for translating the system-dependent value representations into the internal protocol representations when data is transmitted.\n\nThe communication is synchronous. A system call is possible only when GDB is waiting for a response from the ‘ ’, ‘ ’, ‘ ’ or ‘ ’ packets. While GDB handles the request for a system call, the target is stopped to allow deterministic access to the target’s memory. Therefore File-I/O is not interruptible by target signals. On the other hand, it is possible to interrupt File-I/O by a user interrupt (‘ ’) within GDB.\n\nThe target’s request to perform a host system call does not finish the latest ‘ ’, ‘ ’, ‘ ’ or ‘ ’ action. That means, after finishing the system call, the target returns to continuing the previous activity (continue, step). No additional continue or step request from GDB is required.\n\nThe protocol only supports I/O on the console and to regular files on the host file system. Character or block special devices, pipes, named pipes, sockets or any other communication method on the host system are not supported by this protocol.\n\nFile I/O is not supported in non-stop mode.\n\nThe File-I/O protocol uses the packet as the request as well as reply packet. Since a File-I/O system call can only occur when GDB is waiting for a response from the continuing or stepping target, the File-I/O request is a reply that GDB has to expect as a result of a previous ‘ ’, ‘ ’, ‘ ’ or ‘ ’ packet. This packet contains all information needed to allow GDB to call the appropriate host system call:\n• All parameters to the system call. Pointers are given as addresses in the target memory address space. Pointers to strings are given as pointer/length pair. Numerical values are given as they are. Numerical control flags are given in a protocol-specific representation.\n\nAt this point, GDB has to perform the following actions.\n• If the parameters include pointer values to data needed as input to a system call, GDB requests this data from the target with a standard packet request. This additional communication has to be expected by the target implementation and is handled as any other packet.\n• GDB translates all value from protocol representation to host representation as needed. Datatypes are coerced into the host types.\n• It then coerces datatypes back to protocol representation.\n• If the system call is expected to return data in buffer space specified by pointer parameters to the call, the data is transmitted to the target using a or packet. This packet has to be expected by the target implementation and is handled as any other or packet.\n\nEventually GDB replies with another packet which contains all necessary information for the target to continue. This at least contains\n• , if has been changed by the system call.\n\nAfter having done the needed type and value coercion, the target continues the latest continue or step action.\n\nThe request packet has the following format:\n\nThe reply packet has the following format:\n\nIf the ‘ ’ flag is set in the GDB reply packet (see The F Reply Packet), the target should behave as if it had gotten a break message. The meaning for the target is “system call interrupted by ”. Consequently, the target should actually stop (as with a break message) and return to GDB with a packet.\n\nIt’s important for the target to know in which state the system call was interrupted. There are two possible cases:\n• The system call hasn’t been performed on the host yet.\n• The system call on the host has been finished.\n\nThese two states can be distinguished by the target by the value of the returned . If it’s the protocol representation of , the system call hasn’t been performed. This is equivalent to the handling on POSIX systems. In any other case, the target may presume that the system call has been finished — successfully or not — and should behave as if the break message arrived right after the system call.\n\nGDB must behave reliably. If the system call has not been called yet, GDB may send the reply immediately, setting as in the packet. If the system call on the host has been finished before the user requests a break, the full action must be finished by GDB. This requires sending or packets as necessary. The packet may only be sent when either nothing has happened or the full action has been completed.\n\nBy default and if not explicitly closed by the target system, the file descriptors 0, 1 and 2 are connected to the GDB console. Output on the GDB console is handled as any other file output operation ( or ). Console input is handled by GDB so that after the target read request from file descriptor 0 all following typing is buffered until either one of the following conditions is met:\n• The user types . The behavior is as explained above, and the system call is treated as finished.\n• The user presses . This is treated as end of input with a trailing newline.\n• The user types . This is treated as end of input. No trailing character (neither newline nor ‘ ’) is appended to the input.\n\nIf the user has typed more characters than fit in the buffer given to the call, the trailing characters are buffered in GDB until either another is requested by the target, or debugging is stopped at the user’s request.\n\nNote that the call is treated as a special case: it returns 1 to the target if the file descriptor is attached to the GDB console, 0 otherwise. Implementing through system calls would require implementing and would be more complex than needed.\n\nGDB takes over the full task of calling the necessary host calls to perform the call. The return value of on the host is simplified before it’s returned to the target. Any termination signal information from the child process is discarded, and the return value consists entirely of the exit status of the called command.\n\nDue to security concerns, the call is by default refused by GDB. The user has to allow this call explicitly with the command.\n\nThe integral datatypes used in the system calls are , , , , , and .\n\n, , and are implemented as 32 bit values in this protocol.\n\nand are implemented as 64 bit types.\n\nSee Limits, for corresponding MIN and MAX values (similar to those in ) to allow range checking on host and target.\n\ndatatypes are defined as seconds since the Epoch.\n\nAll integral datatypes transferred as part of a memory read or write of a structured datatype e.g. a have to be given in big endian byte order.\n\nPointers to target data are transmitted as they are. An exception is made for pointers to buffers for which the length isn’t transmitted as part of the function call, namely strings. Strings are transmitted as a pointer/length pair, both as hex values, e.g.\n\nwhich is a pointer to data of length 18 bytes at position 0x1aaf. The length is defined as the full string length in bytes, including the trailing null byte. For example, the string at address 0x123456 is transmitted as\n\nStructured data which is transferred using a memory read or write (for example, a ) is expected to be in a protocol-specific format with all scalar multibyte datatypes being big endian. Translation to this representation needs to be done both by the target before the packet is sent, and by GDB before it transfers memory to the target. Transferred pointers to structured data should point to the already-coerced data at any time.\n\nThe buffer of type used by the target and GDB is defined as follows:\n\nThe integral datatypes conform to the definitions given in the appropriate section (see Integral Datatypes, for details) so this structure is of size 64 bytes.\n\nThe values of several fields have a restricted meaning and/or range of values.\n\nThe target gets a of the above representation and is responsible for coercing it to the target representation before continuing.\n\nNote that due to size differences between the host, target, and protocol representations of members, these members could eventually get truncated on the target.\n\nThe buffer of type used by the File-I/O protocol is defined as follows:\n\nThe integral datatypes conform to the definitions given in the appropriate section (see Integral Datatypes, for details) so this structure is of size 8 bytes.\n\nThe following values are used for the constants inside of the protocol. GDB and target are responsible for translating these values before and after the call as needed.\n\nAll values are given in hexadecimal representation.\n\nAll values are given in octal representation.\n\nAll values are given in decimal representation.\n\nis used as a fallback error value if a host system returns any error value not in the list of supported error numbers.\n\nAll values are given in decimal representation.\n\nExample sequence of a write call, file descriptor 3, buffer is at target address 0x1234, 6 bytes should be written:\n\nExample sequence of a read call, file descriptor 3, buffer is at target address 0x1234, 6 bytes should be read:\n\nExample sequence of a read call, call fails on the host due to invalid file descriptor ( ):\n\nExample sequence of a read call, user presses before syscall on host is called:\n\nExample sequence of a read call, user presses after syscall on host is called:\n\nOn some platforms, a dynamic loader (e.g. ) runs in the same process as your application to manage libraries. In this case, GDB can use the loader’s symbol table and normal memory operations to maintain a list of shared libraries. On other platforms, the operating system manages loaded libraries. GDB can not retrieve the list of currently loaded libraries through memory operations, so it uses the ‘ ’ packet (see qXfer library list read) instead. The remote stub queries the target’s operating system and reports which libraries are loaded.\n\nThe ‘ ’ packet returns an XML document which lists loaded libraries and their offsets. Each library has an associated name and one or more segment or section base addresses, which report where the library was loaded in memory.\n\nFor the common case of libraries that are fully linked binaries, the library should have a list of segments. If the target supports dynamic linking of a relocatable object file, its library XML element should instead include a list of allocated sections. The segment or section bases are start addresses, not relocation offsets; they do not depend on the library’s link-time base addresses.\n\nGDB must be linked with the Expat library to support XML library lists. See Expat.\n\nA simple memory map, with one loaded library relocated by a single offset, looks like this:\n\nAnother simple memory map, with one loaded library with three allocated sections (.text, .data, .bss), looks like this:\n\nThe format of a library list is described by this DTD:\n\nIn addition, segments and section descriptors cannot be mixed within a single library element, and you must supply at least one segment or section for each library.\n\nOn SVR4 platforms GDB can use the symbol table of a dynamic loader (e.g. ) and normal memory operations to maintain a list of shared libraries. Still a special library list provided by this packet is more efficient for the GDB remote protocol.\n\nThe ‘ ’ packet returns an XML document which lists loaded libraries and their SVR4 linker parameters. For each library on SVR4 target, the following parameters are reported:\n• - , the absolute file name from the field of .\n• - with address of used for TLS (Thread Local Storage) access.\n• - , the displacement as read from the field of . For prelinked libraries this is not an absolute memory address. It is a displacement of absolute memory address against address the file was prelinked to during the library load.\n• - , which is memory address of the segment\n• - , which is an identifier for a linker namespace, such as the memory address of the object that contains this namespace’s load map or the namespace identifier returned by .\n\nAdditionally the single attribute specifies address of used for the main executable. This parameter is used for TLS access and its presence is optional.\n\nGDB must be linked with the Expat library to support XML SVR4 library lists. See Expat.\n\nA simple memory map, with two loaded libraries (which do not use prelink), looks like this:\n\nThe format of an SVR4 library list is described by this DTD:\n\nTo be able to write into flash memory, GDB needs to obtain a memory map from the target. This section describes the format of the memory map.\n\nThe memory map is obtained using the ‘ ’ (see qXfer memory map read) packet and is an XML document that lists memory regions.\n\nGDB must be linked with the Expat library to support XML memory maps. See Expat.\n\nThe top-level structure of the document is shown below:\n\nEach region can be either:\n• A region of RAM starting at and extending for bytes from there:\n• A region of flash memory, with erasure blocks bytes in length:\n\nRegions must not overlap. GDB assumes that areas of memory not covered by the memory map are RAM, and uses the ordinary ‘ ’ and ‘ ’ packets to write to addresses in such ranges.\n\nThe formal DTD for memory map format is given below:\n\nTo efficiently update the list of threads and their attributes, GDB issues the ‘ ’ packet (see qXfer threads read) and obtains the XML document with the following structure:\n\nEach ‘ ’ element must have the ‘ ’ attribute that identifies the thread (see thread-id syntax). The ‘ ’ attribute, if present, specifies which processor core the thread was last executing on. The ‘ ’ attribute, if present, specifies the human-readable name of the thread. The content of the of ‘ ’ element is interpreted as human-readable auxiliary information. The ‘ ’ attribute, if present, specifies what GDB should print as the target ID of the thread (e.g. in the ‘ ’ command or when switching to the thread). The ‘ ’ attribute, if present, is a hex encoded representation of the thread handle.\n\nTo be able to know which objects in the inferior can be examined when inspecting a tracepoint hit, GDB needs to obtain the list of memory ranges, registers and trace state variables that have been collected in a traceframe.\n\nThis list is obtained using the ‘ ’ (see qXfer traceframe info read) packet and is an XML document.\n\nGDB must be linked with the Expat library to support XML traceframe info discovery. See Expat.\n\nThe top-level structure of the document is shown below:\n\nEach traceframe block can be either:\n• A region of collected memory starting at and extending for bytes from there:\n\nThe formal DTD for the traceframe info format is given below:\n\nIn order to display the branch trace of an inferior thread, GDB needs to obtain the list of branches. This list is represented as list of sequential code blocks that are connected via branches. The code in each block has been executed sequentially.\n\nThis list is obtained using the ‘ ’ (see qXfer btrace read) packet and is an XML document.\n\nGDB must be linked with the Expat library to support XML traceframe info discovery. See Expat.\n\nThe top-level structure of the document is shown below:\n• A block of sequentially executed instructions starting at and ending at :\n\nThe formal DTD for the branch trace format is given below:\n\nFor each inferior thread, GDB can obtain the branch trace configuration using the ‘ ’ (see qXfer btrace-conf read) packet.\n\nThe configuration describes the branch trace format and configuration settings for that format. The following information is described:\n\nGDB must be linked with the Expat library to support XML branch trace configuration discovery. See Expat.\n\nThe formal DTD for the branch trace configuration format is given below:\n\nIn some applications, it is not feasible for the debugger to interrupt the program’s execution long enough for the developer to learn anything helpful about its behavior. If the program’s correctness depends on its real-time behavior, delays introduced by a debugger might cause the program to fail, even when the code itself is correct. It is useful to be able to observe the program’s behavior without interrupting it.\n\nUsing GDB’s and commands, the user can specify locations in the program, and arbitrary expressions to evaluate when those locations are reached. Later, using the command, she can examine the values those expressions had when the program hit the trace points. The expressions may also denote objects in memory — structures or arrays, for example — whose values GDB should record; while visiting a particular tracepoint, the user may inspect those objects as if they were in memory at that moment. However, because GDB records these values without interacting with the user, it can do so quickly and unobtrusively, hopefully not disturbing the program’s behavior.\n\nWhen GDB is debugging a remote target, the GDB agent code running on the target computes the values of the expressions itself. To avoid having a full symbolic expression evaluator on the agent, GDB translates expressions in the source language into a simpler bytecode language, and then sends the bytecode to the agent; the agent then executes the bytecode, and records the values for GDB to retrieve later.\n\nThe bytecode language is simple; there are forty-odd opcodes, the bulk of which are the usual vocabulary of C operands (addition, subtraction, shifts, and so on) and various sizes of literals and memory reference operations. The bytecode interpreter operates strictly on machine-level values — various sizes of integers and floating point numbers — and requires no information about types or symbols; thus, the interpreter’s internal data structures are simple, and each bytecode requires only a few native machine instructions to implement it. The interpreter is small, and strict limits on the memory and time required to evaluate an expression are easy to determine, making it suitable for use by the debugging agent in real-time applications.\n\nThe agent represents bytecode expressions as an array of bytes. Each instruction is one byte long (thus the term bytecode). Some instructions are followed by operand bytes; for example, the instruction is followed by a destination for the jump.\n\nThe bytecode interpreter is a stack-based machine; most instructions pop their operands off the stack, perform some operation, and push the result back on the stack for the next instruction to consume. Each element of the stack may contain either a integer or a floating point value; these values are as many bits wide as the largest integer that can be directly manipulated in the source language. Stack elements carry no record of their type; bytecode could push a value as an integer, then pop it as a floating point value. However, GDB will not generate code which does this. In C, one might define the type of a stack element as follows:\n\nwhere and are names for the largest integer and floating point types on the machine.\n\nBy the time the bytecode interpreter reaches the end of the expression, the value of the expression should be the only value left on the stack. For tracing applications, bytecodes in the expression will have recorded the necessary data, and the value on the stack may be discarded. For other applications, like conditional breakpoints, the value may be useful.\n\nSeparate from the stack, the interpreter has two registers:\n\nNeither of these registers is directly visible to the bytecode language itself, but they are useful for defining the meanings of the bytecode operations.\n\nThere are no instructions to perform side effects on the running program, or call the program’s functions; we assume that these expressions are only used for unobtrusive debugging, not for patching the running code.\n\nMost bytecode instructions do not distinguish between the various sizes of values, and operate on full-width values; the upper bits of the values are simply ignored, since they do not usually make a difference to the value computed. The exceptions to this rule are:\n\nIf the interpreter is unable to evaluate an expression completely for some reason (a memory location is inaccessible, or a divisor is zero, for example), we say that interpretation “terminates with an error”. This means that the problem is reported back to the interpreter’s caller in some helpful way. In general, code using agent expressions should assume that they may attempt to divide by zero, fetch arbitrary memory locations, and misbehave in other ways.\n\nEven complicated C expressions compile to a few bytecode instructions; for example, the expression would typically produce code like the following, assuming that and live in registers, and is a global variable holding a 32-bit :\n\nIn detail, these mean:\n\nEach bytecode description has the following form:\n\nIn this example, is the name of the bytecode, and is the one-byte value used to encode the bytecode, in hexadecimal. The phrase “ ⇒ ” shows the stack before and after the bytecode executes. Beforehand, the stack must contain at least two values, and ; since the top of the stack is to the right, is on the top of the stack, and is underneath it. After execution, the bytecode will have popped and from the stack, and replaced them with a single value, . There may be other values on the stack below those shown, but the bytecode affects only those shown.\n\nHere is another example:\n\nIn this example, the bytecode takes an operand directly from the bytecode stream; the operand follows the bytecode itself. We write any such operands immediately after the name of the bytecode, before the colon, and describe the exact encoding of the operand in the bytecode stream in the body of the bytecode description.\n\nFor the bytecode, there are no stack items given before the ⇒; this simply means that the bytecode consumes no values from the stack. If a bytecode consumes no values, or produces no values, the list on either side of the ⇒ may be empty.\n\nIf a value is written as , , or , then the bytecode treats it as an integer. If a value is written is , then the bytecode treats it as an address.\n\nWe do not fully describe the floating point operations here; although this design can be extended in a clean way to handle floating point values, they are not of immediate interest to the customer, so we avoid describing them, to save time.\n\nAgent expressions can be used in several different ways by GDB, and the debugger can generate different bytecode sequences as appropriate.\n\nOne possibility is to do expression evaluation on the target rather than the host, such as for the conditional of a conditional tracepoint. In such a case, GDB compiles the source expression into a bytecode sequence that simply gets values from registers or memory, does arithmetic, and returns a result.\n\nAnother way to use agent expressions is for tracepoint data collection. GDB generates a different bytecode sequence for collection; in addition to bytecodes that do the calculation, GDB adds bytecodes to save the pieces of memory that were used.\n• The user selects trace points in the program’s code at which GDB should collect data.\n• The user specifies expressions to evaluate at each trace point. These expressions may denote objects in memory, in which case those objects’ contents are recorded as the program runs, or computed values, in which case the values themselves are recorded.\n• GDB transmits the tracepoints and their associated expressions to the GDB agent, running on the debugging target.\n• The agent arranges to be notified when a trace point is hit.\n• When execution on the target reaches a trace point, the agent evaluates the expressions associated with that trace point, and records the resulting values and memory ranges.\n• Later, when the user selects a given trace event and inspects the objects and expression values recorded, GDB talks to the agent to retrieve recorded data as necessary to meet the user’s requests. If the user asks to see an object whose contents have not been recorded, GDB reports an error.\n\nSome targets don’t support floating-point, and some would rather not have to deal with operations. Also, different targets will have different stack sizes, and different bytecode buffer lengths.\n\nThus, GDB needs a way to ask the target about itself. We haven’t worked out the details yet, but in general, GDB should be able to send the target a packet asking it to describe itself. The reply should be a packet whose length is explicit, so we can add new information to the packet in future revisions of the agent, without confusing old versions of GDB, and it should contain a version number. It should contain at least the following information:\n• which registers are actually available for collection\n\nSome of the design decisions apparent above are arguable.\n\nOne of the challenges of using GDB to debug embedded systems is that there are so many minor variants of each processor architecture in use. It is common practice for vendors to start with a standard processor core — ARM, PowerPC, or , for example — and then make changes to adapt it to a particular market niche. Some architectures have hundreds of variants, available from dozens of vendors. This leads to a number of problems:\n• With so many different customized processors, it is difficult for the GDB maintainers to keep up with the changes.\n• Since individual variants may have short lifetimes or limited audiences, it may not be worthwhile to carry information about every variant in the GDB source tree.\n• When GDB does support the architecture of the embedded system at hand, the task of finding the correct architecture name to give the command can be error-prone.\n\nTo address these problems, the GDB remote protocol allows a target system to not only identify itself to GDB, but to actually describe its own features. This lets GDB support processor variants it has never seen before — to the extent that the descriptions are accurate, and that GDB understands them.\n\nGDB must be linked with the Expat library to support XML target descriptions. See Expat.\n\nTarget descriptions can be read from the target automatically, or specified by the user manually. The default behavior is to read the description from the target. GDB retrieves it via the remote protocol using ‘ ’ requests (see qXfer). The in the ‘ ’ packet will be ‘ ’. The contents of the ‘ ’ annex are an XML document, of the form described in Target Description Format.\n\nAlternatively, you can specify a file to read for the target description. If a file is set, the target will not be queried. The commands to specify a file are:\n\nA target description annex is an XML document which complies with the Document Type Definition provided in the GDB sources in . This means you can use generally available tools like to check that your feature descriptions are well-formed and valid. However, to help people unfamiliar with XML write descriptions for their targets, we also describe the grammar here.\n\nTarget descriptions can identify the architecture of the remote target and (for some architectures) provide information about custom register sets. They can also identify the OS ABI of the remote target. GDB can use this information to autoconfigure for your target, or to warn you if you connect to an unsupported target.\n\nThis minimal description only says that the target uses the x86-64 architecture.\n\nA target description has the following overall form, with [ ] marking optional elements and … marking repeatable elements. The elements are explained further below.\n\nThe description is generally insensitive to whitespace and line breaks, under the usual common-sense rules. The XML version declaration and document type declaration can generally be omitted (GDB does not require them), but specifying them may be useful for XML validation tools. The ‘ ’ attribute for ‘ ’ may also be omitted, but we recommend including it; if future versions of GDB use an incompatible revision of , they will detect and report the version mismatch.\n\nIt can sometimes be valuable to split a target description up into several different annexes, either for organizational purposes, or to share files between different possible target descriptions. You can divide a description into multiple files by replacing any element of the target description with an inclusion directive of the form:\n\nWhen GDB encounters an element of this form, it will retrieve the named XML , and replace the inclusion directive with the contents of that document. If the current description was read using ‘ ’, then so will be the included document; will be interpreted as the name of an annex. If the current description was read from a file, GDB will look for as a file in the same directory where it found the original description.\n\nAn ‘ ’ element has this form:\n\nis one of the architectures from the set accepted by (see Specifying a Debugging Target).\n\nThis optional field was introduced in GDB version 7.0. Previous versions of GDB ignore it.\n\nAn ‘ ’ element has this form:\n\nis an OS ABI name from the same selection accepted by (see Configuring the Current ABI).\n\nThis optional field was introduced in GDB version 7.0. Previous versions of GDB ignore it.\n\nis one of the architectures from the set accepted by (see Specifying a Debugging Target).\n\nA ‘ ’ element is used to specify that the target is able to run binaries in some other than the main target architecture given by the ‘ ’ element. For example, on the Cell Broadband Engine, the main architecture is or , but the system is able to run binaries in the architecture as well. The way to describe this capability with ‘ ’ is as follows:\n\nEach ‘ ’ describes some logical portion of the target system. Features are currently used to describe available CPU registers and the types of their contents. A ‘ ’ element has this form:\n\nEach feature’s name should be unique within the description. The name of a feature does not matter unless GDB has some special knowledge of the contents of that feature; if it does, the feature should have its standard name. See Standard Target Features.\n\nAny register’s value is a collection of bits which GDB must interpret. The default interpretation is a two’s complement integer, but other types can be requested by name in the register description. Some predefined types are provided by GDB (see Predefined Target Types), and the description can define additional composite and enum types.\n\nEach type element must have an ‘ ’ attribute, which gives a unique (within the containing ‘ ’) name to the type. Types must be defined before they are used.\n\nSome targets offer vector registers, which can be treated as arrays of scalar elements. These types are written as ‘ ’ elements, specifying the array element type, , and the number of elements, :\n\nIf a register’s value is usefully viewed in multiple ways, define it with a union type containing the useful representations. The ‘ ’ element contains one or more ‘ ’ elements, each of which has a and a :\n\nIf a register’s value is composed from several separate values, define it with either a structure type or a flags type. A flags type may only contain bitfields. A structure type may either contain only bitfields or contain no bitfields. If the value contains only bitfields, its total size in bytes must be specified.\n\nBoth and values are required. No implicit padding is added.\n\nThe value is required. Bitfield values may be named with the empty string, ‘ ’, in which case the field is “filler” and its value is not printed. Not all bits need to be specified, so “filler” fields are optional.\n\nThe and values are required, and is optional. The field’s must be less than or equal to its , and zero represents the least significant bit.\n\nThe default value of is for single bit fields, and an unsigned integer otherwise.\n\nWhich to choose? Structures or flags?\n\nRegisters defined with ‘ ’ have these advantages over defining them with ‘ ’:\n• Arithmetic may be performed on them as if they were integers.\n• They are printed in a more readable fashion.\n\nRegisters defined with ‘ ’ have one advantage over defining them with ‘ ’:\n• One can fetch individual fields like in ‘ ’.\n\nEach register is represented as an element with this form:\n\nThe components are as follows:\n\nType definitions in the self-description can build up composite types from basic building blocks, but can not define fundamental types. Instead, standard identifiers are provided by GDB for the fundamental types. The currently supported types are:\n\nEnum target types are useful in ‘ ’ and ‘ ’ register descriptions. See Target Description Format.\n\nEnum types have a name, size and a list of name/value pairs.\n\nEnums must be defined before they are used.\n\nGiven that description, a value of 3 for the ‘ ’ register would be printed as:\n\nA target description must contain either no registers or all the target’s registers. If the description contains no registers, then GDB will assume a default register layout, selected based on the architecture. If the description contains any registers, the default layout will not be used; the standard registers must be described in the target description, in such a way that GDB can recognize them.\n\nThis is accomplished by giving specific names to feature elements which contain standard registers. GDB will look for features with those names and verify that they contain the expected registers; if any known feature is missing required registers, or if any required feature is missing, GDB will reject the target description. You can add additional registers to any of the standard features — GDB will display them just as if they were added to an unrecognized feature.\n\nThis section lists the known features and their expected contents. Sample XML documents for these features are included in the GDB source tree, in the directory .\n\nNames recognized by GDB should include the name of the company or organization which selected the name, and the overall architecture to which the feature applies; so e.g. the feature containing ARM core registers is named ‘ ’.\n\nThe names of registers are not case sensitive for the purpose of recognizing standard features, but GDB will only display registers using the capitalization used in the description.\n\nThe ‘ ’ feature is required for AArch64 targets. It must contain the following:\n• - ‘ ’ through ‘ ’, the general purpose registers, with size of 64 bits. Register ‘ ’ is also known as the link register, or ‘ ’.\n• - ‘ ’, the stack pointer register or ‘ ’. It is 64 bits in size and has a type of ‘ ’.\n• - ‘ ’, the program counter register. It is 64 bits in size and has a type of ‘ ’.\n• - ‘ ’, the current program status register. It is 32 bits in size and has a custom flags type.\n\nThe semantics of the individual flags and fields in ‘ ’ can change as new architectural features are added. The current layout can be found in the aarch64-core.xml file.\n\nExtra registers are allowed in this feature, but they will not affect GDB.\n\nThe ‘ ’ feature is optional. If present, it must contain the following registers:\n• - ‘ ’ through ‘ ’, the vector registers with size of 128 bits. The type is a custom vector type.\n• - ‘ ’, the floating-point status register. It is 32 bits in size and has a custom flags type.\n• - ‘ ’, the floating-point control register. It is 32 bits in size and has a custom flags type.\n\nThe semantics of the individual flags and fields in ‘ ’ and ‘ ’ can change as new architectural features are added.\n\nThe types for the vector registers, ‘ ’ and ‘ ’ registers can be found in the aarch64-fpu.xml file.\n\nExtra registers are allowed in this feature, but they will not affect GDB.\n\nThe ‘ ’ feature is optional. If present, it means the target supports the Scalable Vector Extension and must contain the following registers:\n• - ‘ ’ through ‘ ’, the scalable vector registers. Their sizes are variable and a multiple of 128 bits up to a maximum of 2048 bit. Their type is a custom union type that helps visualize different sizes of sub-vectors.\n• - ‘ ’, the floating-point status register. It is 32 bits in size and has a custom flags type.\n• - ‘ ’, the floating-point control register. It is 32 bits in size and has a custom flags type.\n• - ‘ ’ through ‘ ’, the predicate registers. Their sizes are variable, based on the current vector length, and a multiple of 16 bits. Their types are a custom union to help visualize sub-elements.\n• - ‘ ’, the First Fault register. It has a variable size based on the current vector length and is a multiple of 16 bits. The type is the same as the predicate registers.\n• - ‘ ’, the vector granule. It represents the number of 64 bits chunks in a ‘ ’ register. It is closely associated with the current vector length. It has a type of ‘ ’.\n\nWhen GDB sees the SVE feature, it will assume the Scalable Vector Extension is supported, and will adjust the sizes of the ‘ ’, ‘ ’ and ‘ ’ registers accordingly, based on the value of ‘ ’.\n\nGDB will also create pseudo-registers equivalent to the ‘ ’ vector registers from the ‘ ’ feature.\n\nThe first 128 bits of the ‘ ’ registers overlap the 128 bits of the ‘ ’ registers, so changing one will trigger a change to the other.\n\nFor the types of the ‘ ’, ‘ ’ and ‘ ’ registers, please check the aarch64-sve.c file. No XML file is available for this feature because it is dynamically generated based on the current vector length.\n\nThe semantics of the individual flags and fields in ‘ ’ and ‘ ’ can change as new architectural features are added.\n\nThe types for the ‘ ’ and ‘ ’ registers can be found in the aarch64-sve.c file, and should match what is described in aarch64-fpu.xml.\n\nExtra registers are allowed in this feature, but they will not affect GDB.\n\nThe ‘ ’ optional feature was introduced so GDB could detect support for the Pointer Authentication extension. If present, it must contain one of two possible register sets.\n• - ‘ ’, the user-mode pointer authentication mask for data pointers. It is 64 bits in size.\n• - ‘ ’, the user-mode pointer authentication mask for code pointers. It is 64 bits in size.\n• - ‘ ’, the user-mode pointer authentication mask for data pointers. It is 64 bits in size.\n• - ‘ ’, the user-mode pointer authentication mask for code pointers. It is 64 bits in size.\n• - ‘ ’, the kernel-mode pointer authentication mask for data pointers. It is 64 bits in size.\n• - ‘ ’, the kernel-mode pointer authentication mask for code pointers. It is 64 bits in size.\n\nIf GDB sees any of the two sets of registers in this feature, it will assume the target is capable of signing pointers. If so, GDB will decorate backtraces with a ‘ ’ marker alongside a function that has a signed link register value that needs to be unmasked/decoded.\n\nGDB will also use the masks to remove non-address bits from pointers.\n\nExtra registers are allowed in this feature, but they will not affect GDB.\n\nPlease note the ‘ ’ feature string is deprecated and must only be used for backwards compatibility with older releases of GDB and . Targets that support Pointer Authentication must advertise such capability by using the ‘ ’ feature string instead.\n\nThe ‘ ’ feature has the exact same contents as feature ‘ ’.\n\nThe reason for having feature ‘ ’ is a bug in previous versions of GDB (versions 9, 10, 11 and 12). This bug caused GDB to crash whenever the target reported support for Pointer Authentication (using feature string ‘ ’) and also reported additional system registers that were not accounted for by GDB. This is more common when using emulators and on bare-metal debugging scenarios.\n\nIt can also happen if a newer gdbserver is used with an old GDB that has the bug. In such a case, the newer gdbserver might report Pointer Authentication support via the ‘ ’ feature string and also report additional registers the older GDB does not know about, potentially leading to a crash.\n\nThe ‘ ’ optional feature was introduced to expose the TLS registers to GDB. If present, it must contain either one of the following register sets.\n• - ‘ ’, the software thread id register. It is 64 bits in size and has a type of ‘ ’.\n• - ‘ ’, the software thread id register. It is 64 bits in size and has a type of ‘ ’.\n• - ‘ ’, the second software thread id register. It is 64 bits in size and has a type of ‘ ’. It may be used in the future alongside the Scalable Matrix Extension for a lazy restore scheme.\n\nIf GDB sees this feature, it will attempt to find one of the variations of the register set. If ‘ ’ is available, GDB may act on it to display additional data in the future.\n\nThere is no XML for this feature as the presence of ‘ ’ is determined dynamically at runtime.\n\nExtra registers are allowed in this feature, but they will not affect GDB.\n\nThe ‘ ’ optional feature was introduced so GDB could detect support for the Memory Tagging Extension and control memory tagging settings. If present, this feature must have the following register:\n• - ‘ ’, the tag control register. It is 64 bits in size and has a type of ‘ ’.\n\nMemory Tagging detection is done via a runtime check though, so the presence of this feature and register is not enough to enable memory tagging support.\n\nThis restriction may be lifted in the future.\n\nExtra registers are allowed in this feature, but they will not affect GDB.\n\nThe ‘ ’ feature is optional. If present, it should contain registers , and . See AArch64 SME.\n• - is a register represented by a vector of x bytes. See svl.\n• - is a 64-bit register containing the value of . See svg.\n• - is a 64-bit status pseudo-register with two valid bits. Bit 0 (SM) shows whether the streaming mode is enabled or disabled. Bit 1 (ZA) shows whether the register state is active (in use) or not. See aarch64 sme svcr. The rest of the unused bits of the pseudo-register is undefined and reserved. Such bits should not be used and may be defined by future extensions of the architecture.\n\nExtra registers are allowed in this feature, but they will not affect GDB.\n\nThe ‘ ’ feature is required when the target also reports support for the ‘ ’ feature.\n\nThe ‘ ’ feature is optional. If present, then the ‘ ’ feature must also be present. The ‘ ’ feature should contain the following: See AArch64 SME2.\n• - is a register of 512 bits (64 bytes). It is defined as a vector of bytes.\n\nExtra registers are allowed in this feature, but they will not affect GDB.\n\nARC processors are so configurable that even core registers and their numbers are not predetermined completely. Moreover, flags and PC registers, which are important to GDB, are not “core” registers in ARC. Therefore, there are two features that their presence is mandatory: ‘ ’ and ‘ ’.\n\nThe ‘ ’ feature is required for all targets. It must contain registers:\n• - ‘ ’ through ‘ ’, and ‘ ’ through ‘ ’ for reduced register file targets.\n\nIn case of an ARCompact target (ARCv1 ISA), the ‘ ’ feature may contain registers ‘ ’ and ‘ ’. While in case of ARC EM and ARC HS targets (ARCv2 ISA), register ‘ ’ may be present. The difference between ARCv1 and ARCv2 is the naming of registers 29th and 30th. They are called ‘ ’ and ‘ ’ for ARCv1 and are optional. For ARCv2, they are called ‘ ’ and ‘ ’ and only ‘ ’ is optional. The optionality of ‘ ’ registers is because of their inaccessibility during user space debugging sessions.\n\nExtension core registers ‘ ’ through ‘ ’ are optional and their existence depends on the configuration. When debugging GNU/Linux applications, i.e. user space debugging, these core registers are not available.\n\nThe ‘ ’ feature is required for all ARC targets. Here is the list of registers pertinent to this feature:\n\nThe ‘ ’ feature is required for non-M-profile ARM targets. It must contain the following registers:\n• - ‘ ’ through ‘ ’. The general purpose registers. They are 32 bits in size and have a type of ‘ ’.\n• - ‘ ’, the stack pointer register, also known as ‘ ’. It is 32 bits in size and has a type of ‘ ’.\n• - ‘ ’, the link register. It is 32 bits in size.\n• - ‘ ’, the program counter register. It is 32 bit in size and of type ‘ ’.\n• - ‘ ’, the current program status register containing all the status bits. It is 32 bits in size. Historically this register was hardwired to number 25, but debugging stubs that report XML do not need to use this number anymore.\n\nExtra registers are allowed in this feature, but they will not affect GDB.\n\nFor M-profile targets (e.g. Cortex-M3), the ‘ ’ feature is replaced by ‘ ’, and it is a required feature. It must contain the following registers:\n• - ‘ ’ through ‘ ’, the general purpose registers. They have a size of 32 bits and a type of ‘ ’.\n• - ‘ ’, the stack pointer register, also known as ‘ ’. It has a size of 32 bits and a type of ‘ ’.\n• - ‘ ’, the link register. It has a size of 32 bits.\n• - ‘ ’, the program counter register. It has a size of 32 bits and a type of ‘ ’.\n• - ‘ ’, the program status register containing all the status bits. It has a size of 32 bits. Historically this register was hardwired to number 25, but debugging stubs that report XML do not need to use this number anymore.\n\nUpon seeing this feature, GDB will acknowledge that it is dealing with an M-profile target. This means GDB will use hooks and configurations that are meaningful to M-profiles.\n\nExtra registers are allowed in this feature, but they will not affect GDB.\n\nThe ‘ ’ feature is obsolete and should not be advertised by debugging stubs anymore. It used to advertise registers for the old FPA architecture that has long been discontinued in toolchains.\n\nIt is kept in GDB for backward compatibility purposes so older debugging stubs that don’t support XML target descriptions still work correctly. One such example is the KGDB debugging stub from Linux or BSD kernels.\n\nThe description below is for historical purposes only. This feature used to contain the following registers:\n• - ‘ ’ through ‘ ’. The floating point registers. They are 96 bits in size and of type ‘ ’. ‘ ’ is pinned to register number 16.\n• - ‘ ’, the status register. It has a size of 32 bits.\n\nAlso known as Helium, the M-profile Vector Extension is advertised via the optional ‘ ’ feature.\n\nIt must contain the following:\n• - ‘ ’, the vector predication status and control register. It is 32 bits in size and has a custom flags type. The flags type is laid out in a way that exposes the ‘ ’ field from bits 0 to 15, the ‘ ’ field from bits 16 to 19 and the ‘ ’ field from bits 20 to 23.\n\nWhen this feature is available, GDB will synthesize the ‘ ’ pseudo-register from ‘ ’ contents.\n\nThis feature must only be advertised if the target is M-profile. Advertising this feature for targets that are not M-profile may cause GDB to assume the target is M-profile when it isn’t.\n\nIf the ‘ ’ feature is available alongside the ‘ ’ feature, GDB will synthesize the ‘ ’ pseudo-registers from ‘ ’ register contents.\n\nExtra registers are allowed in this feature, but they will not affect GDB.\n\nThe XScale ‘ ’ feature is optional. If present, it must contain the following:\n• - ‘ ’ through ‘ ’, registers with size 64 bits and a custom type ‘ ’. ‘ ’ is a union of four other types: ‘ ’, a 2-element vector of ‘ ’, a 4-element vector of ‘ ’ and a 8-element vector of ‘ ’.\n• - ‘ ’ through ‘ ’, registers with size 32 bits and type ‘ ’.\n\nThe following registers are optional:\n• - ‘ ’, register with size of 32 bits and type ‘ ’.\n\nThis feature should only be reported if the target is XScale.\n\nExtra registers are allowed in this feature, but they will not affect GDB.\n\nThe ‘ ’ feature is optional. If present, it should contain one of two possible sets of values depending on whether VFP version 2 or VFP version 3 is in use.\n• - ‘ ’ through ‘ ’. The double-precision registers. They are 64 bits in size and have type ‘ ’.\n• - ‘ ’, the floating-point status and control register. It has a size of 32 bits and a type of ‘ ’.\n• - ‘ ’ through ‘ ’. The double-precision registers. They are 64 bits in size and have type ‘ ’.\n• - ‘ ’, the floating-point status and control register. It has a size of 32 bits and a type of ‘ ’.\n\nIf this feature is available, GDB will synthesize the single-precision floating-point registers from halves of the double-precision registers as pseudo-registers.\n\nExtra registers are allowed in this feature, but they will not affect GDB.\n\nThe ‘ ’ feature is optional. It does not need to contain registers; it instructs GDB to display the VFP double-precision registers as vectors and to synthesize the quad-precision registers from pairs of double-precision registers. If this feature is present, ‘ ’ must also be present and include 32 double-precision registers.\n\nExtra registers are allowed in this feature, but they will not affect GDB.\n\nThe ‘ ’ feature is optional, and acknowledges support for the ARMv8.1-m PACBTI extensions.\n\nThis feature doesn’t contain any required registers, and it only serves as a hint to GDB that the debugging stub supports the ARMv8.1-m PACBTI extensions.\n\nWhen GDB sees this feature, it will track return address signing states and will decorate backtraces using the [PAC] marker, similar to AArch64’s PAC extension. See AArch64 PAC.\n\nExtra registers are allowed in this feature, but they will not affect GDB.\n\nThe ‘ ’ optional feature was introduced as a way to inform GDB about additional system registers.\n\nAt the moment this feature must contain the following:\n• - ‘ ’, the main stack pointer register. It is 32 bits in size with type ‘ ’.\n• - ‘ ’, the process stack pointer register. It is 32 bits in size with type ‘ ’.\n\nThis feature must only be advertised for M-profile targets. When GDB sees this feature, it will attempt to track the values of ‘ ’ and ‘ ’ across frames.\n\nExtra registers are allowed in this feature, but they will not affect GDB.\n\nThe ‘ ’ optional feature was introduced so GDB could better support the switching of stack pointers and secure states in the Security Extensions.\n\nAt the moment this feature must contain the following:\n• - ‘ ’, the main stack pointer register (non-secure state). It is 32 bits in size with type ‘ ’.\n• - ‘ ’, the process stack pointer register (non-secure state). It is 32 bits in size with type ‘ ’.\n• - ‘ ’, the main stack pointer register (secure state). It is 32 bits in size with type ‘ ’.\n• - ‘ ’, the process stack pointer register (secure state). It is 32 bits in size with type ‘ ’.\n\nWhen GDB sees this feature, it will attempt to track the values of all 4 stack pointers across secure state transitions, potentially improving unwinding when applications switch between security states.\n\nExtra registers are allowed in this feature, but they will not affect GDB.\n\nCurrently it contains the following:\n• - ‘ ’, the user read-only thread id register. It is 32 bits in size and has type ‘ ’.\n\nAt the moment GDB looks for this feature, but doesn’t do anything with it other than displaying it.\n\nExtra registers are allowed in this feature, but they will not affect GDB.\n\nThe ‘ ’ feature is required for i386/amd64 targets. It should describe the following registers:\n• - ‘ ’ through ‘ ’ plus ‘ ’ for i386\n• - ‘ ’ through ‘ ’ plus ‘ ’ for amd64\n\nThe register sets may be different, depending on the target.\n\nThe ‘ ’ feature is optional. It should describe registers:\n\nThe ‘ ’ feature is optional and requires the ‘ ’ feature. It should describe the upper 128 bits of YMM registers:\n\nThe ‘ ’ feature is optional. It should describe a single register, ‘ ’.\n\nThe ‘ ’ feature is optional. It should describe two system registers: ‘ ’ and ‘ ’.\n\nThe ‘ ’ feature is optional and requires the ‘ ’ feature. It should describe additional XMM registers:\n• - ‘ ’ through ‘ ’, only valid for amd64.\n\nIt should describe the upper 128 bits of additional YMM registers:\n• - ‘ ’ through ‘ ’, only valid for amd64.\n\nIt should describe the upper 256 bits of ZMM registers:\n\nIt should describe the additional ZMM registers:\n• - ‘ ’ through ‘ ’, only valid for amd64.\n\nIt should describe the additional 64-bit K registers:\n• - ‘ ’ through ‘ ’, valid for amd64 and i386.\n\nThe ‘ ’ feature is optional. It should describe a single register, ‘ ’. It is a 32-bit register valid for i386 and amd64.\n\nThe ‘ ’ feature is required for LoongArch targets. It should contain the registers ‘ ’ through ‘ ’, ‘ ’, and ‘ ’. Either the architectural names (‘ ’, ‘ ’, etc) can be used, or the ABI names (‘ ’, ‘ ’, etc).\n\nThe ‘ ’ feature is optional. If present, it should contain registers ‘ ’ through ‘ ’, ‘ ’, and ‘ ’.\n\nThe ‘ ’ feature is required for MicroBlaze targets. It should contain registers ‘ ’ through ‘ ’, ‘ ’, ‘ ’, ‘ ’, ‘ ’, ‘ ’, ‘ ’, ‘ ’, ‘ ’ through ‘ ’, ‘ ’, ‘ ’, ‘ ’, ‘ ’, ‘ ’, ‘ ’, and ‘ ’.\n\nThe ‘ ’ feature is optional. If present, it should contain registers ‘ ’ and ‘ ’\n\nThe ‘ ’ feature is required for targets. It should contain registers ‘ ’ through ‘ ’, ‘ ’, ‘ ’, and ‘ ’. They may be 32-bit or 64-bit depending on the target.\n\nThe ‘ ’ feature is also required. It should contain at least the ‘ ’, ‘ ’, and ‘ ’ registers. They may be 32-bit or 64-bit depending on the target.\n\nThe ‘ ’ feature is currently required, though it may be optional in a future version of GDB. It should contain registers ‘ ’ through ‘ ’, ‘ ’, and ‘ ’. They may be 32-bit or 64-bit depending on the target.\n\nThe ‘ ’ feature is optional. It should contain registers ‘ ’ through ‘ ’, ‘ ’ through ‘ ’, and ‘ ’. The ‘ ’ register should be 32-bit and the rest may be 32-bit or 64-bit depending on the target.\n\nThe ‘ ’ feature is optional. It should contain a single register, ‘ ’, which is used by the Linux kernel to control restartable syscalls.\n\nThe ‘ ’ feature is required for NDS32 targets. It should contain at least registers ‘ ’ through ‘ ’, ‘ ’, ‘ ’, ‘ ’, ‘ ’, ‘ ’, and ‘ ’.\n\nThe ‘ ’ feature is optional. If present, it should contain 64-bit double-precision floating-point registers ‘ ’ through fdN, which should be ‘ ’, ‘ ’, ‘ ’, or ‘ ’ based on the FPU configuration implemented.\n\nNote: The first sixteen 64-bit double-precision floating-point registers are overlapped with the thirty-two 32-bit single-precision floating-point registers. The 32-bit single-precision registers, if not being listed explicitly, will be synthesized from halves of the overlapping 64-bit double-precision registers. Listing 32-bit single-precision registers explicitly is deprecated, and the support to it could be totally removed some day.\n\nThe ‘ ’ feature is required for OpenRISC 1000 targets. It should contain the 32 general purpose registers (‘ ’ through ‘ ’), ‘ ’, ‘ ’ and ‘ ’.\n\nThe ‘ ’ feature is required for PowerPC targets. It should contain registers ‘ ’ through ‘ ’, ‘ ’, ‘ ’, ‘ ’, ‘ ’, ‘ ’, and ‘ ’. They may be 32-bit or 64-bit depending on the target.\n\nThe ‘ ’ feature is optional. It should contain registers ‘ ’ through ‘ ’ and ‘ ’.\n\nThe ‘ ’ feature is optional. It should contain registers ‘ ’ through ‘ ’, ‘ ’, and ‘ ’. GDB will define pseudo-registers ‘ ’ through ‘ ’ as aliases for the corresponding ‘ ’ registers.\n\nThe ‘ ’ feature is optional. It should contain registers ‘ ’ through ‘ ’. GDB will combine these registers with the floating point registers (‘ ’ through ‘ ’) and the altivec registers (‘ ’ through ‘ ’) to present the 128-bit wide registers ‘ ’ through ‘ ’, the set of vector-scalar registers for POWER7. Therefore, this feature requires both ‘ ’ and ‘ ’.\n\nThe ‘ ’ feature is optional. It should contain registers ‘ ’ through ‘ ’, ‘ ’, and ‘ ’. SPE targets should provide 32-bit registers in ‘ ’ and provide the upper halves in ‘ ’ through ‘ ’. GDB will combine these to present registers ‘ ’ through ‘ ’ to the user.\n\nThe ‘ ’ feature is optional. It should contain the 64-bit register ‘ ’.\n\nThe ‘ ’ feature is optional. It should contain the 64-bit register ‘ ’.\n\nThe ‘ ’ feature is optional. It should contain the 64-bit register ‘ ’.\n\nThe ‘ ’ feature is optional. It should contain registers ‘ ’, ‘ ’ and ‘ ’, all 64-bit wide.\n\nThe ‘ ’ feature is optional. It should contain registers ‘ ’, ‘ ’, ‘ ’, ‘ ’ and ‘ ’, all 64-bit wide. This is the subset of the isa 2.07 server PMU registers provided by GNU/Linux.\n\nThe ‘ ’ feature is optional. It should contain registers ‘ ’, ‘ ’ and ‘ ’, all 64-bit wide.\n\nThe ‘ ’ feature is optional. It should contain the checkpointed general-purpose registers ‘ ’ through ‘ ’, as well as the checkpointed registers ‘ ’ and ‘ ’. These registers may all be either 32-bit or 64-bit depending on the target. It should also contain the checkpointed registers ‘ ’ and ‘ ’, which should both be 32-bit wide.\n\nThe ‘ ’ feature is optional. It should contain the checkpointed 64-bit floating-point registers ‘ ’ through ‘ ’, as well as the checkpointed 64-bit register ‘ ’.\n\nThe ‘ ’ feature is optional. It should contain the checkpointed altivec registers ‘ ’ through ‘ ’, all 128-bit wide. It should also contain the checkpointed registers ‘ ’ and ‘ ’, both 32-bit wide.\n\nThe ‘ ’ feature is optional. It should contain registers ‘ ’ through ‘ ’. GDB will combine these registers with the checkpointed floating point registers (‘ ’ through ‘ ’) and the checkpointed altivec registers (‘ ’ through ‘ ’) to present the 128-bit wide checkpointed vector-scalar registers ‘ ’ through ‘ ’. Therefore, this feature requires both ‘ ’ and ‘ ’.\n\nThe ‘ ’ feature is optional. It should contain the 64-bit checkpointed register ‘ ’.\n\nThe ‘ ’ feature is optional. It should contain the 64-bit checkpointed register ‘ ’.\n\nThe ‘ ’ feature is optional. It should contain the 64-bit checkpointed register ‘ ’.\n\nThe ‘ ’ feature is required for RISC-V targets. It should contain the registers ‘ ’ through ‘ ’, and ‘ ’. Either the architectural names (‘ ’, ‘ ’, etc) can be used, or the ABI names (‘ ’, ‘ ’, etc).\n\nThe ‘ ’ feature is optional. If present, it should contain registers ‘ ’ through ‘ ’, ‘ ’, ‘ ’, and ‘ ’. As with the cpu feature, either the architectural register names, or the ABI names can be used.\n\nThe ‘ ’ feature is optional. If present, it should contain registers that are not backed by real registers on the target, but are instead virtual, where the register value is derived from other target state. In many ways these are like GDBs pseudo-registers, except implemented by the target. Currently the only register expected in this set is the one byte ‘ ’ register that contains the target’s privilege level in the least significant two bits.\n\nThe ‘ ’ feature is optional. If present, it should contain all of the target’s standard CSRs. Standard CSRs are those defined in the RISC-V specification documents. There is some overlap between this feature and the fpu feature; the ‘ ’, ‘ ’, and ‘ ’ registers could be in either feature. The expectation is that these registers will be in the fpu feature if the target has floating point hardware, but can be moved into the csr feature if the target has the floating point control registers, but no other floating point hardware.\n\nThe ‘ ’ feature is optional. If present, it should contain registers ‘ ’ through ‘ ’, all of which must be the same size.\n\nThe ‘ ’ feature is required for RX targets. It should contain the registers ‘ ’ through ‘ ’, ‘ ’, ‘ ’, ‘ ’, ‘ ’, ‘ ’, ‘ ’, ‘ ’, ‘ ’, ‘ ’, and ‘ ’.\n\nThe ‘ ’ feature is required for S/390 and System z targets. It should contain the PSW and the 16 general registers. In particular, System z targets should provide the 64-bit registers ‘ ’, ‘ ’, and ‘ ’ through ‘ ’. S/390 targets should provide the 32-bit versions of these registers. A System z target that runs in 31-bit addressing mode should provide 32-bit versions of ‘ ’ and ‘ ’, as well as the general register’s upper halves ‘ ’ through ‘ ’, and their lower halves ‘ ’ through ‘ ’.\n\nThe ‘ ’ feature is required. It should contain the 64-bit registers ‘ ’ through ‘ ’, and ‘ ’.\n\nThe ‘ ’ feature is required. It should contain the 32-bit registers ‘ ’ through ‘ ’.\n\nThe ‘ ’ feature is optional. It should contain the register ‘ ’, which is 64-bit wide on System z targets and 32-bit otherwise. In addition, the feature may contain the ‘ ’ register, whose width depends on the addressing mode, as well as the ‘ ’ register, which is always 32-bit wide.\n\nThe ‘ ’ feature is optional. It should contain the 64-bit registers ‘ ’, ‘ ’, ‘ ’, ‘ ’, and ‘ ’ through ‘ ’.\n\nThe ‘ ’ feature is optional. It should contain 64-bit wide registers ‘ ’ through ‘ ’, which will be combined by GDB with the floating point registers ‘ ’ through ‘ ’ to present the 128-bit wide vector registers ‘ ’ through ‘ ’. In addition, this feature should contain the 128-bit wide vector registers ‘ ’ through ‘ ’.\n\nThe ‘ ’ feature is optional. It should contain the 64-bit wide guarded-storage-control registers ‘ ’, ‘ ’, and ‘ ’.\n\nThe ‘ ’ feature is optional. It should contain the 64-bit wide guarded-storage broadcast control registers ‘ ’, ‘ ’, and ‘ ’.\n\nThe ‘ ’ feature is required for sparc32/sparc64 targets. It should describe the following registers:\n\nThey may be 32-bit or 64-bit depending on the target.\n\nAlso the ‘ ’ feature is required for sparc32/sparc64 targets. It should describe the following registers:\n\nThe ‘ ’ feature is required for sparc32/sparc64 targets. It should describe the following registers:\n\nThe ‘ ’ feature is required for TMS320C6x targets. It should contain registers ‘ ’ through ‘ ’, registers ‘ ’ through ‘ ’, ‘ ’ and ‘ ’.\n\nThe ‘ ’ feature is optional. It should contain registers ‘ ’ through ‘ ’ and ‘ ’ through ‘ ’.\n\nThe ‘ ’ feature is optional. It should contain registers ‘ ’, ‘ ’ and ‘ ’.\n\nUsers of GDB often wish to obtain information about the state of the operating system running on the target—for example the list of processes, or the list of open files. This section describes the mechanism that makes it possible. This mechanism is similar to the target features mechanism (see Target Descriptions), but focuses on a different aspect of target.\n\nOperating system information is retrieved from the target via the remote protocol, using ‘ ’ requests (see qXfer osdata read). The object name in the request should be ‘ ’, and the identifies the data to be fetched.\n\nWhen requesting the process list, the field in the ‘ ’ request should be ‘ ’. The returned data is an XML document. The formal syntax of this document is defined in .\n\nAn example document is:\n\nEach item should include a column whose name is ‘ ’. The value of that column should identify the process on the target. The ‘ ’ and ‘ ’ columns are optional, and will be displayed by GDB. The ‘ ’ column, if present, should contain a comma-separated list of cores that this process is running on. Target may provide additional columns, which GDB currently ignores.\n\nThe trace file comes in three parts: a header, a textual description section, and a trace frame section with binary data.\n\nThe header has the form . The first byte is so as to indicate that the file contains binary data, while the is a version number that may have different values in the future.\n\nThe description section consists of multiple lines of ASCII text separated by newline characters ( ). The lines may include a variety of optional descriptive or context-setting information, such as tracepoint definitions or register set size. GDB will ignore any line that it does not recognize. An empty line marks the end of this section.\n\nThe trace frame section consists of a number of consecutive frames. Each frame begins with a two-byte tracepoint number, followed by a four-byte size giving the amount of data in the frame. The data in the frame consists of a number of blocks, each introduced by a character indicating its type (at least register, memory, and trace state variable). The data in this section is raw binary, not a hexadecimal or other encoding; its endianness matches the target’s endianness.\n\nFuture enhancements of the trace file format may include additional types of blocks.\n\nThis section documents the index section that is created by (see Index Files). The index section is DWARF-specific; some knowledge of DWARF is assumed in this description.\n\nThe mapped index file format is designed to be directly able on any architecture. In most cases, a datum is represented using a little-endian 32-bit integer value, called an . Big endian machines must byte-swap the values before using them. Exceptions to this rule are noted. The data is laid out such that alignment is always respected.\n\nA mapped index consists of several areas, laid out in order.\n• The file header. This is a sequence of values, of unless otherwise noted:\n• The version number, currently 9. Versions 1, 2 and 3 are obsolete. Version 4 uses a different hashing function from versions 5 and 6. Version 6 includes symbols for inlined functions, whereas versions 4 and 5 do not. Version 7 adds attributes to the CU indices in the symbol table. Version 8 specifies that symbols from DWARF type units (‘ ’) refer to the type unit’s symbol table and not the compilation unit (‘ ’) using the type. Version 9 adds the name and the language of the main function to the index. GDB will only read version 4, 5, or 6 indices by specifying . GDB has a workaround for potentially broken version 7 indices so it is currently not flagged as deprecated.\n• The offset, from the start of the file, of the CU list.\n• The offset, from the start of the file, of the types CU list. Note that this area can be empty, in which case this offset will be equal to the next offset.\n• The offset, from the start of the file, of the address area.\n• The offset, from the start of the file, of the symbol table.\n• The offset, from the start of the file, of the shortcut table.\n• The offset, from the start of the file, of the constant pool.\n• The CU list. This is a sequence of pairs of 64-bit little-endian values, sorted by the CU offset. The first element in each pair is the offset of a CU in the section. The second element in each pair is the length of that CU. References to a CU elsewhere in the map are done using a CU index, which is just the 0-based index into this table. Note that if there are type CUs, then conceptually CUs and type CUs form a single list for the purposes of CU indices.\n• The types CU list. This is a sequence of triplets of 64-bit little-endian values. In a triplet, the first value is the CU offset, the second value is the type offset in the CU, and the third value is the type signature. The types CU list is not sorted.\n• The address area. The address area consists of a sequence of address entries. Each address entry has three elements:\n• The low address. This is a 64-bit little-endian value.\n• The high address. This is a 64-bit little-endian value. Like , the value is one byte beyond the end.\n• The CU index. This is an value.\n• The symbol table. This is an open-addressed hash table. The size of the hash table is always a power of 2. Each slot in the hash table consists of a pair of values. The first value is the offset of the symbol’s name in the constant pool. The second value is the offset of the CU vector in the constant pool. If both values are 0, then this slot in the hash table is empty. This is ok because while 0 is a valid constant pool index, it cannot be a valid index for both a string and a CU vector. The hash value for a table entry is computed by applying an iterative hash function to the symbol’s name. Starting with an initial value of , each (unsigned) character ‘ ’ in the string is incorporated into the hash using the formula depending on the index version: The terminating ‘ ’ is not incorporated into the hash. The step size used in the hash table is computed via , where ‘ ’ is the hash value, and ‘ ’ is the size of the hash table. The step size is used to find the next candidate slot when handling a hash collision. The names of C symbols in the hash table are canonicalized. We don’t currently have a simple description of the canonicalization algorithm; if you intend to create new index sections, you must read the code.\n• The shortcut table This is a data structure with the following fields: An value indicating the language of the main function as a constant. This value will be zero if main function information is not present. An value indicating the offset of the main function’s name in the constant pool. This value must be ignored if the value for the language of main is zero.\n• The constant pool. This is simply a bunch of bytes. It is organized so that alignment is correct: CU vectors are stored first, followed by strings. A CU vector in the constant pool is a sequence of values. The first value is the number of CU indices in the vector. Each subsequent value is the index and symbol attributes of a CU in the CU list. This element in the hash table is used to indicate which CUs define the symbol and how the symbol is used. See below for the format of each CU index+attributes entry. A string in the constant pool is zero-terminated.\n\nAttributes were added to CU index values in version 7. If a symbol has multiple uses within a CU then there is one CU index+attributes value for each use.\n\nThe format of each CU index+attributes entry is as follows (bit 0 = LSB):\n\nThis pseudo-code describes the computation of a symbol’s kind and global/static attributes in the index.\n\nis an HTTP server for distributing ELF, DWARF and source files.\n\nWith the client library, , GDB can query servers using the build IDs associated with missing debug info, executables and source files in order to download them on demand.\n\nFor instructions on building GDB with , see –with-debuginfod. is packaged with , starting with version 0.178. See https://sourceware.org/elfutils/Debuginfod.html for more information regarding .\n\nGDB provides the following commands for configuring .\n\nThe purpose of a debugger such as GDB is to allow you to see what is going on “inside” another program while it executes – or what another program was doing at the moment it crashed.\n\nGDB can do four main kinds of things (plus other things in support of these) to help you catch bugs in the act:\n• Start your program, specifying anything that might affect its behavior.\n• Make your program stop on specified conditions.\n• Examine what has happened, when your program has stopped.\n• Change things in your program, so you can experiment with correcting the effects of one bug and go on to learn about another.\n\nYou can use GDB to debug programs written in C, C , Fortran and Modula-2.\n\nGDB is invoked with the shell command . Once started, it reads commands from the terminal until you tell it to exit with the GDB command or . You can get online help from GDB itself by using the command .\n\nYou can run with no arguments or options; but the most usual way to start GDB is with one argument or two, specifying an executable program as the argument:\n\nYou can also start with both an executable program and a core file specified:\n\nYou can, instead, specify a process ID as a second argument or use option , if you want to debug a running process:\n\nwould attach GDB to process . With option you can omit the filename.\n\nHere are some of the most frequently needed GDB commands:\n\nAny arguments other than options specify an executable file and core file (or process ID); that is, the first argument encountered with no associated option flag is equivalent to a option, and the second, if any, is equivalent to a option if it’s the name of a file. Many options have both long and abbreviated forms; both are shown here. The long forms are also recognized if you truncate them, so long as enough of the option is present to be unambiguous.\n\nThe abbreviated forms are shown here with ‘ ’ and long forms are shown with ‘ ’ to reflect how they are shown in . However, GDB recognizes all of the following conventions for most options:\n\nAll the options and command line arguments you give are processed in sequential order. The order makes a difference when the option is used.\n\nis a program that allows you to run GDB on a different machine than the one which is running the program being debugged.\n\nFirst, you need to have a copy of the program you want to debug put onto the target system. The program can be stripped to save space if needed, as doesn’t care about symbols. All symbol handling is taken care of by the GDB running on the host system.\n\nTo use the server, you log on to the target system, and run the program. You must tell it (a) how to communicate with GDB, (b) the name of your program, and (c) its arguments. The general syntax is:\n\nFor example, using a serial port, you might say:\n\nThis tells to debug emacs with an argument of foo.txt, and to communicate with GDB via . now waits patiently for the host GDB to communicate with it.\n\nTo use a TCP connection, you could say:\n\nThis says pretty much the same thing as the last example, except that we are going to communicate with the GDB via TCP. The argument means that we are expecting to see a TCP connection from to local TCP port 2345. (Currently, the part is ignored.) You can choose any number you want for the port number as long as it does not conflict with any existing TCP ports on the target system. This same port number must be used in the host GDBs command, which will be described shortly. Note that if you chose a port number that conflicts with another service, will print an error message and exit.\n\ncan also attach to running programs. This is accomplished via the argument. The syntax is:\n\nis the process ID of a currently running process. It isn’t necessary to point at a binary for the running process.\n\nTo start without supplying an initial command to run or process ID to attach, use the command line option. In such case you should connect using to start the program you want to debug.\n\nYou need an unstripped copy of the target program on your host system, since GDB needs to examine its symbol tables and such. Start up GDB as you normally would, with the target program as the first argument. (You may need to use the option if the serial line is running at anything except 9600 baud.) That is , or . After that, the only new command you need to know about is (or ). Its argument is either a device name (usually a serial device, like ), or a descriptor. For example:\n\ncommunicates with the server via serial line , and:\n\ncommunicates via a TCP connection to port 2345 on host ‘the-target’, where you previously started up with the same port number. Note that for TCP connections, you must start up prior to using the ‘target remote’ command, otherwise you may get an error that looks something like ‘Connection refused’.\n\ncan also debug multiple inferiors at once, described in Inferiors Connections and Programs. In such case use the GDB command variant:\n\nThe option may or may not be used in such case.\n\nThere are three different modes for invoking :\n• Debug a specific program specified by its program name: The parameter specifies how should the server communicate with GDB; it is either a device name (to use a serial line), a TCP port number ( ), or or to use stdin/stdout of . Specify the name of the program to debug in . Any remaining arguments will be passed to the program verbatim. When the program exits, GDB will close the connection, and will exit.\n• Debug a specific program by specifying the process ID of a running program: The parameter is as described above. Supply the process ID of a running program in ; GDB will do everything else. Like with the previous mode, when the process exits, GDB will close the connection, and will exit.\n• Multi-process mode – debug more than one program/process: In this mode, GDB can instruct which command(s) to run. Unlike the other 2 modes, GDB will not close the connection when a process being debugged exits, so you can debug several processes in the same session.\n\nIn each of the modes you may specify these options:\n\nGenerate core dumps of one or more running programs with process IDs , , etc. A core file produced by is equivalent to one produced by the kernel when the process crashes (and when was used to set up an appropriate core dump limit). However, unlike after a crash, after finishes its job the program remains running without any change.\n\nPrint a stack trace of a running program with process ID . If the process is multi-threaded, outputs backtraces for every thread which exists in the process.\n\nThe script invokes GDB, attaches to the given process ID, prints the stack trace, and detaches from the process.\n\nexits with non-zero status if was unable to attach to the given process ID for any reason, such as a non-existent process ID or insufficient privileges to attach to the process.\n\nThese files contain GDB commands to automatically execute during GDB startup. The lines of contents are canned sequences of commands, described in Sequences.\n\nPlease read more in Startup.\n\nWhen GDB finds a symbol file, it scans the symbols in the file in order to construct an internal symbol table. This lets most GDB operations work quickly–at the cost of a delay early on. For large programs, this delay can be quite lengthy, so GDB provides a way to build an index, which speeds up startup.\n\nTo determine whether a file contains such an index, use the command : the index is stored in a section named (pre-DWARF 5) or and (DWARF 5). Indexes can only be produced on systems which use ELF binaries and DWARF debug information (i.e., sections named ).\n\nBy default will add a pre-DWARF 5 section to . With the DWARF 5 section is added instead.\n\nuses GDB, , and found in the environment variable. If you want to use different versions of these programs, you can specify them through the appropriate environment variables (see below).\n\nexits with status 0 if it succeeds in creating the index for or greater than 0 if an error occurs.\n\nSee more in Index Files.\n\nThe GNU General Public License is a free, copyleft license for software and other kinds of works.\n\nThe licenses for most software and other practical works are designed to take away your freedom to share and change the works. By contrast, the GNU General Public License is intended to guarantee your freedom to share and change all versions of a program—to make sure it remains free software for all its users. We, the Free Software Foundation, use the GNU General Public License for most of our software; it applies also to any other work released this way by its authors. You can apply it to your programs, too.\n\nWhen we speak of free software, we are referring to freedom, not price. Our General Public Licenses are designed to make sure that you have the freedom to distribute copies of free software (and charge for them if you wish), that you receive source code or can get it if you want it, that you can change the software or use pieces of it in new free programs, and that you know you can do these things.\n\nTo protect your rights, we need to prevent others from denying you these rights or asking you to surrender the rights. Therefore, you have certain responsibilities if you distribute copies of the software, or if you modify it: responsibilities to respect the freedom of others.\n\nFor example, if you distribute copies of such a program, whether gratis or for a fee, you must pass on to the recipients the same freedoms that you received. You must make sure that they, too, receive or can get the source code. And you must show them these terms so they know their rights.\n\nDevelopers that use the GNU GPL protect your rights with two steps: (1) assert copyright on the software, and (2) offer you this License giving you legal permission to copy, distribute and/or modify it.\n\nFor the developers’ and authors’ protection, the GPL clearly explains that there is no warranty for this free software. For both users’ and authors’ sake, the GPL requires that modified versions be marked as changed, so that their problems will not be attributed erroneously to authors of previous versions.\n\nSome devices are designed to deny users access to install or run modified versions of the software inside them, although the manufacturer can do so. This is fundamentally incompatible with the aim of protecting users’ freedom to change the software. The systematic pattern of such abuse occurs in the area of products for individuals to use, which is precisely where it is most unacceptable. Therefore, we have designed this version of the GPL to prohibit the practice for those products. If such problems arise substantially in other domains, we stand ready to extend this provision to those domains in future versions of the GPL, as needed to protect the freedom of users.\n\nFinally, every program is threatened constantly by software patents. States should not allow patents to restrict development and use of software on general-purpose computers, but in those that do, we wish to avoid the special danger that patents applied to a free program could make it effectively proprietary. To prevent this, the GPL assures that patents cannot be used to render the program non-free.\n\nThe precise terms and conditions for copying, distribution and modification follow.\n• Definitions. “This License” refers to version 3 of the GNU General Public License. “Copyright” also means copyright-like laws that apply to other kinds of works, such as semiconductor masks. “The Program” refers to any copyrightable work licensed under this License. Each licensee is addressed as “you”. “Licensees” and “recipients” may be individuals or organizations. To “modify” a work means to copy from or adapt all or part of the work in a fashion requiring copyright permission, other than the making of an exact copy. The resulting work is called a “modified version” of the earlier work or a work “based on” the earlier work. A “covered work” means either the unmodified Program or a work based on the Program. To “propagate” a work means to do anything with it that, without permission, would make you directly or secondarily liable for infringement under applicable copyright law, except executing it on a computer or modifying a private copy. Propagation includes copying, distribution (with or without modification), making available to the public, and in some countries other activities as well. To “convey” a work means any kind of propagation that enables other parties to make or receive copies. Mere interaction with a user through a computer network, with no transfer of a copy, is not conveying. An interactive user interface displays “Appropriate Legal Notices” to the extent that it includes a convenient and prominently visible feature that (1) displays an appropriate copyright notice, and (2) tells the user that there is no warranty for the work (except to the extent that warranties are provided), that licensees may convey the work under this License, and how to view a copy of this License. If the interface presents a list of user commands or options, such as a menu, a prominent item in the list meets this criterion.\n• Source Code. The “source code” for a work means the preferred form of the work for making modifications to it. “Object code” means any non-source form of a work. A “Standard Interface” means an interface that either is an official standard defined by a recognized standards body, or, in the case of interfaces specified for a particular programming language, one that is widely used among developers working in that language. The “System Libraries” of an executable work include anything, other than the work as a whole, that (a) is included in the normal form of packaging a Major Component, but which is not part of that Major Component, and (b) serves only to enable use of the work with that Major Component, or to implement a Standard Interface for which an implementation is available to the public in source code form. A “Major Component”, in this context, means a major essential component (kernel, window system, and so on) of the specific operating system (if any) on which the executable work runs, or a compiler used to produce the work, or an object code interpreter used to run it. The “Corresponding Source” for a work in object code form means all the source code needed to generate, install, and (for an executable work) run the object code and to modify the work, including scripts to control those activities. However, it does not include the work’s System Libraries, or general-purpose tools or generally available free programs which are used unmodified in performing those activities but which are not part of the work. For example, Corresponding Source includes interface definition files associated with source files for the work, and the source code for shared libraries and dynamically linked subprograms that the work is specifically designed to require, such as by intimate data communication or control flow between those subprograms and other parts of the work. The Corresponding Source need not include anything that users can regenerate automatically from other parts of the Corresponding Source. The Corresponding Source for a work in source code form is that same work.\n• Basic Permissions. All rights granted under this License are granted for the term of copyright on the Program, and are irrevocable provided the stated conditions are met. This License explicitly affirms your unlimited permission to run the unmodified Program. The output from running a covered work is covered by this License only if the output, given its content, constitutes a covered work. This License acknowledges your rights of fair use or other equivalent, as provided by copyright law. You may make, run and propagate covered works that you do not convey, without conditions so long as your license otherwise remains in force. You may convey covered works to others for the sole purpose of having them make modifications exclusively for you, or provide you with facilities for running those works, provided that you comply with the terms of this License in conveying all material for which you do not control copyright. Those thus making or running the covered works for you must do so exclusively on your behalf, under your direction and control, on terms that prohibit them from making any copies of your copyrighted material outside their relationship with you. Conveying under any other circumstances is permitted solely under the conditions stated below. Sublicensing is not allowed; section 10 makes it unnecessary.\n• Protecting Users’ Legal Rights From Anti-Circumvention Law. No covered work shall be deemed part of an effective technological measure under any applicable law fulfilling obligations under article 11 of the WIPO copyright treaty adopted on 20 December 1996, or similar laws prohibiting or restricting circumvention of such measures. When you convey a covered work, you waive any legal power to forbid circumvention of technological measures to the extent such circumvention is effected by exercising rights under this License with respect to the covered work, and you disclaim any intention to limit operation or modification of the work as a means of enforcing, against the work’s users, your or third parties’ legal rights to forbid circumvention of technological measures.\n• Conveying Verbatim Copies. You may convey verbatim copies of the Program’s source code as you receive it, in any medium, provided that you conspicuously and appropriately publish on each copy an appropriate copyright notice; keep intact all notices stating that this License and any non-permissive terms added in accord with section 7 apply to the code; keep intact all notices of the absence of any warranty; and give all recipients a copy of this License along with the Program. You may charge any price or no price for each copy that you convey, and you may offer support or warranty protection for a fee.\n• Conveying Modified Source Versions. You may convey a work based on the Program, or the modifications to produce it from the Program, in the form of source code under the terms of section 4, provided that you also meet all of these conditions:\n• The work must carry prominent notices stating that you modified it, and giving a relevant date.\n• The work must carry prominent notices stating that it is released under this License and any conditions added under section 7. This requirement modifies the requirement in section 4 to “keep intact all notices”.\n• You must license the entire work, as a whole, under this License to anyone who comes into possession of a copy. This License will therefore apply, along with any applicable section 7 additional terms, to the whole of the work, and all its parts, regardless of how they are packaged. This License gives no permission to license the work in any other way, but it does not invalidate such permission if you have separately received it.\n• If the work has interactive user interfaces, each must display Appropriate Legal Notices; however, if the Program has interactive interfaces that do not display Appropriate Legal Notices, your work need not make them do so. A compilation of a covered work with other separate and independent works, which are not by their nature extensions of the covered work, and which are not combined with it such as to form a larger program, in or on a volume of a storage or distribution medium, is called an “aggregate” if the compilation and its resulting copyright are not used to limit the access or legal rights of the compilation’s users beyond what the individual works permit. Inclusion of a covered work in an aggregate does not cause this License to apply to the other parts of the aggregate.\n• Conveying Non-Source Forms. You may convey a covered work in object code form under the terms of sections 4 and 5, provided that you also convey the machine-readable Corresponding Source under the terms of this License, in one of these ways:\n• Convey the object code in, or embodied in, a physical product (including a physical distribution medium), accompanied by the Corresponding Source fixed on a durable physical medium customarily used for software interchange.\n• Convey the object code in, or embodied in, a physical product (including a physical distribution medium), accompanied by a written offer, valid for at least three years and valid for as long as you offer spare parts or customer support for that product model, to give anyone who possesses the object code either (1) a copy of the Corresponding Source for all the software in the product that is covered by this License, on a durable physical medium customarily used for software interchange, for a price no more than your reasonable cost of physically performing this conveying of source, or (2) access to copy the Corresponding Source from a network server at no charge.\n• Convey individual copies of the object code with a copy of the written offer to provide the Corresponding Source. This alternative is allowed only occasionally and noncommercially, and only if you received the object code with such an offer, in accord with subsection 6b.\n• Convey the object code by offering access from a designated place (gratis or for a charge), and offer equivalent access to the Corresponding Source in the same way through the same place at no further charge. You need not require recipients to copy the Corresponding Source along with the object code. If the place to copy the object code is a network server, the Corresponding Source may be on a different server (operated by you or a third party) that supports equivalent copying facilities, provided you maintain clear directions next to the object code saying where to find the Corresponding Source. Regardless of what server hosts the Corresponding Source, you remain obligated to ensure that it is available for as long as needed to satisfy these requirements.\n• Convey the object code using peer-to-peer transmission, provided you inform other peers where the object code and Corresponding Source of the work are being offered to the general public at no charge under subsection 6d. A separable portion of the object code, whose source code is excluded from the Corresponding Source as a System Library, need not be included in conveying the object code work. A “User Product” is either (1) a “consumer product”, which means any tangible personal property which is normally used for personal, family, or household purposes, or (2) anything designed or sold for incorporation into a dwelling. In determining whether a product is a consumer product, doubtful cases shall be resolved in favor of coverage. For a particular product received by a particular user, “normally used” refers to a typical or common use of that class of product, regardless of the status of the particular user or of the way in which the particular user actually uses, or expects or is expected to use, the product. A product is a consumer product regardless of whether the product has substantial commercial, industrial or non-consumer uses, unless such uses represent the only significant mode of use of the product. “Installation Information” for a User Product means any methods, procedures, authorization keys, or other information required to install and execute modified versions of a covered work in that User Product from a modified version of its Corresponding Source. The information must suffice to ensure that the continued functioning of the modified object code is in no case prevented or interfered with solely because modification has been made. If you convey an object code work under this section in, or with, or specifically for use in, a User Product, and the conveying occurs as part of a transaction in which the right of possession and use of the User Product is transferred to the recipient in perpetuity or for a fixed term (regardless of how the transaction is characterized), the Corresponding Source conveyed under this section must be accompanied by the Installation Information. But this requirement does not apply if neither you nor any third party retains the ability to install modified object code on the User Product (for example, the work has been installed in ROM). The requirement to provide Installation Information does not include a requirement to continue to provide support service, warranty, or updates for a work that has been modified or installed by the recipient, or for the User Product in which it has been modified or installed. Access to a network may be denied when the modification itself materially and adversely affects the operation of the network or violates the rules and protocols for communication across the network. Corresponding Source conveyed, and Installation Information provided, in accord with this section must be in a format that is publicly documented (and with an implementation available to the public in source code form), and must require no special password or key for unpacking, reading or copying.\n• Additional Terms. “Additional permissions” are terms that supplement the terms of this License by making exceptions from one or more of its conditions. Additional permissions that are applicable to the entire Program shall be treated as though they were included in this License, to the extent that they are valid under applicable law. If additional permissions apply only to part of the Program, that part may be used separately under those permissions, but the entire Program remains governed by this License without regard to the additional permissions. When you convey a copy of a covered work, you may at your option remove any additional permissions from that copy, or from any part of it. (Additional permissions may be written to require their own removal in certain cases when you modify the work.) You may place additional permissions on material, added by you to a covered work, for which you have or can give appropriate copyright permission. Notwithstanding any other provision of this License, for material you add to a covered work, you may (if authorized by the copyright holders of that material) supplement the terms of this License with terms:\n• Disclaiming warranty or limiting liability differently from the terms of sections 15 and 16 of this License; or\n• Requiring preservation of specified reasonable legal notices or author attributions in that material or in the Appropriate Legal Notices displayed by works containing it; or\n• Prohibiting misrepresentation of the origin of that material, or requiring that modified versions of such material be marked in reasonable ways as different from the original version; or\n• Limiting the use for publicity purposes of names of licensors or authors of the material; or\n• Declining to grant rights under trademark law for use of some trade names, trademarks, or service marks; or\n• Requiring indemnification of licensors and authors of that material by anyone who conveys the material (or modified versions of it) with contractual assumptions of liability to the recipient, for any liability that these contractual assumptions directly impose on those licensors and authors. All other non-permissive additional terms are considered “further restrictions” within the meaning of section 10. If the Program as you received it, or any part of it, contains a notice stating that it is governed by this License along with a term that is a further restriction, you may remove that term. If a license document contains a further restriction but permits relicensing or conveying under this License, you may add to a covered work material governed by the terms of that license document, provided that the further restriction does not survive such relicensing or conveying. If you add terms to a covered work in accord with this section, you must place, in the relevant source files, a statement of the additional terms that apply to those files, or a notice indicating where to find the applicable terms. Additional terms, permissive or non-permissive, may be stated in the form of a separately written license, or stated as exceptions; the above requirements apply either way.\n• Termination. You may not propagate or modify a covered work except as expressly provided under this License. Any attempt otherwise to propagate or modify it is void, and will automatically terminate your rights under this License (including any patent licenses granted under the third paragraph of section 11). However, if you cease all violation of this License, then your license from a particular copyright holder is reinstated (a) provisionally, unless and until the copyright holder explicitly and finally terminates your license, and (b) permanently, if the copyright holder fails to notify you of the violation by some reasonable means prior to 60 days after the cessation. Moreover, your license from a particular copyright holder is reinstated permanently if the copyright holder notifies you of the violation by some reasonable means, this is the first time you have received notice of violation of this License (for any work) from that copyright holder, and you cure the violation prior to 30 days after your receipt of the notice. Termination of your rights under this section does not terminate the licenses of parties who have received copies or rights from you under this License. If your rights have been terminated and not permanently reinstated, you do not qualify to receive new licenses for the same material under section 10.\n• Acceptance Not Required for Having Copies. You are not required to accept this License in order to receive or run a copy of the Program. Ancillary propagation of a covered work occurring solely as a consequence of using peer-to-peer transmission to receive a copy likewise does not require acceptance. However, nothing other than this License grants you permission to propagate or modify any covered work. These actions infringe copyright if you do not accept this License. Therefore, by modifying or propagating a covered work, you indicate your acceptance of this License to do so.\n• Automatic Licensing of Downstream Recipients. Each time you convey a covered work, the recipient automatically receives a license from the original licensors, to run, modify and propagate that work, subject to this License. You are not responsible for enforcing compliance by third parties with this License. An “entity transaction” is a transaction transferring control of an organization, or substantially all assets of one, or subdividing an organization, or merging organizations. If propagation of a covered work results from an entity transaction, each party to that transaction who receives a copy of the work also receives whatever licenses to the work the party’s predecessor in interest had or could give under the previous paragraph, plus a right to possession of the Corresponding Source of the work from the predecessor in interest, if the predecessor has it or can get it with reasonable efforts. You may not impose any further restrictions on the exercise of the rights granted or affirmed under this License. For example, you may not impose a license fee, royalty, or other charge for exercise of rights granted under this License, and you may not initiate litigation (including a cross-claim or counterclaim in a lawsuit) alleging that any patent claim is infringed by making, using, selling, offering for sale, or importing the Program or any portion of it.\n• Patents. A “contributor” is a copyright holder who authorizes use under this License of the Program or a work on which the Program is based. The work thus licensed is called the contributor’s “contributor version”. A contributor’s “essential patent claims” are all patent claims owned or controlled by the contributor, whether already acquired or hereafter acquired, that would be infringed by some manner, permitted by this License, of making, using, or selling its contributor version, but do not include claims that would be infringed only as a consequence of further modification of the contributor version. For purposes of this definition, “control” includes the right to grant patent sublicenses in a manner consistent with the requirements of this License. Each contributor grants you a non-exclusive, worldwide, royalty-free patent license under the contributor’s essential patent claims, to make, use, sell, offer for sale, import and otherwise run, modify and propagate the contents of its contributor version. In the following three paragraphs, a “patent license” is any express agreement or commitment, however denominated, not to enforce a patent (such as an express permission to practice a patent or covenant not to sue for patent infringement). To “grant” such a patent license to a party means to make such an agreement or commitment not to enforce a patent against the party. If you convey a covered work, knowingly relying on a patent license, and the Corresponding Source of the work is not available for anyone to copy, free of charge and under the terms of this License, through a publicly available network server or other readily accessible means, then you must either (1) cause the Corresponding Source to be so available, or (2) arrange to deprive yourself of the benefit of the patent license for this particular work, or (3) arrange, in a manner consistent with the requirements of this License, to extend the patent license to downstream recipients. “Knowingly relying” means you have actual knowledge that, but for the patent license, your conveying the covered work in a country, or your recipient’s use of the covered work in a country, would infringe one or more identifiable patents in that country that you have reason to believe are valid. If, pursuant to or in connection with a single transaction or arrangement, you convey, or propagate by procuring conveyance of, a covered work, and grant a patent license to some of the parties receiving the covered work authorizing them to use, propagate, modify or convey a specific copy of the covered work, then the patent license you grant is automatically extended to all recipients of the covered work and works based on it. A patent license is “discriminatory” if it does not include within the scope of its coverage, prohibits the exercise of, or is conditioned on the non-exercise of one or more of the rights that are specifically granted under this License. You may not convey a covered work if you are a party to an arrangement with a third party that is in the business of distributing software, under which you make payment to the third party based on the extent of your activity of conveying the work, and under which the third party grants, to any of the parties who would receive the covered work from you, a discriminatory patent license (a) in connection with copies of the covered work conveyed by you (or copies made from those copies), or (b) primarily for and in connection with specific products or compilations that contain the covered work, unless you entered into that arrangement, or that patent license was granted, prior to 28 March 2007. Nothing in this License shall be construed as excluding or limiting any implied license or other defenses to infringement that may otherwise be available to you under applicable patent law.\n• No Surrender of Others’ Freedom. If conditions are imposed on you (whether by court order, agreement or otherwise) that contradict the conditions of this License, they do not excuse you from the conditions of this License. If you cannot convey a covered work so as to satisfy simultaneously your obligations under this License and any other pertinent obligations, then as a consequence you may not convey it at all. For example, if you agree to terms that obligate you to collect a royalty for further conveying from those to whom you convey the Program, the only way you could satisfy both those terms and this License would be to refrain entirely from conveying the Program.\n• Use with the GNU Affero General Public License. Notwithstanding any other provision of this License, you have permission to link or combine any covered work with a work licensed under version 3 of the GNU Affero General Public License into a single combined work, and to convey the resulting work. The terms of this License will continue to apply to the part which is the covered work, but the special requirements of the GNU Affero General Public License, section 13, concerning interaction through a network will apply to the combination as such.\n• Revised Versions of this License. The Free Software Foundation may publish revised and/or new versions of the GNU General Public License from time to time. Such new versions will be similar in spirit to the present version, but may differ in detail to address new problems or concerns. Each version is given a distinguishing version number. If the Program specifies that a certain numbered version of the GNU General Public License “or any later version” applies to it, you have the option of following the terms and conditions either of that numbered version or of any later version published by the Free Software Foundation. If the Program does not specify a version number of the GNU General Public License, you may choose any version ever published by the Free Software Foundation. If the Program specifies that a proxy can decide which future versions of the GNU General Public License can be used, that proxy’s public statement of acceptance of a version permanently authorizes you to choose that version for the Program. Later license versions may give you additional or different permissions. However, no additional obligations are imposed on any author or copyright holder as a result of your choosing to follow a later version.\n• Disclaimer of Warranty. THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW. EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU. SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.\n• Limitation of Liability. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.\n• Interpretation of Sections 15 and 16. If the disclaimer of warranty and limitation of liability provided above cannot be given local legal effect according to their terms, reviewing courts shall apply local law that most closely approximates an absolute waiver of all civil liability in connection with the Program, unless a warranty or assumption of liability accompanies a copy of the Program in return for a fee.\n\nHow to Apply These Terms to Your New Programs\n\nIf you develop a new program, and you want it to be of the greatest possible use to the public, the best way to achieve this is to make it free software which everyone can redistribute and change under these terms.\n\nTo do so, attach the following notices to the program. It is safest to attach them to the start of each source file to most effectively state the exclusion of warranty; and each file should have at least the “copyright” line and a pointer to where the full notice is found.\n\nAlso add information on how to contact you by electronic and paper mail.\n\nIf the program does terminal interaction, make it output a short notice like this when it starts in an interactive mode:\n\nThe hypothetical commands ‘ ’ and ‘ ’ should show the appropriate parts of the General Public License. Of course, your program’s commands might be different; for a GUI interface, you would use an “about box”.\n\nYou should also get your employer (if you work as a programmer) or school, if any, to sign a “copyright disclaimer” for the program, if necessary. For more information on this, and how to apply and follow the GNU GPL, see http://www.gnu.org/licenses/.\n\nThe GNU General Public License does not permit incorporating your program into proprietary programs. If your program is a subroutine library, you may consider it more useful to permit linking proprietary applications with the library. If this is what you want to do, use the GNU Lesser General Public License instead of this License. But first, please read http://www.gnu.org/philosophy/why-not-lgpl.html.\n• PREAMBLE The purpose of this License is to make a manual, textbook, or other functional and useful document free in the sense of freedom: to assure everyone the effective freedom to copy and redistribute it, with or without modifying it, either commercially or noncommercially. Secondarily, this License preserves for the author and publisher a way to get credit for their work, while not being considered responsible for modifications made by others. This License is a kind of “copyleft”, which means that derivative works of the document must themselves be free in the same sense. It complements the GNU General Public License, which is a copyleft license designed for free software. We have designed this License in order to use it for manuals for free software, because free software needs free documentation: a free program should come with manuals providing the same freedoms that the software does. But this License is not limited to software manuals; it can be used for any textual work, regardless of subject matter or whether it is published as a printed book. We recommend this License principally for works whose purpose is instruction or reference.\n• APPLICABILITY AND DEFINITIONS This License applies to any manual or other work, in any medium, that contains a notice placed by the copyright holder saying it can be distributed under the terms of this License. Such a notice grants a world-wide, royalty-free license, unlimited in duration, to use that work under the conditions stated herein. The “Document”, below, refers to any such manual or work. Any member of the public is a licensee, and is addressed as “you”. You accept the license if you copy, modify or distribute the work in a way requiring permission under copyright law. A “Modified Version” of the Document means any work containing the Document or a portion of it, either copied verbatim, or with modifications and/or translated into another language. A “Secondary Section” is a named appendix or a front-matter section of the Document that deals exclusively with the relationship of the publishers or authors of the Document to the Document’s overall subject (or to related matters) and contains nothing that could fall directly within that overall subject. (Thus, if the Document is in part a textbook of mathematics, a Secondary Section may not explain any mathematics.) The relationship could be a matter of historical connection with the subject or with related matters, or of legal, commercial, philosophical, ethical or political position regarding them. The “Invariant Sections” are certain Secondary Sections whose titles are designated, as being those of Invariant Sections, in the notice that says that the Document is released under this License. If a section does not fit the above definition of Secondary then it is not allowed to be designated as Invariant. The Document may contain zero Invariant Sections. If the Document does not identify any Invariant Sections then there are none. The “Cover Texts” are certain short passages of text that are listed, as Front-Cover Texts or Back-Cover Texts, in the notice that says that the Document is released under this License. A Front-Cover Text may be at most 5 words, and a Back-Cover Text may be at most 25 words. A “Transparent” copy of the Document means a machine-readable copy, represented in a format whose specification is available to the general public, that is suitable for revising the document straightforwardly with generic text editors or (for images composed of pixels) generic paint programs or (for drawings) some widely available drawing editor, and that is suitable for input to text formatters or for automatic translation to a variety of formats suitable for input to text formatters. A copy made in an otherwise Transparent file format whose markup, or absence of markup, has been arranged to thwart or discourage subsequent modification by readers is not Transparent. An image format is not Transparent if used for any substantial amount of text. A copy that is not “Transparent” is called “Opaque”. Examples of suitable formats for Transparent copies include plain ASCII without markup, Texinfo input format, LaTeX input format, or using a publicly available , and standard-conforming simple , PostScript or designed for human modification. Examples of transparent image formats include , and . Opaque formats include proprietary formats that can be read and edited only by proprietary word processors, or for which the and/or processing tools are not generally available, and the machine-generated , PostScript or produced by some word processors for output purposes only. The “Title Page” means, for a printed book, the title page itself, plus such following pages as are needed to hold, legibly, the material this License requires to appear in the title page. For works in formats which do not have any title page as such, “Title Page” means the text near the most prominent appearance of the work’s title, preceding the beginning of the body of the text. The “publisher” means any person or entity that distributes copies of the Document to the public. A section “Entitled XYZ” means a named subunit of the Document whose title either is precisely XYZ or contains XYZ in parentheses following text that translates XYZ in another language. (Here XYZ stands for a specific section name mentioned below, such as “Acknowledgements”, “Dedications”, “Endorsements”, or “History”.) To “Preserve the Title” of such a section when you modify the Document means that it remains a section “Entitled XYZ” according to this definition. The Document may include Warranty Disclaimers next to the notice which states that this License applies to the Document. These Warranty Disclaimers are considered to be included by reference in this License, but only as regards disclaiming warranties: any other implication that these Warranty Disclaimers may have is void and has no effect on the meaning of this License.\n• VERBATIM COPYING You may copy and distribute the Document in any medium, either commercially or noncommercially, provided that this License, the copyright notices, and the license notice saying this License applies to the Document are reproduced in all copies, and that you add no other conditions whatsoever to those of this License. You may not use technical measures to obstruct or control the reading or further copying of the copies you make or distribute. However, you may accept compensation in exchange for copies. If you distribute a large enough number of copies you must also follow the conditions in section 3. You may also lend copies, under the same conditions stated above, and you may publicly display copies.\n• COPYING IN QUANTITY If you publish printed copies (or copies in media that commonly have printed covers) of the Document, numbering more than 100, and the Document’s license notice requires Cover Texts, you must enclose the copies in covers that carry, clearly and legibly, all these Cover Texts: Front-Cover Texts on the front cover, and Back-Cover Texts on the back cover. Both covers must also clearly and legibly identify you as the publisher of these copies. The front cover must present the full title with all words of the title equally prominent and visible. You may add other material on the covers in addition. Copying with changes limited to the covers, as long as they preserve the title of the Document and satisfy these conditions, can be treated as verbatim copying in other respects. If the required texts for either cover are too voluminous to fit legibly, you should put the first ones listed (as many as fit reasonably) on the actual cover, and continue the rest onto adjacent pages. If you publish or distribute Opaque copies of the Document numbering more than 100, you must either include a machine-readable Transparent copy along with each Opaque copy, or state in or with each Opaque copy a computer-network location from which the general network-using public has access to download using public-standard network protocols a complete Transparent copy of the Document, free of added material. If you use the latter option, you must take reasonably prudent steps, when you begin distribution of Opaque copies in quantity, to ensure that this Transparent copy will remain thus accessible at the stated location until at least one year after the last time you distribute an Opaque copy (directly or through your agents or retailers) of that edition to the public. It is requested, but not required, that you contact the authors of the Document well before redistributing any large number of copies, to give them a chance to provide you with an updated version of the Document.\n• MODIFICATIONS You may copy and distribute a Modified Version of the Document under the conditions of sections 2 and 3 above, provided that you release the Modified Version under precisely this License, with the Modified Version filling the role of the Document, thus licensing distribution and modification of the Modified Version to whoever possesses a copy of it. In addition, you must do these things in the Modified Version:\n• Use in the Title Page (and on the covers, if any) a title distinct from that of the Document, and from those of previous versions (which should, if there were any, be listed in the History section of the Document). You may use the same title as a previous version if the original publisher of that version gives permission.\n• List on the Title Page, as authors, one or more persons or entities responsible for authorship of the modifications in the Modified Version, together with at least five of the principal authors of the Document (all of its principal authors, if it has fewer than five), unless they release you from this requirement.\n• State on the Title page the name of the publisher of the Modified Version, as the publisher.\n• Preserve all the copyright notices of the Document.\n• Add an appropriate copyright notice for your modifications adjacent to the other copyright notices.\n• Include, immediately after the copyright notices, a license notice giving the public permission to use the Modified Version under the terms of this License, in the form shown in the Addendum below.\n• Preserve in that license notice the full lists of Invariant Sections and required Cover Texts given in the Document’s license notice.\n• Include an unaltered copy of this License.\n• Preserve the section Entitled “History”, Preserve its Title, and add to it an item stating at least the title, year, new authors, and publisher of the Modified Version as given on the Title Page. If there is no section Entitled “History” in the Document, create one stating the title, year, authors, and publisher of the Document as given on its Title Page, then add an item describing the Modified Version as stated in the previous sentence.\n• Preserve the network location, if any, given in the Document for public access to a Transparent copy of the Document, and likewise the network locations given in the Document for previous versions it was based on. These may be placed in the “History” section. You may omit a network location for a work that was published at least four years before the Document itself, or if the original publisher of the version it refers to gives permission.\n• For any section Entitled “Acknowledgements” or “Dedications”, Preserve the Title of the section, and preserve in the section all the substance and tone of each of the contributor acknowledgements and/or dedications given therein.\n• Preserve all the Invariant Sections of the Document, unaltered in their text and in their titles. Section numbers or the equivalent are not considered part of the section titles.\n• Delete any section Entitled “Endorsements”. Such a section may not be included in the Modified Version.\n• Do not retitle any existing section to be Entitled “Endorsements” or to conflict in title with any Invariant Section. If the Modified Version includes new front-matter sections or appendices that qualify as Secondary Sections and contain no material copied from the Document, you may at your option designate some or all of these sections as invariant. To do this, add their titles to the list of Invariant Sections in the Modified Version’s license notice. These titles must be distinct from any other section titles. You may add a section Entitled “Endorsements”, provided it contains nothing but endorsements of your Modified Version by various parties—for example, statements of peer review or that the text has been approved by an organization as the authoritative definition of a standard. You may add a passage of up to five words as a Front-Cover Text, and a passage of up to 25 words as a Back-Cover Text, to the end of the list of Cover Texts in the Modified Version. Only one passage of Front-Cover Text and one of Back-Cover Text may be added by (or through arrangements made by) any one entity. If the Document already includes a cover text for the same cover, previously added by you or by arrangement made by the same entity you are acting on behalf of, you may not add another; but you may replace the old one, on explicit permission from the previous publisher that added the old one. The author(s) and publisher(s) of the Document do not by this License give permission to use their names for publicity for or to assert or imply endorsement of any Modified Version.\n• COMBINING DOCUMENTS You may combine the Document with other documents released under this License, under the terms defined in section 4 above for modified versions, provided that you include in the combination all of the Invariant Sections of all of the original documents, unmodified, and list them all as Invariant Sections of your combined work in its license notice, and that you preserve all their Warranty Disclaimers. The combined work need only contain one copy of this License, and multiple identical Invariant Sections may be replaced with a single copy. If there are multiple Invariant Sections with the same name but different contents, make the title of each such section unique by adding at the end of it, in parentheses, the name of the original author or publisher of that section if known, or else a unique number. Make the same adjustment to the section titles in the list of Invariant Sections in the license notice of the combined work. In the combination, you must combine any sections Entitled “History” in the various original documents, forming one section Entitled “History”; likewise combine any sections Entitled “Acknowledgements”, and any sections Entitled “Dedications”. You must delete all sections Entitled “Endorsements.”\n• COLLECTIONS OF DOCUMENTS You may make a collection consisting of the Document and other documents released under this License, and replace the individual copies of this License in the various documents with a single copy that is included in the collection, provided that you follow the rules of this License for verbatim copying of each of the documents in all other respects. You may extract a single document from such a collection, and distribute it individually under this License, provided you insert a copy of this License into the extracted document, and follow this License in all other respects regarding verbatim copying of that document.\n• AGGREGATION WITH INDEPENDENT WORKS A compilation of the Document or its derivatives with other separate and independent documents or works, in or on a volume of a storage or distribution medium, is called an “aggregate” if the copyright resulting from the compilation is not used to limit the legal rights of the compilation’s users beyond what the individual works permit. When the Document is included in an aggregate, this License does not apply to the other works in the aggregate which are not themselves derivative works of the Document. If the Cover Text requirement of section 3 is applicable to these copies of the Document, then if the Document is less than one half of the entire aggregate, the Document’s Cover Texts may be placed on covers that bracket the Document within the aggregate, or the electronic equivalent of covers if the Document is in electronic form. Otherwise they must appear on printed covers that bracket the whole aggregate.\n• TRANSLATION Translation is considered a kind of modification, so you may distribute translations of the Document under the terms of section 4. Replacing Invariant Sections with translations requires special permission from their copyright holders, but you may include translations of some or all Invariant Sections in addition to the original versions of these Invariant Sections. You may include a translation of this License, and all the license notices in the Document, and any Warranty Disclaimers, provided that you also include the original English version of this License and the original versions of those notices and disclaimers. In case of a disagreement between the translation and the original version of this License or a notice or disclaimer, the original version will prevail. If a section in the Document is Entitled “Acknowledgements”, “Dedications”, or “History”, the requirement (section 4) to Preserve its Title (section 1) will typically require changing the actual title.\n• TERMINATION You may not copy, modify, sublicense, or distribute the Document except as expressly provided under this License. Any attempt otherwise to copy, modify, sublicense, or distribute it is void, and will automatically terminate your rights under this License. However, if you cease all violation of this License, then your license from a particular copyright holder is reinstated (a) provisionally, unless and until the copyright holder explicitly and finally terminates your license, and (b) permanently, if the copyright holder fails to notify you of the violation by some reasonable means prior to 60 days after the cessation. Moreover, your license from a particular copyright holder is reinstated permanently if the copyright holder notifies you of the violation by some reasonable means, this is the first time you have received notice of violation of this License (for any work) from that copyright holder, and you cure the violation prior to 30 days after your receipt of the notice. Termination of your rights under this section does not terminate the licenses of parties who have received copies or rights from you under this License. If your rights have been terminated and not permanently reinstated, receipt of a copy of some or all of the same material does not give you any rights to use it.\n• FUTURE REVISIONS OF THIS LICENSE The Free Software Foundation may publish new, revised versions of the GNU Free Documentation License from time to time. Such new versions will be similar in spirit to the present version, but may differ in detail to address new problems or concerns. See http://www.gnu.org/copyleft/. Each version of the License is given a distinguishing version number. If the Document specifies that a particular numbered version of this License “or any later version” applies to it, you have the option of following the terms and conditions either of that specified version or of any later version that has been published (not as a draft) by the Free Software Foundation. If the Document does not specify a version number of this License, you may choose any version ever published (not as a draft) by the Free Software Foundation. If the Document specifies that a proxy can decide which future versions of this License can be used, that proxy’s public statement of acceptance of a version permanently authorizes you to choose that version for the Document.\n• RELICENSING “Massive Multiauthor Collaboration Site” (or “MMC Site”) means any World Wide Web server that publishes copyrightable works and also provides prominent facilities for anybody to edit those works. A public wiki that anybody can edit is an example of such a server. A “Massive Multiauthor Collaboration” (or “MMC”) contained in the site means any set of copyrightable works thus published on the MMC site. “CC-BY-SA” means the Creative Commons Attribution-Share Alike 3.0 license published by Creative Commons Corporation, a not-for-profit corporation with a principal place of business in San Francisco, California, as well as future copyleft versions of that license published by that same organization. “Incorporate” means to publish or republish a Document, in whole or in part, as part of another Document. An MMC is “eligible for relicensing” if it is licensed under this License, and if all works that were first published under this License somewhere other than this MMC, and subsequently incorporated in whole or in part into the MMC, (1) had no cover texts or invariant sections, and (2) were thus incorporated prior to November 1, 2008. The operator of an MMC Site may republish an MMC contained in the site under CC-BY-SA on the same site at any time before August 1, 2009, provided the MMC is eligible for relicensing.\n\nADDENDUM: How to use this License for your documents\n\nTo use this License in a document you have written, include a copy of the License in the document and put the following copyright and license notices just after the title page:\n\nIf you have Invariant Sections, Front-Cover Texts and Back-Cover Texts, replace the “with…Texts.” line with this:\n\nIf you have Invariant Sections without Cover Texts, or some other combination of the three, merge those two alternatives to suit the situation.\n\nIf your document contains nontrivial examples of program code, we recommend releasing these examples in parallel under your choice of free software license, such as the GNU General Public License, to permit their use in free software."
    },
    {
        "link": "https://stackoverflow.com/questions/29528732/gdb-print-all-values-in-char-array",
        "document": "With gdb, you can achieve to print the elements of your array using the following command:\n\nIf my variable array is a type such as below\n\nThen I could display the 2 first entries of my array by using:\n\nUsing it in order to display the arguments of a program is very handy:\n\nIt's also possible to do the same with x commands using , where N is the integer value of argc (i.e. for argc = 2, x/2s *argv)\n\nThe documentation for the whole magic of the print command is here."
    },
    {
        "link": "https://stackoverflow.com/questions/77824888/why-does-gdb-octal-escape-characters-when-querying-a-string-assigned-to-a-char-a",
        "document": "I noticed that, when assigning a std::string_view (or a std::string) to a character-array containing control characters (e.g. '\\001' [Start Of Heading]), then gdb will represent that string_view with octal-escape characters between the already existing control-characters and another specific character (in my case, '=').\n\nLooking at both and in the gdb debugger, we see:\n\nWe can see that after the first occurrence of , all \"key\" values are octal-escaped.\n\nWhy is this the case?\n\nWhen removing the control characters from the array, the \"escaping-conversion\" is not done. However, in a real-world example, the array must contain control characters.\n\nI do want to note that this is not a problem since substring lookups still work perfectly fine.\n\nI'm just curious to know why gdb gives us this representation."
    },
    {
        "link": "https://developer.apple.com/library/archive/documentation/DeveloperTools/gdb/gdb/gdb_9.html",
        "document": ""
    },
    {
        "link": "https://web.mit.edu/gnu/doc/html/gdb_10.html",
        "document": "The usual way to examine data in your program is with the command (abbreviated ), or its synonym . It evaluates and prints the value of an expression of the language your program is written in (see section Using GDB with Different Languages).\n\nA more low-level way of examining data is with the command. It examines data in memory at a specified address and prints it in a specified format. See section Examining memory.\n\nIf you are interested in information about types, or about how the fields of a struct or class are declared, use the command rather than . See section Examining the Symbol Table.\n\nand many other GDB commands accept an expression and compute its value. Any kind of constant, variable or operator defined by the programming language you are using is valid in an expression in GDB. This includes conditional expressions, function calls, casts and string constants. It unfortunately does not include symbols defined by preprocessor commands.\n\nCasts are supported in all languages, not just in C, because it is so useful to cast a number into a pointer so as to examine a structure at that address in memory.\n\nThe most common kind of expression to use is the name of a variable in your program.\n\nVariables in expressions are understood in the selected stack frame (see section Selecting a frame); they must either be global (or static) or be visible according to the scope rules of the programming language from the point of execution in that frame. This means that in the function\n\nyou can examine and use the variable whenever your program is executing within the function , but you can only use or examine the variable while your program is executing inside the block where is declared.\n\nThere is an exception: you can refer to a variable or function whose scope is a single source file even if the current execution point is not in this file. But it is possible to have more than one such variable or function with the same name (in different source files). If that happens, referring to that name has unpredictable effects. If you wish, you can specify a static variable in a particular function or file, using the colon-colon notation:\n\nHere or is the name of the context for the static . In the case of file names, you can use quotes to make sure GDB parses the file name as a single word--for example, to print a global value of defined in :\n\nThis use of is very rarely in conflict with the very similar use of the same notation in C++. GDB also supports use of the C++ scope resolution operator in GDB expressions.\n\nIt is often useful to print out several successive objects of the same type in memory; a section of an array, or an array of dynamically determined size for which only a pointer exists in the program.\n\nYou can do this by referring to a contiguous span of memory as an , using the binary operator . The left operand of should be the first element of the desired array, as an individual object. The right operand should be the desired length of the array. The result is an array value whose elements are all of the type of the left argument. The first element is actually the left argument; the second element comes from bytes of memory immediately following those that hold the first element, and so on. Here is an example. If a program says\n\nThe left operand of must reside in memory. Array values made with in this way behave just like other arrays in terms of subscripting, and are coerced to pointers when used in expressions. Artificial arrays most often appear in expressions via the value history (see section Value history), after printing one out.\n\nSometimes the artificial array mechanism is not quite enough; in moderately complex data structures, the elements of interest may not actually be adjacent--for example, if you are interested in the values of pointers in an array. One useful work-around in this situation is to use a convenience variable (see section Convenience variables) as a counter in an expression that prints the first interesting value, and then repeat that expression via . For instance, suppose you have an array of pointers to structures, and you are interested in the values of a field in each structure. Here is an example of what you might type:\n\nBy default, GDB prints a value according to its data type. Sometimes this is not what you want. For example, you might want to print a number in hex, or a pointer in decimal. Or you might want to view data in memory at a certain address as a character string or as an instruction. To do these things, specify an when you print a value.\n\nThe simplest use of output formats is to say how to print a value already computed. This is done by starting the arguments of the command with a slash and a format letter. The format letters supported are:\n\nTo reprint the last value in the value history with a different format, you can use the command with just a format and no expression. For example, reprints the last value in hex.\n\nYou can use the command (for \"examine\") to examine memory in any of several formats, independently of your program's data types.\n\n, , and are all optional parameters that specify how much memory to display and how to format it; is an expression giving the address where you want to start displaying memory. If you use defaults for , you need not type the slash . Several commands set convenient defaults for .\n\nFor example, is a request to display three halfwords ( ) of memory, formatted as unsigned decimal integers ( ), starting at address . prints the four words ( ) of memory above the stack pointer (here, ; see section Registers) in hexadecimal ( ).\n\nSince the letters indicating unit sizes are all distinct from the letters specifying output formats, you do not have to remember whether unit size or format comes first; either order works. The output specifications and mean exactly the same thing. (However, the count must come first; does not work.)\n\nEven though the unit size is ignored for the formats and , you might still want to use a count ; for example, specifies that you want to see three machine instructions, including any operands. The command gives an alternative way of inspecting machine instructions; see section Source and machine code.\n\nAll the defaults for the arguments to are designed to make it easy to continue scanning memory with minimal specifications each time you use . For example, after you have inspected three machine instructions with , you can inspect the next seven with just . If you use to repeat the command, the repeat count is used again; the other arguments default as for successive uses of .\n\nThe addresses and contents printed by the command are not saved in the value history because there is often too much of them and they would get in the way. Instead, GDB makes these values available for subsequent use in expressions as values of the convenience variables and . After an command, the last address examined is available for use in expressions in the convenience variable . The contents of that address, as examined, are available in the convenience variable .\n\nIf the command has a repeat count, the address and contents saved are from the last memory unit printed; this is not the same as the last address printed if several units were printed on the last line of output.\n\nIf you find that you want to print the value of an expression frequently (to see how it changes), you might want to add it to the so that GDB prints its value each time your program stops. Each expression added to the list is given a number to identify it; to remove an expression from the list, you specify that number. The automatic display looks like this:\n\nThis display shows item numbers, expressions and their current values. As with displays you request manually using or , you can specify the output format you prefer; in fact, decides whether to use or depending on how elaborate your format specification is--it uses if you specify a unit size, or one of the two formats ( and ) that are only supported by ; otherwise it uses .\n\nFor example, can be helpful, to see the machine instruction about to be executed each time execution stops ( is a common name for the program counter; see section Registers).\n\nIf a display expression refers to local variables, then it does not make sense outside the lexical context for which it was set up. Such an expression is disabled when execution enters a context where one of its variables is not defined. For example, if you give the command while inside a function with an argument , GDB displays this argument while your program continues to stop inside that function. When it stops elsewhere--where there is no variable ---the display is disabled automatically. The next time your program stops where is meaningful, you can enable the display expression once again.\n\nWhen GDB prints a symbolic address, it normally prints the closest earlier symbol plus an offset. If that symbol does not uniquely identify the address (for example, it is a name whose scope is a single source file), you may need to disambiguate. One way to do this is with , for example . Alternately, you can set GDB to print the source file and line number when it prints a symbolic address:\n\nAnother situation where it is helpful to show symbol filenames and line numbers is when disassembling code; GDB shows you the line number and source file that corresponds to each instruction.\n\nAlso, you may wish to see the symbolic form only if the address being printed is reasonably close to the closest earlier symbol:\n\nIf you have a pointer and you are not sure where it points, try . Then you can determine the name and source file location of the variable where it points, using . This interprets the address in symbolic form. For example, here GDB shows that a variable points at another variable , defined in :\n\nValues printed by the command are saved in the GDB so that you can refer to them in other expressions. Values are kept until the symbol table is re-read or discarded (for example with the or commands). When the symbol table changes, the value history is discarded, since the values may contain pointers back to the types defined in the symbol table.\n\nThe values printed are given by which you can refer to them. These are successive integers starting with one. shows you the history number assigned to a value by printing before the value; here is the history number.\n\nTo refer to any previous value, use followed by the value's history number. The way labels its output is designed to remind you of this. Just refers to the most recent value in the history, and refers to the value before that. refers to the th value from the end; is the value just prior to , is equivalent to , and is equivalent to .\n\nFor example, suppose you have just printed a pointer to a structure and want to see the contents of the structure. It suffices to type\n\nIf you have a chain of structures where the component points to the next one, you can print the contents of the next one with this:\n\nNote that the history records values, not expressions. If the value of is 4 and you type these commands:\n\nthen the value recorded in the value history by the command remains 4 even though the value of has changed.\n\nGDB provides that you can use within GDB to hold on to a value and refer to it later. These variables exist entirely within GDB; they are not part of your program, and setting a convenience variable has no direct effect on further execution of your program. That is why you can use them freely.\n\nConvenience variables are prefixed with . Any name preceded by can be used for a convenience variable, unless it is one of the predefined machine-specific register names (see section Registers). (Value history references, in contrast, are numbers preceded by . See section Value history.)\n\nYou can save a value in a convenience variable with an assignment expression, just as you would set a variable in your program. For example:\n\nUsing a convenience variable for the first time creates it, but its value is until you assign a new value. You can alter the value with another assignment at any time.\n\nConvenience variables have no fixed types. You can assign a convenience variable any type of value, including structures and arrays, even if that variable already has a value of a different type. The convenience variable, when used as an expression, has the type of its current value.\n\nOne of the ways to use a convenience variable is as a counter to be incremented or a pointer to be advanced. For example, to print a field from successive elements of an array of structures:\n\nYou can refer to machine register contents, in expressions, as variables with names starting with . The names of registers are different for each machine; use to see the names used on your machine.\n\nGDB has four \"standard\" register names that are available (in expressions) on most machines--whenever they do not conflict with an architecture's canonical mnemonics for registers. The register names and are used for the program counter register and the stack pointer. is used for a register that contains a pointer to the current stack frame, and is used for a register that contains the processor status. For example, you could print the program counter in hex with\n\nWhenever possible, these four standard register names are available on your machine even though the machine has different canonical mnemonics, so long as there is no conflict. The command shows the canonical names. For example, on the SPARC, displays the processor status register as but you can also refer to it as .\n\nGDB always considers the contents of an ordinary register as an integer when the register is examined in this way. Some machines have special registers which can hold nothing but floating point; these registers are considered to have floating point values. There is no way to refer to the contents of an ordinary register as floating point value (although you can print it as a floating point value with ).\n\nSome registers have distinct \"raw\" and \"virtual\" data formats. This means that the data format in which the register contents are saved by the operating system is not the same one that your program normally sees. For example, the registers of the 68881 floating point coprocessor are always saved in \"extended\" (raw) format, but all C programs expect to work with \"double\" (virtual) format. In such cases, GDB normally works with the virtual format only (the format that makes sense for your program), but the command prints the data in both formats.\n\nNormally, register values are relative to the selected stack frame (see section Selecting a frame). This means that you get the value that the register would contain if all stack frames farther in were exited and their saved registers restored. In order to see the true contents of hardware registers, you must select the innermost frame (with ).\n\nHowever, GDB must deduce where registers are saved, from the machine code generated by your compiler. If some registers are not saved, or if GDB is unable to locate the saved registers, the selected stack frame makes no difference.\n\nDepending on the configuration, GDB may be able to give you more information about the status of the floating point hardware."
    },
    {
        "link": "https://web.mit.edu/gnu/doc/html/gdb_11.html",
        "document": "Go to the previous, next section.\n\nUsing GDB with Different Languages\n\nAlthough programming languages generally have common aspects, they are rarely expressed in the same manner. For instance, in ANSI C, dereferencing a pointer is accomplished by , but in Modula-2, it is accomplished by . Values can also be represented (and displayed) differently. Hex numbers in C are written like , while in Modula-2 they appear as .\n\nLanguage-specific information is built into GDB for some languages, allowing you to express operations like the above in your program's native language, and allowing GDB to output values in a manner consistent with the syntax of your program's native language. The language you use to build expressions, called the , can be selected manually, or GDB can set it automatically.\n\nThere are two ways to control the working language--either have GDB set it automatically, or select it manually yourself. You can use the command for either purpose. On startup, GDB defaults to setting the language automatically.\n\nIf you allow GDB to set the language automatically, expressions are interpreted the same way in your debugging session and your program.\n\nIf you wish, you may set the language manually. To do this, issue the command , where is the name of a language, such as or . For a list of the supported languages, type .\n\nSetting the language manually prevents GDB from updating the working language automatically. This can lead to confusion if you try to debug a program when the working language is not the same as the source language, when an expression is acceptable to both languages--but means different things. For instance, if the current source file were written in C, and GDB was parsing Modula-2, a command such as:\n\nmight not have the effect you intended. In C, this means to add and and place the result in . The result printed would be the value of . In Modula-2, this means to compare to the result of , yielding a value.\n\nTo have GDB set the working language automatically, use or . GDB then infers the language that a program was written in by looking at the name of its source files, and examining their extensions:\n\nThis information is recorded for each function or procedure in a source file. When your program stops in a frame (usually by encountering a breakpoint), GDB sets the working language to the language recorded for the function in that frame. If the language for a frame is unknown (that is, if the function or block corresponding to the frame was defined in a source file that does not have a recognized extension), the current working language is not changed, and GDB issues a warning.\n\nThis may not seem necessary for most programs, which are written entirely in one source language. However, program modules and libraries written in one source language can be used by a main program written in a different source language. Using in this case frees you from having to set the working language manually.\n\nThe following commands help you find out which language is the working language, and also what language source files were written in.\n\nSome languages are designed to guard you against making seemingly common errors through a series of compile- and run-time checks. These include checking the type of arguments to functions and operators, and making sure mathematical overflows are caught at run time. Checks such as these help to ensure a program's correctness once it has been compiled by eliminating type mismatches, and providing active checks for range errors when your program is running.\n\nGDB can check for conditions like the above if you wish. Although GDB does not check the statements in your program, it can check expressions entered directly into GDB for evaluation via the command, for example. As with the working language, GDB can also decide whether or not to check automatically based on your program's source language. See section Supported languages, for the default settings of supported languages.\n\nSome languages, such as Modula-2, are strongly typed, meaning that the arguments to operators and functions have to be of the correct type, otherwise an error occurs. These checks prevent type mismatch errors from ever causing any run-time problems. For example,\n\nThe second example fails because the 1 is not type-compatible with the 2.3.\n\nFor expressions you use in GDB commands, you can tell the GDB type checker to skip checking; to treat any mismatches as errors and abandon the expression; or only issue warnings when type mismatches occur, but evaluate the expression anyway. When you choose the last of these, GDB evaluates expressions like the second example above, but also issues a warning.\n\nEven though you may turn type checking off, other type-based reasons may prevent GDB from evaluating an expression. For instance, GDB does not know how to add an and a . These particular type errors have nothing to do with the language in use, and usually arise from expressions, such as the one described above, which make little sense to evaluate anyway.\n\nEach language defines to what degree it is strict about type. For instance, both Modula-2 and C require the arguments to arithmetical operators to be numbers. In C, enumerated types and pointers can be represented as numbers, so that they are valid arguments to mathematical operators. See section Supported languages, for further details on specific languages.\n\nGDB provides some additional commands for controlling the type checker:\n\nIn some languages (such as Modula-2), it is an error to exceed the bounds of a type; this is enforced with run-time checks. Such range checking is meant to ensure program correctness by making sure computations do not overflow, or indices on an array element access do not exceed the bounds of the array.\n\nFor expressions you use in GDB commands, you can tell GDB to treat range errors in one of three ways: ignore them, always treat them as errors and abandon the expression, or issue warnings but evaluate the expression anyway.\n\nA range error can result from numerical overflow, from exceeding an array index bound, or when you type a constant that is not a member of any type. Some languages, however, do not treat overflows as an error. In many implementations of C, mathematical overflow causes the result to \"wrap around\" to lower values--for example, if is the largest integer value, and is the smallest, then\n\nThis, too, is specific to individual languages, and in some cases specific to individual compilers or machines. See section Supported languages, for further details on specific languages.\n\nGDB provides some additional commands for controlling the range checker:\n\nGDB 4 supports C, C++, and Modula-2. Some GDB features may be used in expressions regardless of the language you use: the GDB and operators, and the construct (see section Expressions) can be used with the constructs of any supported language.\n\nThe following sections detail to what degree each source language is supported by GDB. These sections are not meant to be language tutorials or references, but serve only as a reference guide to what the GDB expression parser accepts, and what input and output formats should look like for different languages. There are many good books written on each of these languages; please look to these for a language reference or tutorial.\n\nC and C++\n\nSince C and C++ are so closely related, many features of GDB apply to both languages. Whenever this is the case, we discuss both languages together.\n\nThe C++ debugging facilities are jointly implemented by the GNU C++ compiler and GDB. Therefore, to debug your C++ code effectively, you must compile your C++ programs with the GNU C++ compiler, .\n\nFor best results when debugging C++ programs, use the stabs debugging format. You can select that format explicitly with the command-line options or . See section `Options for Debugging Your Program or GNU CC' in , for more information.\n\nC and C++ operators\n\nOperators must be defined on values of specific types. For instance, is defined on numbers, but not on structures. Operators are often defined on groups of types.\n\nFor the purposes of C and C++, the following definitions hold:\n• Integral types include with any of its storage-class specifiers; ; and .\n• Scalar types include all of the above.\n\nThe following operators are supported. They are listed here in order of increasing precedence:\n\nC and C++ constants\n\nGDB allows you to express the constants of C and C++ in the following ways:\n• Integer constants are a sequence of digits. Octal constants are specified by a leading (ie. zero), and hexadecimal constants by a leading or . Constants may also end with a letter , specifying that the constant should be treated as a value.\n• Floating point constants are a sequence of digits, followed by a decimal point, followed by a sequence of digits, and optionally followed by an exponent. An exponent is of the form: , where is another sequence of digits. The is optional for positive exponents.\n• Enumerated constants consist of enumerated identifiers, or their integral equivalents.\n• Character constants are a single character surrounded by single quotes ( ), or a number--the ordinal value of the corresponding character (usually its ASCII value). Within quotes, the single character may be represented by a letter or by , which are of the form , where is the octal representation of the character's ordinal value; or of the form , where is a predefined special character--for example, for newline.\n• String constants are a sequence of character constants surrounded by double quotes ( ).\n• Pointer constants are an integral value. You can also write pointers to constants using the C operator .\n• Array constants are comma-separated lists surrounded by braces and ; for example, is a three-element array of integers, is a three-by-two array, and is a three-element array of pointers.\n\nGDB expression handling has a number of extensions to interpret a significant subset of C++ expressions.\n• Member function calls are allowed; you can use expressions like\n• While a member function is active (in the selected stack frame), your expressions have the same namespace available as the member function; that is, GDB allows implicit references to the class instance pointer following the same rules as C++.\n• You can call overloaded functions; GDB resolves the function call to the right definition, with one restriction--you must use arguments of the type required by the function that you want to call. GDB does not perform conversions requiring constructors or user-defined type operators.\n• GDB understands variables declared as C++ references; you can use them in expressions just as you do in C++ source--they are automatically dereferenced. In the parameter list shown when GDB displays a frame, the values of reference variables are not displayed (unlike other variables); this avoids clutter, since references are often used for large structures. The address of a reference variable is always shown, unless you have specified .\n• GDB supports the C++ name resolution operator ---your expressions can use it just as expressions in your program do. Since one scope may be defined in another, you can use repeatedly if necessary, for example in an expression like . GDB also allows resolving name scope by reference to source files, in both C and C++ debugging (see section Program variables).\n\nC and C++ defaults\n\nIf you allow GDB to set type and range checking automatically, they both default to whenever the working language changes to C or C++. This happens regardless of whether you, or GDB, selected the working language.\n\nIf you allow GDB to set the language automatically, it sets the working language to C or C++ on entering code compiled from a source file whose name ends with , , or . See section Having GDB infer the source language, for further details.\n\nC and C++ type and range checks\n\nBy default, when GDB parses C or C++ expressions, type checking is not used. However, if you turn type checking on, GDB considers two variables type equivalent if:\n• The two variables are structured and have the same structure, union, or enumerated tag.\n• Two two variables have the same type name, or types that have been declared equivalent through .\n\nRange checking, if turned on, is done on mathematical operations. Array indices are not checked, since they are often used to index a pointer that is not itself an array.\n\nThe and commands apply to the type. When set to , any that is inside a or is also printed. Otherwise, it appears as .\n\nThe operator aids in the debugging of dynamic arrays, formed with pointers and a memory allocation function. See section Expressions.\n\nSome GDB commands are particularly useful with C++, and some are designed specifically for use with C++. Here is a summary:\n\nThe extensions made to GDB to support Modula-2 only support output from the GNU Modula-2 compiler (which is currently being developed). Other Modula-2 compilers are not currently supported, and attempting to debug executables produced by them is most likely to give an error as GDB reads in the executable's symbol table.\n\nOperators must be defined on values of specific types. For instance, is defined on numbers, but not on structures. Operators are often defined on groups of types. For the purposes of Modula-2, the following definitions hold:\n• Integral types consist of , , and their subranges.\n• Character types consist of and its subranges.\n• Pointer types consist of anything declared as .\n• Scalar types consist of all of the above.\n\nThe following operators are supported, and appear in order of increasing precedence:\n\nModula-2 also makes available several built-in procedures and functions. In describing these, the following metavariables are used:\n\nAll Modula-2 built-in procedures also return a result, described below.\n\nGDB allows you to express the constants of Modula-2 in the following ways:\n• Integer constants are simply a sequence of digits. When used in an expression, a constant is interpreted to be type-compatible with the rest of the expression. Hexadecimal integers are specified by a trailing , and octal integers by a trailing .\n• Floating point constants appear as a sequence of digits, followed by a decimal point and another sequence of digits. An optional exponent can then be specified, in the form , where is the desired exponent. All of the digits of the floating point constant must be valid decimal (base 10) digits.\n• Character constants consist of a single character enclosed by a pair of like quotes, either single ( ) or double ( ). They may also be expressed by their ordinal value (their ASCII value, usually) followed by a .\n• String constants consist of a sequence of characters enclosed by a pair of like quotes, either single ( ) or double ( ). Escape sequences in the style of C are also allowed. See section C and C++ constants, for a brief explanation of escape sequences.\n• Boolean constants consist of the identifiers and .\n• Set constants are not yet supported.\n\nIf type and range checking are set automatically by GDB, they both default to whenever the working language changes to Modula-2. This happens regardless of whether you, or GDB, selected the working language.\n\nIf you allow GDB to set the language automatically, then entering code compiled from a file whose name ends with sets the working language to Modula-2. See section Having GDB infer the source language, for further details.\n\nA few changes have been made to make Modula-2 programs easier to debug. This is done primarily via loosening its type strictness:\n• Unlike in standard Modula-2, pointer constants can be formed by integers. This allows you to modify pointer variables during debugging. (In standard Modula-2, the actual address contained in a pointer variable is hidden from you; it can only be modified through direct assignment to another pointer variable or expression that returned a pointer.)\n• C escape sequences can be used in strings and characters to represent non-printable characters. GDB prints out strings with these escape sequences embedded. Single non-printable characters are printed using the format.\n• The assignment operator ( ) returns the value of its right-hand argument.\n• All built-in procedures both modify and return their argument.\n• They are of types that have been declared equivalent via a statement\n• They have been declared on the same line. (Note: This is true of the GNU Modula-2 compiler, but it may not be true of other compilers.)\n\nAs long as type checking is enabled, any attempt to combine variables whose types are not equivalent is an error.\n\nRange checking is done on all mathematical operations, assignment, array index bounds, and all built-in functions and procedures.\n\nThere are a few subtle differences between the Modula-2 scope operator ( ) and the GDB scope operator ( ). The two have similar syntax:\n\nwhere is the name of a module or a procedure, the name of a module, and is any declared identifier within your program, except another module.\n\nUsing the operator makes GDB search the scope specified by for the identifier . If it is not found in the specified scope, then GDB searches all scopes enclosing the one specified by .\n\nUsing the operator makes GDB search the current scope for the identifier specified by that was imported from the definition module specified by . With this operator, it is an error if the identifier was not imported from definition module , or if is not an identifier in .\n\nSome GDB commands have little use when debugging Modula-2 programs. Five subcommands of and apply specifically to C and C++: , , , , and . The first four apply to C++, and the last to the C type, which has no direct analogue in Modula-2.\n\nThe operator (see section Expressions), while available while using any language, is not useful with Modula-2. Its intent is to aid the debugging of , which cannot be created in Modula-2 as they can in C or C++. However, because an address can be specified by an integral constant, the construct is still useful. (see section Expressions)\n\nIn GDB scripts, the Modula-2 inequality operator is interpreted as the beginning of a comment. Use instead.\n\nGo to the previous, next section."
    }
]