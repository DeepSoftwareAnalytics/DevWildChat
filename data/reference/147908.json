[
    {
        "link": "https://developer.android.com/develop/ui/compose/state",
        "document": "State in an app is any value that can change over time. This is a very broad definition and encompasses everything from a Room database to a variable in a class.\n\nAll Android apps display state to the user. A few examples of state in Android apps:\n• A Snackbar that shows when a network connection can't be established.\n• Ripple animations on buttons that play when a user clicks them.\n• Stickers that a user can draw on top of an image.\n\nJetpack Compose helps you be explicit about where and how you store and use state in an Android app. This guide focuses on the connection between state and composables, and on the APIs that Jetpack Compose offers to work with state more easily.\n\nCompose is declarative and as such the only way to update it is by calling the same composable with new arguments. These arguments are representations of the UI state. Any time a state is updated a recomposition takes place. As a result, things like don’t automatically update like they do in imperative XML based views. A composable has to explicitly be told the new state in order for it to update accordingly.\n\nIf you run this and try to enter text, you'll see that nothing happens. That's because the doesn't update itself—it updates when its parameter changes. This is due to how composition and recomposition work in Compose.\n\nTo learn more about initial composition and recomposition, see Thinking in Compose.\n\nComposable functions can use the API to store an object in memory. A value computed by is stored in the Composition during initial composition, and the stored value is returned during recomposition. can be used to store both mutable and immutable objects.\n\ncreates an observable , which is an observable type integrated with the compose runtime.\n\nAny changes to schedules recomposition of any composable functions that read .\n\nThere are three ways to declare a object in a composable:\n\nThese declarations are equivalent, and are provided as syntax sugar for different uses of state. You should pick the one that produces the easiest-to-read code in the composable you're writing.\n\nThe delegate syntax requires the following imports:\n\nYou can use the remembered value as a parameter for other composables or even as logic in statements to change which composables are displayed. For example, if you don't want to display the greeting if the name is empty, use the state in an statement:\n\nWhile helps you retain state across recompositions, the state is not retained across configuration changes. For this, you must use . automatically saves any value that can be saved in a . For other values, you can pass in a custom saver object.\n\nCompose doesn't require that you use to hold state; it supports other observable types. Before reading another observable type in Compose, you must convert it to a so that composables can automatically recompose when the state changes.\n\nCompose ships with functions to create from common observable types used in Android apps. Before using these integrations, add the appropriate artifact(s) as outlined below:\n• collects values from a in a lifecycle-aware manner, allowing your app to conserve app resources. It represents the latest emitted value from the Compose . Use this API as the recommended way to collect flows on Android apps. Note: API , you can read To learn more about collecting flows safely in Android withAPI , you can read this blog post The following dependency is required in the file (it should be 2.6.0-beta01 or newer):\n• is similar to , because it also collects values from a and transforms it into Compose . Use for platform-agnostic code instead of , which is Android-only. Additional dependencies are not required for , because it is available in .\n• starts observing this and represents its values via . The following dependency is required in the file:\n• are extension functions that transform RxJava2’s reactive streams (e.g. , , ) into Compose . The following dependency is required in the file:\n• are extension functions that transform RxJava3’s reactive streams (e.g. , , ) into Compose . The following dependency is required in the file:\n\nA composable that uses to store an object creates internal state, making the composable stateful. is an example of a stateful composable because it holds and modifies its state internally. This can be useful in situations where a caller doesn't need to control the state and can use it without having to manage the state themselves. However, composables with internal state tend to be less reusable and harder to test.\n\nA stateless composable is a composable that doesn't hold any state. An easy way to achieve stateless is by using state hoisting.\n\nAs you develop reusable composables, you often want to expose both a stateful and a stateless version of the same composable. The stateful version is convenient for callers that don't care about the state, and the stateless version is necessary for callers that need to control or hoist the state.\n\nState hoisting in Compose is a pattern of moving state to a composable's caller to make a composable stateless. The general pattern for state hoisting in Jetpack Compose is to replace the state variable with two parameters:\n• : the current value to display\n• : an event that requests the value to change, where is the proposed new value\n\nHowever, you are not limited to . If more specific events are appropriate for the composable, you should define them using lambdas.\n\nState that is hoisted this way has some important properties:\n• Single source of truth: By moving state instead of duplicating it, we're ensuring there's only one source of truth. This helps avoid bugs.\n• Encapsulated: Only stateful composables can modify their state. It's completely internal.\n• Shareable: Hoisted state can be shared with multiple composables. If you wanted to read in a different composable, hoisting would allow you to do that.\n• Interceptable: callers to the stateless composables can decide to ignore or modify events before changing the state.\n• Decoupled: the state for the stateless composables may be stored anywhere. For example, it's now possible to move into a .\n\nIn the example case, you extract the and the out of and move them up the tree to a composable that calls .\n\nBy hoisting the state out of , it's easier to reason about the composable, reuse it in different situations, and test. is decoupled from how its state is stored. Decoupling means that if you modify or replace , you don't have to change how is implemented.\n\nThe pattern where the state goes down, and events go up is called a unidirectional data flow. In this case, the state goes down from to and events go up from to . By following unidirectional data flow, you can decouple composables that display state in the UI from the parts of your app that store and change state.\n\nSee the Where to hoist state page to learn more.\n\nThe API behaves similarly to because it retains state across recompositions, and also across activity or process recreation using the saved instance state mechanism. For example, this happens, when the screen is rotated.\n\nAll data types that are added to the are saved automatically. If you want to save something that cannot be added to the , there are several options.\n\nThe simplest solution is to add the annotation to the object. The object becomes parcelable, and can be bundled. For example, this code makes a parcelable data type and saves it to the state.\n\nIf for some reason is not suitable, you can use to define your own rule for converting an object into a set of values that the system can save to the .\n\nTo avoid needing to define the keys for the map, you can also use and use its indices as keys:\n\nSimple state hoisting can be managed in the composable functions itself. However, if the amount of state to keep track of increases, or the logic to perform in composable functions arises, it's a good practice to delegate the logic and state responsibilities to other classes: state holders.\n\nSee the state hoisting in Compose documentation or, more generally, the State holders and UI State page in the architecture guide to learn more.\n\nThe API is frequently used together with :\n\nHere, using the function makes the value survive recompositions.\n\nIn general, takes a lambda parameter. When is first run, it invokes the lambda and stores its result. During recomposition, returns the value that was last stored.\n\nApart from caching state, you can also use to store any object or result of an operation in the Composition that is expensive to initialize or calculate. You might not want to repeat this calculation in every recomposition. An example is creating this object, which is an expensive operation:\n\nstores the value until it leaves the Composition. However, there is a way to invalidate the cached value. The API also takes a or parameter. If any of these keys change, the next time the function recomposes, invalidates the cache and executes the calculation lambda block again. This mechanism gives you control over the lifetime of an object in the Composition. The calculation remains valid until the inputs change, instead of until the remembered value leaves the Composition.\n\nThe following examples show how this mechanism works.\n\nIn this snippet, a is created and used as the background paint of a composable. stores the instance because it is expensive to recreate, as explained earlier. takes as the parameter, which is the selected background image. If changes, the brush recomposes with the new image, and reapplies to the . This can occur when the user selects another image to be the background from a picker.\n\nIn the next snippet, state is hoisted to a plain state holder class . It exposes a function to initialize an instance of the class using . Exposing such functions to create an instance that survives recompositions is a common pattern in Compose. The function receives , which serves as the parameter for . If this parameter changes, the app needs to recreate the plain state holder class with the latest value. This may occur if, for example, the user rotates the device.\n\nCompose uses the class's equals implementation to decide if a key has changed and invalidate the stored value.\n\nThe API is a wrapper around that can store data in a . This API allows state to survive not only recomposition, but also activity recreation and system-initiated process death. receives parameters for the same purpose that receives . The cache is invalidated when any of the inputs change. The next time the function recomposes, re-executes the calculation lambda block.\n\nIn the following example, stores until changes:\n\nTo learn more about state and Jetpack Compose, consult the following additional resources."
    },
    {
        "link": "https://developer.android.com/codelabs/jetpack-compose-advanced-state-side-effects",
        "document": "The code for this codelab can be found in the android-compose-codelabs Github repository. To clone it, run: Alternatively, you can download the repository as a zip file: The code you just downloaded contains code for all Compose codelabs available. To complete this codelab, open the project inside Android Studio. The compose-codelabs repo contains starter code for all codelabs in the pathway. For this codelab, use the AdvancedStateAndSideEffectsCodelab project.\n• AdvancedStateAndSideEffectsCodelab — Project that contains the start and finished code for this codelab. The project is built in multiple git branches:\n• main – the starter code for this project; you will make changes to this to complete the codelab.\n• end – contains the solution to this codelab. We recommend that you start with the code in the main branch and follow the codelab step-by-step at your own pace. During the codelab, you'll be presented with snippets of code that you'll need to add to the project. In some places, you'll also need to remove code that is explicitly mentioned in comments on the code snippets. Getting familiar with the code and running the sample app Take a moment to explore the project structure and run the app. When you run the app from the main branch, you'll see that some functionality such as the drawer, or loading flight destinations doesn't work! That's what you'll be doing in the next steps of the codelab. The app is covered with very basic UI tests available in the folder. They should pass for both the and branches at all times. [Optional] Displaying the map on the details screen Displaying the map of the city on the details screen is not necessary at all to follow along. However, if you want to see it, you need to get a personal API key as the Maps documentation says. Include that key in the file as follows: When setting up the credentials in the Google dashboard, make sure to use as the package name, and as the SHA-1 certificate fingerprint. To get the branch using git, use this command: Alternatively, you can download the solution code from here:\n• How do I set up a device for development?\n\nThe list of flight destinations is still empty. In the previous step, you produced the UI state in the . Now, you'll consume the UI state exposed by to display in the UI. Open the file and look at the composable. There's a TODO comment above the definition of which is assigned to a remembered empty list. This is what's showing on the screen: an empty list! In this step, you'll fix that and show the suggested destinations that the exposes. Open and take a look at the StateFlow that is initialized to , and gets updated when the or functions get called. You want your UI in the composable to update whenever there's a new item emitted into the stream of data. You can use the function. collects values from the and represents the latest value via Compose's State API in a lifecycle-aware manner. This will make the Compose code that reads that state value recompose on new emissions. To start using the API, first add the following dependency in . The variable is defined already in the project with the appropriate version. Note: To learn more about the API, see the Consuming flows safely in Jetpack Compose blog post. Go back to the composable and replace the line that assigns with a call to on the 's property: If you run the app, you'll see that the list of destinations are populated, and that they change whenever you tap the number of people traveling. Compose also offers APIs for Android's most popular stream-based solutions:\n• included in the or artifact. See the Other supported types of state page in the State documentation to learn more.\n\nIn the project, there's a file that's not used at the moment. You want to add a landing screen to the app, which potentially could be used to load all the data needed in the background. The landing screen will occupy the whole screen and show the app's logo in the middle of the screen. Ideally, you'd show the screen and—after all the data's been loaded—you'd notify the caller that the landing screen can be dismissed using the callback. Kotlin coroutines are the recommended way to perform asynchronous operations in Android. An app would usually use coroutines to load things in the background when it starts. Jetpack Compose offers APIs that make using coroutines safe within the UI layer. As this app doesn't communicate with a backend, you'll use the coroutines' function to simulate loading things in the background. A side-effect in Compose is a change to the state of the app that happens outside the scope of a composable function. For example, opening a new screen when the user taps on a button, or showing a message when the app doesn't have Internet connection. A side-effect in Compose is a change to the state of the app that happens outside the scope of a composable function. Changing the state to show/hide the landing screen will happen in the callback and since before calling you need to load things using coroutines, the state change needs to happen in the context of a coroutine! To call suspend functions safely from inside a composable, use the API, which triggers a coroutine-scoped side-effect in Compose. When enters the Composition, it launches a coroutine with the block of code passed as a parameter. The coroutine will be canceled if leaves the composition. Although the next code is not correct, let's see how to use this API and discuss why the following code is wrong. You'll call the composable later in this step. Some side-effect APIs like take a variable number of keys as a parameter that are used to restart the effect whenever one of those keys changes. Have you spotted the error? We wouldn't want to restart the if callers to this composable function pass a different lambda value. That'd make the start again and you wouldn't be meeting the requirements. Let's fix this. To trigger the side-effect only once during the lifecycle of this composable, use a constant as a key, for example . However, now there's a different issue. If changes while the side-effect is in progress, there's no guarantee that the last is called when the effect finishes. To guarantee that the last is called, remember using the API. This API captures and updates the newest value: You should use when a long-lived lambda or object expression references parameters or values computed during composition, which might be common when working with . Now, you need to show the landing screen when the app is opened. Open the file and check out the composable that's first called. In the composable, you can simply add an internal state that tracks whether the landing should be shown or not: If you run the app now, you should see the appearing and disappearing after 2 seconds.\n\nIn this step, you'll make the navigation drawer work. Currently, nothing happens if you try to tap the hamburger menu. Open the file and check out the composable to see where you need to open the navigation drawer: in the callback! In , you have a that contains a . has methods to open and close the navigation drawer programmatically. However, if you attempt to write in the callback, you'll get an error! That's because the function is a suspend function. We're in the realm of coroutines again. Apart from APIs to make calling coroutines safe from the UI layer, some Compose APIs are suspend functions. One example of this is the API to open the navigation drawer. Suspend functions, in addition to being able to run asynchronous code, also help represent concepts that happen over time. As opening the drawer requires some time, movement, and potential animations, that's perfectly reflected with the suspend function, which will suspend the execution of the coroutine where it's been called until it finishes and resumes execution. must be called within a coroutine. What can you do? is a simple callback function, therefore:\n• You cannot simply call suspend functions in it because is not executed in the context of a coroutine.\n• You cannot use as before because we cannot call composables in . We're not in the Composition. You want to launch a coroutine; which scope should we use? Ideally, you'd want a that follows the lifecycle of its call-site. Using the API returns a bound to the point in the Composition where you call it. The scope will be automatically canceled once it leaves the Composition. With that scope, you can start coroutines when you're not in the Composition, for example, in the callback. If you run the app, you'll see that the navigation drawer opens when you tap the hamburger menu icon. Using in this case wasn't possible because you needed to trigger the call to create a coroutine in a regular callback that was outside of the Composition. Looking back at the landing screen step that used , could you use and call instead of using ? You could've done that, and it would've seemed to work, but it wouldn't be correct. As explained in the Thinking in Compose documentation, composables can be called by Compose at any moment. guarantees that the side-effect will be executed when the call to that composable makes it into the Composition. If you use and in the body of the , the coroutine will be executed every time is called by Compose regardless of whether that call makes it into the Composition or not. Therefore, you'll waste resources and you won't be executing this side-effect in a controlled environment.\n\nHave you noticed that if you tap Choose Destination you can edit the field and filter cities based on your search input? You also probably noticed that whenever you modify Choose Destination, the text style changes. Open the file. The stateful composable takes some parameters such as the and a which corresponds to the optional text next to the icon. For example, the To appears when you search for a destination. The logic to update the and determine whether what's been displayed corresponds to the hint or not is all in the body of the composable. This brings some downsides with it:\n• The value of the is not hoisted and therefore cannot be controlled from outside, making testing harder.\n• The logic of this composable could become more complex and the internal state could be out of sync more easily. By creating a state holder responsible for the internal state of this composable, you can centralize all state changes in one place. With this, it's more difficult for the state to be out of sync, and the related logic is all grouped together in a single class. Furthermore, this state can be easily hoisted up and can be consumed from callers of this composable. In this case, hoisting the state is a good idea since this is a low-level UI component that might be reused in other parts of the app. Therefore, the more flexible and controllable it is, the better. As is a reusable component, create a regular class as state holder named in the same file that looks like the following: The class should have the following traits:\n• is a mutable state of type , just as you have in . It's important to use so that Compose tracks changes to the value and recomposes when changes happen.\n• is a , with a private so it can't be directly mutated from outside the class. Instead of making this variable public, you can expose an event to modify it, which makes the class the single source of truth.\n• The class takes an as a dependency that is used to initialize .\n• The logic to know if the is the hint or not is in the property that performs the check on-demand. If the logic gets more complex in the future, you only need to make changes to one class: . State holders always need to be remembered in order to keep them in the Composition and not create a new one every time. It's a good practice to create a method in the same file that does this to remove boilerplate and avoid any mistakes that might occur. In the file, add this code: If you only this state, it won't survive activity recreations. To achieve that, you can use the API instead which behaves similarly to , but the stored value also survives activity and process recreation. Internally, it uses the saved instance state mechanism. does all this with no extra work for objects that can be stored inside a . That's not the case for the class that you created in your project. Therefore, you need to tell how to save and restore an instance of this class using a . A describes how an object can be converted into something which is . Implementations of a need to override two functions:\n• to convert the original value to a saveable one.\n• to convert the restored value to an instance of the original class. For this case, instead of creating a custom implementation of for the class, you can use some of the existing Compose APIs such as or (that stores the values to save in a or ) to reduce the amount of code that you need to write. It's a good practice to place definitions close to the class they work with. Because it needs to be statically accessed, add the for in a . In the file, add the implementation of the : In this case, you use a as an implementation detail to store and restore an instance of in the saver. Now, you can use this saver in (instead of ) in the method you created before: With this, the remembered state will survive process and activity recreations. You're going to use instead of and , but you don't want to just use it as an internal state in as there's no way for the caller composable to control the state. Instead, you want to hoist so that callers can control the state of . If you hoist the state, then the composable can be used in previews and be tested more easily since you're able to modify its state from the caller. To do this, you need to change the parameters of the composable function and give it a default value in case it is needed. Because you might want to allow with empty hints, add a default argument: You've probably noticed that the parameter is not there anymore! Since the state can be hoisted, if callers want to know if the input changed, they can control the state and pass that state into this function. Next, you need to tweak the function body to use the hoisted state instead of the internal state that was used before. After the refactoring, the function should look like this: Since you changed the API of , you need to check in all places where it's called to make sure you pass in the appropriate parameters. The only place in the project that you call this API is in the file. Open it and go to the composable function; you should see a build error there. As the hint is now part of the state holder, and you want a custom hint for this instance of in the Composition, you need to remember the state at the level and pass it into : The code above is missing functionality to notify 's caller when the input changes. Due to how the app is structured, you don't want to hoist the any higher up in the hierarchy. You wouldn't want to couple the other composables such as with this state. How can you call the lambda from and still keep this composable reusable? You can trigger a side-effect using every time the input changes and call the lambda: You've already used and before, but the code above also uses a new API! The API converts Compose objects into a Flow. When the state read inside mutates, the Flow will emit the new value to the collector. In this case, you convert the state into a flow to use the power of flow operators. With that, you when the is not the , and the emitted items to notify the parent that the current destination changed. There are no visual changes in this step of the codelab, but you've improved the quality of this part of the code. If you run the app now, you should see everything is working as it did previously.\n\nWhen you tap on a destination, the details screen opens and you can see where the city is on the map. That code is in the file. In the composable, you're calling the function. If you open this function, which is in the file, you'll see that it's not connected to any lifecycle! It just remembers a and calls on it: Even though the app runs fine, this is a problem because the is not following the correct lifecycle. Therefore, it won't know when the app is moved to the background, when the View should be paused, etc. Let's fix this! Note: If you don't see the map, check out the [Optional] Displaying the map on the details screen section of the Getting set up step. However, it's not necessary for this section to see the map on the screen. As the is a View and not a composable, you want it to follow the lifecycle of the Activity where it's used as well as the lifecycle of the Composition. That means you need to create a to listen for lifecycle events and call the right methods on the . Then, you need to add this observer to the current activity's lifecycle. Start by creating a function that returns a that calls the corresponding methods in a given a certain event: Now, you need to add this observer to the current lifecycle, which you can get using the current with the composition local. However, it's not enough to add the observer; you also need to be able to remove it! You need a side effect that tells you when the effect is leaving the Composition so that you can perform some cleanup code. The side-effect API you're looking for is . is meant for side effects that need to be cleaned up after the keys change or the composable leaves the Composition. The final code does exactly that. Implement the following lines in your project: The observer is added to the current , and it'll be removed whenever the current lifecycle changes or this composable leaves the Composition. With the s in , if either the or the change, the observer will be removed and added again to the right . With the changes you've just made, the will always follow the of the current and its behavior would be just as if it was used in the View world. Feel free to run the app and open the details screen to make sure that the still renders properly. There are no visual changes in this step. Note: This section explores how to define a to react to events from Compose. You also learned how to use API to safely dispose of resources to avoid memory leaks. The example used the view-based component . In a real Compose app, you can use the new Maps for Compose library which will handle lifecycle events for you.\n\nIn this section, you'll improve how the details screen starts. The composable in the file gets the synchronously from the ViewModel and calls if the result is successful. However, could evolve to be more costly to load on the UI thread and it could use coroutines to move the loading of the data to a different thread. You'll improve this code to add a loading screen and display the when the data is ready. One way to model the state of the screen is with the following class that covers all possibilities: data to display on the screen, and the loading and error signals. Add the class to the file: You could map what the screen needs to display and the in the ViewModel layer by using a stream of data, a of type , that the ViewModel updates when the information is ready and that Compose collects with the API that you already know about. However, for the sake of this exercise, you're going to implement an alternative. If you wanted to move the mapping logic to the Compose world, you could use the API. allows you to convert non-Compose state into Compose State. It launches a coroutine scoped to the Composition that can push values into the returned using the property. As with , also takes keys to cancel and restart the computation. For your use case, you can use to emit updates with an initial value of as follows: Next, depending on the , you show the data, show the loading screen, or report the error. Here's the complete code for the composable: If you run the app, you'll see how the loading spinner appears before showing the city details. Note: API uses API under the hood.\n\nThe last improvement you're going to make to Crane is showing a button to Scroll to top whenever you scroll in the flight destinations list after you pass the first element of the screen. Tapping the button takes you to the first element on the list. Open the file that contains this code. The composable corresponds to what you see in the backdrop of the scaffold. To calculate whether the user has passed the first item, use 's and check if . A naive implementation would look like the following: // DO NOT DO THIS - It's executed on every recomposition This solution is not as efficient as it could be, because the composable function reading recomposes as often as changes - which happens frequently when scrolling. Instead, you want the function to recompose only when the condition changes between and . There's an API that allows you to do this: the API. is an observable Compose . Your calculation, , also needs to be a Compose since you want the UI to recompose when its value changes, and show or hide the button. Use when you want a Compose that's derived from another . The calculation block is executed every time the internal state changes, but the composable function only recomposes when the result of the calculation is different from the last one. This minimizes the amount of times functions reading recompose. Using the API in this case is a better and more efficient alternative. You'll also wrap the call with the API, so the calculated value survives recomposition. // Show the button if the first visible item is past // the first item. We use a remembered derived state to The new code for the composable should be familiar to you already. You're using a to place the that is shown conditionally on top of . And you use to call the suspend function inside the 's callback. If you run the app, you'll see the button appearing at the bottom once you scroll and pass the first element of the screen. Note: To learn more about the API, see the When should I use derivedStateOf? blog post."
    },
    {
        "link": "https://stackoverflow.com/questions/73632301/difference-between-observeasstate-and-collectasstate-and-when-to-use-each-in-and",
        "document": "observeAsState is an extension on LiveData . Starts observing this LiveData and represents its values via State . Uses Lifecyle internally for safely observing the data.\n\nis an extension on .\n\n Collects values from this and represents its latest value via State.\n\n You need to handle the collection as per appropriate ."
    },
    {
        "link": "https://stackoverflow.com/questions/59096435/using-livedata-as-state-inside-jetpack-compose-functions",
        "document": "I want to use a to be the source of my state in a @Composable function.\n\nI cannot use the new @Model annotation, I have seen in this talk Link(at 32:06) it is possible to use LiveData, Flow, etc. by invoking the function .\n\nTo the problem: I cannot find the function used in the video (+observe()) or any other way to use LiveData as an origin. How can I use LiveData inside my @Compose function?"
    },
    {
        "link": "https://blog.sentry.io/getting-started-with-jetpack-compose",
        "document": "Recently, we wrote about the demonstrative move to declarative UI. With Jetpack Compose, Android is joining the declarative trends.\n\nJetpack Compose, a new declarative UI toolkit by Google made for building native Android apps, is rapidly gaining traction. In fact, as announced at the Android Dev Summit last year last year, 160 of the top 1,000 Android apps already use Jetpack Compose. In contrast to the traditional XML Views, Jetpack Compose allows you to build UIs using composable functions that describe how the UI should look and behave.\n\nThe main advantage of using Jetpack Compose is that it allows you to write UI code that is more concise and easier to understand. This leads to improved maintainability and reduced development time.\n\nThe main disadvantage of using Jetpack Compose is that it’s relatively new, so its ecosystem is limited and the number of available libraries, tools, and resources is lower than the traditional ecosystem.\n\nDespite that, we believe that learning Jetpack Compose is worth the learning curve and challenges. Here are some tips we've found helpful as you are getting started.\n\nHow to start using Jetpack Compose\n\nThe recommended IDE for working with Jetpack Compose is Android Studio. After downloading and installing Android Studio, you’ll get the option to create a new project. To create a new Jetpack Compose application, you need to select either the (which uses Material v2), or (which uses the Material v3 which is in version 1.0 as of last year). You can see both options in the top right of this screenshot:\n\n\n\nThis is the easiest way to get started with Jetpack Compose. If you’d like to enable Jetpack Compose into an existing Android application, here’s what you need to do:\n• None Add the following build configurations in your app’s file:\n• None Add the Compose BOM (Bill of Materials) and the subset of Compose dependencies to your dependencies:\n\nHow do you build UI in Jetpack Compose?\n\nJetpack Compose uses Composables to define the view hierarchy, and modifier to apply visual appearance and behavior changes to the composables they’re added to.\n\nComposable functions (or just Composables) are ordinary Kotlin functions that are annotated with , can be nested within another composable functions, and return a hierarchy of other composables in order to define their UI. Let’s see a simple composable that defines a contact row UI that contains a user photo, and a name and phone number:\n\nThe composable is a layout composable that renders its children one next to another. The composable is the first child which is going to render the drawable. Then we have the composable which, similar to the , is a layout composable, but it renders its children one below another. The children of the composable are two composables that render the user’s name and phone number.\n\nModifiers are used to change the visual appearance and behavior of the composables they’re added to. We use modifiers when we want to change UI elements such as the size of the composable (width, height), the padding, background, or alignment.\n\nModifiers can also be stacked on top of each other, allowing us to modify multiple visual properties. Here’s an example of how we can set the padding and max width of the Contact row from the previous snippet:\n\nHow do you interact with data in Jetpack Compose?\n\nThere are multiple ways to keep data within your Jetpack Compose app: MutableState, LiveData, and StateFlow.\n\nIn Jetpack Compose, state management can be accomplished by using the API to store an object in memory, and the to declare a state variable. We can store both mutable and immutable objects. The creates an observable , which is an observable type.\n\nAny changes to schedules a recomposition (re-rendering) of any composable functions that read it.\n\nThere are three ways to declare a object:\n\nLiveData is a data holder class that can be observed within a given lifecycle, meaning it respects the lifecycle of other app components, such as activities, fragments, or services. This ensures LiveData only updates observers that are in an active lifecycle state, which also ensures no memory leaks happen within your app.\n\nLet’s see an example of working with LiveData:\n• None You need to create an instance of the class to hold a certain type of data, which is usually done within your ViewModel class (use if you’d like to update the value at some point):\n• None Obtain the value in your composable by calling the method:\n• None To update 's value (also usually done in the view model), create a function that sets the new value to its property:\n• None You’d use the new function in your Compose file as .\n\nStateFlow is a newer alternative to LiveData. Both have similarities, and both are observable. Here’s how you can work with StateFlow in Jetpack Compose:\n• None Create an instance of to hold a certain type of data (use MutableStateFlow if you’d like to update the value at some point)\n• None Obtain the value in your composable by calling the method:\n• None To update 's value (also usually done in the view model), create a function that sets the new value to its property:\n• None You’d use the new function in your Compose file as .\n\nWhat are the best practices for Jetpack Compose?\n\nAside from the official best practices documentation, we’ve got a few additional tips that would make your codebase safer and easier to work in.\n\nEvery developer or organization has their own opinions on how a project should be structured. There is no “right” or “wrong” way to do it. Okay, maybe it’s wrong to put every file in one single directory 😅. Here’s an example structure to help you get started, which you can modify and evolve as your project grows:\n\n“God” files are a big no-no. They’re files that contain all code associated with them: UI, domain, business logic, utility functions etc… It might be easier putting everything into one file, but maintaining that would get harder and harder as you add functionalities. The solution to this is using a proper architecture in your Jetpack Compose app.\n\nThere are multiple architectures that you can use, all with their own pros and cons. The most common one in Jetpack Compose is MVVM, abbreviated from Model-View-ViewModel, because Jetpack Compose has a first-class implementation.\n\nAs you saw from the previous examples, Jetpack Compose has a first-class implementation. The MVVM, or Model-View-ViewModel, is a software design pattern that is structured to separate business logic from the UI. That means, your UI should not handle state updates, but it should let the view model do that by sending it user actions.\n\nLet’s explore that with an example. Remember the example from before? That example was oversimplified on purpose, but in a real-world project you would never expose a from your , but just a . In order to make that work, you should define a private variable and a public variable that returns the mutable flow by invoking the method.\n\nWith this simple change, we’re preventing the UI from being able to change the state. But, how do we actually change the state? We’ll expose a function from the view model that does that!\n\nSo now the UI has an immutable that it can observe, and a function to update its value. The business logic lives inside of the view model, while the Composable is only responsible to react to state changes and send user actions to the view model.\n\nSo you’ve learned how to create state flows. Great! Would you repeat the same for every state variable you need in your UI? Please don’t 😅 To avoid that, you can create a that keeps all of the values of your state, and create a single flow that uses it.\n\nLet’s learn this with an example. If we wanted to also keep the user’s phone number, email and address, we can create a data class called that contains all those values:\n\nThen we would refactor our view model to use the new instead of a :\n\nAnd then we can use all of the values in our composable by . If we also wanted to be able to update all those values, we would create functions for each of them in our view model:\n\nKeep a close eye on your errors and performance in production\n\nAs you're getting acclimated to Jetpack Compose, an error and performance monitoring tool can be really helpful to reduce your learning curve and ensure that your app is bug-free. Jetpack Compose does a lot of heavy lifting for developers – as a declarative toolkit, developers need to write less code to describe their UI, and Jetpack Compose takes care of the rest. But it does abstract away a lot of code, making it difficult to identify errors.\n\nSentry offers an out-of-the-box integration that can help you build a better Jetpack Compose app. The integration gives precise context to reduce troubleshooting time with transactions and breadcrumbs. Keep an eye on all the issues and crashes your app is experiencing in production, with a lot of context as to why the issue happened, the exact line of code that triggered it, and all sorts of hardware and software info of the device it ran.\n\n\n\nI’d totally understand if you’re feeling overwhelmed by now, but let’s do a quick recap! We’ve learned how to create a new Jetpack Compose project, and that Jetpack Compose uses Composables and Modifiers to define the view hierarchy and apply visual changes. Data in Jetpack Compose can be handled either with a , , or , which make the composables that observe it re-render when the value changes, making our UI dynamic. We also learned how to keep our projects tidy, and how to write maintainable composables and view models.\n\nEven though it’s a relatively new technology, Jetpack Compose’s ecosystem is steadily growing, so we can expect to see a lot of libraries pop up that make it easier to create Jetpack Compose apps. With companies like Lyft, Twitter, Airbnb, Square, Reddit, and Firefox putting their trust into it, more and more developers will follow along and create apps, libraries and resources for Jetpack Compose."
    },
    {
        "link": "https://medium.com/@anandgaur2207/jetpack-compose-chapter-4-state-management-and-livedata-12d186accecc",
        "document": "Jetpack Compose is a modern UI toolkit designed to simplify Android UI development. One of the key components of building dynamic UIs is managing the state of your application. In Compose, state management is fundamental, as it allows your UI to react to changes in the underlying data.\n\nState management is a critical concept in Jetpack Compose, as it directly impacts how your UI reacts to changes in data. Effective state management ensures that your app remains interactive and responsive while maintaining performance.\n\nThis blog will cover key concepts like state, recomposition, state hoisting, ViewModel integration, handling UI events, and observing LiveData and Flow in Jetpack Compose.\n\n1. What is State in Jetpack Compose?\n\nIn Jetpack Compose, state refers to any data that controls what is displayed on the screen. As the state changes, Compose automatically updates the UI to reflect the new data. State is what makes your app interactive and responsive to user input, network updates, or any other dynamic changes.\n\nFor example, if you have a counter app, the count value is the state. When the user clicks a button to increase the count, the UI needs to update the displayed count.\n\nHere’s a basic example of state in Jetpack Compose using the function:\n\nIn this example:\n• The is the state.\n• The composable reflects the value of .\n• The updates the state when clicked, causing the UI to recompose and show the new count.\n\nThere are different ways to manage state in Jetpack Compose, and one of the most common methods is using the ViewModel architecture, which helps separate the UI from business logic.\n\nViewModels allow state to survive configuration changes like screen rotations. Compose works seamlessly with the Android ViewModel.\n\nHere’s how you can manage state with ViewModel:\n\nIn this example:\n• The UI observes the state from the ViewModel using delegation.\n\nLiveData is an observable data holder class that’s lifecycle-aware, meaning it only updates UI components that are in an active lifecycle state. LiveData works well with traditional Android UI components and is often used in conjunction with ViewModel.\n\nJetpack Compose can also observe LiveData and update the UI automatically when the data changes.\n\nTo use LiveData in Jetpack Compose, you can observe the LiveData using the function. Here’s an example:\n\nIn this example:\n• uses to store the count state.\n• The UI observes the LiveData using , and whenever the LiveData changes, the UI updates automatically.\n• MutableState: Works directly within Jetpack Compose to manage state locally within the Composable functions. It’s lightweight and suited for UI-related state management that doesn’t need to survive configuration changes.\n• LiveData: Lifecycle-aware and can survive configuration changes. LiveData is useful when working with traditional Android components or ViewModels that are shared across multiple screens or fragments.\n\nState hoisting refers to moving the state from one composable function to a parent composable to allow the parent to manage it. This practice improves reusability and makes it easier to manage complex UI.\n\nIn this example:\n• is a stateless composable that displays the count and allows interaction via the callback.\n\nIn Jetpack Compose, state represents any data that determines how the UI should look. Whenever the state changes, the relevant parts of the UI are recomposed to reflect these updates. This makes state management essential in handling dynamic content like text fields, lists, or animations.\n\nState hoisting is a pattern in Compose where the state is “hoisted” or moved up to a parent composable so that it can be shared between different parts of the UI. This practice improves the reusability and modularity of composables.\n\nIn this example, the composable manages the state, while is responsible for rendering the UI.\n\nJetpack’s ViewModel is widely used for managing UI-related data in Android apps. It separates the business logic from the UI, ensuring that data survives configuration changes like screen rotations. ViewModel can be easily integrated into Compose.\n\nYou can directly use inside composables to access the ViewModel:\n\nHere, the holds the state, and Compose observes this state. The UI updates whenever the changes.\n\nSince ViewModel holds data that survives configuration changes, you can share the state across multiple composables easily. This allows the data to be consistent across the app and reduces redundant state handling.\n\nCompose provides a flexible way to handle UI events, such as button clicks, gestures, and user inputs. Here’s how you can manage these events:\n\nYou can handle button clicks by passing lambdas as callbacks to composables.\n\nEach time the button is clicked, the state is incremented, and the UI is recomposed to display the updated count.\n\nIn addition to click events, Compose supports gestures like swiping and dragging using modifiers like or .\n\nThis creates a draggable box where the position updates as you drag it horizontally.\n\nYou can use to handle simple touch events for UI components that aren't buttons.\n\nIn this example, the box changes color each time it’s clicked.\n\nCompose also supports reactive programming paradigms, making it easy to observe or objects and automatically update the UI when the data changes.\n\nTo observe LiveData in Compose, use the extension function. This makes it possible for your composables to react to LiveData changes.\n\nYou can also observe objects in Compose by collecting them inside composables using the function.\n\nIn this example, is used to emit continuous data streams, and Compose observes it with .\n\nState management in Jetpack Compose is flexible and powerful. It allows developers to efficiently handle dynamic UIs, from simple state changes to more complex interactions using and . Whether you’re managing local state within a single composable or sharing state across multiple screens with ViewModel, Compose provides the tools needed to create responsive, high-performance apps.\n\nState management is crucial in Jetpack Compose to create dynamic, interactive, and responsive UIs. While Jetpack Compose’s works well for local UI state, integrating LiveData with Compose can be beneficial when managing state across multiple screens or surviving configuration changes. Whether using Compose’s own state system or integrating it with ViewModel and LiveData, managing state efficiently ensures that your app performs well and delivers a smooth user experience."
    },
    {
        "link": "https://developer.android.com/develop/ui/compose/state",
        "document": "State in an app is any value that can change over time. This is a very broad definition and encompasses everything from a Room database to a variable in a class.\n\nAll Android apps display state to the user. A few examples of state in Android apps:\n• A Snackbar that shows when a network connection can't be established.\n• Ripple animations on buttons that play when a user clicks them.\n• Stickers that a user can draw on top of an image.\n\nJetpack Compose helps you be explicit about where and how you store and use state in an Android app. This guide focuses on the connection between state and composables, and on the APIs that Jetpack Compose offers to work with state more easily.\n\nCompose is declarative and as such the only way to update it is by calling the same composable with new arguments. These arguments are representations of the UI state. Any time a state is updated a recomposition takes place. As a result, things like don’t automatically update like they do in imperative XML based views. A composable has to explicitly be told the new state in order for it to update accordingly.\n\nIf you run this and try to enter text, you'll see that nothing happens. That's because the doesn't update itself—it updates when its parameter changes. This is due to how composition and recomposition work in Compose.\n\nTo learn more about initial composition and recomposition, see Thinking in Compose.\n\nComposable functions can use the API to store an object in memory. A value computed by is stored in the Composition during initial composition, and the stored value is returned during recomposition. can be used to store both mutable and immutable objects.\n\ncreates an observable , which is an observable type integrated with the compose runtime.\n\nAny changes to schedules recomposition of any composable functions that read .\n\nThere are three ways to declare a object in a composable:\n\nThese declarations are equivalent, and are provided as syntax sugar for different uses of state. You should pick the one that produces the easiest-to-read code in the composable you're writing.\n\nThe delegate syntax requires the following imports:\n\nYou can use the remembered value as a parameter for other composables or even as logic in statements to change which composables are displayed. For example, if you don't want to display the greeting if the name is empty, use the state in an statement:\n\nWhile helps you retain state across recompositions, the state is not retained across configuration changes. For this, you must use . automatically saves any value that can be saved in a . For other values, you can pass in a custom saver object.\n\nCompose doesn't require that you use to hold state; it supports other observable types. Before reading another observable type in Compose, you must convert it to a so that composables can automatically recompose when the state changes.\n\nCompose ships with functions to create from common observable types used in Android apps. Before using these integrations, add the appropriate artifact(s) as outlined below:\n• collects values from a in a lifecycle-aware manner, allowing your app to conserve app resources. It represents the latest emitted value from the Compose . Use this API as the recommended way to collect flows on Android apps. Note: API , you can read To learn more about collecting flows safely in Android withAPI , you can read this blog post The following dependency is required in the file (it should be 2.6.0-beta01 or newer):\n• is similar to , because it also collects values from a and transforms it into Compose . Use for platform-agnostic code instead of , which is Android-only. Additional dependencies are not required for , because it is available in .\n• starts observing this and represents its values via . The following dependency is required in the file:\n• are extension functions that transform RxJava2’s reactive streams (e.g. , , ) into Compose . The following dependency is required in the file:\n• are extension functions that transform RxJava3’s reactive streams (e.g. , , ) into Compose . The following dependency is required in the file:\n\nA composable that uses to store an object creates internal state, making the composable stateful. is an example of a stateful composable because it holds and modifies its state internally. This can be useful in situations where a caller doesn't need to control the state and can use it without having to manage the state themselves. However, composables with internal state tend to be less reusable and harder to test.\n\nA stateless composable is a composable that doesn't hold any state. An easy way to achieve stateless is by using state hoisting.\n\nAs you develop reusable composables, you often want to expose both a stateful and a stateless version of the same composable. The stateful version is convenient for callers that don't care about the state, and the stateless version is necessary for callers that need to control or hoist the state.\n\nState hoisting in Compose is a pattern of moving state to a composable's caller to make a composable stateless. The general pattern for state hoisting in Jetpack Compose is to replace the state variable with two parameters:\n• : the current value to display\n• : an event that requests the value to change, where is the proposed new value\n\nHowever, you are not limited to . If more specific events are appropriate for the composable, you should define them using lambdas.\n\nState that is hoisted this way has some important properties:\n• Single source of truth: By moving state instead of duplicating it, we're ensuring there's only one source of truth. This helps avoid bugs.\n• Encapsulated: Only stateful composables can modify their state. It's completely internal.\n• Shareable: Hoisted state can be shared with multiple composables. If you wanted to read in a different composable, hoisting would allow you to do that.\n• Interceptable: callers to the stateless composables can decide to ignore or modify events before changing the state.\n• Decoupled: the state for the stateless composables may be stored anywhere. For example, it's now possible to move into a .\n\nIn the example case, you extract the and the out of and move them up the tree to a composable that calls .\n\nBy hoisting the state out of , it's easier to reason about the composable, reuse it in different situations, and test. is decoupled from how its state is stored. Decoupling means that if you modify or replace , you don't have to change how is implemented.\n\nThe pattern where the state goes down, and events go up is called a unidirectional data flow. In this case, the state goes down from to and events go up from to . By following unidirectional data flow, you can decouple composables that display state in the UI from the parts of your app that store and change state.\n\nSee the Where to hoist state page to learn more.\n\nThe API behaves similarly to because it retains state across recompositions, and also across activity or process recreation using the saved instance state mechanism. For example, this happens, when the screen is rotated.\n\nAll data types that are added to the are saved automatically. If you want to save something that cannot be added to the , there are several options.\n\nThe simplest solution is to add the annotation to the object. The object becomes parcelable, and can be bundled. For example, this code makes a parcelable data type and saves it to the state.\n\nIf for some reason is not suitable, you can use to define your own rule for converting an object into a set of values that the system can save to the .\n\nTo avoid needing to define the keys for the map, you can also use and use its indices as keys:\n\nSimple state hoisting can be managed in the composable functions itself. However, if the amount of state to keep track of increases, or the logic to perform in composable functions arises, it's a good practice to delegate the logic and state responsibilities to other classes: state holders.\n\nSee the state hoisting in Compose documentation or, more generally, the State holders and UI State page in the architecture guide to learn more.\n\nThe API is frequently used together with :\n\nHere, using the function makes the value survive recompositions.\n\nIn general, takes a lambda parameter. When is first run, it invokes the lambda and stores its result. During recomposition, returns the value that was last stored.\n\nApart from caching state, you can also use to store any object or result of an operation in the Composition that is expensive to initialize or calculate. You might not want to repeat this calculation in every recomposition. An example is creating this object, which is an expensive operation:\n\nstores the value until it leaves the Composition. However, there is a way to invalidate the cached value. The API also takes a or parameter. If any of these keys change, the next time the function recomposes, invalidates the cache and executes the calculation lambda block again. This mechanism gives you control over the lifetime of an object in the Composition. The calculation remains valid until the inputs change, instead of until the remembered value leaves the Composition.\n\nThe following examples show how this mechanism works.\n\nIn this snippet, a is created and used as the background paint of a composable. stores the instance because it is expensive to recreate, as explained earlier. takes as the parameter, which is the selected background image. If changes, the brush recomposes with the new image, and reapplies to the . This can occur when the user selects another image to be the background from a picker.\n\nIn the next snippet, state is hoisted to a plain state holder class . It exposes a function to initialize an instance of the class using . Exposing such functions to create an instance that survives recompositions is a common pattern in Compose. The function receives , which serves as the parameter for . If this parameter changes, the app needs to recreate the plain state holder class with the latest value. This may occur if, for example, the user rotates the device.\n\nCompose uses the class's equals implementation to decide if a key has changed and invalidate the stored value.\n\nThe API is a wrapper around that can store data in a . This API allows state to survive not only recomposition, but also activity recreation and system-initiated process death. receives parameters for the same purpose that receives . The cache is invalidated when any of the inputs change. The next time the function recomposes, re-executes the calculation lambda block.\n\nIn the following example, stores until changes:\n\nTo learn more about state and Jetpack Compose, consult the following additional resources."
    },
    {
        "link": "https://stackoverflow.com/questions/77002166/what-are-the-differences-between-mutablestateof-and-livedataviewmodel",
        "document": "First off, there's no reason to pair LiveData with ViewModel. ViewModel can be used with anything: LiveData, MutableState, StateFlow, etc.\n\nState/MutableState is designed specifically for Compose. When its changes, it automatically triggers recomposition. Since it is designed specifically for Compose, it is not very useful for non-Compose applications. There's no simple way to observe it for changes without Compose.\n\nLiveData is more general-purpose and was not designed with Compose in mind. To use it properly in Compose, you have to convert it to State by using so that it will trigger recompositions when its changes.\n\nViewModel is a class whose primary purpose is to hold data in memory for an Activity when that Activity is destroyed and recreated due to configuration changes. This is a feature that can also be achieved in pure Compose by using . But ViewModel can be used outside Composables and is more general purpose. You could design a ViewModel that doesn't use State, and it would be useful in Activities both with and without Compose.\n\nThe name \"ViewModel\" suggests the ViewModel of the MVVM architecture pattern, but you don't necessarily have to use it that way (the Google authors have stated they did not intend to imply that's how it should be used). But if you do, it would be used as the intermediate layer between your UI and your data sources/repositories and should probably avoid UI-opinionated types like State/MutableState."
    },
    {
        "link": "https://medium.com/@dugguRK/understand-livedata-and-mutablelivedata-6daa62fda4ed",
        "document": "LiveData is a part of the Android Jetpack suite of libraries. It represents data that is observable and lifecycle-aware. Being lifecycle-aware means LiveData respects the lifecycle of app components such as Activities, Fragments, and Services, ensuring that these components only receive updates when they’re in an active state.\n• Eliminates Manual Lifecycle Management: No need to manually stop or resume updates based on lifecycle changes.\n• Ensures Your UI Matches Your Data State: LiveData notifies the observer objects when the lifecycle state changes, so you can update the UI to reflect changes instantly.\n• Reduces Memory Leaks: Observers are bound to lifecycle objects and get cleaned up when their lifecycle is destroyed.\n• No More Crashes Due to Stopped Activities: LiveData doesn’t push updates to observers that aren’t in an active state.\n\nMutableLiveData is a subclass of LiveData. It has public methods that allow you to modify the value stored in it. Specifically, you can use for main thread operations or for background thread operations.\n\nWhy We Need LiveData and MutableLiveData:\n• Data Consistency: LiveData ensures that the UI always displays the latest data.\n• Lifecycle-awareness: LiveData automatically manages subscription and unsubscription based on lifecycle states, eliminating common bugs due to lifecycle issues.\n• Data Modification: There are cases when the data source needs to be modified. For example, when you fetch data from a database or network and want to update your UI, MutableLiveData allows for that modification.\n\nExample of Integration LiveData and MutableLiveData:\n• LiveData: It’s a read-only version. You can’t alter its content directly from where it’s being observed.\n• MutableLiveData: It’s mutable, meaning you can change its content. It exposes and for this purpose.\n\nWhich is best and when: LiveData or MutableLiveData?\n\nBoth LiveData and MutableLiveData have their use cases:\n• LiveData: Best for situations where data should be observable but not modifiable by the observer. You typically use LiveData in the UI layer to observe changes.\n• MutableLiveData: Best for situations where data is expected to change, such as in your ViewModel or data layer. This allows you to encapsulate the data and expose only LiveData to the UI, ensuring the UI can’t make unexpected changes.\n• ViewModel contains MutableLiveData because it can modify data based on user actions or network responses.\n• View (Activity or Fragment) observes LiveData to reflect changes in the UI, ensuring data is only read and not modified.\n\nBy adhering to this separation, you maintain a clean architecture where responsibilities are clearly defined.\n\nPerhaps my article will offer some clarity. If you find it valuable, please consider following and applauding. Your support will inspire me to write more articles like this."
    },
    {
        "link": "https://developer.android.com/topic/libraries/architecture/livedata",
        "document": "Save and categorize content based on your preferences.\n\nis an observable data holder class. Unlike a regular observable, LiveData is lifecycle-aware, meaning it respects the lifecycle of other app components, such as activities, fragments, or services. This awareness ensures LiveData only updates app component observers that are in an active lifecycle state.\n\nLiveData considers an observer, which is represented by the class, to be in an active state if its lifecycle is in the or state. LiveData only notifies active observers about updates. Inactive observers registered to watch objects aren't notified about changes.\n\nYou can register an observer paired with an object that implements the interface. This relationship allows the observer to be removed when the state of the corresponding object changes to . This is especially useful for activities and fragments because they can safely observe objects and not worry about leaks—activities and fragments are instantly unsubscribed when their lifecycles are destroyed.\n\nFor more information about how to use LiveData, see Work with LiveData objects.\n\nThe advantages of using LiveData\n\nUsing LiveData provides the following advantages:\n\nFollow these steps to work with objects:\n• Create an instance of to hold a certain type of data. This is usually done within your class.\n• Create an object that defines the method, which controls what happens when the object's held data changes. You usually create an object in a UI controller, such as an activity or fragment.\n• None Attach the object to the object using the method. The method takes a object. This subscribes the object to the object so that it is notified of changes. You usually attach the object in a UI controller, such as an activity or fragment. Note: You can register an observer without an associated object using the method. In this case, the observer is considered to be always active and is therefore always notified about modifications. You can remove these observers calling the method.\n\nWhen you update the value stored in the object, it triggers all registered observers as long as the attached is in the active state.\n\nLiveData allows UI controller observers to subscribe to updates. When the data held by the object changes, the UI automatically updates in response.\n\nLiveData is a wrapper that can be used with any data, including objects that implement , such as . A object is usually stored within a object and is accessed via a getter method, as demonstrated in the following example:\n\nInitially, the data in a object is not set.\n\nYou can read more about the benefits and usage of the class in the ViewModel guide.\n\nIn most cases, an app component’s method is the right place to begin observing a object for the following reasons:\n• To ensure the system doesn’t make redundant calls from an activity or fragment’s method.\n• To ensure that the activity or fragment has data that it can display as soon as it becomes active. As soon as an app component is in the state, it receives the most recent value from the objects it’s observing. This only occurs if the object to be observed has been set.\n\nGenerally, LiveData delivers updates only when data changes, and only to active observers. An exception to this behavior is that observers also receive an update when they change from an inactive to an active state. Furthermore, if the observer changes from inactive to active a second time, it only receives an update if the value has changed since the last time it became active.\n\nThe following sample code illustrates how to start observing a object:\n\nAfter is called with passed as parameter, is immediately invoked providing the most recent value stored in . If the object hasn't set a value in , is not called.\n\nLiveData has no publicly available methods to update the stored data. The class exposes the and methods publicly and you must use these if you need to edit the value stored in a object. Usually is used in the and then the only exposes immutable objects to the observers.\n\nAfter you have set up the observer relationship, you can then update the value of the object, as illustrated by the following example, which triggers all observers when the user taps a button:\n\nCalling in the example results in the observers calling their methods with the value . The example shows a button press, but or could be called to update for a variety of reasons, including in response to a network request or a database load completing; in all cases, the call to or triggers observers and updates the UI.\n\nThe Room persistence library supports observable queries, which return objects. Observable queries are written as part of a Database Access Object (DAO).\n\nRoom generates all the necessary code to update the object when a database is updated. The generated code runs the query asynchronously on a background thread when needed. This pattern is useful for keeping the data displayed in a UI in sync with the data stored in a database. You can read more about Room and DAOs in the Room persistent library guide.\n\nincludes support for Kotlin coroutines. For more information, see Use Kotlin coroutines with Android Architecture Components.\n\nis lifecycle-aware, following the lifecycle of entities such as activities and fragments. Use to communicate between these lifecycle owners and other objects with a different lifespan, such as objects. The main responsibility of the is to load and manage UI-related data, which makes it a great candidate for holding objects. Create objects in the and use them to expose state to the UI layer.\n\nActivities and fragments should not hold instances because their role is to display data, not hold state. Also, keeping activities and fragments free from holding data makes it easier to write unit tests.\n\nIt may be tempting to work objects in your data layer class, but is not designed to handle asynchronous streams of data. Even though you can use transformations and to achieve this, this approach has drawbacks: the capability to combine streams of data is very limited and all objects (including ones created through transformations) are observed on the main thread. The code below is an example of how holding a in the can block the main thread:\n\nIf you need to use streams of data in other layers of your app, consider using Kotlin Flows and then converting them to in the using . Learn more about using Kotlin with in this codelab. For codebases built with Java, consider using Executors in conjunction with callbacks or .\n\nLiveData considers an observer to be in an active state if the observer's lifecycle is in either the or states. The following sample code illustrates how to extend the class:\n\nThe implementation of the price listener in this example includes the following important methods:\n• The method is called when the object has an active observer. This means you need to start observing the stock price updates from this method.\n• The method is called when the object doesn't have any active observers. Since no observers are listening, there is no reason to stay connected to the service.\n• The method updates the value of the instance and notifies any active observers about the change.\n\nYou can use the class as follows:\n\nThe method passes the associated with the fragment's view as the first argument. Doing so denotes that this observer is bound to the object associated with the owner, meaning:\n• If the object is not in an active state, then the observer isn't called even if the value changes.\n• After the object is destroyed, the observer is automatically removed.\n\nThe fact that objects are lifecycle-aware means that you can share them between multiple activities, fragments, and services. To keep the example simple, you can implement the class as a singleton as follows:\n\nAnd you can use it in the fragment as follows:\n\nMultiple fragments and activities can observe the instance. LiveData only connects to the system service if one or more of them is visible and active.\n\nYou may want to make changes to the value stored in a object before dispatching it to the observers, or you may need to return a different instance based on the value of another one. The package provides the class which includes helper methods that support these scenarios.\n\nYou can use transformation methods to carry information across the observer's lifecycle. The transformations aren't calculated unless an observer is watching the returned object. Because the transformations are calculated lazily, lifecycle-related behavior is implicitly passed down without requiring additional explicit calls or dependencies.\n\nIf you think you need a object inside a object, a transformation is probably a better solution. For example, assume that you have a UI component that accepts an address and returns the postal code for that address. You can implement the naive for this component as illustrated by the following sample code:\n\nThe UI component then needs to unregister from the previous object and register to the new instance each time it calls . In addition, if the UI component is recreated, it triggers another call to the method instead of using the previous call’s result.\n\nInstead, you can implement the postal code lookup as a transformation of the address input, as shown in the following example:\n\nIn this case, the field is defined as a transformation of the . As long as your app has an active observer associated with the field, the field's value is recalculated and retrieved whenever changes.\n\nThis mechanism allows lower levels of the app to create objects that are lazily calculated on demand. A object can easily obtain references to objects and then define transformation rules on top of them.\n\nThere are a dozen different specific transformation that may be useful in your app, but they aren’t provided by default. To implement your own transformation you can you use the class, which listens to other objects and processes events emitted by them. correctly propagates its state to the source object. To learn more about this pattern, see the reference documentation of the class.\n\nis a subclass of that allows you to merge multiple LiveData sources. Observers of objects are then triggered whenever any of the original LiveData source objects change.\n\nFor example, if you have a object in your UI that can be updated from a local database or a network, then you can add the following sources to the object:\n• A object associated with the data stored in the database.\n• A object associated with the data accessed from the network.\n\nYour activity only needs to observe the object to receive updates from both sources. For a detailed example, see the Addendum: exposing network status section of the Guide to App Architecture.\n\nTo learn more about the class, consult the following resources.\n• LiveData beyond the ViewModel — Reactive patterns using Transformations and MediatorLiveData\n• LiveData with SnackBar, Navigation and other events (the SingleLiveEvent case)"
    }
]