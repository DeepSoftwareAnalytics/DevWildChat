[
    {
        "link": "https://chegg.com/homework-help/questions-and-answers/output-first-round-des-algorithm-plaintext-key-zeroes-remember-desirable-good-block-cipher-q21982675",
        "document": "What is the output of the first round of the DES algorithm when the plaintext and the key are both all zeroes? Remember that it is desirable for good block ciphers that a change in one input bit affects many output bits, a property that is called diffusion or the avalanche effect. We try now to get a feeling for the avalanche property of DES. We apply an input word that has a \"1\" at bit position 57 and all other bits as well as the key are zero. (Note that the input word has to run through the initial permutation.) a. How many S-boxes get different inputs compared to the case when an all-zero plaintext is provided? b. What is the minimum number of output bits of the S-boxes that will change according to the S-box design criteria? c. What is the output after the first round? d. How many output bit after the first round have actually changed compared to the case when the plaintext is all zero? (Observe that we only consider a single round here. There will be more and more output differences after every new round. Hence the term avalanche effect.) Assume we perform a known plaintext attack against DES with one pair of plaintext and ciphertext. How many keys do we have to test in a worst-case scenario if we apply an exhaustive key search in a straightforward way? How many on average? b. One important property which makes DES secure is that the S-boxes are nonlinear. In this problem we verify this property by computing the output of S_1 for the input pairs x_1 = 111111 and x_2 = 000001."
    },
    {
        "link": "https://geeksforgeeks.org/data-encryption-standard-des-set-1",
        "document": "This article talks about the Data Encryption Standard (DES), a historic encryption algorithm known for its 56-bit key length. We explore its operation, key transformation, and encryption process, shedding light on its role in data security and its vulnerabilities in today’s context.\n\nData Encryption Standard (DES) is a block cipher with a 56-bit key length that has played a significant role in data security. Data encryption standard (DES) has been found vulnerable to very powerful attacks therefore, the popularity of DES has been found slightly on the decline. DES is a block cipher and encrypts data in blocks of size of 64 bits each, which means 64 bits of plain text go as the input to DES, which produces 64 bits of ciphertext. The same algorithm and key are used for encryption and decryption, with minor differences. The key length is 56 bits.\n\nThe basic idea is shown below:\n\nWe have mentioned that DES uses a 56-bit key. Actually, The initial key consists of 64 bits. However, before the DES process even starts, every 8th bit of the key is discarded to produce a 56-bit key. That is bit positions 8, 16, 24, 32, 40, 48, 56, and 64 are discarded.\n\nThus, the discarding of every 8th bit of the key produces a 56-bit key from the original 64-bit key.\n\nDES is based on the two fundamental attributes of cryptography: substitution (also called confusion) and transposition (also called diffusion). DES consists of 16 steps, each of which is called a round. Each round performs the steps of substitution and transposition. Let us now discuss the broad-level steps in DES.\n• None In the first step, the 64-bit plain text block is handed over to an initial\n• None The initial permutation is performed on plain text.\n• None Next, the initial permutation (IP) produces two halves of the permuted block; saying Left Plain Text (LPT) and Right Plain Text (RPT).\n• None Now each LPT and RPT go through 16 rounds of the encryption process.\n• None In the end, LPT and RPT are rejoined and a Final Permutation (FP) is performed on the combined block\n• None The result of this process produces 64-bit ciphertext.\n\nAs we have noted, the initial permutation (IP) happens only once and it happens before the first round. It suggests how the transposition in IP should proceed, as shown in the figure. For example, it says that the IP replaces the first bit of the original plain text block with the 58th bit of the original plain text, the second bit with the 50th bit of the original plain text block, and so on.\n\nThis is nothing but jugglery of bit positions of the original plain text block. the same rule applies to all the other bit positions shown in the figure.\n\nAs we have noted after IP is done, the resulting 64-bit permuted text block is divided into two half blocks. Each half-block consists of 32 bits, and each of the 16 rounds, in turn, consists of the broad-level steps outlined in the figure.\n\nWe have noted initial 64-bit key is transformed into a 56-bit key by discarding every 8th bit of the initial key. Thus, for each a 56-bit key is available. From this 56-bit key, a different 48-bit Sub Key is generated during each round using a process called key transformation. For this, the 56-bit key is divided into two halves, each of 28 bits. These halves are circularly shifted left by one or two positions, depending on the round.\n\nFor example: if the round numbers 1, 2, 9, or 16 the shift is done by only one position for other rounds, the circular shift is done by two positions. The number of key bits shifted per round is shown in the figure.\n\nAfter an appropriate shift, 48 of the 56 bits are selected. From the 48 we might obtain 64 or 56 bits based on requirement which helps us to recognize that this model is very versatile and can handle any range of requirements needed or provided. for selecting 48 of the 56 bits the table is shown in the figure given below. For instance, after the shift, bit number 14 moves to the first position, bit number 17 moves to the second position, and so on. If we observe the table , we will realize that it contains only 48-bit positions. Bit number 18 is discarded (we will not find it in the table), like 7 others, to reduce a 56-bit key to a 48-bit key. Since the key transformation process involves permutation as well as a selection of a 48-bit subset of the original 56-bit key it is called Compression Permutation.\n\nBecause of this compression permutation technique, a different subset of key bits is used in each round. That makes DES not easy to crack.\n\nRecall that after the initial permutation, we had two 32-bit plain text areas called Left Plain Text(LPT) and Right Plain Text(RPT). During the expansion permutation, the RPT is expanded from 32 bits to 48 bits. Bits are permuted as well hence called expansion permutation. This happens as the 32-bit RPT is divided into 8 blocks, with each block consisting of 4 bits. Then, each 4-bit block of the previous step is then expanded to a corresponding 6-bit block, i.e., per 4-bit block, 2 more bits are added.\n\nThis process results in expansion as well as a permutation of the input bit while creating output. The key transformation process compresses the 56-bit key to 48 bits. Then the expansion permutation process expands the 32-bit RPT to 48-bits. Now the 48-bit key is XOR with 48-bit RPT and the resulting output is given to the next step, which is the S-Box substitution.\n\nIn conclusion, the Data Encryption Standard (DES) is a block cipher with a 56-bit key length that has played a significant role in data security. However, due to vulnerabilities, its popularity has declined. DES operates through a series of rounds involving key transformation, expansion permutation, and substitution, ultimately producing ciphertext from plaintext. While DES has historical significance, it’s crucial to consider more secure encryption alternatives for modern data protection needs.\n\nQ.1 What should be considered as an alternative to DES for data encryption?\n\nQ.2 How is the 48-bit subkey generated for each round in DES?"
    },
    {
        "link": "https://chegg.com/homework-help/questions-and-answers/output-first-round-des-algorithm-plaintext-key-zeros-need-step-step-solution-clear-answer-q104345887",
        "document": "What is the output of the first round of the DES algorithm when the plaintext and the key are both all zeros?\n\nI need step by step solution and clear answer!"
    },
    {
        "link": "https://page.math.tu-berlin.de/~kant/teaching/hess/krypto-ws2006/des.htm",
        "document": "The DES (Data Encryption Standard) algorithm is the most widely used encryption algorithm in the world. For many years, and among many people, \"secret code making\" and DES have been synonymous. And despite the recent coup by the Electronic Frontier Foundation in creating a $220,000 machine to crack DES-encrypted messages, DES will live on in government and banking for years to come through a life- extending version called \"triple-DES.\" How does DES work? This article explains the various steps involved in DES-encryption, illustrating each step by means of a simple example. Since the creation of DES, many other algorithms (recipes for changing data) have emerged which are based on design principles similar to DES. Once you understand the basic transformations that take place in DES, you will find it easy to follow the steps involved in these more recent algorithms. But first a bit of history of how DES came about is appropriate, as well as a look toward the future. The National Bureau of Standards Coaxes the Genie from the Bottle On May 15, 1973, during the reign of Richard Nixon, the National Bureau of Standards (NBS) published a notice in the Federal Register soliciting proposals for cryptographic algorithms to protect data during transmission and storage. The notice explained why encryption was an important issue. Over the last decade, there has been an accelerating increase in the accumulations and communication of digital data by government, industry and by other organizations in the private sector. The contents of these communicated and stored data often have very significant value and/or sensitivity. It is now common to find data transmissions which constitute funds transfers of several million dollars, purchase or sale of securities, warrants for arrests or arrest and conviction records being communicated between law enforcement agencies, airline reservations and ticketing representing investment and value both to the airline and passengers, and health and patient care records transmitted among physicians and treatment centers. The increasing volume, value and confidentiality of these records regularly transmitted and stored by commercial and government agencies has led to heightened recognition and concern over their exposures to unauthorized access and use. This misuse can be in the form of theft or defalcations of data records representing money, malicious modification of business inventories or the interception and misuse of confidential information about people. The need for protection is then apparent and urgent. It is recognized that encryption (otherwise known as scrambling, enciphering or privacy transformation) represents the only means of protecting such data during transmission and a useful means of protecting the content of data stored on various media, providing encryption of adequate strength can be devised and validated and is inherently integrable into system architecture. The National Bureau of Standards solicits proposed techniques and algorithms for computer data encryption. The Bureau also solicits recommended techniques for implementing the cryptographic function: for generating, evaluating, and protecting cryptographic keys; for maintaining files encoded under expiring keys; for making partial updates to encrypted files; and mixed clear and encrypted data to permit labelling, polling, routing, etc. The Bureau in its role for establishing standards and aiding government and industry in assessing technology, will arrange for the evaluation of protection methods in order to prepare guidelines. NBS waited for the responses to come in. It received none until August 6, 1974, three days before Nixon's resignation, when IBM submitted a candidate that it had developed internally under the name LUCIFER. After evaluating the algorithm with the help of the National Security Agency (NSA), the NBS adopted a modification of the LUCIFER algorithm as the new Data Encryption Standard (DES) on July 15, 1977. DES was quickly adopted for non-digital media, such as voice-grade public telephone lines. Within a couple of years, for example, International Flavors and Fragrances was using DES to protect its valuable formulas transmitted over the phone (\"With Data Encryption, Scents Are Safe at IFF,\" Computerworld 14, No. 21, 95 (1980).) Meanwhile, the banking industry, which is the largest user of encryption outside government, adopted DES as a wholesale banking standard. Standards for the wholesale banking industry are set by the American National Standards Institute (ANSI). ANSI X3.92, adopted in 1980, specified the use of the DES algorithm. DES works on bits, or binary numbers--the 0s and 1s common to digital computers. Each group of four bits makes up a hexadecimal, or base 16, number. Binary \"0001\" is equal to the hexadecimal number \"1\", binary \"1000\" is equal to the hexadecimal number \"8\", \"1001\" is equal to the hexadecimal number \"9\", \"1010\" is equal to the hexadecimal number \"A\", and \"1111\" is equal to the hexadecimal number \"F\". DES works by encrypting groups of 64 message bits, which is the same as 16 hexadecimal numbers. To do the encryption, DES uses \"keys\" where are also apparently 16 hexadecimal numbers long, or apparently 64 bits long. However, every 8th key bit is ignored in the DES algorithm, so that the effective key size is 56 bits. But, in any case, 64 bits (16 hexadecimal digits) is the round number upon which DES is organized. For example, if we take the plaintext message \"8787878787878787\", and encrypt it with the DES key \"0E329232EA6D0D73\", we end up with the ciphertext \"0000000000000000\". If the ciphertext is decrypted with the same secret DES key \"0E329232EA6D0D73\", the result is the original plaintext \"8787878787878787\". This example is neat and orderly because our plaintext was exactly 64 bits long. The same would be true if the plaintext happened to be a multiple of 64 bits. But most messages will not fall into this category. They will not be an exact multiple of 64 bits (that is, an exact multiple of 16 hexadecimal numbers). For example, take the message \"Your lips are smoother than vaseline\". This plaintext message is 38 bytes (76 hexadecimal digits) long. So this message must be padded with some extra bytes at the tail end for the encryption. Once the encrypted message has been decrypted, these extra bytes are thrown away. There are, of course, different padding schemes--different ways to add extra bytes. Here we will just add 0s at the end, so that the total message is a multiple of 8 bytes (or 16 hexadecimal digits, or 64 bits). The plaintext message \"Your lips are smoother than vaseline\" is, in hexadecimal, (Note here that the first 72 hexadecimal digits represent the English message, while \"0D\" is hexadecimal for Carriage Return, and \"0A\" is hexadecimal for Line Feed, showing that the message file has terminated.) We then pad this message with some 0s on the end, to get a total of 80 hexadecimal digits: If we then encrypt this plaintext message 64 bits (16 hexadecimal digits) at a time, using the same DES key \"0E329232EA6D0D73\" as before, we get the ciphertext: This is the secret code that can be transmitted or stored. Decrypting the ciphertext restores the original message \"Your lips are smoother than vaseline\". (Think how much better off Bill Clinton would be today, if Monica Lewinsky had used encryption on her Pentagon computer!) DES is a block cipher--meaning it operates on plaintext blocks of a given size (64-bits) and returns ciphertext blocks of the same size. Thus DES results in a permutation among the 2^64 (read this as: \"2 to the 64th power\") possible arrangements of 64 bits, each of which may be either 0 or 1. Each block of 64 bits is divided into two blocks of 32 bits each, a left half block L and a right half R. (This division is only used in certain operations.) Example: Let M be the plain text message M = 0123456789ABCDEF, where M is in hexadecimal (base 16) format. Rewriting M in binary format, we get the 64-bit block of text: The first bit of M is \"0\". The last bit is \"1\". We read from left to right. DES operates on the 64-bit blocks using key sizes of 56- bits. The keys are actually stored as being 64 bits long, but every 8th bit in the key is not used (i.e. bits numbered 8, 16, 24, 32, 40, 48, 56, and 64). However, we will nevertheless number the bits from 1 to 64, going left to right, in the following calculations. But, as you will see, the eight bits just mentioned get eliminated when we create subkeys. Example: Let K be the hexadecimal key K = 133457799BBCDFF1. This gives us as the binary key (setting 1 = 0001, 3 = 0011, etc., and grouping together every eight bits, of which the last one in each group will be unused): The DES algorithm uses the following steps: Step 1: Create 16 subkeys, each of which is 48-bits long. The 64-bit key is permuted according to the following table, PC-1. Since the first entry in the table is \"57\", this means that the 57th bit of the original key K becomes the first bit of the permuted key K+. The 49th bit of the original key becomes the second bit of the permuted key. The 4th bit of the original key is the last bit of the permuted key. Note only 56 bits of the original key appear in the permuted key. Example: From the original 64-bit key we get the 56-bit permutation Next, split this key into left and right halves, C and D , where each half has 28 bits. Example: From the permuted key K+, we get With C and D defined, we now create sixteen blocks C and D , 1<=n<=16. Each pair of blocks C and D is formed from the previous pair C and D , respectively, for n = 1, 2, ..., 16, using the following schedule of \"left shifts\" of the previous block. To do a left shift, move each bit one place to the left, except for the first bit, which is cycled to the end of the block. This means, for example, C and D are obtained from C and D , respectively, by two left shifts, and C and D are obtained from C and D , respectively, by one left shift. In all cases, by a single left shift is meant a rotation of the bits one place to the left, so that after one left shift the bits in the 28 positions are the bits that were previously in positions 2, 3,..., 28, 1. Example: From original pair pair C and D we obtain: We now form the keys K , for 1<=n<=16, by applying the following permutation table to each of the concatenated pairs C D . Each pair has 56 bits, but PC-2 only uses 48 of these. Therefore, the first bit of K is the 14th bit of C D , the second bit the 17th, and so on, ending with the 48th bit of K being the 32th bit of C D . Example: For the first key we have C D = 1110000 1100110 0101010 1011111 1010101 0110011 0011110 0011110 which, after we apply the permutation PC-2, becomes For the other keys we have So much for the subkeys. Now we look at the message itself. There is an initial permutation IP of the 64 bits of the message data M. This rearranges the bits according to the following table, where the entries in the table show the new arrangement of the bits from their initial order. The 58th bit of M becomes the first bit of IP. The 50th bit of M becomes the second bit of IP. The 7th bit of M is the last bit of IP. Example: Applying the initial permutation to the block of text M, given previously, we get Here the 58th bit of M is \"1\", which becomes the first bit of IP. The 50th bit of M is \"1\", which becomes the second bit of IP. The 7th bit of M is \"0\", which becomes the last bit of IP. Next divide the permuted block IP into a left half L of 32 bits, and a right half R of 32 bits. Example: From IP, we get L and R We now proceed through 16 iterations, for 1<=n<=16, using a function f which operates on two blocks--a data block of 32 bits and a key K of 48 bits--to produce a block of 32 bits. Let + denote XOR addition, (bit-by-bit addition modulo 2). Then for n going from 1 to 16 we calculate This results in a final block, for n = 16, of L R . That is, in each iteration, we take the right 32 bits of the previous result and make them the left 32 bits of the current step. For the right 32 bits in the current step, we XOR the left 32 bits of the previous step with the calculation f . Example: For n = 1, we have It remains to explain how the function f works. To calculate f, we first expand each block R from 32 bits to 48 bits. This is done by using a selection table that repeats some of the bits in R . We'll call the use of this selection table the function E. Thus E(R ) has a 32 bit input block, and a 48 bit output block. Let E be such that the 48 bits of its output, written as 8 blocks of 6 bits each, are obtained by selecting the bits in its inputs in order according to the following table: Thus the first three bits of E(R ) are the bits in positions 32, 1 and 2 of R while the last 2 bits of E(R ) are the bits in positions 32 and 1. Example: We calculate E(R ) from R as follows: Next in the f calculation, we XOR the output E(R ) with the key K : Example: For K , E(R ), we have We have not yet finished calculating the function f . To this point we have expanded R from 32 bits to 48 bits, using the selection table, and XORed the result with the key K . We now have 48 bits, or eight groups of six bits. We now do something strange with each group of six bits: we use them as addresses in tables called \"S boxes\". Each group of six bits will give us an address in a different S box. Located at that address will be a 4 bit number. This 4 bit number will replace the original 6 bits. The net result is that the eight groups of 6 bits are transformed into eight groups of 4 bits (the 4-bit outputs from the S boxes) for 32 bits total. Write the previous result, which is 48 bits, in the form: where each B is a group of six bits. We now calculate where S (B ) referres to the output of the i-th S box. To repeat, each of the functions S1, S2,..., S8, takes a 6-bit block as input and yields a 4-bit block as output. The table to determine S is shown and explained below: If S is the function defined in this table and B is a block of 6 bits, then S (B) is determined as follows: The first and last bits of B represent in base 2 a number in the decimal range 0 to 3 (or binary 00 to 11). Let that number be i. The middle 4 bits of B represent in base 2 a number in the decimal range 0 to 15 (binary 0000 to 1111). Let that number be j. Look up in the table the number in the i-th row and j-th column. It is a number in the range 0 to 15 and is uniquely represented by a 4 bit block. That block is the output S (B) of S for the input B. For example, for input block B = 011011 the first bit is \"0\" and the last bit \"1\" giving 01 as the row. This is row 1. The middle four bits are \"1101\". This is the binary equivalent of decimal 13, so the column is column number 13. In row 1, column 13 appears 5. This determines the output; 5 is binary 0101, so that the output is 0101. Hence S (011011) = 0101. The tables defining the functions S ,...,S are the following: Example: For the first round, we obtain as the output of the eight S boxes: The final stage in the calculation of f is to do a permutation P of the S-box output to obtain the final value of f: The permutation P is defined in the following table. P yields a 32-bit output from a 32-bit input by permuting the bits of the input block. Example: From the output of the eight S boxes: In the next round, we will have L = R , which is the block we just calculated, and then we must calculate R =L + f(R , K ), and so on for 16 rounds. At the end of the sixteenth round we have the blocks L and R . We then reverse the order of the two blocks into the 64-bit block and apply a final permutation IP-1 as defined by the following table: That is, the output of the algorithm has bit 40 of the preoutput block as its first bit, bit 8 as its second bit, and so on, until bit 25 of the preoutput block is the last bit of the output. Example: If we process all 16 blocks using the method defined previously, we get, on the 16th round, We reverse the order of these two blocks and apply the final permutation to which in hexadecimal format is This is the encrypted form of M = 0123456789ABCDEF: namely, C = 85E813540F0AB405. Decryption is simply the inverse of encryption, follwing the same steps as above, but reversing the order in which the subkeys are applied. The DES algorithm turns a 64-bit message block M into a 64-bit cipher block C. If each 64-bit block is encrypted individually, then the mode of encryption is called Electronic Code Book (ECB) mode. There are two other modes of DES encryption, namely Chain Block Coding (CBC) and Cipher Feedback (CFB), which make each cipher block dependent on all the previous messages blocks through an initial XOR operation. Before DES was adopted as a national standard, during the period NBS was soliciting comments on the proposed algorithm, the creators of public key cryptography, Martin Hellman and Whitfield Diffie, registered some objections to the use of DES as an encryption algorithm. Hellman wrote: \"Whit Diffie and I have become concerned that the proposed data encryption standard, while probably secure against commercial assault, may be extremely vulnerable to attack by an intelligence organization\" (letter to NBS, October 22, 1975). Diffie and Hellman then outlined a \"brute force\" attack on DES. (By \"brute force\" is meant that you try as many of the 2^56 possible keys as you have to before decrypting the ciphertext into a sensible plaintext message.) They proposed a special purpose \"parallel computer using one million chips to try one million keys each\" per second, and estimated the cost of such a machine at $20 million. Fast forward to 1998. Under the direction of John Gilmore of the EFF, a team spent $220,000 and built a machine that can go through the entire 56-bit DES key space in an average of 4.5 days. On July 17, 1998, they announced they had cracked a 56-bit key in 56 hours. The computer, called Deep Crack, uses 27 boards each containing 64 chips, and is capable of testing 90 billion keys a second. Despite this, as recently as June 8, 1998, Robert Litt, principal associate deputy attorney general at the Department of Justice, denied it was possible for the FBI to crack DES: \"Let me put the technical problem in context: It took 14,000 Pentium computers working for four months to decrypt a single message . . . . We are not just talking FBI and NSA [needing massive computing power], we are talking about every police department.\" Responded cryptograpy expert Bruce Schneier: \" . . . the FBI is either incompetent or lying, or both.\" Schneier went on to say: \"The only solution here is to pick an algorithm with a longer key; there isn't enough silicon in the galaxy or enough time before the sun burns out to brute- force triple-DES\" (Crypto-Gram, Counterpane Systems, August 15, 1998). Triple-DES is just DES with two 56-bit keys applied. Given a plaintext message, the first key is used to DES- encrypt the message. The second key is used to DES-decrypt the encrypted message. (Since the second key is not the right key, this decryption just scrambles the data further.) The twice-scrambled message is then encrypted again with the first key to yield the final ciphertext. This three-step procedure is called triple-DES. Triple-DES is just DES done three times with two keys used in a particular order. (Triple-DES can also be done with three separate keys instead of only two. In either case the resultant key space is about 2^112.) \"Cryptographic Algorithms for Protection of Computer Data During Transmission and Dormant Storage,\" Federal Register 38, No. 93 (May 15, 1973). Data Encryption Standard, Federal Information Processing Standard (FIPS) Publication 46, National Bureau of Standards, U.S. Department of Commerce, Washington D.C. (January 1977). Carl H. Meyer and Stephen M. Matyas, Cryptography: A New Dimension in Computer Data Security, John Wiley & Sons, New York, 1982. D.W. Davies and W.L. Price, Security for Computer Networks: An Introduction to Data Security in Teleprocessing and Electronics Funds Transfer, Second Edition, John Wiley & Sons, New York, 1984, 1989. Miles E. Smid and Dennis K. Branstad, \"The Data Encryption Standard: Past and Future,\" in Gustavus J. Simmons, ed., Contemporary Cryptography: The Science of Information Integrity, IEEE Press, 1992. Alfred J. Menezes, Paul C. van Oorschot, and Scott A. Vanstone, Handbook of Applied Cryptography, CRC Press, Boca Raton, 1997. This article appeared in Laissez Faire City Times, Vol 2, No. 28."
    },
    {
        "link": "https://coursehero.com/file/229865321/Homework-2docx",
        "document": ""
    },
    {
        "link": "https://geeksforgeeks.org/data-encryption-standard-des-set-1",
        "document": "This article talks about the Data Encryption Standard (DES), a historic encryption algorithm known for its 56-bit key length. We explore its operation, key transformation, and encryption process, shedding light on its role in data security and its vulnerabilities in today’s context.\n\nData Encryption Standard (DES) is a block cipher with a 56-bit key length that has played a significant role in data security. Data encryption standard (DES) has been found vulnerable to very powerful attacks therefore, the popularity of DES has been found slightly on the decline. DES is a block cipher and encrypts data in blocks of size of 64 bits each, which means 64 bits of plain text go as the input to DES, which produces 64 bits of ciphertext. The same algorithm and key are used for encryption and decryption, with minor differences. The key length is 56 bits.\n\nThe basic idea is shown below:\n\nWe have mentioned that DES uses a 56-bit key. Actually, The initial key consists of 64 bits. However, before the DES process even starts, every 8th bit of the key is discarded to produce a 56-bit key. That is bit positions 8, 16, 24, 32, 40, 48, 56, and 64 are discarded.\n\nThus, the discarding of every 8th bit of the key produces a 56-bit key from the original 64-bit key.\n\nDES is based on the two fundamental attributes of cryptography: substitution (also called confusion) and transposition (also called diffusion). DES consists of 16 steps, each of which is called a round. Each round performs the steps of substitution and transposition. Let us now discuss the broad-level steps in DES.\n• None In the first step, the 64-bit plain text block is handed over to an initial\n• None The initial permutation is performed on plain text.\n• None Next, the initial permutation (IP) produces two halves of the permuted block; saying Left Plain Text (LPT) and Right Plain Text (RPT).\n• None Now each LPT and RPT go through 16 rounds of the encryption process.\n• None In the end, LPT and RPT are rejoined and a Final Permutation (FP) is performed on the combined block\n• None The result of this process produces 64-bit ciphertext.\n\nAs we have noted, the initial permutation (IP) happens only once and it happens before the first round. It suggests how the transposition in IP should proceed, as shown in the figure. For example, it says that the IP replaces the first bit of the original plain text block with the 58th bit of the original plain text, the second bit with the 50th bit of the original plain text block, and so on.\n\nThis is nothing but jugglery of bit positions of the original plain text block. the same rule applies to all the other bit positions shown in the figure.\n\nAs we have noted after IP is done, the resulting 64-bit permuted text block is divided into two half blocks. Each half-block consists of 32 bits, and each of the 16 rounds, in turn, consists of the broad-level steps outlined in the figure.\n\nWe have noted initial 64-bit key is transformed into a 56-bit key by discarding every 8th bit of the initial key. Thus, for each a 56-bit key is available. From this 56-bit key, a different 48-bit Sub Key is generated during each round using a process called key transformation. For this, the 56-bit key is divided into two halves, each of 28 bits. These halves are circularly shifted left by one or two positions, depending on the round.\n\nFor example: if the round numbers 1, 2, 9, or 16 the shift is done by only one position for other rounds, the circular shift is done by two positions. The number of key bits shifted per round is shown in the figure.\n\nAfter an appropriate shift, 48 of the 56 bits are selected. From the 48 we might obtain 64 or 56 bits based on requirement which helps us to recognize that this model is very versatile and can handle any range of requirements needed or provided. for selecting 48 of the 56 bits the table is shown in the figure given below. For instance, after the shift, bit number 14 moves to the first position, bit number 17 moves to the second position, and so on. If we observe the table , we will realize that it contains only 48-bit positions. Bit number 18 is discarded (we will not find it in the table), like 7 others, to reduce a 56-bit key to a 48-bit key. Since the key transformation process involves permutation as well as a selection of a 48-bit subset of the original 56-bit key it is called Compression Permutation.\n\nBecause of this compression permutation technique, a different subset of key bits is used in each round. That makes DES not easy to crack.\n\nRecall that after the initial permutation, we had two 32-bit plain text areas called Left Plain Text(LPT) and Right Plain Text(RPT). During the expansion permutation, the RPT is expanded from 32 bits to 48 bits. Bits are permuted as well hence called expansion permutation. This happens as the 32-bit RPT is divided into 8 blocks, with each block consisting of 4 bits. Then, each 4-bit block of the previous step is then expanded to a corresponding 6-bit block, i.e., per 4-bit block, 2 more bits are added.\n\nThis process results in expansion as well as a permutation of the input bit while creating output. The key transformation process compresses the 56-bit key to 48 bits. Then the expansion permutation process expands the 32-bit RPT to 48-bits. Now the 48-bit key is XOR with 48-bit RPT and the resulting output is given to the next step, which is the S-Box substitution.\n\nIn conclusion, the Data Encryption Standard (DES) is a block cipher with a 56-bit key length that has played a significant role in data security. However, due to vulnerabilities, its popularity has declined. DES operates through a series of rounds involving key transformation, expansion permutation, and substitution, ultimately producing ciphertext from plaintext. While DES has historical significance, it’s crucial to consider more secure encryption alternatives for modern data protection needs.\n\nQ.1 What should be considered as an alternative to DES for data encryption?\n\nQ.2 How is the 48-bit subkey generated for each round in DES?"
    },
    {
        "link": "https://github.com/vaibkumr/Data-Encryption-Standard",
        "document": "DES is an insecure, old, easily bruteforce-able, symmetric-key encryption algorithm.\n\nDES is simple to code and helps learning about block ciphers, this is a python implementation of the same.\n• On first run, execute to generate a new key and initialize the model\n• To generate a new key, run . The new key will be saved in the file (pickled dictionary)\n• Permutation, S blocks and other data is stored in as numpy array\n• Bruteforce to make evident how inscure DES is."
    },
    {
        "link": "https://scaler.com/topics/des-algorithm",
        "document": "The arrival of the information age marked an abundance of data being produced. For the necessity of people’s privacy, protecting vital and sensitive information has been of great urgency, therefore the way information is protected during its transmission over networks and storage in system memory is given way more importance. With the arrival of scientific discipline technologies during the 1970’s, IBM came out with the DES(Data Encryption Standard, DES) algorithm, a symmetric-key algorithm based on an algorithm given earlier by Horst Feistel. Symmetric key algorithms are those where the encryption and decryption of message and ciphertext is done using the same key. The algorithm was submitted to the National Bureau of Standards, USA. In 1976, after consultation with the National Security Agency (NSA), the DES algorithm was given a few modifications and was selected, and published as an official Federal Information Processing Standard (FIPS) in America in 1977.\n\nThe Data Encryption Standard algorithm is a block cipher algorithm that takes in 64-bit blocks of plaintext at a time as input and produces 64-bit blocks of cipher text at a time, using a 48-bit key for each input. In block cipher algorithms, the text to be encrypted is broken into ‘blocks’ of text, and each block is encrypted separately using the key. The decryption process is the exact opposite of the encryption. It takes in a 64 bit block of ciphertext, and produces the 64 bit block of plaintext using the same 48 bit key during encryption. The encryptor and the decryptor need to use the same key, otherwise, they will not be able to communicate together. The DES algorithm was successful in the early days of the internet, but its short key length of 56 bits makes it too insecure for today’s applications. With the evolution of technology and the increase in computing power, an attacker with sufficient computing resources can break the key within a few minutes. It has however been highly influential in the development and advancement of cryptography.\n\nComputers don’t deal with letters or numbers. All the plaintext characters are converted to binary before they’re encrypted. During the encryption process, data is separated into blocks for processing. The DES algorithm makes a 64 bit block size, hence breaking the binary plaintext into blocks of 64 bits each. When the last block is not the required 64 bits long, it is padded before anything is done. Padding makes sure that extra information to the block is added in order to get it to a length of 64 bits. Padding can also ensure that the encrypted data is harder to crack. Keys are used to change the end result of an encryption process in such a way that it wouldn’t be possible for an attacker to predict the plaintext just by knowing the algorithm. DES begins with one key, which is used to form sub keys that are applied during each ‘round’. To produce the final ciphertext, the DES algorithm is run 16 times, and each time it is run is called a round with the output of one round acting as the input for the next. This lets the plaintext be confused as much as possible. Now, the first thing we do is choose a random 64 bit number to be our key K. Mind you, both the sender and the receiver need to have the same 64 bit key to communicate.\n\n For each round, one subkey is needed. This subkey is unique to that round, and is essentially a permutation of our master key K that we set at the beginning. A total of 16 subkeys are generated, one for each round. They’re denoted as K1​ to K16​.\n• The first step to derive our round keys is to permute the key according to the table. We shall rearrange the elements of our data block using the following PC1 table. The “C” and “D” are the \"Left\" and \"Right\" halves of the data block. The numbers given in the table decide which bits from the input key belong to which (left or right) sections of the state of the key scheduling. During the PC-1 permutation, each bit of the original key is rearranged and placed at a new position in accordance with the table. Since the first cell of table \"C\" reads 57, the 57th bit from the original key will be placed in the first cell. The second cell reads 49, hence the second bit of our new key will be the 49th bit from the old block. Similarly, all the other numbers from the old block are arranged in the order of table “C” to make our new key. Once the block is arranged in order of table”C”, we jump to table “D” to complete the second half of our new key. Looking at the table and the key, you may have noticed that they are only 56 bits in length, rather than 64 bits. This is because every eighth bit (8, 16, 24, 32, 40, 48, 56) is specified for use as parity bits to ensure that the key has been received correctly. Due to these parity bits, the DES algorithm has the security of a 56 bit key in practice. Our 56 bit key is now split into left and right halves, each 28 bits in length. We will now be using this for our next step.\n• The next step is shifting the key to the left either by 1 or 2 bits depending on the round number. The exact number to shift is given in the following table: In these rounds, the numbers are shifted to the left by the distances given in the table, with each of the shifts being applied to the result of the previous round.\n\n For example, if we’re in the 5th encryption round and had 1101101101101101 as our key, then according to the table we’ll have to left shift it by 2 spaces. Hence after this round, our key will now be: 0110110110110111. Hence, sixteen different subkeys are generated, with one for each round of the DES process.\n• Next, we permute the key according to the Permuted Choice-2 table as given. Here we once again rearrange the bits in our key according to the table below. Similar to the previous permutation, the key is shuffled in such a way that the new position of the key bit is derived as indicated by the table. Hence the 14th bit of the key is placed at the first position of the new permuted key, the 17th bit of the key is placed at the second position of the new permuted key..so on and so forth. On further inspection, we can see that the newly generated key has only 48 bits, unlike the previous keys that generated 56 bits. This process is called compression permutation. The top half of the table contains numbers from 1 to 28, and the bottom half contains numbers from 29 to 56. This ensures the left and right halves of the resulting subkeys are separate. Now, we have derived 16 different subkeys for each of the DES rounds. Now, we can move on to see how the encryption of the plaintext happens using the DES algorithm.\n\nThe encryption process of plaintext using the DES algorithm is as follows:\n• Initial Permutation Function:\n\n Just like what we did with the key, the plaintext is broken into blocks of 64 bits each. The plaintext is the data that needs to be encrypted and transmitted from sender to receiver. It is also padded if the last block is not the required 64 bits long. Then, it is fed to the initial permutation function, which confuses the text before any operation is done on it. The IP (Initial Permutation) does not contain any cryptographic value. The permutation is done similar to what we did with the key, and the bits of the binary coded message are arranged following the Initial Permutation table. The output of this step is taken as input for the next step:\n• Splitting the Blocks:\n\n Once the IP process is finished, the data is split into 2 halves, a left block L0 made-up of 32 bits, and a right block R0, made up of 32 bits.\n\n After the splitting of the blocks, we move to the next function. In round one, the right half of the block is taken and undergoes the following steps: A) Expansion Permutation (E):\n\n Three things are accomplished by the expansion permutation, an important one being the avalanche effect, where one bit of input data directly affects the output of 2 different bits. This step also makes sure the right half has 48 bits, so that it has the same length as the subkey for the upcoming step. An example of avalanche effect: Another important outcome of the Expansion Permutation is that it permits the data to be squeezed together in the substitution operation by making the output longer than the input. Next, the blocks are permuted once again using the following expansion function table: On careful inspection, we can notice that a few blocks are repeated in the table. This is to expand the block from 32 to 48 bits. B) Key Mixing (⊕):\n\n Once we have expanded the block to 48 bits, we apply the subkey of the 1st round which we derived from the key scheduling we did before. The block is then amended by the subkey using the XOR table. For example, if the last 8 bits of the expanded key is 01001011, then the key after the key mixing step becomes: 10110100. The resulting block is pushed to the next step. C) Substitution (S):\n\n Substitution is used to make the data more complex so that it cannot be deciphered easily. 8 pre-made tables called substitution boxes or S-Boxes are used to transform each 6 bit input into a 4 bit output. From the 6 bit input, the MSB and LSB is taken and converted to decimal number X. This number X gives us the row number of the S-box. Next, take the 4 bits in the middle of the input and convert that into decimal number Y. This number Y gives us the column number to look at. Now, take the number from the S-Box corresponding to the X row and Y column, and convert this into a 4 bit binary number. Hence, we have successfully converted a 6 bit input into a 4 bit output. For example, let’s assume that the 6 bit output from the previous step is B = (101111)2​. We’ll represent the bits with (b1​b2​b3​b4​b5​b6​)2​. To find the row number, we first take and combine the MSB and LSB ( b1​b6​) which gives (11)2​. We then convert this to decimal, which gives us (3)10​, meaning row 3.\n\n For the column number, we take b1​b2​b3​b4​b5​, which is (0111)2​. On converting to decimal, we get (7)10​, or column 7. Hence for the number, we substitute it with the number from row 3 and column 7, which gives 7. We choose which substitution box to choose from based on the location of the bits. Here in our example, the 6 bits are from the beginning of the output from step (B). Hence, we take the first S-box. D) Permutation (P):\n\n Finally, the F function is again permuted using the below permutation P table: Now, we have finished all steps of the F function. This value that we have derived (the encrypted data) is known mathematically as f(R0, K1). This means that the outcome is a function of the initial right side of block R0 and subkey of the first round. Now we take this value and do the following steps: iii) XORing with the Left Block: Now, we take the left half of the block we left previously, and XOR it with the f(R0,K1) block that we got after permuting in the previous step. This gives us R1, the result of the first round of processing. iv) 15 more times!: The above 3 steps are run 15 more times to complete 16 rounds of processing. The next diagram gives a visual representation of the processing of the blocks: The formula is as follows:\n\n Ln=Rn−1 where,\n\n Ln​= left half of the block during round number ‘n’\n\n Rn​ = right half of the block during round number ‘n’\n\n f = f function\n\n Kn​ = subkey for round n v) Final Permutation: Finally, the result of the final round is permuted one last time following the given IP−1 table: Here, the table IP−1 is the inverse of the initial table P. Finally, the output of this inverse permutation table is the ciphertext of the DES algorithm. A. bird’s eye view of the entire process is as follows:"
    },
    {
        "link": "https://github.com/LeoMartinezTAMUK/DES_Cipher_Encryption-Decryption",
        "document": "This C++ program implements the DES Cipher, a type of block cipher, for encrypting and decrypting messages.\n• The DES_Encrypt.cpp/.exe script takes a plaintext and a 56-bit key as input.\n• It performs an initial permutation (IP) on the 64-bit plaintext.\n• The 64-bit block is divided into two 32-bit halves, left (L) and right (R).\n• The function performs 16 rounds of Feistel network operations using the subkeys derived from the key.\n• In each round, the right half is expanded, XORed with the subkey, and passed through S-boxes for substitution.\n• The results are then permuted and combined with the left half.\n• After 16 rounds, the left and right halves are swapped, and a final permutation (IP^(-1)) is applied.\n• The resulting 64-bit block is the ciphertext.\n• Use the same DES algorithm, but reverse the key order of the generated keys\n• Program was created in VS Code using C++\n\nHere is a brief explanation of the items:\n• src: folder that contains the source code C++ script (.cpp)\n• bin: contains the corresponding compiled .exe version.\n• README.md: contains most basic information about the project\n• LICENSE: Contains license information in regards to the Github repository"
    },
    {
        "link": "https://pypi.org/project/pyDes",
        "document": "A required part of this site couldn’t load. This may be due to a browser extension, network issues, or browser settings. Please check your connection, disable any ad blockers, or try using a different browser."
    }
]