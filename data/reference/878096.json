[
    {
        "link": "https://vuejs.org/guide/components/props.html",
        "document": "Vue components require explicit props declaration so that Vue knows what external props passed to the component should be treated as fallthrough attributes (which will be discussed in its dedicated section).\n\nIn SFCs using , props can be declared using the macro: In non- components, props are declared using the option: // setup() receives props as the first argument. Notice the argument passed to is the same as the value provided to the options: the same props options API is shared between the two declaration styles.\n\nIn addition to declaring props using an array of strings, we can also use the object syntax:\n\nFor each property in the object declaration syntax, the key is the name of the prop, while the value should be the constructor function of the expected type.\n\nThis not only documents your component, but will also warn other developers using your component in the browser console if they pass the wrong type. We will discuss more details about prop validation further down this page.\n\nVue's reactivity system tracks state usage based on property access. E.g. when you access in a computed getter or a watcher, the prop gets tracked as a dependency. So, given the following code: // runs only once before 3.5 // re-runs when the \"foo\" prop changes in 3.5+ In version 3.4 and below, is an actual constant and will never change. In version 3.5 and above, Vue's compiler automatically prepends when code in the same block accesses variables destructured from . Therefore the code above becomes equivalent to the following: // `foo` transformed to `props.foo` by the compiler In addition, you can use JavaScript's native default value syntax to declare default values for the props. This is particularly useful when using the type-based props declaration: If you prefer to have more visual distinction between destructured props and normal variables in your IDE, Vue's VSCode extension provides a setting to enable inlay-hints for destructured props. When we pass a destructured prop into a function, e.g.: This will not work as expected because it is equivalent to - we are passing a value instead of a reactive data source to . In fact, Vue's compiler will catch such cases and throw a warning. Similar to how we can watch a normal prop with , we can watch a destructured prop also by wrapping it in a getter: In addition, this is the recommended approach when we need to pass a destructured prop into an external function while retaining reactivity: The external function can call the getter (or normalize it with toValue) when it needs to track changes of the provided prop, e.g. in a computed or watcher getter.\n\nWe declare long prop names using camelCase because this avoids having to use quotes when using them as property keys, and allows us to reference them directly in template expressions because they are valid JavaScript identifiers:\n\nTechnically, you can also use camelCase when passing props to a child component (except in in-DOM templates). However, the convention is using kebab-case in all cases to align with HTML attributes:\n\nWe use PascalCase for component tags when possible because it improves template readability by differentiating Vue components from native elements. However, there isn't as much practical benefit in using camelCase when passing props, so we choose to follow each language's conventions.\n\nSo far, you've seen props passed as static values, like in:\n\nYou've also seen props assigned dynamically with or its shortcut, such as in:\n\nIn the two examples above, we happen to pass string values, but any type of value can be passed to a prop.\n\nIf you want to pass all the properties of an object as props, you can use without an argument ( instead of ). For example, given a object:\n\nWill be equivalent to:\n\nAll props form a one-way-down binding between the child property and the parent one: when the parent property updates, it will flow down to the child, but not the other way around. This prevents child components from accidentally mutating the parent's state, which can make your app's data flow harder to understand.\n\nIn addition, every time the parent component is updated, all props in the child component will be refreshed with the latest value. This means you should not attempt to mutate a prop inside a child component. If you do, Vue will warn you in the console:\n\nThere are usually two cases where it's tempting to mutate a prop:\n• None The prop is used to pass in an initial value; the child component wants to use it as a local data property afterwards. In this case, it's best to define a local data property that uses the prop as its initial value: // counter only uses props.initialCounter as the initial value; // it is disconnected from future prop updates. // counter only uses this.initialCounter as the initial value; // it is disconnected from future prop updates.\n• None The prop is passed in as a raw value that needs to be transformed. In this case, it's best to define a computed property using the prop's value: // computed property that auto-updates when the prop changes // computed property that auto-updates when the prop changes\n\nWhen objects and arrays are passed as props, while the child component cannot mutate the prop binding, it will be able to mutate the object or array's nested properties. This is because in JavaScript objects and arrays are passed by reference, and it is unreasonably expensive for Vue to prevent such mutations.\n\nThe main drawback of such mutations is that it allows the child component to affect parent state in a way that isn't obvious to the parent component, potentially making it more difficult to reason about the data flow in the future. As a best practice, you should avoid such mutations unless the parent and child are tightly coupled by design. In most cases, the child should emit an event to let the parent perform the mutation.\n\nComponents can specify requirements for their props, such as the types you've already seen. If a requirement is not met, Vue will warn you in the browser's JavaScript console. This is especially useful when developing a component that is intended to be used by others.\n\nTo specify prop validations, you can provide an object with validation requirements to the macro option, instead of an array of strings. For example:\n• None All props are optional by default, unless is specified.\n• None An absent optional prop other than will have value.\n• None The absent props will be cast to . You can change this by setting a for it — i.e.: to behave as a non-Boolean prop.\n• None If a value is specified, it will be used if the resolved prop value is - this includes both when the prop is absent, or an explicit value is passed.\n\nWhen prop validation fails, Vue will produce a console warning (if using the development build).\n\nThe can be one of the following native constructors:\n\nIn addition, can also be a custom class or constructor function and the assertion will be made with an check. For example, given the following class:\n\nYou could use it as a prop's type:\n\nVue will use to validate whether the value of the prop is indeed an instance of the class.\n\nIf the type is required but nullable, you can use the array syntax that includes :\n\nNote that if is just without using the array syntax, it will allow any type.\n\nProps with type have special casting rules to mimic the behavior of native boolean attributes. Given a with the following declaration:\n\nThe component can be used like this:\n\nWhen a prop is declared to allow multiple types, the casting rules for will also be applied. However, there is an edge when both and are allowed - the Boolean casting rule only applies if Boolean appears before String:"
    },
    {
        "link": "https://vueschool.io/articles/vuejs-tutorials/techniques-for-sharing-data-between-vue-js-components",
        "document": "In this example, we are passing the prop with a value of to our child component. We will then be able to access this value from inside of the by initializing our props object in the script tag of our child component file\n\nAs our application grows in size and complexity, passing data through components can become messy. We will have to pass data from a parent component to a child component which may be deeply nested in the component tree. Stores introduce an advanced method of passing data across components by eliminating the problem of prop drilling. Prop drilling refers to transporting data or states as props to the intended destination through intermediate components.\n\nWith stores, our states or data are stored in a centralized point to be accessed by any components irrespective of their hierarchy in the component tree. This is a common way of handling states for big Vue.js applications. Popular state management tools for Vue.js include Pinia and Vuex. For our basic example, we will use Pinia which is the official state management tool for Vue js 3.\n\nProvide and Inject technique is also another useful technique of preventing prop drilling when building complex Vue.js applications. With this technique the parent component can provide dependencies for all its child components. This means that any component in the component tree, regardless of how deep it is, can inject dependencies that are provided by components higher up in the component chain."
    },
    {
        "link": "https://blog.logrocket.com/use-props-pass-data-child-components-vue-3",
        "document": "This article was last reviewed and updated on 4 October 2024.\n\nYou can send state from a parent component to a child component in Vue using props:\n• Static props: You can pass data from a parent component to its child using static values within the parent’s template. This is useful when the value doesn’t need to change dynamically\n• Dynamic props: You can pass reactive state (like arrays or objects) from the parent to the child using , allowing for automatic updates when the data changes\n• Typed props: In the child component, you can define prop types such as , , to validate the incoming data, ensuring proper validation and preventing potential errors\n\nHandling props can be tricky. In this article, we’ll dive deeper into how to pass data between a parent component to its child using props in Vue 3. You can find the complete code for this tutorial on GitHub. Let’s get started!\n\nThis article is suited for developers of all stages, including beginners. To follow along, you’ll need Node.js version ≥16.x installed. You can verify if you already have it installed by running the command in your terminal or the command prompt.\n\nYou’ll also need a code editor; I highly recommend VS Code.\n\nAt the time of writing, Vue 3 is the latest version. To follow along, you’ll need Vue 3 installed globally on your machine.\n\nBefore getting started, download a Vue starter project. Unzip the downloaded project, navigate into the unzipped file, and then run the command below to keep all the dependencies up to date:\n\nWhat are props in Vue?\n\nIn Vue, props are custom attributes that you can register on any component. You define your data on the parent component and give it a value. Then, you go to the child component that needs that data and pass the value to a prop attribute. Therefore, the data becomes a property in the child component.\n\nIn a component, the syntax looks like the following code:\n\nIn a non- component, the syntax looks like this:\n\nTo access this data dynamically from any component that needs it, you can use the root component as the parent component, store the data, and then register props.\n\nVue uses a more flexible approach to props where you can specify the type of a prop using JavaScript constructors:\n\nThe types can be , , , , or .\n\nThe type accepts only string values, the prop with type accepts only numeric values, the prop with type accepts only Boolean values, and the prop with or type accepts only array or object values respectively.\n\nWhy should you use props in Vue?\n\nLet’s say you have an array of objects that you want to display in two different components. For example, component A renders the artist names from the array of objects while component B renders the artist names and countries from the array of objects. Your first instinct might be to:\n• Display them in the template\n\nThis solution is great initially but becomes more complicated as you add more components. Let’s demonstrate this with the starter project you’ve opened in VS Code.\n\nOpen the file and copy the code block below:\n\nCreate a new file in the components folder called and paste the following code block inside it:\n\nTo register the new component you just created, open the file and copy the code below inside it:\n\nIn the VS Code terminal, serve up the application in the development environment with the following command:\n\nIt should look like the following:\n\nYou’ll notice that if you had only about five more components, you would have to keep copying the data in every component. Imagine there was a way that you could define the data in a parent component and then bring it into every child component that needs it by using the property name. This is where using props to pass data from parent to child components comes in handy.\n\nBecause you’ve chosen the root component to be your parent component, you first have to define the data object that you want to share dynamically inside of the root component.\n\nIf you’ve followed this article from the start, open up your file and copy the data object code block inside of the script section:\n\nTo receive props in a component, you have to specify the props that you want to receive inside of that component. After defining the data, go into the two test components, and delete the data objects inside them, and add the specifications in the script section, as shown below:\n\nTo let the Vue engine know that you have props you want to dynamically pass to child components, you have to indicate this in the Vue instance. This is done in the template section as shown here:\n\nThe directive in Vue is used to bind HTML attributes or component props dynamically. In the code above, we used to bind , which is the name of the data object array in the script section, and , the prop name in the test components, which you set up in the section above.\n\nIf you set it up without the following directive, you won’t see any output; neither the Vue compiler nor ESLint will flag it as an error or warning:\n\nTherefore, it’s important to pay attention and remember to use for every dynamic binding.\n\nAfter you’ve set up the props in your Vue app, you can then use them inside of your component as if the data were defined inside of the same component. Therefore, in our demo case, you can set up method calls and easily access .\n\nBy strongly typing the props, you can also ensure that your component only receives exactly the data type you want it to. In our demo, for instance, you can ensure that only arrays get passed down to your component by setting up authentication as follows:\n\nTherefore, whenever you add a wrong type, say, a , you’ll get a warning in the console telling you that the type it received is not the type it expected:\n\nHow to set default values for props\n\nYou can set default values for props using the property in the option:\n\nThe default value of a prop should correspond with the specified type.\n\nHow to work with multiple props in Vue\n\nWorking with multiple props is similar to working with a single prop, but you need to declare and define each prop in the component’s props option.\n\nUsing the component in a parent component, you can pass values for each prop as follows:\n\nIn the child component definition, declare the option as an object where each property represents a prop. You can specify the type, default value, and other options for each prop:\n\nIn the above code, is a required prop of type , is an optional prop of type with a default value of 42, while is an optional prop of type with a default value of .\n\nYou can use the props in the child component’s methods or computed properties just like any other data property:\n\nIn the child component’s template, you can access the props using the syntax:\n\nWorking with multiple props in the Vue 3 Composition API\n\nIn the Vue 3 Composition API, working with multiple props is slightly different than in the Options API discussed above:\n• Declaring props: In the Composition API, you use the function to declare props, while the Options API uses a option object\n• Accessing props: Props in the Composition API are accessed via the argument passed to the function, while in the Options API, they are directly available within the component’s options\n• Destructuring props: Destructuring props in the Composition API can lose reactivity unless you use utilities like\n\nIn the Composition API, you can use the function to declare and define props:\n\nThe first argument in the function is the argument. You can use the prop values directly in the template as follows:\n\nYou may want to destructure the object in the setup function; by doing this, the destructured variables will lose reactivity. It is therefore recommended to always access props in the form of .\n\nBut if you need to destructure the props, or need to pass a prop into an external function while retaining reactivity; you can do so with the and utility APIs:\n\nHere, we use to turn the props into an object of refs to destructure. is a ref that tracks .\n\nYou can use the destructured prop values directly in the template as follows:\n\nHow to pass functions to props in Vue\n\nIn Vue 3, you can pass functions as props to child components in a similar way to passing any other data.\n\nIn the parent component, define a function that you want to pass as a prop:\n\nIn the child component, declare the prop to accept a function. You can do this by adding a option and specifying the type as :\n\nYou can then use it in the child component template as follows:\n\nIn this article, we explored how to send state from parent to child components in Vue using Vue 3 props. We demonstrated how to define props for both static and dynamic data and how to enforce prop types for better validation. We also discussed how to send state as an object in Vue, making it easier to pass complex data structures.\n\nFor additional information, check out Vue’s official documentation on props."
    },
    {
        "link": "https://vuejs.org/guide/components/props",
        "document": "Vue components require explicit props declaration so that Vue knows what external props passed to the component should be treated as fallthrough attributes (which will be discussed in its dedicated section).\n\nIn SFCs using , props can be declared using the macro: In non- components, props are declared using the option: // setup() receives props as the first argument. Notice the argument passed to is the same as the value provided to the options: the same props options API is shared between the two declaration styles.\n\nIn addition to declaring props using an array of strings, we can also use the object syntax:\n\nFor each property in the object declaration syntax, the key is the name of the prop, while the value should be the constructor function of the expected type.\n\nThis not only documents your component, but will also warn other developers using your component in the browser console if they pass the wrong type. We will discuss more details about prop validation further down this page.\n\nVue's reactivity system tracks state usage based on property access. E.g. when you access in a computed getter or a watcher, the prop gets tracked as a dependency. So, given the following code: // runs only once before 3.5 // re-runs when the \"foo\" prop changes in 3.5+ In version 3.4 and below, is an actual constant and will never change. In version 3.5 and above, Vue's compiler automatically prepends when code in the same block accesses variables destructured from . Therefore the code above becomes equivalent to the following: // `foo` transformed to `props.foo` by the compiler In addition, you can use JavaScript's native default value syntax to declare default values for the props. This is particularly useful when using the type-based props declaration: If you prefer to have more visual distinction between destructured props and normal variables in your IDE, Vue's VSCode extension provides a setting to enable inlay-hints for destructured props. When we pass a destructured prop into a function, e.g.: This will not work as expected because it is equivalent to - we are passing a value instead of a reactive data source to . In fact, Vue's compiler will catch such cases and throw a warning. Similar to how we can watch a normal prop with , we can watch a destructured prop also by wrapping it in a getter: In addition, this is the recommended approach when we need to pass a destructured prop into an external function while retaining reactivity: The external function can call the getter (or normalize it with toValue) when it needs to track changes of the provided prop, e.g. in a computed or watcher getter.\n\nWe declare long prop names using camelCase because this avoids having to use quotes when using them as property keys, and allows us to reference them directly in template expressions because they are valid JavaScript identifiers:\n\nTechnically, you can also use camelCase when passing props to a child component (except in in-DOM templates). However, the convention is using kebab-case in all cases to align with HTML attributes:\n\nWe use PascalCase for component tags when possible because it improves template readability by differentiating Vue components from native elements. However, there isn't as much practical benefit in using camelCase when passing props, so we choose to follow each language's conventions.\n\nSo far, you've seen props passed as static values, like in:\n\nYou've also seen props assigned dynamically with or its shortcut, such as in:\n\nIn the two examples above, we happen to pass string values, but any type of value can be passed to a prop.\n\nIf you want to pass all the properties of an object as props, you can use without an argument ( instead of ). For example, given a object:\n\nWill be equivalent to:\n\nAll props form a one-way-down binding between the child property and the parent one: when the parent property updates, it will flow down to the child, but not the other way around. This prevents child components from accidentally mutating the parent's state, which can make your app's data flow harder to understand.\n\nIn addition, every time the parent component is updated, all props in the child component will be refreshed with the latest value. This means you should not attempt to mutate a prop inside a child component. If you do, Vue will warn you in the console:\n\nThere are usually two cases where it's tempting to mutate a prop:\n• None The prop is used to pass in an initial value; the child component wants to use it as a local data property afterwards. In this case, it's best to define a local data property that uses the prop as its initial value: // counter only uses props.initialCounter as the initial value; // it is disconnected from future prop updates. // counter only uses this.initialCounter as the initial value; // it is disconnected from future prop updates.\n• None The prop is passed in as a raw value that needs to be transformed. In this case, it's best to define a computed property using the prop's value: // computed property that auto-updates when the prop changes // computed property that auto-updates when the prop changes\n\nWhen objects and arrays are passed as props, while the child component cannot mutate the prop binding, it will be able to mutate the object or array's nested properties. This is because in JavaScript objects and arrays are passed by reference, and it is unreasonably expensive for Vue to prevent such mutations.\n\nThe main drawback of such mutations is that it allows the child component to affect parent state in a way that isn't obvious to the parent component, potentially making it more difficult to reason about the data flow in the future. As a best practice, you should avoid such mutations unless the parent and child are tightly coupled by design. In most cases, the child should emit an event to let the parent perform the mutation.\n\nComponents can specify requirements for their props, such as the types you've already seen. If a requirement is not met, Vue will warn you in the browser's JavaScript console. This is especially useful when developing a component that is intended to be used by others.\n\nTo specify prop validations, you can provide an object with validation requirements to the macro option, instead of an array of strings. For example:\n• None All props are optional by default, unless is specified.\n• None An absent optional prop other than will have value.\n• None The absent props will be cast to . You can change this by setting a for it — i.e.: to behave as a non-Boolean prop.\n• None If a value is specified, it will be used if the resolved prop value is - this includes both when the prop is absent, or an explicit value is passed.\n\nWhen prop validation fails, Vue will produce a console warning (if using the development build).\n\nThe can be one of the following native constructors:\n\nIn addition, can also be a custom class or constructor function and the assertion will be made with an check. For example, given the following class:\n\nYou could use it as a prop's type:\n\nVue will use to validate whether the value of the prop is indeed an instance of the class.\n\nIf the type is required but nullable, you can use the array syntax that includes :\n\nNote that if is just without using the array syntax, it will allow any type.\n\nProps with type have special casting rules to mimic the behavior of native boolean attributes. Given a with the following declaration:\n\nThe component can be used like this:\n\nWhen a prop is declared to allow multiple types, the casting rules for will also be applied. However, there is an edge when both and are allowed - the Boolean casting rule only applies if Boolean appears before String:"
    },
    {
        "link": "https://vuejs.org/guide/essentials/component-basics",
        "document": "Components allow us to split the UI into independent and reusable pieces, and think about each piece in isolation. It's common for an app to be organized into a tree of nested components:\n\nThis is very similar to how we nest native HTML elements, but Vue implements its own component model that allows us to encapsulate custom content and logic in each component. Vue also plays nicely with native Web Components. If you are curious about the relationship between Vue Components and native Web Components, read more here.\n\nWhen using a build step, we typically define each Vue component in a dedicated file using the extension - known as a Single-File Component (SFC for short):\n\nWhen not using a build step, a Vue component can be defined as a plain JavaScript object containing Vue-specific options:\n\nThe template is inlined as a JavaScript string here, which Vue will compile on the fly. You can also use an ID selector pointing to an element (usually native elements) - Vue will use its content as the template source.\n\nThe example above defines a single component and exports it as the default export of a file, but you can use named exports to export multiple components from the same file.\n\nTo use a child component, we need to import it in the parent component. Assuming we placed our counter component inside a file called , the component will be exposed as the file's default export:\n\nIt's also possible to globally register a component, making it available to all components in a given app without having to import it. The pros and cons of global vs. local registration is discussed in the dedicated Component Registration section.\n\nComponents can be reused as many times as you want:\n\nNotice that when clicking on the buttons, each one maintains its own, separate . That's because each time you use a component, a new instance of it is created.\n\nIn SFCs, it's recommended to use tag names for child components to differentiate from native HTML elements. Although native HTML tag names are case-insensitive, Vue SFC is a compiled format so we are able to use case-sensitive tag names in it. We are also able to use to close a tag.\n\nIf you are authoring your templates directly in a DOM (e.g. as the content of a native element), the template will be subject to the browser's native HTML parsing behavior. In such cases, you will need to use and explicit closing tags for components:\n\nSee in-DOM template parsing caveats for more details.\n\nIf we are building a blog, we will likely need a component representing a blog post. We want all the blog posts to share the same visual layout, but with different content. Such a component won't be useful unless you can pass data to it, such as the title and content of the specific post we want to display. That's where props come in.\n\nProps are custom attributes you can register on a component. To pass a title to our blog post component, we must declare it in the list of props this component accepts, using the option macro:\n\nA component can have as many props as you like and, by default, any value can be passed to any prop.\n\nOnce a prop is registered, you can pass data to it as a custom attribute, like this:\n\nIn a typical app, however, you'll likely have an array of posts in your parent component:\n\nThen want to render a component for each one, using :\n\nNotice how syntax ( ) is used to pass dynamic prop values. This is especially useful when you don't know the exact content you're going to render ahead of time.\n\nThat's all you need to know about props for now, but once you've finished reading this page and feel comfortable with its content, we recommend coming back later to read the full guide on Props.\n\nAs we develop our component, some features may require communicating back up to the parent. For example, we may decide to include an accessibility feature to enlarge the text of blog posts, while leaving the rest of the page at its default size.\n\nIn the parent, we can support this feature by adding a data propertyref:\n\nWhich can be used in the template to control the font size of all blog posts:\n\nNow let's add a button to the component's template:\n\nThe button doesn't do anything yet - we want clicking the button to communicate to the parent that it should enlarge the text of all posts. To solve this problem, components provide a custom events system. The parent can choose to listen to any event on the child component instance with or , just as we would with a native DOM event:\n\nThen the child component can emit an event on itself by calling the built-in method, passing the name of the event:\n\nThanks to the listener, the parent will receive the event and update the value of .\n\nWe can optionally declare emitted events using the option macro:\n\nThis documents all the events that a component emits and optionally validates them. It also allows Vue to avoid implicitly applying them as native listeners to the child component's root element.\n\nThat's all you need to know about custom component events for now, but once you've finished reading this page and feel comfortable with its content, we recommend coming back later to read the full guide on Custom Events.\n\nJust like with HTML elements, it's often useful to be able to pass content to a component, like this:\n\nWhich might render something like:\n\nThis can be achieved using Vue's custom element:\n\nAs you'll see above, we use the as a placeholder where we want the content to go – and that's it. We're done!\n\nThat's all you need to know about slots for now, but once you've finished reading this page and feel comfortable with its content, we recommend coming back later to read the full guide on Slots.\n\nSometimes, it's useful to dynamically switch between components, like in a tabbed interface:\n\nThe above is made possible by Vue's element with the special attribute:\n\nIn the example above, the value passed to can contain either:\n• the name string of a registered component, OR\n\nYou can also use the attribute to create regular HTML elements.\n\nWhen switching between multiple components with , a component will be unmounted when it is switched away from. We can force the inactive components to stay \"alive\" with the built-in component.\n\nIf you are writing your Vue templates directly in the DOM, Vue will have to retrieve the template string from the DOM. This leads to some caveats due to browsers' native HTML parsing behavior.\n\nHTML tags and attribute names are case-insensitive, so browsers will interpret any uppercase characters as lowercase. That means when you’re using in-DOM templates, PascalCase component names and camelCased prop names or event names all need to use their kebab-cased (hyphen-delimited) equivalents:\n\nWe have been using self-closing tags for components in previous code samples:\n\nThis is because Vue's template parser respects as an indication to end any tag, regardless of its type.\n\nIn in-DOM templates, however, we must always include explicit closing tags:\n\nThis is because the HTML spec only allows a few specific elements to omit closing tags, the most common being and . For all other elements, if you omit the closing tag, the native HTML parser will think you never terminated the opening tag. For example, the following snippet:\n\nwill be parsed as:\n\nSome HTML elements, such as , , and have restrictions on what elements can appear inside them, and some elements such as , , and can only appear inside certain other elements.\n\nThis will lead to issues when using components with elements that have such restrictions. For example:\n\nThe custom component will be hoisted out as invalid content, causing errors in the eventual rendered output. We can use the special attribute as a workaround:\n\nThat's all you need to know about in-DOM template parsing caveats for now - and actually, the end of Vue's Essentials. Congratulations! There's still more to learn, but first, we recommend taking a break to play with Vue yourself - build something fun, or check out some of the Examples if you haven't already.\n\nOnce you feel comfortable with the knowledge you've just digested, move on with the guide to learn more about components in depth."
    },
    {
        "link": "https://vuejs.org/guide/components/events.html",
        "document": "A component can emit custom events directly in template expressions (e.g. in a handler) using the built-in method:\n\nThe parent can then listen to it using :\n\nThe modifier is also supported on component event listeners:\n\nLike components and props, event names provide an automatic case transformation. Notice we emitted a camelCase event, but can listen for it using a kebab-cased listener in the parent. As with props casing, we recommend using kebab-cased event listeners in templates.\n\nIt's sometimes useful to emit a specific value with an event. For example, we may want the component to be in charge of how much to enlarge the text by. In those cases, we can pass extra arguments to to provide this value:\n\nThen, when we listen to the event in the parent, we can use an inline arrow function as the listener, which allows us to access the event argument:\n\nOr, if the event handler is a method:\n\nThen the value will be passed as the first parameter of that method:\n\nA component can explicitly declare the events it will emit using the macro option:\n\nThe method that we used in the isn't accessible within the section of a component, but returns an equivalent function that we can use instead: The macro cannot be used inside a function, it must be placed directly within , as in the example above. If you're using an explicit function instead of , events should be declared using the option, and the function is exposed on the context: As with other properties of the context, can safely be destructured:\n\nThe option and macro also support an object syntax. If using TypeScript you can type arguments, which allows us to perform runtime validation of the payload of the emitted events:\n\nAlthough optional, it is recommended to define all emitted events in order to better document how a component should work. It also allows Vue to exclude known listeners from fallthrough attributes, avoiding edge cases caused by DOM events manually dispatched by 3rd party code.\n\nSimilar to prop type validation, an emitted event can be validated if it is defined with the object syntax instead of the array syntax.\n\nTo add validation, the event is assigned a function that receives the arguments passed to the call and returns a boolean to indicate whether the event is valid or not."
    },
    {
        "link": "https://stackoverflow.com/questions/67371579/vue-3-emit-event-from-parent-to-child-component",
        "document": "If you were like me calling some event on and in Vue2 from any parent/child to any child/parent for somehow keep your code cleaner rather then using bunch of emits and props respectively and have your code blows up..\n\nfrom Vue3 doc, event bus pattern can be replaced by using an external library implementing the event emitter interface. use a library that implement a pub-sub pattern or write it. vue3 event description\n\nNow if you're using the Option-API (like vue 2) y need to import that event file then using it right a way in any component.\n\nif you are using the you need add extra step in order to you that event library heres the code.\n\nhere's a basic example of pub-sub javascript pattern, don't forget to add the off method and call it on (v3), (v2) to not have multiple function execution for each mounted call )\n\nif you're doing vue2 like syntax Option-API: //in vue component\n\n//obviously you have to emit that from another component //...\n\nif you're using the which means all variables and methods are exposed by default to the template.\n\n//using it in a"
    },
    {
        "link": "https://vuejs.org/guide/components/events",
        "document": "A component can emit custom events directly in template expressions (e.g. in a handler) using the built-in method:\n\nThe parent can then listen to it using :\n\nThe modifier is also supported on component event listeners:\n\nLike components and props, event names provide an automatic case transformation. Notice we emitted a camelCase event, but can listen for it using a kebab-cased listener in the parent. As with props casing, we recommend using kebab-cased event listeners in templates.\n\nIt's sometimes useful to emit a specific value with an event. For example, we may want the component to be in charge of how much to enlarge the text by. In those cases, we can pass extra arguments to to provide this value:\n\nThen, when we listen to the event in the parent, we can use an inline arrow function as the listener, which allows us to access the event argument:\n\nOr, if the event handler is a method:\n\nThen the value will be passed as the first parameter of that method:\n\nA component can explicitly declare the events it will emit using the macro option:\n\nThe method that we used in the isn't accessible within the section of a component, but returns an equivalent function that we can use instead: The macro cannot be used inside a function, it must be placed directly within , as in the example above. If you're using an explicit function instead of , events should be declared using the option, and the function is exposed on the context: As with other properties of the context, can safely be destructured:\n\nThe option and macro also support an object syntax. If using TypeScript you can type arguments, which allows us to perform runtime validation of the payload of the emitted events:\n\nAlthough optional, it is recommended to define all emitted events in order to better document how a component should work. It also allows Vue to exclude known listeners from fallthrough attributes, avoiding edge cases caused by DOM events manually dispatched by 3rd party code.\n\nSimilar to prop type validation, an emitted event can be validated if it is defined with the object syntax instead of the array syntax.\n\nTo add validation, the event is assigned a function that receives the arguments passed to the call and returns a boolean to indicate whether the event is valid or not."
    },
    {
        "link": "https://ni4yja.medium.com/parent-child-communication-in-vue-from-child-to-parent-9d9d9d353a09",
        "document": "I chose the Star Wars theme just before the war started, kind of prophetic, don’t you think? Relation between Luke and his father is dramatic and recognizable, and I wanted to use it in my small project about components’ communication in Vue. There are two components — and . The child has a text field for a message, which should be sent to its parent and displayed in it. How to achieve this?\n\nWe need to use , which allows us to send custom events from a child component to its parent. Each Vue call can pass two arguments: the event name and a payload object (optional). Let’s check how it works on the real-world example. In my codesandbox (visit this link to play around with code), the parent component listens for a custom event and confers the received value to its data:\n\nNow we need our child component to listen for the native input event and then emit its event. To pass the value of our original change event, we need to send our custom event with the event payload — in this case, the — as a second parameter. It looks like this:\n\nThat’s all the magic. The message from the child component is displayed in its parent. Note, that this is an example of emitting inline events in Vue. If you are curious about other ways of using in your code, watch this video. Thanks for reading. Stay tuned."
    },
    {
        "link": "https://blog.bitsrc.io/vue-js-3-3s-definemodel-enhancing-parent-child-component-communication-d43eca5cb089",
        "document": "In older versions of Vue.js, creating a Vue element with two-way binding demanded two distinct steps. Initially, the element had to declare a property to accept data from the parent. Subsequently, it needed to emit an update event with a corresponding name to notify the parent when the data was updated. This process involved boilerplate code and added complexity to element development.\n\nHowever, with the release of Vue.js 3.3 “Rurouni Kenshin”, developers can now take advantage of the defineModel macro. This macro significantly simplifies the process of bidirectional binding.\n\nInstead of manually declaring a prop and emitting an update event, the defineModel macro handles these tasks automatically. Let’s take a look at an example of how two-way binding was implemented before and how it is achieved with the macro:\n\nTwo-way binding is established when the parent component passes the prop to the child component using the attribute , and the child component emits update events to the parent component using the function.\n\nIn this specific case, the presented code uses to create a numerical model that will be shared between the parent component and the child component. As you can see, the new approach is much cleaner and more straightforward. Instead of explicitly declaring the prop and emitting an event, the macro automatically registers the prop and returns a reference that can be directly changed, providing a continuous bidirectional data-binding experience.\n\nSuppose we have a parent component that needs to communicate with a child component using multiple bidirectional bindings. We will use three props: , , and . The parent component will send updated values for these props to the child component, and the child component will be able to modify and send back updated values.\n\nBy utilizing reactive variables and props, we unlock the potential of efficient bidirectional communication between ParentComponent and ChildComponent. This powerful feature ensures seamless data synchronization between the components, enabling a cohesive and synchronized user experience. Let’s delve into the mechanics of this approach and witness its effectiveness in action.\n• In the , we define three reactive variables: , , and using . Next, we pass these variables to using , which sets up the bidirectional binding between the parent and child components.\n• In , we use the macro to create three props: , , and . The macro automatically registers these props and returns a , allowing for direct mutation of the prop values. We also log the value to the console for demonstration purposes. receives the , , and props from the parent.\n\nWhen the buttons in the child component are clicked, the and values are incremented, reflecting the changes in the parent component as well. The input field allows the parent and child components to synchronize the value.\n\n💡 If you want to get the most out of Vue.js 3.3, you could consider using tools such as Bit. With Bit, you can pack your Vue.js components into packages and independently test, document, version and publish them to Bit’s component-storage platform, from where you can share and reuse your components across multiple projects with a simple command.\n\nThe use of multiple communications through the and features between and enables efficient and bidirectional synchronization of data. By creating reactive variables in and defining props using the macro in , we establish a direct connection that allows for updating values in both components.\n\nThis approach provides a smooth and real-time interaction between the components, allowing changes made in either of them to be instantly reflected in the other. This architecture of communication promotes modularity and code reusability while ensuring a more objective and interactive developer experience. The flexibility provided by this communication mechanism makes Vue.js application development more efficient and effective."
    },
    {
        "link": "https://vuejs.org/guide/components/provide-inject",
        "document": "Usually, when we need to pass data from the parent to a child component, we use props. However, imagine the case where we have a large component tree, and a deeply nested component needs something from a distant ancestor component. With only props, we would have to pass the same prop across the entire parent chain:\n\nNotice although the component may not care about these props at all, it still needs to declare and pass them along just so can access them. If there is a longer parent chain, more components would be affected along the way. This is called \"props drilling\" and definitely isn't fun to deal with.\n\nWe can solve props drilling with and . A parent component can serve as a dependency provider for all its descendants. Any component in the descendant tree, regardless of how deep it is, can inject dependencies provided by components up in its parent chain.\n\nTo provide data to a component's descendants, use the function: If not using , make sure is called synchronously inside : The function accepts two arguments. The first argument is called the injection key, which can be a string or a . The injection key is used by descendant components to lookup the desired value to inject. A single component can call multiple times with different injection keys to provide different values. The second argument is the provided value. The value can be of any type, including reactive state such as refs: Providing reactive values allows the descendant components using the provided value to establish a reactive connection to the provider component.\n\nTo provide data to a component's descendants, use the option: For each property in the object, the key is used by child components to locate the correct value to inject, while the value is what ends up being injected. If we need to provide per-instance state, for example data declared via the , then must use a function value: // use function syntax so that we can access `this` However, do note this does not make the injection reactive. We will discuss making injections reactive below.\n\nIn addition to providing data in a component, we can also provide at the app level:\n\nApp-level provides are available to all components rendered in the app. This is especially useful when writing plugins, as plugins typically wouldn't be able to provide values using components.\n\nTo inject data provided by an ancestor component, use the option: Injections are resolved before the component's own state, so you can access injected properties in : If multiple parents provide data with the same key, inject will resolve to the first parent in its parent chain. When using the array syntax for , the injected properties are exposed on the component instance using the same key. In the example above, the property was provided under the key , and injected as . The local key is the same as the injection key. If we want to inject the property using a different local key, we need to use the object syntax for the option: Here, the component will locate a property provided with the key , and then expose it as .\n\nBy default, assumes that the injected key is provided somewhere in the parent chain. In the case where the key is not provided, there will be a runtime warning.\n\nIf we want to make an injected property work with optional providers, we need to declare a default value, similar to props:\n\n// `value` will be \"default value\" // if no data matching \"message\" was provided In some cases, the default value may need to be created by calling a function or instantiating a new class. To avoid unnecessary computation or side effects in case the optional value is not used, we can use a factory function for creating the default value: The third parameter indicates the default value should be treated as a factory function.\n\nWhen using reactive provide / inject values, it is recommended to keep any mutations to reactive state inside of the provider whenever possible. This ensures that the provided state and its possible mutations are co-located in the same component, making it easier to maintain in the future. There may be times when we need to update the data from an injector component. In such cases, we recommend providing a function that is responsible for mutating the state: Finally, you can wrap the provided value with if you want to ensure that the data passed through cannot be mutated by the injector component.\n\nSo far, we have been using string injection keys in the examples. If you are working in a large application with many dependency providers, or you are authoring components that are going to be used by other developers, it is best to use Symbol injection keys to avoid potential collisions.\n\nIt's recommended to export the Symbols in a dedicated file:"
    },
    {
        "link": "https://codemag.com/Article/2101091/The-Complete-Guide-to-Provide-Inject-API-in-Vue-3-Part-1",
        "document": "By Bilal Haidar\n\n Published in: CODE Magazine: 2021 - January/February\n\n Last updated: January 31, 2025\n\nThis is the first article of two on the topic of developing Vue 3 plug-ins. With the introduction of the Composition API, developing plug-ins in Vue 3 has dramatically changed, for the better, as is expected. Now you have the option of developing plug-ins that only work with the new Composition API or you can still use the old method of developing plug-ins to incorporate the new Application API that supports the Options API. This also provides your plug-in functionality via the Provide/Inject API to support the Composition API.\n\nThe Composition API is optional and can be added. Therefore, be careful when developing a Vue 3 plug-in with it. You need to support apps that still use the Options API while making it compatible with the new Composition API.\n\nToday, I'm providing you with a complete guide to understanding and using the Provide/Inject API in Vue 3. It constitutes the core that Vue 3 plug-ins are built on. Building on this knowledge, I'll look at how to build a Vue 3 plug-in that supports both the Options API and the Composition API in the next article.\n\nWhen you write HTML markup, you define attributes on your HTML elements. Examples of attributes are the ID, NAME, and other headings. The browser then parses the HTML and creates a Document Object Model (DOM) in JavaScript. It converts the HTML attributes to properties on the DOM objects. The properties of a single DOM relate to attributes with the same or similar names, but it's not a one-to-one relationship.\n\nThe concept of Vue Props relates to the HTML attributes and DOM properties.\n\nVue promotes building up single page apps (SPAs) by composing components inside each other in a tree-form. A parent component passes data to its child components by using properties.\n\nA Vue or property is a custom attribute that you add on a Vue component and bind to some sort of data. The binding can be static when you set the value of a property to a static data. It can also be dynamic by setting the value to a variable that you define inside the component. Irrespective of this, the child components receive their data via properties.\n\nA Vue component uses the property to receive any set of properties from the parent component. A line of code is worth a thousand words. Listing 1 shows how you define a property on a Vue component. Figure 1 illustrates the one-way data flow in Vue.\n\n, by nature, are reactive. This means that when you change the value binding of a , the new value is propagated to the child components automatically. In turn, Vue detects a change in component properties and re-renders all affected components. Most probably, the affected components are the child components themselves.\n\nHowever, in some cases the parent component uses those same properties that you pass to the child components. It uses them inside the component source code or inside the component markup. In this case, the parent component is also re-rendered. A parent component re-rendering causes the re-rendering of the entire tree of components inside it.\n\nTo learn more about Vue Props, check out the official documentation (https://v3.vuejs.org/guide/component-props.html).\n\nNow that you're familiar with Vue Props, how to define and use them inside your components, and how they function internally, let's move on and discuss the Prop Drilling problem. React ecosystem first coined this term and now it's a common problem among Vue developers.\n\nBefore diving in, let's consider and note three important Vue concepts that are essential to understand the problem at hand.\n• You build a Vue app by composing components inside each other to form a tree of components.\n• Parent components use properties to pass data to their child components.\n• Component properties are reactive. The moment the parent component mutates the data, Vue re-renders all the child components that use the data.\n\nProp Drilling happens when a parent component wants to pass down some properties to deeply nested components in the component hierarchy. The middle component(s) has no need for these properties but passes them down to the target component(s) that need these properties.\n\nImagine that the component in Figure 2 holds the property that Component F needs in order to render its UI. Every time the component changes that property, Vue passes the new property value down to Component F and, at the same time, it re-renders the entire component hierarchy including Component F itself. This re-rendering includes components B, D, and F all together. In fact, only Component F should re-render.\n\nThis is just a sample component hierarchy. In medium and large apps, there might be several layers of such components that need to be re-rendered along the way. The app performance might be highly affected and that's something you want to avoid.\n\nVue offers a couple of ways to overcome the Prop Drilling problem. Vuex and Provide/Inject API are two.\n\nVuex is a state management library for Vue. It serves as a centralized store for all the components in an app, with rules ensuring that the state can only be mutated in a predictable fashion. Literally any component in the app can query the store inside Vuex and locate the data. Whether you allow every component to access the store or not or whether you are using smart vs. dumb components is up to you. That's another topic for another day.\n\nPersonally, I'd employ Vuex in a bigger app where there are a hundred or more components interacting to form the apps function. The next section introduces an alternative to Vuex for small/medium apps that you can use right away.\n\nYou can learn and read more about Vuex by checking their official website (https://vuex.vuejs.org/guide).\n\nThe Provide/Inject API in Vue is equivalent to the Context API in React development. This concept is based on two main elements: The Dependency Provider and Dependency Consumer. Figure 3 shows a schematic of this concept.\n\nIn this scenario, the component takes the role of the dependency provider. It provides the dependency property. Component F takes the role of the dependency injector. It injects the property.\n\nThe parent component provides a dependency, let's say a property, and somewhere within the same parent chain, a descendent component(s) injects the property and makes use of it. Regardless of how deep the component hierarchy is, if the provider and descendant components are in the same hierarchy, this mechanism works perfectly.\n\nA Vue app using the Provide/Inject API has better performance metrics as Vue re-renders only the affected descendent components and not all the components along the component hierarchy.\n\nBack to Figure 3, when the component, which is the provider component in this case, changes the property value, Vue only re-renders Component F. Component F is the only component using this property. So, the rest of the components inside the hierarchy are left as they are without re-rendering. That's an important reason to use the Provide/Inject API in your apps.\n\nOne last note before closing about reactivity. The dependency property the component provides by default is not reactive. Therefore, you must wrap the content of the provided property by Vue 3 function. This way, when the component changes the provided property, the component automatically injecting this dependency reacts to this change.\n\nIn the next sections, I'll go through live examples on using the Provide/Inject API. You can learn and read more about Provide/Inject API by checking the official documentation (https://v3.vuejs.org/guide/component-provide-inject.html).\n\nLet's go through an example demonstrating the concept of Prop Drilling and see how Vue re-renders all components inside the component hierarchy.\n\nThe example code is an imaginary app that displays a collection of cat images using an external third-party API. Figure 4 shows the component hierarchy of the app.\n\nThis consists of the , , and components. The component lives inside the component. Two instances of the component live inside the .\n\nYou can play with this sample app here: https://stackblitz.com/edit/vue3-prop-drilling.\n\nThe goal is to store some state inside the component that both components need to render their UI. For this app, the state is an object that tracks the third-party Cat API authorization key and Search API URL.\n\nThe component accepts a property to receive the state from the parent App component. In turn, the component defines a property to receive the state from the parent component. The component acts as a mediator that receives the state from the component and passes it down to both instances of the components.\n\nThe component renders a single instance of the component and passes to it a single property named . It binds the property to a variable named that it defines on the data option as follows:\n\nThe settings data variable consists of the and properties.\n\nLet's move on to check the component.\n\nThe component renders two different instances of the component. For each instance, it passes down the property and the property that represents the number of the component instance.\n\nThe receives the property from the parent component. It defines the property as follows:\n\nThe property is of type . The component receives this property and passes it down to the component without using it inside its markup.\n\nFinally, the component. It defines the following markup:\n\nIt makes use of an HTML element to display a single image. It binds the source of the image to the property. It defines a property named that it receives from the parent component. In addition, it uses the lifecycle hook to query the Cats API for a new image to display.\n\nListing 2 shows the entire source code of this component. You can learn more about Vue Lifecycle Hooks by checking their online documentation (https://v3.vuejs.org/guide/composition-api-lifecycle-hooks.html#lifecycle-hooks).\n\nNow that you understand the internal code of the sample app, let's add a button inside the App component to trigger a change on the property it holds.\n\nThe button defines a event handler that sets the property to an empty string.\n\nIn addition, let's register the lifecycle hook on the component. Vue triggers this hook when the data changes, before the DOM is patched. This way, you can track when Vue re-renders this component.\n\nLet's add the same hook onto both the and components.\n\nFinally, let's the property inside the component so that when its value changes, the component triggers a new call to the Cats API to retrieve a new cat image.\n\nNow let's run the app and check the console logs to understand how Vue reacts to this change and how it re-renders the affected components. Click the Change Props button and check the logs. Figure 6 shows the logs.\n\nThe component is re-rendered. This happens because the App component changes the settings property and at the same time it's binding it to the property on the component. The component is also re-rendered despite the fact that it's not using this property but instead is just passing it over to the two component instances.\n\nClearly, the Prop Drilling problem prevails in this example. A parent component passes down the property to the middle one in the hierarchy. It passes the property down to a child component without making use of it inside the middle one's markup. The target component uses the property. The Prop Drilling forces Vue to re-render the middle component, even though it's just a carrier to the property and isn't using it internally.\n\nNext, we'll look at how to fix this problem by using the Provide/Inject API.\n\nIn this section, I'll be using the Provide/Inject API in Vue 3 to overcome the side-effects of Prop Drilling when passing data from a parent component to another nested deeply in the component hierarchy.\n\nFirst, I start by using the Provide/Inject API in the Option API. Then, I use the Provide/Inject API available in the new Composition API. You can read about the new Composition API by checking Shawn Wildermuth's article in CODE Magazine about Vue's Composition API.\n\nUsing the Provide/Inject API in the Options API\n\nVue offers the option as part of its Option API. In this section, I'll use this option to provide the property.\n\nLocate the component and replace its markup with the following:\n\nIt uses an instance of the component without passing any properties.\n\nNow let's provide the property via the provide option inside the component. Add the following option inside the component:\n\nVue offers two forms for using the provide option. Either you define the provide option as an object with properties, or you define it as a function returning an object. The latter gives you more flexibility in terms of defining what data you want to provide and making the provided data reactive.\n\nBy default, the data you provide is not reactive. This means, if the data you provide changes inside the dependency provider component, the new changes won't be reflected inside the dependency injector component.\n\nTo make the data reactive, start by using the provide option as a function. Then, wrap your data inside a function to make it reactive and read-only.\n\nThe code uses the function that belongs to the new reactive Composition API library in Vue 3. Vue 3 internally implements the property using the reactivity API. The function returns a property that's an instance of the object. Read about Computed properties in Vue by checking their official documentation. (https://v3.vuejs.org/guide/computed.html).\n\nSo far, the component provides a property named . Let's move on to the component.\n\nThe component receives no more properties from the parent component. Its markup now looks like this:\n\nThe only property it passes to the component is the property. Nothing interesting really.\n\nLet's move on to the component. It uses the same markup as before. However, let's see how it injects the property. It uses the inject option to receive what the component provides.\n\nThe component, as you now know, provides the property as a property. It uses the function that belongs to the Composition API inside the Options API, the option in this case. That's why you access this property differently in this situation. Let's check how.\n\nLet's change the function like so:\n\nThe code now watches the property and not only settings. I mentioned previously that Vue 3 returns an instance of object for any property. Internally, this object makes use of the object. Therefore, you access the value of a object, and consequently a property, by accessing its property.\n\nThis is only valid for the scenario where you make use of the new Composition API objects inside the Options API. For all computed properties that you define with the Options API, you continue to access their values by using the name of the property only. The same applies when you are using the Composition API alone.\n\nNow, back to the component. The code now monitors any changes on the provided property and loads a new image accordingly.\n\nFinally, you change the function to use the new property as follows:\n\nNotice how the function now accesses the to get the Cats API details. Listing 3 shows the entire source code of this component.\n\nNow let's run the app and check the console logs to understand how Vue reacts to this change and how it re-renders the affected components only.\n\nClick the Change Props button and check the logs. Figure 7 shows the logs.\n\nVue re-renders only the FavoriteCat component. No other components are affected across the component hierarchy. This is the ultimate solution you're after, with some help from the Provide/Inject API, of course. You can play with this sample app here: ( https://stackblitz.com/edit/vue3-prop-drilling-provide-inject).\n\nUsing the Provide/Inject API in the Composition API\n\nNow that you know how to solve the problem of Prop Drilling inside the Options API, let's switch gears and learn how to overcome Prop Drilling when using only the Composition API in Vue 3.\n\nStarting at the component, paste the following inside the markup section:\n\nThe component uses the CatsCollection component and the button click-event handler now calls a new function named .\n\nAdd a new function to the component. It sits at the core of the new Composition API and provides all the functionality of the component. Listing 4 shows the entire source code of this function. The function starts by defining a settings property by using the function to wrap the object. It then provides the settings object via the function. Once again, the component provides the object via a property to ensure any changes inside the component are propagated into the entire component hierarchy.\n\nThe function then defines the function to change the value of the settings object. This is the same function that the button above uses to trigger a change on the settings data. Finally, the function returns an object with the exposed items to the markup. In this case, it's just the function.\n\nThat's all that you must add to the component to provide the property when using the Composition API.\n\nThe component remains the same without any change. Let's move on to the component and study its changes to adapt to the Composition API.\n\nAll of the functionality inside the component is now encapsulated inside the function. Listing 5 shows the entire source code of this function. The function starts by injecting the property via the function.\n\nAs a reminder, the settings variable represents a computed property and therefore, to access its value, you should access the property on this object.\n\nIt then defines a new object to hold the image URL that the component retrieves from the remote Cats API.\n\nThe function makes use of the lifecycle hook to load the image for the first time.\n\nYou can learn more about using the lifecycle hooks in Vue 3 Composition API by checking their official documentation (https://v3.vuejs.org/api/composition-api.html#lifecycle-hooks).\n\nThe function makes use of the function to monitor and react to any changes on the injected property.\n\nThe function in the Composition API works the same as in the Options API. The first parameter is an function that returns the property to watch. In this case, it's the property. Whenever the component changes the property, the component is notified on the spot via the handler. You can read more about the function in the Composition API by checking their official documentation (https://v3.vuejs.org/api/computed-watch-api.html#watch).\n\nFinally, the function returns an object to expose its functionality into the markup section of the component.\n\nIt returns the as a computed property wrapping the property that it receives from the component. It also returns to the markup reactive property that holds the image URL to display.\n\nTo recap on the function, Vue calls it with two input parameters: and . The parameter is just a copy of the object that you define on the component itself. Whatever properties the component receives are also available to the function. The property contains additional data like attrs, slots, and . Learn about the function in the Composition API by checking their official documentation (https://v3.vuejs.org/api/composition-api.html#setup).\n\nNow let's run the app and check the console logs to understand how Vue reacts to this change and how it re-renders the affected components only.\n\nClick the Change Props button and check the logs. Figure 8 shows the logs.\n\nVue re-renders only the component. No other components are affected across the component hierarchy. Once again, you're solving the problem of Prop Drilling by using the Provide/Inject API inside the new Composition API. You can play with this sample app here: (https://stackblitz.com/edit/vue3-prop-drilling-composition-api-provide-inject.\n\nThe Provide/Inject API in Vue 3 is a major building block in managing state in your app. In small or even medium apps, you can use the Provide/Inject API to manage the state at different levels inside the component hierarchy. You might opt to skip Vuex depending on the requirements and the complexity of the app at hand.\n\nProvide/Inject API helps modularize your app in terms of managing the state at different layers of the component hierarchy. Providing data at the App component makes the state available globally across all components in the app. Depending on your needs and requirements, you can provide data at different levels inside the app.\n\nIn the next article, I'll be using the Provide/Inject API inside a custom Vue 3 plug-in. The plug-in will provide global state at the app level to allow all the components in the hierarchy to inject and access the state."
    },
    {
        "link": "https://dev.to/jacobandrewsky/how-to-use-provideinject-in-vue-3bob",
        "document": "How to Use Provide/Inject in Vue\n\nTop 10 Vue.js libraries you should be using in 2025\n\nVue’s Provide/Inject API is a powerful feature that allows components to share data without prop drilling. This makes it an excellent choice for managing dependencies between deeply nested components while keeping code clean and maintainable.\n\nIn this article, we’ll explore how to use the Provide/Inject API effectively, along with best practices and common pitfalls.\n\nThe Provide/Inject API enables parent components to provide data or methods that can be accessed by their descendant components, no matter how deeply nested they are. Unlike Vuex or Pinia, this API is not meant for global state management but rather for local component hierarchies.\n\nThe function is used in a parent component to make data available to its descendants.\n\n\n\nIn this example, we use to share a reactive reference ( ) with child components.\n\nTo consume the provided data in a child component, we use the function.\n\n\n\nThis allows the child component to access and display the value of from its ancestor component.\n\n🟢 Best Practices and Common Issues for Provide/Inject\n\nWhen using Provide/Inject, you may encounter following issues:\n• Forgetting Reactivity - Values provided using are not automatically reactive unless wrapped in or . If updates are not reflecting, ensure your data is reactive.\n• Overcomplicating Component Hierarchies - If you find yourself using Provide/Inject across many levels, consider restructuring your components to keep dependencies more local.\n\nSo, always remember to follow these best practices:\n\n1.Use Provide/Inject for Contextual Dependencies - Provide/Inject is best suited for sharing dependencies like form contexts, themes, or service instances, rather than global state management. If multiple components rely on the same data structure, consider Vuex or Pinia.\n\n 2.Use Reactive Data When Needed - Since passes values by reference, you may need to use or to ensure reactivity.\n\n\n\n3.Provide Defaults for Injected Values - To prevent errors when an injected value is missing, use a default value in .\n\n\n\n4.Avoid Overusing Provide/Inject - While convenient, excessive use of Provide/Inject can make code harder to trace. Use it only when it simplifies component communication.\n\nIf you would like to learn more about Vue, Nuxt, JavaScript or other useful technologies, checkout VueSchool by clicking this link or by clicking the image below:\n\nIt covers most important concepts while building modern Vue or Nuxt applications that can help you in your daily work or side projects 😉\n\nVue’s Provide/Inject API is a great way to manage dependencies between nested components without unnecessary prop drilling. By following best practices and being mindful of its limitations, you can effectively use it to improve your Vue application’s structure and maintainability.\n\nTake care and see you next time!\n\nAnd happy coding as always 🖥️"
    },
    {
        "link": "https://reddit.com/r/vuejs/comments/13rl6ms/best_way_to_pass_data_when_dealing_with_deeply",
        "document": "I have a Vue 3 project with deeply nested components. Let's say I have Component A which uses Component B which uses Component C etc. all the way to Component F. In Component F some data is generated (let's say via an API) which is needed in Component A. The way I do it now (with the options API) is emitting all that data to the direct parent (which is Component E) and then working my way up all the way to Component A.\n\nThis way of data handling is quite cumbersome because I have to pass it through all those intermediate components. The same is true when I want to pass something from Component A to Component F through properties. I don't like this, because it makes the code unmaintainable and I'm losing overview and structure.\n\nCan someone point me in the right direction with an example how to do this differently? I know the Composition API fixes this issue with the inject and provide methods but as it seems now my company isn't willing to migrate all this code to the Composition API version due to time and budget restrictions.\n\nEDIT: Apparantly you don't need the Composition API to use inject and provide. Didn't knew that."
    },
    {
        "link": "https://codingexplorations.com/blog/understanding-the-provideinject-feature-in-vue-3-a-deep-dive",
        "document": "Vue 3, the latest version of the popular JavaScript framework, comes with an array of features designed to make the development of modern web applications more efficient and intuitive. Among these features, the and mechanism stands out for its ability to facilitate communication and data sharing between components, especially in deeply nested structures. This blog post aims to shed light on how the and feature works in Vue 3, enriched with code examples to ensure a comprehensive understanding.\n• None What is the provide function in Vue 3?\n• None What is the difference between provide and inject in Vue?\n• None What is the difference between props and provide inject?\n• None What is the default value of provide inject?\n\nIn Vue.js, the and feature is a powerful tool for passing data and methods from parent components down to their descendants without having to prop-drill (passing props down the component tree through every layer). This feature is particularly useful in scenarios where you have deeply nested components or when you're building a large-scale application that requires a more efficient way to share data across components.\n\nHow Does it Work?\n\nThe function is used in a parent component to define the data or methods it wishes to share with its child components, regardless of the depth of nesting. The function is then used in any descendant component that needs access to this data or methods.\n\nIn Vue 3, the method can be defined inside the function of a component, making it part of the Composition API. This method allows you to specify a unique identifier for the data or methods you wish to provide to descendant components."
    }
]