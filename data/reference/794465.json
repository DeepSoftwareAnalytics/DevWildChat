[
    {
        "link": "https://docs.python.org/3/howto/sorting.html",
        "document": "Python lists have a built-in method that modifies the list in-place. There is also a built-in function that builds a new sorted list from an iterable.\n\nIn this document, we explore the various techniques for sorting data using Python.\n\nA simple ascending sort is very easy: just call the function. It returns a new sorted list: You can also use the method. It modifies the list in-place (and returns to avoid confusion). Usually it’s less convenient than - but if you don’t need the original list, it’s slightly more efficient. Another difference is that the method is only defined for lists. In contrast, the function accepts any iterable.\n\nBoth and have a key parameter to specify a function (or other callable) to be called on each list element prior to making comparisons. \"This is a test string from Andrew\" ['a', 'Andrew', 'from', 'is', 'string', 'test', 'This'] The value of the key parameter should be a function (or other callable) that takes a single argument and returns a key to use for sorting purposes. This technique is fast because the key function is called exactly once for each input record. A common pattern is to sort complex objects using some of the object’s indices as keys. For example: The same technique works for objects with named attributes. For example: Objects with named attributes can be made by a regular class as shown above, or they can be instances of or a named tuple.\n\nThe key function patterns shown above are very common, so Python provides convenience functions to make accessor functions easier and faster. The module has , , and a function. Using those functions, the above examples become simpler and faster: The operator module functions allow multiple levels of sorting. For example, to sort by grade then by age: The module provides another helpful tool for making key-functions. The function can reduce the arity of a multi-argument function making it suitable for use as a key-function.\n\nSorts are guaranteed to be stable. That means that when multiple records have the same key, their original order is preserved. Notice how the two records for blue retain their original order so that is guaranteed to precede . This wonderful property lets you build complex sorts in a series of sorting steps. For example, to sort the student data by descending grade and then ascending age, do the age sort first and then sort again using grade: This can be abstracted out into a wrapper function that can take a list and tuples of field and order to sort them on multiple passes. The Timsort algorithm used in Python does multiple sorts efficiently because it can take advantage of any ordering already present in a dataset.\n\nThis idiom is called Decorate-Sort-Undecorate after its three steps:\n• None First, the initial list is decorated with new values that control the sort order.\n• None Second, the decorated list is sorted.\n• None Finally, the decorations are removed, creating a list that contains only the initial values in the new order. For example, to sort the student data by grade using the DSU approach: This idiom works because tuples are compared lexicographically; the first items are compared; if they are the same then the second items are compared, and so on. It is not strictly necessary in all cases to include the index i in the decorated list, but including it gives two benefits:\n• None The sort is stable – if two items have the same key, their order will be preserved in the sorted list.\n• None The original items do not have to be comparable because the ordering of the decorated tuples will be determined by at most the first two items. So for example the original list could contain complex numbers which cannot be sorted directly. Another name for this idiom is Schwartzian transform, after Randal L. Schwartz, who popularized it among Perl programmers. Now that Python sorting provides key-functions, this technique is not often needed.\n\nUnlike key functions that return an absolute value for sorting, a comparison function computes the relative ordering for two inputs. For example, a balance scale compares two samples giving a relative ordering: lighter, equal, or heavier. Likewise, a comparison function such as will return a negative value for less-than, zero if the inputs are equal, or a positive value for greater-than. It is common to encounter comparison functions when translating algorithms from other languages. Also, some libraries provide comparison functions as part of their API. For example, is a comparison function. To accommodate those situations, Python provides to wrap the comparison function to make it usable as a key function:\n• None For locale aware sorting, use for a key function or for a comparison function. This is necessary because “alphabetical” sort orderings can vary across cultures even if the underlying alphabet is the same.\n• None The reverse parameter still maintains sort stability (so that records with equal keys retain the original order). Interestingly, that effect can be simulated without the parameter by using the builtin function twice:\n• None The sort routines use when making comparisons between two objects. So, it is easy to add a standard sort order to a class by defining an method: However, note that can fall back to using if is not implemented (see for details on the mechanics). To avoid surprises, PEP 8 recommends that all six comparison methods be implemented. The decorator is provided to make that task easier.\n• None Key functions need not depend directly on the objects being sorted. A key function can also access external resources. For instance, if the student grades are stored in a dictionary, they can be used to sort a separate list of student names:"
    },
    {
        "link": "http://python-reference.readthedocs.io/en/latest/docs/functions/sorted.html",
        "document": "In general, the key and reverse conversion processes are much faster than specifying an equivalent cmp function. This is because cmp is called multiple times for each list element while key and reverse touch each element only once. Use functools.cmp_to_key() to convert an old-style cmp function to a key function. For sorting examples and a brief sorting tutorial, see Sorting HowTo."
    },
    {
        "link": "https://docs.python.org/3.10/howto/sorting.html",
        "document": "Python lists have a built-in method that modifies the list in-place. There is also a built-in function that builds a new sorted list from an iterable.\n\nIn this document, we explore the various techniques for sorting data using Python.\n\nA simple ascending sort is very easy: just call the function. It returns a new sorted list: You can also use the method. It modifies the list in-place (and returns to avoid confusion). Usually it’s less convenient than - but if you don’t need the original list, it’s slightly more efficient. Another difference is that the method is only defined for lists. In contrast, the function accepts any iterable.\n\nBoth and have a key parameter to specify a function (or other callable) to be called on each list element prior to making comparisons. \"This is a test string from Andrew\" ['a', 'Andrew', 'from', 'is', 'string', 'test', 'This'] The value of the key parameter should be a function (or other callable) that takes a single argument and returns a key to use for sorting purposes. This technique is fast because the key function is called exactly once for each input record. A common pattern is to sort complex objects using some of the object’s indices as keys. For example: The same technique works for objects with named attributes. For example:\n\nThe key-function patterns shown above are very common, so Python provides convenience functions to make accessor functions easier and faster. The module has , , and a function. Using those functions, the above examples become simpler and faster: The operator module functions allow multiple levels of sorting. For example, to sort by grade then by age:\n\nSorts are guaranteed to be stable. That means that when multiple records have the same key, their original order is preserved. Notice how the two records for blue retain their original order so that is guaranteed to precede . This wonderful property lets you build complex sorts in a series of sorting steps. For example, to sort the student data by descending grade and then ascending age, do the age sort first and then sort again using grade: This can be abstracted out into a wrapper function that can take a list and tuples of field and order to sort them on multiple passes. The Timsort algorithm used in Python does multiple sorts efficiently because it can take advantage of any ordering already present in a dataset.\n\nThe Old Way Using Decorate-Sort-Undecorate¶ This idiom is called Decorate-Sort-Undecorate after its three steps:\n• None First, the initial list is decorated with new values that control the sort order.\n• None Second, the decorated list is sorted.\n• None Finally, the decorations are removed, creating a list that contains only the initial values in the new order. For example, to sort the student data by grade using the DSU approach: This idiom works because tuples are compared lexicographically; the first items are compared; if they are the same then the second items are compared, and so on. It is not strictly necessary in all cases to include the index i in the decorated list, but including it gives two benefits:\n• None The sort is stable – if two items have the same key, their order will be preserved in the sorted list.\n• None The original items do not have to be comparable because the ordering of the decorated tuples will be determined by at most the first two items. So for example the original list could contain complex numbers which cannot be sorted directly. Another name for this idiom is Schwartzian transform, after Randal L. Schwartz, who popularized it among Perl programmers. Now that Python sorting provides key-functions, this technique is not often needed.\n\nThe Old Way Using the cmp Parameter¶ Many constructs given in this HOWTO assume Python 2.4 or later. Before that, there was no builtin and took no keyword arguments. Instead, all of the Py2.x versions supported a cmp parameter to handle user specified comparison functions. In Py3.0, the cmp parameter was removed entirely (as part of a larger effort to simplify and unify the language, eliminating the conflict between rich comparisons and the magic method). In Py2.x, sort allowed an optional function which can be called for doing the comparisons. That function should take two arguments to be compared and then return a negative value for less-than, return zero if they are equal, or return a positive value for greater-than. For example, we can do: Or you can reverse the order of comparison with: When porting code from Python 2.x to 3.x, the situation can arise when you have the user supplying a comparison function and you need to convert that to a key function. The following wrapper makes that easy to do: To convert to a key function, just wrap the old comparison function: In Python 3.2, the function was added to the module in the standard library."
    },
    {
        "link": "https://developers.google.com/edu/python/sorting",
        "document": "The easiest way to sort is with the sorted(list) function, which takes a list and returns a new list with those elements in sorted order. The original list is not changed.\n\nIt's most common to pass a list into the sorted() function, but in fact it can take as input any sort of iterable collection. The older list.sort() method is an alternative detailed below. The sorted() function seems easier to use compared to sort(), so I recommend using sorted().\n\nThe sorted() function can be customized through optional arguments. The sorted() optional argument reverse=True, e.g. sorted(list, reverse=True), makes it sort backwards.\n\nFor more complex custom sorting, sorted() takes an optional \"key=\" specifying a \"key\" function that transforms each element before comparison. The key function takes in 1 value and returns 1 value, and the returned \"proxy\" value is used for the comparisons within the sort.\n\nFor example with a list of strings, specifying key=len (the built in len() function) sorts the strings by length, from shortest to longest. The sort calls len() for each string to get the list of proxy length values, and then sorts with those proxy values.\n\nAs another example, specifying \"str.lower\" as the key function is a way to force the sorting to treat uppercase and lowercase the same:\n\nYou can also pass in your own MyFn as the key function, like this:\n\nFor more complex sorting like sorting by last name then by first name, you can use the itemgetter or attrgetter functions like:\n\nAs an alternative to sorted(), the sort() method on a list sorts that list into ascending order, e.g. list.sort(). The sort() method changes the underlying list and returns None, so use it like this:\n\nThe above is a very common misunderstanding with sort() -- it *does not return* the sorted list. The sort() method must be called on a list; it does not work on any enumerable collection (but the sorted() function above works on anything). The sort() method predates the sorted() function, so you will likely see it in older code. The sort() method does not need to create a new list, so it can be a little faster in the case that the elements to sort are already in a list.\n\nA tuple is a fixed size grouping of elements, such as an (x, y) co-ordinate. Tuples are like lists, except they are immutable and do not change size (tuples are not strictly immutable since one of the contained elements could be mutable). Tuples play a sort of \"struct\" role in Python -- a convenient way to pass around a little logical, fixed size bundle of values. A function that needs to return multiple values can just return a tuple of the values. For example, if I wanted to have a list of 3-d coordinates, the natural python representation would be a list of tuples, where each tuple is size 3 holding one (x, y, z) group.\n\nTo create a tuple, just list the values within parenthesis separated by commas. The \"empty\" tuple is just an empty pair of parenthesis. Accessing the elements in a tuple is just like a list -- len(), [ ], for, in, etc. all work the same.\n\nTo create a size-1 tuple, the lone element must be followed by a comma.\n\nIt's a funny case in the syntax, but the comma is necessary to distinguish the tuple from the ordinary case of putting an expression in parentheses. In some cases you can omit the parenthesis and Python will see from the commas that you intend a tuple.\n\nAssigning a tuple to an identically sized tuple of variable names assigns all the corresponding values. If the tuples are not the same size, it throws an error. This feature works for lists too.\n\nList comprehensions are a more advanced feature which is nice for some cases but is not needed for the exercises and is not something you need to learn at first (i.e. you can skip this section). A list comprehension is a compact way to write an expression that expands to a whole list. Suppose we have a list nums [1, 2, 3, 4], here is the list comprehension to compute a list of their squares [1, 4, 9, 16]:\n\nThe syntax is -- the looks like a regular for-loop, but without the colon (:). The expr to its left is evaluated once for each element to give the values for the new list. Here is an example with strings, where each string is changed to upper case with '!!!' appended:\n\nYou can add an if test to the right of the for-loop to narrow the result. The if test is evaluated for each element, including only the elements where the test is true.\n\nTo practice the material in this section, try later problems in list1.py that use sorting and tuples (in the Basic Exercises)."
    },
    {
        "link": "https://docs.python.org/3.9/howto/sorting.html",
        "document": "Python lists have a built-in method that modifies the list in-place. There is also a built-in function that builds a new sorted list from an iterable.\n\nIn this document, we explore the various techniques for sorting data using Python.\n\nA simple ascending sort is very easy: just call the function. It returns a new sorted list: You can also use the method. It modifies the list in-place (and returns to avoid confusion). Usually it’s less convenient than - but if you don’t need the original list, it’s slightly more efficient. Another difference is that the method is only defined for lists. In contrast, the function accepts any iterable.\n\nBoth and have a key parameter to specify a function (or other callable) to be called on each list element prior to making comparisons. \"This is a test string from Andrew\" ['a', 'Andrew', 'from', 'is', 'string', 'test', 'This'] The value of the key parameter should be a function (or other callable) that takes a single argument and returns a key to use for sorting purposes. This technique is fast because the key function is called exactly once for each input record. A common pattern is to sort complex objects using some of the object’s indices as keys. For example: The same technique works for objects with named attributes. For example:\n\nThe key-function patterns shown above are very common, so Python provides convenience functions to make accessor functions easier and faster. The module has , , and a function. Using those functions, the above examples become simpler and faster: The operator module functions allow multiple levels of sorting. For example, to sort by grade then by age:\n\nSorts are guaranteed to be stable. That means that when multiple records have the same key, their original order is preserved. Notice how the two records for blue retain their original order so that is guaranteed to precede . This wonderful property lets you build complex sorts in a series of sorting steps. For example, to sort the student data by descending grade and then ascending age, do the age sort first and then sort again using grade: This can be abstracted out into a wrapper function that can take a list and tuples of field and order to sort them on multiple passes. The Timsort algorithm used in Python does multiple sorts efficiently because it can take advantage of any ordering already present in a dataset.\n\nThe Old Way Using Decorate-Sort-Undecorate¶ This idiom is called Decorate-Sort-Undecorate after its three steps:\n• None First, the initial list is decorated with new values that control the sort order.\n• None Second, the decorated list is sorted.\n• None Finally, the decorations are removed, creating a list that contains only the initial values in the new order. For example, to sort the student data by grade using the DSU approach: This idiom works because tuples are compared lexicographically; the first items are compared; if they are the same then the second items are compared, and so on. It is not strictly necessary in all cases to include the index i in the decorated list, but including it gives two benefits:\n• None The sort is stable – if two items have the same key, their order will be preserved in the sorted list.\n• None The original items do not have to be comparable because the ordering of the decorated tuples will be determined by at most the first two items. So for example the original list could contain complex numbers which cannot be sorted directly. Another name for this idiom is Schwartzian transform, after Randal L. Schwartz, who popularized it among Perl programmers. Now that Python sorting provides key-functions, this technique is not often needed.\n\nThe Old Way Using the cmp Parameter¶ Many constructs given in this HOWTO assume Python 2.4 or later. Before that, there was no builtin and took no keyword arguments. Instead, all of the Py2.x versions supported a cmp parameter to handle user specified comparison functions. In Py3.0, the cmp parameter was removed entirely (as part of a larger effort to simplify and unify the language, eliminating the conflict between rich comparisons and the magic method). In Py2.x, sort allowed an optional function which can be called for doing the comparisons. That function should take two arguments to be compared and then return a negative value for less-than, return zero if they are equal, or return a positive value for greater-than. For example, we can do: Or you can reverse the order of comparison with: When porting code from Python 2.x to 3.x, the situation can arise when you have the user supplying a comparison function and you need to convert that to a key function. The following wrapper makes that easy to do: To convert to a key function, just wrap the old comparison function: In Python 3.2, the function was added to the module in the standard library."
    },
    {
        "link": "https://stackoverflow.com/questions/15410119/use-list-comprehension-to-build-a-tuple",
        "document": "Technically, it's a generator expression. It's like a list comprehension, but it's evaluated lazily and won't need to allocate memory for an intermediate list.\n\nFor completeness, the list comprehension would look like this:\n\nPS: is not faster ( has a million items here):"
    },
    {
        "link": "https://www2.lawrence.edu/fast/GREGGJ/CMSC210/loops/tuples.html",
        "document": "The Python tuple is an alternative to the list structure. The example below shows how to construct a tuple.\n\nUnlike lists, which can have items appended or removed from them via the use of list methods, the tuple is an immutable structure. The tuple in the example above has two items in it: this size is fixed and can never be changed.\n\nYou can access the elements in a tuple using the same index notation you would use with a list.\n\nYou can also update the entries in a tuple by assigning new values to them.\n\nTuples are especially useful in situations where data items belong together and would not make sense by themselves.\n\nHere is an example. The list below shows currency codes for a number of currencies and the exchange rate from US dollars to that currency. The numbers in each case show how many units of the currency one US dollar would buy.\n\nBecause the list spans multiple lines, I have used the Python continuation character, \\, at the end of each line.\n\nSuppose we wanted to write a program that prompts the user to enter a code for a foreign currency and an amount of that currency that the user wants to purchase. The program will compute and print how many US dollars it would take to purchase that many units of the currency. Here some code that will do this.\n\nAn alternative to using the index notation for tuples in a for loop is to use a form of the for loop that assigns each member of a tuple to a different loop variable:\n\nSometimes you will want to combine data from two separate lists into a single list. A common situation where you might want to do this is printing a table.\n\nIn an earlier lecture I showed some code to print a list of data points in a table. Here is the original code.\n\nThis code iterates over a list of index values and uses those index values to access elements of both lists.\n\nAn alternative approach is to construct a zip list from the original pair of lists and just iterate over that. A zip list formed from a pair of lists is a single lists of tuples, with each pair of data items from the original lists becoming one tuple in the zip list. Here is the table printing example rewritten to use a zip list:\n\nA Python list comprehension is a method for constructing a list from a list, a range, or other iterable structure. List comprehensions are frequently used to extract data from other lists or to generate new data from an existing data list.\n\nHere is an example. Suppose we wanted to make a list of just the currency codes from the example above. We could do this by using a combination of a loop and the list append() method.\n\nA list comprehension provides a more compact way to accomplish the same thing.\n\nAnother common application of list comprehensions is making lists from ranges. For example, if we wanted to make a list of powers of 2 we could use the following code:\n\nHere is a more sophisticated example. A currency cross rate is an exchange rate from one currency to another, with an origin currency and a destination currency. We can use our list of US dollar exchange rates to make cross rates for any pair of currencies in the exchange list. For example, if we wanted to set up an exchange from GBP to CNY, we would first convert 1 GBP to 1/0.760425 dollars. We would then convert 1/0.760425 dollars to (1/0.760425)*6.9228 CNY.\n\nHere is a list comprehension that makes a table of all possible cross rates. This is a nested set of list comprehensions, where the outer comprehension uses an inner comprehension to make lists of cross rates, producing a list of lists as the final result.\n\nHere is one final thing we should do with the resulting table. The diagonal entries represent exchanges where the origin currency and the destination currency are the same. We should go in and set all of those cross rates to be exactly 1. Here is a for loop that can do this.\n\nRedo assignment two using tuples. Start your program with the statements\n\nand then do everything else in the rest of the program using the list. Try not to use the list or the list in any of the following code: do everything with the list.\n\nAlso, include at least one list comprehesion in your program. The list of residuals is a good candidate for this: try building this list with a list comprehension instead of a loop."
    },
    {
        "link": "https://geeksforgeeks.org/python-create-a-list-of-tuples",
        "document": "The task of creating a list of tuples in Python involves combining or transforming multiple data elements into a sequence of tuples within a list. Tuples are immutable, making them useful when storing fixed pairs or groups of values, while lists offer flexibility for dynamic collections. For example, given two separate lists like [1, 2, 3] and [‘apple’, ‘orange’, ‘cherry’], the goal is to combine them into a list of tuples like [(1, ‘apple’), (2, ‘orange’), (3, ‘cherry’)].\n\nzip() is the most efficient approach to combine two or more separate lists into a list of tuples. It pairs elements from each list based on their index and stops when the shortest list ends. This method is optimized, making it fast and memory efficient and is preferred for combining data into tuples.\n\nExplanation: zip() pairs elements from lists a and b by index, creating tuples like (a[0], b[0]), (a[1], b[1]), etc. and returns an iterator, which is converted into a list using list().\n\nmap() is the most efficient approach to convert a list of lists into a list of tuples. It applies the tuple() constructor to each sublist, transforming each inner list into a tuple. This approach is optimized, making it faster than list comprehension when working with nested lists. It is highly recommended when transforming list-based data into tuples.\n\nExplanation: map() converts each inner list in a into a tuple by applying tuple() to every sublist. It returns an iterator, which is converted into a list using list().\n\nThis method combines zip() with list comprehension to form a list of tuples. It is slightly less efficient than bare zip() due to the extra comprehension layer, but it offers more flexibility and readability when additional operations need to be performed while pairing data from two lists. It is frequently used for clarity in custom logic scenarios.\n\nExplanation :list comprehension pairs elements from a and b using zip(), forming (x, y) tuples and produces a list of tuples as the result.\n\nThis traditional approach involves iterating through two separate lists using a for loop and append() to build a list of tuples manually. While functional, it is less efficient compared to zip() because Python-level loops introduce overhead. This method is still useful when detailed control over the loop is required, but it is not recommended for simple tuple creation tasks.\n\nExplanation: for loop iterates over indices of a and b using range(len(a)), forming tuples (a[i], b[i]), and appends them to res."
    },
    {
        "link": "https://geeksforgeeks.org/python-list-comprehension",
        "document": "List comprehension is a way to create lists using a concise syntax. It allows us to generate a new list by applying an expression to each item in an existing iterable (such as a list or range). This helps us to write cleaner, more readable code compared to traditional looping techniques.\n\nFor example, if we have a list of integers and want to create a new list containing the square of each element, we can easily achieve this using list comprehension.\n• expression: The transformation or value to be included in the new list.\n• item: The current element taken from the iterable.\n• if condition (optional): A filtering condition that decides whether the current item should be included.\n\nThis syntax allows us to combine iteration, modification, and conditional filtering all in one line.\n\nThe main difference is that a for loop requires multiple lines to create a new list by iterating over items and manually adding each one. Whereas, list comprehension do the same task in a single line, this makes the code simpler and easier to read.\n\nExample: Let’s take an example, where we want to double each number of given list into a new list\n\nExplanation: Create an empty list ‘res‘ to store results and iterate over each element in list ‘a‘ and for each items in list ‘a‘, multiply it by 2 and append it to ‘res‘ using append() method.\n\nExplanation: In the above list comprehension, the iterable is a list ‘a’, and the expression is val * 2, which multiplies each value from the list by 2.\n\nList comprehensions can include conditional statements to filter or modify items based on specific criteria. These conditionals help us create customized lists quickly and making the code cleaner and more efficient.\n\nExample: Suppose we want to filter all even list from the given list.\n\nTo learn more about filtering conditions in list comprehensions, please refer to “Python List Comprehension Using If-Else“\n\nA simple example is creating a list of numbers from 0 to 9.\n\nList comprehension can also be used with nested loops. Here, we generate a list of coordinate pairs for a simple 3×3 grid.\n\nSuppose we have a list of lists and we want to convert it into a single list.\n\nExplanation: The line [val for row in mat for val in row] uses nested list comprehension to iterate through each row in mat. For each row, it iterates through each val in that row and collecting all values into a single list."
    },
    {
        "link": "https://docs.python.org/3/tutorial/datastructures.html",
        "document": "This chapter describes some things you’ve learned about already in more detail, and adds some new things as well.\n\nThe list data type has some more methods. Here are all of the methods of list objects: Add an item to the end of the list. Similar to . Extend the list by appending all the items from the iterable. Similar to . Insert an item at a given position. The first argument is the index of the element before which to insert, so inserts at the front of the list, and is equivalent to . Remove the first item from the list whose value is equal to x. It raises a if there is no such item. Remove the item at the given position in the list, and return it. If no index is specified, removes and returns the last item in the list. It raises an if the list is empty or the index is outside the list range. Remove all items from the list. Similar to . Return zero-based index in the list of the first item whose value is equal to x. Raises a if there is no such item. The optional arguments start and end are interpreted as in the slice notation and are used to limit the search to a particular subsequence of the list. The returned index is computed relative to the beginning of the full sequence rather than the start argument. Return the number of times x appears in the list. Sort the items of the list in place (the arguments can be used for sort customization, see for their explanation). Reverse the elements of the list in place. Return a shallow copy of the list. Similar to . An example that uses most of the list methods: You might have noticed that methods like , or that only modify the list have no return value printed – they return the default . This is a design principle for all mutable data structures in Python. Another thing you might notice is that not all data can be sorted or compared. For instance, doesn’t sort because integers can’t be compared to strings and can’t be compared to other types. Also, there are some types that don’t have a defined ordering relation. For example, isn’t a valid comparison. The list methods make it very easy to use a list as a stack, where the last element added is the first element retrieved (“last-in, first-out”). To add an item to the top of the stack, use . To retrieve an item from the top of the stack, use without an explicit index. For example: It is also possible to use a list as a queue, where the first element added is the first element retrieved (“first-in, first-out”); however, lists are not efficient for this purpose. While appends and pops from the end of list are fast, doing inserts or pops from the beginning of a list is slow (because all of the other elements have to be shifted by one). To implement a queue, use which was designed to have fast appends and pops from both ends. For example: # The first to arrive now leaves # The second to arrive now leaves List comprehensions provide a concise way to create lists. Common applications are to make new lists where each element is the result of some operations applied to each member of another sequence or iterable, or to create a subsequence of those elements that satisfy a certain condition. For example, assume we want to create a list of squares, like: Note that this creates (or overwrites) a variable named that still exists after the loop completes. We can calculate the list of squares without any side effects using: which is more concise and readable. A list comprehension consists of brackets containing an expression followed by a clause, then zero or more or clauses. The result will be a new list resulting from evaluating the expression in the context of the and clauses which follow it. For example, this listcomp combines the elements of two lists if they are not equal: Note how the order of the and statements is the same in both these snippets. If the expression is a tuple (e.g. the in the previous example), it must be parenthesized. # create a new list with the values doubled # apply a function to all the elements # the tuple must be parenthesized, otherwise an error is raised File , line : did you forget parentheses around the comprehension target? # flatten a list using a listcomp with two 'for' List comprehensions can contain complex expressions and nested functions: The initial expression in a list comprehension can be any arbitrary expression, including another list comprehension. Consider the following example of a 3x4 matrix implemented as a list of 3 lists of length 4: The following list comprehension will transpose rows and columns: As we saw in the previous section, the inner list comprehension is evaluated in the context of the that follows it, so this example is equivalent to: which, in turn, is the same as: # the following 3 lines implement the nested listcomp In the real world, you should prefer built-in functions to complex flow statements. The function would do a great job for this use case: See Unpacking Argument Lists for details on the asterisk in this line.\n\nWe saw that lists and strings have many common properties, such as indexing and slicing operations. They are two examples of sequence data types (see Sequence Types — list, tuple, range). Since Python is an evolving language, other sequence data types may be added. There is also another standard sequence data type: the tuple. A tuple consists of a number of values separated by commas, for instance: File , line , in : # but they can contain mutable objects: As you see, on output tuples are always enclosed in parentheses, so that nested tuples are interpreted correctly; they may be input with or without surrounding parentheses, although often parentheses are necessary anyway (if the tuple is part of a larger expression). It is not possible to assign to the individual items of a tuple, however it is possible to create tuples which contain mutable objects, such as lists. Though tuples may seem similar to lists, they are often used in different situations and for different purposes. Tuples are immutable, and usually contain a heterogeneous sequence of elements that are accessed via unpacking (see later in this section) or indexing (or even by attribute in the case of ). Lists are mutable, and their elements are usually homogeneous and are accessed by iterating over the list. A special problem is the construction of tuples containing 0 or 1 items: the syntax has some extra quirks to accommodate these. Empty tuples are constructed by an empty pair of parentheses; a tuple with one item is constructed by following a value with a comma (it is not sufficient to enclose a single value in parentheses). Ugly, but effective. For example: The statement is an example of tuple packing: the values , and are packed together in a tuple. The reverse operation is also possible: This is called, appropriately enough, sequence unpacking and works for any sequence on the right-hand side. Sequence unpacking requires that there are as many variables on the left side of the equals sign as there are elements in the sequence. Note that multiple assignment is really just a combination of tuple packing and sequence unpacking.\n\nPython also includes a data type for sets. A set is an unordered collection with no duplicate elements. Basic uses include membership testing and eliminating duplicate entries. Set objects also support mathematical operations like union, intersection, difference, and symmetric difference. Curly braces or the function can be used to create sets. Note: to create an empty set you have to use , not ; the latter creates an empty dictionary, a data structure that we discuss in the next section. Here is a brief demonstration: # show that duplicates have been removed # Demonstrate set operations on unique letters from two words # letters in a but not in b # letters in a or b or both # letters in both a and b # letters in a or b but not both Similarly to list comprehensions, set comprehensions are also supported:\n\nAnother useful data type built into Python is the dictionary (see Mapping Types — dict). Dictionaries are sometimes found in other languages as “associative memories” or “associative arrays”. Unlike sequences, which are indexed by a range of numbers, dictionaries are indexed by keys, which can be any immutable type; strings and numbers can always be keys. Tuples can be used as keys if they contain only strings, numbers, or tuples; if a tuple contains any mutable object either directly or indirectly, it cannot be used as a key. You can’t use lists as keys, since lists can be modified in place using index assignments, slice assignments, or methods like and . It is best to think of a dictionary as a set of key: value pairs, with the requirement that the keys are unique (within one dictionary). A pair of braces creates an empty dictionary: . Placing a comma-separated list of key:value pairs within the braces adds initial key:value pairs to the dictionary; this is also the way dictionaries are written on output. The main operations on a dictionary are storing a value with some key and extracting the value given the key. It is also possible to delete a key:value pair with . If you store using a key that is already in use, the old value associated with that key is forgotten. It is an error to extract a value using a non-existent key. Performing on a dictionary returns a list of all the keys used in the dictionary, in insertion order (if you want it sorted, just use instead). To check whether a single key is in the dictionary, use the keyword. Here is a small example using a dictionary: The constructor builds dictionaries directly from sequences of key-value pairs: In addition, dict comprehensions can be used to create dictionaries from arbitrary key and value expressions: When the keys are simple strings, it is sometimes easier to specify pairs using keyword arguments:\n\nWhen looping through dictionaries, the key and corresponding value can be retrieved at the same time using the method. When looping through a sequence, the position index and corresponding value can be retrieved at the same time using the function. To loop over two or more sequences at the same time, the entries can be paired with the function. What is your name? It is lancelot. What is your quest? It is the holy grail. What is your favorite color? It is blue. To loop over a sequence in reverse, first specify the sequence in a forward direction and then call the function. To loop over a sequence in sorted order, use the function which returns a new sorted list while leaving the source unaltered. Using on a sequence eliminates duplicate elements. The use of in combination with over a sequence is an idiomatic way to loop over unique elements of the sequence in sorted order. It is sometimes tempting to change a list while you are looping over it; however, it is often simpler and safer to create a new list instead.\n\nThe conditions used in and statements can contain any operators, not just comparisons. The comparison operators and are membership tests that determine whether a value is in (or not in) a container. The operators and compare whether two objects are really the same object. All comparison operators have the same priority, which is lower than that of all numerical operators. Comparisons can be chained. For example, tests whether is less than and moreover equals . Comparisons may be combined using the Boolean operators and , and the outcome of a comparison (or of any other Boolean expression) may be negated with . These have lower priorities than comparison operators; between them, has the highest priority and the lowest, so that A and not B or C is equivalent to (A and (not B)) or C . As always, parentheses can be used to express the desired composition. The Boolean operators and are so-called short-circuit operators: their arguments are evaluated from left to right, and evaluation stops as soon as the outcome is determined. For example, if and are true but is false, A and B and C does not evaluate the expression . When used as a general value and not as a Boolean, the return value of a short-circuit operator is the last evaluated argument. It is possible to assign the result of a comparison or other Boolean expression to a variable. For example, Note that in Python, unlike C, assignment inside expressions must be done explicitly with the walrus operator . This avoids a common class of problems encountered in C programs: typing in an expression when was intended.\n\nSequence objects typically may be compared to other objects with the same sequence type. The comparison uses lexicographical ordering: first the first two items are compared, and if they differ this determines the outcome of the comparison; if they are equal, the next two items are compared, and so on, until either sequence is exhausted. If two items to be compared are themselves sequences of the same type, the lexicographical comparison is carried out recursively. If all items of two sequences compare equal, the sequences are considered equal. If one sequence is an initial sub-sequence of the other, the shorter sequence is the smaller (lesser) one. Lexicographical ordering for strings uses the Unicode code point number to order individual characters. Some examples of comparisons between sequences of the same type: Note that comparing objects of different types with or is legal provided that the objects have appropriate comparison methods. For example, mixed numeric types are compared according to their numeric value, so 0 equals 0.0, etc. Otherwise, rather than providing an arbitrary ordering, the interpreter will raise a exception."
    }
]