[
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/API/Document/querySelectorAll",
        "document": "A string containing one or more selectors to match. This string must be a valid CSS selector string; if it isn't, a exception is thrown. Note that the HTML specification does not require attribute values to be valid CSS identifiers. If a or attribute value is not a valid CSS identifier, then you must escape it before using it in a selector, either by calling on the value, or using one of the techniques described in Escaping characters. See Escaping attribute values for an example.\n\nA non-live containing one object for each element that matches at least one of the specified selectors or an empty in case of no matches. The elements are in document order — that is, parents before children, earlier siblings before later siblings. Note: If the specified include a CSS pseudo-element, the returned list is always empty.\n\nTo obtain a of all of the elements in the document: This example returns a list of all elements within the document with a class of either or : Here, we get a list of elements whose immediate parent element is a with the class and which are located inside a container whose ID is . This example uses an attribute selector to return a list of the elements in the document that contain an attribute named : Here, an attribute selector is used to return a list of the list items contained within a list whose ID is which have a attribute whose value is :\n\nOnce the of matching elements is returned, you can examine it just like any array. If the array is empty (that is, its property is 0), then no matches were found. Otherwise, you can use standard array notation to access the contents of the list. You can use any common looping statement, such as:\n\nThis example shows that if an HTML document contains an which is not a valid CSS identifier, then we must escape the attribute value before using it in . In the following code, a element has an of , which is not a valid CSS identifier, because the character is not allowed in CSS identifiers. We also have three buttons, and a element for logging errors. All three buttons, when clicked, try to select the , and then set its background color to a random value.\n• The first button uses the value directly.\n• The second button escapes the value using .\n• The third button explicitly escapes the character using a backslash. Note that we must also escape the backslash itself, using another backslash, like: . Clicking the first button gives an error, while the second and third buttons work properly."
    },
    {
        "link": "https://w3schools.com/jsref/met_document_queryselectorall.asp",
        "document": "The method returns all elements that matches a CSS selector(s).\n\nThe method throws a SYNTAX_ERR exception if the selector(s) is invalid\n\nA NodeList is an array-like collection (list) of nodes.\n\nThe nodes in the list can be accessed by index. The index starts at 0.\n\nThe length Poperty returns the number of nodes in the list.\n\nAdd a background color to the first <p> element with class=\"example\": Try it Yourself »\n\nSet the background color of all elements with class=\"example\": Try it Yourself »\n\nIt is fully supported in all modern browsers:"
    },
    {
        "link": "https://stackoverflow.com/questions/59662423/using-document-queryselector-to-find-all-links-containing-a-query-string",
        "document": "I have a list of 20+ links across a site. For example:\n\nThey all commonly contain the same query strings.\n\nThe intention is to set attributes through Adobe DTM e.g. open in a new tab. This is currently what I have working for one of the links. However we have 20+ links across the site. Is there a way I can amend this so either it picks up all links that contain this query string or perhaps i can add them as an array and maintain manually? I've tested both but i'm not sure I am doing it correctly as neither work.\n\nAny help would be appreciated. Thanks in advance."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/API/Document/querySelector",
        "document": "The method returns the first within the document that matches the specified CSS selector, or group of CSS selectors. If no matches are found, is returned. The matching is done using depth-first pre-order traversal of the document's nodes starting with the first element in the document's markup and iterating through sequential nodes by order of the number of child nodes. If the specified selector matches an ID that is incorrectly used more than once in the document, the first element with that ID is returned. CSS pseudo-elements will never return any elements, as specified in the Selectors API.\n\nA string containing one or more selectors to match. This string must be a valid CSS selector string; if it isn't, a exception is thrown. Note that the HTML specification does not require attribute values to be valid CSS identifiers. If a or attribute value is not a valid CSS identifier, then you must escape it before using it in a selector, either by calling on the value, or using one of the techniques described in Escaping characters. See Escaping attribute values for an example.\n\nAn object representing the first element in the document that matches the specified set of CSS selectors, or is returned if there are no matches. If you need a list of all elements matching the specified selectors, you should use instead.\n\nAs all CSS selector strings are valid, you can also negate selectors: This will select an input with a parent div with the class but not the class.\n\nThis example shows that if an HTML document contains an which is not a valid CSS identifier, then we must escape the attribute value before using it in . In the following code, a element has an of , which is not a valid CSS identifier, because the character is not allowed in CSS identifiers. We also have three buttons, and a element for logging errors. All three buttons, when clicked, try to select the , and then set its background color to a random value.\n• The first button uses the value directly.\n• The second button escapes the value using .\n• The third button explicitly escapes the character using a backslash. Note that we must also escape the backslash itself, using another backslash, like: . Clicking the first button gives an error, while the second and third buttons work properly."
    },
    {
        "link": "https://stackoverflow.com/questions/33178114/using-queryselectorall-to-change-the-style-property-of-multiple-elements",
        "document": "I have the following function which when triggered will make a DIV become semi-transparent.\n\nHowever I would like this function to apply to several DIVs simultaneously. I tried giving each DIV the same class name and then using but couldn't figure out how to implement it.\n\nWould be more appropriate and if so how would I implement it?"
    },
    {
        "link": "https://aditya-armal.medium.com/mastering-dom-manipulation-with-javascript-tips-and-best-practices-d937db5fe356",
        "document": "DOM (Document Object Model) manipulation is a crucial aspect of web development. It allows developers to interact with and modify the structure and content of web pages dynamically. In this guide, we will explore tips and best practices to help you master DOM manipulation with JavaScript, making your web development projects more efficient and maintainable.\n\n1. Use querySelector and querySelectorAll for Element Selection:\n\n — Instead of using getElementById, getElementsByClassName, or getElementsByTagName, prefer querySelector and querySelectorAll. They provide more flexibility and make it easier to select elements using CSS-like selectors.\n\n2. Cache Selected Elements:\n\n — To optimize performance, cache frequently accessed elements to avoid redundant DOM queries. This reduces the number of times you access the DOM, improving your application’s responsiveness.\n\n3. Leverage Event Delegation:\n\n — Event delegation involves attaching a single event listener to a common ancestor of multiple elements. It’s particularly useful when working with dynamically created elements or long lists of items, as it reduces the number of event listeners.\n\n4. Use classList for Class Manipulation:\n\n — When adding, removing, or toggling classes, use the `classList` property. It provides convenient methods for manipulating classes without affecting other existing classes.\n\n5. Avoid Inline Styles:\n\n — Minimize the use of inline styles (e.g., `element.style.color = ‘red’`) and favor adding/removing classes or manipulating CSS properties using stylesheets. This separation of concerns makes your code more maintainable.\n\n6. Optimize DOM Updates:\n\n — When making multiple changes to the DOM, consider using a Document Fragment to batch updates before applying them to the actual DOM. This can significantly improve performance, especially when adding or removing multiple elements.\n\n7. Handle Asynchronous Operations with Promises or Async/Await:\n\n — When dealing with asynchronous tasks like fetching data or animations, make use of Promises or Async/Await to ensure that the DOM is manipulated in the correct sequence and prevent race conditions.\n\n8. Test Your DOM Manipulation Code:\n\n — Write unit tests for your DOM manipulation functions to catch regressions and ensure your code behaves as expected, especially as your project grows in complexity.\n\nConclusion:\n\nDOM manipulation is a core skill for web developers. By following these tips and best practices, you can write cleaner, more efficient, and maintainable code. Leveraging modern JavaScript features and techniques, like Promises and Event Delegation, can make your DOM manipulation tasks easier and more reliable, ultimately improving the user experience of your web applications."
    },
    {
        "link": "https://freecodecamp.org/news/dom-manipulation-in-javascript",
        "document": "JavaScript, the language of the web, empowers developers to create dynamic and interactive web pages. One of the key features that enables this interactivity is Document Object Model (DOM) manipulation.\n\nDOM manipulation allows developers to interact with and modify the structure, style, and content of web pages. In this article, we'll explore the fundamentals of DOM manipulation in JavaScript, breaking down complex concepts into easy-to-understand snippets.\n\nWhat is the DOM?\n\nThe Document Object Model (DOM) is a programming interface for web documents. It represents the structure of a document as a tree of objects, where each object corresponds to a part of the document, such as elements, attributes, and text. JavaScript can manipulate this tree structure, allowing developers to dynamically alter the content and appearance of a webpage.\n\nTo manipulate the DOM, we need to access its elements. This is commonly done using the object, which represents the entire HTML document. Let's look at a simple example:\n\nIn the code snippet above, we use , , and to retrieve specific elements. The returned values can then be stored in variables for further manipulation.\n\nOnce we have access to an element, we can modify its content using the property:\n\nIn the example above, we changed the content of the to . This is a simple yet powerful way to update the text within an element.\n\nEvents are actions or occurrences that happen in the browser, such as a user clicking a button or resizing the window. JavaScript allows us to handle these events and execute code in response. Event handling is a crucial aspect of creating interactive web pages.\n\nTo respond to events, we can use event listeners. These are functions that \"listen\" for a specific event on a particular element. Let's consider a button click event as an example:\n\nIn this example, when the button with the ID is clicked, an alert saying will pop up. Event listeners provide a way to execute custom code based on user interactions.\n\nDOM manipulation also extends to modifying the styles of elements, allowing us to create visually appealing and dynamic web pages.\n\nWe can use the property of an element to change its appearance. Let's take an example of changing the color of a paragraph when a button is clicked:\n\nIn this example, when the button with the ID is clicked, the text color of the paragraph with the ID is changed to blue.\n\nHow to Create and Modify Elements\n\nIn addition to modifying existing elements, JavaScript allows us to create new elements and add them to the DOM.\n\nHow to create new elements\n\nThe method is used to create a new HTML element. Let's create a new paragraph element and append (add) it to the body of the document:\n\nIn this example, we create a new (paragraph) element, set its text content, and then append it to the body of the document.\n\nWe can also modify the attributes of existing elements. Let's consider changing the source of an image dynamically:\n\nHere, we access an image element with the ID and change its attribute to , dynamically updating the displayed image.\n\nLet's consider a scenario where you want to update the value of a text input based on user interaction:\n\nIn this example, as the user types in the text input with the ID , a paragraph with the ID is dynamically updated to reflect the input value.\n\nYou can toggle the visibility of an element by using the style property. Let's create a button that toggles the visibility of a paragraph:\n\nHere, the paragraph with the ID is initially visible. Clicking the button with the ID toggles its visibility.\n\nWhile DOM manipulation is a powerful tool for creating dynamic web pages, beginners often encounter common pitfalls that can lead to unexpected behavior or errors. Let's explore some of these pitfalls and provide tips on how to avoid them.\n\nManipulating the DOM before it's ready\n\nWe may sometimes attempt to manipulate the DOM before it has fully loaded. This can lead to JavaScript trying to access elements that haven't been rendered yet. To avoid this, it's crucial to wait for the DOM to be fully loaded before executing any JavaScript code:\n\nBy wrapping your DOM manipulation code inside the event listener, you ensure that it runs only when the DOM is ready.\n\nNot checking if an element exists\n\nWhen attempting to access an element using methods like , we might assume the element exists and proceed with manipulation. However, if the element is not present on the page, it can lead to errors.\n\nAlways check if an element exists before manipulating it:\n\nThis simple check prevents errors when working with elements that may or may not be present.\n\nWhen handling events, forgetting to prevent the default action can result in unexpected page behavior. For instance, if a form is submitted without preventing the default action, the page might reload, causing loss of data:\n\nBy calling , you stop the default behavior associated with the event, giving you full control over how the event is handled.\n\nPerforming inefficient DOM queries, especially within loops, can degrade performance. Each query involves traversing the DOM, and unnecessary queries can slow down your webpage.\n\nInstead of repeatedly querying the DOM, cache references to elements:\n\nBy querying the DOM once and reusing the reference, you optimize your code.\n\nDifferent browsers may interpret JavaScript and DOM manipulation slightly differently. Failing to account for cross-browser compatibility can lead to inconsistent behavior.\n\nUse feature detection and consider using libraries like jQuery or modern frameworks to handle cross-browser inconsistencies:\n\nBy checking for features before using them, you ensure your code works across various browsers.\n\nHow to Use Frameworks for DOM Manipulation\n\nWhile JavaScript allows for direct DOM manipulation, modern web development often involves using frameworks like React or Vue.js. These frameworks provide a more structured way to build and manage user interfaces.\n\nIn this React example, a component is created to handle a button click event, demonstrating a more declarative approach to UI development.\n\nHere, a Vue.js instance is created to manage data and methods, showcasing the reactivity and component-based structure of Vue.js.\n\nIn this comprehensive guide, we've delved into the world of DOM manipulation in JavaScript. From accessing elements to handling events, and from modifying styles to creating new elements, we've covered the essential concepts in a straightforward manner.\n\nRemember, DOM manipulation is at the core of creating dynamic and interactive web pages. By mastering these fundamental techniques, you'll be well-equipped to build engaging and user-friendly web applications. As you continue your journey with JavaScript, practice and experimentation will deepen your understanding of these concepts, paving the way for your success as a web developer."
    },
    {
        "link": "https://medium.com/@amitmishraam941/mastering-dom-manipulation-with-javascript-basics-and-best-practices-e65775984648",
        "document": "DOM (Document Object Model) manipulation lies at the heart of modern web development, enabling dynamic and interactive web experiences. In this blog, we’ll delve into the fundamentals of DOM manipulation using JavaScript, covering essential concepts, techniques, and best practices. Through detailed examples, you’ll learn how to effectively interact with the DOM to create dynamic web applications.\n\nThe DOM represents the structure of an HTML document as a tree-like structure, with each element represented as a node. JavaScript provides powerful APIs to access and manipulate these nodes, allowing developers to dynamically update the content, structure, and styling of web pages.\n\nOne of the fundamental tasks in DOM manipulation is selecting elements from the document. JavaScript provides several methods for this purpose, including `getElementById`, `getElementsByClassName`, `getElementsByTagName`, `querySelector`, and `querySelectorAll`.\n\nOnce you’ve selected elements, you can manipulate their content, attributes, and styling using various JavaScript methods and properties.\n\nEvent handling is crucial for building interactive web applications. JavaScript allows you to attach event listeners to DOM elements to respond to user actions such as clicks, keypresses, and mouse movements.\n\nWhen working with DOM manipulation, it’s essential to follow best practices to ensure maintainable and efficient code.\n\n2. Use Event Delegation: Attach event listeners to parent elements to handle events for multiple child elements efficiently.\n\n3. Avoid Excessive DOM Manipulation: Batch DOM updates whenever possible to minimize reflows and repaints.\n\n4. Separation of Concerns: Keep JavaScript code separate from HTML and CSS, following the principles of modularization and encapsulation.\n\nMastering DOM manipulation with JavaScript is essential for building modern web applications with dynamic and interactive user interfaces. By understanding the basics, practicing with examples, and following best practices, you can leverage the full power of the DOM to create compelling web experiences. Keep exploring and experimenting with DOM manipulation to enhance your frontend development skills."
    },
    {
        "link": "https://dev.to/wizdomtek/mastering-dom-manipulation-10-essential-tips-for-efficient-and-high-performance-web-development-3mke",
        "document": "Manipulating the Document Object Model (DOM) is a fundamental aspect of web development.\n\nAt the heart of every web page lies the Document Object Model (DOM). Think of the DOM as a tree-like structure representing all the elements of a webpage. Each HTML tag becomes a node in this tree, which you can interact with using JavaScript. Manipulating the DOM means changing these nodes—adding, removing, or modifying elements and their attributes—to alter the content, structure, and styling of a webpage dynamically.\n• Interactivity: Without DOM manipulation, web pages would be static. By manipulating the DOM, you can create interactive experiences where the content responds to user actions, such as clicks, hovers, or form submissions.\n• Dynamic Content Updates: You can update parts of a webpage without reloading the entire page. This is essential for creating smooth user experiences in modern web applications.\n• Control Over the Page: DOM manipulation gives you granular control over every element on the page, allowing for precise adjustments and customizations.\n\nWhether you're updating content dynamically, handling user interactions, or building complex interfaces, efficient DOM manipulation is key to creating responsive and high-performing web applications. However, working with the DOM can be tricky; inefficient code can lead to sluggish performance, memory leaks, and a poor user experience.\n\nIn this comprehensive guide, we'll delve into essential DOM API tips that will simplify your code, enhance performance, and make your development process smoother.\n• Understand the Difference Between Nodes and Elements\n• Use Options for Better Control\n\nIn the early days of JavaScript, developers used methods like , , and to select DOM elements. While these methods are still available, they are limited in flexibility and can lead to verbose code.\n\nThe introduction of and revolutionized DOM selection by allowing the use of CSS selectors. This means you can select elements with the same syntax you use in your stylesheets.\n\nHow to Use and\n• : Returns the first element within the document that matches the specified selector.\n• : Returns a static NodeList of all elements that match the selector.\n• Flexibility and Power: Use any valid CSS selector to target elements, including attribute selectors, pseudo-classes, and combinators.\n• Consistency: One method for all your selection needs reduces the cognitive load of remembering multiple methods.\n• Improved Readability: Code becomes more intuitive and aligns closely with your CSS, making it easier to maintain.\n\nWhile is powerful, be mindful of performance when dealing with large DOM trees or selecting many elements. For performance-critical applications, consider:\n• Limiting the Scope: Instead of querying the entire document, narrow down the search to a specific parent element.\n• Caching Selectors: If you're selecting the same elements multiple times, cache them in a variable.\n\nEvery time you modify the DOM, the browser may need to recalculate styles (reflow) and redraw elements (repaint). Frequent reflows and repaints can significantly degrade performance, especially when adding or modifying many elements individually.\n\nA Document Fragment is a lightweight container that allows you to group multiple DOM nodes. Think of it as a temporary, invisible parent element. You can perform multiple DOM manipulations on the fragment, and when you're ready, append it to the DOM in a single operation.\n\nHow to Use Document Fragments\n• Performance Optimization: Minimizes the number of reflows and repaints by updating the DOM in a single operation.\n• Efficiency: Manipulations on a fragment don't affect the live DOM, allowing for smoother performance.\n• Simplifies Code: Organizes batch updates, making your code cleaner and easier to understand.\n• Complex DOM Manipulations: Building a nested structure before inserting it into the document.\n• Template Rendering: Preparing content from templates or data before displaying it.\n\nAttaching event listeners to numerous elements can lead to:\n• Performance Overhead: The browser needs to manage many listeners, which can slow down event handling.\n\nEvent Delegation leverages the concept of event bubbling (also known as propagation). Instead of attaching event listeners to individual child elements, you attach a single listener to a parent element. When an event occurs on a child element, it bubbles up to the parent, where you can handle it.\n• Improved Performance: Reduces the number of event listeners, leading to lower memory consumption.\n• Dynamic Handling: Automatically handles events for elements added to the DOM in the future.\n• Event Targeting: Use and check properties like , , or custom attributes to identify the clicked element.\n• Event Propagation: Be cautious with events that may not bubble (e.g., events) and understand the event flow in the DOM.\n• Potential Side Effects: Ensure that the event handler doesn't inadvertently respond to events from unintended elements.\n\nThe Need for Cloning Nodes\n\nWhen building interfaces with repeating structures, such as lists or grids, you might need to create multiple similar elements. Creating each element from scratch can be repetitive and error-prone.\n\nThe method creates a copy of a node. It accepts a boolean parameter:\n• : Performs a deep clone, copying the node and all of its descendants.\n• : Performs a shallow clone, copying only the node itself.\n• Consistency: Ensures that all elements have the same structure and attributes.\n• Maintainability: Changes to the template automatically apply to all clones.\n• Use Templates: Define a hidden template in your HTML to serve as the basis for clones.\n• Deep Cloning: Unless you have a specific reason, use deep cloning ( ) to copy all child nodes.\n• Update IDs and Event Listeners: Ensure that cloned elements have unique IDs if necessary and attach event listeners appropriately.\n\nUsing the property to manipulate classes can be cumbersome:\n• String Manipulation: Requires string concatenation or splitting, which can be error-prone.\n• Risk of Overwriting: Setting can accidentally remove existing classes if not handled carefully.\n\nThe property provides a DOMTokenList of the class attributes of an element. It offers methods to add, remove, toggle, and check for classes in a more intuitive way.\n\nHow to Use\n• Simplicity: Provides straightforward methods that are easy to use.\n• Styling: Dynamically apply styles by adding classes that correspond to CSS rules.\n\nis well-supported in modern browsers. For IE9 and earlier versions, you may need a polyfill.\n\nBuilding HTML strings with traditional string concatenation can be:\n• Hard to Read: Escaping quotes and managing line breaks make the code messy.\n• Error-Prone: Easy to introduce syntax errors or omit parts of the string.\n\nIntroduced in ES6, template literals allow for:\n• Multiline Strings: Using backticks (`) instead of single or double quotes.\n• Expression Interpolation: Embed expressions directly within the string using .\n\nHow to Use Template Literals\n• Enhanced Readability: The code closely resembles the HTML structure, making it easier to read and maintain.\n• Easy Interpolation: Embed variables and expressions without breaking the string.\n• Multiline Support: No need for cumbersome concatenation of strings split across lines.\n\nWhen inserting dynamic content into the DOM, especially from user input, be cautious of Cross-Site Scripting (XSS) vulnerabilities.\n• Sanitize User Input: Use libraries or built-in methods to sanitize data before insertion.\n• Avoid When Possible: If you don't need to insert HTML, use or .\n\nFor complex templating needs, consider using client-side template engines like Handlebars, Mustache, or using frameworks like React or Vue.js, which handle rendering and state management more robustly.\n\n7. Understand the Difference Between Nodes and Elements\n\nThe Hierarchy of the DOM\n\nThe DOM is structured as a tree of nodes, where each node represents a part of the document.\n• Node: The base type from which other types inherit. Includes elements, text nodes, comment nodes, etc.\n• Element: A type of node that represents an HTML or XML element.\n• Use Appropriate Methods: Some methods and properties are specific to elements or nodes.\n• Traverse the DOM Correctly: Avoid unexpected results when navigating through child nodes.\n• / : Access the first and last child nodes.\n• : Returns an HTMLCollection of child elements (excludes text and comment nodes).\n• / : Access the first and last child elements.\n\n// Using children\n\n console.log(container.children); // Only the\n\n// Accessing the first child node\n\n console.log(container.firstChild); // Might be a text node (e.g., whitespace)\n\n// Accessing the first element child\n\n console.log(container.firstElementChild); // The first\n• Iterating Over Children: Use when you only care about element nodes.\n• Text Content: When dealing with text, be mindful that text nodes may contain whitespace (e.g., line breaks and indentation).\n• Method Compatibility: Some methods like return elements, while others like can return various node types.\n\nAccessing and manipulating the DOM is significantly slower than operations in JavaScript variables. Each interaction with the DOM can trigger layout calculations, style recalculations, and can block the rendering process.\n\nRepeatedly querying the DOM for the same element is inefficient.\n\njavascript\n\n for (let i = 0; i < 1000; i++) {\n\n document.getElementById('counter').textContent = i;\n\n }\n\n\n\njavascript\n\n const counter = document.getElementById('counter');\n\n for (let i = 0; i < 1000; i++) {\n\n counter.textContent = i;\n\n }\n\n\n\nLayout thrashing occurs when you read from and write to the DOM in a way that forces the browser to recalculate styles or layouts repeatedly.\n\nUse techniques like Document Fragments or off-DOM manipulations to batch updates.\n\nFor complex applications, consider using libraries like React or Vue.js, which use a virtual DOM to minimize direct DOM manipulations.\n• Performance Tools: Use browser developer tools to monitor repaint and reflow events.\n• Profiling: Identify bottlenecks by profiling your application during typical user interactions.\n\nA closure is a function that has access to its own scope, the outer function's scope, and the global scope. Closures allow you to retain access to variables defined in an outer function even after that function has completed execution.\n\nWhy Use Closures in Event Handlers?\n• State Preservation: Keep track of variables without polluting the global scope.\n• Dynamic Data: Capture the current value of a variable within a loop.\n\nConsider the following example:\n\nThis code will alert \"Button 6 clicked\" every time because the variable is hoisted and its value at the time of the click is 6 (after the loop completes).\n\nUse an IIFE (Immediately Invoked Function Expression) or to capture the correct value.\n• Avoid Global Variables: Reduce the risk of naming collisions and unintended side effects.\n• Maintain State: Keep track of information across function calls.\n\n10. Use Options for Better Control\n• Listener: The function that will be called when the event is triggered.\n\nOptionally, a third parameter, useCapture, could be passed as a boolean.\n\nModern browsers support an options object as the third parameter, providing more control over event handling.\n• : Boolean indicating whether events of this type will be dispatched to the registered listener before being dispatched to any EventTarget beneath it in the DOM tree.\n• : Boolean indicating that the listener should be invoked at most once after being added. If true, the listener would be automatically removed when invoked.\n• : Boolean indicating that the listener will never call . If it does, the user agent should ignore it and generate a console warning.\n\nOn touch devices, and events can delay scrolling because the browser waits to see if is called.\n\nWhen you need an event to be handled only once.\n\nHandle events during the capture phase rather than the bubble phase.\n• Performance Improvements: Use to enhance scrolling and touch performance.\n\nMost modern browsers support these options, but if you need to support older browsers, ensure you have fallbacks or feature detection.\n\nEfficient and effective DOM manipulation is vital for creating responsive, interactive, and high-performance web applications. By leveraging modern DOM APIs and best practices, you can write cleaner code, reduce errors, and improve the user experience.\n• Modern Selectors: Use and for flexible and powerful element selection.\n• Event Delegation: Simplify event handling and improve performance by attaching events to parent elements.\n• Class Manipulation: Use for intuitive and error-free class management.\n• Understanding the DOM: Know the difference between nodes and elements to traverse and manipulate the DOM effectively.\n• Closures: Use closures to maintain state and avoid common pitfalls in event handlers.\n• Event Listener Options: Gain better control over event handling with options like and .\n\nFor more tutorials, insights, and discussions on software development, don't forget to follow me on YouTube! Your support helps me create more valuable content to assist you on your coding journey."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Learn_web_development/Core/Scripting/DOM_scripting",
        "document": "When writing web pages and apps, one of the most common things you'll want to do is change the document structure in some way. This is usually done by manipulating the Document Object Model (DOM) via a set of built-in browser APIs for controlling HTML and styling information. In this article we'll introduce you to DOM scripting. An understanding of HTML and the fundamentals of CSS, familiarity with JavaScript basics as covered in previous lessons.\n• What the DOM is — the browser's internal representation of the document's HTML structure as a hierarchy of objects.\n• The important parts of a web browser as represented in JavaScript — , , and .\n• How DOM nodes exist relative to each other in the DOM tree — root, parent, child, sibling, and descendant.\n• Getting references to DOM nodes, creating new nodes, adding and removing nodes and attributes.\n\nWeb browsers are very complicated pieces of software with a lot of moving parts, many of which can't be controlled or manipulated by a web developer using JavaScript. You might think that such limitations are a bad thing, but browsers are locked down for good reasons, mostly centering around security. Imagine if a website could get access to your stored passwords or other sensitive information, and log into websites as if it were you? Despite the limitations, Web APIs still give us access to a lot of functionality that enable us to do a great many things with web pages. There are a few really obvious bits you'll reference regularly in your code — consider the following diagram, which represents the main parts of a browser directly involved in viewing web pages:\n• The window is the browser tab that a web page is loaded into; this is represented in JavaScript by the object. Using methods available on this object you can do things like return the window's size (see and ), manipulate the document loaded into that window, store data specific to that document on the client-side (for example using a local database or other storage mechanism), attach an event handler to the current window, and more.\n• The navigator represents the state and identity of the browser (i.e. the user-agent) as it exists on the web. In JavaScript, this is represented by the object. You can use this object to retrieve things like the user's preferred language, a media stream from the user's webcam, etc.\n• The document (represented by the DOM in browsers) is the actual page loaded into the window, and is represented in JavaScript by the object. You can use this object to return and manipulate information on the HTML and CSS that comprises the document, for example get a reference to an element in the DOM, change its text content, apply new styles to it, create new elements and add them to the current element as children, or even delete it altogether. In this article we'll focus mostly on manipulating the document, but we'll show a few other useful bits besides.\n\nLet's provide a brief recap on the Document Object Model (DOM), which we also looked at earlier in the course. The document currently loaded in each one of your browser tabs is represented by a DOM. This is a \"tree structure\" representation created by the browser that enables the HTML structure to be easily accessed by programming languages — for example the browser itself uses it to apply styling and other information to the correct elements as it renders a page, and developers like you can manipulate the DOM with JavaScript after the page has been rendered. We have created an example page at dom-example.html (see it live also). Try opening this up in your browser — it is a very simple page containing a element inside which you can find an image, and a paragraph with a link inside. The HTML source code looks like this: <!doctype html> <html lang=\"en-US\"> <head> <meta charset=\"utf-8\" /> <title>Simple DOM example</title> </head> <body> <section> <img src=\"dinosaur.png\" alt=\"A red Tyrannosaurus Rex: A two legged dinosaur standing upright like a human, with small arms, and a large head with lots of sharp teeth.\" /> <p> Here we will add a link to the <a href=\"https://www.mozilla.org/\">Mozilla homepage</a> </p> </section> </body> </html> The DOM on the other hand looks like this: Note: This DOM tree diagram was created using Ian Hickson's Live DOM viewer. Each entry in the tree is called a node. You can see in the diagram above that some nodes represent elements (identified as , , and so on) and others represent text (identified as ). There are other types of nodes as well, but these are the main ones you'll encounter. Nodes are also referred to by their position in the tree relative to other nodes:\n• Root node: The top node in the tree, which in the case of HTML is always the node (other markup vocabularies like SVG and custom XML will have different root elements).\n• Child node: A node directly inside another node. For example, is a child of in the above example.\n• Descendant node: A node anywhere inside another node. For example, is a child of in the above example, and it is also a descendant. is not a child of , as it is two levels below it in the tree, but it is a descendant of .\n• Parent node: A node which has another node inside it. For example, is the parent node of in the above example.\n• Sibling nodes: Nodes that sit on the same level under the same parent node in the DOM tree. For example, and are siblings in the above example. It is useful to familiarize yourself with this terminology before working with the DOM, as a number of the code terms you'll come across make use of them. You'll also come across them in CSS (e.g. descendant selector, child selector).\n\nTo start learning about DOM manipulation, let's begin with a practical example.\n• Take a local copy of the dom-example.html page and the image that goes along with it.\n• Add a element just above the closing tag.\n• To manipulate an element inside the DOM, you first need to select it and store a reference to it inside a variable. Inside your script element, add the following line:\n• Now we have the element reference stored in a variable, we can start to manipulate it using properties and methods available to it (these are defined on interfaces like in the case of element, its more general parent interface , and — which represents all nodes in a DOM). First of all, let's change the text inside the link by updating the value of the property. Add the following line below the previous one:\n• We should also change the URL the link is pointing to, so that it doesn't go to the wrong place when it is clicked on. Add the following line, again at the bottom: Note that, as with many things in JavaScript, there are many ways to select an element and store a reference to it in a variable. is the recommended modern approach. It is convenient because it allows you to select elements using CSS selectors. The above call will match the first element that appears in the document. If you wanted to match and do things to multiple elements, you could use , which matches every element in the document that matches the selector, and stores references to them in an array-like object called a . There are older methods available for grabbing element references, such as:\n• , which selects an element with a given attribute value, e.g. . The ID is passed to the function as a parameter, i.e. .\n• , which returns an array-like object containing all the elements on the page of a given type, for example s, s, etc. The element type is passed to the function as a parameter, i.e. . These two work better in older browsers than the modern methods like , but are not as convenient. Have a look and see what others you can find!\n\nThe above has given you a little taste of what you can do, but let's go further and look at how we can create new elements.\n• Going back to the current example, let's start by grabbing a reference to our element — add the following code at the bottom of your existing script (do the same with the other lines too):\n• Now let's create a new paragraph using and give it some text content in the same way as before: const para = document.createElement(\"p\"); para.textContent = \"We hope you enjoyed the ride.\";\n• You can now append the new paragraph at the end of the section using :\n• Finally for this part, let's add a text node to the paragraph the link sits inside, to round off the sentence nicely. First we will create the text node using :\n• Now we'll grab a reference to the paragraph the link is inside, and append the text node to it: That's most of what you need for adding nodes to the DOM — you'll make a lot of use of these methods when building dynamic interfaces (we'll look at some examples later).\n\nThere may be times when you want to move nodes, or delete them from the DOM altogether. This is perfectly possible. If we wanted to move the paragraph with the link inside it to the bottom of the section, we could do this: This moves the paragraph down to the bottom of the section. You might have thought it would make a second copy of it, but this is not the case — is a reference to the one and only copy of that paragraph. If you wanted to make a copy and add that as well, you'd need to use instead. Removing a node is pretty simple as well, at least when you have a reference to the node to be removed and its parent. In our current case, we just use , like this: When you want to remove a node based only on a reference to itself, which is fairly common, you can use : This method is not supported in older browsers. They have no method to tell a node to remove itself, so you'd have to do the following: Have a go at adding the above lines to your code.\n\nIt is possible to manipulate CSS styles via JavaScript in a variety of ways. To start with, you can get a list of all the stylesheets attached to a document using , which returns an array-like object with objects. You can then add/remove styles as wished. However, we're not going to expand on those features because they are a somewhat archaic and difficult way to manipulate style. There are much easier ways. The first way is to add inline styles directly onto elements you want to dynamically style. This is done with the property, which contains inline styling information for each element in the document. You can set properties of this object to directly update element styles.\n• As an example, try adding these lines to our ongoing example:\n• Reload the page and you'll see that the styles have been applied to the paragraph. If you look at that paragraph in your browser's Page Inspector/DOM inspector, you'll see that these lines are indeed adding inline styles to the document: <p style=\"color: white; background-color: black; padding: 10px; width: 250px; text-align: center;\"> We hope you enjoyed the ride. </p> Note: Notice how the JavaScript property versions of the CSS styles are written in lower camel case whereas the CSS versions are hyphenated (kebab-case) (e.g. versus ). Make sure you don't get these mixed up, otherwise it won't work. There is another common way to dynamically manipulate styles on your document, which we'll look at now.\n• Delete the previous five lines you added to the JavaScript.\n• Add the following inside your HTML :\n• Now we'll turn to a very useful method for general HTML manipulation — — this takes two arguments, the attribute you want to set on the element, and the value you want to set it to. In this case we will set a class name of highlight on our paragraph:\n• Refresh your page, and you'll see no change — the CSS is still applied to the paragraph, but this time by giving it a class that is selected by our CSS rule, not as inline CSS styles. Which method you choose is up to you; both have their advantages and disadvantages. The first method takes less setup and is good for simple uses, whereas the second method is more purist (no mixing CSS and JavaScript, no inline styles, which are seen as a bad practice). As you start building larger and more involved apps, you will probably start using the second method more, but it is really up to you. At this point, we haven't really done anything useful! There is no point using JavaScript to create static content — you might as well just write it into your HTML and not use JavaScript. It is more complex than HTML, and creating your content with JavaScript also has other issues attached to it (such as not being readable by search engines). In the next section we will look at a more practical use of DOM APIs. Note: You can find our finished version of the dom-example.html demo on GitHub (see it live also)."
    }
]