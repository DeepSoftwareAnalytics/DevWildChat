[
    {
        "link": "https://medium.com/@ryan_forrester_/c-file-handling-with-fstream-a-complete-guide-a4ebcc294bd0",
        "document": "#include <fstream>\n\n#include <iostream>\n\n#include <string>\n\n\n\nint main() {\n\n // Writing to a file\n\n std::ofstream outFile(\"example.txt\");\n\n if (outFile.is_open()) {\n\n outFile << \"Hello, World!\n\n\";\n\n outFile << \"This is a test file.\n\n\";\n\n outFile.close();\n\n } else {\n\n std::cerr << \"Error opening file for writing!\" << std::endl;\n\n return 1;\n\n }\n\n \n\n // Reading from a file\n\n std::ifstream inFile(\"example.txt\");\n\n std::string line;\n\n if (inFile.is_open()) {\n\n while (std::getline(inFile, line)) {\n\n std::cout << line << std::endl;\n\n }\n\n inFile.close();\n\n } else {\n\n std::cerr << \"Error opening file for reading!\" << std::endl;\n\n return 1;\n\n }\n\n \n\n return 0;\n\n}\n\n#include <fstream>\n\n#include <iostream>\n\n#include <string>\n\n\n\nclass FileManager {\n\nprivate:\n\n std::fstream file;\n\n \n\npublic:\n\n FileManager(const std::string& filename) {\n\n file.open(filename, std::ios::in | std::ios::out | std::ios::binary);\n\n }\n\n \n\n ~FileManager() {\n\n if (file.is_open()) {\n\n file.close();\n\n }\n\n }\n\n \n\n void seekAndRead(std::streampos position) {\n\n if (file.is_open()) {\n\n file.seekg(position);\n\n char buffer[100];\n\n file.read(buffer, 99);\n\n buffer[99] = '\\0';\n\n std::cout << \"Read from position \" << position << \": \" \n\n << buffer << std::endl;\n\n }\n\n }\n\n \n\n void seekAndWrite(std::streampos position, const std::string& text) {\n\n if (file.is_open()) {\n\n file.seekp(position);\n\n file << text;\n\n file.flush();\n\n }\n\n }\n\n};\n\n\n\nint main() {\n\n // Create a test file\n\n {\n\n std::ofstream outFile(\"seek_test.txt\");\n\n outFile << \"This is a test file for seeking operations.\n\n\";\n\n }\n\n \n\n FileManager fm(\"seek_test.txt\");\n\n fm.seekAndRead(10); // Read from position 10\n\n fm.seekAndWrite(5, \"was\"); // Replace \"is\" with \"was\"\n\n \n\n return 0;\n\n}\n\n#include <fstream>\n\n#include <iostream>\n\n#include <string>\n\n\n\nclass FileHandler {\n\npublic:\n\n static bool copyFile(const std::string& source, const std::string& dest) {\n\n std::ifstream src(source, std::ios::binary);\n\n if (!src.is_open()) {\n\n std::cerr << \"Error opening source file: \" << source << std::endl;\n\n return false;\n\n }\n\n \n\n std::ofstream dst(dest, std::ios::binary);\n\n if (!dst.is_open()) {\n\n std::cerr << \"Error opening destination file: \" << dest << std::endl;\n\n src.close();\n\n return false;\n\n }\n\n \n\n dst << src.rdbuf();\n\n \n\n if (src.fail() || dst.fail()) {\n\n std::cerr << \"Error during file copy\" << std::endl;\n\n src.close();\n\n dst.close();\n\n return false;\n\n }\n\n \n\n src.close();\n\n dst.close();\n\n return true;\n\n }\n\n \n\n static void checkFileState(std::fstream& file) {\n\n if (file.good()) {\n\n std::cout << \"File stream is good\" << std::endl;\n\n }\n\n if (file.eof()) {\n\n std::cout << \"End of file reached\" << std::endl;\n\n }\n\n if (file.fail()) {\n\n std::cout << \"A recoverable error occurred\" << std::endl;\n\n }\n\n if (file.bad()) {\n\n std::cout << \"A non-recoverable error occurred\" << std::endl;\n\n }\n\n }\n\n};\n\n#include <fstream>\n\n#include <iostream>\n\n#include <string>\n\n#include <vector>\n\n#include <sstream>\n\n\n\nclass CSVParser {\n\nprivate:\n\n std::string filename;\n\n char delimiter;\n\n \n\npublic:\n\n CSVParser(const std::string& fname, char delim = ',') \n\n : filename(fname), delimiter(delim) {}\n\n \n\n std::vector<std::vector<std::string>> parse() {\n\n std::vector<std::vector<std::string>> data;\n\n std::ifstream file(filename);\n\n \n\n if (!file.is_open()) {\n\n throw std::runtime_error(\"Could not open file: \" + filename);\n\n }\n\n \n\n std::string line;\n\n while (std::getline(file, line)) {\n\n std::vector<std::string> row;\n\n std::stringstream ss(line);\n\n std::string cell;\n\n \n\n while (std::getline(ss, cell, delimiter)) {\n\n // Remove leading and trailing whitespace\n\n cell.erase(0, cell.find_first_not_of(\" \\t\"));\n\n cell.erase(cell.find_last_not_of(\" \\t\") + 1);\n\n row.push_back(cell);\n\n }\n\n \n\n data.push_back(row);\n\n }\n\n \n\n file.close();\n\n return data;\n\n }\n\n};\n\n\n\nint main() {\n\n try {\n\n CSVParser parser(\"data.csv\");\n\n auto data = parser.parse();\n\n \n\n // Print the parsed data\n\n for (const auto& row : data) {\n\n for (const auto& cell : row) {\n\n std::cout << cell << \"\\t\";\n\n }\n\n std::cout << std::endl;\n\n }\n\n } catch (const std::exception& e) {\n\n std::cerr << \"Error: \" << e.what() << std::endl;\n\n return 1;\n\n }\n\n \n\n return 0;\n\n}\n\nfstream in C++ provides robust file handling capabilities. Key points to remember:\n\n1. Always check if files are opened successfully\n\n2. Close files when you’re done with them\n\n3. Use appropriate file modes (binary vs text)\n\n4. Handle errors properly\n\n5. Consider using RAII principles for file management"
    },
    {
        "link": "https://geeksforgeeks.org/stringstream-c-applications",
        "document": "stringstream in C++ and its Applications\n\nA stringstream associates a string object with a stream allowing you to read from the string as if it were a stream (like cin). To use stringstream, we need to include sstream header file. The stringstream class is extremely useful in parsing input.\n• str()- To get and set string object whose content is present in the stream.\n• operator >>- Read something from the stringstream object.\n\n1. Count the number of words in a string\n\nBelow is the C++ program to implement the above approach-\n\nTime complexity: O(n), Where n is the length of the string.\n\nAuxiliary space: O(m), Where m is the number of words in the string.\n\nBelow is the C++ program to implement the above approach-\n\nTime complexity: O(n log(k)), n is the total number of words in the input string, and k is the number of unique words.\n\nAuxiliary space: O(n).\n\nSince, the insertion and extraction operators of string stream work with different data types. So that’s why it works well with integers.\n\nWe will insert an integer into the string stream and after extracting that into a string, that integer value will become a string.\n\nRemoving spaces from a string using Stringstream\n\nConverting Strings to Numbers in C/C++"
    },
    {
        "link": "https://docs.oracle.com/cd/E19957-01/806-3569/Standard.html",
        "document": "When compiling in default (standard) mode, the compiler has access to the complete library specified by the C++ standard. The library components include what is informally known as the Standard Template Library (STL), as well as the following components.\n\nThe term STL does not have a formal definition, but is usually understood to include containers, iterators, and algorithms. The following subset of the standard library headers can be thought of as comprising the STL.\n\nThe C++ standard library (libCstd) is based on the RogueWave Standard C++ Library, Version 2. This library is available only for the default mode ( ) of the compiler and is not supported with use of the or options.\n\nIf you need to use your own version of the C++ standard library instead of the version that is supplied with the compiler, you can do so by specifying the option. Replacing the standard library that is distributed with the compiler is risky, and good results are not guaranteed. For more information, see the chapter on using libraries in the C++ User's Guide.\n\nFor details about the standard library, see the Standard C++ Library User's Guide and the Standard C++ Class Library Reference. The Related Documentation section in the preface contains information about accessing this documentation. For a list of available books about the C++ standard library see Commercially Available Books in the preface.\n\nTABLE 5-1 lists the headers for the complete standard library along with a brief description of each. Sequences supporting addition and removal at each end Sequences supporting addition at the head and removal at the tail Stream I/O using an in-memory string as source or sink Sequences supporting addition and removal at the head Value arrays useful for numeric programming\n\nTABLE 5-2 lists the documentation available for each of the components of the standard library. Generic algorithms for performing various operations on containers and sequences An iterator that can both read and write and can traverse a container in both directions A forward-moving iterator that can both read and write See entries for , , and An iterator adaptor that allows an iterator to insert into a container rather than overwrite elements in the container Pointer generalizations for traversal and modification of collections Function adaptors and function objects used to reverse the sense of predicate function objects Operators for the C++ Standard Template Library Output A function or a function object that returns a boolean (true/false) value or an integer value An iterator that reads, writes, and allows random access to a container Includes iterator capabilities for ostreams and istreams that allow generic algorithms to be used directly on streams Determines the type of distance used by an iterator-- obsolete Determines the category to which an iterator belongs--obsolete Accumulates all elements within a range into a single value Outputs a sequence of the differences between each adjacent pair of elements in a range Find the first adjacent pair of elements in a sequence that are equivalent Moves an iterator forward or backward (if available) by a certain distance The default allocator object for storage management in Standard Library containers An insert iterator used to insert items at the end of a collection An insert iterator used to insert items at the end of a collection Class that associates the input or output sequence with a file Supports reading and writing of named files or devices associated with a file descriptor Supports reading from named files or other devices associated with a file descriptor A base class that includes the common functions required by all streams Assists in formatting and interpreting sequences of characters controlled by a stream buffer Assists in reading and interpreting input from sequences controlled by a stream buffer Supports reading objects of class from an array in memory Supports writing into named files or other devices associated with a file descriptor Assists in formatting and writing output to sequences controlled by a stream buffer Abstract base class for deriving various stream buffers to facilitate control of character sequences Associates the input or output sequence with a sequence of arbitrary characters Supports writing and reading objects of class to or from an array in memory A function object that returns the complement of the result of its binary predicate Performs a binary search for a value on a container A template class and related functions for storing and manipulating fixed-size sequences of bits Controls output to an unbuffered stream buffer associated with the object stderr declared in <cstdio> A traits class with types and operations for the container and iostream classes Controls input from a stream buffer associated with the object stdin declared in Controls output to a stream buffer associated with the object stderr declared in A facet that includes code set conversion classification facilities based on the named locales A binary function or a function object that returns true or false Count the number of elements in a container that satisfy a given condition Count the number of elements in a container that satisfy a given condition Controls output to a stream buffer associated with the object stdout declared in A facet that includes character classification facilities based on the named locales A sequence that supports random access iterators and efficient insertion/deletion at both beginning and end Computes the distance between two iterators Returns the result of dividing its first argument by its second Finds the largest subrange in a collection into which a given value can be inserted without violating the ordering of the collection A binary function object that returns true if its first argument equals its second A family of classes used to encapsulate categories of locale functionality Class that associates the input or output sequence with a file Initializes a range with a given value Initializes a range with a given value Finds an occurrence of value in a sequence Finds the last occurrence of a sub-sequence in a sequence Finds the first occurrence of any value from one sequence in another sequence Finds an occurrence of a value in a sequence that satisfies a specified predicate Applies a function to each element in a range An insert iterator used to insert items at the beginning of a collection An insert iterator used to insert items at the beginning of a collection Supports reading and writing of named files or devices associated with a file descriptor A binary function object that returns true if its first argument is greater than its second A binary function object that returns true if its first argument is greater than or equal to its second A numeric array class used to represent a generalized slice from an array A numeric array class used to represent a BLAS-like slice from a valarray A function template used to determine if a locale has a given facet Supports reading from named files or other devices associated with a file descriptor A numeric array class used to represent elements selected from a valarray Computes the inner product A X B of two ranges A and B Merges two sorted sequences into one An insert iterator used to insert items into a collection rather than overwrite the collection An insert iterator used to insert items into a collection rather than overwrite the collection A base class that includes the common functions required by all streams Defines member types and maintains data for classes that inherit from it Declares the input/output library template classes and specializes them for wide and tiny characters Determines if a character is alphabetic or numeric Assists in reading and interpreting input from sequences controlled by a stream buffer A stream iterator that has iterator capabilities for istreams Reads successive characters from the stream buffer for which it was constructed Supports reading objects of class from an array in memory Reads characters from an array in memory A binary function object that returns true if tis first argument is less than its second A binary function object that returns true if its first argument is less than or equal to its second A binary function object that returns true if both of its arguments are true A unary function object that returns true if its argument is false A binary function object that returns true if either of its arguments are true Determines the first valid position for an element in a sorted container An associative container with access to non-key values using unique keys A numeric array class that gives a masked view of a valarray Finds and returns the maximum of a pair of values Finds the maximum value in a range Function objects that adapt a pointer to a member function, to take the place of a global function Function objects that adapt a pointer to a member function, to take the place of a global function Function objects that adapt a pointer to a member function, to take the place of a global function Function objects that adapt a pointer to a member function, to take the place of a global function Merges two sorted sequences into a third sequence Finds and returns the minimum of a pair of values Finds the minimum value in a range Returns the result of subtracting its second argument from its first Compares elements from two sequences and returns the first two elements that don't match each other Returns the remainder obtained by dividing the first argument by the second argument An associative container that gives access to non-key values using keys A binary function object that returns the result of multiplying its first and second arguments An associative container that allows fast access to stored key values Unary function object that returns the negation of its argument Generates successive permutations of a sequence based on an ordering function A function adaptor used to reverse the sense of a unary predicate function object A function adaptor used to reverse the sense of a binary predicate function object A binary function object that returns true if its first argument is not equal to its second Rearranges a collection so that all elements lower in sorted order than the th element come before it and all elements higher in sorter order than the th element come after it Supports writing into named files or other devices associated with a file descriptor Assists in formatting and writing output to sequences controlled by a stream buffer Stream iterators allow for use of iterators with ostreams and istreams Writes successive characters onto the stream buffer object from which it was constructed Writes to an array in memory Places all of the entities that satisfy the given predicate before all of the entities that do not Generates successive permutations of a sequence based on an ordering function A binary function object that returns the result of adding its first and second arguments A function object that adapts a pointer to a binary function, to take the place of a A function object class that adapts a pointer to a function, to take the place of a Moves the largest element off the heap Generates successive permutations of a sequence based on an ordering function A function that is overloaded to adapt a pointer to a function, to take the place of a function A container adaptor that behaves like a queue (first in, first out) Moves desired elements to the front of a container, and returns an iterator that describes where the sequence of desired elements ends Moves desired elements to the front of a container, and returns an iterator that describes where the sequence of desired elements ends Moves desired elements to the front of a container, and returns an iterator that describes where the sequence of desired elements ends Moves desired elements to the front of a container, and returns an iterator that describes where the sequence of desired elements ends Substitutes elements in a collection with new values Substitutes elements in a collection with new values, and moves the revised sequence into result Substitutes elements in a collection with new values, and moves the revised sequence into result Substitutes elements in a collection with new values Reverses the order of elements in a collection Reverses the order of elements in a collection while copying them to a new collection Swaps the segment that contains elements from first through middle-1 with the segment that contains the elements from middle through last Swaps the segment that contains elements from first through middle-1 with the segment that contains the elements from middle through last Finds a sub-sequence within a sequence of values that is element-wise equal to the values in an indicated range Finds a sub-sequence within a sequence of values that is element-wise equal to the values in an indicated range A numeric array class for representing a BLAS-like slice from an array Places all of the entities that satisfy the given predicate before all of the entities that do not, while maintaining the relative order of elements in each group A container adapter that behaves like a stack (last in, first out) Abstract base class for deriving various stream buffers to facilitate control of character sequences Associates the input or output sequence with a sequence of arbitrary characters Supports writing and reading objects of class to/from an array in memory Reads and writes to an array in memory Associates either the input sequence or the output sequence with a tiny character array whose elements store arbitrary values Exchanges a range of values in one location with those in anothe A time formatting facet for input, based on the named locales A time formatting facet for output, based on the named locales Applies an operation to a range of values in a collection and stores the result A function object that returns the complement of the result of its unary predicate An algorithm that uses construct to copy values from one range to another location An algorithm that uses the construct algorithm for setting values in a collection An algorithm that uses the construct algorithm for setting values in a collection Removes consecutive duplicates from a range of values and places the resulting unique values into the result Removes consecutive duplicates from a range of values and places the resulting unique values into the result Determines the last valid position for a value in a sorted container Controls output to an unbuffered stream buffer associated with the object stderr declared in Controls input from a stream buffer associated with the object stdin declared in Controls output to a stream buffer associated with the object stderr declared in Controls output to a stream buffer associated with the object stdout declared in Class that associates the input or output sequence with a file Supports reading and writing of named files or devices associated with a file descriptor Supports reading from named files or other devices associated with a file descriptor A base class that includes the common functions required by all streams Assists in reading and interpreting input from sequences controlled by a stream buffer Supports reading objects of class from an array in memory Supports writing into named files or other devices associated with a file descriptor Assists in formatting and writing output to sequences controlled by a stream buffer Abstract base class for deriving various stream buffers to facilitate control of character sequences Associates the input or output sequence with a sequence of arbitrary characters"
    },
    {
        "link": "https://geeksforgeeks.org/file-handling-c-classes",
        "document": "File handling is used to store data permanently in a computer. Using file handling we can store our data in secondary memory (Hard disk).\n\nHow to achieve the File Handling\n\nFor achieving file handling we need to follow the following steps:-\n\n STEP 1-Naming a file\n\n STEP 2-Opening a file\n\n STEP 3-Writing data into the file\n\n STEP 4-Reading data from the file\n\n STEP 5-Closing a file.\n\nWe give input to the executing program and the execution program gives back the output. The sequence of bytes given as input to the executing program and the sequence of bytes that comes as output from the executing program are called stream. In other words, streams are nothing but the flow of data in a sequence.\n\nThe input and output operation between the executing program and the devices like keyboard and monitor are known as “console I/O operation”. The input and output operation between the executing program and files are known as “disk I/O operation”.\n\nThe I/O system of C++ contains a set of classes which define the file handling methods. These include ifstream, ofstream and fstream classes. These classes are derived from fstream and from the corresponding iostream class. These classes, designed to manage the disk files, are declared in fstream and therefore we must include this file in any program that uses files. File handling is essential for data storage and retrieval in applications.\n• None This class is the base class for other classes in this class hierarchy.\n• None This class contains the necessary facilities that are used by all the other derived classes for input and output operations.\n• None This class is derived from the class ‘ios’.\n• None The extraction operator(>>) is overloaded in this class to handle input streams from files to the program execution.\n• None This class declares input functions such as get(), getline() and read().\n• None This class is derived from the class ‘ios’.\n• None The insertion operator(<<) is overloaded in this class to handle output streams to files from the program execution.\n• None This class declares output functions such as put() and write().\n• None This class contains a pointer which points to the buffer which is used to manage the input and output streams.\n• None This class provides operations common to the file streams. Serves as a base for fstream, ifstream and ofstream class.\n• None This class contains open() and close() function.\n• None It contains open() function with default input mode.\n• None Inherits the functions get(), getline(), read(), seekg() and tellg() functions from the istream.\n• None It contains open() function with default output mode.\n• None Inherits the functions put(), write(), seekp() and tellp() functions from the ostream.\n• None This class provides support for simultaneous input and output operations.\n• None Inherits all the functions from istream and ostream classes through iostream.\n• None Its purpose is to set the file buffers to read and write.\n• None We can also use file buffer member function to determine the length of the file. \n\n\n\nIn C++, files are mainly dealt by using three classes fstream, ifstream, ofstream available in fstream headerfile. \n\nofstream: Stream class to write on files \n\nifstream: Stream class to read from files \n\nfstream: Stream class to both read and write from/to files.\n\nNow the first step to open the particular file for read or write operation. We can open file by \n\n1. passing file name in constructor at the time of object creation \n\n2. using the open method\n\nBoth ios::app and ios::ate take us to the end of the file when it is opened. The difference between the two modes is that ios :: app allow us to add data to the end of the file only, while ios :: ate mode permits us add data or to modify the existing data anywhere in the file.\n\nProblem Statement : To read and write a File in C++. \n\nExamples:\n\nBelow is the implementation by using ifstream & ofstream classes.\n\nBelow is the implementation by using fstream class."
    },
    {
        "link": "https://stackoverflow.com/questions/37553026/whats-the-point-of-stringstream",
        "document": "Well, one problem is that you cannot \"concatenate a bunch of variables in a string using the + operator\" (only other strings or char*s).\n\nSo, how are you going to turn all your objects into strings? Unlike Java, C++ does not have any to_string() member convention. On the other hand, every class interested in using iostream will define stream inserters ( and maybe .)\n\nSo, you use the stream inserters to convert objects to text. Sometimes you don't want to write to the console or to a file, but instead you want to store it as a string.\n\nAlso, using the iostream framework lets you use the manipulators to control precision, width, numerical base, and so on, instead of trying to do all that manually as you construct a string.\n\nNow, that's not to say that the stringstream solution is ideal: in fact, a lot of libraries exist to do the same sort of task better (including at least Boost.Format, Boost.Convert, Boost.Lexical_Cast, and Boost.Spirit just in Boost.)"
    },
    {
        "link": "https://geeksforgeeks.org/reading-writing-text-files-python",
        "document": "Python provides built-in functions for creating, writing, and reading files. Two types of files can be handled in Python, normal text files and binary files (written in binary language, 0s, and 1s).\n• Text files: In this type of file, Each line of text is terminated with a special character called EOL (End of Line), which is the new line character (‘\n\n’) in Python by default.\n• Binary files: In this type of file, there is no terminator for a line, and the data is stored after converting it into machine-understandable binary language.\n\nThis article will focus on opening, closing, reading, and writing data in a text file. Here, we will also see how to get Python output in a text file.\n\nIt is done using the open() function. No module is required to be imported for this function.\n\nExample: Here, file1 is created as an object for MyFile1 and file2 as object for MyFile2.\n\nThere are three ways to read txt file in Python:\n\nread(): Returns the read bytes in form of a string. Reads n bytes, if no n specified, reads the entire file.\n\nreadline(): Reads a line of the file and returns in form of a string.For specified n, reads at most n bytes. However, does not reads more than one line, even if n exceeds the length of the line.\n\nreadlines(): Reads all the lines and return them as each line a string element in a list.\n\nNote: ‘\n\n’ is treated as a special character of two bytes.\n\nIn this example, a file named “myfile.txt” is created and opened in write mode ( ). Data is written to the file using and methods. The file is then reopened in read and append mode ( ). Various read operations, including , , , and the use of , demonstrate different ways to retrieve data from the file. Finally, the file is closed.\n\nThere are two ways to write in a file:\n\nwrite(): Inserts the string str1 in a single line in the text file.\n\nwritelines(): For a list of string elements, each string is inserted in the text file.Used to insert multiple strings at a single time.\n\nIn this example, a file named “myfile.txt” is initially opened in write mode ( ) to write lines of text. The file is then reopened in append mode ( ), and “Today” is added to the existing content. The output after appending is displayed using . Subsequently, the file is reopened in write mode, overwriting the content with “Tomorrow”. The final output after writing is displayed using\n\nPython close() function closes the file and frees the memory space acquired by that file. It is used at the time when the file is no longer needed or if it is to be opened in a different file mode. File_object.close()\n\nReading and Writing to text files in Python – FAQs\n\nAccess modes govern the type of operations possible in the opened file. It refers to how the file will be used once it’s opened. These modes also define the location of the File Handle in the file. The file handle is like a cursor, which defines from where the data has to be read or written in the file and we can get Python output in text file. There are 6 access modes in Python:\n• Read Only (‘r’): Open text file for reading. The handle is positioned at the beginning of the file. If the file does not exist, raises the I/O error. This is also the default mode in which a file is opened.\n• Read and Write (‘r+’): Open the file for reading and writing. The handle is positioned at the beginning of the file. Raises I/O error if the file does not exist.\n• Write Only (‘w’): Open the file for writing. For the existing files, the data is truncated and over-written. The handle is positioned at the beginning of the file. Creates the file if the file does not exist.\n• Write and Read (‘w+’) : Open the file for reading and writing. For an existing file, data is truncated and over-written. The handle is positioned at the beginning of the file.\n• Append Only (‘a’) : Open the file for writing. The file is created if it does not exist. The handle is positioned at the end of the file. The data being written will be inserted at the end, after the existing data.\n• Append and Read (‘a+’): Open the file for reading and writing. The file is created if it does not exist. The handle is positioned at the end of the file. The data being written will be inserted at the end, after the existing data.\n\nHow to read a file and write to another file in Python?\n\nHow Files are Loaded into Primary Memory?\n\nThere are two kinds of memory in a computer i.e. Primary and Secondary memory every file that you saved or anyone saved is on secondary memory causing any data in primary memory to be deleted when the computer is powered off. So when you need to change any text file or just to work with them in Python you need to load that file into primary memory. Python interacts with files loaded in primary memory or main memory through “file handlers” ( This is how your operating system gives access to Python to interact with the file you opened by searching the file in its memory if found it returns a file handler and then you can work with the file).\n\nWhat is the difference between reading and writing files in Python?\n\nWhich function is used to read data from a text file?"
    },
    {
        "link": "https://realpython.com/read-write-files-python",
        "document": "One of the most common tasks that you can do with Python is reading and writing files. Whether it’s writing to a simple text file, reading a complicated server log, or even analyzing raw byte data, all of these situations require reading or writing a file.\n• What makes up a file and why that’s important in Python\n• The basics of reading and writing files in Python\n• Some basic scenarios of reading and writing files\n\nThis tutorial is mainly for beginner to intermediate Pythonistas, but there are some tips in here that more advanced programmers may appreciate as well.\n\nBefore we can go into how to work with files in Python, it’s important to understand what exactly a file is and how modern operating systems handle some of their aspects. At its core, a file is a contiguous set of bytes used to store data. This data is organized in a specific format and can be anything as simple as a text file or as complicated as a program executable. In the end, these byte files are then translated into binary and for easier processing by the computer. Files on most modern file systems are composed of three main parts:\n• Header: metadata about the contents of the file (file name, size, type, and so on)\n• Data: contents of the file as written by the creator or editor\n• End of file (EOF): special character that indicates the end of the file What this data represents depends on the format specification used, which is typically represented by an extension. For example, a file that has an extension of most likely conforms to the Graphics Interchange Format specification. There are hundreds, if not thousands, of file extensions out there. For this tutorial, you’ll only deal with or file extensions. When you access a file on an operating system, a file path is required. The file path is a string that represents the location of a file. It’s broken up into three major parts:\n• Folder Path: the file folder location on the file system where subsequent folders are separated by a forward slash (Unix) or backslash (Windows)\n• File Name: the actual name of the file\n• Extension: the end of the file path pre-pended with a period ( ) used to indicate the file type Here’s a quick example. Let’s say you have a file located within a file structure like this: Let’s say you wanted to access the file, and your current location was in the same folder as . In order to access the file, you need to go through the folder and then the folder, finally arriving at the file. The Folder Path is . The File Name is . The File Extension is . So the full path is . Now let’s say that your current location or current working directory (cwd) is in the folder of our example folder structure. Instead of referring to the by the full path of , the file can be simply referenced by the file name and extension . / │ ├── path/ | │ | ├── to/ ← Your current working directory (cwd) is here | │ └── cats.gif ← Accessing this file | │ | └── dog_breeds.txt | └── animals.csv But what about ? How would you access that without using the full path? You can use the special characters double-dot ( ) to move one directory up. This means that will reference the file from the directory of : / │ ├── path/ ← Referencing this parent folder | │ | ├── to/ ← Current working directory (cwd) | │ └── cats.gif | │ | └── dog_breeds.txt ← Accessing this file | └── animals.csv The double-dot ( ) can be chained together to traverse multiple directories above the current directory. For example, to access from the folder, you would use . One problem often encountered when working with file data is the representation of a new line or line ending. The line ending has its roots from back in the Morse Code era, when a specific pro-sign was used to communicate the end of a transmission or the end of a line. Later, this was standardized for teleprinters by both the International Organization for Standardization (ISO) and the American Standards Association (ASA). ASA standard states that line endings should use the sequence of the Carriage Return ( or ) and the Line Feed ( or ) characters ( or ). The ISO standard however allowed for either the characters or just the character. Windows uses the characters to indicate a new line, while Unix and the newer Mac versions use just the character. This can cause some complications when you’re processing files on an operating system that is different than the file’s source. Here’s a quick example. Let’s say that we examine the file that was created on a Windows system: This same output will be interpreted on a Unix device differently: This can make iterating over each line problematic, and you may need to account for situations like this. Another common problem that you may face is the encoding of the byte data. An encoding is a translation from byte data to human readable characters. This is typically done by assigning a numerical value to represent a character. The two most common encodings are the ASCII and UNICODE Formats. ASCII can only store 128 characters, while Unicode can contain up to 1,114,112 characters. ASCII is actually a subset of Unicode (UTF-8), meaning that ASCII and Unicode share the same numerical to character values. It’s important to note that parsing a file with the incorrect character encoding can lead to failures or misrepresentation of the character. For example, if a file was created using the UTF-8 encoding, and you try to parse it using the ASCII encoding, if there is a character that is outside of those 128 values, then an error will be thrown.\n\nWhen you want to work with a file, the first thing to do is to open it. This is done by invoking the built-in function. has a single required argument that is the path to the file. has a single return, the file object: After you open a file, the next thing to learn is how to close it. Warning: You should always make sure that an open file is properly closed. To learn why, check out the Why Is It Important to Close Files in Python? tutorial. It’s important to remember that it’s your responsibility to close the file. In most cases, upon termination of an application or script, a file will be closed eventually. However, there is no guarantee when exactly that will happen. This can lead to unwanted behavior including resource leaks. It’s also a best practice within Python (Pythonic) to make sure that your code behaves in a way that is well defined and reduces any unwanted behavior. When you’re manipulating a file, there are two ways that you can use to ensure that a file is closed properly, even when encountering an error. The first way to close a file is to use the block: # Further file processing goes here If you’re unfamiliar with what the block is, check out Python Exceptions: An Introduction. The second way to close a file is to use the statement: # Further file processing goes here The statement automatically takes care of closing the file once it leaves the block, even in cases of error. I highly recommend that you use the statement as much as possible, as it allows for cleaner code and makes handling any unexpected errors easier for you. Most likely, you’ll also want to use the second positional argument, . This argument is a string that contains multiple characters to represent how you want to open the file. The default and most common is , which represents opening the file in read-only mode as a text file: # Further file processing goes here Other options for modes are fully documented online, but the most commonly used ones are the following: Open for writing, truncating (overwriting) the file first Let’s go back and talk a little about file objects. A file object is: “an object exposing a file-oriented API (with methods such as or ) to an underlying resource.” (Source) There are three different categories of file objects: Each of these file types are defined in the module. Here’s a quick rundown of how everything lines up. A text file is the most common file that you’ll encounter. Here are some examples of how these files are opened: With these types of files, will return a file object: This is the default file object returned by . A buffered binary file type is used for reading and writing binary files. Here are some examples of how these files are opened: With these types of files, will return either a or file object: “generally used as a low-level building-block for binary and text streams.” (Source) It is therefore not typically used. Here’s an example of how these files are opened: With these types of files, will return a file object:\n\nOnce you’ve opened up a file, you’ll want to read or write to the file. First off, let’s cover reading a file. There are multiple methods that can be called on a file object to help you out: What It Does This reads from the file based on the number of bytes. If no argument is passed or or is passed, then the entire file is read. This reads at most number of characters from the line. This continues to the end of the line and then wraps back around. If no argument is passed or or is passed, then the entire line (or rest of the line) is read. This reads the remaining lines from the file object and returns them as a list. Using the same file you used above, let’s go through some examples of how to use these methods. Here’s an example of how to open and read the entire file using : Here’s an example of how to read 5 bytes of a line each time using the Python method: # Read & print the first 5 characters of the line 5 times # Notice that line is greater than the 5 chars and continues # down the line, reading 5 chars each time until the end of the # line and then \"wraps\" around Here’s an example of how to read the entire file as a list using the Python method: The above example can also be done by using to create a list out of the file object: Iterating Over Each Line in the File A common thing to do while reading a file is to iterate over each line. Here’s an example of how to use the Python method to perform that iteration: # Read and print the entire file line by line # The EOF char is an empty string Another way you could iterate over each line in the file is to use the Python method of the file object. Remember, returns a list where each element in the list represents a line in the file: However, the above examples can be further simplified by iterating over the file object itself: # Read and print the entire file line by line This final approach is more Pythonic and can be quicker and more memory efficient. Therefore, it is suggested you use this instead. Note: Some of the above examples contain . The is to prevent Python from adding an additional newline to the text that is being printed and only print what is being read from the file. Now let’s dive into writing files. As with reading files, file objects have multiple methods that are useful for writing to a file: What It Does This writes the string to the file. This writes the sequence to the file. No line endings are appended to each sequence item. It’s up to you to add the appropriate line ending(s). Here’s a quick example of using and : # Alternatively you could use # Write the dog breeds to the file in reversed order Sometimes, you may need to work with files using byte strings. This is done by adding the character to the argument. All of the same methods for the file object apply. However, each of the methods expect and return a object instead: Opening a text file using the flag isn’t that interesting. Let’s say we have this cute picture of a Jack Russell Terrier ( ): You can actually open that file in Python and examine the contents! Since the file format is well defined, the header of the file is 8 bytes broken up like this: A “magic” number to indicate that this is the start of a Sure enough, when you open the file and read these bytes individually, you can see that this is indeed a header file: Let’s bring this whole thing home and look at a full example of how to read and write to a file. The following is a like tool that will convert a file that contains line endings of to . This tool is broken up into three major sections. The first is , which converts a string from line endings to . The second is , which converts a string that contains characters into . calls internally. Finally, there’s the block, which is called only when the file is executed as a script. Think of it as the function found in other programming languages. A simple script and library to convert files or strings from dos like Converts the string from \\r\n\n line endings to \n\n The string whose line endings will be converted Converts a file that contains Dos like line endings into Unix like The path to the source file to be converted The path to the converted file for output # Create our Argument parser and set its description \"Script that converts a DOS like file to an Unix like file\" # - source_file: the source file we want to convert # - dest_file: the destination where the output should go # Note: the use of the argument type of argparse.FileType could 'The location of the source ' # Parse the args (argparse automatically grabs the values from # If the destination file wasn't passed, then assume we want to # create a new file based on the old one\n\nNow that you’ve mastered the basics of reading and writing files, here are some tips and tricks to help you grow your skills. The attribute is a special attribute of modules, similar to . It is: “the pathname of the file from which the module was loaded, if it was loaded from a file.” (Source Note: To re-iterate, returns the path relative to where the initial Python script was called. If you need the full system path, you can use to get the current working directory of your executing code. Here’s a real world example. In one of my past jobs, I did multiple tests for a hardware device. Each test was written using a Python script with the test script file name used as a title. These scripts would then be executed and could print their status using the special attribute. Here’s an example folder structure: I was able to run and get the status of all my tests dynamically through use of the special attribute. Sometimes, you may want to append to a file or start writing at the end of an already populated file. This is easily done by using the character for the argument: When you examine again, you’ll see that the beginning of the file is unchanged and is now added to the end of the file: Working With Two Files at the Same Time There are times when you may want to read a file and write to another file at the same time. If you use the example that was shown when you were learning how to write to a file, it can actually be combined into the following: There may come a time when you’ll need finer control of the file object by placing it inside a custom class. When you do this, using the statement can no longer be used unless you add a few magic methods: and . By adding these, you’ll have created what’s called a context manager. is invoked when calling the statement. is called upon exiting from the statement block. Here’s a template that you can use to make your custom class: Now that you’ve got your custom class that is now a context manager, you can use it similarly to the built-in: Here’s a good example. Remember the cute Jack Russell image we had? Perhaps you want to open other files but don’t want to parse the header file each time. Here’s an example of how to do this. This example also uses custom iterators. If you’re not familiar with them, check out Python Iterators: # Every .png file contains this in the header. Use it to verify # the file is indeed a .png. # Ensure the file has the right extension \"The File is not a properly formatted .png file!\" # This and __next__() are used to create a custom iterator # The file hasn't been opened or reached EOF. This means we # can't go any further so stop the iteration by raising the # Each chunk has a len, type, data (based on len) and crc # Grab these values and return them as a tuple You can now open files and properly parse them using your custom context manager:"
    },
    {
        "link": "https://stackoverflow.com/questions/68167425/what-is-the-correct-way-of-using-context-managers-to-read-files",
        "document": "Memory wise both are the same.\n\nHowever, the first example keeps the file open for longer (while reading and iterating), while the second one keeps the file open only while reading.\n\nIt might make a difference for very long files and if there is another process that waits to read or write to the file, otherwise the difference is neglectable.\n\nBest-practice wise, I'd go with the second approach. If we can close the file early, we might as well do it."
    },
    {
        "link": "https://realpython.com/python-with-statement",
        "document": "The statement in Python is a quite useful tool for properly managing external resources in your programs. It allows you to take advantage of existing context managers to automatically handle the setup and teardown phases whenever you’re dealing with external resources or with operations that require those phases.\n\nBesides, the context management protocol allows you to create your own context managers so you can customize the way you deal with system resources. So, what’s the statement good for?\n• What the Python statement is for and how to use it\n• What the context management protocol is\n• How to implement your own context managers\n\nWith this knowledge, you’ll write more expressive code and avoid resource leaks in your programs. The statement helps you implement some common resource management patterns by abstracting their functionality and allowing them to be factored out and reused.\n\nOne common problem you’ll face in programming is how to properly manage external resources, such as files, locks, and network connections. Sometimes, a program will retain those resources forever, even if you no longer need them. This kind of issue is called a memory leak because the available memory gets reduced every time you create and open a new instance of a given resource without closing an existing one. Managing resources properly is often a tricky problem. It requires both a setup phase and a teardown phase. The latter phase requires you to perform some cleanup actions, such as closing a file, releasing a lock, or closing a network connection. If you forget to perform these cleanup actions, then your application keeps the resource alive. This might compromise valuable system resources, such as memory and network bandwidth. For example, a common problem that can arise when developers are working with databases is when a program keeps creating new connections without releasing or reusing them. In that case, the database back end can stop accepting new connections. This might require an admin to log in and manually kill those stale connections to make the database usable again. Another frequent issue shows up when developers are working with files. Writing text to files is usually a buffered operation. This means that calling on a file won’t immediately result in writing text to the physical file but to a temporary buffer. Sometimes, when the buffer isn’t full and developers forget to call , part of the data can be lost forever. Another possibility is that your application runs into errors or exceptions that cause the control flow to bypass the code responsible for releasing the resource at hand. Here’s an example in which you use to write some text to a file: This implementation doesn’t guarantee the file will be closed if an exception occurs during the call. In this case, the code will never call , and therefore your program might leak a file descriptor. In Python, you can use two general approaches to deal with resource management. You can wrap your code in: The first approach is quite general and allows you to provide setup and teardown code to manage any kind of resource. However, it’s a little bit verbose. Also, what if you forget any cleanup actions? The second approach provides a straightforward way to provide and reuse setup and teardown code. In this case, you’ll have the limitation that the statement only works with context managers. In the next two sections, you’ll learn how to use both approaches in your code. Working with files is probably the most common example of resource management in programming. In Python, you can use a … statement to handle opening and closing files properly: # Make sure to close the file after using it In this example, you need to safely open the file , which you can do by wrapping the call to in a … statement. Later, when you try to write to , the clause will guarantee that is properly closed, even if an exception occurs during the call to in the clause. You can use this pattern to handle setup and teardown logic when you’re managing external resources in Python. The block in the above example can potentially raise exceptions, such as or . You can handle those exceptions in an clause like this: \"An error occurred while writing to the file: # Make sure to close the file after using it In this example, you catch any potential exceptions that can occur while writing to the file. In real-life situations, you should use a specific exception type instead of the general to prevent unknown errors from passing silently. The Python statement creates a runtime context that allows you to run a group of statements under the control of a context manager. PEP 343 added the statement to make it possible to factor out standard use cases of the … statement. Compared to traditional … constructs, the statement can make your code clearer, safer, and reusable. Many classes in the standard library support the statement. A classic example of this is , which allows you to work with file objects using . To write a statement, you need to use the following general syntax: The context manager object results from evaluating the after . In other words, must return an object that implements the context management protocol. This protocol consists of two special methods:\n• is called by the statement to enter the runtime context.\n• is called when the execution leaves the code block. The specifier is optional. If you provide a with , then the return value of calling on the context manager object is bound to that variable. Note: Some context managers return from because they have no useful object to give back to the caller. In these cases, specifying a makes no sense. Here’s how the statement proceeds when Python runs into it:\n• Store the context manager’s and methods for later use.\n• Call on the context manager and bind its return value to if provided.\n• Call on the context manager when the code block finishes. In this case, , typically provides the setup code. The statement is a compound statement that starts a code block, like a conditional statement or a loop. Inside this code block, you can run several statements. Typically, you use the code block to manipulate if applicable. Once the code block finishes, gets called. This method typically provides the teardown logic or cleanup code, such as calling on an open file object. That’s why the statement is so useful. It makes properly acquiring and releasing resources a breeze. Here’s how to open your file for writing using the statement: When you run this statement, returns an object. This object is also a context manager, so the statement calls and assigns its return value to . Then you can manipulate the file inside the code block. When the block ends, automatically gets called and closes the file for you, even if an exception is raised inside the block. This construct is shorter than its … alternative, but it’s also less general, as you already saw. You can only use the statement with objects that support the context management protocol, whereas … allows you to perform cleanup actions for arbitrary objects without the need for supporting the context management protocol. In Python 3.1 and later, the statement supports multiple context managers. You can supply any number of context managers separated by commas: This works like nested statements but without nesting. This might be useful when you need to open two files at a time, the first for reading and the second for writing: In this example, you can add code for reading and transforming the content of . Then you write the final result to in the same code block. Using multiple context managers in a single has a drawback, though. If you use this feature, then you’ll probably break your line length limit. To work around this, you need to use backslashes ( ) for line continuation, so you might end up with an ugly final result. The statement can make the code that deals with system resources more readable, reusable, and concise, not to mention safer. It helps avoid bugs and leaks by making it almost impossible to forget cleaning up, closing, and releasing a resource after you’re done with it. Using allows you to abstract away most of the resource handling logic. Instead of having to write an explicit … statement with setup and teardown code each time, takes care of that for you and avoids repetition.\n\nAs long as Python developers have incorporated the statement into their coding practice, the tool has been shown to have several valuable use cases. More and more objects in the Python standard library now provide support for the context management protocol so you can use them in a statement. In this section, you’ll code some examples that show how to use the statement with several classes both in the standard library and in third-party libraries. So far, you’ve used to provide a context manager and manipulate files in a construct. Opening files using the statement is generally recommended because it ensures that open file descriptors are automatically closed after the flow of execution leaves the code block. As you saw before, the most common way to open a file using is through the built-in : In this case, since the context manager closes the file after leaving the code block, a common mistake might be the following: The first successfully writes into . Note that returns the number of bytes written into the file, . When you try to run a second , however, you get a because your is already closed. Another way to use the statement to open and manage files is by using : is a class that represents concrete paths to physical files in your computer. Calling on a object that points to a physical file opens it just like would do. So, works similarly to , but the file path is automatically provided by the object you call the method on. Since provides an elegant, straightforward, and Pythonic way to manipulate file system paths, you should consider using in your statements as a best practice in Python. Finally, whenever you load an external file, your program should check for possible issues, such as a missing file, writing and reading access, and so on. Here’s a general pattern that you should consider using when you’re working with files: In this example, you wrap the statement in a … statement. If an occurs during the execution of , then you use to log the error with a user-friendly and descriptive message. The module provides a function called , which returns an iterator over objects corresponding to the entries in a given directory. This function is specially designed to provide optimal performance when you’re traversing a directory structure. A call to with the path to a given directory as an argument returns an iterator that supports the context management protocol: In this example, you write a statement with as the context manager supplier. Then you iterate over the entries in the selected directory ( ) and print their name and size on the screen. In this case, calls to close the iterator and release the acquired resources. Note that if you run this on your machine, you’ll get a different output depending on the content of your current directory. Unlike built-in floating-point numbers, the module provides a way to adjust the precision to use in a given calculation that involves numbers. The precision defaults to places, but you can change it to meet your problem requirements. A quick way to perform calculations with a custom precision is using from : Here, provides a context manager that creates a local decimal context and allows you to perform calculations using a custom precision. In the code block, you need to set to the new precision you want to use, which is places in the example above. When the code block finishes, the precision is reset back to its default value, places. Another good example of using the statement effectively in the Python standard library is . This class provides a primitive lock to prevent multiple threads from modifying a shared resource at the same time in a multithreaded application. You can use a object as the context manager in a statement to automatically acquire and release a given lock. For example, say you need to protect the balance of a bank account: # Use the try ... finally pattern The statement in the second example automatically acquires and releases a lock when the flow of execution enters and leaves the statement. This way, you can focus on what really matters in your code and forget about those repetitive operations. In this example, the lock in the statement creates a protected region known as the critical section, which prevents concurrent access to the account balance. So far, you’ve coded a few examples using context managers that are available in the Python standard library. However, several third-party libraries include objects that support the context management protocol. Say you’re testing your code with pytest. Some of your functions and code blocks raise exceptions under certain situations, and you want to test those cases. To do that, you can use . This function allows you to assert that a code block or a function call raises a given exception. Since provides a context manager, you can use it in a statement like this: In the first example, you use to capture the that the expression raises. The second example uses the function to capture the that is raised when you access a key that doesn’t exist in a given dictionary. If your function or code block doesn’t raise the expected exception, then raises a failure exception: Another cool feature of is that you can specify a target variable to inspect the raised exception. For example, if you want to verify the error message, then you can do something like this: You can use all these features to capture the exceptions you raise from your functions and code block. This is a cool and useful tool that you can incorporate into your current testing strategy.\n\nTo implement the context management protocol and create class-based context managers, you need to add both the and the special methods to your classes. The table below summarizes how these methods work, the arguments they take, and the logic you can put in them: This method handles the setup logic and is called when entering a new context. Its return value is bound to the target variable. This method handles the teardown logic and is called when the flow of execution leaves the context. If an exception occurs, then , , and hold the exception type, value, and traceback information, respectively. When the statement executes, it calls on the context manager object to signal that you’re entering into a new runtime context. If you provide a target variable with the specifier, then the return value of is assigned to that variable. When the flow of execution leaves the context, is called. If no exception occurs in the code block, then the three last arguments to are set to . Otherwise, they hold the type, value, and traceback associated with the exception at hand. If the method returns , then any exception that occurs in the block is swallowed and the execution continues at the next statement after . If returns , then exceptions are propagated out of the context. This is also the default behavior when the method doesn’t return anything explicitly. You can take advantage of this feature to encapsulate exception handling inside the context manager. Here’s a sample class-based context manager that implements both methods, and . It also shows how Python calls them in a construct: implements both and . In , you first print a message to signal that the flow of execution is entering a new context. Then you return the string. In , you print a message to signal that the flow of execution is leaving the context. You also print the content of its three arguments. When the statement runs, Python creates a new instance of and calls its method. You know this because you get printed on the screen. Note: A common mistake when you’re using context managers is forgetting to call the object passed to the statement. In this case, the statement can’t get the required context manager, and you get an like this: The exception message doesn’t say too much, and you might feel confused in this kind of situation. So, make sure to call the object in the statement to provide the corresponding context manager. Then Python runs the code block, which prints to the screen. Note that holds the return value of . When the flow of execution exits the code block, Python calls . You know that because you get printed on your screen. The final line in the output confirms that the three arguments to are set to . Note: A common trick when you don’t remember the exact signature of and don’t need to access its arguments is to use and like in . Now, what happens if an exception occurs during the execution of the block? Go ahead and write the following statement: In this case, you try to retrieve the value at index in the string . This raises an , and the arguments to are set to the following: This behavior is quite useful when you want to encapsulate the exception handling in your context managers. As an example of encapsulating exception handling in a context manager, say you expect to be the most common exception when you’re working with . You might want to handle that exception in the context manager so you don’t have to repeat the exception-handling code in every code block. In that case, you can do something like this: \"An exception occurred in your with block: \"Continue normally from here...\" In , you check if is an instance of . If so, then you print a couple of informative messages and finally return with . Returning a truthy value makes it possible to swallow the exception and continue the normal execution after the code block. In this example, if no occurs, then the method returns and the exception propagates out. However, if you want to be more explicit, then you can return from outside the block. If you run from your command line, then you get the following output: python exc_handling.py An exception occurred in your with block: <class 'IndexError'> Continue normally from here... is now able to handle exceptions that occur in the code block. Since you return when an occurs, the flow of execution continues in the next line, right after exiting the code block. Now that you know how to implement the context management protocol, you can get a sense of what this would look like by coding a practical example. Here’s how you can take advantage of to create a context manager that opens files for writing: implements the context management protocol and supports the statement, just like the original does, but it always opens the file for writing using the mode. Here’s how you can use your new context manager: After running this code, your file contains the string. As an exercise, you can write a complementary context manager that opens files for reading, but using functionalities. Go ahead and give it a shot! A subtle detail to consider when you’re writing your own context managers is that sometimes you don’t have a useful object to return from and therefore to assign to the target variable. In those cases, you can return explicitly or you can just rely on Python’s implicit return value, which is as well. For example, say you need to temporarily redirect the standard output, , to a given file on your disk. To do this, you can create a context manager like this: This context manager takes a file object through its constructor. In , you reassign the standard output, , to an instance attribute to avoid losing the reference to it. Then you reassign the standard output to point to the file on your disk. In , you just restore the standard output to its original value. To use , you can do something like this: The outer statement in this example provides the file object that you’re going to use as your new output, . The inner temporarily redirects the standard output to , so the first call to writes directly to that file instead of printing on your screen. Note that when you leave the inner code block, the standard output goes back to its original value. is a quick example of a context manager that doesn’t have a useful value to return from . However, if you’re only redirecting the output, you can get the same functionality without the need for coding a context manager. You just need to provide a argument to like this: In this examples, takes your file as an argument. This causes to write directly into the physical file on your disk instead of printing to your screen. Just like every other class, a context manager can encapsulate some internal state. The following example shows how to create a stateful context manager to measure the execution time of a given code block or function: When you use in a statement, gets called. This method uses to get the time at the beginning of the code block and stores it in . It also initializes and returns a function that computes a time delta. In this case, holds the initial state or time measurement. Note: To take a deeper dive into how to time your code, check out Python Timer Functions: Three Ways to Monitor Your Code. Once the block ends, gets called. The method gets the time at the end of the block and updates the value of so that the function can compute the time required to run the code block. Here’s how you can use this context manager in your code: With , you can measure the execution time of any piece of code. In this example, holds an instance of the function that computes the time delta, so you need to call to get the final result.\n\nPython’s generator functions and the decorator provide an alternative and convenient way to implement the context management protocol. If you decorate an appropriately coded generator function with , then you get a function-based context manager that automatically provides both required methods, and . This can make your life more pleasant by saving you some boilerplate code. The general pattern to create a context manager using along with a generator function goes like this: In this example, you can identify two visible sections in . Before the statement, you have the setup section. There, you can place the code that acquires the managed resources. Everything before the runs when the flow of execution enters the context. After the statement, you have the teardown section, in which you can release the resources and do the cleanup. The code after runs at the end of the block. The statement itself provides the object that will be assigned to the target variable. This implementation and the one that uses the context management protocol are practically equivalent. Depending on which one you find more readable, you might prefer one over the other. A downside of the function-based implementation is that it requires an understanding of advanced Python topics, such as decorators and generators. The decorator reduces the boilerplate required to create a context manager. Instead of writing a whole class with and methods, you just need to implement a generator function with a single that produces whatever you want to return. You can use the to reimplement your context manager. Here’s what rewriting it with this technique looks like: In this case, is a generator function that opens for writing. Then it temporarily suspends its own execution and yields the resource so can bind it to its target variable. When the flow of execution leaves the code block, the function continues to execute and closes correctly. As a final example of how to create custom context managers with , say you’re testing a piece of code that works with time measurements. The code uses to get the current time measurement and do some further computations. Since time measurements vary, you decide to mock so you can test your code. Here’s a function-based context manager that can help you do that: Inside , you use a statement to signal that you’re going to modify the global name . Then you save the original function object in so you can safely restore it later. The next step is to monkey patch using a function that always returns the same value, . The bare statement specifies that this context manager doesn’t have a useful object to send back to the target variable for later use. After , you reset the global to its original content. When the execution enters the block, any calls to return . Once you leave the code block, calls to return the expected current time. That’s it! Now you can test your time-related code.\n\nContext managers are quite flexible, and if you use the statement creatively, then you can define convenient APIs for your classes, modules, and packages. For example, what if the resource you wanted to manage is the text indentation level in some kind of report generator application? In that case, you could write code like this: This almost reads like a domain-specific language (DSL) for indenting text. Also, notice how this code enters and leaves the same context manager multiple times to switch between different indentation levels. Running this code snippet leads to the following output and prints neatly formatted text: How would you implement a context manager to support this functionality? This could be a great exercise to wrap your head around how context managers work. So, before you check out the implementation below, you might take some time and try to solve this by yourself as a learning exercise. Ready? Here’s how you might implement this functionality using a context manager class: Here, increments by every time the flow of execution enters the context. The method also returns the current instance, . In , you decrease so the printed text steps back one indentation level every time you exit the context. The key point in this example is that returning from allows you to reuse the same context manager across several nested statements. This changes the text indentation level every time you enter and leave a given context. A good exercise for you at this point would be to write a function-based version of this context manager. Go ahead and give it a try!"
    },
    {
        "link": "https://llego.dev/posts/python-guide-reading-writing-text-files",
        "document": "Text files are one of the most common file formats used for storing and processing data in Python. Whether you need to read data from a configuration file, parse a CSV file, or write logs to a text file, knowing how to handle text files is an essential skill for any Python developer.\n\nIn this comprehensive guide, we will explore practical techniques for reading from and writing to text files in Python, with real-world examples and code snippets you can apply right away.\n\nA text file is a file that stores information as plaintext characters. Text files contain only textual data - no formatting or binary data. In Python, we can work with text files using the built-in function combined with the object attributes and methods.\n\nHere are some key things to know about text files in Python:\n• Text files are simple, portable, and widely supported across platforms and programs. CSV, JSON, XML, and source code files are common text file types.\n• Python provides easy ways to open, read, write, and close access to text files. We don’t need to import any external libraries.\n• File access modes control how we open a text file. The common modes are for read-only, for write-only, and for append.\n• Handle text files carefully to avoid data loss or corruption. Always close files when done and use exception handling.\n• Text data may require additional processing when reading and writing, such as decoding, encoding, splitting, or joining lines.\n\nNow let’s look at practical examples of reading and writing text files in Python.\n\nTo read data from a text file in Python, we use the built-in function together with a file access mode to open the file for reading only. This will return a file object that contains the file’s data.\n\nHere is the basic syntax:\n\nThis opens and assigns the file object to . We can then call various methods on the file object to read the file contents.\n\nTo read all data from the file into a string variable, we use the method:\n\nThis reads the entire contents of into the string .\n\nThis will print the full contents of .\n\nFor iterating over each line in a file, we can use the method. This returns a list where each element is a line from the file:\n\nThis reads each line of text into the list , then prints each line.\n\nAlternatively, we can use a loop on the file object directly:\n\nThis loops through the file line by line without loading all data into memory.\n\nTo read only a set number of characters from the file, we can pass an integer argument to :\n\nThis reads the first 100 characters into the variable .\n\nWe can also read from a specific position in the file by using to set the file cursor position before reading:\n\nThis seeks to character 50 first, then reads 100 characters from that position.\n\nThe file object has an attribute that is True when the end of the file has been reached. We can check this within loops to stop at end-of-file:\n\nThis loops line-by-line until end-of-file is reached.\n\nBy leveraging these file methods, we can efficiently read and process text file data in the desired way.\n\nTo write data to a new text file, we open the file with mode for write-only access. This will create the file if it does not already exist:\n\nFor an existing file, opening with mode will overwrite the existing contents.\n\nWe can then use the method to write data to the file:\n\nThis writes the string 'This is some text' to the file.\n\nThe method will not add any newline characters automatically - we need to explicitly add newlines:\n\nWrites two lines of text with a newline between them.\n\nSome key points for writing text files in Python:\n• Use mode to create new files or overwrite existing files\n• Remember to close files with when writing is complete\n\nTo write each element of a list to new lines in a file, we can loop through the list:\n\nThis loops through and writes each list item to a new file line.\n\nFor better performance with large data, we can write a list of strings all at once using :\n\nThis writes all strings in the list to the file in batch rather than one at a time.\n\nTo add data to an existing text file without overwriting it, open the file with mode for append:\n\nThis will append 'This is new text' to the end of .\n\nWhen working with text files in Python, errors can occur that we need to handle properly:\n• - Base error for I/O failures. Raised when the file can’t be opened.\n• - Raised when is called after reaching end-of-file.\n\nWe should wrap our file operations in try/except blocks to catch and handle these errors:\n\nThis catches and other exceptions, printing custom error messages.\n\nWe can access the exception instance for additional context in our exception handling:\n\nProper error handling ensures our programs are robust and prevent crashes when working with text files.\n\nNow let’s look at some real-world examples of processing text files in Python.\n\nApplication configuration files store program settings and options in a text file. For example:\n\nWe can write Python code to open this configuration file, parse the key-value pairs, and assign to program variables:\n\nThis parses each line into a dictionary we can use to set configurable options.\n\nCSV files store tabular data in plaintext comma-separated rows and columns. Python has a module to help parse CSV files:\n\nThis prints each row as a list of column values.\n\nWe can process CSV data into dictionaries as well:\n\nThis parses rows into dicts using as headers.\n\nApplications often write log messages to a text file to record events or debug info:\n\nThe function prepends a timestamp and appends each message to the log file.\n\nJSON is a common plaintext data format in Python. We can use the module:\n\nThis reads JSON into a Python dict, writes a dict to JSON file.\n\nAs you can see, reading and writing text files like CSV, configuration, logs, and JSON is a common task in Python.\n\nIn this guide, we covered several practical techniques for reading and writing text files in Python, including:\n• Opening files in various read, write, and append access modes\n• Writing strings, lines, and batches using and\n• Parsing and processing text file formats like CSV and JSON\n• Applying these concepts to real-world use cases\n\nPython’s built-in text file handling provides a straightforward way to access data from plain text files on disk. With the file methods and additional string processing, we can easily read, parse, and write text file content exactly how we need for a given application.\n\nTo learn more about working with files in Python, refer to the official Python Documentation on Text File I/O and the Open() Function."
    }
]