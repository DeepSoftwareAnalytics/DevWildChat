[
    {
        "link": "https://developer.mozilla.org/en-US/docs/Learn_web_development/Core/Structuring_content/Structuring_documents",
        "document": "In addition to defining individual parts of your page (such as \"a paragraph\" or \"an image\"), HTML also boasts a number of block level elements used to define areas of your website (such as \"the header\", \"the navigation menu\", \"the main content column\"). This article looks into how to plan a basic website structure, and write the HTML to represent this structure. Basic HTML familiarity, as covered in Basic HTML Syntax. Text-level semantics such as headings and paragraphs and lists.\n• The common HTML semantic structural elements, for example , , , , , and , and how to use them correctly.\n• The need to use semantic elements in appropriate places, rather than just using elements wherever a block-level container is required, and the benefits of this (such as improved accessibility).\n\nWebpages can and will look pretty different from one another, but they all tend to share similar standard components, unless the page is displaying a fullscreen video or game, is part of some kind of art project, or is just badly structured: Usually a big strip across the top with a big heading, logo, and perhaps a tagline. This usually stays the same from one page of a website to another. Links to the site's main sections; usually represented by menu buttons, links, or tabs. Like the header, this content usually remains consistent from one webpage to another — having inconsistent navigation on your website will just lead to confused, frustrated users. Many web designers consider the navigation bar to be part of the header rather than an individual component, but that's not a requirement; in fact, some also argue that having the two separate is better for accessibility, as screen readers can read the two features better if they are separate. A big area in the center that contains most of the unique content of a given webpage, for example, the video you want to watch, or the main story you're reading, or the map you want to view, or the news headlines, etc. This is the one part of the website that definitely will vary from page to page! Some peripheral info, links, quotes, ads, etc. Usually, this is contextual to what is contained in the main content (for example on a news article page, the sidebar might contain the author's bio, or links to related articles) but there are also cases where you'll find some recurring elements like a secondary navigation system. A strip across the bottom of the page that generally contains fine print, copyright notices, or contact info. It's a place to put common information (like the header) but usually, that information is not critical or secondary to the website itself. The footer is also sometimes used for SEO purposes, by providing links for quick access to popular content. A \"typical website\" could be structured something like this: Note: The image above illustrates the main sections of a document, which you can define with HTML. However, the appearance of the page shown here — including the layout, colors, and fonts — is achieved by applying CSS to the HTML.\n\nActive learning: exploring the code for our example Our example seen above is represented by the following code (you can also find the example in our GitHub repository). We'd like you to look at the example above, and then look over the listing below to see what parts make up what section of the visual. <!doctype html> <html lang=\"en-US\"> <head> <meta charset=\"utf-8\" /> <meta name=\"viewport\" content=\"width=device-width\" /> <title>My page title</title> <link href=\"https://fonts.googleapis.com/css?family=Open+Sans+Condensed:300|Sonsie+One\" rel=\"stylesheet\" /> <link rel=\"stylesheet\" href=\"style.css\" /> </head> <body> <!-- The main header used across all the pages of our website --> <header> <h1>Header</h1> </header> <nav> <ul> <li><a href=\"#\">Home</a></li> <li><a href=\"#\">Our team</a></li> <li><a href=\"#\">Projects</a></li> <li><a href=\"#\">Contact</a></li> </ul> <!-- A Search form: another common non-linear way to navigate through a site. --> <form> <input type=\"search\" name=\"q\" placeholder=\"Search query\" /> <input type=\"submit\" value=\"Go!\" /> </form> </nav> <!-- Our page's main content --> <main> <!-- An article --> <article> <h2>Article heading</h2> <p> Lorem ipsum dolor sit amet, consectetur adipisicing elit. Donec a diam lectus. Set sit amet ipsum mauris. Maecenas congue ligula as quam viverra nec consectetur ant hendrerit. Donec et mollis dolor. Praesent et diam eget libero egestas mattis sit amet vitae augue. Nam tincidunt congue enim, ut porta lorem lacinia consectetur. </p> <section> <h3>Subsection</h3> <p> Donec ut librero sed accu vehicula ultricies a non tortor. Lorem ipsum dolor sit amet, consectetur adipisicing elit. Aenean ut gravida lorem. Ut turpis felis, pulvinar a semper sed, adipiscing id dolor. </p> <p> Pelientesque auctor nisi id magna consequat sagittis. Curabitur dapibus, enim sit amet elit pharetra tincidunt feugiat nist imperdiet. Ut convallis libero in urna ultrices accumsan. Donec sed odio eros. </p> </section> <section> <h3>Another subsection</h3> <p> Donec viverra mi quis quam pulvinar at malesuada arcu rhoncus. Cum soclis natoque penatibus et manis dis parturient montes, nascetur ridiculus mus. In rutrum accumsan ultricies. Mauris vitae nisi at sem facilisis semper ac in est. </p> <p> Vivamus fermentum semper porta. Nunc diam velit, adipscing ut tristique vitae sagittis vel odio. Maecenas convallis ullamcorper ultricied. Curabitur ornare, ligula semper consectetur sagittis, nisi diam iaculis velit, is fringille sem nunc vet mi. </p> </section> </article> <!-- the aside content can also be nested within the main content --> <aside> <h2>Related</h2> <ul> <li><a href=\"#\">Oh I do like to be beside the seaside</a></li> <li><a href=\"#\">Oh I do like to be beside the sea</a></li> <li><a href=\"#\">Although in the North of England</a></li> <li><a href=\"#\">It never stops raining</a></li> <li><a href=\"#\">Oh well…</a></li> </ul> </aside> </main> <!-- The footer that is used across all the pages of our website --> <footer> <p>©Copyright 2050 by nobody. All rights reversed.</p> </footer> </body> </html> Take some time to look over the code and understand it — the comments inside the code should also help you to understand it. We aren't asking you to do much else in this article, because the key to understanding document layout is writing a sound HTML structure, and then laying it out with CSS. We'll wait for this until you start to study CSS layout as part of the CSS topic.\n\nSometimes you'll come across a situation where you can't find an ideal semantic element to group some items together or wrap some content. Sometimes you might want to just group a set of elements together to affect them all as a single entity with some CSS or JavaScript. For cases like these, HTML provides the and elements. You should use these preferably with a suitable attribute, to provide some kind of label for them so they can be easily targeted. is an inline non-semantic element, which you should only use if you can't think of a better semantic text element to wrap your content, or don't want to add any specific meaning. For example: <p> The King walked drunkenly back to his room at 01:00, the beer doing nothing to aid him as he staggered through the door. <span class=\"editor-note\"> [Editor's note: At this point in the play, the lights should be down low]. </span> </p> In this case, the editor's note is supposed to merely provide extra direction for the director of the play; it is not supposed to have extra semantic meaning. For sighted users, CSS would perhaps be used to distance the note slightly from the main text. is a block level non-semantic element, which you should only use if you can't think of a better semantic block element to use, or don't want to add any specific meaning. For example, imagine a shopping cart widget that you could choose to pull up at any point during your time on an e-commerce site: This isn't really an , as it doesn't necessarily relate to the main content of the page (you want it viewable from anywhere). It doesn't even particularly warrant using a , as it isn't part of the main content of the page. So a is fine in this case. We've included a heading as a signpost to aid screen reader users in finding it. Warning: Divs are so convenient to use that it's easy to use them too much. As they carry no semantic value, they just clutter your HTML code. Take care to use them only when there is no better semantic solution and try to reduce their usage to the minimum otherwise you'll have a hard time updating and maintaining your documents.\n\nTwo elements that you'll use occasionally and will want to know about are and . creates a line break in a paragraph; it is the only way to force a rigid structure in a situation where you want a series of fixed short lines, such as in a postal address or a poem. For example: <p> There once was a man named O'Dell<br /> Who loved to write HTML<br /> But his structure was bad, his semantics were sad<br /> and his markup didn't read very well. </p> Without the elements, the paragraph would just be rendered in one long line (as we said earlier in the course, HTML ignores most whitespace); with elements in the code, the markup renders like this: elements create a horizontal rule in the document that denotes a thematic change in the text (such as a change in topic or scene). Visually it just looks like a horizontal line. As an example: <p> Ron was backed into a corner by the marauding netherbeasts. Scared, but determined to protect his friends, he raised his wand and prepared to do battle, hoping that his distress call had made it through. </p> <hr /> <p> Meanwhile, Harry was sitting at home, staring at his royalty statement and pondering when the next spin off series would come out, when an enchanted distress letter flew through his window and landed in his lap. He read it hazily and sighed; \"better get back to work then\", he mused. </p>"
    },
    {
        "link": "https://kinsta.com/blog/html-best-practices",
        "document": "HTML best practices help developers offer innovative and highly interactive websites and web apps. These best practices help you develop the most feature-rich and business-centric applications. Plus, organizations can harness these best practices to provide a seamless user experience.\n\nToday, when we talk about HTML, we typically discuss HTML5 (and not its immediate predecessors). HTML5 is a powerful markup language that allows web developers to create a web document. It’s easy to use and understand, and almost all browsers support it. Also, it’s the foundation of almost all Content Management Systems (CMS)\n\nAs a web developer with minimal experience, questions such as “How can I write better HTML?” often arise. This article aims to help you get started on the right foot.\n\nYou probably already have a grasp of this markup language, but here are some HTML5 best practices that will let you code better.\n\nWhen creating an HTML document, the declaration is required for informing the browser what standards you’re using. Its purpose is to render your markup correctly.\n\nThe declaration should be in the first line of your HTML document. Here is a comparison between its right and wrong implementation:\n\nAlternatively, you can use the doctype corresponding to the HTML/XHTML version you want to use. Learn about the recommended list of doctype declarations to help you choose the right one.\n\nDevelopers know that the purpose of tags is to help web browsers distinguish between HTML content and ordinary content. HTML tags contain an opening tag, content, and closing tag. However, they’re often confused about the proper placement of tags, the elements that require closing tags, or when to omit tags.\n\nFor instance, where’s the best place to put tags?\n\nScript tags are typically placed inside the element. But a modern HTML best practice is to place them at the bottom of the document instead, before closing the tag, to delay their download. The webpage will load the Document Object Model (DOM) first, show it to the user, and then request the scripts afterward, reducing time to first byte (TTFB).\n\nThe browser interprets your HTML document line by line from top to bottom. So, when it reads the head and comes across a script tag, it starts a request to the server to get the file. There’s nothing inherently wrong with this process, but if the page is loading a huge file, it will take a long time and greatly affect the user experience.\n\nUnder the root element is the , or language, attribute. This attribute helps in translating an HTML document into the proper language. The best practice is to keep this attribute’s value as short as possible.\n\nFor example, the Japanese language is mostly used in Japan. Therefore, the country code is not necessary when targeting the Japanese language.\n\nOne of the most common HTML best practices is to check on the do’s and don’ts. Here are some known don’ts in HTML coding:\n\nLike any coding practice, the “keep it simple” principle is very applicable to HTML and HTML5. Generally, HTML5 is compatible with older HTML versions and XHTML. For that reason, we recommend avoiding the use of XML declarations or attributes.\n\nYou don’t need to declare code as such unless you want to write an XHTML document. Similarly, you don’t need XML attributes, such as:\n\nDevelopers should code with SEO in mind. Web contents that are not found are also not indexed. For that reason, here are some best SEO best practices to consider:\n\nThe tag is a handy tag, but misusing it may result in some non-intuitive behaviors. Thus, if you declare a base tag, then every link in the document will be relative unless explicitly specified:\n\nThis syntax changes the default behavior of some links. For example, linking to an external webpage with only the page name and extension:\n\nOr the browser will interpret it as:\n\nThis interpretation becomes chaotic, so it’s safer to always use absolute paths for your links.\n\nOn the other hand, writing metatag descriptions is not strictly a part of HTML best practices, but it’s still equally important. The attribute is what search engine crawlers reference when they index your page, so it’s vital to your SEO health.\n\nThe tag makes a web page search engine-friendly. For one thing, the text inside the tag appears in Google’s Search Engine Result Pages (SERP) and the user’s web browser bar and tabs.\n\nTake, for example, when you search the keyword “HTML5.” The title in this search result indicates the specific title attribute and the author. This is very important in SEO and site traffic generation.\n\nImages Must Have an Alt Attribute\n\nUsing a meaningful alt attribute with elements is a must for writing valid and semantic code.\n\nIn the table below, the bad practice column shows an element without an alt attribute. Although the second example in the same column has an alt attribute, its value is meaningless.\n\nThe meta description is an HTML element that describes and summarizes the contents of a webpage. Its purpose is for the users to find the context of the page. Although metadata doesn’t help anymore with SEO rankings, the meta description still plays a significant role in on-page SEO.\n\nHere is a sample code that includes the keywords, description, author’s name, and character set. The character set is used to support almost all the characters and symbols from different languages. On the other hand, you can set cookies, add a revision date, and allow the page to refresh.\n\nIn the anchor elements, the best practice is to use title attributes to improve accessibility. The title attribute increases the meaning of the anchor tag. The tag (or anchor element) paired with its attribute, creates a hyperlink to web pages, email addresses, and files. It is used to link locations within the same page or external addresses.\n\nCheck the example under the bad practice column — it’s there for being redundant. This type of practice is evident if a user uses a screen reader to read the anchor tag and read the same text twice to the listener. A screen reader is an assistive technology provided to the visually impaired or those with a learning disability. As a good practice, if you’re just repeating the anchor’s text, then it’s better not to use a title at all.\n\nWebsite development isn’t simply a matter of creating a block of text and headers, link pages, and you’re done. There are some best practices in HTML to consider to make the best of your website.\n\nThe HTML documents will still work without the primary elements: , , and . However, pages may not render correctly if these elements are missing. To that end, it’s important to use proper document structure consistently.\n\nFor a thematic grouping of content, use the section element. According to the W3C specification, a should contain a heading (H1, H2, etc.). Some developers skip the use of the heading element entirely, but we recommend including it to reach those better using screen readers:\n\nThe tag serves as a container for an external resource. This includes web pages, pictures, videos, or plug-ins. However, you must consider that most browsers no longer support Java Applets and plug-ins. What’s more, ActiveX controls are no longer supported in any browser, and the support for Shockwave Flash has also been turned off in modern browsers.\n\nWe recommend the following:\n• For a picture, use the tag.\n• For HTML pulled in from another site, use the tag.\n• For videos or audios, use the and tags.\n\nThe alt attribute in the element provides an image description useful to search engines and screen readers. It can come in especially handy to users when the images can’t be processed:\n\nLeave the alt attribute empty if there’s supplemental text to explain the image. This is to avoid redundancy:\n\nLeave elements empty if there are some restrictions in its content. An empty iframe element is always safe:\n\nDevelopers should provide fallback content, or backup links, for any or elements, just as with images. Fallback content is needed, especially for newly introduced elements in HTML:\n\nHTML documents become complicated, especially for web pages with a lot of content. It’s best to reduce the number of elements on a page to as few as you can manage. Learn how to use the heading elements wisely and follow how to elements denote HTML’s content hierarchy. This makes your content more meaningful for your readers, screen-reading software, and search engines.\n\nFor WordPress developers and content creators, use the element for the blog post’s title instead of the site’s name. This helps in search engine crawling, and this approach is SEO-friendly.\n\nIn addition, use the right HTML element to convey the information it contains to achieve a semantic and meaningful content structure. For example, use for emphasis and for heavy emphasis instead of their predecessors or , which are now deprecated.\n\nJust as importantly, use for paragraphs, and avoid using to add a new line between paragraphs. Instead, make use of CSS margin and/or padding properties to position your content better. Sometimes, you might find yourself tempted to use the tag for indentation purposes. Avoid this pitfall — use it exclusively when quoting text.\n\nOne of the best HTML best practices is to use semantically appropriate elements in your page layout. Several elements will help you organize your layout in sections.\n\nWith the wide breadth of topics under HTML layout, it’s best to highlight the do’s and don’ts in layout quickly. For instance, HTML gives more semantic meaning to the header and footer elements, so don’t neglect the use of the tag as it’s used in any given section or article. Aside from controlling the and tags and other stylistic elements of the document, it’s used in headings, publish dates, and other introductory content of your page or section. Similarly, you can do away with the notion that footers belong to the copyright section only — now, you can use it just about everywhere.\n\nFor the element, you should use it for site-wide navigation. There is no need to declare a role as the usage is already implied in the tag.\n\nAs for the element, it is already part of the latest HTML5 versions, which denote the main content of the document body. So, there is no longer any need to use when we have a more specific tag for our main content.\n\nThe is used for a content block. It is a stand-alone and makes sense without the need to give further explanation, while the tag is used to divide a page into different subject areas or to section an individual article. Unfortunately, many developers still use the two interchangeably.\n\nConsider that the tag is a more generic tag than the tag. This means that the former denotes content related to the topic at hand, but not necessarily self-contained. The latter, conversely, is a stand-alone property.\n\nBut when there’s no appropriate markup tag for your purposes, what should you use? The answer is to use when no other element works or when it’s a specifically stylistic element. For our purposes, using is also a bad practice.\n\nLet’s go back to the tag, which is a semantic markup tag. It is not a stylistic one, and it is important to emphasize it. In effect, a good coding practice should include a heading tag.\n\nNow, the don’ts with follows that you shouldn’t use it to tag a wrapper, a container, or any other purely stylistic block. Below is an example of bad coding practice with the tag:\n\nHere is a better approach, but it overuses the tag:\n\nHence, a much better coding practice is:\n\nA popular part of many layouts are figures for data representation, and the element is mostly used with pictures. However, it has a wider range of possible uses, as anything related to the document could be positioned anywhere and wrapped in a element. Some examples include illustrations, tables, or diagrams in a book.\n\nAn interesting characteristic of is that it does not contribute to the document’s outline. Therefore, you can use it to group elements with a common theme — for instance, several images with one common , or even a block of code.\n\nIn grouping elements with , use . The caption should go either directly after the opening tag, or directly before the closing tag :\n\nHTML is one of the core technologies in web development. It has awesome power and features that made it popular with developers and business owners. Frontend development keeps on innovating, and to keep up with it, developers should know the best practices in HTML scripting.\n\nInline styles will make your code cluttered and unreadable. To that end, always link to and use external stylesheets. Also, avoid using import statements in your CSS files as they produce an extra server request.\n\nThe same goes for inline CSS and JavaScript. Apart from readability issues, this will make your document heavier and more difficult to maintain so that you can avoid inlining code.\n\nUsing lowercase characters in code is an industry-standard practice. Although using uppercase or other text cases will still render your page, the problem is not standardization but code readability.\n\nCode readability is an important aspect of coding as it helps make applications maintainable and secure. Not only that, web development mostly comprises a team. Making your code readable makes your work and the work of your team less complicated.\n\nWhile there are many don’ts in coding HTML, we’ll share two basics don’ts in scripting:\n• Write well-indented and consistently formatted codes: Clean and well-written code promotes better readability on your site, which is a huge help to your developer and other people who might work with the site. It also shows great professionalism and attention to detail, reflecting well on your attitude as a developer.\n• Refrain from including excessive comments: Comments are essential and make your code easier to understand. However, HTML syntax is very self-explanatory, so commenting is not necessary unless you have to clarify semantics and naming conventions.\n\nValidating and minifying codes are used to identify errors early on. Don’t wait until you finish your HTML document — make it a habit to validate and identify errors frequently. You can do validation either manually or use any known validator tool such as W3C Markup Validator.\n\nAt the same time, practice minification by removing anything that is not essential such as comments or whitespace. Ensure that you write clean and concise codes to reduce the size of your HTML file. You can use tools such as HTML Minifier and others.\n\nMany HTML5 best practices resources for 2021 are available online to assist you. However, remember the general rule in coding: consistency. This article has provided basic insights and helped you kick-start that frontend development journey. Using this guide, you’ll be an expert in semantically correct HTML5 in no time.\n\nWhen you’re ready, look beyond what HTML can offer and explore some open source HTML frameworks too for building modern, single-page web apps. They offer excellent synchronization between the data and UI and work seamlessly with CSS and JavaScript.\n\nDid we miss any HTML best practices that you use in your own coding? Let us know in the comments section!"
    },
    {
        "link": "https://html.spec.whatwg.org/multipage/introduction.html",
        "document": "\n• Introduction\n• Where does this specification fit?\n• Structure of this specification\n• How to read this specification\n• A quick introduction to HTML\n• Common pitfalls to avoid when using the scripting APIs\n• How to catch mistakes when writing HTML: validators and conformance checkers\n• Conformance requirements for authors\n• Restrictions on content models and on attribute values\n\nWhere does this specification fit?\n\nThis specification defines a big part of the web platform, in lots of detail. Its place in the web platform specification stack relative to other specifications can be best summed up as follows:\n\nIn more length: the term \"HTML5\" is widely used as a buzzword to refer to modern web technologies, many of which (though by no means all) are developed at the WHATWG. This document is one such; others are available from the WHATWG Standards overview.\n\nHTML is the World Wide Web's core markup language. Originally, HTML was primarily designed as a language for semantically describing scientific documents. Its general design, however, has enabled it to be adapted, over the subsequent years, to describe a number of other types of documents and even applications.\n\nThis specification is intended for authors of documents and scripts that use the features defined in this specification, implementers of tools that operate on pages that use the features defined in this specification, and individuals wishing to establish the correctness of documents or implementations with respect to the requirements of this specification.\n\nThis document is probably not suited to readers who do not already have at least a passing familiarity with web technologies, as in places it sacrifices clarity for precision, and brevity for completeness. More approachable tutorials and authoring guides can provide a gentler introduction to the topic.\n\nIn particular, familiarity with the basics of DOM is necessary for a complete understanding of some of the more technical parts of this specification. An understanding of Web IDL, HTTP, XML, Unicode, character encodings, JavaScript, and CSS will also be helpful in places but is not essential.\n\nThis specification is limited to providing a semantic-level markup language and associated semantic-level scripting APIs for authoring accessible pages on the web ranging from static documents to dynamic applications.\n\nThe scope of this specification does not include providing mechanisms for media-specific customization of presentation (although default rendering rules for web browsers are included at the end of this specification, and several mechanisms for hooking into CSS are provided as part of the language).\n\nThe scope of this specification is not to describe an entire operating system. In particular, hardware configuration software, image manipulation tools, and applications that users would be expected to use with high-end workstations on a daily basis are out of scope. In terms of applications, this specification is targeted specifically at applications that would be expected to be used by users on an occasional basis, or regularly but from disparate locations, with low CPU requirements. Examples of such applications include online purchasing systems, searching systems, games (especially multiplayer online games), public telephone books or address books, communications software (email clients, instant messaging clients, discussion software), document editing software, etc.\n\nFor its first five years (1990-1995), HTML went through a number of revisions and experienced a number of extensions, primarily hosted first at CERN, and then at the IETF.\n\nWith the creation of the W3C, HTML's development changed venue again. A first abortive attempt at extending HTML in 1995 known as HTML 3.0 then made way to a more pragmatic approach known as HTML 3.2, which was completed in 1997. HTML4 quickly followed later that same year.\n\nThe following year, the W3C membership decided to stop evolving HTML and instead begin work on an XML-based equivalent, called XHTML. This effort started with a reformulation of HTML4 in XML, known as XHTML 1.0, which added no new features except the new serialization, and which was completed in 2000. After XHTML 1.0, the W3C's focus turned to making it easier for other working groups to extend XHTML, under the banner of XHTML Modularization. In parallel with this, the W3C also worked on a new language that was not compatible with the earlier HTML and XHTML languages, calling it XHTML2.\n\nAround the time that HTML's evolution was stopped in 1998, parts of the API for HTML developed by browser vendors were specified and published under the name DOM Level 1 (in 1998) and DOM Level 2 Core and DOM Level 2 HTML (starting in 2000 and culminating in 2003). These efforts then petered out, with some DOM Level 3 specifications published in 2004 but the working group being closed before all the Level 3 drafts were completed.\n\nIn 2003, the publication of XForms, a technology which was positioned as the next generation of web forms, sparked a renewed interest in evolving HTML itself, rather than finding replacements for it. This interest was borne from the realization that XML's deployment as a web technology was limited to entirely new technologies (like RSS and later Atom), rather than as a replacement for existing deployed technologies (like HTML).\n\nA proof of concept to show that it was possible to extend HTML4's forms to provide many of the features that XForms 1.0 introduced, without requiring browsers to implement rendering engines that were incompatible with existing HTML web pages, was the first result of this renewed interest. At this early stage, while the draft was already publicly available, and input was already being solicited from all sources, the specification was only under Opera Software's copyright.\n\nThe idea that HTML's evolution should be reopened was tested at a W3C workshop in 2004, where some of the principles that underlie the HTML5 work (described below), as well as the aforementioned early draft proposal covering just forms-related features, were presented to the W3C jointly by Mozilla and Opera. The proposal was rejected on the grounds that the proposal conflicted with the previously chosen direction for the web's evolution; the W3C staff and membership voted to continue developing XML-based replacements instead.\n\nShortly thereafter, Apple, Mozilla, and Opera jointly announced their intent to continue working on the effort under the umbrella of a new venue called the WHATWG. A public mailing list was created, and the draft was moved to the WHATWG site. The copyright was subsequently amended to be jointly owned by all three vendors, and to allow reuse of the specification.\n\nThe WHATWG was based on several core principles, in particular that technologies need to be backwards compatible, that specifications and implementations need to match even if this means changing the specification rather than the implementations, and that specifications need to be detailed enough that implementations can achieve complete interoperability without reverse-engineering each other.\n\nThe latter requirement in particular required that the scope of the HTML5 specification include what had previously been specified in three separate documents: HTML4, XHTML1, and DOM2 HTML. It also meant including significantly more detail than had previously been considered the norm.\n\nIn 2006, the W3C indicated an interest to participate in the development of HTML5 after all, and in 2007 formed a working group chartered to work with the WHATWG on the development of the HTML5 specification. Apple, Mozilla, and Opera allowed the W3C to publish the specification under the W3C copyright, while keeping a version with the less restrictive license on the WHATWG site.\n\nFor a number of years, both groups then worked together. In 2011, however, the groups came to the conclusion that they had different goals: the W3C wanted to publish a \"finished\" version of \"HTML5\", while the WHATWG wanted to continue working on a Living Standard for HTML, continuously maintaining the specification rather than freezing it in a state with known problems, and adding new features as needed to evolve the platform.\n\nIn 2019, the WHATWG and W3C signed an agreement to collaborate on a single version of HTML going forward: this document.\n\nIt must be admitted that many aspects of HTML appear at first glance to be nonsensical and inconsistent.\n\nHTML, its supporting DOM APIs, as well as many of its supporting technologies, have been developed over a period of several decades by a wide array of people with different priorities who, in many cases, did not know of each other's existence.\n\nFeatures have thus arisen from many sources, and have not always been designed in especially consistent ways. Furthermore, because of the unique characteristics of the web, implementation bugs have often become de-facto, and now de-jure, standards, as content is often unintentionally written in ways that rely on them before they can be fixed.\n\nDespite all this, efforts have been made to adhere to certain design goals. These are described in the next few subsections.\n\nTo avoid exposing web authors to the complexities of multithreading, the HTML and DOM APIs are designed such that no script can ever detect the simultaneous execution of other scripts. Even with workers, the intent is that the behavior of implementations can be thought of as completely serializing the execution of all scripts in all globals.\n\nThe exception to this general design principle is the JavaScript class. Using objects, it can in fact be observed that scripts in other agents are executing simultaneously. Furthermore, due to the JavaScript memory model, there are situations which not only are un-representable via serialized script execution, but also un-representable via serialized statement execution among those scripts.\n\nHTML has a wide array of extensibility mechanisms that can be used for adding semantics in a safe manner:\n• None Authors can use the attribute to extend elements, effectively creating their own elements, while using the most applicable existing \"real\" HTML element, so that browsers and other tools that don't know of the extension can still support it somewhat well. This is the tack used by microformats, for example.\n• None Authors can include data for inline client-side scripts or server-side site-wide scripts to process using the attributes. These are guaranteed to never be touched by browsers, and allow scripts to include data on HTML elements that scripts can then look for and process.\n• None Authors can use the mechanism to include page-wide metadata.\n• None Authors can use the mechanism to annotate links with specific meanings by registering extensions to the predefined set of link types. This is also used by microformats.\n• None Authors can embed raw data using the mechanism with a custom type, for further handling by inline or server-side scripts.\n• None Authors can extend APIs using the JavaScript prototyping mechanism. This is widely used by script libraries, for instance.\n• None Authors can use the microdata feature (the and attributes) to embed nested name-value pairs of data to be shared with other applications and sites.\n• None Authors can define, share, and use custom elements to extend the vocabulary of HTML. The requirements of valid custom element names ensure forward compatibility (since no elements will be added to HTML, SVG, or MathML with hyphen-containing local names in the future).\n\nThis specification defines an abstract language for describing documents and applications, and some APIs for interacting with in-memory representations of resources that use this language.\n\nThe in-memory representation is known as \"DOM HTML\", or \"the DOM\" for short.\n\nThere are various concrete syntaxes that can be used to transmit resources that use this abstract language, two of which are defined in this specification.\n\nThe first such concrete syntax is the HTML syntax. This is the format suggested for most authors. It is compatible with most legacy web browsers. If a document is transmitted with the MIME type, then it will be processed as an HTML document by web browsers. This specification defines the latest HTML syntax, known simply as \"HTML\".\n\nThe second concrete syntax is XML. When a document is transmitted with an XML MIME type, such as , then it is treated as an XML document by web browsers, to be parsed by an XML processor. Authors are reminded that the processing for XML and HTML differs; in particular, even minor syntax errors will prevent a document labeled as XML from being rendered fully, whereas they would be ignored in the HTML syntax.\n\nThe XML syntax for HTML was formerly referred to as \"XHTML\", but this specification does not use that term (among other reasons, because no such term is used for the HTML syntaxes of MathML and SVG).\n\nThe DOM, the HTML syntax, and the XML syntax cannot all represent the same content. For example, namespaces cannot be represented using the HTML syntax, but they are supported in the DOM and in the XML syntax. Similarly, documents that use the feature can be represented using the HTML syntax, but cannot be represented with the DOM or in the XML syntax. Comments that contain the string \" \" can only be represented in the DOM, not in the HTML and XML syntaxes.\n\nThis specification is divided into the following major sections:\n\nThere are also some appendices, listing obsolete features and IANA considerations, and several indices.\n\nHow to read this specification\n\nThis specification should be read like all other specifications. First, it should be read cover-to-cover, multiple times. Then, it should be read backwards at least once. Then it should be read by picking random sections from the contents list and following all the cross-references.\n\nAs described in the conformance requirements section below, this specification describes conformance criteria for a variety of conformance classes. In particular, there are conformance requirements that apply to producers, for example authors and the documents they create, and there are conformance requirements that apply to consumers, for example web browsers. They can be distinguished by what they are requiring: a requirement on a producer states what is allowed, while a requirement on a consumer states how software is to act.\n\nRequirements on producers have no bearing whatsoever on consumers.\n\nThis is a definition, requirement, or explanation.\n\nThis is an example.\n\nThis is an open issue.\n\nThe defining instance of a term is marked up like . Uses of that term are marked up like this or like this.\n\nThe defining instance of an element, attribute, or API is marked up like . References to that element, attribute, or API are marked up like .\n\nOther code fragments are marked up .\n\nVariables are marked up like .\n\nIn an algorithm, steps in synchronous sections are marked with ⌛.\n\nIn some cases, requirements are given in the form of lists with conditions and corresponding requirements. In such cases, the requirements that apply to a condition are always the first set of requirements that follow the condition, even in the case of there being multiple sets of conditions for those requirements. Such cases are presented as follows:\n\nA basic HTML document looks like this:\n\nHTML documents consist of a tree of elements and text. Each element is denoted in the source by a start tag, such as \" \", and an end tag, such as \" \". (Certain start tags and end tags can in certain cases be omitted and are implied by other tags.)\n\nTags have to be nested such that elements are all completely within each other, without overlapping:\n\nThis specification defines a set of elements that can be used in HTML, along with rules about the ways in which the elements can be nested.\n\nElements can have attributes, which control how the elements work. In the example below, there is a hyperlink, formed using the element and its attribute:\n\nAttributes are placed inside the start tag, and consist of a name and a value, separated by an \" \" character. The attribute value can remain unquoted if it doesn't contain ASCII whitespace or any of or . Otherwise, it has to be quoted using either single or double quotes. The value, along with the \" \" character, can be omitted altogether if the value is the empty string.\n\nHTML user agents (e.g., web browsers) then parse this markup, turning it into a DOM (Document Object Model) tree. A DOM tree is an in-memory representation of a document.\n\nDOM trees contain several kinds of nodes, in particular a node, nodes, nodes, nodes, and in some cases nodes.\n\nThe markup snippet at the top of this section would be turned into the following DOM tree:\n\nThe document element of this tree is the element, which is the element always found in that position in HTML documents. It contains two elements, and , as well as a node between them.\n\nThere are many more nodes in the DOM tree than one would initially expect, because the source contains a number of spaces (represented here by \"␣\") and line breaks (\"⏎\") that all end up as nodes in the DOM. However, for historical reasons not all of the spaces and line breaks in the original markup appear in the DOM. In particular, all the whitespace before start tag ends up being dropped silently, and all the whitespace after the end tag ends up placed at the end of the .\n\nThe element contains a element, which itself contains a node with the text \"Sample page\". Similarly, the element contains an element, a element, and a comment.\n\nThis DOM tree can be manipulated from scripts in the page. Scripts (typically in JavaScript) are small programs that can be embedded using the element or using event handler content attributes. For example, here is a form with a script that sets the value of the form's element to say \"Hello World\":\n\nEach element in the DOM tree is represented by an object, and these objects have APIs so that they can be manipulated. For instance, a link (e.g. the element in the tree above) can have its \" \" attribute changed in several ways:\n\nSince DOM trees are used as the way to represent HTML documents when they are processed and presented by implementations (especially interactive implementations like web browsers), this specification is mostly phrased in terms of DOM trees, instead of the markup described above.\n\nHTML documents represent a media-independent description of interactive content. HTML documents might be rendered to a screen, or through a speech synthesizer, or on a braille display. To influence exactly how such rendering takes place, authors can use a styling language such as CSS.\n\nIn the following example, the page has been made yellow-on-blue using CSS.\n\nFor more details on how to use HTML, authors are encouraged to consult tutorials and guides. Some of the examples included in this specification might also be of use, but the novice author is cautioned that this specification, by necessity, defines the language with a level of detail that might be difficult to understand at first.\n\nWhen HTML is used to create interactive sites, care needs to be taken to avoid introducing vulnerabilities through which attackers can compromise the integrity of the site itself or of the site's users.\n\nA comprehensive study of this matter is beyond the scope of this document, and authors are strongly encouraged to study the matter in more detail. However, this section attempts to provide a quick introduction to some common pitfalls in HTML application development.\n\nThe security model of the web is based on the concept of \"origins\", and correspondingly many of the potential attacks on the web involve cross-origin actions. [ORIGIN]\n\nCommon pitfalls to avoid when using the scripting APIs\n\nScripts in HTML have \"run-to-completion\" semantics, meaning that the browser will generally run the script uninterrupted before doing anything else, such as firing further events or continuing to parse the document.\n\nOn the other hand, parsing of HTML files happens incrementally, meaning that the parser can pause at any point to let scripts run. This is generally a good thing, but it does mean that authors need to be careful to avoid hooking event handlers after the events could have possibly fired.\n\nThere are two techniques for doing this reliably: use event handler content attributes, or create the element and add the event handlers in the same script. The latter is safe because, as mentioned earlier, scripts are run to completion before further events can fire.\n\nHow to catch mistakes when writing HTML: validators and conformance checkers\n\nAuthors are encouraged to make use of conformance checkers (also known as validators) to catch common mistakes. The WHATWG maintains a list of such tools at: https://whatwg.org/validator/\n\nUnlike previous versions of the HTML specification, this specification defines in some detail the required processing for invalid documents as well as valid documents.\n\nHowever, even though the processing of invalid content is in most cases well-defined, conformance requirements for documents are still important: in practice, interoperability (the situation in which all implementations process particular content in a reliable and identical or equivalent way) is not the only goal of document conformance requirements. This section details some of the more common reasons for still distinguishing between a conforming document and one with errors.\n\nThe majority of presentational features from previous versions of HTML are no longer allowed. Presentational markup in general has been found to have a number of problems:\n\nFor those reasons, presentational markup has been removed from HTML in this version. This change should not come as a surprise; HTML4 deprecated presentational markup many years ago and provided a mode (HTML4 Transitional) to help authors move away from presentational markup; later, XHTML 1.1 went further and obsoleted those features altogether.\n\nThe only remaining presentational markup features in HTML are the attribute and the element. Use of the attribute is somewhat discouraged in production environments, but it can be useful for rapid prototyping (where its rules can be directly moved into a separate style sheet later) and for providing specific styles in unusual cases where a separate style sheet would be inconvenient. Similarly, the element can be useful in syndication or for page-specific styles, but in general an external style sheet is likely to be more convenient when the styles apply to multiple pages.\n\nIt is also worth noting that some elements that were previously presentational have been redefined in this specification to be media-independent: , , , , , and .\n\nThe syntax of HTML is constrained to avoid a wide variety of problems.\n\nSome authors find it helpful to be in the practice of always quoting all attributes and always including all optional tags, preferring the consistency derived from such custom over the minor benefits of terseness afforded by making use of the flexibility of the HTML syntax. To aid such authors, conformance checkers can provide modes of operation wherein such conventions are enforced.\n\nRestrictions on content models and on attribute values\n\nBeyond the syntax of the language, this specification also places restrictions on how elements and attributes can be specified. These restrictions are present for similar reasons:\n\nTo avoid misuse of elements with defined meanings, content models are defined that restrict how elements can be nested when such nestings would be of dubious value. For example, this specification disallows nesting a element inside a element, since it is highly unlikely for an author to indicate that an entire section should be keyed in. Similarly, to draw the author's attention to mistakes in the use of elements, clear contradictions in the semantics expressed are also considered conformance errors. In the fragments below, for example, the semantics are nonsensical: a separator cannot simultaneously be a cell, nor can a radio button be a progress bar. Another example is the restrictions on the content models of the element, which only allows element children. Lists by definition consist just of zero or more list items, so if a element contains something other than an element, it's not clear what was meant. Cases where the default styles are likely to lead to confusion Certain elements have default styles or behaviors that make certain combinations likely to lead to confusion. Where these have equivalent alternatives without this problem, the confusing combinations are disallowed. For example, elements are rendered as block boxes, and elements as inline boxes. Putting a block box in an inline box is unnecessarily confusing; since either nesting just elements, or nesting just elements, or nesting elements inside elements all serve the same purpose as nesting a element in a element, but only the latter involves a block box in an inline box, the latter combination is disallowed. Another example would be the way interactive content cannot be nested. For example, a element cannot contain a element. This is because the default behavior of such nesting interactive elements would be highly confusing to users. Instead of nesting these elements, they can be placed side by side. Errors that indicate a likely misunderstanding of the specification Sometimes, something is disallowed because allowing it would likely cause author confusion. For example, setting the attribute to the value \" \" is disallowed, because despite the appearance of meaning that the element is enabled, it in fact means that the element is disabled (what matters for implementations is the presence of the attribute, not its value). Errors involving limits that have been imposed merely to simplify the language Some conformance errors simplify the language that authors need to learn. For example, the element's attribute, despite accepting both and values in practice as synonyms, disallows the use of the value, so as to simplify tutorials and other learning aids. There would be no benefit to allowing both, but it would cause extra confusion when teaching the language. Errors that involve peculiarities of the parser Certain elements are parsed in somewhat eccentric ways (typically for historical reasons), and their content model restrictions are intended to avoid exposing the author to these issues. For example, a element isn't allowed inside phrasing content, because when parsed as HTML, a element's start tag will imply a element's end tag. Thus, the following markup results in two paragraphs, not one: It is parsed exactly like the following: Errors that would likely result in scripts failing in hard-to-debug ways Some errors are intended to help prevent script problems that would be hard to debug. This is why, for instance, it is non-conforming to have two attributes with the same value. Duplicate IDs lead to the wrong element being selected, with sometimes disastrous effects whose cause is hard to determine. Some constructs are disallowed because historically they have been the cause of a lot of wasted authoring time, and by encouraging authors to avoid making them, authors can save time in future efforts. For example, a element's attribute causes the element's contents to be ignored. However, this isn't obvious, especially if the element's contents appear to be executable script — which can lead to authors spending a lot of time trying to debug the inline script without realizing that it is not executing. To reduce this problem, this specification makes it non-conforming to have executable script in a element when the attribute is present. This means that authors who are validating their documents are less likely to waste time with this kind of mistake. Errors that involve areas that affect authors migrating between the HTML and XML syntaxes Some authors like to write files that can be interpreted as both XML and HTML with similar results. Though this practice is discouraged in general due to the myriad of subtle complications involved (especially when involving scripting, styling, or any kind of automated serialization), this specification has a few restrictions intended to at least somewhat mitigate the difficulties. This makes it easier for authors to use this as a transitionary step when migrating between the HTML and XML syntaxes. For example, there are somewhat complicated rules surrounding the and attributes intended to keep the two synchronized. Another example would be the restrictions on the values of attributes in the HTML serialization, which are intended to ensure that elements in conforming documents end up in the same namespaces whether processed as HTML or XML. As with the restrictions on the syntax intended to allow for new syntax in future revisions of the language, some restrictions on the content models of elements and values of attributes are intended to allow for future expansion of the HTML vocabulary. For example, limiting the values of the attribute that start with an U+005F LOW LINE character (_) to only specific predefined values allows new predefined values to be introduced at a future time without conflicting with author-defined values. Errors that indicate a mis-use of other specifications Certain restrictions are intended to support the restrictions made by other specifications. For example, requiring that attributes that take media query lists use only valid media query lists reinforces the importance of following the conformance rules of that specification.\n\nThe following documents might be of interest to readers of this specification."
    },
    {
        "link": "https://freecodecamp.org/news/html-best-practices",
        "document": "HTML is the backbone of any website. It's the first thing people see. Without it, there would be no website.\n\nBecause of this, it's important that you stick to good coding practices. If you don't follow the best practices, you will create a bad user experience for the web user.\n\nThere's always something new to learn in HTML, whether you're a coding newbie or an experienced pro.\n\nIn this article, we will talk about the basic best practices of HTML.\n\nHTML best practices are rules that help you create websites that are easy to maintain and read.\n\nHere are some guidelines to keep in mind when building an HTML-based website:\n\nUse only one\n\nThere are six different heading tags in HTML, to . The tag is the main heading (subject of the web page) while the tag is the least important heading.\n\nThe tag is bigger than the tag, the tag is bigger than the tag, all the way down to the tag. Each of the headings decreases in size according to its importance.\n\nIt is important to avoid using more than one element for one code sheet.\n\nIn the above example, we used the tag on the first and second . Coding this way will work, but although you will achieve the same goal, this is not the best practice.\n\nDo this instead ⬇️:\n\nHaving only one element on a web page is vital for Search Engine Optimization (SEO). It helps search engines understand what a web page is all about (the main idea of a web page).\n\nDo not skip heading levels in HTML\n\nWhen using the header tags, it's vital to proceed from to to to and so on...\n\nDon't use and then jump to when using header tags. It's difficult for web visitors using a screen reader to understand the contents of your web page when you skip heading levels.\n\nA screen reader is a technology that helps people who have difficulty seeing access and interact with digital content, like websites or applications via audio or touch. The main users of screen readers are people who are blind or have very limited vision.\n\nYou can read a little introduction to screen readers here.\n\nDo this instead ⬇️:\n\nUse the figure element to add captions to your images in HTML\n\nIt's advisable to use the element when adding captions to your images. It is important to use the element along with the element for it to work.\n\nThe above example will work as expected but is not the best way to go about it. In a situation where the image fails to load you will have the text and the text on the element showing on the screen. It will be difficult for a web visitor using a screen reader to tell the difference between the and text.\n\nAlways keep in mind that just because your code works doesn't mean you're following best practices.\n\nDo this instead ⬇️:\n\nThe above example is the best way to add captions to your images.\n\nIt is important to add captions to your images this way for:\n• Search engine optimization: It is easier to find your images on search engines.\n• It will be easier for web visitors who use screen readers to understand the content of your web page.\n\nHTML semantic elements mark up the structure of a document in a more meaningful way on a webpage. It is best practice to use HTML semantic elements for the proper assembly of your web page.\n\nAvoid using in place of HTML semantics. Do not use elements to show headers and footers on your web page. Use semantic and elements instead.\n\nThe element shows the navigation or the opening part of the web page.\n\nThe element shows copyright information or navigation links about the web page.\n\nIn the above example, we used the tag as a container for the and . Coding this way will work, but although you will achieve the same goal, this is not the best practice.\n\nDo this instead ⬇️:\n\nThe above example is the best way to add and to your web page.\n\nIt is important to add and using HTML semantic elements because:\n• None Using semantic elements for your and makes your code easier to read.\n• None It provides a better user experience for web visitors. It will be easier for web visitors who use screen readers to understand the content of your web page.\n\nCheckout this article to know more about HTML semantic elements.\n\nAvoid using and to bold and italicize texts on a web page\n\nThe and tags are also known as the bold and italics tag. They are both used to highlight words in a text on a web page.\n\nYou shouldn't use and for bolding and italics because they have no semantic meaning. Use the CSS property or use the and the tags instead.\n\nYou use the tag to make a text on a webpage important. It highlights or bolds a text on a webpage. The tag emphasizes the text in a webpage. It also displays the text in italics like the tag.\n\nThe displayed texts will be bold and italicized in the example above. It will be of no importance to the web user using a screen reader. It has no semantic meaning.\n\nThe HTML5 specification says that the and tags should only be used as a last resort if no other tag is available.\n\nDo this instead ⬇️:\n\nBlock-level elements start in a new line on a web page. By default, they stretch from the beginning of the line to the end on a web page. You won't be able to add more content inline to a block element without using CSS.\n\nThe , , and the elements are some of the examples of a block level element.\n\nThe inline element covers the smallest area on a web page. They do not start on a new line on a web page.\n\nThe , , and the elements are some of the examples of inline elements.\n\nYou cannot wrap inside a element because is a block-level element and is an inline element.\n\nDo this instead ⬇️:\n\nThe above example is the best way to nest inline elements inside a block-level element.\n\nIt is important to note that:\n• The block-level element cannot be nested inside an inline element.\n• The inline element can be nested inside a block-level element.\n• The inline and the block-level element can be nested inside the block-level element.\n\nJust a quick note: nested, in the above example, means to place inside. So when I say it can't be nested, I'm referring to the fact that it can't be placed inside.\n\nI hope you understand these three simple rules used for nesting elements.\n\nIt is also possible to convert block-level elements to inline elements and vice versa using CSS. Use and to convert from block-level to inline element.\n\nIt's important to remember that just because your code works doesn't mean you're following best practices.\n\nThis is why I always recommend using the W3C markup validation service to double-check your codes.\n\nThis validator checks the markup validity of web documents in HTML, XHTML, SMIL, MathML, etc: W3c markup validation service.\n\nYou can double-check your code by copying its URL and pasting it on the site or uploading your HTML file.\n\nI hope this article helped you learn a thing or two about HTML best practices. I tried to include only the most useful tips so you can start using them right away!\n\nIf you have any other questions or comments, please feel free to contact me anytime on Twitter: @cessss_ and LinkedIn: Success\n\nI'll try to respond as soon as possible! Thank you for reading 💙."
    },
    {
        "link": "https://linkedin.com/pulse/html5-guide-best-practices-implementation-advantages-nazanin-teymoori",
        "document": "HTML5, the fifth iteration of the Hypertext Markup Language, marks a pivotal moment in the history of web development. The journey began with Tim Berners-Lee's creation of the World Wide Web in 1990, followed by the introduction of HTML2 and HTML3. HTML4 brought essential enhancements, including support for CSS and frames, but it lacked native multimedia capabilities. XHTML attempted to bridge the gap between HTML and XML but proved too complex. The need for a more adaptable and capable standard became evident as web applications and multimedia content gained prominence. In response, the Web Hypertext Application Technology Working Group (WHATWG) was formed in 2004, leading to the birth of HTML5. This open standard addressed the limitations of its predecessors by introducing native support for multimedia elements, improved form handling, offline storage, and much more. Major browsers embraced HTML5, fostering its widespread adoption. The collaboration between WHATWG and the World Wide Web Consortium (W3C) resulted in a unified HTML5 specification, which was officially published in 2014 as the new standard for web development. HTML5 continues to evolve, forming the backbone of the modern web and enabling the creation of dynamic, interactive, and multimedia-rich websites and applications.\n\nIn this HTML5 example, we use the <video> element to embed a video. We specify the video source (src) in different formats (in this case, MP4) for better cross-browser compatibility. The controls attribute adds video playback controls like play, pause, and volume. The text \"Your browser does not support the video tag\" is displayed for browsers that do not support the <video> element.\n• Removal of Deprecated Elements: HTML5 has removed several deprecated elements from previous HTML versions, including isindex, noframes, acronym, applet, basefont, dir, font, frame, frameset, big, center, strike, and tt. These elements were either no longer relevant or considered best practices in modern web development.\n• New Attributes: HTML5 introduced new attributes that enhance the capabilities of HTML elements. Some of these attributes include sandbox for creating isolated environments for web content, srcdoc for embedding content in iframes, and reversed for reversing the order of list items.\n• Global Attributes: HTML5 introduced global attributes that can be applied to various HTML elements. These attributes, such as hidden for hiding elements, role for defining the role of an element in accessibility, spellcheck for controlling spell checking, and translate for specifying whether an element's content should be translated, provide more control and customization options for web developers.\n• Customizable Data Attributes: In older versions of HTML, adding custom attributes could be risky, potentially causing rendering issues or invalid documents. HTML5 introduced the data-* attribute, which provides a safe and standardized way to store extra information about elements. These attributes can also be used for CSS styling or accessed through JavaScript libraries like jQuery. This flexibility allows developers to create engaging and efficient web pages without complex server-side lookups or Ajax calls."
    },
    {
        "link": "https://w3schools.com/css/css_navbar.asp",
        "document": "W3Schools offers a wide range of services and products for beginners and professionals, helping millions of people everyday to learn and master new skills."
    },
    {
        "link": "https://nobledesktop.com/learn/html-css/building-navigation-bars-techniques-using-html-and-css",
        "document": "Discover the art of coding links for external websites and internal pages through our HTML & CSS tutorial that delves into the use of anchor tags, hrefs, and the method of opening a link in a fresh browser window/tab."
    },
    {
        "link": "https://medium.com/@adamwojnicki/lets-build-a-simple-responsive-navigation-bar-with-html-css-and-a-little-bit-of-vanilla-js-5abba28da32e",
        "document": "Hello, Medium community! In my first article here I would like to share some basic skills of front-end web development by building a navigation bar that will look good on any device (desktop computer, tablet, smartphones).\n\nWhat do you need?\n\nFinal code of this tutorial is uploaded on Code Pen. The link can be found on the bottom of the article.\n\nLet’s start with writing our markup in html file:\n\nAs you can see we imported FontAwesome icons to our document, linked our .css stylesheet and our .js script. We also added some markup for our navigation bar in the <header> tag. Let’s look ho it looks so far:\n\nYep. As expected it looks like trash. So our next step is to add some style. In our CSS let’s format our navbar using flex CSS property:\n\nWe used display: flex property to make our logo, navlink list and hamburger icon displayed in one line instead of one under another. align-items: center makes the child elements vertically aligned in the middle of the bar. justify-content: space-around adds space around the neighboring child elements.\n\nIf we take a look at our document now, it will look like this:\n\nLet’s add some more styling to it so it will look more modern:\n\nSo we modified our CSS a little bit. We used Arial, Helvetica, sans-serif as our font stack. I like to set dark backgrounds in my projects so I set #232323 which is a very dark shade of grey as background color and for contrast I used light grey (#ccc) color for my text. It’s just my preference so you may use any colors, fonts you like. I also made fonts a little bit bigger for better readability. Note that .burger item display value has been set to none. It is important. We will make this icon appear on mobile devices only. Here’s how it looks like so far:\n\nWe can see that our navigation bar looks good on big displays. The problem appears when somebody will try to open our site on a mobile device. They will see something like this:\n\nHere is where CSS media queries come to action. In simple words media query is a block of CSS properties that are used only when certain conditions are true. In our case our condition will be display size. It means that different styles will be applied to our document when it’s opened on a device with smaller display (like smartphone or tablet).\n\nAt the bottom of our stylesheet let’s add following line of code:\n\nWhat it does is checking if the screen width of given device is less than 678px wide. If it is it will apply style properties from the inside of curly braces.\n\nNow let’s stop for a second and think. What kind of behavior we need from our navigation when opened on such a small device. First of all we would like our hamburger icon to appear instead of navigation links. We will also want the navigation links to be hidden by default and to appear only after tapping the hamburger icon (we will get to it later writing our .js).\n\nInside of our media query let’s add some style:\n\nAside from styling with text and background color there are way more important things. The burger icon is now visible by setting .burger’s display value to block. We set navigation menu’s position to absolute which means we can position this item wherever we like based on right and top properties. In this case it’s set to appear on the right side of the window. We set flex-direction to column so the menu items will appear one under another instead of one line. The height property is also worth attention. It’s set to calc() value. It sets the height of our side menu to the difference of height of the window and height of the navigation bar (which was set to 70px). Let’s have a look on it now:\n\nW still need our navigation menu to be hidden by default so let’s set .nav’s right value to -100%. It will move entire thing to the right by the 100% of it’s width so it will be hidden behind the right border of the window.\n\nSo we are almost there. Now we need to add interactivity to our navigation. What I mean is to trigger an action after en event occurs. In our case we want to make our side menu appear after clicking on the burger icon on the top right. We will also make the icon change to an X icon that will make the menu disappear. Before jumping to JavaScript let’s create yet another class inside of our media query in the .css file:\n\nThis class is not given to any HTML object yet. It will be added and removed with JS code in order to make side menu appear on the right side and disappear right behind it. Entire JavaScript code that operates this functionality is quite short and takes just a couple lines:\n\nFirstly, proper HTML objects are selected with .querySelector method. Personally it’s my favorite methond for selecting DOM objects. It allows to select items almost the same way as CSS.\n\nThen we declare a function toggleNav() which swithces between fa-bars and fa-times class. These classes are FontAwesome classes that represent icons we need. In effect it will change the burger icon to an x icon and back. And most importantly it till add and remove nav-active class which in effect will show and hide our side menu.\n\nLastly we add an event listener to the icon that in our case is clicking it. It will call the previously declared toggleNav function everytime the icon is clicked.\n\nSo far we managed to write markup, styles and JS code to cover basic functionality of our responsive navbar. My recommendation is to add some visual effects to it. For instance make the side navigation slide in smoothly by adding transition property to the nav class.\n\nAaaand that would be it for a simple responsive navigation bar.\n\nThere are plenty of things you may want to add/change/remove/do it our way. If you have such an idea please share it.\n\nI’ve uploaded project’s code on Code Pen so you can have a look on it, experiment, change stuff to check if it works :)\n\nAs I mentioned before this is my very first article here on Medium. Any feedback and opinion is very welcome so I may improve next time."
    },
    {
        "link": "https://geeksforgeeks.org/how-to-make-responsive-navbar-menu-in-css",
        "document": "A responsive navbar menu is a crucial element of a website that adjusts its layout and appearance based on the screen size and device type used by the user. This adaptability ensures that users can easily navigate the website and access its various features regardless of whether they are using a desktop, tablet, or mobile device.\n• None Create a CSS file and set the display-flex property as flex for <nav> element to use flexbox for layout. Set the justify-content property to space-between to keep the logo and links at opposite ends of the navbar. Apply spacing to nav links to keep space between links. Add hover effects to the navigation links for interactivity.\n• None We will use for responsiveness. When the screen width becomes less we will change the flex direction to the\n• None We will hide the navigation links by default and display them when a toggle button is clicked. Style the toggle button for visibility and interaction.\n\nExample: Implementation of creating a responsive navbar menu in CSS."
    },
    {
        "link": "https://stackoverflow.com/questions/17538998/navigation-bar-styling-with-css",
        "document": "I have a few navigation bars on the top of my view. I'm using MVC 4 Razor View to design my layout. Right now I managed to get the navigation bar with hover effect but I need to do something more.\n\nRight now this is what I have in my View.\n\nBy default I want to have the Home bar appeared as Orange color. And when user navigate to other bars Home bar will go back to normal and the selected bar will have the active styling.\n\nAnd in my _Layout.cshtml, here's my code."
    }
]