[
    {
        "link": "https://stackoverflow.com/questions/44772007/when-to-use-absolute-path-vs-relative-path-in-python",
        "document": "For reference. The absolute path is the full path to some place on your computer. The relative path is the path to some file with respect to your current working directory (PWD). For example:\n\nIf my PWD is , then the relative path to would be:\n\nCool, awesome. Now, I wrote some scripts which check if a file exists.\n\nThis returns if exists and it works.\n\nNow, instead if I write,\n\nIs there a definite time when we need to use one over the other? Is there a methodology for how python looks for paths? Does it try one first then the other?"
    },
    {
        "link": "https://pythoncheatsheet.org/cheatsheet/file-directory-path",
        "document": "There are two main modules in Python that deal with path manipulation. One is the module and the other is the module.\n\nOn Windows, paths are written using backslashes ( ) as the separator between folder names. On Unix based operating system such as macOS, Linux, and BSDs, the forward slash ( ) is used as the path separator. Joining paths can be a headache if your code needs to work on different platforms.\n\nFortunately, Python provides easy ways to handle this. We will showcase how to deal with both, and\n\nAnd using on *nix:\n\nalso provides a shortcut to joinpath using the operator:\n\nNotice the path separator is different between Windows and Unix based operating system, that’s why you want to use one of the above methods instead of adding strings together to join paths together.\n\nJoining paths is helpful if you need to create different file paths under the same directory.\n\nOh no, we got a nasty error! The reason is that the ‘delicious’ directory does not exist, so we cannot make the ‘walnut’ and the ‘waffles’ directories under it. To fix this, do:\n\nAnd all is good :)\n\nThere are two ways to specify a file path.\n• An absolute path, which always begins with the root folder\n• A relative path, which is relative to the program’s current working directory\n\nThere are also the dot ( ) and dot-dot ( ) folders. These are not real folders, but special names that can be used in a path. A single period (“dot”) for a folder name is shorthand for “this directory.” Two periods (“dot-dot”) means “the parent folder.”\n\nTo see if a path is an absolute path:\n\nYou can extract an absolute path with both and\n\nYou can get a relative path from a starting path to another path.\n\nUsing and together on Windows:\n\nThe module provides functions for copying files, as well as entire folders.\n\nWhile will copy a single file, will copy an entire folder and every folder and file contained in it:\n\nThe destination path can also specify a filename. In the following example, the source file is moved and renamed:\n\nIf there is no eggs folder, then will rename bacon.txt to a file named eggs:\n• None Calling or will delete the file at path.\n• None Calling or will delete the folder at path. This folder must be empty of any files or folders.\n• None Calling will remove the folder at path, and all files and folders it contains will also be deleted."
    },
    {
        "link": "https://stackoverflow.com/questions/77695077/absolute-vs-relative-file-path-python",
        "document": "Is it better to use a relative or absolute file path in Python, in both a situational setting and for best practice?\n\nI know what both of them do, and I'm wondering if, for example, always using an absolute file path is better practice than using a relative file path, or if it depends.\n\nAnd if it is a situational thing, when should you use one or the other?"
    },
    {
        "link": "https://courses.cs.washington.edu/courses/cse140/13wi/file-interaction.html",
        "document": "How do I interact with files in python?\n\nPython comes with libraries that allow your programs to interact with files in your computer. This document covers part of the module.\n\nYour computer drive is organized in a hierarchical structure of files and directories.\n• files -- These contain information. Examples include be csv files, or python files.\n• directories -- These contain files and directories inside of them\n\nYour filesystem starts from a root directory, notated by a forward slash on Unux and by a drive letter on Windows.\n\nAbsolute file paths are notated by a leading forward slash or drive label. For example, or . An absolute file path describes how to access a given file or directory, starting from the root of the file system. A file path is also called a pathname.\n\nRelative file paths are notated by a lack of a leading forward slash. For example, . A relative file path is interpreted from the perspective your current working directory. If you use a relative file path from the wrong directory, then the path will refer to a different file than you intend, or it will refer to no file at all.\n\nIn a sense, whenever you use a relative file path, it is joined with your current directory to create an absolute file path. That is, if my current working directory is and I use a relative file path of , then that is equivalent to using tho absolute file path .\n\nIn the following example usage of a Unix command-line shell, the current working directory is initially . There is a program called , which prints \"this is an example python program\". At first, the program can be referenced by the relative file path . After the directory is changed to , the relative file path to access the program becomes . Please note that the symbolizes a prompt where the user is allowed to type.\n\nWhen you run a python program, its current working directory is initialized to whatever your current working directory was when you ran the program. It can be retrieved using the function . Consider the following program, .\n\nThe following example usage of the command-line shell illustrates how Python's current working directory is set.\n\nThe function takes one argument: an absolute or relative pathname, which should refer to a directory. The function returns a list of relative pathnames (strings) of all files/directories inside of the given directory name.\n\nThese strings should be used relative to 's argument. Consider the following situation:\n• There is a directory inside of called . That is, this folder's absolute path is , and its relative path is\n\nThe following example usage shows a wrong and a right way to open\n\nNotice that when the first attempt to open the file was made, python reported that no file exists. Consider that we are trying to open the file with the absolute path of . When we try to use the relative path of (recall that this is interpreted as relative because it does not have a leading ), our computer will combine the relative path with the current working directory, which in this case is . This generates the incorrect absolute path of\n\nInstead, we can combine and using to generate the relative path . When we try to use this new relative path, our computer generates the absolute path , which is what we want.\n\nDo not combine paths using string concatenation ( ) or anything other than . Different computers represent paths in different ways. In particular, Windows uses \\ as a directory separator in pathnames, while Unix (Mac and Linux) machines use / as a directory separator in pathnames. Your code will not handle pathnames as elegantly and correctly as will."
    },
    {
        "link": "https://realpython.com/absolute-vs-relative-python-imports",
        "document": "If you’ve worked on a Python project that has more than one file, chances are you’ve had to use an import statement before.\n\nEven for Pythonistas with a couple of projects under their belt, imports can be confusing! You’re probably reading this because you’d like to gain a deeper understanding of imports in Python, particularly absolute and relative imports.\n\nIn this tutorial, you’ll learn the differences between the two, as well as their pros and cons. Let’s dive right in!\n\nYou need to have a good understanding of Python modules and packages to know how imports work. A Python module is a file that has a extension, and a Python package is any folder that has modules inside it (or, in Python 2, a folder that contains an file). What happens when you have code in one module that needs to access code in another module or package? You import it! But how exactly do imports work? Let’s say you import a module like so: The first thing Python will do is look up the name in . This is a cache of all modules that have been previously imported. If the name isn’t found in the module cache, Python will proceed to search through a list of built-in modules. These are modules that come pre-installed with Python and can be found in the Python Standard Library. If the name still isn’t found in the built-in modules, Python then searches for it in a list of directories defined by . This list usually includes the current directory, which is searched first. When Python finds the module, it binds it to a name in the local scope. This means that is now defined and can be used in the current file without throwing a . If the name is never found, you’ll get a . You can find out more about imports in the Python documentation here! Be aware that Python’s import system presents some significant security risks. This is largely due to its flexibility. For example, the module cache is writable, and it is possible to override core Python functionality using the import system. Importing from third-party packages can also expose your application to security threats. Here are a couple of interesting resources to learn more about these security concerns and how to mitigate them:\n• 10 common security gotchas in Python and how to avoid them by Anthony Shaw (Point 5 talks about Python’s import system.)\n• Episode #168: 10 Python security holes and how to plug them from the TalkPython podcast (The panelists begin talking about imports at around the 27:15 mark.) Now that you know how import statements work, let’s explore their syntax. You can import both packages and modules. (Note that importing a package essentially imports the package’s file as a module.) You can also import specific objects from a package or module. There are generally two types of import syntax. When you use the first one, you import the resource directly, like this: can be a package or a module. When you use the second syntax, you import the resource from another package or module. Here’s an example: can be a module, subpackage, or object, such as a class or function. You can also choose to rename an imported resource, like so: This renames the imported resource to within the script. It must now be referenced as , or it will not be recognized. PEP 8, the official style guide for Python, has a few pointers when it comes to writing import statements. Here’s a summary:\n• Imports should always be written at the top of the file, after any module comments and docstrings.\n• Imports should be divided according to what is being imported. There are generally three groups:\n• related third party imports (modules that are installed and do not belong to the current application)\n• local application imports (modules that belong to the current application)\n• Each group of imports should be separated by a blank line. It’s also a good idea to order your imports alphabetically within each import group. This makes finding particular imports much easier, especially when there are many imports in a file. Here’s an example of how to style import statements: Note that the imports come after the docstring. The import statements above are divided into three distinct groups, separated by a blank space. They are also ordered alphabetically within each group.\n\nYou’ve gotten up to speed on how to write import statements and how to style them like a pro. Now it’s time to learn a little more about absolute imports. An absolute import specifies the resource to be imported using its full path from the project’s root folder. Let’s say you have the following directory structure: There’s a directory, , which contains two sub-directories, and . The directory has two files, and . The directory has three files: two modules, and , and an initialization file, . It also contains a directory, , which in turn contains a file, . The following are practical examples of absolute imports: Note that you must give a detailed path for each package or file, from the top-level package folder. This is somewhat similar to its file path, but we use a dot ( ) instead of a slash ( ). Absolute imports are preferred because they are quite clear and straightforward. It is easy to tell exactly where the imported resource is, just by looking at the statement. Additionally, absolute imports remain valid even if the current location of the import statement changes. In fact, PEP 8 explicitly recommends absolute imports. Sometimes, however, absolute imports can get quite verbose, depending on the complexity of the directory structure. Imagine having a statement like this: That’s ridiculous, right? Luckily, relative imports are a good alternative in such cases!\n\nA relative import specifies the resource to be imported relative to the current location—that is, the location where the import statement is. There are two types of relative imports: implicit and explicit. Implicit relative imports have been deprecated in Python 3, so I won’t be covering them here. The syntax of a relative import depends on the current location as well as the location of the module, package, or object to be imported. Here are a few examples of relative imports: You can see that there is at least one dot in each import statement above. Relative imports make use of dot notation to specify location. A single dot means that the module or package referenced is in the same directory as the current location. Two dots mean that it is in the parent directory of the current location—that is, the directory above. Three dots mean that it is in the grandparent directory, and so on. This will probably be familiar to you if you use a Unix-like operating system! Let’s assume you have the same directory structure as before: You can import into the file this way: You’d use only one dot here because is in the same directory as the current module, which is . You can import and into the file this way: In the first import statement, the single dot means that you are importing from the current package. Remember that importing a package essentially imports the package’s file as a module. In the second import statement, you’d use a single dot again because is in the same directory as the current module, which is . One clear advantage of relative imports is that they are quite succinct. Depending on the current location, they can turn the ridiculously long import statement you saw earlier to something as simple as this: Unfortunately, relative imports can be messy, particularly for shared projects where directory structure is likely to change. Relative imports are also not as readable as absolute ones, and it’s not easy to tell the location of the imported resources."
    },
    {
        "link": "https://btelligent.com/en/blog/best-practice-working-with-paths-in-python-part-1-2",
        "document": "In smart manufacturing, a scalable edge platform and the ability to quickly implement business-relevant use cases are crucial for success. With Azure IoT Operations and Microsoft Fabric, Microsoft oﬀers two revolutionary technologies that provide real-time insights into production. Learn how these solutions unlock the potential of use cases such as predictive maintenance, process optimization and generative AI, transforming them from concepts into real value drivers."
    },
    {
        "link": "https://stackoverflow.com/questions/45684631/what-is-the-best-practice-for-working-with-files-and-paths",
        "document": "I am creating a python script that essentially takes a 'path to a file' as an argument by the user. It does some post processing and creates a new file in the same directory as the original file.\n\nI'm using the path I received itself to create a File Handler for\n\n\n\nI've been told to use to navigate to the folder instead and create my final file there instead of using paths directly. What is the best practice in such a scenario? Is there a risk in not changing the working directory?"
    },
    {
        "link": "https://reddit.com/r/learnpython/comments/16jo8g7/what_are_best_practices_for_file_paths_and",
        "document": "All of my learning in python so far involving paths to files has involved going in windows explorer, right-clicking on \"copy address as text\" and then pasting it in my code as a raw string.\n\nNow I want to iterate over several different csv files ending in \"ABC.csv\" , \"DEF.csv\" etc.\n\nBut I'm finding through google searches that I can't then change a variable into an r string or use variables within raw strings.\n\nShould I be handling path strings in a different way?"
    },
    {
        "link": "https://pythoncheatsheet.org/cheatsheet/file-directory-path",
        "document": "There are two main modules in Python that deal with path manipulation. One is the module and the other is the module.\n\nOn Windows, paths are written using backslashes ( ) as the separator between folder names. On Unix based operating system such as macOS, Linux, and BSDs, the forward slash ( ) is used as the path separator. Joining paths can be a headache if your code needs to work on different platforms.\n\nFortunately, Python provides easy ways to handle this. We will showcase how to deal with both, and\n\nAnd using on *nix:\n\nalso provides a shortcut to joinpath using the operator:\n\nNotice the path separator is different between Windows and Unix based operating system, that’s why you want to use one of the above methods instead of adding strings together to join paths together.\n\nJoining paths is helpful if you need to create different file paths under the same directory.\n\nOh no, we got a nasty error! The reason is that the ‘delicious’ directory does not exist, so we cannot make the ‘walnut’ and the ‘waffles’ directories under it. To fix this, do:\n\nAnd all is good :)\n\nThere are two ways to specify a file path.\n• An absolute path, which always begins with the root folder\n• A relative path, which is relative to the program’s current working directory\n\nThere are also the dot ( ) and dot-dot ( ) folders. These are not real folders, but special names that can be used in a path. A single period (“dot”) for a folder name is shorthand for “this directory.” Two periods (“dot-dot”) means “the parent folder.”\n\nTo see if a path is an absolute path:\n\nYou can extract an absolute path with both and\n\nYou can get a relative path from a starting path to another path.\n\nUsing and together on Windows:\n\nThe module provides functions for copying files, as well as entire folders.\n\nWhile will copy a single file, will copy an entire folder and every folder and file contained in it:\n\nThe destination path can also specify a filename. In the following example, the source file is moved and renamed:\n\nIf there is no eggs folder, then will rename bacon.txt to a file named eggs:\n• None Calling or will delete the file at path.\n• None Calling or will delete the folder at path. This folder must be empty of any files or folders.\n• None Calling will remove the folder at path, and all files and folders it contains will also be deleted."
    },
    {
        "link": "https://stackoverflow.com/questions/23529312/what-is-the-preferred-way-to-write-a-file-path-in-python",
        "document": "When writing a file path in python, I have seen several variations to write the syntax and I was curious if there is just one preferred way: the examples are:\n\nIf someone could provide some guidance, it would greatly be appreciated. Oh, just as a for info, my skill level in writing python is novice."
    }
]