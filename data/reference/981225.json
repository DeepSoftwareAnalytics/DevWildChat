[
    {
        "link": "https://stackoverflow.com/questions/37237954/calculate-the-lcm-of-a-list-of-given-numbers-in-python",
        "document": "I have written a code to find out the LCM (Lowest Common Multiple) of a list of numbers but there appears to be an error in my code. The code is given below:\n\nKindly pardon my poor choice of variables, I request you to see if the logic is correct and that the code is functional.\n\nThe syntax error which I am getting is that \"factors\" is invalid syntax though I don't agree with this. Please tell me where my code is wrong."
    },
    {
        "link": "https://stackoverflow.com/questions/51716916/built-in-module-to-calculate-the-least-common-multiple",
        "document": "There is no such thing built into the stdlib.\n\nHowever, there is a Greatest Common Divisor function in the library. (For Python 3.4 or 2.7, it's buried in instead.) And writing an LCM on top of a GCD is pretty trivial:\n\nOr, if you're using NumPy, it's come with an function for quite some time now."
    },
    {
        "link": "https://docs.python.org/3/library/functools.html",
        "document": ""
    },
    {
        "link": "https://w3resource.com/python-exercises/basic/python-basic-1-exercise-135.php",
        "document": "Python: Least Common Multiple (LCM) of more than two numbers\n\nWrite a Python program that calculates the Least Common Multiple (LCM) of more than two numbers. The numbers should be taken from a given list of positive integers.\n\nFrom Wikipedia,\n\n In arithmetic and number theory, the least common multiple, lowest common multiple, or smallest common multiple of two integers a and b, usually denoted by lcm(a, b), is the smallest positive integer that is divisible by both a and b. Since division of integers by zero is undefined, this definition has meaning only if a and b are both different from zero. However, some authors define lcm(a,0) as 0 for all a, which is the result of taking the lcm to be the least upper bound in the lattice of divisibility.\n\nHere is a breakdown of the above Python code:\n• The test function takes a list of positive integers as input and calculates the LCM of the numbers.\n• It uses the \"reduce()\" function to apply the \"lcm()\" function cumulatively to the elements of the input list.\n• The \"gcd()\" function calculates the Greatest Common Divisor (GCD) of two numbers using the Euclidean algorithm.\n• The \"lcm()\" function calculates the Least Common Multiple (LCM) of two numbers using the formula: LCM(a, b) = (a * b) / GCD(a, b).\n\nUse functools.reduce(), math.gcd() and lcm(x,y) = x * y / gcd(x,y) over the given list.\n\nHere is a breakdown of the above Python code:\n• The \"lcm()\" function takes a list of numbers as input and calculates the LCM of the numbers.\n• It uses the \"reduce()\" function to apply the lambda function cumulatively to the elements of the input list.\n• The lambda function calculates the LCM using the formula: LCM(a, b) = (a * b) / GCD(a, b).\n\nFor more Practice: Solve these Related Problems:\n• Write a Python program to compute the least common multiple (LCM) of a list of positive integers using the gcd function.\n• Write a Python program to calculate the LCM of multiple numbers by iteratively applying the LCM formula pairwise.\n• Write a Python program to find the LCM of an array of integers using the reduce function and math.gcd.\n• Write a Python program to determine the smallest common multiple for a list of numbers using a pairwise LCM approach.\n\nHave another way to solve this solution? Contribute your code (and comments) through Disqus.\n\nPrevious: Write a Python program to alternate the case of each letter in a given string and the first letter of the said string must be uppercase.\n\n Next: Write a Python program to reverse all the words which have odd length."
    },
    {
        "link": "https://geeksforgeeks.org/lcm-of-given-array-elements",
        "document": "In this article, we will learn how to find the LCM of given array elements.\n\nGiven an array of n numbers, find the LCM of it.\n\nWe know, [Tex]LCM(a, b)=\\frac{a*b}{gcd(a, b)} [/Tex]\n\nThe above relation only holds for two numbers, \n\n[Tex]LCM(a, b, c)\n\neq \\frac{a*b*c}{gcd(a, b, c)} [/Tex]\n\nThe main steps of our algorithm are:\n• None Iterate over all the elements of the array i.e. from i = 1 to i = n-1 \n\n At the ith iteration ans = LCM(arr[0], arr[1], …….., arr[i-1]). This can be done easily as LCM(arr[0], arr[1], …., arr[i]) = LCM(ans, arr[i]) . Thus at i’th iteration we just have to do ans = LCM(ans, arr[i]) = ans x arr[i] / gcd(ans, arr[i]) \n\n\n\nBelow is the implementation of the above algorithm :\n\nTime Complexity: O(n * log(min(a, b))), where n represents the size of the given array.\n\nAuxiliary Space: O(n*log(min(a, b))) due to recursive stack space.\n\n[Alternate Implementation] Recursive LCM Calculation – O(n * log(max(a, b)) Time and O(n) Space\n\nBelow is the implementation of the above algorithm Recursively :\n\nTime Complexity: O(n * log(max(a, b)), where n represents the size of the given array.\n\nAuxiliary Space: O(n) due to recursive stack space.\n\n[Efficient Approach] Using Euclidean Algorithm for GCD – O(n log n) Time and O(1) Space\n\nThe function starts by initializing the lcm variable to the first element in the array. It then iterates through the rest of the array, and for each element, it calculates the GCD of the current lcm and the element using the Euclidean algorithm. The calculated GCD is stored in the gcd variable.\n\nOnce the GCD is calculated, the LCM is updated by multiplying the current lcm with the element and dividing by the GCD. This is done using the formula LCM(a,b) = (a * b) / GCD(a,b).\n\n\n\nThe time complexity of the above code is O(n log n), where n is the length of the input array. This is because for each element of the array, we need to find the GCD, which has a time complexity of O(log n) using the Euclidean algorithm. Since we are iterating over n elements of the array, the overall time complexity becomes O(n log n).\n\nThe auxiliary space used by this algorithm is O(1), as only a constant number of variables are used throughout the algorithm, regardless of the size of the input array.\n\nThis code uses the reduce function from the functools library and the gcd function from the math library to find the LCM of a list of numbers. The reduce function applies the lambda function to the elements of the list, cumulatively reducing the list to a single value (the LCM in this case). The lambda function calculates the LCM of two numbers using the same approach as the previous implementation. The final LCM is returned as the result.\n\nThe time complexity of the program is O(n log n)\n\nThe auxiliary space used by the program is O(1)\n• None Finding LCM of more than two (or array) numbers without using GCD\n• None Inbuilt function for calculating LCM in C++"
    },
    {
        "link": "https://w3schools.com/python/ref_math_gcd.asp",
        "document": "W3Schools offers a wide range of services and products for beginners and professionals, helping millions of people everyday to learn and master new skills."
    },
    {
        "link": "https://geeksforgeeks.org/python-program-to-find-the-gcd-of-two-numbers",
        "document": "Python Program to Find the Gcd of Two Numbers\n\nThe task of finding the GCD (Greatest Common Divisor) of two numbers in Python involves determining the largest number that divides both input values without leaving a remainder. For example, if a = 60 and b = 48, the GCD is 12, as 12 is the largest number that divides both 60 and 48 evenly.\n\nEuclidean algorithm repeatedly replaces the larger number with the remainder of the division until the remainder is zero. The last non-zero divisor is the GCD.\n\nExplanation: while loop runs until b becomes 0. In each iteration, a is updated to b and b is updated to a % b. When b becomes 0, the value of a is the GCD .\n\nmath.gcd() function is a built-in function in python hence an efficient way to find the GCD of two numbers in Python, internally using the Euclidean algorithm.\n\nExplanation: math.gcd(a, b) takes and as arguments and returns their GCD. when it is called, it computes the GCD and directly returns the result.\n\nThis method repeatedly subtracts the smaller number from the larger one until both numbers become equal, resulting in the GCD.\n\nExplanation: while loop runs until a becomes equal to b. In each iteration, if a is greater than b, b is subtracted from a otherwise, a is subtracted from b. When both values become equal, that value is the GCD."
    },
    {
        "link": "https://stackoverflow.com/questions/11175131/code-for-greatest-common-divisor-in-python",
        "document": "The greatest common divisor (GCD) of a and b is the largest number that divides both of them with no remainder.\n\nOne way to find the GCD of two numbers is Euclid’s algorithm, which is based on the observation that if is the remainder when is divided by , then . As a base case, we can use .\n\nWrite a function called gcd that takes parameters and and returns their greatest common divisor."
    },
    {
        "link": "https://codecademy.com/resources/docs/python/math-module/math-gcd",
        "document": "The function in Python returns the Greatest Common Divisor (GCD) of two or more integers. The GCD is the largest positive integer that divides all of the given numbers without leaving a remainder.\n• : This represents the integers for which to compute the GCD.\n\nThe example below uses the function to return the greatest common divisor of the specified integers:\n\nThe output of the example code above is:\n\nNote: If function is called with no arguments or if all arguments are zero ( ), it will return zero ( ).\n\nRun the following example that uses the function to understand how it works:"
    },
    {
        "link": "https://docs.python.org/3/library/math.html",
        "document": "This module provides access to the mathematical functions defined by the C standard.\n\nThese functions cannot be used with complex numbers; use the functions of the same name from the module if you require support for complex numbers. The distinction between functions which support complex numbers and those which don’t is made since most users do not want to learn quite as much mathematics as required to understand complex numbers. Receiving an exception instead of a complex result allows earlier detection of the unexpected complex number used as a parameter, so that the programmer can determine how and why it was generated in the first place.\n\nThe following functions are provided by this module. Except when explicitly noted otherwise, all return values are floats.\n\nReturn the number of ways to choose k items from n items without repetition and without order. Evaluates to when and evaluates to zero when . Also called the binomial coefficient because it is equivalent to the coefficient of k-th term in polynomial expansion of . Raises if either of the arguments are not integers. Raises if either of the arguments are negative. Return n factorial as an integer. Raises if n is not integral or is negative. Changed in version 3.10: Floats with integral values (like ) are no longer accepted. Return the greatest common divisor of the specified integer arguments. If any of the arguments is nonzero, then the returned value is the largest positive integer that is a divisor of all arguments. If all arguments are zero, then the returned value is . without arguments returns . Changed in version 3.9: Added support for an arbitrary number of arguments. Formerly, only two arguments were supported. Return the integer square root of the nonnegative integer n. This is the floor of the exact square root of n, or equivalently the greatest integer a such that a² ≤ n. For some applications, it may be more convenient to have the least integer a such that n ≤ a², or in other words the ceiling of the exact square root of n. For positive n, this can be computed using . Return the least common multiple of the specified integer arguments. If all arguments are nonzero, then the returned value is the smallest positive integer that is a multiple of all arguments. If any of the arguments is zero, then the returned value is . without arguments returns . Return the number of ways to choose k items from n items without repetition and with order. Evaluates to when and evaluates to zero when . If k is not specified or is , then k defaults to n and the function returns . Raises if either of the arguments are not integers. Raises if either of the arguments are negative.\n\nReturn the ceiling of x, the smallest integer greater than or equal to x. If x is not a float, delegates to , which should return an value. Return the absolute value of x. Return the floor of x, the largest integer less than or equal to x. If x is not a float, delegates to , which should return an value. Fused multiply-add operation. Return , computed as though with infinite precision and range followed by a single round to the format. This operation often provides better accuracy than the direct expression . This function follows the specification of the fusedMultiplyAdd operation described in the IEEE 754 standard. The standard leaves one case implementation-defined, namely the result of and . In these cases, returns a NaN, and does not raise any exception. Return the floating-point remainder of , as defined by the platform C library function . Note that the Python expression may not return the same result. The intent of the C standard is that be exactly (mathematically; to infinite precision) equal to for some integer n such that the result has the same sign as x and magnitude less than . Python’s returns a result with the sign of y instead, and may not be exactly computable for float arguments. For example, is , but the result of Python’s is , which cannot be represented exactly as a float, and rounds to the surprising . For this reason, function is generally preferred when working with floats, while Python’s is preferred when working with integers. Return the fractional and integer parts of x. Both results carry the sign of x and are floats. Note that has a different call/return pattern than its C equivalents: it takes a single argument and return a pair of values, rather than returning its second return value through an ‘output parameter’ (there is no such thing in Python). Return the IEEE 754-style remainder of x with respect to y. For finite x and finite nonzero y, this is the difference , where is the closest integer to the exact value of the quotient . If is exactly halfway between two consecutive integers, the nearest even integer is used for . The remainder thus always satisfies . Special cases follow IEEE 754: in particular, is x for any finite x, and and raise for any non-NaN x. If the result of the remainder operation is zero, that zero will have the same sign as x. On platforms using IEEE 754 binary floating point, the result of this operation is always exactly representable: no rounding error is introduced. Return x with the fractional part removed, leaving the integer part. This rounds toward 0: is equivalent to for positive x, and equivalent to for negative x. If x is not a float, delegates to , which should return an value. For the , , and functions, note that all floating-point numbers of sufficiently large magnitude are exact integers. Python floats typically carry no more than 53 bits of precision (the same as the platform C double type), in which case any float x with necessarily has no fractional bits.\n\nReturn a float with the magnitude (absolute value) of x but the sign of y. On platforms that support signed zeros, returns -1.0. Return the mantissa and exponent of x as the pair . m is a float and e is an integer such that exactly. If x is zero, returns , otherwise . This is used to “pick apart” the internal representation of a float in a portable way. Note that has a different call/return pattern than its C equivalents: it takes a single argument and return a pair of values, rather than returning its second return value through an ‘output parameter’ (there is no such thing in Python). Return if the values a and b are close to each other and otherwise. Whether or not two values are considered close is determined according to given absolute and relative tolerances. If no errors occur, the result will be: . rel_tol is the relative tolerance – it is the maximum allowed difference between a and b, relative to the larger absolute value of a or b. For example, to set a tolerance of 5%, pass . The default tolerance is , which assures that the two values are the same within about 9 decimal digits. rel_tol must be nonnegative and less than . abs_tol is the absolute tolerance; it defaults to and it must be nonnegative. When comparing to , is computed as , which is for any nonzero and rel_tol less than . So add an appropriate positive abs_tol argument to the call. The IEEE 754 special values of , , and will be handled according to IEEE rules. Specifically, is not considered close to any other value, including . and are only considered close to themselves. Return if x is neither an infinity nor a NaN, and otherwise. (Note that is considered finite.) Return if x is a positive or negative infinity, and otherwise. Return if x is a NaN (not a number), and otherwise. Return . This is essentially the inverse of function . Return the floating-point value steps steps after x towards y. If x is equal to y, return y, unless steps is zero.\n• None goes up: towards positive infinity.\n• None goes down: towards minus infinity.\n• None goes towards zero.\n• None goes away from zero. Return the value of the least significant bit of the float x:\n• None If x is a NaN (not a number), return x.\n• None If x is equal to zero, return the smallest positive denormalized representable float (smaller than the minimum positive normalized float, ).\n• None If x is equal to the largest positive representable float, return the value of the least significant bit of x, such that the first float smaller than x is .\n• None Otherwise (x is a positive finite number), return the value of the least significant bit of x, such that the first float bigger than x is . ULP stands for “Unit in the Last Place”. See also and .\n\nReturn e raised to the power x, where e = 2.718281… is the base of natural logarithms. This is usually more accurate than or . Return e raised to the power x, minus 1. Here e is the base of natural logarithms. For small floats x, the subtraction in can result in a significant loss of precision; the function provides a way to compute this quantity to full precision: With one argument, return the natural logarithm of x (to base e). With two arguments, return the logarithm of x to the given base, calculated as . Return the natural logarithm of 1+x (base e). The result is calculated in a way which is accurate for x near zero. Return the base-2 logarithm of x. This is usually more accurate than . returns the number of bits necessary to represent an integer in binary, excluding the sign and leading zeros. Return the base-10 logarithm of x. This is usually more accurate than . Return x raised to the power y. Exceptional cases follow the IEEE 754 standard as far as possible. In particular, and always return , even when x is a zero or a NaN. If both x and y are finite, x is negative, and y is not an integer then is undefined, and raises . Unlike the built-in operator, converts both its arguments to type . Use or the built-in function for computing exact integer powers. Changed in version 3.11: The special cases and were changed to return instead of raising , for consistency with IEEE 754.\n\nReturn the Euclidean distance between two points p and q, each given as a sequence (or iterable) of coordinates. The two points must have the same dimension. Return an accurate floating-point sum of values in the iterable. Avoids loss of precision by tracking multiple intermediate partial sums. The algorithm’s accuracy depends on IEEE-754 arithmetic guarantees and the typical case where the rounding mode is half-even. On some non-Windows builds, the underlying C library uses extended precision addition and may occasionally double-round an intermediate sum causing it to be off in its least significant bit. For further discussion and two alternative approaches, see the ASPN cookbook recipes for accurate floating-point summation. Return the Euclidean norm, . This is the length of the vector from the origin to the point given by the coordinates. For a two dimensional point , this is equivalent to computing the hypotenuse of a right triangle using the Pythagorean theorem, . Changed in version 3.8: Added support for n-dimensional points. Formerly, only the two dimensional case was supported. Changed in version 3.10: Improved the algorithm’s accuracy so that the maximum error is under 1 ulp (unit in the last place). More typically, the result is almost always correctly rounded to within 1/2 ulp. Calculate the product of all the elements in the input iterable. The default start value for the product is . When the iterable is empty, return the start value. This function is intended specifically for use with numeric values and may reject non-numeric types. Return the sum of products of values from two iterables p and q. Raises if the inputs do not have the same length. For float and mixed int/float inputs, the intermediate products and sums are computed with extended precision.\n\nThe mathematical constant π = 3.141592…, to available precision. The mathematical constant e = 2.718281…, to available precision. The mathematical constant τ = 6.283185…, to available precision. Tau is a circle constant equal to 2π, the ratio of a circle’s circumference to its radius. To learn more about Tau, check out Vi Hart’s video Pi is (still) Wrong, and start celebrating Tau day by eating twice as much pie! A floating-point positive infinity. (For negative infinity, use .) Equivalent to the output of . A floating-point “not a number” (NaN) value. Equivalent to the output of . Due to the requirements of the IEEE-754 standard, and are not considered to equal to any other numeric value, including themselves. To check whether a number is a NaN, use the function to test for NaNs instead of or . Example: Changed in version 3.11: It is now always available. CPython implementation detail: The module consists mostly of thin wrappers around the platform C math library functions. Behavior in exceptional cases follows Annex F of the C99 standard where appropriate. The current implementation will raise for invalid operations like or (where C99 Annex F recommends signaling invalid operation or divide-by-zero), and for results that overflow (for example, ). A NaN will not be returned from any of the functions above unless one or more of the input arguments was a NaN; in that case, most functions will return a NaN, but (again following C99 Annex F) there are some exceptions to this rule, for example or . Note that Python makes no effort to distinguish signaling NaNs from quiet NaNs, and behavior for signaling NaNs remains unspecified. Typical behavior is to treat all NaNs as though they were quiet. Complex number versions of many of these functions."
    }
]