[
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/api/system.object.gethashcode?view=net-9.0",
        "document": "Some information relates to prerelease product that may be substantially modified before it’s released. Microsoft makes no warranties, express or implied, with respect to the information provided here.\n\nFor more information about this API, see Supplemental API remarks for Object.GetHashCode.\n\nA hash function is used to quickly generate a number (hash code) that corresponds to the value of an object. Hash functions are usually specific to each type and, for uniqueness, must use at least one of the instance fields as input. Hash codes should not be computed by using the values of static fields.\n\nFor classes derived from Object, the method can delegate to the base class GetHashCode() implementation only if the derived class defines equality to be reference equality. The default implementation of GetHashCode() for reference types returns a hash code that is equivalent to the one returned by the GetHashCode(Object) method. You can override GetHashCode() for immutable reference types. In general, for mutable reference types, you should override GetHashCode() only if:\n• None You can compute the hash code from fields that are not mutable; or\n• None You can ensure that the hash code of a mutable object does not change while the object is contained in a collection that relies on its hash code.\n\nOtherwise, you might think that the mutable object is lost in the hash table. If you do choose to override GetHashCode() for a mutable reference type, your documentation should make it clear that users of your type should not modify object values while the object is stored in a hash table.\n\nFor value types, GetHashCode() provides a default hash code implementation that uses reflection. You should consider overriding it for better performance.\n\nFor more information and examples that compute hash codes in a variety of ways, see the Examples section.\n\nA hash function must have the following properties:\n• None If two objects compare as equal, the GetHashCode() method for each object must return the same value. However, if two objects do not compare as equal, the GetHashCode() methods for the two objects do not have to return different values.\n• None The GetHashCode() method for an object must consistently return the same hash code as long as there is no modification to the object state that determines the return value of the object's System.Object.Equals method. Note that this is true only for the current execution of an application, and that a different hash code can be returned if the application is run again.\n• None For the best performance, a hash function should generate an even distribution for all input, including input that is heavily clustered. An implication is that small modifications to object state should result in large modifications to the resulting hash code for best hash table performance.\n• None Hash functions should be inexpensive to compute.\n• None The GetHashCode() method should not throw exceptions.\n\nFor example, the implementation of the GetHashCode() method provided by the String class returns identical hash codes for identical string values. Therefore, two String objects return the same hash code if they represent the same string value. Also, the method uses all the characters in the string to generate reasonably randomly distributed output, even when the input is clustered in certain ranges (for example, many users might have strings that contain only the lower 128 ASCII characters, even though a string can contain any of the 65,535 Unicode characters).\n\nProviding a good hash function on a class can significantly affect the performance of adding those objects to a hash table. In a hash table with keys that provide a good implementation of a hash function, searching for an element takes constant time (for example, an O(1) operation). In a hash table with a poor implementation of a hash function, the performance of a search depends on the number of items in the hash table (for example, an O( ) operation, where is the number of items in the hash table). A malicious user can input data that increases the number of collisions, which can significantly degrade the performance of applications that depend on hash tables, under the following conditions:\n• None When a large proportion of objects in a hash table produce hash codes that are equal or approximately equal to one another.\n• None When users input the data from which the hash code is computed.\n\nDerived classes that override GetHashCode() must also override Equals(Object) to guarantee that two objects considered equal have the same hash code; otherwise, the Hashtable type might not work correctly."
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/api/system.version.gethashcode?view=net-9.0",
        "document": "Some information relates to prerelease product that may be substantially modified before it’s released. Microsoft makes no warranties, express or implied, with respect to the information provided here.\n\nThe following code example demonstrates the Version constructor, and Major, Minor, Build, Revision, MajorRevision, and MinorRevision properties."
    },
    {
        "link": "https://stackoverflow.com/questions/371328/why-is-it-important-to-override-gethashcode-when-equals-method-is-overridden",
        "document": "I have overridden the Equals method because Foo represent a row for the Foo s table. Which is the preferred method for overriding the GetHashCode ?\n\nYes, it is important if your item will be used as a key in a dictionary, or , etc - since this is used (in the absence of a custom ) to group items into buckets. If the hash-code for two items does not match, they may never be considered equal (Equals will simply never be called). The GetHashCode() method should reflect the logic; the rules are:\n• if two things are equal ( ) then they must return the same value for\n• if the is equal, it is not necessary for them to be the same; this is a collision, and will be called to see if it is a real equality or not. In this case, it looks like \" \" is a suitable implementation. If you are testing multiple properties, it is common to combine them using code like below, to reduce diagonal collisions (i.e. so that has a different hash-code to ): In modern frameworks, the type has methods to help you create a hashcode from multiple values; on older frameworks, you'd need to go without, so something like: unchecked // only needed if you're compiling with arithmetic checks enabled { // (the default compiler behaviour is *disabled*, so most folks won't need this) int hash = 13; hash = (hash * 7) + field1.GetHashCode(); hash = (hash * 7) + field2.GetHashCode(); ... return hash; } Oh - for convenience, you might also consider providing and operators when overriding and . A demonstration of what happens when you get this wrong is here.\n\nJust to add on above answers: If you don't override Equals then the default behavior is that references of the objects are compared. The same applies to hashcode - the default implmentation is typically based on a memory address of the reference. Because you did override Equals it means the correct behavior is to compare whatever you implemented on Equals and not the references, so you should do the same for the hashcode. Clients of your class will expect the hashcode to have similar logic to the equals method, for example linq methods which use a IEqualityComparer first compare the hashcodes and only if they're equal they'll compare the Equals() method which might be more expensive to run, if we didn't implement hashcode, equal object will probably have different hashcodes (because they have different memory address) and will be determined wrongly as not equal (Equals() won't even hit). In addition, except the problem that you might not be able to find your object if you used it in a dictionary (because it was inserted by one hashcode and when you look for it the default hashcode will probably be different and again the Equals() won't even be called, like Marc Gravell explains in his answer, you also introduce a violation of the dictionary or hashset concept which should not allow identical keys - you already declared that those objects are essentially the same when you overrode Equals so you don't want both of them as different keys on a data structure which suppose to have a unique key. But because they have a different hashcode the \"same\" key will be inserted as different one.\n\nIt's not necessarily important; it depends on the size of your collections and your performance requirements and whether your class will be used in a library where you may not know the performance requirements. I frequently know my collection sizes are not very large and my time is more valuable than a few microseconds of performance gained by creating a perfect hash code; so (to get rid of the annoying warning by the compiler) I simply use: When you are in the position that you do need the performance than all of the issues mentioned by others here apply, of course. Most important - otherwise you will get wrong results when retrieving items from a hash set or dictionary: the hash code must not vary with the life time of an object (more accurately, during the time whenever the hash code is needed, such as while being a key in a dictionary): for example, the following is wrong as Value is public and so can be changed externally to the class during the life time of the instance, so you must not use it as the basis for the hash code: class A { public int Value; public override int GetHashCode() { return Value.GetHashCode(); //WRONG! Value is not constant during the instance's life time } } On the other hand, if Value can't be changed it's ok to use: class A { public readonly int Value; public override int GetHashCode() { return Value.GetHashCode(); //OK Value is read-only and can't be changed during the instance's life time } }\n\nYou should always guarantee that if two objects are equal, as defined by Equals(), they should return the same hash code. As some of the other comments state, in theory this is not mandatory if the object will never be used in a hash based container like HashSet or Dictionary. I would advice you to always follow this rule though. The reason is simply because it is way too easy for someone to change a collection from one type to another with the good intention of actually improving the performance or just conveying the code semantics in a better way. For example, suppose we keep some objects in a List. Sometime later someone actually realizes that a HashSet is a much better alternative because of the better search characteristics for example. This is when we can get into trouble. List would internally use the default equality comparer for the type which means Equals in your case while HashSet makes use of GetHashCode(). If the two behave differently, so will your program. And bear in mind that such issues are not the easiest to troubleshoot. I've summarized this behavior with some other GetHashCode() pitfalls in a blog post where you can find further examples and explanations.\n\nIn .NET, when you override the method, it's recommended to also override . The reason is related to how .NET uses in its built-in data structures. When you store an object in a hash-based collection like or , .NET uses the value returned by to organize its data. Objects that are considered equal should return the same hash code, providing optimal performance when retrieving objects from such a collection. If you override , you're changing the definition of what makes two objects equal. So, if you don't also override , objects that you consider \"equal\" may return different hash codes. This can lead to inconsistent behavior when objects are used in a hash-based collection. They might not be found in the collection, even though you know they're there, because the collection is looking in the wrong hash bucket. Let's see an example. Suppose, you have a class and you have overridden to say that two objects are equal if their property matches. But you forgot to override . Now, if you add a object with to a , and later try to check if the object with exists in the , it might return , which is incorrect, because the might be returning the hash code of the object reference, not the string which you're using for equality comparison. To avoid this issue, anytime you override , you should also override to ensure it uses the same properties that does. This will help maintain consistency when using hash-based collections. Overriding requires producing a hash code that considers the same properties used in , and is also evenly distributed to prevent hash collisions. Here is one example of how you might achieve this: public override int GetHashCode() { int hash = 17; // Suitable nullity checks etc, of course :) hash = (hash * 23) + field1.GetHashCode(); hash = (hash * 23) + field2.GetHashCode(); return hash; } In this example, and are the fields that the method checks. The constants and are just arbitrarily chosen 'magic' numbers that often give good results. You can also use in C# 8.0 and later: Remember, the goal of is not to avoid collisions entirely, but to distribute them evenly. Collisions are inevitable because the number of possible hash codes ( for ) is smaller than the number of possible string values, for example. But a good hash function will help ensure a more even distribution of hash code values and reduce the probability of collision, resulting in better performance when using hash-based collections."
    },
    {
        "link": "https://stackoverflow.com/questions/34505/is-object-gethashcode-unique-to-a-reference-or-a-value",
        "document": "Not sure what MSDN documentation you are referring to. Looking at the current documentation on Object.GetHashCode (http://msdn.microsoft.com/en-us/library/system.object.gethashcode.aspx) provides the following \"rules\":\n• None If two objects compare as equal, the GetHashCode method for each object must return the same value. However, if two objects do not compare as equal, the GetHashCode methods for the two object do not have to return different values.\n• None The GetHashCode method for an object must consistently return the same hash code as long as there is no modification to the object state that determines the return value of the object's Equals method. Note that this is true only for the current execution of an application, and that a different hash code can be returned if the application is run again.\n• None For the best performance, a hash function must generate a random distribution for all input.\n\nIf you are referring to the second bullet point, the key phrases here are \"as long as there is no modification to the object state\" and \"true only for the current execution of an application\".\n\nAlso from the documentation,\n\nA hash function is used to quickly generate a number (hash code) that corresponds to the value of an object. Hash functions are usually specific to each Type and must use at least one of the instance fields as input. [Emphasis added is mine.]\n\nAs for the actual implementation, it clearly states that derived classes can defer to the Object.GetHashCode implementation if and only if that derived class defines value equality to be reference equality and the type is not a value type. In other words, the default implementation of Object.GetHashCode is going to be based on reference equality since there are no real instance fields to use and, therefore, does not guarantee unique return values for different objects. Otherwise, your implementation should be specific to your type and should use at least one of your instance fields. As an example, the implementation of String.GetHashCode returns identical hash codes for identical string values, so two String objects return the same hash code if they represent the same string value, and uses all the characters in the string to generate that hash value."
    },
    {
        "link": "https://docs.unity3d.com/Packages/com.unity.entities@1.0/api/Unity.Entities.BlobAssetReference-1.GetHashCode.html",
        "document": "Generates the hash code for this object."
    },
    {
        "link": "https://discussions.unity.com/t/using-type-gettype-with-unity-objects/476600",
        "document": ""
    },
    {
        "link": "https://docs.unity3d.com/560/Documentation/ScriptReference/String.html",
        "document": "Select your preferred scripting language. All code snippets will be displayed in this language."
    },
    {
        "link": "https://discussions.unity.com/t/c-typeof-or-is/491478",
        "document": ""
    },
    {
        "link": "https://stackoverflow.com/questions/57030665/how-to-use-a-string-like-a-type",
        "document": "It's not entirely clear what you're asking, due to the lack of a good minimal, complete, and verifiable code example. In particular, while you say you want to retrieve an object by type, it's not clear from your post that there are in fact types having names like , , etc.\n\nAssuming there are though, then you should just use the non-generic overload, documented here: https://docs.unity3d.com/2018.4/Documentation/ScriptReference/Object.FindObjectOfType.html\n\nThen you can pass an actual object, retrieved by calling . Pay close attention to the documentation though:\n\ntypeName String\n\n The assembly-qualified name of the type to get. See AssemblyQualifiedName. If the type is in the currently executing assembly or in Mscorlib.dll, it is sufficient to supply the type name qualified by its namespace.\n\nIt's unlikely you can just pass e.g. the string to the method.\n\nFrankly, it would be much better for you to initialize your own table to look up the \"level manager\" objects. Assuming your \"level manager\" objects share a common base type, you can use that as the dictionary's value type, instead of .\n\nPresumably, this is something your code needs to do only infrequently. As long as this doesn't happen very often, it should be okay. Still, do note the guidance in the Unity3d documentation:\n\nIt is a general best practice to eliminate all usage of and in production code. As these APIs require Unity to iterate over all GameObjects and Components in memory, they rapidly become non-performant as the scope of a project grows."
    },
    {
        "link": "https://docs.unity3d.com/2019.1/Documentation/ScriptReference/String.html",
        "document": "Did you find this page useful? Please give it a rating:\n\nIs something described here not working as you expect it to? It might be a Known Issue . Please check with the Issue Tracker at\n\nWhat kind of problem would you like to report?\n\nThanks for letting us know! This page has been marked for review based on your feedback. If you have time, you can provide more information to help us fix the problem faster. Provide more information\n\nYou've told us this page needs code samples. If you'd like to help us further, you could provide a code sample, or tell us about what kind of code sample you'd like to see:\n\nYou've told us there are code samples on this page which don't work. If you know how to fix it, or have something better we could use instead, please let us know:\n\nYou've told us there is information missing from this page. Please tell us more about what's missing:\n\nYou've told us there is incorrect information on this page. If you know what we should change to make it correct, please tell us:\n\nYou've told us this page has unclear or confusing information. Please tell us more about what you found unclear or confusing, or let us know how we could make it clearer:\n\nYou've told us there is a spelling or grammar error on this page. Please tell us what's wrong:\n\nYou've told us this page has a problem. Please tell us more about what's wrong:"
    }
]