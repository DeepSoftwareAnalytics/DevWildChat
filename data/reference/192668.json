[
    {
        "link": "https://developer.android.com/guide/fragments/lifecycle",
        "document": "Each instance has its own lifecycle. When a user navigates and interacts with your app, your fragments transition through various states in their lifecycle as they are added, removed, and enter or exit the screen.\n\nTo manage lifecycle, implements , exposing a object that you can access through the method.\n\nEach possible state is represented in the enum.\n\nBy building on top of , you can use the techniques and classes available for Handling Lifecycles with Lifecycle-Aware Components. For example, you might display the device's location on the screen using a lifecycle-aware component. This component could automatically start listening when the fragment becomes active and stop when the fragment moves to an inactive state.\n\nAs an alternative to using a , the class includes callback methods that correspond to each of the changes in a fragment's lifecycle. These include , , , , , and .\n\nA fragment's view has a separate that is managed independently from that of the fragment's . Fragments maintain a for their view, which can be accessed using or . Having access to the view's is useful for situations where a Lifecycle-aware component should only perform work while a fragment's view exists, such as observing that is only meant to be displayed on the screen.\n\nThis topic discusses the lifecycle in detail, explaining some of the rules that determine a fragment's lifecycle state and showing the relationship between the states and the fragment lifecycle callbacks.\n\nWhen a fragment is instantiated, it begins in the state. For a fragment to transition through the rest of its lifecycle, it must be added to a . The is responsible for determining what state its fragment should be in and then moving them into that state.\n\nBeyond the fragment lifecycle, is also responsible for attaching fragments to their host activity and detaching them when the fragment is no longer in use. The class has two callback methods, and , that you can override to perform work when either of these events occur.\n\nThe callback is invoked when the fragment has been added to a and is attached to its host activity. At this point, the fragment is active, and the is managing its lifecycle state. At this point, methods such as return this fragment.\n\nis always called before any Lifecycle state changes.\n\nThe callback is invoked when the fragment has been removed from a and is detached from its host activity. The fragment is no longer active and can no longer be retrieved using .\n\nis always called after any Lifecycle state changes.\n\nNote that these callbacks are unrelated to the methods and . For more information on these methods, see Fragment transactions.\n\nWhen determining a fragment's lifecycle state, considers the following:\n• A fragment's maximum state is determined by its . A fragment cannot progress beyond the state of its .\n• As part of a , you can set a maximum lifecycle state on a fragment using .\n• A fragment's lifecycle state can never be greater than its parent. For example, a parent fragment or activity must be started before its child fragments. Likewise, child fragments must be stopped before their parent fragment or activity.\n\nFigure 1 shows each of the fragment's states and how they relate to both the fragment's lifecycle callbacks and the fragment's view .\n\nAs a fragment progresses through its lifecycle, it moves upward and downward through its states. For example, a fragment that is added to the top of the back stack moves upward from to to . Conversely, when a fragment is popped off of the back stack, it moves downward through those states, going from to to and finally .\n\nWhen moving upward through its lifecycle states, a fragment first calls the associated lifecycle callback for its new state. Once this callback is finished, the relevant is emitted to observers by the fragment's , followed by the fragment's view , if it has been instantiated.\n\nWhen your fragment reaches the state, it has been added to a and the method has already been called.\n\nThis would be the appropriate place to restore any saved state associated with the fragment itself through the fragment's . Note that the fragment's view has not been created at this time, and any state associated with the fragment's view should be restored only after the view has been created.\n\nThis transition invokes the callback. The callback also receives a argument containing any state previously saved by . Note that has a value the first time the fragment is created, but it is always non-null for subsequent recreations, even if you do not override . See Saving state with fragments for more details.\n\nThe fragment's view is created only when your provides a valid instance. In most cases, you can use the fragment constructors that take a , which automatically inflates the view at the appropriate time. You can also override to programmatically inflate or create your fragment's view.\n\nIf and only if your fragment's view is instantiated with a non-null , that is set on the fragment and can be retrieved using . The is then updated with the newly corresponding with the fragment's view. The lifecycle callback is also called at this time.\n\nThis is the appropriate place to set up the initial state of your view, to start observing instances whose callbacks update the fragment's view, and to set up adapters on any or instances in your fragment's view.\n\nAfter the fragment's view has been created, the previous view state, if any, is restored, and the view's is then moved into the state. The view lifecycle owner also emits the event to its observers. Here you should restore any additional state associated with the fragment's view.\n\nThis transition also invokes the callback.\n\nIt is strongly recommended to tie Lifecycle-aware components to the state of a fragment, as this state guarantees that the fragment's view is available, if one was created, and that it is safe to perform a on the child of the fragment. If the fragment's view is non-null, the fragment's view is moved to immediately after the fragment's is moved to .\n\nWhen the fragment becomes , the callback is invoked.\n\nWhen the fragment is visible, all and effects have finished, and the fragment is ready for user interaction. The fragment's moves to the state, and the callback is invoked.\n\nThe transition to is the appropriate signal to indicate that the user is now able to interact with your fragment. Fragments that are not should not manually set focus on their views or attempt to handle input method visibility.\n\nWhen a fragment moves downward to a lower lifecycle state, the relevant is emitted to observers by the fragment's view , if instantiated, followed by the fragment's . After a fragment's lifecycle event is emitted, the fragment calls the associated lifecycle callback.\n\nAs the user begins to leave the fragment, and while the fragment is still visible, the s for the fragment and for its view are moved back to the state and emit the event to their observers. The fragment then invokes its callback.\n\nOnce the fragment is no longer visible, the s for the fragment and for its view are moved into the state and emit the event to their observers. This state transition is triggered not only by the parent activity or fragment being stopped, but also by the saving of state by the parent activity or fragment. This behavior guarantees that the event is invoked before the fragment's state is saved. This makes the event the last point where it is safe to perform a on the child .\n\nAs shown in figure 2, the ordering of the callback and the saving of the state with differs based on API level. For all API levels prior to API 28, is invoked before . For API levels 28 and higher, the calling order is reversed.\n\nAfter all of the exit animations and transitions have completed, and the fragment's view has been detached from the window, the fragment's view is moved into the state and emits the event to its observers. The fragment then invokes its callback. At this point, the fragment's view has reached the end of its lifecycle and returns a value.\n\nAt this point, all references to the fragment's view should be removed, allowing the fragment's view to be garbage collected.\n\nIf the fragment is removed, or if the is destroyed, the fragment's is moved into the state and sends the event to its observers. The fragment then invokes its callback. At this point, the fragment has reached the end of its lifecycle.\n\nFor more information related to the fragment lifecycle, see the following additional resources."
    },
    {
        "link": "https://developer.android.com/guide/fragments",
        "document": "A represents a reusable portion of your app's UI. A fragment defines and manages its own layout, has its own lifecycle, and can handle its own input events. Fragments can't live on their own. They must be hosted by an activity or another fragment. The fragment’s view hierarchy becomes part of, or attaches to, the host’s view hierarchy.\n\nFragments introduce modularity and reusability into your activity’s UI by letting you divide the UI into discrete chunks. Activities are an ideal place to put global elements around your app's user interface, such as a navigation drawer. Conversely, fragments are better suited to define and manage the UI of a single screen or portion of a screen.\n\nConsider an app that responds to various screen sizes. On larger screens, you might want the app to display a static navigation drawer and a list in a grid layout. On smaller screens, you might want the app to display a bottom navigation bar and a list in a linear layout.\n\nManaging these variations in the activity is unwieldy. Separating the navigation elements from the content can make this process more manageable. The activity is then responsible for displaying the correct navigation UI, while the fragment displays the list with the proper layout.\n\nDividing your UI into fragments makes it easier to modify your activity's appearance at runtime. While your activity is in the lifecycle state or higher, fragments can be added, replaced, or removed. And you can keep a record of these changes in a back stack that is managed by the activity, so that the changes can be reversed.\n\nYou can use multiple instances of the same fragment class within the same activity, in multiple activities, or even as a child of another fragment. With this in mind, only provide a fragment with the logic necessary to manage its own UI. Avoid depending on or manipulating one fragment from another.\n\nFor more documentation and resources related to fragments, see the following.\n• Single Activity: Why, when, and how (Android Dev Summit '18)"
    },
    {
        "link": "https://geeksforgeeks.org/fragment-lifecycle-in-android",
        "document": "In Android, the fragment is the part of the Activity that represents a portion of the User Interface(UI) on the screen. It is the modular section of the Android activity that is very helpful in creating UI designs that are flexible in nature and auto-adjustable based on the device screen size. The UI flexibility on all devices improves the user experience and adaptability of the application. that can exist only inside an activity as its lifecycle is dependent on the lifecycle of the host activity. For example, if the host activity is paused, then all the methods and operations of the fragment related to that activity will stop functioning, the fragment is also termed a sub-activity. Fragments in Android can be added, removed, or replaced dynamically i.e., while the activity is running.\n\nBelow is the pictorial representation of fragment interaction with the activity:\n• Single Fragment: Display only one single view on the device screen. This type of fragment in android is mostly used for mobile phones.\n• List Fragment: This Fragment is used to display a list-view from which the user can select the desired sub-activity. The menu drawer of apps like Gmail is the best example of this kind of android fragment.\n• Fragment Transaction: This kind of fragments in android supports the transition from one fragment in android to another at run time. Users can switch between multiple fragments like switching tabs.\n\nThe very first method to be called when the fragment has been associated with the activity. This method executes only once during the lifetime of a fragment. \n\n When we attach fragment(child) to Main(parent) activity then it call first and then not call this method any time(like you run an app and close and reopen) simple means that this method call only one time. This method initializes the fragment by adding all the required attributes and components. System calls this method to create the user interface of the fragment. The root of the fragment’s layout is returned as the View component by this method to draw the UI. \n\n You should inflate your layout in onCreateView but shouldn’t initialize other views using findViewById in onCreateView. It indicates that the activity has been created in which the fragment exists. View hierarchy of the fragment also instantiated before this function call. The system invokes this method to make the fragment visible on the user’s device. This method is called to make the visible fragment interactive. It indicates that the user is leaving the fragment. System call this method to commit the changes made to the fragment. Method to terminate the functioning and visibility of fragment from the user’s screen. System calls this method to clean up all kinds of resources as well as view hierarchy associated with the fragment. It will call when you can attach new fragment and destroy existing fragment Resoruce It is called to perform the final clean up of fragment’s state and its lifecycle. The system executes this method to disassociate the fragment from its host activity. \n\n It will call when your fragment Destroy(app crash or attach new fragment with existing fragment)\n\nConsider Fragment-1 is A and Fragment-2 is B and A is attached to the Main Activity\n\n 1. If you can replace B with A.\n\n A’s call back:\n\n onDestroyView()\n\n onDestroy()\n\n onDetach()\n\n2. If you can replace B with A without Losing resources.\n\n A’s call back:\n\n onDestroy()\n\n onDetach()\n\nFragments in android are always embedded in Activities i.e., they are added to the layout of activity in which they reside. Multiple fragments can be added to one activity. This task can be carried out in 2 ways:\n• None Statically: Explicitly mention the fragment in the XML file of the activity. This type of fragment can not be replaced during the run time.\n• FragmentManager is used to embed fragments with activities that enable the addition, deletion, or replacement of fragments at run time.\n\nAlmost all android app uses dynamic addition of fragments as it improves the user experience. Below is the step-by-step implementation of adding 2 fragments in one activity. A default fragment will be visible when the activity appears on the screen and the user can switch between the 2 fragments at the run time.\n• None Click on File, then New => New Project.\n• None Select the minimum SDK as per your need.\n\nAll the strings which are used in the activity are listed in this file\n\nOpen the activity_main.xml file and add 2 buttons to it which will be used to switch between the 2 fragments. Further, add the fragment element in the activity layout. It is the area in which the fragments in android will be displayed.\n\nThese files contain only the onCreateView() method to inflate the UI of the fragment and returns the root of the fragment layout. If the fragment does not have any UI, it will return null.\n\nStep 5: Creating Layouts for both the fragments\n\nCreate two Layout Resource Files for both the fragments. Fragment displays a text on the screen and have a background color to differentiate their area in the Activity layout. Below is the code to implement this layout.\n\nNow, the functionality of the button to perform operations on clicking will be defined in the MainActivity class. Moreover, the code for the replacement of fragments during run time is also mentioned in this file. Below is the code to implement this step."
    },
    {
        "link": "https://medium.com/androiddevelopers/the-android-lifecycle-cheat-sheet-part-iii-fragments-afc87d4f37fd",
        "document": "In this section we’ll cover the behavior of a fragment that is attached to an activity. Don’t confuse this scenario with that of a fragment added to the back stack (see Tasks and Back Stack for more information on fragment transactions and the back stack).\n\nNote that it’s guaranteed that the Activity’s is executed before the Fragment’s. However, callbacks shown side by side — such as and — are executed in parallel and can therefore be called in either order. For example, the system might execute the Activity’s method before the Fragment’s method, but then execute the Fragment’s method before the Activity’s method.\n\nBe careful to manage the timing of the respective execution sequences so that you avoid race conditions."
    },
    {
        "link": "https://medium.com/androiddevelopers/the-android-lifecycle-cheat-sheet-part-i-single-activities-e49fd3d202ab",
        "document": "Android is designed to empower users and let them use apps in a intuitive way. For example, users of an app might rotate the screen, respond to a notification, or switch to another task, and they should be able to continue using the app seamlessly after such an event.\n\nTo provide this user experience, you should know how to manage component lifecycles. A component can be an Activity, a Fragment, a Service, the Application itself and even the underlying process. The component has a lifecycle, during which it transitions through states. Whenever a transition happens, the system notifies you via a lifecycle callback method.\n\nTo help us explain how lifecycles work, we’ve defined a series of scenarios which are grouped according to the components that are present:\n\nThe diagrams are also available as a cheat sheet in PDF format for quick reference."
    },
    {
        "link": "https://stackoverflow.com/questions/59382910/how-do-i-successfully-implement-viewpager-and-recyclerview-migrating-from-activi",
        "document": "Am following the udacity android basic nanodegree course and to implement recyclerView viewPager we are instructed to move code from activity to fragment, I have followed the instructions but when I run the app, It crashes before it even displays the first page and my debugger point me to a line(line 18) in the MainActivity.java file which is setContentView(R.layout.activity_main); I have done all fixes I could find on stack overflow and other tutorials I found but nothing seem to work for me. I have no idea what else to do. Help out. Pls\n\nthis is the xml layout of main activity\n\none of the activities and corresponding fragment with xml"
    },
    {
        "link": "https://stackoverflow.com/questions/27645144/adding-fragments-dynamically-on-both-side-of-the-viewpager-using-fragmentstatepa",
        "document": "In one of my apps, I need to add Fragments on both sides of the ViewPager. First of all, I will get a constant of 5 feeds, and my ViewPager will show feed at index 2 i.e. my current displayed Fragment will contain data present at index 2. So overall my ViewPager will show center of 5 feeds at start and that i have achieved by just setting the ViewPager current Item as 2 like this\n\nNow user can swipe both sides, when he will swipe left from center position, I will look for next feed i.e fetch from server and add feed at zero index of my ViewPager like this\n\nand when i swipe right from center position, i will add feed at the last simply like this\n\nNow the problem is if i only add feeds at the right i.e at the end of the feedsList, everything works fine, but problem comes when i add feeds at zero index. My adapter is not showing that new feed that has been added to zero position instead it is repeating one of the existing feed and that too on the right side but not on the left. I Have tried everything, but nothing is going right way. Here is my adapter code.\n\nI have also used this\n\nSo in severe need, If anyone had done that earlier and faced the same issue, please let me know what i am doing wrong. I only need to add fragment at zero index of my ViewPager."
    },
    {
        "link": "https://developer.android.com/develop/ui/views/animations/vp2-migration",
        "document": "Stay organized with collections Save and categorize content based on your preferences.\n\nis an improved version of the library that offers enhanced functionality and addresses common difficulties with using . If your app already uses , read this page to learn more about migrating to .\n\nIf you want to use in your app and are not currently using , read Slide between fragments using ViewPager2 and Create swipe views with tabs using ViewPager2 for more information.\n\nThe primary reason to migrate is that is receiving active development support and is not. However, also offers several other specific advantages.\n\nsupports vertical paging in addition to traditional horizontal paging. You can enable vertical paging for a element by setting its attribute:\n\nYou can also set this attribute programmatically using the setOrientation() method.\n\nsupports right-to-left (RTL) paging. RTL paging is enabled automatically where appropriate based on locale, but you can also manually enable RTL paging for a element by setting its attribute:\n\nYou can also set this attribute programmatically using the setLayoutDirection() method.\n\nsupports paging through a modifiable collection of fragments, calling to update the UI when the underlying collection changes.\n\nThis means that your app can dynamically modify the fragment collection at runtime, and will correctly display the modified collection.\n\nis built on , which means it has access to the utility class. This results in several benefits, but most notably it means that objects natively take advantage of the dataset change animations from the class.\n\nFollow these steps to update objects in your app to :\n\nFirst, replace the elements in your XML layout files with elements:\n\nWhen using , you had to extend the adapter class that supplied new pages to the object. Depending on the use case, used three different abstract classes. only uses two abstract classes.\n\nFor each object you are converting to a object, update the adapter class to extend the appropriate abstract class as follows:\n• When used to page through views, use with .\n• When used to page through a small, fixed number of fragments, use with .\n• When used to page through a large or unknown number of fragment, use with .\n\nFragment-based adapter classes inheriting from or always accept a single object as a constructor parameter. When you extend for a adapter class, you have the following options for constructor parameters instead:\n• The object or object where the object resides. In most cases, this is the better option.\n\nView-based adapter classes inheriting directly from do not require a constructor parameter.\n\nYour adapter classes also need to override different methods for than they did for :\n• Instead of , override . Other than the name, this method is unchanged.\n• Instead of , override in fragment-based adapter classes. Make sure that your new method always supplies a new fragment instance each time the function is called instead of reusing instances.\n\nIn summary, to convert a adapter class for use with , you must make the following changes:\n• Change the superclass to for paging through views, or for paging through fragments.\n• Override instead of in fragment-based adapter classes.\n\nintroduces changes to integration. If you currently use a with a object to display horizontal tabs for navigation, you need to refactor the object for integration with .\n\nhas been decoupled from and is now available as part of Material components. This means that in order to use it, you need to add the appropriate dependency to your file:\n\nYou also need to change the element's location in the hierarchy of your XML layout file. With , the element is declared as a child of the element; but with , the element is declared directly above the element, on the same level:\n\nFinally, you must update the code that attaches the object to the object. While uses its own method to integrate with , it requires a instance to integrate with .\n\nThe object also handles the task of generating page titles for the object, which means that the adapter class does not need to override :\n\ndoes not natively support nested scroll views in cases where the scroll view has the same orientation as the object that contains it. For example, scrolling would not work for a vertical scroll view inside a vertically-oriented object.\n\nTo support a scroll view inside a object with the same orientation, you must call on the object when you expect to scroll the nested element instead. The ViewPager2 nested scrolling sample demonstrates one way of solving this problem with a versatile custom wrapper layout.\n\nTo learn more about , see the following additional resources."
    },
    {
        "link": "https://medium.com/@myofficework000/implementation-of-viewpager2-with-android-kotlin-and-fragments-a-step-by-step-guide-78b8b9b65ca4",
        "document": "Before we begin, ensure you have the following:\n\n ✅ Basic understanding of Android development with Kotlin\n\n ✅ Android Studio installed on your system\n\n ✅ Familiarity with creating and managing Fragments\n• Open Android Studio and create a new project with an appropriate name.\n• Choose an Empty Activity template as the project’s starting point.\n• In the block, add the following line to include the ViewPager2 library:\n\n3. Sync the project to download the library.\n• Right-click on the package in the Project Explorer and select New -> Fragment -> Fragment (Blank).\n• Repeat this step to create multiple fragments that you want to display in the ViewPager2.\n• Replace the default layout with the following code:\n• Create a new Kotlin class for the ViewPager2 Adapter, e.g., .\n• Implement the and create a ViewHolder for the fragments.\n• Initialize the ViewPager2 and provide it with the adapter in the method:\n• Connect your Android device or start an emulator.\n• Swipe left and right to navigate between fragments.\n\n🎉 Congratulations! You have successfully implemented ViewPager2 with Fragments in your Android app.\n\nNow that you have successfully implemented ViewPager2, here are some additional use cases and advanced techniques to explore:\n\nCustom Tabs using ViewPager2 → Learn how to design and implement fully customized tab layouts.\n\nInfinite Fragments — Dynamic Tabs with ViewPager2 → Implement an infinite scrolling experience with ViewPager2.\n\nStay tuned for these upcoming tutorials to take your Android UI development to the next level!\n\n🔥 Got questions or suggestions? Drop a comment or reach out! Happy coding! 😊"
    },
    {
        "link": "https://developer.android.com/develop/ui/views/layout/recyclerview",
        "document": "Save and categorize content based on your preferences.\n\nRecyclerView makes it easy to efficiently display large sets of data. You supply the data and define how each item looks, and the RecyclerView library dynamically creates the elements when they're needed.\n\nAs the name implies, RecyclerView recycles those individual elements. When an item scrolls off the screen, RecyclerView doesn't destroy its view. Instead, RecyclerView reuses the view for new items that have scrolled onscreen. RecyclerView improves performance and your app's responsiveness, and it reduces power consumption.\n\nSeveral classes work together to build your dynamic list.\n• None is the that contains the views corresponding to your data. It's a view itself, so you add to your layout the way you would add any other UI element.\n• None Each individual element in the list is defined by a view holder object. When the view holder is created, it doesn't have any data associated with it. After the view holder is created, the binds it to its data. You define the view holder by extending .\n• None The requests views, and binds the views to their data, by calling methods in the adapter. You define the adapter by extending .\n• None The layout manager arranges the individual elements in your list. You can use one of the layout managers provided by the RecyclerView library, or you can define your own. Layout managers are all based on the library's abstract class.\n\nYou can see how all the pieces fit together in the RecyclerView sample app (Kotlin) or RecyclerView sample app (Java).\n\nIf you're going to use RecyclerView, there are a few things you need to do. They are explained in detail in the following sections.\n• None Decide how the list or grid looks. Ordinarily, you can use one of the RecyclerView library's standard layout managers.\n• None Design how each element in the list looks and behaves. Based on this design, extend the class. Your version of provides all the functionality for your list items. Your view holder is a wrapper around a , and that view is managed by .\n• None Define the that associates your data with the views.\n\nThere are also advanced customization options that let you tailor your RecyclerView to your exact needs.\n\nThe items in your RecyclerView are arranged by a class. The RecyclerView library provides three layout managers, which handle the most common layout situations:\n• arranges the items in a two-dimensional grid:\n• If the grid is arranged vertically, tries to make all the elements in each row have the same width and height, but different rows can have different heights.\n• If the grid is arranged horizontally, tries to make all the elements in each column have the same width and height, but different columns can have different widths.\n• is similar to , but it does not require that items in a row have the same height (for vertical grids) or items in the same column have the same width (for horizontal grids). The result is that the items in a row or column can end up offset from each other.\n\nYou also need to design the layout of the individual items. You need this layout when you design the view holder, as described in the next section.\n\nOnce you determine your layout, you need to implement your and . These two classes work together to define how your data is displayed. The is a wrapper around a that contains the layout for an individual item in the list. The creates objects as needed and also sets the data for those views. The process of associating views to their data is called binding.\n\nWhen you define your adapter, you override three key methods:\n• None : calls this method whenever it needs to create a new . The method creates and initializes the and its associated , but does not fill in the view's contents—the has not yet been bound to specific data.\n• None : calls this method to associate a with data. The method fetches the appropriate data and uses the data to fill in the view holder's layout. For example, if the displays a list of names, the method might find the appropriate name in the list and fill in the view holder's widget.\n• None : calls this method to get the size of the dataset. For example, in an address book app, this might be the total number of addresses. RecyclerView uses this to determine when there are no more items that can be displayed.\n\nHere's a typical example of a simple adapter with a nested that displays a list of data. In this case, the RecyclerView displays a simple list of text elements. The adapter is passed an array of strings containing the text for the elements.\n\n> * Provide a reference to the type of views that you are using // Create new views (invoked by the layout manager) // Create a new view, which defines the UI of the list item // Replace the contents of a view (invoked by the layout manager) // Get element from your dataset at this position and replace the // contents of the view with that element // Return the size of your dataset (invoked by the layout manager) > * Provide a reference to the type of views that you are using * Initialize the dataset of the Adapter * @param dataSet String[] containing the data to populate views to be used // Create new views (invoked by the layout manager) // Create a new view, which defines the UI of the list item // Replace the contents of a view (invoked by the layout manager) // Get element from your dataset at this position and replace the // contents of the view with that element // Return the size of your dataset (invoked by the layout manager)\n\nThe layout for the each view item is defined in an XML layout file, as usual. In this case, the app has a file like this:\n\nThe following code snippet shows how you can use the .\n\nThe library also offers many ways to customize your implementation. For more information, see Advanced RecyclerView customization.\n\nFollow these steps to enable an edge-to-edge display for a :\n• If the list items initially overlap the system bars, apply insets on the . You can do this by setting to or by using .\n• Allow the list items to draw under the system bars while scrolling by setting to on the .\n\nThe following video shows a with edge-to-edge display disabled (left) and enabled (right):\n\nFor more information about testing on Android, consult the following resources."
    }
]