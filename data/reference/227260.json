[
    {
        "link": "https://docs.oracle.com/javase/tutorial/uiswing/events/eventsandcomponents.html",
        "document": "The Java Tutorials have been written for JDK 8. Examples and practices described in this page don't take advantage of improvements introduced in later releases and might use technology no longer available. See Dev.java for updated tutorials taking advantage of the latest releases. See Java Language Changes for a summary of updated language features in Java SE 9 and subsequent releases. See JDK Release Notes for information about new features, enhancements, and removed or deprecated options for all JDK releases.\n\nYou can tell what kinds of events a component can fire by looking at the kinds of event listeners you can register on it. For example, the class defines these listener registration methods:\n\nThus, a combo box supports action, item, and context menu listeners in addition to the listener methods it inherits from .\n\nListeners supported by Swing components fall into two categories:\n\nBecause all Swing components descend from the AWT class, you can register the following listeners on any Swing component:\n\nAll Swing components descend from the AWT class, but many of them are not used as containers. So, technically speaking, any Swing component can fire container events, which notify listeners that a component has been added to or removed from the container. Realistically speaking, however, only containers (such as panels and frames) and compound components (such as combo boxes) typically fire container events.\n\nprovides support for three more listener types. You can register an ancestor listener to be notified when a component's containment ancestors are added to or removed from a container, hidden, made visible, or moved. This listener type is an implementation detail which predated hierarchy listeners.\n\nThe other two listener types are part of the Swing components' conformance to the JavaBeans specification. Among other things, this means that Swing components support bound and constrained properties and notify listeners of changes to the properties. Property change listeners listen for changes to bound properties and are used by several Swing components, such as formatted text fields, to track changes on a component's bound properties. Also, property change listeners, as well as vetoable change listeners are used by builder tools to listen for changes on constrained properties. For more information refer to the Properties lesson in the JavaBeans trail.\n\nThe following table lists Swing components and the specialized listeners they support, not including listeners supported by all s, s, or s. In many cases, the events are fired directly from the component. In other cases, the events are fired from the component's data or selection model. To find out the details for the particular component and listener you are interested in, go first to the component how-to section, and then if necessary to the listener how-to section."
    },
    {
        "link": "https://docs.oracle.com/javase/tutorial/uiswing/events/actionlistener.html",
        "document": "The Java Tutorials have been written for JDK 8. Examples and practices described in this page don't take advantage of improvements introduced in later releases and might use technology no longer available. See Dev.java for updated tutorials taking advantage of the latest releases. See Java Language Changes for a summary of updated language features in Java SE 9 and subsequent releases. See JDK Release Notes for information about new features, enhancements, and removed or deprecated options for all JDK releases.\n\nHow to Write an Action Listener\n\nAction listeners are probably the easiest — and most common — event handlers to implement. You implement an action listener to define what should be done when an user performs certain operation.\n\nAn action event occurs, whenever an action is performed by the user. Examples: When the user clicks a button, chooses a menu item, presses Enter in a text field. The result is that an message is sent to all action listeners that are registered on the relevant component.\n\nTo write an Action Listener, follow the steps given below:\n• Declare an event handler class and specify that the class either implements an ActionListener interface or extends a class that implements an ActionListener interface. For example:\n• Register an instance of the event handler class as a listener on one or more components. For example:\n• Include code that implements the methods in listener interface. For example: public void actionPerformed(ActionEvent e) { ...//code that reacts to the action... }\n\nIn general, to detect when the user clicks an onscreen button (or does the keyboard equivalent), a program must have an object that implements the ActionListener interface. The program must register this object as an action listener on the button (the event source), using the addActionListener method. When the user clicks the onscreen button, the button fires an action event. This results in the invocation of the action listener's actionPerformed method (the only method in the ActionListener interface). The single argument to the method is an ActionEvent object that gives information about the event and its source.\n\nLet us write a simple program which displays how many number of times a button is clicked by the user. First, here is the code that sets up the TextField , button and numClicks variable:\n\nIn the above example, the event handler class is AL which implements ActionListener.\n\nWe would like to handle the button-click event, so we add an action listener to the button b as below:\n\nIn the above code, Button b is a component upon which an instance of event handler class AL is registered.\n\nNow, we want to display the text as to how many number of times a user clicked button. We can do this by writing the code as below:\n\nNow, when the user clicks the Button b, the button fires an action event which invokes the action listener's actionPerformed method. Each time the user presses the button, numClicks variable is appended and the message is displayed in the text field.\n\nHere is the complete program(AL.java):\n\nMore Examples: program example is available in this trail's introduction to events, Introduction to Event Listeners. You can find the entire program in . The other example described in that section, , has two action sources and two action listeners, with one listener listening to both sources and the other listening to just one.\n\nBecause has only one method, it has no corresponding adapter class.\n\nThe following table lists some of the many examples that use action listeners."
    },
    {
        "link": "https://stackoverflow.com/questions/21997130/how-to-use-keylistener-with-jframe",
        "document": "So, I was trying to make a rectangle move with a ( ) and whenever I try to hit the key, the rectangle doesn't move.\n\nThe rectangle is drawn, but whenever I hit the and keys, nothing happens. I have two classes, one is my main class with the keyEvents and the frame and the other, draws the rectangle and holds the function to move the rectangle.\n\nHere is my code:\n\nAnd now the second class:\n\nPlease tell me how I can move the rectangle. Thanks in advance!"
    },
    {
        "link": "https://happycoding.io/tutorials/java/swing",
        "document": "So far, all of our Java programs have been command line programs, which we interacted with through the command prompt, if we interacted with the program at all.\n\nCommand line programs are fine for simple tasks or for programs that don’t really interact with the user, but if you want to interact with the user, then you probably want to create a graphical user interface, or GUI (pronounced “gee-you-eye” or “gooey”). GUIs are the types of programs you’re probably more accustomed to using: the types of programs that have windows and buttons and text fields instead of only using the command prompt.\n\nJava contains a bunch of classes that help you create GUIs, and this tutorial focuses on a set of classes that make up a library called Swing.\n\nNote: Swing is not an acronym! (Neither is Java, for that matter.)\n\nJava contains three different GUI libraries, which are each just a bunch of classes in the Java API that you can use. Trying to understand how all of these classes fit together can be confusing, so here’s a brief summary of how they work:\n• The Abstract Window Toolkit, or AWT, has been a part of Java since day one, way back in 1996. AWT works by passing in “native” calls to your computer. So if you create a checkbox in AWT, you’re really telling your operating system to create a checkbox. All of the AWT classes are in the package.\n• The downside of that approach is that your program will look different on different computers: a checkbox on Linux looks different from a checkbox on Windows. This can make it harder to layout your program or have a consistent experience across different platforms. To fix this, Swing was added to Java in 1998. The idea behind Swing is that instead of telling your computer to create a checkbox, Swing draws the checkbox itself. That way, the checkbox will look the same on different operating systems. The Swing classes are in the package. But Swing was built on top of AWT, so you’ll see Swing code using classes from the package as well.\n• JavaFX was originally developed as an external library in 2008, and it was included in Java in 2014. JavaFX focuses on modern GUI features, like more animations, CSS styling, and using a computer’s graphics card to handle the rendering. JavaFX classes are in the package, which is in a file that comes with Java.\n\nEven though JavaFX is newer, I’m focusing on Swing for a couple reasons:\n• The benefit of Swing being around longer is that there are a ton of resources for learning more about it. If you’re wondering how to do something in Swing, chances are somebody has asked your question on Stack Overflow.\n• I think Swing is a great way to become more comfortable with OOP, inheritance, and general program flow. So even if your end goal with programming isn’t Swing, it’s a good idea to spend some time here because it’ll help you learn other stuff you need to be learning.\n• I know Swing better than I know JavaFX.\n\nOne more thing worth noting: the above libraries, including Swing, are for creating a desktop application, which is a program that runs on your computer, not in a webpage. Think of opening up the Spotify application, not going to Spotify’s website. But like I said above, even if your end goal isn’t creating a desktop application in Java, it’s still a good idea to learn this stuff since it teaches you other stuff you need to know anyway.\n\nEnough history, to the tutorial!\n\nThe first step to creating a GUI is displaying a window, so you can interact with that instead of the command prompt. The class is Swing’s representation of a window, and it works like this:\n\nLet’s take it one line of code at a time:\n\nThis line of code creates an instance of the class, passing in a parameter that sets the title of the window.\n\nThis makes it so when you click the X button in the window, your program exits. If you don’t do this, your program could continue running in the background even after the window closes, which you probably don’t want.\n\nThis line of code sets the width and height of the window in pixels. Try passing in different values to change the size of the window.\n\nFinally, this actually pops the window up and shows it to the user. Notice that the program continues running even after our function ends!\n\nUsually you wouldn’t put all of your code in the method like that, except for very simple programs like this one. You would probably do something like this:\n\nThis code moves the logic from the function into the class, and the function simply creates an instance of that class. This isn’t much different from putting it all in the method, but this will make more sense as your code gets more complicated.\n\nYou might also split your code up like this:\n\nThis code does the same thing, but it splits the code up: it initializes the variable in the constructor, and it shows it in the function.\n\nIn any case, you would save this to a file named and then you’d compile and run it from the command line, just like the other programs we’ve seen so far. (Yeah, you still have to compile and run using the command line. We’ll talk about how to create an executable file in a later tutorial!)\n\nThe code causes a window to show:\n\nOur window is blank, because we haven’t added anything to it yet.\n\nIn addition to the class, Swing has a bunch of classes that represent different components you can add to a window: stuff like buttons, labels, checkboxes, and text areas. To use a component, you call to add it to the window. We’ll see some examples below.\n\nAs always, your best friend is the Java API, but here are a few of the most commonly used classes:\n\nThe class is Swing’s representation of a clickable button. Let’s add it to our GUI:\n\nFirst we construct a and make it so the program ends when we close it. Then we create an instance of the class, passing in an argument that sets the text of the button. Then we add the button the the window. Finally, we set the size of the window and show it.\n\nRight now the button just takes up the whole window, and nothing happens when you click it. We’ll fix that in a second.\n\nThe class is Swing’s representation of an undeditable text label. Let’s add it to our GUI:\n\nThis is almost the same as the code, except now we’re creating an instance of and adding it to the .\n\nRight now the label is left-aligned and uses the default font. We can fix that by calling functions on our instance:\n\nNow our has a large bold serif font, which it displays using a center alignment.\n\nYou can find other ways to customize your components by looking them up in the Java API! Try changing the text color of the .\n\nThe class is Swing’s representation of a box of text that the user can edit.\n\nThis gives us a box of text that the user can type into:\n\nAgain, you can customize this component using functions you find in the Java API. Try changing the font!\n\nThis tutorial isn’t meant to show you every single thing you can do with Swing. It’s meant to show you the basics so you can use the Java API to figure out exactly how to do what you want. Here are just a few other components you should check out:\n• and allow the user to select items from lists.\n• lets you add menus to your window.\n• and let the user adjust a value.\n• adds scroll bars to content that’s too large to fit in the window.\n\nTo learn how to use these components, look them up in the Java API and read about the constructors, functions, and variables they contain. Then put together a little example program that tests the component out before integrating it into your main project.\n\nSo far, we’ve only added a single component to our window. That’s not very exciting, but we can use the class to add multiple components to a window. is a component that holds other components. To use a , you’d follow this basic flow:\n• Add that to the .\n\nIt looks like this:\n\nThis code creates a , then creates a instance. It adds four different components to the , and then it adds that to the . Finally, it sets the size of the and shows it.\n\nBy default, the components are displayed one after the other, and they wrap to multiple rows if the window is not wide enough to fit them. Try changing the width of the window to see the components rearrange themselves.\n\nYou probably don’t want your components to be display like that though. You can change how they’re arranged using layout managers, which are classes that tell a how to arrange components.\n\nTo use a layout manager, you first create an instance of the layout manager you want to use, and then you pass it into the function of your . It looks like this:\n\nOf course, you can also pass the instance directly into the function instead of storing it in a variable first:\n\nAnd the constructor can take a layout manager as an argument:\n\nIn any case, this code uses a layout manager, which splits the up into 5 different areas: the top of the is , the bottom is , the left is , the right is , and the center is, well, . You can pass these values (which are static variables in the class) into the function along with the component to arrange them. Putting it all together, it looks like this:\n\nThis code uses a layout manager, and adds each component to a different section of the .\n\nNotice that the components stay in their positions, even when you resize the window. Also notice that the size of each component is set by the layout.\n\nThere are a bunch of other layout managers, and this tutorial is a great place to learn more about them. Here’s an example that uses :\n\nThis code sets a layout manager, which arranges the components in a single line, either horizontally or vertically depending on the value you pass into the constructor. Try changing the parameter to to see what happens!\n\nAgain, notice that the size of the components depends on the layout you use! This can be a little confusing, but it helps make sure your components do reasonable things when the user resizes the window.\n\nRemember that we can add components to instances, and is itself a component. That means we can add components to a with one layout manager, and then add that to another with a different layout manager! This is called nesting layouts, and it lets us bundle up multiple components and treat them as a single block in the overall layout.\n\nIf that sounds confusing, think about it this way: we can create a with a vertical that contains 5 instances. Then we can create another with a layout manager, and we can add the first to the section of the second !\n\nThis code creates a with a vertical , then adds five components to it. Then it creates another with another vertical , and it adds five components to it. Then it creates a third with a layout manager, and it adds the first two components to it.\n\nIn other words, it treats each set of components as a block that it lays out in the main window layout.\n\nThere isn’t really a limit to how much nesting you can have!\n\nSo far, our components haven’t done anything other than display. Nothing happens when we click a button, for example. We can change that by adding event listeners to our components.\n\nEvent listeners are objects that define functions that are called when a certain event happens: when the user clicks the mouse or presses a key on the keyboard, for example.\n\nFor example, let’s create an , which lets us trigger a function when the user clicks a button. is an interface, so the first step is to create a class that implements that interface:\n\nThe interface requires a single function named , and our class implements the interface by defining that function.\n\nNow that we have a class that implements , we can create an instance of this class and add it to a :\n\nThis code creates a and adds a to it. Then it creates an instance of our class and passes it into the function of our instance. Then the code sets the size of the window and displays it.\n\nNow, when we click the button, the function inside our class is called, and is printed to the console.\n\nWe probably want to do something a little more involved than just printing something to the console when the user clicks the button, though. Let’s say we want to change the text on the button to show how many times the user has clicked. To do that, we need a reference to the instance inside our class.\n\nOne way to get that reference is through the instance passed in as a parameter to the function. That class contains a function, which returns the object that generated the event: in our case, this is our instance! But the reference is an reference, so you have to cast it to to use functions from the class.\n\nThat might sound confusing, but it looks like this:\n\nNow our class contains a variable that keeps track of how many times the user has clicked. In the function, that variable is incremented. Then the code calls the function, casts the returned reference to and stores it in the variable. Finally, the code calls the function of that to display the click count. And since the variable points to the same instance that we’ve added to our , our displayed button’s text is updated.\n\nBut what if we wanted to update a different component that wasn’t the source of the event? For example, what if we want to update a whenever we click a ? To do that, we have to pass a reference to the ourselves. We could use a setter function, or we could use a constructor that took the as an argument:\n\nNow our class takes a argument in its constructor, and it updates the text of that whenever the function is called.\n\nBack in our function, we have to create a instance, add it to the window, and pass it into the constructor of our class. Putting it all together, it looks like this:\n\nThis code creates a and a , and then it creates a and a and adds both of them to the . The code then passes the into the constructor, and it adds that listener to the . Then it adds the to the and shows the window.\n\nNow when the user clicks the button, the text on the is updated.\n\nThe above examples use a named, top-level class that implements the interface, but rememeber that you can also implement an interface using inner classes and anonymous classes. This lets us include our listener code with our GUI code, like this:\n\nNow instead of using a separate class, we’re using an anonymous class that implements the interface. The logic is the same, but note that we’re no longer passing the into a constructor. Because this is an anonymous inner class, it has access to the variables in its enclosing scope (in this case, the function). That means it can reference the variable directly.\n\nYou can also shorten that into a single statement:\n\nNow instead of storing the instance of our anonymous class in a variable, we pass it directly into the function.\n\nAnonymous classes are often used when specifying listeners, which lets us keep logic related to a single component together, and avoids creating a bunch of classes we only use once.\n\nThere are a bunch of different kinds of event listeners, and you can add multiple listeners to the same component. You can also add listeners to the overall window. Here’s an example that adds a and a to the :\n\nThis might seem like a lot, but this code is only really doing a few things. First it creates a and a , and then it adds a to that . The interface requires five functions: , , , , and . In each of those functions, the text of the is set based on the values of the and functions, which return the position of the cursor.\n\nNext, a is added to the . The interface requires three functions: , , and . In each of those functions, the text of the is set based on the value of the function, which returns the key the user is hitting.\n\nThen the is added to the , and the is displayed.\n\nThe result is a window that displays information about the the events generated by the mouse and keyboard:\n\nThere are a bunch of other event listeners, and you should check out the Java API and this tutorial to learn more about them.\n\nSo far, we’ve learned how to create a GUI using the components that come with Swing. We can customize these components by specifying their layout, font size, color, border, etc. But if we want to do our own drawing, we have to create our own component that performs custom painting.\n\nLooking at the Java API, we can see that Swing components inherit a function named from the class. Basically, the function draws the stuff inside the component.\n\nSo, to create a custom component, we can extend a component class and override the function. Then we can put our drawing code inside the function. The class gives us a reasonable starting point since it’s just a blank component, so let’s extend that.\n\nThat sounds confusing, but it looks like this:\n\nThis code defines a class that extends the class and overrides the function, which takes a instance as an argument. The code then calls the super class’s function, which handles stuff like drawing the background of the component. Then the code calls the function, which draws an oval on the component.\n\nAnd because the class extends the class, we can use it just like any other component! We can add it to another or a to display it:\n\nThis code creates an instance of the class and adds it to a . This displays our component in a window, and we can see the circle we’re drawing:\n\nIn Swing, drawing is done through the instance passed into the function. You should check out the Java API to read about all the different functions you can call, and they should look pretty similar to Processing’s drawing functions. That’s because Processing is built on top of Java! In fact, Processing’s drawing functions actually end up calling Swing’s functions.\n\nHowever, there are a few differences between Processing’s drawing and Swing’s drawing:\n• The function is NOT automatically called 60 times per second. In fact, you don’t really have total control over when it’s called! It can be called when the window is resized, when you move the window, when other windows are moved, or whenever Swing feels like it. You should not rely on for timing!\n• Similarly, you should not put any “business logic” inside your function. That means stuff like user input should be handled using event listeners, and animation should be handled outside of the function. We’ll get to that in a second.\n• The class contains very similar functions to Processing. Processing’s function is the function in Swing, is , etc. There are a few differences though. For example, Processing uses a stroke color to draw both the shape’s outline and a fill color to draw its inner area. Swing splits that up into two functions, so to draw a circle with an outline you would first call and then to draw an outline around it. Similarly, both Processing and Swing use a coordinate system where is in the upper-left corner, but some of Swing’s individual functions are a little different: the function takes the upper-left corner of the circle, not the center.\n• Remember that custom painting happens in a class that extends , so we have access to the functions defined by that class (and all of its super classes). For example, the and functions return the width and height of the component.\n\nHere’s an example that shows some of what I’m talking about:\n\nAgain, this code creates a subcalss of . It also defines a constructor and calls the function (which it inherits from a superclass) and passes in a instance to set the background color. That line of code uses the constructor, which takes RGB arguments to create a color.\n\nThen in the function, it first calls the super class’s function, which handles stuff like drawing the background color. Then the code calls the function, which changes the drawing color. This line of code uses the static variable defined in the class, which is an easy way to use predefined colors instead of going through RGB every time. Then the code calls the function to draw the inside of a circle. Then it sets the color to black and draws the outline.\n\nOur main class code doesn’t change. It can still just treat our class as a component and add it to a to display it.\n\nLike I mentioned above, you have no control over when the function is called, so you shouldn’t use for stuff like animation or timing.\n\nInstead, you should use the class in the package. The class lets you specify an interval and an , and the will call the function of that at that interval. Here’s a simple example:\n\nThis code creates an implementation of using an anonymous class, and in its function it just prints a message to the console. Then the code calls the constructor, passing in an interval of 1000 milliseconds as well as the it just created. Then it calls the function on that instance. This causes the to call the function every 1000 milliseconds, which results in the message being printed to the console one time per second.\n\nNote that we could also have done it in a single statement:\n\nEither format is fine, or you could create a separate top-level class that implements instead of using an anonymous class. You’ll see a mix of all of these approaches in the real world.\n\nAnyway, now that we know how to create a to call code at an interval, and we know how to do custom painting, we can combine those ideas to create an animation!\n\nThe idea is the same as it was in Processing: we want to base our drawing off of variables, and we want to change those variables over time so that the drawing changes over time. Only instead of doing the drawing and changing in the same function, we want to split that up into two functions: one that contains the “business logic” of updating the variables and is triggered by the , and the function that draws a frame based on those variables.\n\nPutting it all together, it looks like this:\n\nThis code defines a class that extends and contains a variable that starts out at 0. In the constructor, the background color is set, and a is created. Every 16 milliseconds (60 times per second), the calls the function, which increments the variable and resets its value if it becomes greater than the height of the component. Then the calls the function, which is another inherited function that tells the component to redraw itself. This (eventually) causes the overridden function to be called, which draws the circle to the screen.\n• We’re using an anonymous inner class to create our implementation of that we’re passing into our , which means that we can access functions from the outer class inside the function. This is why we can call and directly.\n• We’re keeping our “business logic” isolated from our painting code. It’s a good idea to keep things separated like this.\n• You should think of the function as a suggestion for the component to redraw itself. This does not always mean the function will be called right away, and this isn’t the only time the function will be called! For example, on a busy system, you can call multiple times before the component has a chance to redraw itself. If you call 10 times before the component can redraw itself, you still only get one call to ! That’s why it’s important to keep your logic separate, so you can more reliably call it.\n\nAgain, our main code doesn’t change, and we can just create an instance of this class and add it to a to show it:\n\nWe can also add an event listener to add user interaction to our animation:\n\nThis is the same code as before, but now it adds a that moves the circle to wherever the cursor is when the user presses the mouse button.\n\nAnd just to show you another approach: instead of using anonymous classes for our listeners, we could have implemented the interfaces in our class, like this:\n\nThis code does the exact same thing as before. But now instead of using anonymous inner classes to implement the and interfaces, our class implements them by defining the body of their respective functions. Then we use the keyword to pass a self-reference into the constructor and function. Since this class implements those interfaces, it can be treated as its own or .\n\nEither approach is fine, and neither is more or less correct than the other. You could also split each listener into its own separate top-level class in its own file. Which approach you use depends on what makes more sense to you and how this stuff fits into your brain.\n\nThis tutorial isn’t meant to show you every detail about every single thing you can do in Swing. It’s meant to introduce you to the basic concepts Swing is built on, so you can then consult other resources to accomplish your goals. Here are a few places to get you started:\n• As always, the Java API is your best friend.\n• The official Swing tutorial is a good place to start and links to a bunch of other resources.\n• Using Swing Components introduces a ton of components and how to use them.\n• Laying out Components introduces different layout managers. The visual guide gives you a quick preview of what each one looks like.\n• Writing Event Listeners talks more about different types of event listeners.\n• Performing Custom Painting goes into more detail about doing your own drawing.\n\nIf you’re still confused after reading through the documentation, you can always Google stuff like “Java Swing set JButton border” for example. The Swing tag on Stack Overflow is also very active, but make sure you do a search before asking a question.\n\nAnd of course, you can always ask questions on the Happy Coding forum!\n• Create a GUI that does something useful, or something that’s not useful! Get creative!\n• Take some of your old Processing sketches and rewrite them using Swing."
    },
    {
        "link": "https://stackoverflow.com/questions/42596883/jframes-keylistener-with-actionlistener",
        "document": "I'm trying to add a KeyListener to my JFrame and the key pressed will do all the code inside an ActionListener class.\n\nWhen I press F1, it will trigger the ActionListener class. Doing all the instructions.\n\nAny help? Thank you in advance."
    },
    {
        "link": "https://stackoverflow.com/questions/76769595/how-to-lazy-load-images-in-java-swing",
        "document": "I want to load multiple images into a , and I prefer to load them on demand rather than all at once, especially since I'm using . Most of the images I load are from direct URLs, which I store in an of . I load them one by one in a using my method\n\nI tried to use and expected it to load the images only when they're visible in the , but it didn't work, and all the images still load simultaneously, which freezes the application. Most of the images I load are 10-50 KBs, so when I load 20 images, it doesn't freeze, but when I load 100, it freezes.\n\nHere is the class used to load the images.\n\nThank you so much in advance for your assistance!"
    },
    {
        "link": "https://oreilly.com/library/view/learning-java-4th/9781449372477/ch21s01.html",
        "document": "One of the challenges in building software for networked applications is that data is not always instantly available. Since some of Java’s roots are in Internet applications such as web browsers, its image handling APIs were designed specifically to accommodate the fact that images might take some time to load over a slow network, providing for detailed information about image-loading progress. While many client applications do not require handling of image data in this way, it’s still useful to understand this mechanism if for no other reason than it appears in the most basic image-related APIs. The Swing toolkit adds its own layer of image handling over this with components such as , which encapsulates an image source for you. After reading this chapter, you’ll have an understanding of how the layers fit together.\n\nIn the previous chapter, we mentioned that all operations on image data (e.g., loading, drawing, scaling) allow you to specify an “image observer” object as a participant. An image observer implements the interface, allowing it to receive notification as information about the image becomes available. The image observer is essentially a callback that is notified progressively as the image is loaded. For a static image, such as a GIF or JPEG data file, the observer is notified as chunks of image data arrive and also when the entire image is complete. For a video source or animation (e.g., GIF89), the image observer is notified at the end of each frame as the continuous stream of pixel data is generated. The image observer can do whatever it wants with this information. For example, in the last chapter we used the image observer built into the base class. Although you probably didn’t see it happen in our examples, the image observer invoked for us each time a new section of the image became available so that the picture, if it had taken a long time to load, would have displayed progressively. A different kind of image observer might have waited for the entire image before telling the application to display it; yet another use for an observer might be to update a loading meter showing how far the image loading had progressed. To be an image observer, implement the method, which is defined by the interface: is called by the graphics system, as needed, to pass the observer information about the construction of its view of the image. The parameter holds a reference to the object in question. is an integer whose bits specify what information about the image is now available. The flag values are defined as variables in the interface, as illustrated in this example: Run the example, supplying an image file as the command-line argument and observe the output. You’ll see a number of incremental messages about loading the image. The integer determines which of the other parameters— , , , and —hold valid data and what that data means. To test whether a particular flag in the integer is set, we have to resort to some binary shenanigans—using the ( ) operator). The and parameters play a dual role. If is set, they represent the size of the chunk of the image that has just been delivered. If or is set, however, they represent the overall image dimensions. Finally, returns a value indicating whether or not it’s interested in future updates. In this example, after requesting the object with , we kick-start the loading process with the Toolkit’s method, which takes our image observer as an argument. Using an Image API method such as , , or asking for image dimensions with or will also suffice to start the operation. Remember that although the method created the image object, it doesn’t begin loading the data until one of the image operations requires it. The example shows the lowest-level general mechanism for starting and monitoring the process of loading image data. You should be able to see how we could implement all sorts of sophisticated image loading and tracking schemes with this. The two most important strategies (to draw an image progressively, as it’s constructed, or to wait until it’s complete and draw it in its entirety) are handled for us. We have already seen that the class implements the first scheme. Another class, , is a general utility that tracks the loading of a number of images or other media types for us. We’ll look at it in the next section.\n\nis a utility class that simplifies life if we have to wait for one or more images to be loaded completely before they’re displayed. A monitors the loading of an image or a group of images and lets us check on them periodically or wait until they are finished. implements the interface that we just discussed, allowing it to receive image updates. The following code snippet illustrates how to use a to wait while an image is prepared: In this example, we created a trivial component called that accepts an image and draws a text status message until it is told that the image is loaded. It then displays the image. The only interesting part here is that we use a to load the image data for us, simplifying our logic. First, we create a to manage the image. The constructor takes a as an argument; this is supposed to be the component onto which the image is later drawn. This argument is somewhat of a holdover from earlier Java days with AWT. If you don’t have the component reference handy, you can simply substitute a generic component reference like so: After creating the , we assign it images to manage. Each image is associated with an integer that identifier we can use later for checking on its status or to wait for its completion. Multiple images can be associated with the same identifier, letting us manage them as a group. The value of the identifier is also meant to prioritize loading when waiting on multiple sets of images; lower IDs have higher priority. In this case, we want to manage only a single image, so we created one identifier called and passed it as the ID for our image in the call to . Next, we call the routine, which blocks on the image, waiting for it to finish loading. If successful, we tell our example component to use the image and repaint. Another method, , waits for all images to complete, not just a single ID. It’s possible to be interrupted here by an . We should also test for errors during image preparation with . In our example, we change the status message if we find one. The and methods may be used to poll periodically the status of images loading, returning or to indicate whether loading is finished. The method does this for the union of all images being loaded. Additionally, the and methods return a constant indicating the status or final condition of an image load. The value is one of the constant values: , , , or . For , the value is the bitwise OR value of all of the various statuses. This may seem like a lot of work to go through just to put up a status message while loading a single image. is more valuable when you are working with many raw images that have to be available before you can begin parts of an application. It saves implementing a custom for every application. For general Swing application work, you can use yet another simplification by employing the component to use a . This is covered next.\n\nIn Chapter 17, we discussed Swing components that can work with images using the interface. In particular, the class accepts an image filename or URL and can render it into a component. Internally, uses a to fully load the image in the call to its constructor. It can also provide the reference back. So, a shortcut to what we did in the last few sections—getting an image loaded fully before using it—would be: This quirky approach saves a few lines of typing, but uses an icon in an odd way and is not very clear. also gives you direct access to the it’s using through the method or tells you the load status through the method. This returns one of the constants: , , or .\n\nAs we mentioned in the introduction to Chapter 1, the package is a standard extension that deals with reading and writing many image formats. It is a part of the larger Java Advanced Imaging (JAI) API. This API supports advanced manipulation and display of images. While the AWT has a relatively fixed set of functionality, JAI is an extensible framework that accepts plug-ins for new image formats and features. The portion of JAI is bundled with Java 1.4 and later, so we can take advantage of it on all current Java releases. effectively supercedes the APIs we’ve talked about here with new ones for loading and monitoring image data, and although we won’t cover it in detail, we will discuss it briefly here for several reasons. First, it is fairly easy to use. Second, natively works with s and not just plain AWT s. As we’ll discuss throughout the rest of this chapter, buffered images can expose their pixel data for you to read or manipulate. Finally, using allows you both to load and save s to files. The core AWT has no tools for encoding image data for saving to files. Previously, we showed how easy it is to load an image with the static methods of the class, which accept either a , , or : In this example, we revealed that the type returned is actually a , which is a subtype of . The method, like the AWT method, automatically detects the image type and decodes it properly. Because is extensible, it’s useful to be able to list the types of images it can decode. You get this information with the method, which returns an array of strings corresponding roughly to file extensions for the image types it understands. ( does not rely on file extensions to detect image types; rather, it looks at the content of the file.) Images loaded by the methods are fully loaded before they are returned, so the method blocks until they are done. If you want more fine-grained information on the progress of image loading, you can use the interface of the package, which roughly corresponds to the AWT . To use it, you must delve a little deeper into the ImageIO API by first looking up an appropriate object with which to register the listener: This code is fairly straightforward. The is used like any of the AWT or Swing event interfaces we’ve seen before. You can refer to the Javadoc for the exact methods you must implement. Finally, in addition to the progress listener, two other listener APIs, and , offer information on pixel changes (e.g., for progressive loading) and loading errors. There are also, of course, “write” versions of all of these tools that handle the flip side, saving image data. We’ll return to that topic later in this chapter."
    },
    {
        "link": "https://coderanch.com/t/709947/java/load-unload-images-swing-application",
        "document": "Did you see how Paul cut 87% off of his electric heat bill with 82 watts of micro heaters?"
    },
    {
        "link": "https://stackoverflow.com/questions/18928204/using-swing-worker-to-load-images",
        "document": "runs in the background, in a separate , so doing something like...\n\nBasically says, do this and I will continue running...It won't wait for worker to complete.\n\nYou really shouldn't be loading images in methods anyway...and don't of resources you did not explicitly create (ie is a bad idea) and worries me, you shouldn't be trying to maintain a reference to any context you did not explicitly create...\n\nInstead, you should pass some kind of callback to the , so when it's done, it knows who to notify.\n\nNow, one of the reasons to use a is because it has functionality to allow you to more easily synchronise the background process with the Event Dispatching Thread, making it safer to interact with the UI without fear of generating dirty paints or dead locked threads :P"
    },
    {
        "link": "https://darksleep.com/notablog/articles/Rotate_Translate_and_Scale",
        "document": "A Brief Tutorial on Image Manipulation In Java\n\nby Steven J. Owens (unless otherwise attributed)\n\nI started down this little oddyssey when somebody posted on a mailing list, somewhere, about how to \"view, zoom, rotate and move images\". I remember this was a pain in the ass to figure out when I was doing it. Particularly the part about doing more than one at a time, I tended to get little errors creeping in as I added operations. Turns out that order of operation is important.\n\nBefore I go further, I highly recommend using Other Peoples Brains for this sort of thing. Java2D is slick and all, but it's a set of building blocks, not an application. Odds are, whatever your application, there are people out there who're already trying to build an open source equivalent of it. A good example would be the SVG Batik project, (http://xml.apache.org/batik/) which is an open source SVG implementation in java.\n\nHaving said all that, let's go ahead and do it the hard way, using Java2D and JFrame and Bufferedimage and AffineTransform.\n\nOkay, so first of all, we need a little application to actually load in and display an image.\n\nThis turns out to be surprisingly hard to figure out just from looking at the various APIs. Turns out the Java2D API doesn't have a whole lot to do with actually loading images, it's more preoccupied with generating them and manipulating them. So you can generate an image by drawing it with shapes and such, but we're not getting into that here.\n\nTo load in a pre-existing image, you have a few options. They're not easy to figure out from looking at the API docs, so I'll give you some hints. The favorite methods all seem to be quite connected to other things, like applets or icons:\n• javax.swing.ImageIcon lets you instantiate an ImageIcon with a filename as an argument, then you can get the Image with javax.swing.ImageIcon.getImage().\n• applet.getImage(URL) loads in an image from a URL.\n• com.sun.image.codec.jpeg.JPEGImageDecoder.decodeAsBufferedImage() will load in a JPEG file, but it is, of course, undocumented and unsupported. Oh joy.\n• In theory you can use java.awt.Component.createImage(ImageProducer producer), which is also available on javax.swing.JComponent. However, both of these beg the question of how you get an ImageProducer, and the answer is, I can't figure that out.\n• Likewise, java.awt.Toolkit.getImage(), but Toolkit is abstract, and so is Toolkit.getImage(). I'm not sure where you're supposed to get the concrete implementation.\n\n Ah, here it is, java.awt.Toolkit.getDefaultToolkit() will return whatever the appropriate Toolkit implementation is for your platform (usually that means the sun implementation. You're also going to need a java.awt.MediaTracker with this approach. Apparently the whole thing goes like so:\n\n MediaTracker tracker = new MediaTracker(this); defaultLoadImage = Toolkit.getDefaultToolkit().getImage(imageName); tracker.addImage(defaultLoadImage, 0); try { tracker.waitForAll(); } catch (InterruptedException e) { throw new Error(\"Could not load \" + imageName); }\n\nThis is all making my head spin. Here's a little sample application that loads and displays a JPEG image using Sun's JPEGDecoder.\n\nAffine Transforms are these nifty mathematical representations of various image manipulations, like scaling, rotating, shifting the location (called translating) and even warping the image (shearing). If you think about it, ultimately any image is just a big 2-dimensional array of pixels, and any manipulations you want to do can be thought of as a mathematical operation on that 2-dimensional array. (No, don't ask me to explain the math, if I could understand it, do you think I'd be talking to you about it?).\n\nLuckily for us, the fine folks at Sun provided an implementation, in the java.awt.geom.AffineTransform class.\n\nUnluckily, as is so often the case in GUI-oriented java stuff, it's not that simple. You see, we don't actually mess with the image, we mess with the display space, or rather the graphics context. The graphics context is sort of like a lense that we view the image through. So, rather than just apply some transforms to the image data, and then display it, we have to add the transforms to the graphics context, by overriding our image viewer's paint() method, casting the Graphics object parameter of paint() to a Graphics2D, adding an AffineTransform to the Graphics2D object, and then calling the drawImage()\n\nOkay, so in our sample code above, we displayed the image in a JFrame, on a JComponent. To mess with the image, we have to extend the code a little, like so:\n\n\n\n> I use JPanel in JFrame to view, rotate and scale images using \n\n> Graphics2D.\n\nI presume you're doing this with AffineTransforms?\n\n\n\n> How can I center the images in the window if the size of the \n\n> image is smaller then window?\n\nThis is way too complicated for me to explain it in depth in the time I have, but basically you keep track of your image dimension, window dimension, image rotation, move offset, and and I guess in your case zoom level. Come rendering time, you carry out a sequence of AffineTransforms based on the numbers.\n\nI suggest for now you assume symetric images, to simplify the math, and worry about asymetric images later - basically you handle his by calculating the numbers independently for width vs. height. Also, remember that for now we're assuming that this is all in the render step, you're just checking a set of numbers (scaling, etc) that you've been keeping track of.\n\nThe big gotcha to watch out for is order-of-operations. The one I found to work was: rotate, translate, scale. Do NOT assume you can switch the sequence and it'll still work the same.\n\nFirst you rotate it around it's center coordinate, i.e.\n\nDo this first, because you just plain don't want to deal with the grief of rotating an off-centered image and then figuring out the right set of offsets to translate it back to center. By doing this first, you keep it simple.\n\nThen you figure out how much you'll need to offset it. This is where you have to stop and think carefully about things like, how big the image is, how big you plan to scale it, how big the space you plan to draw it in is, etc. It's not that it takes any genius or twisty math, but it's easy to forget a step.\n\nIn this example, since we're assuming square images and square windows, it's easy, but even to say this clearly I have to stop and use a step by step list:\n\n1) take either dimension of the original image (width or height)\n\n2) multiply dimension by the scaling amount you're planning to use in the last step, to get the scaled image dimension.\n\n3) subtract scaled image dimension from the corresponding dimension of the window to get the difference.\n\n4) divide the difference in two to get the offset\n\n5) translate the image up and over by the offset with affineTransform.translate()\n\nNow, if you're going to use rectangular images or rectangular windows, this is complicated in two ways. First, you have to do that series of steps above independently for each window. Second, you have to figure out how the rotation affected the image height and width. If you're dealing with rotations that don't divide easily into 90 degree chunks, it's even more complicated, since you can't just flip the width/height around.\n\nNow, to further complicate matters, if you're going to deal with images that may be larger than the window, you have to figure out how the negative values, etc, affect things. However, other than that it really doesn't change the steps - you still have to figure out how much to shove it horizontally and vertically to keep it centerd. You'll have to use clipping, described at the URL below, to keep java from drawing any of the image that's outside the window:\n\nAnyway, so finally, you scale it with an affineTransform.scale(). Since you did all the annoying math before you scaled it, the scaled image should be centered nicely in your drawing area."
    }
]