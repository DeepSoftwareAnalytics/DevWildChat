[
    {
        "link": "https://stackoverflow.com/questions/55004354/why-are-variadic-macros-so-unpleasant",
        "document": "Variadic macros in CPP (the C/C++ preprocessor; for simplicity's sake I'll treat it as a single, separate language in this question) are extremely limited compared to, e.g., C++'s variadic templates. Essentially, variadic macros are just macros with a parameter whose argument is allowed to contain commas. This provides no straightforward way to count arguments, operate on arguments one by one, etc. Those things are possible, but require elaborate, confusing, and slow-to-compile hacks, such as those described in this question. The only thing that's anywhere near straightforward to do with is pass them to a variadic function.\n\nMy question is, why were they designed this way? The standard approach to lists in any pure-functional language like CPP is cons-style pattern matching: handle the first argument of a list and recurse for the rest, and have a base case for the empty list. The standards committee members would have been quite familiar with this approach.\n\nWhy was an approach like this not taken with CPP's variadic macros? Were variadic macros seen as simply a way to wrap variadic functions, such that there was no need to operate on the argument list? Was there some underlying issue that would have made it impractical to allow variadic macros to recurse? Or...?\n\nNOTE: I'm not looking for answers/comments of the form \"because people shouldn't want variadic macros\". The existence of things like boost.preprocessor indicates that reasonable people wanted to use the preprocessor in non-trivial ways. Also not looking for personal opinions on why some other design would be a good/bad idea. I'm trying to find out the actual reasoning from the time."
    },
    {
        "link": "https://learn.microsoft.com/en-us/cpp/preprocessor/variadic-macros?view=msvc-170",
        "document": "Variadic macros are function-like macros that contain a variable number of arguments.\n\nTo use variadic macros, the ellipsis may be specified as the final formal argument in a macro definition, and the replacement identifier may be used in the definition to insert the extra arguments. is replaced by all of the arguments that match the ellipsis, including commas between them.\n\nThe C Standard specifies that at least one argument must be passed to the ellipsis to ensure the macro doesn't resolve to an expression with a trailing comma. The traditional Microsoft C++ implementation suppresses a trailing comma if no arguments are passed to the ellipsis. When the compiler option is set, the trailing comma isn't suppressed."
    },
    {
        "link": "https://stackoverflow.com/questions/18909726/c-macro-with-a-variable-number-of-arguments",
        "document": "I would like to know how can I create a c++ macro that would make an or between a given number of arguments, something like\n\nBut with a varible number of arguments.\n\nI know about varadic macros, I know they exist and I know there are some questions about it on SO but as far as I know none of them addresses my question on how to do the || part."
    },
    {
        "link": "https://scs.stanford.edu/~dm/blog/va-opt.html",
        "document": ""
    },
    {
        "link": "https://akrzemi1.wordpress.com/2014/06/18/using-variadic-macros",
        "document": "Today I want to describe an issue I bumped onto recently. I had a function template that deals with two parameters ‚Äî and and needed to make sure that one is convertible to the other. In C++11 I would write:\n\nBut since I need my code that also needs to work on older compilers, I decided to go with Boost.StaticAssert. It is one of Boost libraries that allows the migration from old to new compilers. I just write:\n\nOn newer compilers this is replaced with keyword ; on older ones, it uses some sophisticated C++03 tricks to achieve (almost) the same result:\n\nI tested it on two compilers and it worked fine, so I committed the code, but when the full regression tests were run on many more compilers, some of them rejected my code as invalid. Do you know what they said? ‚ÄúAttempted to pass two arguments to a macro that expects only one argument.‚Äù If you look at the code above and if you are familiar with how macros work, the error message is clear. What the preprocessor sees it this:\n\nThat is, what we interpret as opening and closing angle brackets in a template, to a preprocessor is only a character. The preprocessor only assigns special meaning to commas and parentheses. Therefore, in order to fix the bug it is recommended that you use additional parentheses:\n\nNow, the preprocessor sees it differently:\n\nYou probably know that too. But what struck me was something different. Why is it only some compilers that rejected my code. Why did most of the other compilers accept my apparently buggy code and produced the right result?\n\nThe answer is in the title of this post. Boost.StaticAssert is clever and wherever possible it uses variadic macros. The macro is now defined something like this:\n\nNow, the following code:\n\nis still recognized as two arguments passed to macro, but it is now OK: all these arguments along with the separating commas are forwarded further (e.g., to ) to the code that knows how to interpret these tokens. This is a very nice usage of variadic macros.\n\nBut you can also wonder if it is a good idea to use this trick in Boost.StaticAssert. If the trick wasn‚Äôt there I would have immediately spotted the problem in my program, in my compilers. But because the library tried best to work around my bug on my compilers, it concealed the problem until the program was tested in other environments. In order for my code to be portable I still need to use the additional parentheses anyway."
    },
    {
        "link": "https://geeksforgeeks.org/initialize-a-vector-in-cpp-different-ways",
        "document": "Initializing a vector means assigning some initial values to the std::vector elements. In this article, we will learn 8 different ways to initialize a vector in C++.\n\nWe can initialize a vector with the list of values enclosed in curly braces {} known as initializer list. The values of the list will be assigned sequentially i.e. 1st value will be assigned to the 1st element of vector, 2nd value to 2nd element and so on.\n\nwhere, val1, val2, val3,‚Ä¶ are the initial values.\n\nOne by One Initialization\n\nVector can be initialized by pushing value one by one. In this method, an empty vector is created, and elements are added to it one by one using the vector::push_back() method. This method is mostly used to initialize vector after declaration.\n\nwhere, val is the value which we have to insert.\n\nWe can initialize all the elements of the vector to a single value. We create a vector of a specified size and initialize all elements to the same value using vector constructor.\n\nwhere, n is the size and val is the initial value.\n\nWe can also initialize a vector using plain old static arrays using vector constructor. This works by copying all the elements of the array to the newly created vector.\n\nwhere arr is the array name and n is the size of the array.\n\nWe can also initialize a newly created vector from an already created vector if they are of same type.\n\nwhere v1 is the already existing vector.\n\nVectors are flexible containers that can be initialized by any other already existing containers such as set, multiset, map, etc. if they are of same type.\n\nwhere first and last are the iterator to the first element and the element just after the last element in the range of STL container.\n\nWe can also use the std::fill function to initialize the whole or a part of a vector to the same value.\n\nwhere first and last are the iterator to the first element and the element just after the last element in the range of STL container and val is the value to be initialized with.\n\nThe std::iota() function from the <numeric> library allows us to initialize a vector with consecutive values starting from the given value.\n\nwhere first and last are the iterator to the first element and the element just after the last element in the range of the vector and val refers to the starting value."
    },
    {
        "link": "https://stackoverflow.com/questions/49846263/initializing-vector-in-a-class-with-capacity-resize",
        "document": "reserve() is not the same as resize(). See this answer for a detailed explanation. https://stackoverflow.com/a/7397862/9281750\n\nSince you want to initialize your vector with 10 elements(i.e. has a size of 10), you should use instead of inside your constructor.\n\nAn alternative solution would be to use the vector's constructor directly in the initialization list.\n\nAlso, a pointer to a std::vector is usually not necessary. You can simply make myVector a std::vector and pass-by-reference in a function. The following should perform the same thing"
    },
    {
        "link": "https://cplusplus.com/reference/vector/vector/resize",
        "document": ""
    },
    {
        "link": "https://medium.com/@ryan_forrester_/c-initialize-vector-with-size-how-to-guide-bf419adbc739",
        "document": "A Note From The Author That You‚Äôll Actually Want to Read\n\nHey there, I‚Äôm Ryan üëã . I hope you‚Äôre finding this article useful!\n\nI just wanted to tell you about something I built after one too many late-night debugging sessions.\n\nHere‚Äôs the truth: I was tired of spending hours hunting down bugs, scrolling through endless Stack Overflow threads, and getting generic AI responses that didn‚Äôt actually solve my problems.\n\nSo I built SolvePro (https://solvepro.co/ai/), and it turned out to be the tool I wish I‚Äôd had years ago.\n\nRemember that feeling when you finally understand a concept, and everything just clicks?\n\nThat‚Äôs what I wanted to create ‚Äî not just another AI tool, but an actual learning companion that helps those ‚Äúaha!‚Äù moments happen more often.\n\nWhat sets SolvePro apart from other AI‚Äôs is how it guides your learning journey. Based on your coding questions and style, it suggests quizzes and real projects that match your needs.\n\nMy Promise to You\n\nAs an educator and developer, I stand behind SolvePro‚Äôs quality. We‚Äôre constantly improving based on user feedback, and I personally read every suggestion. If it doesn‚Äôt help you become a better programmer, I want to know why.\n\nI believe everyone deserves access to quality programming education. That‚Äôs why you can get instant access to SolvePro at https://solvepro.co/ai/\n\n‚ÄúIt‚Äôs like having a really patient senior dev who actually wants to help you understand the problem.‚Äù\n\n‚ÄúThis helped me finally make sense of async programming. The personalized exercises made all the difference.‚Äù\n\nI built this because I believe coding should be less frustrating and more rewarding. If you try SolvePro and it doesn‚Äôt help, email me directly at help@solvepro.co, I want to know why so we can make it better."
    },
    {
        "link": "https://geeksforgeeks.org/vector-resize-c-stl",
        "document": "In C++, the vector resize() is a built-in method used to change the size of vector container after it is declared. It can be used to increase or decrease the size of vector.\n\nLet‚Äôs take a look at an example that illustrates the vector resize() method:\n\nThis article covers the syntax, usage, and common examples of vector resize() method in C++:\n\nThe vector resize() is the member method of std::vector defined inside <vector> header file.\n‚Ä¢ n: New size of vector. Can only be positive.\n‚Ä¢ val: Value by which extra elements of vector will be initialized. It is optional and by default is set to 0.\n‚Ä¢ None It does not return any value.\n\nThe below examples demonstrate the use of vector resize() function in different cases.\n\nExplanation: The extra elements after the new size are deleted.\n\nExplanation: Initially the size of vector is 3, after that we resize the vector to 7 and initialized the added 4 elements with value 9.\n\nWhat is difference between vector resize() and vector reserve()?\n\nWhat is the time complexity of vector resize()?\n\nDoes vector resize() free memory when reducing the size?"
    }
]