[
    {
        "link": "https://forums.raspberrypi.com/viewtopic.php?t=183474",
        "document": ""
    },
    {
        "link": "https://forum.armbian.com/topic/21191-no-way-to-get-device-serial-number-from-proccpuinfo-or-elsewhere",
        "document": "I'll start with questions then: \n\n 1) i got the armbian 5.17 kernel, patched the file, built a new .dtd, tried that on my device\n\n 2) Now i can see OTP device: \n\n\n\n\n\n But if I understand correctly, devices with NVMEM cells should be exposed to userspace as /sys/bus/nvmem/devices/somethingsomething/nvmem, but i got nothing there:\n\n\n\nSo, am I doing something wrong or this is expected behaviour? Do I need a loaded and active device driver for nvmem cells to be available via /sys/bus/nvmem or correct device tree definition should be enough?"
    },
    {
        "link": "https://redhat.com/en/blog/get-cpu-information-linux",
        "document": "Sometimes, you need to get information about the CPU on a machine, whether it's because you just can't remember what kind of CPU your computer has or you need a specific detail, such as the number of cores or whether it's 32- or 64-bit. Here are six ways to get that information on Linux.\n\nIf you use the GNOME desktop, you can see what kind of CPU you use in the Settings application.\n\nFirst, click the Activities button in the top-left corner of the GNOME desktop and type Settings. In the Settings window that appears, click About in the left column.\n\n[ Get the guide to installing applications on Linux. ]\n\nIf you use the KDE desktop, find all the CPU information you could ever need in the KInfocenter application.\n\nFirst, click the K Menu in the bottom-left corner of the KDE Plasma Desktop, and select Info Center. In the Info Center window, click Devices in the left column and then CPU.\n\n[ Keep your most commonly used commands handy with the Linux commands cheat sheet. ]\n\nWhile we often use the term \"Linux\" (or sometimes GNU+Linux) to refer to the operating system, it's a kernel first and foremost. As the binary responsible for bootstrapping your system, Linux has information about everything it's managing, including the CPU. This data is stored in the virtual filesystem in a file named . It's this file that applications like KInfocenter parse to deliver data about your CPU, but you can parse it yourself, too.\n\nIf all you need to know is the architecture of your CPU, you can use the command:\n\n[ Keep your most frequently used commands handy with the Linux commands cheat sheet. ]\n\nThe command is usually used to print information about your kernel. Because your kernel is highly dependent on your CPU, you can extract a lot of CPU data from its output. For example, you can get the vendor of your CPU with the ( for short) option:\n\nYou can also get the model of your CPU with the ( for short) option:\n\nAnd finally, the architecture with ( ):\n\nSometimes you need CPU information within a non-interactive interface. On Linux, any command you type into an interactive terminal session can be scripted so that it's non-interactive, but sometimes you're working with more than just a simple script. There are usually libraries for obtaining that information if you're using a compiled programming language and you need to determine what architecture you're on. However, you may also be able to do some rudimentary tests to determine the architecture without importing a special library.\n\nThere are too many programming languages for me to give an example of all of them, but here's a simple example in C++ of the kind of logic you might use:\n\nThis code checks SIZE_MAX to determine the potential maximum size of a variable. If it's set to 64-bit, then the CPU that compiled the code is capable of 64-bit.\n\nThat's not the only way to extract that kind of data; if you have libraries that make it even easier, you can use those.\n\nGetting insight into what CPU you're running is a useful trick to know. It may not come up often, but it's annoying when it occurs and you're caught without the necessary information.\n\nI've covered all the ways I could think of to get CPU information in this article, but there are many other ways I haven't thought of. How do you get CPU information on your systems? Email us at enable-sysadmin@redhat.com to let us know."
    },
    {
        "link": "https://forums.raspberrypi.com/viewtopic.php?t=156820",
        "document": ""
    },
    {
        "link": "https://stackoverflow.com/questions/5045450/how-to-get-cpu-serial-under-linux-without-root-permissions",
        "document": "CPUs has no serial number; maybe that you want DMI basic info without root privilege (This will only show you a persistent id of your motherboard manufacturer and model, but no serial number):\n\nOtherwise you could \"tell\" dmidecode to run from unprivileged user:\n\nThen you could run for instance:\n\nIn most cases \"system-serial-number\" is like either \"chassis-serial-number\" or \"baseboard-serial-number\". Remember that not all distros have this program installed, for instance, Debian based systems have a package named after it.\n\nOtherwise you can find a unique and persistent, thro' installs, system ID via your system's disk; to do that you may run the following:\n\nThe former will give you device's path where your system is mounted (for my OS it returned /dev/sda7), and then you can find an ID for it with the following:\n\nSo the complete command to find a unique ID from your system's hard disk could be:\n\nI hope this may fit your needs or someone else's in here. Command cut -b 6-8 may not be portable, because I'm assuming block devices names to be three chars long; moreover, /dev/disk/by-id/ path is only filled by UDEV managed systems and not all Linux distros use it, but I ensure you the former will work in Ubuntu."
    },
    {
        "link": "https://kodekloud.com/blog/make-bash-script-file-executable-linux",
        "document": "A Bash script is essentially a text file containing a series of commands. To make a Bash script file executable means giving it permission to be run as a program.\n\nIn this blog post, we'll start by taking a deep dive into the concept of file permissions in Linux. We'll then learn how to use the command, exploring both its symbolic and octal notations, to make a Bash script file executable. Let’s get started!\n\nTo follow along with the examples in this blog post, you'll need access to a Linux operating system.\n\nFor the purpose of this blog post, I'll be using Ubuntu as my Linux distribution of choice. Specifically, I will use KodeKloud’s Ubuntu playground, which lets you access a pre-installed Ubuntu operating system in just one click. Best of all, you won't need to go through the hassle of installing any additional software — everything you need is already set up and ready to use.\n\nNote that the examples and commands in this blog post are meant to be executed in a Bash shell, which is the most common shell environment in Linux distributions by default.\n\nWe'll begin by creating a simple Bash script file named , which we’ll later turn into an executable file.\n\nMake sure you’re inside the directory where you want to save this file. Then, run the command below to create and open the file using the \"nano\" text editor:\n\nExecuting this command brings up the \"nano\" text editor right in your terminal, as shown below:\n\nNext, add the following script to the \"nano\" editor:\n\nWhat you see is a basic \"Hello World!\" script. When executed, it will echo the message to your terminal.\n\nAfter adding this code to , it's time to save and exit the file. With \"nano\", you do this by pressing to write the changes, followed by to exit the editor.\n\nOur script file is ready. In the next section, we’ll explore file permissions in Linux.\n\nLinux uses three types of permission controls for files. They are:\n• Read permission: Determines the ability to read the contents of a file.\n• Write permission: Determines the ability to modify the contents of a file.\n• Execute permission: Determines whether a user is allowed to execute (or \"run\") the file. If a file has execute permission, it means the system allows the file to be run as a program.\n\nNote: In Linux, not all files store data. Some files can also store scripts or programs that perform specific tasks. For example, the file we created in the previous section doesn’t contain any data; it contains a script.\n\nThese permissions can be granted or revoked separately for three types of user classes:\n• User: The owner of the file.\n• Group: Users who are part of the file's group.\n• Others: All other users on the system.\n\nNow, how can we check the permissions of a given file?\n\nUsing the command with the option.\n\nTo check the permissions for the file, run the following command:\n\nThe output will look something like this:\n\nThe first column of the output (-rw-r--r--) is a string of ten characters that represents the file's permissions. Let’s understand what these characters mean.\n\nThe first character indicates the type of object. A (dash) means it's a regular file.\n\nThe next nine characters are divided into three sets, each comprising three characters. These represent the permissions given to the user (owner of the file), group (group to which the file belongs), and others (everyone else), respectively.\n\nIn each set of three characters:\n• The first character is if permission to read the file is given.\n• The second character is if permission to write the file is given.\n• The third character is if permission to execute the file is given.\n• If any of these permissions (read, write, execute) is not granted, it is represented by a dash (-).\n\nFor example, in the above output \"-rw-r--r--\":\n• \"-\" indicates that \"demo.sh\" is a file.\n• \"rw-\" indicates that the owner of the file can read and write the file but not execute it.\n• \"r--\" indicates that the group members can only read the file but not modify or execute it.\n• \"r--\" indicates that other users can only read the file but not modify or execute it.\n\nIn the previous section, we learned that the file doesn’t have execute permission. This means we can’t run it as a program. Let’s confirm this.\n\nMake sure you’re in the directory that contains the file. Then run the following command:\n\nYou’ll see the message printed on your terminal like this:\n\nNote: We can still run the file as a program without making it executable. We can do this by passing it as an argument to the command. This is possible because the script file is in the root directory, which is in the system’s command path. But our goal is different. We want to run as a standalone program. To do this, the file must have execute permission.\n\nSo, how do we run the script file as a program?\n\nThe answer is: We have to make the file executable, meaning we need to grant it execute permission. We can do this using the (stands for \"Change Mode\") command, which has two modes of operation: symbolic mode and octal mode.\n\nIn symbolic mode, you specify permissions using letters instead of numbers. Here's how it works:\n• You start by specifying who you want to change permissions for. This could be the user (owner) of the file, the group that owns the file, other users, or all users. You represent these with the letters , , , and , respectively.\n• Next, you specify what change you want to make. This can be adding a permission, or removing a permission. You represent these with the symbols and respectively.\n• Finally, you specify which permission you want to change. This can be the permission to read, write, or execute the file. You represent these with the letters , , and , respectively.\n\nNow that you understand how the symbolic mode works let’s use it to add the execute permission to the file. Run the following command:\n\nHere's what each part of the command means:\n• : This is the command to change permissions.\n• : This specifies that you want to change permissions for the user (owner) of the file.\n• : This specifies that you want to add permission.\n• : This specifies that the permission you want to add is the execute permission.\n• : This is the name of the file you want to change permissions for.\n\nAfter running this, let’s verify that the execute permission has been applied. Run the following command:\n\nAfter running this command, you’ll get an output like this:\n\nAs you can see, the file has now execute permission (for the owner of the file). Now, we can run it as a program with the following command (make sure you’re inside the directory that contains the file):\n\nAfter running this command, you’ll see the text printed to the terminal like this:\n\nThe second mode available in is called the octal mode. With octal mode, the permissions are represented as three numbers, one each for the owner, group, and other permissions.\n\nThe following table shows how the octal number matches the three symbolic mode permissions:\n\nOur file currently has execute permission set. Let's remove this permission, so that we can re-add it again using the command’s octal notation.\n\nThis command uses the symbolic notation to remove (-) the execute (x) permission for the user (u) from the file.\n\nTo confirm that the execute permission has been removed, run the following command:\n\nAs you can see in the output below, the owner no longer has execute permission.\n\nNow, having removed the execute permission, let's re-add it, but this time using octal notation of the command. Run the following command:\n\nThis command tells the system to set the permissions of to 744, which in octal notation means the user (u) has read (4), write (2), and execute (1) permissions (adding up to 7), and the group (g) and others (o) have only read permissions (4).\n\nTo confirm that the changes have indeed been applied, let's inspect the file permissions. Run the command as follows:\n\nYou should see output similar to this:\n\nAs indicated by the \"-rwxr--r--\", the file now has read, write, and execute permissions for the user. Let’s run it as a program as we did in the previous section with the following command (make sure you’re inside the directory that contains the file):\n\nYou’ll see printed on the terminal, as shown below:\n\nCongratulations! Now you know how to use the command in both symbolic and octal modes to make a Bash script file executable in Linux.\n\nLooking to build a solid foundation in Linux? Check out the following Linux Learning Path:\n\nIn this blog post, we understood the importance of file permissions in Linux and explored the meanings of read, write, and execute permissions and how they impact user interactions with files. Then, we demonstrated how to make a Bash script file executable using the command, exploring its two primary modes of operation: symbolic and octal notation.\n\nSo, which mode should you use, symbolic or octal? They both achieve the same end result - they control access to your files. The choice comes down to personal preference. That being said, I think the symbolic notation is a bit more intuitive for beginners. It's less abstract than the octal notation and can be easier to read at a glance.\n• How to Check Disk Space on Linux\n• How to Remove a Directory in Linux\n• How to Terminate, or Kill a Process in Linux (Complete Guide)\n• How to List All Users in Linux\n• How to Rename a Directory in Linux\n• How to List All Groups in Linux\n• How to Check if a File Exists in Bash\n• How to Find Out When a File Was Created in Linux\n• How to Read a File Line by Line in Bash\n• How to Run Shell Script (.sh) Files in Linux"
    },
    {
        "link": "https://redhat.com/en/blog/linux-file-permissions-explained",
        "document": "File permissions are core to the security model used by Linux systems. They determine who can access files and directories on a system and how. This article provides an overview of Linux file permissions, how they work, and how to change them.\n\nHow do you view Linux file permissions?\n\nThe command along with its (for long listing) option will show you metadata about your Linux files, including the permissions set on the file.\n\nIn this example, you see two different listings. The first field of the output is a group of metadata that includes the permissions on each file. Here are the components of the listing:\n\nThe fields \"File type\" and \"Extended attributes\" are outside the scope of this article, but in the featured output above, the file is a normal file, which is file type (that is, no special type).\n\nThe listing is for a , or directory, type file. There are other file types as well, but these two are the most common. Available attributes are dependent on the filesystem format that the files are stored on. For Red Hat Enterprise Linux 7, 8, and 9, the default filesystem format is XFS.\n\nHow do you read file permissions?\n\nThis article is about the permission settings on a file. The interesting permissions from the listing are:\n\nThis string is actually an expression of three different sets of permissions:\n\nThe first set of permissions applies to the owner of the file. The second set of permissions applies to the user group that owns the file. The third set of permissions is generally referred to as \"others.\" All Linux files belong to an owner and a group.\n\nWhen permissions and users are represented by letters, that is called symbolic mode. For users, stands for user owner, for group owner, and for others. For permissions, stands for read, for write, and for execute.\n\n[ Learn how to manage your Linux environment for success. ]\n\nWhen the system is looking at a file's permissions to determine what information to provide you when you interact with a file, it runs through a series of checks:\n• It first checks to see whether you are the user that owns the file. If so, then you are granted the user owner's permissions, and no further checks will be completed.\n• If you are not the user that owns the file, next your group membership is validated to see whether you belong to the group that matches the group owner of the file. If so, then you're covered under the group owner field of permissions, and no further checks will be made.\n• \"Others\" permissions are applied when the account interacting with the file is neither the user owner nor in the group that owns the files. Or, to put it another way, the three fields are mutually exclusive: You can not be covered under more than one of the fields of permission settings on a file.\n\nPermissions go beyond the different types of people that can interact with a file. Each user gets an expression that includes the three basic types of permissions. In the example above, the owner of the file is given the following permissions:\n\nEach character in the expression indicates whether a specific permission is granted or not. In the example above, read ( ) permission and write ( ) permission have been granted on the file. However, the execute permission ( ) is not granted, which is why there's a sign in the expression. The permission in this field is disabled.\n\nConsider the group owner's permissions in this example:\n\nThe read ( ) permission is granted to members of the group, but write and execute have both been disabled.\n\n[ Keep your most commonly used commands handy with the Linux commands cheat sheet. ]\n\nWhen Linux file permissions are represented by numbers, it's called numeric mode. In numeric mode, a three-digit value represents specific file permissions (for example, 744.) These are called octal values. The first digit is for owner permissions, the second digit is for group permissions, and the third is for other users. Each permission has a numeric value assigned to it:\n\nIn the permission value 744, the first digit corresponds to the user, the second digit to the group, and the third digit to others. By adding up the value of each user classification, you can find the file permissions.\n\nFor example, a file might have read, write, and execute permissions for its owner, and only read permission for all other users. That looks like this:\n\nThe results produce the three-digit value 744.\n\nWhat do Linux file permissions actually do?\n\nI've talked about how to view file permissions, who they apply to, and how to read what permissions are enabled or disabled. But what do these permissions actually do in practice?\n\nRead permission is used to access the file's contents. You can use a tool like or on the file to display the file contents. You could also use a text editor like Vi or on the file to display the contents of the file. Read permission is required to make copies of a file, because you need to access the file's contents to make a duplicate of it.\n\nWrite permission allows you to modify or change the contents of a file. Write permission also allows you to use the redirect or append operators in the shell ( or ) to change the contents of a file. Without write permission, changes to the file's contents are not permitted.\n\nExecute permission allows you to execute the contents of a file. Typically, executables would be things like commands or compiled binary applications. However, execute permission also allows someone to run Bash shell scripts, Python programs, and a variety of interpreted languages.\n\nThere are other ways to execute the contents of a file without execute permission. For example, you could use an interpreter that has execute permission to read a file with instructions for the interpreter to execute. An example would be invoking a Bash shell script:\n\nThe executable being run is . The file is read by the Bash interpreter, and its commands are executed. The content in this article is general purpose, but in Linux, there are often additional ways to accomplish tasks.\n\nDirectory file types are indicated with . Conceptually, permissions operate the same way, but directories interpret these operations differently.\n\nLike regular files, this permission allows you to read the contents of the directory. However, that means that you can view the contents (or files) stored within the directory. This permission is required to have things like the command work.\n\nAs with regular files, this allows someone to modify the contents of the directory. When you are changing the contents of the directory, you are either adding files to the directory or removing files from the directory. As such, you must have write permission on a directory to move ( ) or remove ( ) files from it. You also need write permission to create new files (using or a file-redirect operator) or copy ( ) files into the directory.\n\nThis permission is very different on directories compared to files. Essentially, you can think of it as providing access to the directory. Having execute permission on a directory authorizes you to look at extended information on files in the directory (using , for instance) but also allows you to change your working directory (using ) or pass through this directory on your way to a subdirectory underneath.\n\nLacking execute permission on a directory can limit the other permissions in interesting ways. For example, how can you add a new file to a directory (by leveraging the write permission) if you can't access the directory's metadata to store the information for a new, additional file? You cannot. It is for this reason that directory-type files generally offer execute permission to one or more of the user owner, group owner, or others.\n\n[ Want to test your sysadmin skills? Take a skills assessment today. ]\n\nHow do you modify Linux file permissions?\n\nYou can modify file and directory permissions with the command, which stands for \"change mode.\" To change file permissions in numeric mode, you enter and the octal value you desire, such as 744, alongside the file name. To change file permissions in symbolic mode, you enter a user class and the permissions you want to grant them next to the file name. For example:\n\nThis grants read, write, and execute for the user and group, and only read for others. In symbolic mode, represents permissions for the user owner, represents other users in the file's group, represents other users not in the file's group. For all users, use .\n\nMaybe you want to change the user owner itself. You can do that with the command. Similarly, the command can be used to change the group ownership of a file.\n\nSpecial permissions are available for files and directories and provide additional privileges over the standard permission sets that have been covered.\n• SUID is the special permission for the user access level and always executes as the user who owns the file, no matter who is passing the command.\n• SGID allows a file to be executed as the group owner of the file; a file created in the directory has its group ownership set to the directory owner. This is helpful for directories used collaboratively among different members of a group because all members can access and execute new files.\n\nThe \"sticky bit\" is a directory-level special permission that restricts file deletion, meaning only the file owner can remove a file within the directory.\n\nWant to take a deeper dive into special permissions? Read Linux permissions: SUID, SGID, and sticky bit.\n\nUnderstanding Linux file permissions (how to find them, read them, and change them) is an important part of maintaining and securing your systems. You can learn more about file permissions for Red Hat Enterprise Linux by checking out the documentation or by practicing with a self-paced lab on using file permissions.\n\n[ Cheat sheet: Get a list of Linux utilities and commands for managing servers and networks. ]"
    },
    {
        "link": "https://stackoverflow.com/questions/37770065/getting-permission-to-execute-a-bash-script",
        "document": "First, make sure that you have the correct file permissions:\n\nIn order to execute your script, the easiest option is to just simply call it (without any additional commands) by typing in the relative path to the script:\n\nThere are other options for explicitly executing your script from the shell (in your case, use the shell to execute your script as a script). From TLDP documentation...\n\nA script can also explicitly be executed by a given shell, but generally we only do this if we want to obtain special behavior, such as checking if the script works with another shell or printing traces for debugging:\n\nIt is not an advised practice to use file extensions with your scripts, especially if you think your code may evolve beyond its current functionality.\n\nJust in case you were wondering if the file extension may be your problem... it is not. It is important that you know that the file extension of a script isn't necessary at all. What matter is what you put in the \"shebang\" line:\n\nTo use the shell:\n\nTo use the shell:\n\nIt won't matter what file extension you use - the \"shebang\" line indicates what shell will be used to execute the script. You could save a script with the \"shebang\" of as , but it would remain a script. If you attempt to execute it, , it would be executed as a script.\n\nAs @Arjan mentioned in the comments, using file extensions for your script could lead to unnecessary complications if you decide to change the implementation of your project (i.e., a different shell / language):\n\nI could decide later to shift my project to , , , , etc. Perhaps because I want to add functionality. Perhaps because I want to make it portable to a system without . It would be much more difficult if I used the file extension, since then I'd need to change all my references to the script just because I changed its implementation."
    },
    {
        "link": "https://geeksforgeeks.org/bash-script-file-permissions",
        "document": "In this article, we will discuss file permission in Bash Script\n\nTo understand the scenario let’s take an example. Let’s consider there is a system admin A for company XYZ he designs a script that is to be executed by a user at 8:00 PM daily to send a report. He designs the script but forgets to give permission to the user to execute the script. Whenever a user tries to execute a script, he gets the error You are not authorized to take this action so why did this happen?\n\nIn the above case, we see that the system admin created a script but he did not give permission to the user as he was unable to execute it so to go into depth about this let’s explain how can we set file permission and how to check them.\n\nSolution: Now for the above example the system admin only has to give or set the user file permission to execute so that he can execute that file\n\nSo, what are the file permissions?\n\nFile permissions can be described as who, what, and which activities can be done to a file or directory.\n• None who refers to users, groups, or others\n• None what means to add, delete and set\n\nBasic list views of file and their permissions\n\nThe command we use is ls -l to show us the list of files/directory in the current folder we are present. This screenshot is a common example to show permission (using normal centos7 )\n\nFrom the above screenshot, let’s take a file let’s say luser_t04.sh, and see its file permissions\n• None 1 represents the permission of the user, they have all the 3 permission to read, write and execute the file\n• None 2 represents the group to which the file is associated it also has all the permissions\n• None 3 represent others which also contains all the 3 permissions\n\nTo manage file permissions, we have a command called chmod which we can use to change the permission of files and directories.\n\nThere are 2 methods to use the command\n• None what is to +(add) ,-(remove) ,+(set)\n\nLet’s see an example: –\n\nSuppose you want to remove read and write permission of group and others from the file\n\nchmod go-rw luser_t04.sh. The new permission will be like this\n\n#: represents each digit the permission for user, group and others.\n\nLet’s see the example from above:\n• None user permission has been represented by rwx (4+2+1=7)\n• None group permission has been described as –x (0+0+1 =1)\n• None other permission has been described as –x ( 0+0+1=1)\n\nLet us take another example of a file\n\nFile with permission of 640 what it means in numeric method\n• None user have read(4) and write(2) permission represented by rw- (4+2+0=6)\n• None the group has read(4) permission represented by r– (4+0+0=4)\n• None other have no permission(0) ,represented by — (0+0+0=0)\n\nIn this example to set file permission for a file (Example: FILE )\n\nWe want the user to be able to read, write and execute files but we don’t want groups to write and execute the file and others to only be able to execute the file so what command and syntax we should use\n\nThe new permission set will be rwx r– –x for FILE\n\nWe can explain the file permission by creating a simple script to execute and change the permission of the file after understanding file permissions.\n\nStep 1. First, we create a file or check if an existing file is there as mentioned in the screenshot. If the file is not present then we execute the command\n\nStep 2. Our aim is to remove the write permission of others and groups as mentioned in the screenshot we will execute the command in the script\n\nStep 3. Finally, to check if permission is changed or not, we will use\n\nNow we will execute this script and check if it works\n\nNOTE: In writing script and executing it is important to check permission always after creating script ls -l command"
    },
    {
        "link": "https://freecodecamp.org/news/bash-scripting-tutorial-linux-shell-script-and-command-line-for-beginners",
        "document": "In Linux, process automation relies heavily on shell scripting. This involves creating a file containing a series of commands that can be executed together.\n\nIn this article, we'll start with the basics of bash scripting which includes variables, commands, inputs/ outputs, and debugging. We'll also see examples of each along the way.\n• How to Get Started with Bash Scripting\n• How to Run Bash Commands from the Command Line\n• How to Create and Execute Bash Scripts\n• How to Schedule Scripts using cron\n• How to Debug and Troubleshoot Bash Scripts\n• Resources for learning more about Bash scripting\n\nTo follow along with this tutorial, you should have the following accesses:\n• A running version of Linux with access to the command line.\n\nIf you do not have Linux installed or you are just starting out, you can easily access the Linux command line through Replit. Replit is a browser-based IDE where you can access the bash shell in a few minutes.\n\nYou can also install Linux on top of your Windows system using WSL (Windows Subsystem for Linux). Here is a tutorial for that.\n\nA bash script is a file containing a sequence of commands that are executed by the bash program line by line. It allows you to perform a series of actions, such as navigating to a specific directory, creating a folder, and launching a process using the command line.\n\nBy saving these commands in a script, you can repeat the same sequence of steps multiple times and execute them by running the script.\n\nBash scripting is a powerful and versatile tool for automating system administration tasks, managing system resources, and performing other routine tasks in Unix/Linux systems. Some advantages of shell scripting are:\n• Automation: Shell scripts allow you to automate repetitive tasks and processes, saving time and reducing the risk of errors that can occur with manual execution.\n• Portability: Shell scripts can be run on various platforms and operating systems, including Unix, Linux, macOS, and even Windows through the use of emulators or virtual machines.\n• Flexibility: Shell scripts are highly customizable and can be easily modified to suit specific requirements. They can also be combined with other programming languages or utilities to create more powerful scripts.\n• Accessibility: Shell scripts are easy to write and don't require any special tools or software. They can be edited using any text editor, and most operating systems have a built-in shell interpreter.\n• Integration: Shell scripts can be integrated with other tools and applications, such as databases, web servers, and cloud services, allowing for more complex automation and system management tasks.\n• Debugging: Shell scripts are easy to debug, and most shells have built-in debugging and error-reporting tools that can help identify and fix issues quickly.\n\nThe terms \"shell\" and \"bash\" are used interchangeably. But there is a subtle difference between the two.\n\nThe term \"shell\" refers to a program that provides a command-line interface for interacting with an operating system. Bash (Bourne-Again SHell) is one of the most commonly used Unix/Linux shells and is the default shell in many Linux distributions.\n\nA shell or command-line interface looks like this:\n\nThe shell accepts commands from the user and displays the output\n\nIn the above output, is the shell prompt. When a shell is used interactively, it displays a when it is waiting for a command from the user.\n\nIf the shell is running as root (a user with administrative rights), the prompt is changed to . The superuser shell prompt looks like this:\n\nAlthough Bash is a type of shell, there are other shells available as well, such as Korn shell (ksh), C shell (csh), and Z shell (zsh). Each shell has its own syntax and set of features, but they all share the common purpose of providing a command-line interface for interacting with the operating system.\n\nYou can determine your shell type using the command:\n\nHere is the output for me:\n\nIn summary, while \"shell\" is a broad term that refers to any program that provides a command-line interface, \"Bash\" is a specific type of shell that is widely used in Unix/Linux systems.\n\nNote: In this tutorial, we will be using the \"bash\" shell.\n\nHow to Get Started with Bash Scripting\n\nAs mentioned earlier, the shell prompt looks something like this:\n\nYou can enter any command after the sign and see the output on the terminal.\n\nLet's discuss a few basic bash commands and see their outputs. Make sure to follow along :)\n• : Lists the contents of the current directory.\n• : Prints a string of text, or value of a variable to the terminal.\n\nYou can always refer to a commands manual with the command.\n\nFor example, the manual for looks something like this:\n\nYou can see options for a command in detail using\n\nHow to Create and Execute Bash scripts\n\nBy naming convention, bash scripts end with . However, bash scripts can run perfectly fine without the extension.\n\nBash scripts start with a . Shebang is a combination of and followed by the bash shell path. This is the first line of the script. Shebang tells the shell to execute it via bash shell. Shebang is simply an absolute path to the bash interpreter.\n\nBelow is an example of the shebang statement.\n\nYou can find your bash shell path (which may vary from the above) using the command:\n\nOur first script prompts the user to enter a path. In return, its contents will be listed.\n\nCreate a file named using the command. You can use any editor of your choice.\n\nAdd the following commands in your file and save it:\n\nLet's take a deeper look at the script line by line. I am displaying the same script again, but this time with line numbers.\n• Line #1: The shebang ( ) points toward the bash shell path.\n• Line #2: The command is displaying the current date and time on the terminal. Note that the is in backticks.\n• Line #4: We want the user to enter a valid path.\n• Line #5: The command reads the input and stores it in the variable .\n• line #8: The command takes the variable with the stored path and displays the current files and folders.\n\nTo make the script executable, assign execution rights to your user using this command:\n• modifies the ownership of a file for the current user : .\n• adds the execution rights to the current user. This means that the user who is the owner can now run the script.\n• is the file we wish to run.\n\nYou can run the script using any of the mentioned methods:\n\nLet's see it running in action 🚀\n\nComments start with a in bash scripting. This means that any line that begins with a is a comment and will be ignored by the interpreter.\n\nComments are very helpful in documenting the code, and it is a good practice to add them to help others understand the code.\n\nThese are examples of comments:\n\nVariables let you store data. You can use variables to read, access, and manipulate data throughout your script.\n\nThere are no data types in Bash. In Bash, a variable is capable of storing numeric values, individual characters, or strings of characters.\n\nIn Bash, you can use and set the variable values in the following ways:\n• Assign the value based on the output obtained from a program or command, using command substitution. Note that is required to access an existing variable's value.\n\nTo access the variable value, append to the variable name.\n\nIn Bash scripting, the following are the variable naming conventions:\n• Variable names should start with a letter or an underscore ( ).\n• Variable names can contain letters, numbers, and underscores ( ).\n• Variable names should not contain spaces or special characters.\n• Use descriptive names that reflect the purpose of the variable.\n• Avoid using reserved keywords, such as , , , , and so on as variable names.\n\nHere are some examples of valid variable names in Bash:\n\nAnd here are some examples of invalid variable names:\n\nFollowing these naming conventions helps make Bash scripts more readable and easier to maintain.\n\nIn this section, we'll discuss some methods to provide input to our scripts.\n• Reading the user input and storing it in a variable\n\nWe can read the user input using the command.\n\nThis code reads each line from a file named and prints it to the terminal. We'll study while loops later in this article.\n\nIn a bash script or function, denotes the initial argument passed, denotes the second argument passed, and so forth.\n\nThis script takes a name as a command-line argument and prints a personalized greeting.\n\nWe have supplied as our argument to the script.\n\nHere we'll discuss some methods to receive output from the scripts.\n\nThis prints the text \"Hello, World!\" to the terminal.\n\nThis writes the text \"This is some text.\" to a file named . Note that the operator overwrites a file if it already has some content.\n\nThis appends the text \"More text.\" to the end of the file .\n\nThis lists the files in the current directory and writes the output to a file named . You can redirect output of any command to a file this way.\n\nHere is a list of some of the most commonly used bash commands:\n• : Change the directory to a different location.\n• : List the contents of the current directory.\n• : Concatenate and print the contents of a file.\n• : Change the permissions of a file or directory.\n• : Display the amount of disk space available.\n\nExpressions that produce a boolean result, either true or false, are called conditions. There are several ways to evaluate conditions, including , , , and nested conditionals.\n\nWe can use logical operators such as AND and OR to make comparisons that have more significance.\n\nLet's see an example of a Bash script that uses , , and statements to determine if a user-inputted number is positive, negative, or zero:\n\nThe script first prompts the user to enter a number. Then, it uses an statement to check if the number is greater than 0. If it is, the script outputs that the number is positive. If the number is not greater than 0, the script moves on to the next statement, which is an statement. Here, the script checks if the number is less than 0. If it is, the script outputs that the number is negative. Finally, if the number is neither greater than 0 nor less than 0, the script uses an statement to output that the number is zero.\n\nSeeing it in action 🚀\n\nWhile loops check for a condition and loop until the condition remains . We need to provide a counter statement that increments the counter to control loop execution.\n\nIn the example below, is the counter statement that increments the value of . The loop will run exactly 10 times.\n\nThe loop, just like the loop, allows you to execute statements a specific number of times. Each loop differs in its syntax and usage.\n\nIn the example below, the loop will iterate 5 times.\n\nIn Bash, case statements are used to compare a given value against a list of patterns and execute a block of code based on the first pattern that matches. The syntax for a case statement in Bash is as follows:\n\nHere, \"expression\" is the value that we want to compare, and \"pattern1\", \"pattern2\", \"pattern3\", and so on are the patterns that we want to compare it against.\n\nThe double semicolon \";;\" separates each block of code to execute for each pattern. The asterisk \"*\" represents the default case, which executes if none of the specified patterns match the expression.\n\nLet's see an example.\n\nIn this example, since the value of \"fruit\" is \"apple\", the first pattern matches, and the block of code that echoes \"This is a red fruit.\" is executed. If the value of \"fruit\" were instead \"banana\", the second pattern would match and the block of code that echoes \"This is a yellow fruit.\" would execute, and so on. If the value of \"fruit\" does not match any of the specified patterns, the default case is executed, which echoes \"Unknown fruit.\"\n\nHow to Schedule Scripts using cron\n\nCron is a powerful utility for job scheduling that is available in Unix-like operating systems. By configuring cron, you can set up automated jobs to run on a daily, weekly, monthly, or specific time basis. The automation capabilities provided by cron play a crucial role in Linux system administration.\n\nBelow is the syntax to schedule crons:\n\nHere, the s represent minute(s) hour(s) day(s) month(s) weekday(s), respectively.\n\nBelow are some examples of scheduling cron jobs.\n\nThe utility is used to add and edit the cron jobs.\n\nlists the already scheduled scripts for a particular user.\n\nYou can add and edit the cron through .\n\nYou can read more about corn jobs in my other article here.\n\nHow to Debug and Troubleshoot Bash Scripts\n\nDebugging and troubleshooting are essential skills for any Bash scripter. While Bash scripts can be incredibly powerful, they can also be prone to errors and unexpected behavior. In this section, we will discuss some tips and techniques for debugging and troubleshooting Bash scripts.\n\nOne of the most useful techniques for debugging Bash scripts is to set the option at the beginning of the script. This option enables debugging mode, which causes Bash to print each command that it executes to the terminal, preceded by a sign. This can be incredibly helpful in identifying where errors are occurring in your script.\n\nWhen Bash encounters an error, it sets an exit code that indicates the nature of the error. You can check the exit code of the most recent command using the variable. A value of indicates success, while any other value indicates an error.\n\nAnother useful technique for debugging Bash scripts is to insert statements throughout your code. This can help you identify where errors are occurring and what values are being passed to variables.\n\nIf you want your script to exit immediately when any command in the script fails, you can use the option. This option will cause Bash to exit with an error if any command in the script fails, making it easier to identify and fix errors in your script.\n\nWe can troubleshoot crons using the log files. Logs are maintained for all the scheduled jobs. You can check and verify in logs if a specific job ran as intended or not.\n\nFor Ubuntu/Debian, you can find logs at:\n\nThe location varies for other distributions.\n\nA cron job log file can look like this:\n\nIn this article, we started with how to access the terminal and then ran some basic bash commands. We also studied what a bash shell is. We briefly looked at branching the code using loops and conditionals. Finally, we discussed automating the scripts using cron followed by some troubleshooting techniques.\n\nResources for learning more about Bash scripting\n\nIf you want to dig deeper into the world of bash scripting, I would suggest you have a look at this 6-hour course on Linux at freeCodeCamp.\n\nWhat’s your favorite thing you learned from this tutorial? You can also connect with me on any of these platforms. 📧�\n\nSee you in the next tutorial, happy coding 😁"
    }
]