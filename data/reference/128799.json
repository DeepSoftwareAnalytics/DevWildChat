[
    {
        "link": "https://pygame.org/docs/tut/newbieguide.html",
        "document": "The most important thing is to feel confident using python. Learning something as potentially complicated as graphics programming will be a real chore if you're also unfamiliar with the language you're using. Write a few sizable non-graphical programs in python -- parse some text files, write a guessing game or a journal-entry program or something. Get comfortable with string and list manipulation -- know how to split, slice and combine strings and lists. Know how works -- try writing a program that is spread across several source files. Write your own functions, and practice manipulating numbers and characters; know how to convert between the two. Get to the point where the syntax for using lists and dictionaries is second-nature -- you don't want to have to run to the documentation every time you need to slice a list or sort a set of keys. Get comfortable using file paths -- this will come in handy later when you start loading assets and creating save files. Resist the temptation to ask for direct help online when you run into trouble. Instead, fire up the interpreter and play with the problem for a few hours, or use print statements and debugging tools to find out what's going wrong in your code. Get into the habit of looking things up in the official Python documentation, and Googling error messages to figure out what they mean.\n\nPete Shinners' wrapper may have cool alpha effects and fast blitting speeds, but I have to admit my favorite part of pygame is the lowly class. A rect is simply a rectangle -- defined only by the position of its top left corner, its width, and its height. Many pygame functions take rects as arguments, and they also take 'rectstyles', a sequence that has the same values as a rect. So if I need a rectangle that defines the area between 10, 20 and 40, 50, I can do any of the following: For example, suppose I'd like to get a list of all the sprites that contain a point (x, y) -- maybe the player clicked there, or maybe that's the current location of a bullet. It's simple if each sprite has a .rect member -- I just do: Rects have no other relation to surfaces or graphics functions, other than the fact that you can use them as arguments. You can also use them in places that have nothing to do with graphics, but still need to be defined as rectangles. Every project I discover a few new places to use rects where I never thought I'd need them.\n\nThe second method uses the SDL event queue. This queue is a list of events -- events are added to the list as they're detected, and they're deleted from the queue as they're read off. In the queue system, however, each keypress arrives in the queue as a completely separate event, so you'd need to remember that the key was down, and hadn't come up yet, while checking for the key. A little more complicated. The lesson is: choose the system that meets your requirements. If you don't have much going on in your loop -- say you're just sitting in a loop, waiting for input, use or another state function; the latency will be lower. On the other hand, if every keypress is crucial, but latency isn't as important -- say your user is typing something in an editbox, use the event queue. Some key presses may be slightly late, but at least you'll get them all."
    },
    {
        "link": "https://pygame.org/docs",
        "document": "Welcome to pygame! Once you've got pygame installed ( or for most people), the next question is how to get a game loop running. Pygame, unlike some other libraries, gives you full control of program execution. That freedom means it is easy to mess up in your initial steps.\n\nHere is a good example of a basic setup (opens the window, updates the screen, and handles events)--\n\nHere is a slightly more fleshed out example, which shows you how to move something (a circle in this case) around on screen--\n\nFor more in depth reference, check out the Tutorials section below, check out a video tutorial (I'm a fan of this one), or reference the API documentation by module."
    },
    {
        "link": "https://stackoverflow.com/questions/20842801/how-to-display-text-in-pygame",
        "document": "I can't figure out to display text in pygame.\n\n I know I can't use print like in regular Python IDLE but I don't know how.\n\nThis is only the beginning part of the whole program.\n\n If there is a format that will allow me to show the text I type in the pygame window that'd be great. So instead of using print I would use something else. But I don't know what that something else is. When I run my program in pygame it doesn't show anything.\n\n I want the program to run in the pygame window instead of it just running in idle."
    },
    {
        "link": "https://geeksforgeeks.org/pygame-working-with-text",
        "document": "In this article, we will see how to play with texts using the Pygame module. We will be dealing here with initializing the font, rendering the text, editing the text using the keyboard, and adding a blinking cursor note.\n\nTo install this module type the below command in the terminal.\n\nNow we can proceed further with the font initialization part. The pygame.font.init() method is used to initialize the font and the pygame.font.get_init() method is used to check whether the font has been initialized or not. Both of the methods do not require any argument. If the font has been initialized successfully then pygame.font.get_init() method returns true.\n\nHere we will see how to get customized font and text on the screen. We will set the position of the texts’ to be displayed on the screen using x and y coordinates. First, we will create the font files and then render the texts. The screen. blit() function is used for copying the text surface objects to the display surface objects at the center coordinates.\n\nWe are going to add Blinking Cursor Note here. Our cursor will continue blinking after every 0.5 sec. We can also edit our text.\n\nHere we will see how to read the text using the keyboard in pygame. We are going to show our text inside a rectangle. When the mouse is taken over the rectangle the color of the rectangle gets changed. Comments have been added to the code for clear understanding."
    },
    {
        "link": "https://pygame.readthedocs.io/en/latest/4_text/text.html",
        "document": "In pygame, text cannot be written directly to the screen. The first step is to create a object with a given font size. The second step is to render the text into an image with a given color. The third step is to blit the image to the screen. These are the steps:\n\nOnce the font is created, its size cannot be changed. A object is used to create a object from a string. Pygame does not provide a direct way to write text onto a object. The method must be used to create a Surface object from the text, which then can be blit to the screen. The method can only render single lines. A newline character is not rendered.\n\nInitializing the font can take a few seconds. On a MacBook Air the the creation of a system Font object: took more then 8 seconds: The function returns a list of all installed fonts. The following code checks what fonts are on your system and how many, and prints them to the console: You will get something like this:\n\nThe font object can render a given text into an image. In the example below, we place a blue bounding rectangle around that text image: We then create two more fonts, Chalkduster and Didot at a size of 72 points. We render a text with both fonts: Finally the text images are blit to the screen like regular images:\n\nThe keyboard event can be used to edit a text. First we create a text which we save in a string variable and which we render to an image: Then we define the bounding rectangle and furthermore a cursor rectangle which is juxtaposed to the text bounding rectangle: Inside the event loop we watch out for KEYDOWN events. If the key press is a BACKSPACE and the lenght of the string is larger than 0, then we remove the last character, else we append the new character to the text variable: Then we render the modified text, update the bounding rectangle, and place the cursor box at the end of the updated bounding rectangle:\n\nIn order to make the cursor more visible, we let it blink every 0.5 seconds. We do this using the time.time() floating point value:"
    },
    {
        "link": "https://geeksforgeeks.org/create-a-chess-game-in-python",
        "document": "Here, we have a task to create a chess game in Python. In this article, we will see how to create a chess game in Python.\n\nChess Game, Played by two players on an 8x8 grid board with alternate light and dark squares, chess is a time-honored board game of strategy and cunning. Each player deploys 16 pieces at the beginning of the game, placing them in the rows closest to them. Pawns are arranged on the second row, and the first row is occupied by other pieces. The goal of the game is to advance your pieces to a position from which you can capture the king of your opponent and force a \"checkmate,\" winning the game for you. Every piece has certain movement rules that players must stick to.\n\nBelow are the step-by-step procedure and explanation of how to create a Chess Game in Python:\n\nFirst, create the virtual environment using the below commands\n\nFirst, we need to install the Pygame library, which is used for creating games. We are utilizing it to create a chess game. To install Pygame, use the following command:\n\nBelow are the step-by-step explanation of the main.py code that we have used to create a chess game in Python:\n\nImporting necessary modules for the code, including for game development, for making HTTP requests, for removing image backgrounds, and for handling byte data.\n\nHere, the code initializes the Pygame module using . This step is crucial for setting up the Pygame environment and enabling the use of its functionalities throughout the script.\n\nIn below code initializes three different fonts of varying sizes using the function. These fonts are likely to be used for rendering text within the game. Additionally, the code creates a clock object using to control the frame rate of the game.\n\nBelow, code defines variables related to the game, such as lists representing the locations and types of chess pieces. URLs for chess piece images are stored in . These variables play a crucial role in managing the game state, including the positions of pieces and the URLs required to fetch their corresponding images.\n\nIn below code we are Using the function, the code loads chess piece images from URLs. The library is employed to remove image backgrounds, enhancing the visual appearance of the pieces. Each image is then scaled using to ensure a consistent size within the game.\n\nIn below code , section organizes the loaded piece images into lists for convenient access and manipulation. Two lists, and , contain the original and scaled versions of white chess pieces, respectively. Similar lists are created for black pieces. Grouping the images simplifies the process of drawing pieces onto the game board.\n\nbelow code code defines functions responsible for drawing the game board. The function uses Pygame's drawing functions to create a chessboard with alternating light gray and gray squares. Additionally, lines are drawn to delineate the squares, and status text is displayed at the bottom of the window, indicating the current player's turn and actions\n\nBelow, are the explanation of Piece Drawing Functions for create a chess game in Python.\n\nIn below code function is responsible for visually representing chess pieces on the board. It iterates through both white and black pieces, displaying them at their respective locations. The function adjusts the position for pawn images and outlines the selected piece with a red rectangle during white's turn and a blue rectangle during black's turn\n\nIn below code the function, , validates and gathers all possible moves for each piece on the chessboard, distinguishing between different piece types and their respective movements.\n\nIn below code function focuses on determining and returning the valid moves for a king, considering its ability to move one square in any direction and distinguishing between friendly and enemy pieces.\n\nIn below code function combines the valid moves of a queen by integrating the results from both the bishop and rook functions, providing a comprehensive list of valid moves for a queen at a given position and color.\n\nIn below code function calculates and returns the valid moves for a bishop by traversing diagonal paths in all four directions, considering board boundaries and avoiding friendly pieces.\n\nIn below code the function, , determines the valid moves for a rook by exploring horizontal and vertical paths in all four directions, ensuring the moves stay within the board boundaries and avoid friendly pieces.\n\nThe function identifies and returns the valid moves for a pawn, considering different scenarios such as initial double moves, single moves, and diagonal captures based on the color of the pawn.\n\nThe function calculates and returns the valid moves for a knight by exploring eight possible positions in an \"L\" shape, ensuring the moves are within the board boundaries and avoid friendly pieces.\n\nThe function determines the valid moves for the currently selected piece based on the game's current turn, providing a list of possible moves.\n\nThe function visually represents valid moves on the screen by drawing small circles, using red circles for white's turn and blue circles for black's turn.\n\nThe function visually displays captured pieces on the side of the screen, utilizing lists of captured pieces for both white and black.\n\nThe function visually indicates a check condition by drawing a flashing square around the king, with the color and conditions dependent on the current turn.\n\nThe function displays a message on the screen declaring the winner of the game and instructs the player to press ENTER to restart, utilizing the winner variable to determine the winner displayed on the screen.\n\nThe game loop begins by calculating valid move options for both black and white pieces using the function. Subsequently, a counter is incremented, and the screen is filled with a dark gray color, providing a clean canvas for rendering. Functions like , , , and are then called to visually represent the chessboard, pieces, captured pieces, and check conditions.\n\nThe code utilizes a loop to handle pygame events, primarily focusing on mouse clicks (`pygame.MOUSEBUTTONDOWN`). It checks for the left button click (`event.button == 1`) and ensures the game is not over (`not game_over`). The coordinates of the click are determined and translated to grid coordinates. Depending on the turn step, it processes player input for moving pieces, capturing opponents, and updating the game state accordingly.\n\nWithin the event loop, the code checks for a key press (`pygame.KEYDOWN`) when the game is over. Specifically, it looks for the \"Enter\" key (`event.key == pygame.K_RETURN`). Upon detecting this key press, the game resets to its initial state, including piece positions, captured pieces, turn steps, and valid move lists. This functionality allows players to restart the game seamlessly.\n\nIf a winner is determined, the code sets the `game_over` flag to true and calls the `draw_game_over` function to display a game-over message on the screen. The winner variable influences this decision, considering factors like capturing the opponent's king or pressing forfeit squares. This aspect enhances the user experience by providing clear feedback on the game's outcome.\n\nBelow is the complete code implementation of main.py file that we have used to create a chess game in Python.\n\n# Setting Width and height of the Chess Game screen # function to check all pieces valid options on board # 8 squares to check for kings, they can go one square any direction \\ \\ \\ \\ \\ \\ # 8 squares to check for knights, they can go two squares in one direction and one in another # check for valid moves for just selected piece # draw a flashing square around king if in check"
    },
    {
        "link": "https://levelup.gitconnected.com/chess-python-ca4532c7f5a4",
        "document": "This is a large project that me and a friend in school conducted. This is pretty funny because we had plans on doing this over several months and 7 days later we have the entire thing completed. I must say, this would not have been possible if it weren’t for the help of my friend Edwin. Firstly we abstracted the entire game since this is a very complex game to code and we decided that I would be responsible for the interface(what the user can see) while Edwin was responsible for the actual behaviour of each piece. They both have their own forms of difficulties to make and we did have to co-ordinate a lot so it wasn’t like we didn’t help each other make each other’s parts eg. i did teach him a bit of list comprehension to speed up his code while he exposed my pretty stupid mistake of doing column row instead of row column.\n\nThis code is everything that I wrote alongside some of the dictionary and methods above it. First we create the window object which is the window that comes up when we run the chess game on. We set the dimensions to 800x800 which is the tuple argument which we passed into it. We specifically chose 800 x 800 because the images for the chess pieces that we hard were all 100x100 which meant it would fit perfectly if the board was 800x800.\n\nThe main thing that makes my program work are these node objects and they are just the containers which hold the chess pieces(they are simulated as the tiles of the chess board in this case. They have their attributes which are their row, column,x,y co-ordinates. We need these separately because all these nodes are going to be stored in a 8x8 2d list so if we call it we would need to call it using its row and col numbers while if we were drawing it onto the screen we need its x,y pixel values(we could just do row*100 but that would risk us forgetting to add that 1 time in the entire code and watching the entire thing break).\n\nThe draw function is used to used to draw the tile onto the screen(so the black and white pattern) while the setup method is used to draw any images onto the screen if we had a piece on the screen at that position. You draw onto the screen using blit.\n\nDraw grid draws the boundaries to the grid(so the black horizontal and vertical lines that separate the tiles) and draw grid and make grid is creating the 2d list which are going to use to access all the nodes later. Update display is used to update the screen every-time the tick. I think to avoid the CPU being overloaded, we chose to run the program at 20fps which is ofc completely unreasonable for chess but we didn’t want too much delay.\n\nWhen the user clicks on the screen, we need to figure out what tile they have clicked on which is what find_node does. Display_potential_moves is a function edwin made but it just takes a list of potential moves and for those moves, changes the colour of the tile so that it stands out.\n\nDo_move is used to acc make the swap on the screen but swapping the values on my dictionary, when the screen updates, this change will be visible on the screen.\n\nremove_highlight is used because it is hard to remove the highlights for specific tiles so we decided to just to redraw the black colours for all the tiles instead.\n\nThe main function then contains a lot fo standard logic which I would hope you would have a grasp on if you know pygame. I will attach a video here too just incase you don’t\n\nimport pygame\n\n\n\nimport time\n\n\n\nimport sys\n\n\n\nboard = [[' ' for i in range(8)] for i in range(8)]\n\n\n\n## Creates a chess piece class that shows what team a piece is on, what type of piece it is and whether or not it can be killed by another selected piece.\n\nclass Piece:\n\n def __init__(self, team, type, image, killable=False):\n\n self.team = team\n\n self.type = type\n\n self.killable = killable\n\n self.image = image\n\n\n\n\n\n## Creates instances of chess pieces, so far we got: pawn, king, rook and bishop\n\n## The first parameter defines what team its on and the second, what type of piece it is\n\nbp = Piece('b', 'p', 'b_pawn.png')\n\nwp = Piece('w', 'p', 'w_pawn.png')\n\nbk = Piece('b', 'k', 'b_king.png')\n\nwk = Piece('w', 'k', 'w_king.png')\n\nbr = Piece('b', 'r', 'b_rook.png')\n\nwr = Piece('w', 'r', 'w_rook.png')\n\nbb = Piece('b', 'b', 'b_bishop.png')\n\nwb = Piece('w', 'b', 'w_bishop.png')\n\nbq = Piece('b', 'q', 'b_queen.png')\n\nwq = Piece('w', 'q', 'w_queen.png')\n\nbkn = Piece('b', 'kn', 'b_knight.png')\n\nwkn = Piece('w', 'kn', 'w_knight.png')\n\n\n\n\n\nstarting_order = {(0, 0): pygame.image.load(br.image), (1, 0): pygame.image.load(bkn.image),\n\n (2, 0): pygame.image.load(bb.image), (3, 0): pygame.image.load(bk.image),\n\n (4, 0): pygame.image.load(bq.image), (5, 0): pygame.image.load(bb.image),\n\n (6, 0): pygame.image.load(bkn.image), (7, 0): pygame.image.load(br.image),\n\n (0, 1): pygame.image.load(bp.image), (1, 1): pygame.image.load(bp.image),\n\n (2, 1): pygame.image.load(bp.image), (3, 1): pygame.image.load(bp.image),\n\n (4, 1): pygame.image.load(bp.image), (5, 1): pygame.image.load(bp.image),\n\n (6, 1): pygame.image.load(bp.image), (7, 1): pygame.image.load(bp.image),\n\n\n\n (0, 2): None, (1, 2): None, (2, 2): None, (3, 2): None,\n\n (4, 2): None, (5, 2): None, (6, 2): None, (7, 2): None,\n\n (0, 3): None, (1, 3): None, (2, 3): None, (3, 3): None,\n\n (4, 3): None, (5, 3): None, (6, 3): None, (7, 3): None,\n\n (0, 4): None, (1, 4): None, (2, 4): None, (3, 4): None,\n\n (4, 4): None, (5, 4): None, (6, 4): None, (7, 4): None,\n\n (0, 5): None, (1, 5): None, (2, 5): None, (3, 5): None,\n\n (4, 5): None, (5, 5): None, (6, 5): None, (7, 5): None,\n\n\n\n (0, 6): pygame.image.load(wp.image), (1, 6): pygame.image.load(wp.image),\n\n (2, 6): pygame.image.load(wp.image), (3, 6): pygame.image.load(wp.image),\n\n (4, 6): pygame.image.load(wp.image), (5, 6): pygame.image.load(wp.image),\n\n (6, 6): pygame.image.load(wp.image), (7, 6): pygame.image.load(wp.image),\n\n (0, 7): pygame.image.load(wr.image), (1, 7): pygame.image.load(wkn.image),\n\n (2, 7): pygame.image.load(wb.image), (3, 7): pygame.image.load(wk.image),\n\n (4, 7): pygame.image.load(wq.image), (5, 7): pygame.image.load(wb.image),\n\n (6, 7): pygame.image.load(wkn.image), (7, 7): pygame.image.load(wr.image),}\n\n\n\n\n\ndef create_board(board):\n\n board[0] = [Piece('b', 'r', 'b_rook.png'), Piece('b', 'kn', 'b_knight.png'), Piece('b', 'b', 'b_bishop.png'), \\\n\n Piece('b', 'q', 'b_queen.png'), Piece('b', 'k', 'b_king.png'), Piece('b', 'b', 'b_bishop.png'), \\\n\n Piece('b', 'kn', 'b_knight.png'), Piece('b', 'r', 'b_rook.png')]\n\n\n\n board[7] = [Piece('w', 'r', 'w_rook.png'), Piece('w', 'kn', 'w_knight.png'), Piece('w', 'b', 'w_bishop.png'), \\\n\n Piece('w', 'q', 'w_queen.png'), Piece('w', 'k', 'w_king.png'), Piece('w', 'b', 'w_bishop.png'), \\\n\n Piece('w', 'kn', 'w_knight.png'), Piece('w', 'r', 'w_rook.png')]\n\n\n\n for i in range(8):\n\n board[1][i] = Piece('b', 'p', 'b_pawn.png')\n\n board[6][i] = Piece('w', 'p', 'w_pawn.png')\n\n return board\n\n\n\n\n\n## returns the input if the input is within the boundaries of the board\n\ndef on_board(position):\n\n if position[0] > -1 and position[1] > -1 and position[0] < 8 and position[1] < 8:\n\n return True\n\n\n\n\n\n## returns a string that places the rows and columns of the board in a readable manner\n\ndef convert_to_readable(board):\n\n output = ''\n\n\n\n for i in board:\n\n for j in i:\n\n try:\n\n output += j.team + j.type + ', '\n\n except:\n\n output += j + ', '\n\n output += '\n\n'\n\n return output\n\n\n\n\n\n## resets \"x's\" and killable pieces\n\ndef deselect():\n\n for row in range(len(board)):\n\n for column in range(len(board[0])):\n\n if board[row][column] == 'x ':\n\n board[row][column] = ' '\n\n else:\n\n try:\n\n board[row][column].killable = False\n\n except:\n\n pass\n\n return convert_to_readable(board)\n\n\n\n\n\n## Takes in board as argument then returns 2d array containing positions of valid moves\n\ndef highlight(board):\n\n highlighted = []\n\n for i in range(len(board)):\n\n for j in range(len(board[0])):\n\n if board[i][j] == 'x ':\n\n highlighted.append((i, j))\n\n else:\n\n try:\n\n if board[i][j].killable:\n\n highlighted.append((i, j))\n\n except:\n\n pass\n\n return highlighted\n\n\n\ndef check_team(moves, index):\n\n row, col = index\n\n if moves%2 == 0:\n\n if board[row][col].team == 'w':\n\n return True\n\n else:\n\n if board[row][col].team == 'b':\n\n return True\n\n\n\n## This takes in a piece object and its index then runs then checks where that piece can move using separately defined functions for each type of piece.\n\ndef select_moves(piece, index, moves):\n\n if check_team(moves, index):\n\n if piece.type == 'p':\n\n if piece.team == 'b':\n\n return highlight(pawn_moves_b(index))\n\n else:\n\n return highlight(pawn_moves_w(index))\n\n\n\n if piece.type == 'k':\n\n return highlight(king_moves(index))\n\n\n\n if piece.type == 'r':\n\n return highlight(rook_moves(index))\n\n\n\n if piece.type == 'b':\n\n return highlight(bishop_moves(index))\n\n\n\n if piece.type == 'q':\n\n return highlight(queen_moves(index))\n\n\n\n if piece.type == 'kn':\n\n return highlight(knight_moves(index))\n\n\n\n\n\n## Basically, check black and white pawns separately and checks the square above them. If its free that space gets an \"x\" and if it is occupied by a piece of the opposite team then that piece becomes killable.\n\ndef pawn_moves_b(index):\n\n if index[0] == 1:\n\n if board[index[0] + 2][index[1]] == ' ' and board[index[0] + 1][index[1]] == ' ':\n\n board[index[0] + 2][index[1]] = 'x '\n\n bottom3 = [[index[0] + 1, index[1] + i] for i in range(-1, 2)]\n\n\n\n for positions in bottom3:\n\n if on_board(positions):\n\n if bottom3.index(positions) % 2 == 0:\n\n try:\n\n if board[positions[0]][positions[1]].team != 'b':\n\n board[positions[0]][positions[1]].killable = True\n\n except:\n\n pass\n\n else:\n\n if board[positions[0]][positions[1]] == ' ':\n\n board[positions[0]][positions[1]] = 'x '\n\n return board\n\n\n\ndef pawn_moves_w(index):\n\n if index[0] == 6:\n\n if board[index[0] - 2][index[1]] == ' ' and board[index[0] - 1][index[1]] == ' ':\n\n board[index[0] - 2][index[1]] = 'x '\n\n top3 = [[index[0] - 1, index[1] + i] for i in range(-1, 2)]\n\n\n\n for positions in top3:\n\n if on_board(positions):\n\n if top3.index(positions) % 2 == 0:\n\n try:\n\n if board[positions[0]][positions[1]].team != 'w':\n\n board[positions[0]][positions[1]].killable = True\n\n except:\n\n pass\n\n else:\n\n if board[positions[0]][positions[1]] == ' ':\n\n board[positions[0]][positions[1]] = 'x '\n\n return board\n\n\n\n\n\n## This just checks a 3x3 tile surrounding the king. Empty spots get an \"x\" and pieces of the opposite team become killable.\n\ndef king_moves(index):\n\n for y in range(3):\n\n for x in range(3):\n\n if on_board((index[0] - 1 + y, index[1] - 1 + x)):\n\n if board[index[0] - 1 + y][index[1] - 1 + x] == ' ':\n\n board[index[0] - 1 + y][index[1] - 1 + x] = 'x '\n\n else:\n\n if board[index[0] - 1 + y][index[1] - 1 + x].team != board[index[0]][index[1]].team:\n\n board[index[0] - 1 + y][index[1] - 1 + x].killable = True\n\n return board\n\n\n\n\n\n## This creates 4 lists for up, down, left and right and checks all those spaces for pieces of the opposite team. The list comprehension is pretty long so if you don't get it just msg me.\n\ndef rook_moves(index):\n\n cross = [[[index[0] + i, index[1]] for i in range(1, 8 - index[0])],\n\n [[index[0] - i, index[1]] for i in range(1, index[0] + 1)],\n\n [[index[0], index[1] + i] for i in range(1, 8 - index[1])],\n\n [[index[0], index[1] - i] for i in range(1, index[1] + 1)]]\n\n\n\n for direction in cross:\n\n for positions in direction:\n\n if on_board(positions):\n\n if board[positions[0]][positions[1]] == ' ':\n\n board[positions[0]][positions[1]] = 'x '\n\n else:\n\n if board[positions[0]][positions[1]].team != board[index[0]][index[1]].team:\n\n board[positions[0]][positions[1]].killable = True\n\n break\n\n return board\n\n\n\n\n\n## Same as the rook but this time it creates 4 lists for the diagonal directions and so the list comprehension is a little bit trickier.\n\ndef bishop_moves(index):\n\n diagonals = [[[index[0] + i, index[1] + i] for i in range(1, 8)],\n\n [[index[0] + i, index[1] - i] for i in range(1, 8)],\n\n [[index[0] - i, index[1] + i] for i in range(1, 8)],\n\n [[index[0] - i, index[1] - i] for i in range(1, 8)]]\n\n\n\n for direction in diagonals:\n\n for positions in direction:\n\n if on_board(positions):\n\n if board[positions[0]][positions[1]] == ' ':\n\n board[positions[0]][positions[1]] = 'x '\n\n else:\n\n if board[positions[0]][positions[1]].team != board[index[0]][index[1]].team:\n\n board[positions[0]][positions[1]].killable = True\n\n break\n\n return board\n\n\n\n\n\n## applies the rook moves to the board then the bishop moves because a queen is basically a rook and bishop in the same position.\n\ndef queen_moves(index):\n\n board = rook_moves(index)\n\n board = bishop_moves(index)\n\n return board\n\n\n\n\n\n## Checks a 5x5 grid around the piece and uses pythagoras to see if if a move is valid. Valid moves will be a distance of sqrt(5) from centre\n\ndef knight_moves(index):\n\n for i in range(-2, 3):\n\n for j in range(-2, 3):\n\n if i ** 2 + j ** 2 == 5:\n\n if on_board((index[0] + i, index[1] + j)):\n\n if board[index[0] + i][index[1] + j] == ' ':\n\n board[index[0] + i][index[1] + j] = 'x '\n\n else:\n\n if board[index[0] + i][index[1] + j].team != board[index[0]][index[1]].team:\n\n board[index[0] + i][index[1] + j].killable = True\n\n return board\n\n\n\n\n\nWIDTH = 800\n\n\n\nWIN = pygame.display.set_mode((WIDTH, WIDTH))\n\n\n\n\"\"\" This is creating the window that we are playing on, it takes a tuple argument which is the dimensions of the window so in this case 800 x 800px\n\n\"\"\"\n\n\n\npygame.display.set_caption(\"Chess\")\n\nWHITE = (255, 255, 255)\n\nGREY = (128, 128, 128)\n\nYELLOW = (204, 204, 0)\n\nBLUE = (50, 255, 255)\n\nBLACK = (0, 0, 0)\n\n\n\n\n\nclass Node:\n\n def __init__(self, row, col, width):\n\n self.row = row\n\n self.col = col\n\n self.x = int(row * width)\n\n self.y = int(col * width)\n\n self.colour = WHITE\n\n self.occupied = None\n\n\n\n def draw(self, WIN):\n\n pygame.draw.rect(WIN, self.colour, (self.x, self.y, WIDTH / 8, WIDTH / 8))\n\n\n\n def setup(self, WIN):\n\n if starting_order[(self.row, self.col)]:\n\n if starting_order[(self.row, self.col)] == None:\n\n pass\n\n else:\n\n WIN.blit(starting_order[(self.row, self.col)], (self.x, self.y))\n\n\n\n \"\"\"\n\n For now it is drawing a rectangle but eventually we are going to need it\n\n to use blit to draw the chess pieces instead\n\n \"\"\"\n\n\n\n\n\ndef make_grid(rows, width):\n\n grid = []\n\n gap = WIDTH // rows\n\n print(gap)\n\n for i in range(rows):\n\n grid.append([])\n\n for j in range(rows):\n\n node = Node(j, i, gap)\n\n grid[i].append(node)\n\n if (i+j)%2 ==1:\n\n grid[i][j].colour = GREY\n\n return grid\n\n\"\"\"\n\nThis is creating the nodes thats are on the board(so the chess tiles)\n\nI've put them into a 2d array which is identical to the dimesions of the chessboard\n\n\"\"\"\n\n\n\n\n\ndef draw_grid(win, rows, width):\n\n gap = width // 8\n\n for i in range(rows):\n\n pygame.draw.line(win, BLACK, (0, i * gap), (width, i * gap))\n\n for j in range(rows):\n\n pygame.draw.line(win, BLACK, (j * gap, 0), (j * gap, width))\n\n\n\n \"\"\"\n\n The nodes are all white so this we need to draw the grey lines that separate all the chess tiles\n\n from each other and that is what this function does\"\"\"\n\n\n\n\n\ndef update_display(win, grid, rows, width):\n\n for row in grid:\n\n for spot in row:\n\n spot.draw(win)\n\n spot.setup(win)\n\n draw_grid(win, rows, width)\n\n pygame.display.update()\n\n\n\n\n\ndef Find_Node(pos, WIDTH):\n\n interval = WIDTH / 8\n\n y, x = pos\n\n rows = y // interval\n\n columns = x // interval\n\n return int(rows), int(columns)\n\n\n\n\n\ndef display_potential_moves(positions, grid):\n\n for i in positions:\n\n x, y = i\n\n grid[x][y].colour = BLUE\n\n \"\"\"\n\n Displays all the potential moves\n\n \"\"\"\n\n\n\n\n\ndef Do_Move(OriginalPos, FinalPosition, WIN):\n\n starting_order[FinalPosition] = starting_order[OriginalPos]\n\n starting_order[OriginalPos] = None\n\n\n\n\n\ndef remove_highlight(grid):\n\n for i in range(len(grid)):\n\n for j in range(len(grid[0])):\n\n if (i+j)%2 == 0:\n\n grid[i][j].colour = WHITE\n\n else:\n\n grid[i][j].colour = GREY\n\n return grid\n\n\"\"\"this takes in 2 co-ordinate parameters which you can get as the position of the piece and then the position of the node it is moving to\n\nyou can get those co-ordinates using my old function for swap\"\"\"\n\n\n\ncreate_board(board)\n\n\n\n\n\ndef main(WIN, WIDTH):\n\n moves = 0\n\n selected = False\n\n piece_to_move=[]\n\n grid = make_grid(8, WIDTH)\n\n while True:\n\n pygame.time.delay(50) ##stops cpu dying\n\n for event in pygame.event.get():\n\n if event.type == pygame.QUIT:\n\n pygame.quit()\n\n sys.exit()\n\n\n\n \"\"\"This quits the program if the player closes the window\"\"\"\n\n\n\n if event.type == pygame.MOUSEBUTTONDOWN:\n\n pos = pygame.mouse.get_pos()\n\n y, x = Find_Node(pos, WIDTH)\n\n if selected == False:\n\n try:\n\n possible = select_moves((board[x][y]), (x,y), moves)\n\n for positions in possible:\n\n row, col = positions\n\n grid[row][col].colour = BLUE\n\n piece_to_move = x,y\n\n selected = True\n\n except:\n\n piece_to_move = []\n\n print('Can\\'t select')\n\n #print(piece_to_move)\n\n\n\n else:\n\n try:\n\n if board[x][y].killable == True:\n\n row, col = piece_to_move ## coords of original piece\n\n board[x][y] = board[row][col]\n\n board[row][col] = ' '\n\n deselect()\n\n remove_highlight(grid)\n\n Do_Move((col, row), (y, x), WIN)\n\n moves += 1\n\n print(convert_to_readable(board))\n\n else:\n\n deselect()\n\n remove_highlight(grid)\n\n selected = False\n\n print(\"Deselected\")\n\n except:\n\n if board[x][y] == 'x ':\n\n row, col = piece_to_move\n\n board[x][y] = board[row][col]\n\n board[row][col] = ' '\n\n deselect()\n\n remove_highlight(grid)\n\n Do_Move((col, row), (y, x), WIN)\n\n moves += 1\n\n print(convert_to_readable(board))\n\n else:\n\n deselect()\n\n remove_highlight(grid)\n\n selected = False\n\n print(\"Invalid move\")\n\n selected = False\n\n\n\n update_display(WIN, grid, 8, WIDTH)\n\n\n\n\n\nmain(WIN, WIDTH)\n\nIf I were to explain the entirety of the code, this would take hours on hours to write so I am going to explain the functions and any complex concepts which may be in them and leave you to solve out the rest.\n\nWe used pygame to write this program since it can easily give us the interface and I have experience from my A* algorithm on how to make a grid so most of the grid is just recycled code from that.\n\nExcept from the starting order dict, all of this was edwins code and all of it used for the move calculations. Theoretically you could have done this with only one of either a dictionary or a 2d list like he has done but since we both needed access to an array for our parts while we were coding and we couldn’t share a python script, we made our own versions. Edwin makes a class for the pieces since it is easier to manage and at the bottom he is setting up his 2d list so all the pieces are in their starting positions. In my dictionary, I hard wrote all the positions automatically since I needed to put the name of each of the individual image files into the load. pygame.image.load() is going to load an image onto the python file and then we only need to draw the image onto the screen. It is better this way than loading the image and then drawing because it means we only need to load the image once for the entire program and then just translate this image onto new positions on the screen.\n\nThe rest of edwins code is pretty self-explanatory and is just choosing the correct positions that each piece can move to and then putting those ‘legal’ tiles on the chessboard for us to use on the interface as a way of highlighting the board.\n\nWIDTH = 800\n\n\n\nWIN = pygame.display.set_mode((WIDTH, WIDTH))\n\n\n\n\"\"\" This is creating the window that we are playing on, it takes a tuple argument which is the dimensions of the window so in this case 800 x 800px\n\n\"\"\"\n\n\n\npygame.display.set_caption(\"Chess\")\n\nWHITE = (255, 255, 255)\n\nGREY = (128, 128, 128)\n\nYELLOW = (204, 204, 0)\n\nBLUE = (50, 255, 255)\n\nBLACK = (0, 0, 0)\n\n\n\n\n\nclass Node:\n\n def __init__(self, row, col, width):\n\n self.row = row\n\n self.col = col\n\n self.x = int(row * width)\n\n self.y = int(col * width)\n\n self.colour = WHITE\n\n self.occupied = None\n\n\n\n def draw(self, WIN):\n\n pygame.draw.rect(WIN, self.colour, (self.x, self.y, WIDTH / 8, WIDTH / 8))\n\n\n\n def setup(self, WIN):\n\n if starting_order[(self.row, self.col)]:\n\n if starting_order[(self.row, self.col)] == None:\n\n pass\n\n else:\n\n WIN.blit(starting_order[(self.row, self.col)], (self.x, self.y))\n\n\n\n \"\"\"\n\n For now it is drawing a rectangle but eventually we are going to need it\n\n to use blit to draw the chess pieces instead\n\n \"\"\"\n\n\n\n\n\ndef make_grid(rows, width):\n\n grid = []\n\n gap = WIDTH // rows\n\n print(gap)\n\n for i in range(rows):\n\n grid.append([])\n\n for j in range(rows):\n\n node = Node(j, i, gap)\n\n grid[i].append(node)\n\n if (i+j)%2 ==1:\n\n grid[i][j].colour = GREY\n\n return grid\n\n\"\"\"\n\nThis is creating the nodes thats are on the board(so the chess tiles)\n\nI've put them into a 2d array which is identical to the dimesions of the chessboard\n\n\"\"\"\n\n\n\n\n\ndef draw_grid(win, rows, width):\n\n gap = width // 8\n\n for i in range(rows):\n\n pygame.draw.line(win, BLACK, (0, i * gap), (width, i * gap))\n\n for j in range(rows):\n\n pygame.draw.line(win, BLACK, (j * gap, 0), (j * gap, width))\n\n\n\n \"\"\"\n\n The nodes are all white so this we need to draw the grey lines that separate all the chess tiles\n\n from each other and that is what this function does\"\"\"\n\n\n\n\n\ndef update_display(win, grid, rows, width):\n\n for row in grid:\n\n for spot in row:\n\n spot.draw(win)\n\n spot.setup(win)\n\n draw_grid(win, rows, width)\n\n pygame.display.update()\n\n\n\n\n\ndef Find_Node(pos, WIDTH):\n\n interval = WIDTH / 8\n\n y, x = pos\n\n rows = y // interval\n\n columns = x // interval\n\n return int(rows), int(columns)\n\n\n\n\n\ndef display_potential_moves(positions, grid):\n\n for i in positions:\n\n x, y = i\n\n grid[x][y].colour = BLUE\n\n \"\"\"\n\n Displays all the potential moves\n\n \"\"\"\n\n\n\n\n\ndef Do_Move(OriginalPos, FinalPosition, WIN):\n\n starting_order[FinalPosition] = starting_order[OriginalPos]\n\n starting_order[OriginalPos] = None\n\n\n\n\n\ndef remove_highlight(grid):\n\n for i in range(len(grid)):\n\n for j in range(len(grid[0])):\n\n if (i+j)%2 == 0:\n\n grid[i][j].colour = WHITE\n\n else:\n\n grid[i][j].colour = GREY\n\n return grid\n\n\"\"\"this takes in 2 co-ordinate parameters which you can get as the position of the piece and then the position of the node it is moving to\n\nyou can get those co-ordinates using my old function for swap\"\"\"\n\n\n\ncreate_board(board)\n\n\n\n\n\ndef main(WIN, WIDTH):\n\n moves = 0\n\n selected = False\n\n piece_to_move=[]\n\n grid = make_grid(8, WIDTH)\n\n while True:\n\n pygame.time.delay(50) ##stops cpu dying\n\n for event in pygame.event.get():\n\n if event.type == pygame.QUIT:\n\n pygame.quit()\n\n sys.exit()\n\n\n\n \"\"\"This quits the program if the player closes the window\"\"\"\n\n\n\n if event.type == pygame.MOUSEBUTTONDOWN:\n\n pos = pygame.mouse.get_pos()\n\n y, x = Find_Node(pos, WIDTH)\n\n if selected == False:\n\n try:\n\n possible = select_moves((board[x][y]), (x,y), moves)\n\n for positions in possible:\n\n row, col = positions\n\n grid[row][col].colour = BLUE\n\n piece_to_move = x,y\n\n selected = True\n\n except:\n\n piece_to_move = []\n\n print('Can\\'t select')\n\n #print(piece_to_move)\n\n\n\n else:\n\n try:\n\n if board[x][y].killable == True:\n\n row, col = piece_to_move ## coords of original piece\n\n board[x][y] = board[row][col]\n\n board[row][col] = ' '\n\n deselect()\n\n remove_highlight(grid)\n\n Do_Move((col, row), (y, x), WIN)\n\n moves += 1\n\n print(convert_to_readable(board))\n\n else:\n\n deselect()\n\n remove_highlight(grid)\n\n selected = False\n\n print(\"Deselected\")\n\n except:\n\n if board[x][y] == 'x ':\n\n row, col = piece_to_move\n\n board[x][y] = board[row][col]\n\n board[row][col] = ' '\n\n deselect()\n\n remove_highlight(grid)\n\n Do_Move((col, row), (y, x), WIN)\n\n moves += 1\n\n print(convert_to_readable(board))\n\n else:\n\n deselect()\n\n remove_highlight(grid)\n\n selected = False\n\n print(\"Invalid move\")\n\n selected = False\n\n\n\n update_display(WIN, grid, 8, WIDTH)\n\n\n\n\n\nmain(WIN, WIDTH)"
    },
    {
        "link": "https://playgama.com/blog/unity/what-are-the-best-practices-for-implementing-chess-piece-movement-logic-in-a-digital-chess-game",
        "document": "First, ensure you have a thorough understanding of the movement rules for each chess piece. Pawns move forward while capturing diagonally, knights follow an L-shape, rooks move linearly, bishops move diagonally, the queen combines the powers of rooks and bishops, and the king moves one square in any direction.\n\nUse a 2D array, often 8×8, to represent the chessboard grid. Each element can represent a piece using a class with properties defining its type and position. This structure simplifies the validation of moves within bounds.\n\nImmerse yourself in gaming and excitement!\n\nImplement collision checks to ensure a piece does not move through others, except for knights. Consider creating a method within your piece class to validate possible moves based on its type.\n\nCreate a piece-specific class hierarchy to encapsulate movement logic. Each class should have a method to return a list of legal moves from the current position, leveraging subclass methods tailored to each piece type.\n\nUse algorithms like Minimax with alpha-beta pruning to evaluate board positions and generate moves. These can simulate various depth levels of future moves, balancing performance and decision quality.\n\nIntegrate machine learning by training models to recognize optimal moves in various board states through platforms like TensorFlow or PyTorch. Reinforcement learning can refine this process over time.\n\nImplement logic to handle castling and the ‘en passant’ pawn capture. This requires additional rule checks during movement logic evaluation, ensuring these special moves are as per chess laws.\n\nDevelop unit tests for movement logic to guarantee all rules are followed. Automated tests can cover common cases and edge scenarios, ensuring robust and error-free gameplay."
    },
    {
        "link": "https://reddit.com/r/learnjava/comments/7sawtg/how_to_implement_java_chess_game_logic",
        "document": "So right now I have a board class that holds all the pieces of the game. I have a class for each piece (rook, queen, ect...) but how do implement that piece having a valid move? I cant bring the board as a parameter of the class so I don't know how each piece moves in relation to the board. IE rooks jumping over pieces if its a valid move in the rook class. Would I have to place this logic in the board class?\n\nBasically, how do I have a method in my chess piece class that tells me it's a valid move and how do I utilize that method in the board class?\n\nI don't want AI, just the basic rules for 2 people to play.\n\nThanks for the help"
    },
    {
        "link": "https://stackoverflow.com/questions/66467383/how-to-draw-a-chessboard-with-pygame-and-move-the-pieces-on-the-board",
        "document": "I've been trying different ways how to get my chess pieces to drag and drop I've found ways, but the problem is that I'm using a dictionary to load my images via . I've created a dictionary for my images like this:\n\nI've been through these questions for sprite drop and drag:\n\n How to move Sprite in Pygame\n\nDrag multiple sprites with different \"update ()\" methods from the same Sprite class in Pygame\n\npython pygame - how to create a drag and drop with multiple images?\n\nI've attempted many of these, but I can't seem to figure out how to implement any of them in my code for image dictionaries. I'm just lost. I need help. If you need anymore information or code let me know."
    },
    {
        "link": "https://codingal.com/coding-for-kids/blog/building-a-chess-game-in-python",
        "document": "Future employment prospects for youngsters who learn Python Programming might be very diverse. With Python being used in many sophisticated disciplines, many new employment possibilities have emerged and will continue to emerge in the future.\n\nYou should start introducing Python programming for kids right off the bat. It would strengthen their academic performance and their chances of securing a prosperous future profession. Even if your children decide not to embrace computer programming in the future, training them in Python today will enable them to develop life skills.\n\nThese days, creating video games may be quite lucrative. It can also be utilized as an educational and advertisement tool. Game creation may be really enjoyable and involves a lot of math, logic, physics, AI, and other subjects.\n\nPython can also be used to make games, with features like collision detection, music, backgrounds, and sprites among many others.\n\nPyGame is one of the greatest modules for programming games in Python and is used for game development.\n\nWhat is the Python PyGame Module?\n\nA cross-platform collection of Python modules called Pygame is intended for use in game development. It comes with music and graphics libraries made specifically for use with the Python programming language.\n\nA collection of open-source and free Python modules is called PyGame. It may also be used to create games, as the name would imply. We may code the games and then convert them into an executable file by using certain instructions.\n\nThis way, you can show friends what you have been working on. It comes with music and graphics libraries made specifically for use with the Python programming language. The most recent version of PyGame at the time this article was written was 2.0.1.\n\nThis blog post will demonstrate how to create a chess game with the Python PyGame package.\n\nBasic Functions Used in the Python PyGame Module:\n• The PyGame module is started using the command pygame.init().\n• : Using this command, the user may create a window with the specified dimensions (width, height). The object on which we execute various graphical operations is a Surface Object, which is the return value.\n• : This command is used to set the title of the window/ board.\n• : The event queue is emptied using this. The operating system will see the game as unresponsive if we fail to call this, causing the window messages to build up.\n• : This is used to terminate the event when we click on the close button at the corner of the window.\n\nRendering the game item onto the surface is called blitting. We should render the game object when we’ve created it. The black window will appear if the game item is not rendered. Blitting may be done using blit(), a function in PyGame. Since it is among the slowest functions in a game.\n\nwe must use caution while utilizing it and avoid blitting too much onto the screen in a single frame.\n\nsrc: It is the source of the image which we want to display on the screen.\n\ndest: It is the coordinates where we want our image to be displayed.\n\nThis Python code is for a two-player chess game implemented using the PyGame library.\n\nImporting the PyGame library is the first step in the code, which creates the chess game’s graphical user interface.\n\nPyGame is initialized using pygame.init(), which sets up the Pygame environment.\n\nThe code sets 800 pixels for both width and height as the game window’s size. The window caption is changed to “Two-Player Chess Game.”\n\nTo present text at varying sizes, three distinct fonts are defined. To manage the game’s frame rate (60 frames per second), a clock object (timer) is made.\n\nThere are set-up lists of the starting places of the white and black pieces on the chessboard. Both players’ captured pieces are observed. The game state and player movements are controlled by the variables (turn_step, selection, and valid_moves). The chess piece images (such as the king, queen, and rook) are loaded and resized appropriately.\n\nTo verify the legal movements for every kind of chess piece—such as pawns, rooks, knights, bishops, queens, and kings—several functions are defined. For a given piece at a particular position, these routines produce a list of feasible move locations.\n\nThe chessboard grid, status text, and “FORFEIT” button are all drawn using the draw_board() method.\n\nThe chess pieces are drawn on the board based on their present locations using the draw_pieces() method. A red or blue rectangle indicates which piece the player has picked.\n\nAfter determining if the chosen piece may be moved, the check_valid_moves() method gives a list of possible move locations. The picked piece can be moved to the valid move positions indicated by the little circles shown by the draw_valid() function.\n\nThe code is always looking for PyGame events, such as keystrokes and mouse clicks. Moves and piece selection are done using mouse clicks. You can stop the game by clicking the “FORFEIT” button. The “ENTER” key is used to resume the game once it has ended.\n\nThe captured pieces are shown to both players on the side of the game window via the draw_captured() function.\n\nChecking for Check and Game Over:\n\nThe king of the player who is in check is surrounded by a flashing square drawn by the draw_check() function. To decide the winner and put a stop to the game, the checkmate or stalemate condition is checked for.\n\nRendering, event management, and game updates are handled by the main game loop (during the run:).\n\n It also controls player turns, the game’s finish, and the overall condition of the game.\n\nPyGame may be terminated using pygame.quit() to end the game loop, which lasts until the player exits the game window.\n\nYou can find the images used in the activity here.\n\nKids Can Sign up with Codingal Today to Master Their Coding Skills\n\nPyGame is an excellent option for individuals who are new to game creation as it is easy to use. It is accessible due to its simplicity and Python syntax. We can customize the chessboard’s appearance by modifying the graphics and colors in your game. Learn Python for kids online with Codingal. Whether you are a beginner exploring the basics or an experienced developer aiming to add depth to your projects, learning Python online with Codingal proves to be a transformative journey."
    },
    {
        "link": "https://geeksforgeeks.org/create-a-chess-game-in-python",
        "document": "Here, we have a task to create a chess game in Python. In this article, we will see how to create a chess game in Python.\n\nChess Game, Played by two players on an 8x8 grid board with alternate light and dark squares, chess is a time-honored board game of strategy and cunning. Each player deploys 16 pieces at the beginning of the game, placing them in the rows closest to them. Pawns are arranged on the second row, and the first row is occupied by other pieces. The goal of the game is to advance your pieces to a position from which you can capture the king of your opponent and force a \"checkmate,\" winning the game for you. Every piece has certain movement rules that players must stick to.\n\nBelow are the step-by-step procedure and explanation of how to create a Chess Game in Python:\n\nFirst, create the virtual environment using the below commands\n\nFirst, we need to install the Pygame library, which is used for creating games. We are utilizing it to create a chess game. To install Pygame, use the following command:\n\nBelow are the step-by-step explanation of the main.py code that we have used to create a chess game in Python:\n\nImporting necessary modules for the code, including for game development, for making HTTP requests, for removing image backgrounds, and for handling byte data.\n\nHere, the code initializes the Pygame module using . This step is crucial for setting up the Pygame environment and enabling the use of its functionalities throughout the script.\n\nIn below code initializes three different fonts of varying sizes using the function. These fonts are likely to be used for rendering text within the game. Additionally, the code creates a clock object using to control the frame rate of the game.\n\nBelow, code defines variables related to the game, such as lists representing the locations and types of chess pieces. URLs for chess piece images are stored in . These variables play a crucial role in managing the game state, including the positions of pieces and the URLs required to fetch their corresponding images.\n\nIn below code we are Using the function, the code loads chess piece images from URLs. The library is employed to remove image backgrounds, enhancing the visual appearance of the pieces. Each image is then scaled using to ensure a consistent size within the game.\n\nIn below code , section organizes the loaded piece images into lists for convenient access and manipulation. Two lists, and , contain the original and scaled versions of white chess pieces, respectively. Similar lists are created for black pieces. Grouping the images simplifies the process of drawing pieces onto the game board.\n\nbelow code code defines functions responsible for drawing the game board. The function uses Pygame's drawing functions to create a chessboard with alternating light gray and gray squares. Additionally, lines are drawn to delineate the squares, and status text is displayed at the bottom of the window, indicating the current player's turn and actions\n\nBelow, are the explanation of Piece Drawing Functions for create a chess game in Python.\n\nIn below code function is responsible for visually representing chess pieces on the board. It iterates through both white and black pieces, displaying them at their respective locations. The function adjusts the position for pawn images and outlines the selected piece with a red rectangle during white's turn and a blue rectangle during black's turn\n\nIn below code the function, , validates and gathers all possible moves for each piece on the chessboard, distinguishing between different piece types and their respective movements.\n\nIn below code function focuses on determining and returning the valid moves for a king, considering its ability to move one square in any direction and distinguishing between friendly and enemy pieces.\n\nIn below code function combines the valid moves of a queen by integrating the results from both the bishop and rook functions, providing a comprehensive list of valid moves for a queen at a given position and color.\n\nIn below code function calculates and returns the valid moves for a bishop by traversing diagonal paths in all four directions, considering board boundaries and avoiding friendly pieces.\n\nIn below code the function, , determines the valid moves for a rook by exploring horizontal and vertical paths in all four directions, ensuring the moves stay within the board boundaries and avoid friendly pieces.\n\nThe function identifies and returns the valid moves for a pawn, considering different scenarios such as initial double moves, single moves, and diagonal captures based on the color of the pawn.\n\nThe function calculates and returns the valid moves for a knight by exploring eight possible positions in an \"L\" shape, ensuring the moves are within the board boundaries and avoid friendly pieces.\n\nThe function determines the valid moves for the currently selected piece based on the game's current turn, providing a list of possible moves.\n\nThe function visually represents valid moves on the screen by drawing small circles, using red circles for white's turn and blue circles for black's turn.\n\nThe function visually displays captured pieces on the side of the screen, utilizing lists of captured pieces for both white and black.\n\nThe function visually indicates a check condition by drawing a flashing square around the king, with the color and conditions dependent on the current turn.\n\nThe function displays a message on the screen declaring the winner of the game and instructs the player to press ENTER to restart, utilizing the winner variable to determine the winner displayed on the screen.\n\nThe game loop begins by calculating valid move options for both black and white pieces using the function. Subsequently, a counter is incremented, and the screen is filled with a dark gray color, providing a clean canvas for rendering. Functions like , , , and are then called to visually represent the chessboard, pieces, captured pieces, and check conditions.\n\nThe code utilizes a loop to handle pygame events, primarily focusing on mouse clicks (`pygame.MOUSEBUTTONDOWN`). It checks for the left button click (`event.button == 1`) and ensures the game is not over (`not game_over`). The coordinates of the click are determined and translated to grid coordinates. Depending on the turn step, it processes player input for moving pieces, capturing opponents, and updating the game state accordingly.\n\nWithin the event loop, the code checks for a key press (`pygame.KEYDOWN`) when the game is over. Specifically, it looks for the \"Enter\" key (`event.key == pygame.K_RETURN`). Upon detecting this key press, the game resets to its initial state, including piece positions, captured pieces, turn steps, and valid move lists. This functionality allows players to restart the game seamlessly.\n\nIf a winner is determined, the code sets the `game_over` flag to true and calls the `draw_game_over` function to display a game-over message on the screen. The winner variable influences this decision, considering factors like capturing the opponent's king or pressing forfeit squares. This aspect enhances the user experience by providing clear feedback on the game's outcome.\n\nBelow is the complete code implementation of main.py file that we have used to create a chess game in Python.\n\n# Setting Width and height of the Chess Game screen # function to check all pieces valid options on board # 8 squares to check for kings, they can go one square any direction \\ \\ \\ \\ \\ \\ # 8 squares to check for knights, they can go two squares in one direction and one in another # check for valid moves for just selected piece # draw a flashing square around king if in check"
    },
    {
        "link": "https://thepythoncode.com/article/make-a-chess-game-using-pygame-in-python",
        "document": "Before we get started, have you tried our new Python Code Assistant? It's like having an expert coder at your fingertips. Check it out!\n\nThe chess game is a pretty cool project idea for intermediate Python programmers. It's good practice for making apps with GUIs while getting good at using classes. In this tutorial, you learn about:\n• None Using the basics of\n• None Learn how to code a chess game with Python classes.\n\nRelated: How to Make a Hangman Game in Python.\n\nBefore we start coding, let's first install the module in the terminal:\n\nOnce we installed the , let's move into setting up our environment by making the py files and folder we're using in this order:\n\nMove the images of the chess icons you'll use in the directory. Make sure your image files are named just like this:\n\nIf you don't have chess icons, you can use mine here.\n\nAnd now we're done setting up; we can start coding now. Our chess game has two main code parts; creating the board and creating the pieces. The board will mainly focus on square positions and game rules, while the pieces focus on the piece they represent and the moves it has.\n\nLet's start by making the class. The class creates, colors, position, and draw each chess tile inside our game window:\n\nThe first thing we're gonna do is to make a class for making chess . Let's start by adding the function to get the square's , , for a row, and for the column.\n\nWith this basic information, we can fulfill other variables using them. As you see above, we have and while we also have and . and dictates where the chess tile is assigned to be drawn inside the window, and we compile them both in .\n\nThe tells the square tile should be light colored if it is divisible by 2 or instead dark if not, while the tells the color configuration for light and dark. We also have which we use to highlight the tiles with the possible movement of a piece if it was selected. The configures the width, height, and location (using and ) of a square or tile.\n\nThe returns the name of the tile depending on its and based on the real board. Letters symbolize rows, and the number symbolizes columns. Like \"a1\", it is the bottom leftmost tile in a chess board.\n\nThe , executes the configurations we did by drawing the tile in the canvas, in the color it was assigned. The second statement tells that if the square has a piece in this position, you should access its icon and place it inside the tile.\n\nNow we have a class for making a square. Let's make another class for handling tiles and the whole board.\n\nIn making the whole chess board, it's important to know first what is the and of the game window so we can divide it into 8 rows with 8 columns to identify our tiles' exact size.\n\nThe represents the chessboard configuration with a 2D list having our pieces with their default position. Below it, we configure the with a value calling our for making chess tiles and putting them all in a list.\n\nNow let's create the other parts of the , including the we called above.\n\nThe creates each piece, and puts them in their respective place by mapping the with the whole board. If the current value of in is an empty string or , then the tile must be empty, and if not, it will access its respective tile position through the current value of and . Each from will be identified according to the capital letter it has, except the .\n\nIf we got , then it's a if , then it's a . If , then it's a , 'B' for , and so on. After we configure the letters, we'll overwrite the current with a value of their piece class with the color depending on the first value of the string. As you noticed here and in the other statement:\n\nWe put a as an argument for the class. That means we put our current class, , as an argument.\n\nWe need a function that detects each click in our game. So let's make in our class:\n\nThe accepts the x ( ) and y ( ) coordinates of where you click inside the game window as an argument. The and variables inside this function compute what row and column you clicked, then we pass its outcomes to to get the square or the tile.\n\nThis configuration can now receive our every click inside the game window. The following if/else statements process our click if we're making a move or just clicking around.\n\nIt all works once you clicked somewhere inside the game window so let's assume that you're playing the game using a white piece and you've already clicked. If we haven't selected any piece yet, it will look as if the tile you clicked has a piece, and if it's your colors turn, and if yes, it will be your .\n\nWith the help of other classes, your piece's possible move will be highlighted in the game. After selecting a piece's move, it will convert the into the next player's piece color.\n\nNow that we have a selected piece and chosen a move, it will make the move. I'll explain the other moving later as we make the classes for that piece.\n\nLet's add another feature for the class; we are adding functions that check if a player is in check or checkmate.\n\nFor every move we make, the function will be called, whenever the is not empty.\n\nIn the first iteration, it locates the position of the old tile, passes its current piece in , and empty that tile while in the second iteration, it catches the new tile position and passes its current piece to and give it a new piece from .\n\nOnce our is not empty, it'll try to identify if it's a by getting its . If so, it'll override the and give it the value of .\n\nNote: The is a variable from the pieces' class, that serves as an identification containing their letter symbols.\n\nThe next thing we'll try to identify is what the enemy piece does to do the check to our player's , where we check starting by .\n\nWith the following code above, we can iterate through enemy pieces and check their , which gets all the possible moves of a piece. If a has a position in the same value as , which means one of the players is checked, so we set the to . The tells if a is in check or not, so we have to return it.\n\nNow let's make the function for identifying if we have a winner yet:\n\nOnce we get the the same color as the argument we passed, it'll try to see if it has any moves left. If none, then it'll check if the player is in check. If that's the case, then it will return the value of the which is , which means the side of the color we passed is checkmate.\n\nNow we have all the board configurations; it's time to add the final function for the class which is the function:\n\nThis function highlights all the possible moves of a piece once selected while it is its color's turn.\n\nLearn also: How to Make a Tetris Game using PyGame in Python.\n\nNow we're finished with class, let's make another class for pieces in .\n\nLet's start by adding a function that gets all the available moves and a checker if the next player got checked by the previous player:\n\nThe gets all the available moves of the current player, including attacking the enemy piece. If an opponent piece is in range of a piece's move, the piece can capture it where its range will limit on these opponent's piece tile position through then unless the piece is which can move in an 'L-shape'.\n\nBefore proceeding for our current player in making a move, the checks first if the last player does a move that checked our current player. And if not, then it will return the available moves.\n\nTo make the pieces work, we're adding a function that handles every move we make on the board:\n\nIt takes and as arguments. If the tile we select to move our chosen piece is in , the move is valid to execute. To make it happen, the function will get the current square using and save it in and get its positions , , and save it in , , and for further use.\n\nThen the function will empty the , and the piece (self - the current chess piece class) will be moved to the .\n\nChess has cool features; some of them are castling and pawn promotion, and that's what we do next.\n\nIf the notation of the piece we've just moved in is , which is a pawn, and it reaches row 0 (for white pawns) or row 7 (for black pawns), the pawn will be replaced by another queen of the same color.\n\nAnd if the piece's notation is and then moved 2 tiles to the left or right, it means the player's move is casting.\n\nNow that we've finished the , , and classes, it's time to create different classes for every piece type. Each piece will have the main class as its parent class:\n\nHere is our code for the pieces, whether it is black or white. As you notice, we have and functions here in the class, just like the functions we have in the class but given with a different script. It is because pawn pieces are basically allowed to move 1 step at a time away from their team position. A pawn also has 3 possible moves; the pawn can move up to 2 tiles from its starting position only, can move 1 step forward at a time, and can capture a piece 1 diagonally step at a time.\n\nAs we noticed, we have another function which is the . As of its name, it gets all the possible moves of a piece base on the current state of the board.\n\nNow let's move to do the other codes for other pieces.\n\nLet's finish the game by adding code in that runs our whole game:\n\nAs you see above, we had and variable, which has pretty similar arguments but not really.\n\nThe handles the rendering of the chess board on the screen so we can see what's happening in the . The code creates the game window.\n\nWhile we use the for making and handling tiles, tile positions, and what piece a chess square has. As you remember, in the class code, we give it two arguments: the game window's length and width.\n\nTo keep the game running, we give it a loop that runs as long as the value of is .\n\nThe locates the current position of your mouse as long as it's inside the game window. If you add below this code, you'll see the current mouse position, and its value changes every time you hover it inside the window.\n\nThe catches every click you make. To identify if a player is making a move, every time it catches a player doing a click, the current position of the mouse we get from will be sent in , and process your click back there.\n\nOk, now let's try this game. If it's working so in your terminal, move to the directory where our file was saved, then run the . Once you run the file, the game will start immediately:\n\nStart clicking on the pieces that can move, and you'll see available moves:\n\nTo simplify it, always remember that the chess game has two main parts, the board, and the pieces.\n\nThe board is in charge of every tile's name & position and the rules of the game, while the piece classes take care of moves and attacks for every piece.\n\nTo make the board, you should have a class that creates the handling chess tiles that also mind the piece it contains, and another class called , which contains the game rules. We also need to do class for every chess piece, from the to the . And that's how you make a chess game with Python using only classes and !\n\nYou can check the complete code here.\n\nHere is a list of other pygame tutorials:\n• None How to Make a Checkers Game with Pygame in Python\n• None How to Build a Tic Tac Toe Game in Python\n• None How to Make a Tetris Game using PyGame in Python\n• None How to Create a Hangman Game using PyGame in Python\n• None How to Make a Drawing Program in Python\n• None How to Make a Planet Simulator with PyGame in Python\n• None How to Make a Snake Game in Python\n\nJust finished the article? Now, boost your next project with our Python Code Generator. Discover a faster, smarter way to code."
    },
    {
        "link": "https://newill.dev/creating-a-chessboard-with-pygame-part-2",
        "document": "Recently I wrote about learning Python by creating a chess game. I am new to Python, although not new to programming. Python has intrigued me for the last few months, especially how popular it seems to be (second place on GitHub fourth quarter 2020). When an opportunity came up to work with some friends and learn it I jumped at it.\n\nIn the last post about the chess game I wrote about getting familiar with Pygame and was able to programmatically draw a chessboard on the screen. I didn’t make much of an attempt at classes and structuring the program in any good way. In this post, I want to show what I have managed to accomplish as part of my teamwork. The image above shows how it looks now when I run the program.\n\nI added some folders to the project. The first one is a pieces folder and contains seven .py files. Six of them are classes for each piece. The second folder is for resources, called res, and within that is an img folder containing images of the different chess pieces.\n\nLets take a look at the Pawn class:\n\nEach piece inherits from piece.py which contains the Piece class. The reason I went with inheritance is that every piece has some of the same attributes such as its colour and if it’s active or not (active meaning it is in play and hasn’t been taken off the board). But, each piece has differences such as a type (meaning Pawn in the example above) and an associated image.\n\nLine 1: I import Piece from pieces.piece which means the piece file is in the pieces folder.\n\nLine 2: I import an enum here so I can specify what each piece is. Perhaps I could have just used a string and specified “Pawn” as the piece type, but I went with an enum instead out of habit from other languages and because the names of pieces are constants.\n\nLine 3: I import an enum called ChessColour that also provides constants of BLACK or WHITE.\n\nLine 4: I import pygame.image because it is needed later when I return the correct image to represent the piece.\n\nLine 7: The class is declared. I called it Pawn and with Piece being passed in as a parameter it indicates to Python that Pawn inherits from Piece and in doing so, contains all of its attributes.\n\nLine 9 is where the init method is declared. Whenever a Pawn is instantiated, the init method is called and sets up the properties as needed. In this case, I pass in if the piece is black or white. I then manually set the piece_type property using the enum and set the image to None.\n\nYou will see on line 12 that I call super init which calls the init method of the superclass so that the piece colour is set.\n\nLines 14-21: I declare a getter and setter in this section of code. The getter is used to find out what type of piece this object is, and the setter is used to change the piece type.\n\nLines 23-29: This contains the getter for the piece image property. A surface is returned based on what colour the chess piece is. I also use convert_alpha() to ensure that the transparent background on each image is used.\n\nThe Piece class which the Pawn above inherits from is as follows:\n\nIt contains two properties, the colour of the piece and if it’s active or not. I didn’t pass in is_active as a parameter because when a chess piece is instantiated, it will always be active.\n\nThe chess_colour property has a getter that returns the item from the enum (either BLACK or WHITE).\n\nThe is_active property has both a setter and getter. The setter is used to deactivate or reactivate the chess piece.\n\nAfter creating all of the pieces I moved the chessboard class out to its own file. This has the following properties:\n\nThe x and y start properties are used for determining the position on screen of the top left corner of each square.\n\nThe width_height stores how many pixels the width/height of the square is.\n\nThe chess_colour property determines what colour the square is.\n\nPosition is a more friendly A1 – H8 reference stored as a string. It seemed better to use that property to determine what square was clicked on than passing back difficult to understand x/y coordinates of a square.\n\nThe Piece defaults to None on instantiation, but when pieces are added to the board, or when they move around, an instance of the Piece class which includes its properties will be stored here. Note that this Piece class will be either a Rook, Pawn, King, Queen, Knight, or Bishop Piece.\n\nSetters and getters, if needed, are also included in this class. Not everything has a setter or getter.\n\nSetting Up the Chessboard and Pieces\n\nAt the moment the main.py file has a few methods.\n\nThis method creates a board square from coordinates, colour, and position.\n\nLines 4-7 determine the screen width or height which are constants declared earlier in main.py. It uses the shorter dimension to set the width_height property that will be used to instantiate a BoardSquare object. The reason for this is so that if a board is setup wider than it is tall, then the board will fit in the height and not run off the screen.\n\nLines 10 and 11 are used to set the coordinate of where the square will be on the screen.\n\nFinally, we instantiate BoardSquare with the details and return it to the caller.\n\nI set up an alternate_colour method that takes a ChessColour object and if it’s black, it swaps it to white and vice-versa:\n\nThe method above is fairly simply. You pass in a ChessColour and it returns the other colour from the ChessColour enum. This is used when putting squares on the board. They alternate on each row from black to white, and then the same again but starting with the opposite colour.\n\nLine 2: creates a square_colour which will be used to set the colour of each square as it is instantiated.\n\nLine 3: We loop around the y axis which moves us from the top to the bottom of the screen.\n\nLine 4: We create another list called chess_row. The idea I had here was to append chess_row to chess_board making chess_board a two-dimensional list. This means that we can store rows that have eight squares in each to represent the columns.\n\nLine 5: We alternate the square colour. In line 2 it defaulted to BLACK, but the top left colour on a chessboard is always white, so I alternate this here back to white to begin. I’ll explain more of this later on in this section of code.\n\nLine 6: A nested loop is created that works across the x-axis that allows us to create board squares across the row.\n\nLine 7: This is used to determine the friendly position name. By getting the character of x+65 it makes the initial zero on the first run of the loop equal to A, and then we append 8-y which is y for the outer loop, so 0 on the first run. 8-0 is 8. As it runs across it sets position to A8, B8, C8, D8 and so on. On the next run of the outer loop X will increment and make the first character 1, and the 8-y will be 8-1 which equals 7 making it A7, B7, C7 and so on.\n\nLine 8: We create a board square with the colour of white on the first run and append this to the chess_row.\n\nLine 9: The colour of the square is swapped to black in preparation for the next square in the row. When it reaches the end of the row, line 10 appends the chess_row list to the chess_board list.\n\nThe outer loop then increments, but if you notice on a chessboard, the last square on the first row is the same colour as the square on the next row. This process repeats down the rest of the board. On the last iteration for the nested loop, the colour was set to white on line 9, but the colour on row 2 needs to be black. This is why on line 5, I alternate it back on the outer loop. There might be a simpler way of doing this, but this seemed a decent approach to me. The only caveat is that to get a white square at the top left, the initial square colour is set to black, which really isn’t a caveat.\n\nI needed a way to determine which square the mouse clicked on. To accomplish this I used a bit of if/then logic to determine if the appropriate square had been found. I return the board_square object so that when it is clicked on, the piece and other properties can be accessed.\n\nThis section of code is one that works well, but when my IDE offered to simply my if statements, and I accepted, it actually made it a little harder to understand. I think it’s written well and it seems to work flawlessly, but I’ll explain what it’s doing.\n\nLine 1: The x and y coordinate of the mouse click us passed in.\n\nLine 2: Cycle through each row list stored in the chess_board list.\n\nLine 3: On this if statement, row[0] is used to just grab the first square in the row. Because we are checking if the mouse click is within the height of this row, we can choose any of the 8 squares to search, but I decided to check the first one. We check the y_start of the first square. If we’re on the third row down then y_start might be 150. If we clicked at 167 then yes, y_start is less than 167. We then check if y is less than y_start (being 150) plus the width_height of the row. If that width_height was 50 pixels, then is y < 150+50. Yes, it is. 167 is less than 200. This test passes, so we go on to the nested loop.\n\nLine 4: Now that we have found the correct row, this next step loops through each square and checks if the mouse pointer is between the x_start and the x_start + width_height. If it is, it returns and if not, it tries the next square in the row.\n\nThe above classes and methods put in place provide what is needed to draw the chessboard on screen. At this point in the code, I haven’t yet reached the main loop. My plan was to draw the initial state of the board before hitting the game loop and then use the loop when the game was in play.\n\nThe example above is what I use to draw the board on screen and also add the pieces. I have cut most of the if statement out because you can see enough of what’s happening with just part of it.\n\nLines 1 and 2: The for loop works through the chess_board and the nested loop on line 2 works across each row.\n\nLine 3 creates the surface for the square. I pass in the width_height twice for the x and y axis.\n\nLines 5-8 are used to determine the colour of the square. If it’s white I use 200, 200, 200 as the RGB values. This is off-white because the white chess piece images were hard to see. Likewise, the black is more grey at 55, 55, 55 so that the black chess pieces are more visible.\n\nLines 10-12 are used to put the chess square on the screen. The x_start and y_start properties are used to specify the top left corner of where the square will be going.\n\nFor the rest of the code, I ended up using a lot of if and elif statements. I couldn’t think of a way to programmatically add pieces based on position except for perhaps a list of what goes where, but I decided to just use logic to determine if a square has a piece or not. Take the pawns for example. If I’m on the second row down, it’s a full row of black pawns and if on the second to last row, it’s all white pawns. I then just used statements such as if A8 or H8 then add a black rook to the square.\n\nWhen running this code, it now shows a chessboard with all of the pieces in the right places.\n\nThe only parts broken at the moment is the positioning of the chess pieces in each square and the resizing of those chess piece images. Unlike the squares that can resize by editing the width and height constants, the pieces do not resize. They look great when the board is 500 x 500 pixels, but any smaller then the pieces are bigger than the squares they are in, and any larger for board dimensions, then the pieces get smaller. This is just a quick fix.\n\nAlso, the pieces are not centred by default. They are aligned top left. I need to add some logic to put them in the middle of each square.\n\nOther than those problems, things are working well so far. I think the organisation of classes is going well so far. I mentioned last time I wrote that my focus was going to be on MVC, but this time I just focussed on organising classes. My next update will be to move pieces and then at the same time I’ll make sure I stick to MVC principles to separate logic from the view.\n\nChessboard pieces: “PNG chess pieces/Standard transparent” by Cburnett is licensed under CC BY-SA 3.0"
    },
    {
        "link": "https://stackoverflow.com/questions/43334197/creating-chess-in-python-and-pawn-movement-gets-affected-by-bishop",
        "document": "I am in the progress of making chess using Pygame.\n\nCurrently, I only have the ability to make white pawns and white bishops. I have a projected() function for each of the WhitePawn and WhiteBishop classes, which highlights the positions on the board that the pieces can go. For example, if there is a pawn on E2 and a bishop on E4, then E2 (when you click the piece) and E3 would light up, but E4 would not light up because the bishop is in the way. When you click on the lit up square, then it moves the piece to that position on the board. The noProjected() function for both classes is supposed to remove the lit up positions on the board.\n\nMy issue right now is that if the white pawn tries to move through a white bishop's projected path (even if I didn't click on it), it doesn't light up the square and therefore I can't move there. For example, if a White Pawn is on E2 and White Bishop on D4, then E2 and E4 light up, when E2, E3, and E4 are supposed to light up.\n\nI do have a guess that the issue is the for loop on the bottom: play.totalPlayList consists of play.whitePawnList (all the white pawns on board) and play.whiteBishopList in that order. When I reversed the order, in that list, the pawn movement worked (but of course the bishop movement didn't). So even if I click on the pawn only, the whiteBishop.noProjected() function still gets called which I don't want."
    }
]