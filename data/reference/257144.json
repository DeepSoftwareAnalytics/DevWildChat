[
    {
        "link": "https://stackoverflow.com/questions/49197666/c-dynamic-memory-best-practice",
        "document": "Working with a very outdated notion and limited understanding of C++.\n\nFirst of all, C++ does not report a failure to allocate memory by returning . It throws an exception, of type (which is derived from ).\n\nSecond, with the advent of C++11, using \"naked\" pointers like that is frowned upon, because they all-too-easily result in resource leaks when you forget to them, e.g. when an unexpected exception makes your pointer go out of scope.\n\nSo you really should use either std::shared_ptr<> or unique_ptr<>."
    },
    {
        "link": "https://reddit.com/r/cpp_questions/comments/122zh0v/memory_best_practices",
        "document": "I'm currently improving my C++ skills and have been reading about how the stack and heap memory work in C++.\n\nI was wondering which are in your opinion the best practices with this regards. Malloc, pointers, references, arrays,... when to use them and when to avoid them.\n\nHow to use the power of stack and heap memory in the best way possible."
    },
    {
        "link": "https://alexomegapy.com/post/pointers-in-c-memory-management-arrays-and-smart-pointers",
        "document": "In C++, pointers and arrays work well together, but arrays are not necessarily required when using pointers and vice versa. However, they are often used together due to their similar nature, as they use direct memory access; that is arrays use indexing to access elements, while pointers use memory addresses to access elements. Both are derived data types in C++ that have a lot in common (Rinkalktailor, 2024); a derived data type is a data type that is created or derived from the fundamental or built-in data types. In some cases, pointers can even replace arrays. However, if they are very closely related they are still different data types. Below is a table listing the similarities and differences between the two data types.\n\nint num1 = 10, num2 = 20; int* ptr1 = &num1; int* ptr2 = &num2; if (ptr1 != ptr2) { std::cout << \"The pointers point to different locations.\" << std::endl; } else { std::cout << \"The pointers point to the same location.\" << std::endl; } // The pointers point to different locations\n\n// Outputs the value of x (10) // Modifies the value of x through the pointer // Outputs the updated value of x (20)\n\nSmart pointers in C++ are also referred to as unique pointers (‘unique_ptr’). They automatically manage the dynamically allocated resources on the heap. They are just wrappers around regular raw pointers preventing errors such as forgetting to delete a pointer and causing a memory leak or accidentally deleting a pointer twice or in the wrong way (Pritamauddy, 2023). Additionally, a ‘unique_ptr’ does not share its raw pointer, meaning that it cannot be copied to another ‘unique_ptr’ (Whitney, 2021). Instead, it can only moved. This means that the ownership of the memory address of the values stored can be transferred from one ‘unique_ptr’ to another. For example:\n\nif (!ptr1) { std::cout << \"ptr1 is now empty.\"<< std::endl; } // No need to delete manually; unique_ptr automatically deletes the // resource when // it goes out of scope\n\nTo summarize, pointers offer flexibility and precise control over memory, making them a powerful tool for applications where memory usage management and manipulation are needed. Pointers and arrays work well together; arrays are not necessarily required when using pointers and vice versa. Nonetheless, they are similar as both are derived data types and use direct memory access. However, they handle memory allocation and how elements are accessed differently. Pointers and the values they point to can be manipulated using pointer arithmetic and the operators (*) and (&). This comes with risks that can be mitigated by using the smart pointers (‘unique_ptr’), which manage access to the heap, protecting it from errors."
    },
    {
        "link": "https://reddit.com/r/C_Programming/comments/udn4ca/what_are_good_projects_to_get_comfortable_with",
        "document": "I’ve quite a few projects, and I’ve learned quite a bit, but none have really forced me to use pointers.\n\nI’ve implemented malloc() and free() in my OS course, but implementing library functions lack the pazazz of implementing an NES"
    },
    {
        "link": "https://medium.com/@naseefcse/mastering-memory-management-in-modern-c-essential-techniques-for-high-performance-applications-b3dc1b66b9f0",
        "document": "In the ever-evolving landscape of C++ programming, efficient memory management stands as a cornerstone for crafting robust and high-performance applications. With the advent of modern C++ features, developers now have an array of powerful tools at their disposal to optimize memory usage and enhance overall application performance. In this article, we’ll delve into the essential techniques and best practices for memory management in modern C++, empowering developers to write cleaner, more efficient code that excels not only in performance but also in search engine rankings across platforms like Google, Bing, and Yahoo.\n\nUnderstanding Memory Management in C++: Memory management in C++ has traditionally relied on manual allocation and deallocation of memory using pointers and dynamic memory allocation operators like and . While this approach offers unparalleled flexibility, it also introduces the risk of memory leaks and other memory-related errors. However, with the advent of modern C++ features such as smart pointers and memory management utilities, developers can mitigate these risks while writing code that is not only safer but also more maintainable and concise.\n\nHarnessing the Power of Smart Pointers: Smart pointers, introduced in C++11, represent a paradigm shift in memory management. These intelligent wrappers automate memory allocation and deallocation, drastically reducing the likelihood of memory leaks and other common pitfalls associated with manual memory management. Types such as , , and offer varying levels of ownership semantics, enabling developers to express their intentions clearly and manage memory resources efficiently.\n\nSteering Clear of Manual Memory Management: While manual memory management using raw pointers remains feasible in C++, it is generally discouraged in modern codebases due to the inherent risks and complexities involved. Instead, leveraging smart pointers and container classes from the Standard Library, such as and , can simplify memory management and enhance code safety and readability.\n\nOptimizing Memory Usage: In addition to utilizing smart pointers and container classes, developers can optimize memory usage in C++ through techniques such as object pooling, memory reclamation, and custom allocators. These strategies can help reduce memory fragmentation, improve cache locality, and boost overall application performance, thereby making code more efficient and scalable.\n\nEfficient memory management lies at the heart of high-quality C++ development, enabling developers to create applications that not only perform optimally but also rank higher in search engine results. By embracing modern C++ features, avoiding manual memory management, and optimizing memory usage, developers can unlock the full potential of the language and elevate their code to new heights of performance and reliability.\n\nThrough the incorporation of pertinent keywords and the provision of valuable insights into memory management in modern C++, this article aims to capture the attention of developers seeking guidance on this critical aspect of C++ programming. With its informative content and SEO-friendly structure, this article is poised to rank prominently in search engine results on platforms like Google, Bing, and Yahoo, ensuring maximum visibility and engagement among the target audience."
    },
    {
        "link": "https://en.cppreference.com/w/cpp/algorithm/max",
        "document": "Returns the greater of the given values.\n\nReturns the greater of and .\n\nUses to compare the values.\n\nUse the comparison function to compare the values.\n\nReturns the greatest of the values in initializer list .\n\nUses to compare the values.\n\nUse the comparison function to compare the values.\n\ninitializer list with the values to compare comparison function object (i.e. an object that satisfies the requirements of ) which returns if is less than .\n\n The signature of the comparison function should be equivalent to the following: While the signature does not need to have const&, the function must not modify the objects passed to it and must be able to accept all values of type (possibly const) and regardless of value category (thus, Type1& is not allowed, nor is Type1 unless for a move is equivalent to a copy(since C++11)).\n\n The types Type1 and Type2 must be such that an object of type T can be implicitly converted to both of them.\n\nThe greater of and . If they are equivalent, returns .\n\nThe greatest value in . If several values are equivalent to the greatest, returns the leftmost one.\n\nExactly one comparison using .\n\nExactly one application of the comparison function .\n\nExactly applications of the comparison function .\n\nCapturing the result of by reference produces a dangling reference if one of the parameters is a temporary and that parameter is returned:\n\nThe following behavior-changing defect reports were applied retroactively to previously published C++ standards."
    },
    {
        "link": "https://geeksforgeeks.org/stdmax-in-cpp",
        "document": "The std::max() is the built-in function in C++ used for finding the maximum among two or more elements passed to it as arguments. It is defined inside <algorithm> header file. In this article, we will learn how to use std::max() function in C++.\n\nThe std::max() can be used in the following ways:\n\nWe can use std::max() function to find the larger among two values. We can also compare the two values using different parameters by defining the custom comparison function.\n• a : First value to be compared.\n• b : Second value to be compared.\n• comp: Binary function that accepts two values and returns a value convertible to bool. It is optional and by default set to return true if the first element is larger than second.\n• None Returns the larger of the two values.\n• None If both are equal, returns the first value.\n\nThe function is essential for finding the maximum value between two values.\n\nExample: Finding Maximum Among Two Numbers using std::max()\n\nFind the Maximum Among the Multiple Values\n\nThe std::max() function can also find the maximum value between more than two values. We have to pass the values enclosed in { } braces and separated by a comma (initializer list).\n• comp: Optional comparator function to change the way of comparison.\n• None Returns the largest value among the given lists.\n• None If all are equal, return the first value.\n\nExample: Finding Largest Value Among the List of Integers\n\nTime Complexity: O(n), where n is the number of elements. \n\nAuxiliary Space: O(1)"
    },
    {
        "link": "https://en.cppreference.com/w/cpp/standard_library",
        "document": "The C++ standard library provides a wide range of facilities that are usable in standard C++.\n\nThe language support library provides components that are required by certain parts of the C++ language, such as memory allocation (new/delete) and exception processing.\n\nThe diagnostics library provides a consistent framework for reporting errors in a C++ program, including predefined exception classes.\n\nThe memory management library provides components for memory management, including smart pointers and scoped allocator(since C++11).\n\nThe general utilities library includes components used by other library elements, such as a predefined storage allocator for dynamic storage management, and components used as infrastructure in C++ programs, such as tuples and(since C++11) function wrappers.\n\nThe containers, iterators, ranges(since C++20), and algorithms libraries provide a C++ program with access to a subset of the most widely used algorithms and data structures.\n\nThe strings library provides support for manipulating text represented as homogeneous sequences of following types: char, char8_t(since C++20), char16_t, char32_t(since C++11), wchar_t, and any other character-like types.\n\nThe text processing library provides regular expression matching and searching(since C++11), utilities for text formatting(since C++20) and identifying text encodings(since C++26), and localization facilities.\n\nThe numerics library provides numeric algorithms and complex number components that extend support for numeric processing. The valarray component provides support for n-at-a-time processing, potentially implemented as parallel operations on platforms that support such processing. The random number component provides facilities for generating pseudo-random numbers.(since C++11)\n\nThe time library provides generally useful time utilities.\n\nThe input/output library provides the iostream components that are the primary mechanism for C++ program input and output. They can be used with other elements of the library, particularly strings, locales, and iterators.\n\nThe C++ standard library provides definitions for the entities and macros described in the synopses of the C++ standard library headers, unless otherwise specified.\n\nAll library entities except operator new and operator delete are defined within the namespace std or namespaces nested within namespace std (except the entities for the C standard library facilities, see below). It is unspecified whether names declared in a specific namespace are declared directly in that namespace or in an inline namespace inside that namespace.(since C++11)\n\nEach element of the C++ standard library is declared or defined (as appropriate) in a header. A header is not necessarily a source file, nor are the sequences delimited by and in header names necessarily valid source file names.\n\nThe C++ standard library provides the C++ library headers and additional C++ headers for C library facilities (see “headers” page for descriptions):\n\nA freestanding implementation has an implementation-defined set of headers, see here for the minimal requirement on the set of headers.\n\nThe C++ standard library also makes available the facilities of the C standard library, suitably adjusted to ensure static type safety. The descriptions of many library functions rely on the C standard library for the semantics of those functions.\n\nIn some cases, the signatures specified in standard C++ may be different from the signatures in the C standard library, and additional overloads may be declared, but the behavior and the preconditions (including those implied by C's restrict)(since C++17) are the same unless otherwise stated.\n\nFor compatibility with the C standard library, the C++ standard library provides the C headers listed below. The intended use of these headers is for interoperability only. It is possible that C++ source files need to include one of these headers in order to be valid ISO C. Source files that are not intended to also be valid ISO C should not use any of the C headers. See here for descriptions.\n\nExcept otherwise noted, the contents of each header is the same as that of the corresponding header as specified in the C standard library. In the C++ standard library, however, the declarations (except for names which are defined as macros in C) are within namespace scope of the namespace std. It is unspecified whether these names (including any overloads added) are first declared within the global namespace scope and are then injected into namespace std by explicit using-declarations.\n\nNames which are defined as macros in C ( , , , , and ) must be defined as macros in the C++ standard library, even if C grants license for implementation as functions.\n\nNames that are defined as functions in C must be defined as functions in the C++ standard library. This disallows the practice, allowed in C, of providing a masking macro in addition to the function prototype. The only way to achieve equivalent inline behavior in C++ is to provide a definition as an extern inline function.\n\nIdentifiers that are keywords or operators in C++ cannot be defined as macros in C++ standard library headers. In particular, including the standard header has no effect.\n\nNames associated with safe functions in standard C\n\nIf any C++ header is included, it is implementation-defined whether any of the following C standard Annex K names is declared in the global namespace (none of them is declared in namespace std):\n\nThe entities in the C++ standard library are defined in headers, whose contents are made available to a translation unit when it contains the appropriate preprocessing directive.\n\nA translation unit may include library headers in any order. Each may be included more than once, with no effect different from being included exactly once, except that the effect of including either or depends each time on the lexically current definition of NDEBUG.\n\nA translation unit can only include a header outside of any declaration or definition, and lexically before the first reference in that translation unit to any of the entities declared in that header. No diagnostic is required.\n\nEntities in the C++ standard library have storage duration#external linkage. Unless otherwise specified, objects and functions have the default extern \"C++\" linkage.\n\nWhether a name from the C standard library declared with external linkage has extern \"C\" or extern \"C++\" linkage is implementation-defined. The C++ standard recommends using extern \"C++\" in this case.\n\nObjects and functions defined in the library and required by a C++ program are included in the program prior to program startup.\n\nA C++ header must provide declarations and definitions that appear in\n• the synopsis of that header, or\n• the synopsis of another header which is appeared to be included in the synopsis of that header.\n\nFor types and macros defined in multiple headers (such as ), including any number of these headers in any order never violates the one definition rule.\n\nUnless otherwise specified, all object-like macros defined by the C standard library that expand to integral constant expressions can be used in preprocessing directives.\n\nCalling a standard library non-member function signature always results in actually calling that function. Therefore a conforming standard library implementation cannot define additional non-member functions that may be called by a valid C++ program.\n\nNon-member function signatures are never declared with additional default arguments.\n\nUnless otherwise specified, calls made by functions in the standard library to non-operator, non-member functions do not use functions from another namespace which are found through argument-dependent name lookup.\n\nFor each friend declaration of a function (template) within a class (template) definition, no other declaration is provided for that function (template).\n\nFor each class defined in the C++ standard library required to be derived from another class defined in the C++ standard library,\n• the base class must be virtual if it is specified as ,\n• the base class cannot be virtual if it is not specified as , and\n• unless otherwise specified, types with distinct names shall be distinct types.\n\nIf a function defined in the C++ standard library is specified to throw an exception (in a particular situation) of a given type, the exception thrown can only have that type or a type derived from that type so that an exception handler for the base type can catch it.\n\nFunctions from the C standard library can only throw exceptions when such a function calls a program-supplied function that throws an exception ( and meet this condition).\n\nDestructor operations defined in the C++ standard library never throw exceptions. Every destructor in the C++ standard library behaves as if it had a non-throwing exception specification.\n\nIt is unspecified whether any member or non-member functions in the C++ standard library are defined as inline.\n\nFor a non-virtual C++ standard library member function, a different set of member function signatures can be declared, provided that any call to that member function that would select an overload from the given set of declarations behaves as if that overload was selected. This allows, for instance:\n• replacing a member function with default arguments with two or more member functions with equivalent behavior, or\n\nUnless otherwise specified, it is implementation-defined which functions in the C++ standard library may be recursively reentered.\n\nIt is unspecified whether any function signature or class in the C++ standard library is a friend of another class in the C++ standard library.\n\nThe names and global function signatures described here are reserved to the implementation.\n\nAny class in the C++ standard library can be derived from a class with a name reserved to the implementation. If a class defined in the C++ standard library is required to be derived from other classes in the C++ standard library, that class can be derived directly from the required base or indirectly through a hierarchy of base classes with names reserved to the implementation.\n\nIf a function defined in the C++ standard library is not specified to throw an exception but does not have a non-throwing exception specification, the exception thrown is implementation-defined, but its type should be std::exception or any type derived from std::exception.\n\nThe exception specification for a non-virtual function can be strengthened by adding a non-throwing exception specification.\n\nThe following behavior-changing defect reports were applied retroactively to previously published C++ standards."
    },
    {
        "link": "https://stackoverflow.com/questions/4234004/is-maxa-b-defined-in-stdlib-h-or-not",
        "document": "Any C library which defines a macro named in its standard headers is broken beyond imagination. Fortunately, an easy workaround if you need to support such platforms is to (and any other problematic macros it defines) after including the system headers and before any of your own headers/code.\n\nNote that everyone else is saying to wrap your definition in . This is not a good idea. Defining in a system header is an indication that the implementor was incompetent, and it's possible that certain versions of the environment have incorrect macros (for example, ones which do not properly protect arguments with parentheses, but I've even seen a macro that was incorrectly performing instead of at least once in my life!). Just use and be safe.\n\nAs for why it's so broken for to define , the C standard is very specific about what names are reserved for the application and what names are reserved for standard functions and/or internal use by the implementation. There are very good reasons for this. Defining macro names in system headers that could clash with variable/function names used in the application program is dangerous. In the best case it leads to compile-time errors with an obvious cause, but in other cases it can cause very strange behavior that's hard to debug. In any case it makes it very difficult to write portable code because you never know what names will already be taken by the library."
    },
    {
        "link": "https://en.wikipedia.org/wiki/C%2B%2B11",
        "document": "2011 edition of the C++ programming language standard\n\nC++11 is a version of a joint technical standard, ISO/IEC 14882, by the International Organization for Standardization (ISO) and International Electrotechnical Commission (IEC), for the C++ programming language. C++11 replaced the prior version of the C++ standard, named C++03,[1] and was later replaced by C++14. The name follows the tradition of naming language versions by the publication year of the specification, though it was formerly named C++0x because it was expected to be published before 2010.[2]\n\nAlthough one of the design goals was to prefer changes to the libraries over changes to the core language,[3] C++11 does make several additions to the core language. Areas of the core language that were significantly improved include multithreading support, generic programming support, uniform initialization, and performance. Significant changes were also made to the C++ Standard Library, incorporating most of the C++ Technical Report 1 (TR1) libraries, except the library of mathematical special functions.[4]\n\nC++11 was published as ISO/IEC 14882:2011[5] in September 2011 and is available for a fee. The working draft most similar to the published C++11 standard is N3337, dated 16 January 2012;[6] it has only editorial corrections from the C++11 standard.[7]\n\nC++11 is fully supported by Clang 3.3 and later.[8] C++11 is fully supported by GNU Compiler Collection (GCC) 4.8.1 and later.[9]\n\nThe design committee attempted to stick to a number of goals in designing C++11:\n• Prefer introducing new features via the standard library, rather than extending the core language\n• Improve C++ to facilitate systems and library design, rather than introduce new features useful only to specific applications\n• Increase performance and the ability to work directly with hardware\n• Make C++ easy to teach and to learn without removing any utility needed by expert programmers\n\nAttention to beginners is considered important, because most computer programmers will always be such, and because many beginners never widen their knowledge, limiting themselves to work in aspects of the language in which they specialize.[2][3]\n\nOne function of the C++ committee is the development of the language core. Areas of the core language that were significantly improved include multithreading support, generic programming support, uniform initialization, and performance.\n\nThese language features primarily exist to provide some kind of runtime performance benefit, either of memory or of computing speed.[citation needed]\n\nIn C++03 (and before), temporaries (termed \"rvalues\", as they often lie on the right side of an assignment) were intended to never be modifiable — just as in C — and were considered to be indistinguishable from types; nevertheless, in some cases, temporaries could have been modified, a behavior that was even considered to be a useful loophole.[10] C++11 adds a new non-const reference type called an rvalue reference, identified by . This refers to temporaries that are permitted to be modified after they are initialized, for the purpose of allowing \"move semantics\".\n\nA chronic performance problem with C++03 is the costly and unneeded deep copies that can happen implicitly when objects are passed by value. To illustrate the issue, consider that an is, internally, a wrapper around a C-style array with a defined size. If an temporary is created or returned from a function, it can be stored only by creating a new and copying all the rvalue's data into it. Then the temporary and all its memory is destroyed. (For simplicity, this discussion neglects the return value optimization.)\n\nIn C++11, a move constructor of that takes an rvalue reference to an can copy the pointer to the internal C-style array out of the rvalue into the new , then set the pointer inside the rvalue to null. Since the temporary will never again be used, no code will try to access the null pointer, and because the pointer is null, its memory is not deleted when it goes out of scope. Hence, the operation not only forgoes the expense of a deep copy, but is safe and invisible.\n\nRvalue references can provide performance benefits to existing code without needing to make any changes outside the standard library. The type of the returned value of a function returning an temporary does not need to be changed explicitly to to invoke the move constructor, as temporaries are considered rvalues automatically. (However, if is a C++03 version without a move constructor, then the copy constructor will be invoked with a , incurring a significant memory allocation.)\n\nFor safety reasons, some restrictions are imposed. A named variable will never be considered to be an rvalue even if it is declared as such. To get an rvalue, the function template should be used. Rvalue references can also be modified only under certain circumstances, being intended to be used primarily with move constructors.\n\nDue to the nature of the wording of rvalue references, and to some modification to the wording for lvalue references (regular references), rvalue references allow developers to provide perfect function forwarding. When combined with variadic templates, this ability allows for function templates that can perfectly forward arguments to another function that takes those particular arguments. This is most useful for forwarding constructor parameters, to create factory functions that will automatically call the correct constructor for those particular arguments. This is seen in the emplace_back set of the C++ standard library methods.\n\nC++ has always had the concept of constant expressions. These are expressions such as that will always yield the same results, at compile time and at runtime. Constant expressions are optimization opportunities for compilers, and compilers frequently execute them at compile time and hardcode the results in the program. Also, in several places, the C++ specification requires using constant expressions. Defining an array requires a constant expression, and enumerator values must be constant expressions.\n\nHowever, a constant expression has never been allowed to contain a function call or object constructor. So a piece of code as simple as this is invalid:\n\nThis was not valid in C++03, because is not a constant expression. A C++03 compiler has no way of knowing if actually is constant at runtime. In theory, this function could affect a global variable, call other non-runtime constant functions, etc.\n\nC++11 introduced the keyword , which allows the user to guarantee that a function or object constructor is a compile-time constant.[11] The above example can be rewritten as follows:\n\nThis allows the compiler to understand, and verify, that is a compile-time constant.\n\nUsing on a function imposes some limits on what that function can do. First, the function must have a non-void return type. Second, the function body cannot declare variables or define new types. Third, the body may contain only declarations, null statements and a single return statement. There must exist argument values such that, after argument substitution, the expression in the return statement produces a constant expression.\n\nBefore C++11, the values of variables could be used in constant expressions only if the variables are declared const, have an initializer which is a constant expression, and are of integral or enumeration type. C++11 removes the restriction that the variables must be of integral or enumeration type if they are defined with the keyword:\n\nSuch data variables are implicitly const, and must have an initializer which must be a constant expression.\n\nTo construct constant expression data values from user-defined types, constructors can also be declared with . A constructor's function body can contain only declarations and null statements, and cannot declare variables or define types, as with a function. There must exist argument values such that, after argument substitution, it initializes the class's members with constant expressions. The destructors for such types must be trivial.\n\nThe copy constructor for a type with any constructors should usually also be defined as a constructor, to allow objects of the type to be returned by value from a constexpr function. Any member function of a class, such as copy constructors, operator overloads, etc., can be declared as , so long as they meet the requirements for constexpr functions. This allows the compiler to copy objects at compile time, perform operations on them, etc.\n\nIf a constexpr function or constructor is called with arguments which aren't constant expressions, the call behaves as if the function were not constexpr, and the resulting value is not a constant expression. Likewise, if the expression in the return statement of a constexpr function does not evaluate to a constant expression for a given invocation, the result is not a constant expression.\n\ndiffers from , introduced in C++20, in that the latter must always produce a compile time constant, while does not have this restriction.\n\nIn C++03, a class or struct must follow a number of rules for it to be considered a plain old data (POD) type. Types that fit this definition produce object layouts that are compatible with C, and they could also be initialized statically. The C++03 standard has restrictions on what types are compatible with C or can be statically initialized despite there being no technical reason a compiler couldn't accept the program; if someone were to create a C++03 POD type and add a non-virtual member function, this type would no longer be a POD type, could not be statically initialized, and would be incompatible with C despite no change to the memory layout.\n\nC++11 relaxed several of the POD rules, by dividing the POD concept into two separate concepts: trivial and standard-layout.\n\nA type that is trivial can be statically initialized. It also means that it is valid to copy data around via , rather than having to use a copy constructor. The lifetime of a trivial type begins when its storage is defined, not when a constructor completes.\n\nA trivial class or struct is defined as one that:\n• Has a trivial default constructor. This may use the default constructor syntax ( ).\n• Has trivial copy and move constructors, which may use the default syntax.\n• Has trivial copy and move assignment operators, which may use the default syntax.\n• Has a trivial destructor, which must not be virtual.\n\nConstructors are trivial only if there are no virtual member functions of the class and no virtual base classes. Copy/move operations also require all non-static data members to be trivial.\n\nA type that is standard-layout means that it orders and packs its members in a way that is compatible with C. A class or struct is standard-layout, by definition, provided:\n• It has no virtual functions\n• It has no virtual base classes\n• All its non-static data members have the same access control (public, private, protected)\n• All its non-static data members, including any in its base classes, are in the same one class in the hierarchy\n• The above rules also apply to all the base classes and to all non-static data members in the class hierarchy\n• It has no base classes of the same type as the first defined non-static data member\n\nA class/struct/union is considered POD if it is trivial, standard-layout, and all of its non-static data members and base classes are PODs.\n\nBy separating these concepts, it becomes possible to give up one without losing the other. A class with complex move and copy constructors may not be trivial, but it could be standard-layout and thus interoperate with C. Similarly, a class with public and private non-static data members would not be standard-layout, but it could be trivial and thus -able.\n\nIn C++03, the compiler must instantiate a template whenever a fully specified template is encountered in a translation unit. If the template is instantiated with the same types in many translation units, this can dramatically increase compile times. There is no way to prevent this in C++03, so C++11 introduced extern template declarations, analogous to extern data declarations.\n\nC++03 has this syntax to oblige the compiler to instantiate a template:\n\nC++11 now provides this syntax:\n\nwhich tells the compiler not to instantiate the template in this translation unit.\n\nThese features exist for the primary purpose of making the language easier to use. These can improve type safety, minimize code repetition, make erroneous code less likely, etc.\n\nC++03 inherited the initializer-list feature from C. A struct or array is given a list of arguments in braces, in the order of the members' definitions in the struct. These initializer-lists are recursive, so an array of structs or struct containing other structs can use them.\n\nThis is very useful for static lists, or initializing a struct to some value. C++ also provides constructors to initialize an object, but they are often not as convenient as the initializer list. However, C++03 allows initializer-lists only on structs and classes that conform to the Plain Old Data (POD) definition; C++11 extends initializer-lists, so they can be used for all classes including standard containers like .\n\nC++11 binds the concept to a template, called . This allows constructors and other functions to take initializer-lists as parameters. For example:\n\nThis allows to be constructed from a sequence of integers, such as:\n\nThis constructor is a special kind of constructor, called an initializer-list-constructor. Classes with such a constructor are treated specially during uniform initialization (see below)\n\nThe template class is a first-class C++11 standard library type. They can be constructed statically by the C++11 compiler via use of the syntax without a type name in contexts where such braces will deduce to an , or by explicitly specifying the type like (and so on for other varieties of construction syntax).\n\nThe list can be copied once constructed, which is cheap and will act as a copy-by-reference (the class is typically implemented as a pair of begin/end pointers). An is constant: its members cannot be changed once it is created, and nor can the data in those members be changed (which rules out moving from them, requiring copies into class members, etc.).\n\nAlthough its construction is specially treated by the compiler, an is a real type, and so it can be used in other places besides class constructors. Regular functions can take typed s as arguments. For example:\n\nExamples of this in the standard library include the and templates taking s of numeric type.\n\nStandard containers can also be initialized in these ways:\n\nC++03 has a number of problems with initializing types. Several ways to do this exist, and some produce different results when interchanged. The traditional constructor syntax, for example, can look like a function declaration, and steps must be taken to ensure that the compiler's most vexing parse rule will not mistake it for such. Only aggregates and POD types can be initialized with aggregate initializers (using ).\n\nC++11 provides a syntax that allows for fully uniform type initialization that works on any object. It expands on the initializer list syntax:\n\nThe initialization of behaves exactly as though it were aggregate-initialization. That is, each data member of an object, in turn, will be copy-initialized with the corresponding value from the initializer-list. Implicit type conversion will be used where needed. If no conversion exists, or only a narrowing conversion exists, the program is ill-formed. The initialization of invokes the constructor.\n\nOne can also do this:\n\nUniform initialization does not replace constructor syntax, which is still needed at times. If a class has an initializer list constructor ( ), then it takes priority over other forms of construction, provided that the initializer list conforms to the sequence constructor's type. The C++11 version of has an initializer list constructor for its template type. Thus this code:\n\nwill call the initializer list constructor, not the constructor of that takes a single size parameter and creates the vector with that size. To access the latter constructor, the user will need to use the standard constructor syntax directly.\n\nIn C++03 (and C), to use a variable, its type must be specified explicitly. However, with the advent of template types and template metaprogramming techniques, the type of something, particularly the well-defined return value of a function, may not be easily expressed. Thus, storing intermediates in variables is difficult, possibly needing knowledge of the internals of a given metaprogramming library.\n\nC++11 allows this to be mitigated in two ways. First, the definition of a variable with an explicit initialization can use the keyword.[12][13] This creates a variable of the specific type of the initializer:\n\nThe type of is simply whatever the particular template function override of returns for those particular arguments. This type is easily determined procedurally by the compiler as part of its semantic analysis duties, but is not easy for the user to determine upon inspection. The type of is also well-defined, but it is easier for the user to determine. It is an , which is the same type as the integer literal.\n\nThis use of the keyword in C++ re-purposes the semantics of this keyword, which was originally used in the typeless predecessor language B in a related role of denoting an untyped automatic variable definition.\n\nFurther, the keyword can be used to determine the type of expression at compile-time. For example:\n\nThis is more useful in conjunction with , since the type of auto variable is known only to the compiler. However, can also be very useful for expressions in code that makes heavy use of operator overloading and specialized types.\n\nis also useful for reducing the verbosity of the code. For instance, instead of writing\n\nthe programmer can use the shorter\n\nwhich can be further compacted since \"myvec\" implements begin/end iterators:\n\nThis difference grows as the programmer begins to nest containers, though in such cases s are a good way to decrease the amount of code.\n\nThe type denoted by can be different from the type deduced by .\n\nC++11 extends the syntax of the statement to allow for easy iteration over a range of elements:\n\nThis form of , called the “range-based for”, will iterate over each element in the list. It will work for C-style arrays, initializer lists, and any type that has and functions defined for it that return iterators. All the standard library containers that have begin/end pairs will work with the range-based for statement.\n\nC++11 provides the ability to create anonymous functions, called lambda functions.[14] These are defined as follows:\n\nThe return type ( in this example) can be omitted as long as all expressions return the same type. A lambda can optionally be a closure.\n\nStandard C function declaration syntax was perfectly adequate for the feature set of the C language. As C++ evolved from C, it kept the basic syntax and extended it where needed. However, as C++ grew more complex, it exposed several limits, especially regarding template function declarations. For example, in C++03 this is invalid:\n\nThe type is whatever the addition of types and will produce. Even with the aforementioned C++11 functionality of , this is not possible:\n\nThis is not valid C++ because and have not yet been defined; they will not be valid identifiers until after the parser has parsed the rest of the function prototype.\n\nTo work around this, C++11 introduced a new function declaration syntax, with a trailing-return-type:[15]\n\nThis syntax can be used for more mundane function declarations and definitions:\n\nThe use of the “auto” keyword in this case is just part of the syntax and does not perform automatic type deduction in C++11. However, starting with C++14, the trailing return type can be removed entirely and the compiler will deduce the return type automatically.[16]\n\nIn C++03, constructors of a class are not allowed to call other constructors in an initializer list of that class. Each constructor must construct all of its class members itself or call a common member function, as follows:\n\nConstructors for base classes cannot be directly exposed to derived classes; each derived class must implement constructors even if a base class constructor would be appropriate. Non-constant data members of classes cannot be initialized at the site of the declaration of those members. They can be initialized only in a constructor.\n\nC++11 provides solutions to all of these problems.\n\nC++11 allows constructors to call other peer constructors (termed delegation). This allows constructors to utilize another constructor's behavior with a minimum of added code. Delegation has been used in other languages e.g., Java and Objective-C.\n\nThis syntax is as follows:\n\nIn this case, the same effect could have been achieved by making a default parameter. The new syntax, however, allows the default value (42) to be expressed in the implementation rather than the interface — a benefit to maintainers of library code since default values for function parameters are “baked in” to call sites, whereas constructor delegation allows the value to be changed without recompilation of the code using the library.\n\nThis comes with a caveat: C++03 considers an object to be constructed when its constructor finishes executing, but C++11 considers an object constructed once any constructor finishes execution. Since multiple constructors will be allowed to execute, this will mean that each delegating constructor will be executing on a fully constructed object of its own type. Derived class constructors will execute after all delegation in their base classes is complete.\n\nFor base-class constructors, C++11 allows a class to specify that base class constructors will be inherited. Thus, the C++11 compiler will generate code to perform the inheritance and the forwarding of the derived class to the base class. This is an all-or-nothing feature: either all of that base class's constructors are forwarded or none of them are. Also, an inherited constructor will be shadowed if it matches the signature of a constructor of the derived class, and restrictions exist for multiple inheritance: class constructors cannot be inherited from two classes that use constructors with the same signature.\n\nThe syntax is as follows:\n\nFor member initialization, C++11 allows this syntax:\n\nAny constructor of the class will initialize with 5, if the constructor does not override the initialization with its own. So the above empty constructor will initialize as the class definition states, but the constructor that takes an int will initialize it to the given parameter.\n\nIt can also use constructor or uniform initialization, instead of the assignment initialization shown above.\n\nIn C++03, it is possible to accidentally create a new virtual function, when one intended to override a base class function. For example:\n\nSuppose the is intended to replace the base class version. But instead, because it has a different signature, it creates a second virtual function. This is a common problem, particularly when a user goes to modify the base class.\n\nC++11 provides syntax to solve this problem.\n\nThe special identifier means that the compiler will check the base class(es) to see if there is a virtual function with this exact signature. And if there is not, the compiler will indicate an error.\n\nC++11 also adds the ability to prevent inheriting from classes or simply preventing overriding methods in derived classes. This is done with the special identifier . For example:\n\nIn this example, the statement declares a new virtual function, but it also prevents derived classes from overriding it. It also has the effect of preventing derived classes from using that particular function name and parameter combination.\n\nNeither nor are language keywords. They are technically identifiers for declarator attributes:\n• they gain special meaning as attributes only when used in those specific trailing contexts (after all type specifiers, access specifiers, member declarations (for struct, class and enum types) and declarator specifiers, but before initialization or code implementation of each declarator in a comma-separated list of declarators);\n• they do not alter the declared type signature and do not declare or override any new identifier in any scope;\n• the recognized and accepted declarator attributes may be extended in future versions of C++ (some compiler-specific extensions already recognize added declarator attributes, to provide code generation options or optimization hints to the compiler, or to generate added data into the compiled code, intended for debuggers, linkers, and deployment of the compiled code, or to provide added system-specific security attributes, or to enhance reflective programming (reflection) abilities at runtime, or to provide added binding information for interoperability with other programming languages and runtime systems; these extensions may take parameters between parentheses after the declarator attribute identifier; for ANSI conformance, these compiler-specific extensions should use the double underscore prefix convention).\n• In any other location, they can be valid identifiers for new declarations (and later use if they are accessible).\n\nFor the purposes of this section and this section alone, every occurrence of \" \" is meant as \"a constant expression which evaluates to , which is of type int\". In reality, the constant expression can be of any integral type.\n\nSince the dawn of C in 1972, the constant has had the double role of constant integer and null pointer constant. The ambiguity inherent in the double meaning of was dealt with in C by using the preprocessor macro , which commonly expands to either or . C++ forbids implicit conversion from to other pointer types, thus removing the benefit of casting to . As a consequence, only is allowed as a null pointer constant. This interacts poorly with function overloading:\n\nIf is defined as (which is usually the case in C++), the statement will call , which is almost certainly not what the programmer intended, and not what a superficial reading of the code suggests.\n\nC++11 corrects this by introducing a new keyword to serve as a distinguished null pointer constant: . It is of type , which is implicitly convertible and comparable to any pointer type or pointer-to-member type. It is not implicitly convertible or comparable to integral types, except for . While the original proposal specified that an rvalue of type should not be convertible to , the core language working group decided that such a conversion would be desirable, for consistency with regular pointer types. The proposed wording changes were unanimously voted into the Working Paper in June 2008.[1] A similar proposal was also brought to the C standard working group and was accepted for inclusion in C23.[17]\n\nIn C++03, enumerations are not type-safe. They are effectively integers, even when the enumeration types are distinct. This allows the comparison between two enum values of different enumeration types. The only safety that C++03 provides is that an integer or a value of one enum type does not convert implicitly to another enum type. Further, the underlying integral type is implementation-defined; code that depends on the size of the enumeration is thus non-portable. Lastly, enumeration values are scoped to the enclosing scope. Thus, it is not possible for two separate enumerations in the same scope to have matching member names.\n\nC++11 allows a special classification of enumeration that has none of these issues. This is expressed using the ( is also accepted as a synonym) declaration:\n\nThis enumeration is type-safe. Enum class values are not implicitly converted to integers. Thus, they cannot be compared to integers either (the expression gives a compile error).\n\nThe underlying type of enum classes is always known. The default type is ; this can be overridden to a different integral type as can be seen in this example:\n\nWith old-style enumerations the values are placed in the outer scope. With new-style enumerations they are placed within the scope of the enum class name. So in the above example, is undefined, but is defined.\n\nThere is also a transitional syntax to allow old-style enumerations to provide explicit scoping, and the definition of the underlying type:\n\nIn this case the enumerator names are defined in the enumeration's scope ( ), but for backwards compatibility they are also placed in the enclosing scope.\n\nForward-declaring enums is also possible in C++11. Formerly, enum types could not be forward-declared because the size of the enumeration depends on the definition of its members. As long as the size of the enumeration is specified either implicitly or explicitly, it can be forward-declared:\n\nC++03's parser defines “ ” as the right shift operator or stream extraction operator in all cases. However, with nested template declarations, there is a tendency for the programmer to neglect to place a space between the two right angle brackets, thus causing a compiler syntax error.\n\nC++11 improves the specification of the parser so that multiple right angle brackets will be interpreted as closing the template argument list where it is reasonable. This can be overridden by using parentheses around parameter expressions using the “ ”, “ ” or “ ” binary operators:\n\nC++98 added the keyword as a modifier on constructors to prevent single-argument constructors from being used as implicit type conversion operators. However, this does nothing for actual conversion operators. For example, a smart pointer class may have an to allow it to act more like a primitive pointer: if it includes this conversion, it can be tested with (which would be true if the pointer was non-null and false otherwise). However, this allows other, unintended conversions as well. Because C++ is defined as an arithmetic type, it can be implicitly converted to integral or even floating-point types, which allows for mathematical operations that are not intended by the user.\n\nIn C++11, the keyword can now be applied to conversion operators. As with constructors, it prevents using those conversion functions in implicit conversions. However, language contexts that specifically need a Boolean value (the conditions of if-statements and loops, and operands to the logical operators) count as explicit conversions and can thus use a bool conversion operator.\n\nFor example, this feature solves cleanly the safe bool issue.\n\nIn C++03, it is possible to define a typedef only as a synonym for another type, including a synonym for a template specialization with all actual template arguments specified. It is not possible to create a typedef template. For example:\n\nThis will not compile.\n\nC++11 adds this ability with this syntax:\n\nThe syntax can also be used as type aliasing in C++11:\n\nIn C++03, there are restrictions on what types of objects can be members of a . For example, unions cannot contain any objects that define a non-trivial constructor or destructor. C++11 lifts some of these restrictions.[2]\n\nIf a member has a non trivial special member function, the compiler will not generate the equivalent member function for the and it must be manually defined.\n\nThis is a simple example of a union permitted in C++11:\n\nThe changes will not break any existing code since they only relax current rules.\n\nThese features allow the language to do things that were formerly impossible, exceedingly verbose, or needed non-portable libraries.\n\nIn C++11, templates can take variable numbers of template parameters. This also allows the definition of type-safe variadic functions.\n\nC++03 offers two kinds of string literals. The first kind, contained within double quotes, produces a null-terminated array of type . The second kind, defined as , produces a null-terminated array of type , where is a wide-character of undefined size and semantics. Neither literal type offers support for string literals with UTF-8, UTF-16, or any other kind of Unicode encodings.\n\nC++11 supports three Unicode encodings: UTF-8, UTF-16, and UTF-32. The definition of the type has been modified to explicitly express that it is at least the size needed to store an eight-bit coding of UTF-8, and large enough to contain any member of the compiler's basic execution character set. It was formerly defined as only the latter in the C++ standard itself, then relying on the C standard to guarantee at least 8 bits. Furthermore, C++11 adds two new character types: and . These are designed to store UTF-16 and UTF-32 respectively.\n\nCreating string literals for each of the supported encodings can be done thus:\n\nThe type of the first string is the usual . The type of the second string is (note lower case 'u' prefix). The type of the third string is (upper case 'U' prefix).\n\nWhen building Unicode string literals, it is often useful to insert Unicode code points directly into the string. To do this, C++11 allows this syntax:\n\nThe number after the is a hexadecimal number; it does not need the usual prefix. The identifier represents a 16-bit Unicode code point; to enter a 32-bit code point, use and a 32-bit hexadecimal number. Only valid Unicode code points can be entered. For example, code points on the range U+D800–U+DFFF are forbidden, as they are reserved for surrogate pairs in UTF-16 encodings.\n\nIt is also sometimes useful to avoid escaping strings manually, particularly for using literals of XML files, scripting languages, or regular expressions. C++11 provides a raw string literal:\n\nIn the first case, everything between the and the is part of the string. The and characters do not need to be escaped. In the second case, the starts the string, and it ends only when is reached. The string can be any string up to 16 characters in length, including the empty string. This string cannot contain spaces, control characters, , , or the character. Using this delimiter string, the user can have the sequence within raw string literals. For example, is equivalent to .\n\nRaw string literals can be combined with the wide literal or any of the Unicode literal prefixes:\n\nC++03 provides a number of literals. The characters are a literal that is resolved by the compiler as a type with the value of 12.5. However, the addition of the suffix , as in , creates a value of type that contains the value 12.5. The suffix modifiers for literals are fixed by the C++ specification, and C++03 code cannot create new literal modifiers.\n\nBy contrast, C++11 enables the user to define new kinds of literal modifiers that will construct objects based on the string of characters that the literal modifies.\n\nTransformation of literals is redefined into two distinct phases: raw and cooked. A raw literal is a sequence of characters of some specific type, while the cooked literal is of a separate type. The C++ literal , as a raw literal, is this sequence of characters , , , . As a cooked literal, it is the integer 1234. The C++ literal in raw form is , , , while in cooked form it is the integer 10.\n\nLiterals can be extended in both raw and cooked forms, with the exception of string literals, which can be processed only in cooked form. This exception is due to the fact that strings have prefixes that affect the specific meaning and type of the characters in question.\n\nAll user-defined literals are suffixes; defining prefix literals is not possible. All suffixes starting with any character except underscore ( ) are reserved by the standard. Thus, all user-defined literals must have suffixes starting with an underscore ( ).[18]\n\nUser-defined literals processing the raw form of the literal are defined via a literal operator, which is written as . An example follows:\n\nThe assignment statement executes the code defined by the user-defined literal function. This function is passed as a C-style string, so it has a null terminator.\n\nAn alternative mechanism for processing integer and floating point raw literals is via a variadic template:\n\nThis instantiates the literal processing function as . In this form, there is no null character terminating the string. The main purpose for doing this is to use C++11's keyword to ensure that the compiler will transform the literal entirely at compile time, assuming is a constexpr-constructible and copyable type, and the literal processing function is a function.\n\nFor numeric literals, the type of the cooked literal is either for integral literals or for floating point literals. (Note: There is no need for signed integral types because a sign-prefixed literal is parsed as an expression containing the sign as a unary prefix operator and the unsigned number.) There is no alternative template form:\n\nIn accord with the formerly mentioned new string prefixes, for string literals, these are used:\n\nThere is no alternative template form. Character literals are defined similarly.\n\nThere are two parts involved: a memory model which allows multiple threads to co-exist in a program and library support for interaction between threads. (See this article's section on threading facilities.)\n\nThe memory model defines when multiple threads may access the same memory location, and specifies when updates by one thread become visible to other threads.\n\nIn a multi-threaded environment, it is common for every thread to have some unique variables. This already happens for the local variables of a function, but it does not happen for global and static variables.\n\nA new thread-local storage duration (in addition to the existing static, dynamic and automatic) is indicated by the storage specifier .\n\nAny object which could have static storage duration (i.e., lifetime spanning the entire execution of the program) may be given thread-local duration instead. The intent is that like any other static-duration variable, a thread-local object can be initialized using a constructor and destroyed using a destructor.\n\nIn C++03, the compiler provides, for classes that do not provide them for themselves, a default constructor, a copy constructor, a copy assignment operator ( ), and a destructor. The programmer can override these defaults by defining custom versions. C++ also defines several global operators (such as ) that work on all classes, which the programmer can override.\n\nHowever, there is very little control over creating these defaults. Making a class inherently non-copyable, for example, may be done by declaring a private copy constructor and copy assignment operator and not defining them. Attempting to use these functions is a violation of the One Definition Rule (ODR). While a diagnostic message is not required,[19] violations may result in a linker error.\n\nIn the case of the default constructor, the compiler will not generate a default constructor if a class is defined with any constructors. This is useful in many cases, but it is also useful to be able to have both specialized constructors and the compiler-generated default.\n\nC++11 allows the explicit defaulting and deleting of these special member functions.[20] For example, this class explicitly declares that a default constructor can be used:\n\nA function can be explicitly disabled. This is useful for preventing implicit type conversions. The specifier can be used to prohibit calling a function with particular parameter types.[20] For example:\n\nAn attempt to call with an parameter will be rejected by the compiler, instead of performing a silent conversion to . Calling with a still works.\n\nIt is possible to prohibit calling the function with any type other than by using a template:\n\ncalling will work, while will generate a compiler error.\n\nClass member functions and constructors can also be deleted. For example, it is possible to prevent copying class objects by deleting the copy constructor and :\n\nIn C++03, the largest integer type is . It is guaranteed to have at least as many usable bits as . This resulted in having size of 64 bits on some popular implementations and 32 bits on others. C++11 adds a new integer type to address this issue. It is guaranteed to be at least as large as a , and have no fewer than 64 bits. The type was originally introduced by C99 to the standard C, and most C++ compilers supported it as an extension already.[21][22]\n\nC++03 provides two methods to test assertions: the macro and the preprocessor directive . However, neither is appropriate for use in templates: the macro tests the assertion at execution-time, while the preprocessor directive tests the assertion during preprocessing, which happens before instantiation of templates. Neither is appropriate for testing properties that are dependent on template parameters.\n\nThe new utility introduces a new way to test assertions at compile-time, using the new keyword . The declaration assumes this form:\n\nHere are some examples of how can be used:\n\nWhen the constant expression is the compiler produces an error message. The first example is similar to the preprocessor directive , although the preprocessor does only support integral types.[23] In contrast, in the second example the assertion is checked at every instantiation of the template class .\n\nStatic assertions are useful outside of templates also. For instance, a given implementation of an algorithm might depend on the size of a being larger than an , something the standard does not guarantee. Such an assumption is valid on most systems and compilers, but not all.\n\nIn C++03, the operator can be used on types and objects. But it cannot be used to do this:\n\nThis should return the size of . C++03 disallows this, so it is a compile error. C++11 allows it. It is also allowed for the operator introduced in C++11.\n\nC++11 allows variable alignment to be queried and controlled with and .\n\nThe operator takes the type and returns the power of 2 byte boundary on which the type instances must be allocated (as a ). When given a reference type returns the referenced type's alignment; for arrays it returns the element type's alignment.\n\nThe specifier controls the memory alignment for a variable. The specifier takes a constant or a type; when supplied a type is shorthand for . For example, to specify that a char array should be properly aligned to hold a float:\n\nPrior C++ standards provided for programmer-driven garbage collection via , but gave no definition of object reachability for the purpose of automatic garbage collection. C++11 defines conditions under which pointer values are \"safely derived\" from other values. An implementation may specify that it operates under strict pointer safety, in which case pointers that are not derived according to these rules can become invalid.\n\nC++11 provides a standardized syntax for compiler/tool extensions to the language. Such extensions were traditionally specified using directive or vendor-specific keywords (like for GNU and for Microsoft). With the new syntax, added information can be specified in a form of an attribute enclosed in double square brackets. An attribute can be applied to various elements of source code:\n\nIn the example above, attribute applies to the type of variable , and apply to the variable itself, applies to the statement and applies to the return statement. In general (but with some exceptions), an attribute specified for a named entity is placed after the name, and before the entity otherwise, as shown above, several attributes may be listed inside one pair of double square brackets, added arguments may be provided for an attribute, and attributes may be scoped by vendor-specific attribute namespaces.\n\nIt is recommended that attributes have no language semantic meaning and do not change the sense of a program when ignored. Attributes can be useful for providing information that, for example, helps the compiler to issue better diagnostics or optimize the generated code.\n\nC++11 provides two standard attributes itself: to specify that a function does not return, and to help optimizing multi-threaded code by indicating that function arguments or return value carry a dependency.[clarification needed]\n\nA number of new features were introduced in the C++11 standard library. Many of these could have been implemented under the old standard, but some rely (to a greater or lesser extent) on new C++11 core features.\n\nA large part of the new libraries was defined in the document C++ Standards Committee's Library Technical Report (called TR1), which was published in 2005. Various full and partial implementations of TR1 are currently available using the namespace . For C++11 they were moved to namespace . However, as TR1 features were brought into the C++11 standard library, they were upgraded where appropriate with C++11 language features that were not available in the initial TR1 version. Also, they may have been enhanced with features that were possible under C++03, but were not part of the original TR1 specification.\n\nC++11 offers a number of new language features that the currently existing standard library components can benefit from. For example, most standard library containers can benefit from Rvalue reference based move constructor support, both for quickly moving heavy containers around and for moving the contents of those containers to new memory locations. The standard library components were upgraded with new C++11 language features where appropriate. These include, but are not necessarily limited to:\n• Rvalue references and the associated move support\n• Support for the UTF-16 encoding unit, and UTF-32 encoding unit Unicode character types\n• Variadic templates (coupled with Rvalue references to allow for perfect forwarding)\n\nFurther, much time has passed since the prior C++ standard. Much code using the standard library has been written. This has revealed parts of the standard libraries that could use some improving. Among the many areas of improvement considered were standard library allocators. A new scope-based model of allocators was included in C++11 to supplement the prior model.\n\nWhile the C++03 language provides a memory model that supports threading, the primary support for actually using threading comes with the C++11 standard library.\n\nA thread class ( ) is provided, which takes a function object (and an optional series of arguments to pass to it) to run in the new thread. It is possible to cause a thread to halt until another executing thread completes, providing thread joining support via the member function. Access is provided, where feasible, to the underlying native thread object(s) for platform-specific operations by the member function.\n\nFor synchronization between threads, appropriate mutexes ( , , etc.) and condition variables ( and ) are added to the library. These are accessible via Resource Acquisition Is Initialization (RAII) locks ( and ) and locking algorithms for easy use.\n\nFor high-performance, low-level work, communicating between threads is sometimes needed without the overhead of mutexes. This is done using atomic operations on memory locations. These can optionally specify the minimum memory visibility constraints needed for an operation. Explicit memory barriers may also be used for this purpose.\n\nThe C++11 thread library also includes futures and promises for passing asynchronous results between threads, and for wrapping up a function call that can generate such an asynchronous result. The futures proposal was criticized because it lacks a way to combine futures and check for the completion of one promise inside a set of promises.[24]\n\nFurther high-level threading facilities such as thread pools have been remanded to a future C++ technical report. They are not part of C++11, but their eventual implementation is expected to be built entirely on top of the thread library features.\n\nThe new facility provides a convenient method of running tasks and tying them to a . The user can choose whether the task is to be run asynchronously on a separate thread or synchronously on a thread that waits for the value. By default, the implementation can choose, which provides an easy way to take advantage of hardware concurrency without oversubscription, and provides some of the advantages of a thread pool for simple usages.\n\nTuples are collections composed of heterogeneous objects of pre-arranged dimensions. A tuple can be considered a generalization of a struct's member variables.\n\nThe C++11 version of the TR1 tuple type benefited from C++11 features like variadic templates. To implement reasonably, the TR1 version required an implementation-defined maximum number of contained types, and substantial macro trickery. By contrast, the implementation of the C++11 version requires no explicit implementation-defined maximum number of types. Though compilers will have an internal maximum recursion depth for template instantiation (which is normal), the C++11 version of tuples will not expose this value to the user.\n\nUsing variadic templates, the declaration of the tuple class looks as follows:\n\nAn example of definition and use of the tuple type:\n\nIt's possible to create the tuple without defining its contents, but only if the tuple elements' types possess default constructors. Moreover, it's possible to assign a tuple to another tuple: if the two tuples’ types are the same, each element type must possess a copy constructor; otherwise, each element type of the right-side tuple must be convertible to that of the corresponding element type of the left-side tuple or that the corresponding element type of the left-side tuple has a suitable constructor.\n\nJust like for , there exists to automatically create s using type deduction and helps to declare such a tuple. creates tuples of lvalue references to help unpack tuples. also helps here. See the example:\n\nRelational operators are available (among tuples with the same number of elements), and two expressions are available to check a tuple's characteristics (only during compilation):\n• returns the number of elements in the tuple ,\n• returns the type of the object number of the tuple .\n\nIncluding hash tables (unordered associative containers) in the C++ standard library is one of the most recurring requests. It was not adopted in C++03 due to time constraints only. Although hash tables are less efficient than a balanced tree in the worst case (in the presence of many collisions), they perform better in many real applications.\n\nCollisions are managed only via linear chaining because the committee didn't consider it to be opportune to standardize solutions of open addressing that introduce quite a lot of intrinsic problems (above all when erasure of elements is admitted). To avoid name clashes with non-standard libraries that developed their own hash table implementations, the prefix “unordered” was used instead of “hash”.\n\nThe new library has four types of hash tables, differentiated by whether or not they accept elements with the same key (unique keys or equivalent keys), and whether they map each key to an associated value. They correspond to the four existing binary search tree based associative containers, with an unordered_ prefix.\n\nThe new classes fulfill all the requirements of a container class, and have all the methods needed to access elements: , , , .\n\nThis new feature didn't need any C++ language core extensions (though implementations will take advantage of various C++11 language features), only a small extension of the header and the introduction of headers and . No other changes to any existing standard classes were needed, and it doesn't depend on any other extensions of the standard library.\n\nIn addition to the hash tables two more containers was added to the standard library. The std::array is a fixed size container that is more efficient than std::vector but safer and easier to use than a c-style array. The std::forward_list is a single linked list that provides more space efficient storage than the double linked std::list when bidirectional iteration is not needed.\n\nThe new library, defined in the new header , is made of a couple of new classes:\n• regular expressions are represented by instance of the template class ;\n• occurrences are represented by instance of the template class ,\n• std::regex_iterator is used to iterate over all matches of a regex\n\nThe function is used for searching, while for ‘search and replace’ the function is used which returns a new string.[25]\n\nHere is an example of the use of :\n\nThe library requires neither alteration of any existing header (though it will use them where appropriate) nor an extension of the core language. In POSIX C, regular expressions are also available via the C POSIX library#regex.h.\n\nC++11 provides , and improvements to and from TR1. is deprecated.\n\nThe C standard library provides the ability to generate pseudorandom numbers via the function . However, the algorithm is delegated entirely to the library vendor. C++ inherited this functionality with no changes, but C++11 provides a new method for generating pseudorandom numbers.\n\nC++11's random number functionality is split into two parts: a generator engine that contains the random number generator's state and produces the pseudorandom numbers; and a distribution, which determines the range and mathematical distribution of the outcome. These two are combined to form a random number generator object.\n\nUnlike the C standard , the C++11 mechanism will come with three base generator engine algorithms:\n\nC++11 also provides a number of standard distributions:\n\nThe generator and distributions are combined as in this example:\n\nA wrapper reference is obtained from an instance of the class template . Wrapper references are similar to normal references (‘ ’) of the C++ language. To obtain a wrapper reference from any object the function template is used (for a constant reference is used).\n\nWrapper references are useful above all for function templates, where references to parameters rather than copies are needed:\n\nThis new utility was added to the existing header and didn't need further extensions of the C++ language.\n\nPolymorphic wrappers for function objects are similar to function pointers in semantics and syntax, but are less tightly bound and can indiscriminately refer to anything which can be called (function pointers, member function pointers, or functors) whose arguments are compatible with those of the wrapper.\n\nAn example can clarify its characteristics:\n\nThe template class was defined inside the header , without needing any change to the C++ language.\n\nMetaprogramming consists of creating a program that creates or modifies another program (or itself). This can happen during compilation or during execution. The C++ Standards Committee has decided to introduce a library for metaprogramming during compiling via templates.\n\nHere is an example of a meta-program using the C++03 standard: a recursion of template instances for calculating integer exponents:\n\nMany algorithms can operate on different types of data; C++'s templates support generic programming and make code more compact and useful. Nevertheless, it is common for algorithms to need information on the data types being used. This information can be extracted during instantiation of a template class using type traits.\n\nType traits can identify the category of an object and all the characteristics of a class (or of a struct). They are defined in the new header .\n\nIn the next example there is the template function ‘elaborate’ which, depending on the given data types, will instantiate one of the two proposed algorithms ( ).\n\nVia type traits, defined in header , it's also possible to create type transformation operations ( and are insufficient inside a template).\n\nThis type of programming produces elegant and concise code; however, the weak point of these techniques is the debugging: it's uncomfortable during compilation and very difficult during program execution.\n\nDetermining the return type of a template function object at compile-time is not intuitive, particularly if the return value depends on the parameters of the function. As an example:\n\nInstantiating the class template , the function object of will have always the same return type as the function object of . However, given class below:\n\nAttempting to instantiate will cause the return type of to not be the same as that of class . The compiler may generate warnings about the conversion from to and vice versa.\n\nTR1 introduces, and C++11 adopts, the template class that allows one to determine and use the return type of a function object for every declaration. The object uses the object to derive the return type of the function object:\n\nIn this way in instances of function object of there are no conversions, warnings, or errors.\n\nThe only change from the TR1 version of is that the TR1 version allowed an implementation to fail to be able to determine the result type of a function call. Due to changes to C++ for supporting , the C++11 version of no longer needs these special cases; implementations are required to compute a type in all cases.\n\nFor compatibility with C, from C99, these were added:[26]\n• – integer type that is at least 64 bits long.\n• – macro evaluating to the name of the function it is in.\n\nThe term sequence point was removed, being replaced by specifying that either one operation is sequenced before another, or that two operations are unsequenced.[28]\n\nThe former use of the keyword was removed.[29] The keyword itself remains, being reserved for potential future use.\n\nDynamic exception specifications are deprecated.[29] Compile-time specification of non-exception-throwing functions is available with the keyword, which is useful for optimization.\n\nis deprecated, having been superseded by .\n\nFunction object base classes ( , ), adapters to pointers to functions and adapters to pointers to members, and binder classes are all deprecated.\n• C++0X: The New Face of Standard C++\n• A talk on C++0x given by Bjarne Stroustrup at the University of Waterloo Archived 2009-01-23 at the Wayback Machine\n• The State of the Language: An Interview with Bjarne Stroustrup (15 August 2008) Archived 31 January 2009 at the Wayback Machine\n• Wiki page to help keep track of C++ 0x core language features and their availability in compilers\n• More information on C++11 features:range-based for loop, why auto_ptr is deprecated, etc. [usurped]"
    }
]