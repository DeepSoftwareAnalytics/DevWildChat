[
    {
        "link": "https://docs.acrcloud.com/reference/identification-api",
        "document": "This is a demo program which implements ACRCloud Identify Protocol V1 with the third party library \"requests\".\n\nWe recomment you implement your own app with \"requests\" too.\n\nYou can install this python library by:\n\nReplace \"###...###\" below with your project's host, access_key and access_secret.\n\n# default is \"fingerprint\", it's for recognizing fingerprint,\n\n# if you want to identify audio, please change data_type=\"audio\"\n\n# File size: < 1M , You'de better cut large file to small file, within 15 seconds data size is better"
    },
    {
        "link": "https://github.com/acrcloud/acrcloud_scan_files_python",
        "document": "ACRCloud provides Automatic Content Recognition services for Audio Fingerprinting based applications such as Audio Recognition (supports music, video, ads for both online and offline), Broadcast Monitoring, Second Screen, Copyright Protection and etc.\n\n\n\nThis tool can scan audio/video files and detect audios you want to recognize such as music, ads.\n• Follow one of the tutorials to create a project and get your host, access_key and access_secret.\n• Install Docker\n• If you are using Windows: Download Docker Desktop for Windows and install.\n• If you are using MacOs: Download Docker Desktop for Mac and install.\n• If you are using Linux: Open the Terminal and input\n• Run following command git clone https://github.com/acrcloud/acrcloud_scan_files_python.git cd acrcloud_scan_files_python sudo docker build -t acrcloud/python_scan_tool . # Call it without arguments to display the full help sudo docker run --rm acrcloud/python_scan_tool # Basic usage sudo docker run --rm -v $(pwd):/tmp -v /Users/acrcloud/:/music/ acrcloud/python_scan_tool -f /music/test.mp4 -o /tmp You need to change /Users/acrcloud/ to the directory where your audio/video file is. And the report file will in the acrcloud_scan_files_python directory.\n\nFor Windows System, you must install Python and pip.\n\nOpen your terminal and change to the script directory of acrcloud_scan_files_python-master. Then run the command:\n\nYou can run the following command to install it.\n\nOr you can download the sdk and install it by following command.\n\nBefore you use this script,you must have acrcloud host,access_key and access_secret. If you haven't have these ,you can register one https://console.acrcloud.com/signup\n\nChange the content of config.json,fill in your host, access_key and access_secret\n\n\"-l\" ---- recongizing length. (use how many seconds to recongize. for example: -s 20 -l 10, it will get 20 seconds of audio each time and use the first 10 seconds of audio to recognize)\n\n\"-r\" ---- scan range. （The scan range. for example: -r 5-20, it will recognize the file starting from the 5th second and finish at the 20th second.）\n\n\"-w\" ---- results with duration. (1-yes, 0-no), you must set offset config for your access key, pls contact support@acrcloud.com\n\n\"-o\" ---- set the directory to save the results\n\n\"-t\" ---- set the type of file.(csv[default] or xlsx).\n\nDefault is scan folder where this script in.\n\nThe results are saved in the folder where this script in."
    },
    {
        "link": "https://github.com/acrcloud/acrcloud_sdk_python",
        "document": "ACRCloud provides services such as Music Recognition, Broadcast Monitoring, Custom Audio Recognition, Copyright Compliance & Data Deduplication, Live Channel Detection, and Offline Recognition etc.\n\n\n\nThis audio recognition python SDK support most of audio / video files.\n\nFollow one of the tutorials to create a project and get your host, access_key and access_secret.\n\nYou can run python -m pip install git+https://github.com/acrcloud/acrcloud_sdk_python or go to sub dir, and run\"sudo python setup.py install\".\n\nIf you run the SDK on Windows, you must install this library.\n\n X86: download and install Library(windows/vcredist_x86.exe)\n\n x64: download and install Library(windows/vcredist_x64.exe)\n• If you run the SDK on Windows, you must install library(vcredist).\n• If you use docker alpine, you need to install \"apk add --update libstdc++\"\n\n( , , , , ): #audio_len_seconds: Length of audio data you need. if you create recogize frigerprint, default is 12 seconds, if you create db frigerprint, it is not usefully; #is_db_fingerprint: If it is True, it will create db frigerprint (Fingerprint for bucket, not for recognition); : , : , : } ( , , ): #audio_len_seconds: Length of audio data you need. if you create recogize frigerprint, default is 12 seconds, if you create db frigerprint, it is not usefully; ( , , , , ): #audio_len_seconds: Length of audio data you need. if you create recogize frigerprint, default is 12 seconds, if you create db frigerprint, it is not usefully; #is_db_fingerprint: If it is True, it will create db frigerprint (Fingerprint for bucket, not for recognition); : , : , : } ( , , ): #audio_len_seconds: Length of audio data you need. if you create recogize frigerprint, default is 12 seconds, if you create db frigerprint, it is not usefully; ( , ): #is_db_fingerprint: If it is True, it will create db frigerprint (Fingerprint for bucket, not for recognition); ( ): ( , , ): #It will return the audio data(RIFF (little-endian) data, WAVE audio, Microsoft PCM, 16 bit, mono 8000 Hz); #audio_len_seconds: Length of audio data you need, if it is 0, will decode all the audio; ( , , ): #It will return the audio data(RIFF (little-endian) data, WAVE audio, Microsoft PCM, 16 bit, mono 8000 Hz); #audio_len_seconds: Length of audio data you need, if it is 0, will decode all the audio; () #return the version of this module"
    },
    {
        "link": "https://barstool.engineering/using-acr-cloud-to-identify-copyrighted-content-in-audio-files",
        "document": "Consumer applications like Shazam have been around for years, but only recently has using Automated Content Recognition (ACR) tools in enterprise software been easy and affordable. As a major podcast producer, the team at Barstool has to verify that any new podcast episodes we upload don’t contain copyrighted content that we aren’t licensed to use prior to publishing. Up until recently, this process was manual and laborious. The engineering team set out to fix that.\n\nThe goal was to create an automated system identify any copyrighted audio at upload-time. We could then compare the identified content with a whitelist of labels that we license for use in podcasts, and display a simple UI so producers can verify at-a-glance that we have rights to use all of the content prior to publishing. If a section of audio comes back as containing unlicensed content, the producer would then recut the episode with alternate content in its place.\n\nAfter evaluating several vendors, we chose to go with ACRCloud. They’re a relatively new startup, but have made a name for themselves in their short time in the industry. Their music identification service allows you to upload an audio or fingerprint file for identification. While uploading a full podcast audio file was tempting, in practice the transit and processing time was too long for our purposes.\n\nACRCloud provides a number of tools and SDKs on their GitHub to interface with their APIs. To prove out the concept we used the Python Scan Tool. This generates fingerprint files for every 10 second segment of the input file, then uploads them to the ACRCloud API. The output is parsed as either JSON or CSV locally. While we wouldn't use this tool directly in our infrastructure, it helped us to understand & prove out the process. After vetting the data, we were ready to replace the python script with a direct integration in our CMS.\n\nUnder the hood, the Python script uses the ACRCloud Extractor Tool to generate fingerprint files. The fingerprint files are generated for a specific span of time based on the CLI input. When each fingerprint file was ready, a request was made to the ACRCloud's identification API. These endpoints require each upload be signed to verify the payload integrity, so each request required an SHA1 hash to accompany the request. Below is the NodeJS to send the request\n\nOur first performance improvement was to asynchronously upload the fingerprints for identification in parallel rather than one at a time. This reduced the total processing time greatly, while adding comparatively little complexity. This would all live in BQE so we aren't resource constrained per-process and don't have an upper run-time limit to worry about.\n\nWhile the actual identification was performant, we noticed the tool took exponentially longer to generate fingerprints the further into the audio file they were, meaning generating a fingerprint from 0-10 was almost instant, while each subsequent fingerprint would longer and longer to generate. This is common behavior with applications that require seeking to a specific location in a media file, as the underlying mp3 library has to decode every frame to make sure your seek command is frame-accurate.\n\nWhile FFMPEG can have this same issue, there are several ways to make frame-accurate seeking faster. We’ve used some of these methods when clipping live video so we were familiar with the problem. To speed up ACRCloud, our solution was to generate mp3 clips using FFMPEG map function with the flag -segment_time flag set to 10 seconds.\n\nWe then could take all of the generated mp3s segments and process them using the ACR extractor tool in parallel. Once we have an array of fingerprint files we had to tie everything together and generate a response with the specific time ranges where copyrighted content was found. This reduced our processing time to ~1 minute for a 1 hour long audio file.\n\nOnce we had a JSON response with all of the licensed content used in the audio file, all that was left to do was return the value back to our Podcast API. Below is a view of that our producers see if an audio file is uploaded with unlicensed content:"
    },
    {
        "link": "https://docs.acrcloud.com/reference/console-api/buckets/audio-files",
        "document": "Upload the audio files or fingerprint to the specified bucket\n\nMove the files to another bucket\n\nMove the files to another bucket\n\nGet one or multiple files\n\nDump all the files information in this bucket (only dump bucket data once a day)\n\nThis is an asynchronous request. After the request is completed, you must wait and check the status through the interface. Once it becomes 1, you can download it using the down_url address."
    },
    {
        "link": "https://docs.genius.com",
        "document": "First, visit the Genius API Client management page and create an API client for your application. This will provide you with a and a that you'll use to identify your application to Genius. The is used for authenticating Genius users with your application. You can change it later. The API Client will belong to the user account signed in to Genius when it's created.\n\nThe available endpoints are listed below in the resources section, along with embedded examples showing how they work and what they return.\n\nGenius uses OAuth2 for authentication. All API requests must be authenticated. There are plenty of libraries available to help with this part of your integration. There's also a detailed guide below if you're committed to implementing it yourself.\n\nSee details about using an access token in the Authenticate with the Docs App to Try See details about using an access token in the authentication section below. Information about a web page retrieved by the page's full URL (including protocol). The returned data includes Genius's ID for the page, which may be used to look up associated referents with the endpoint. Data is only available for pages that already have at least one annotation. Provide as many of the following variants of the URL as possible: The URL as it would appear in a browser The URL as specified by an appropriate tag in a page's The URL as specified by an tag in a page's\n\nGenius uses the OAuth2 standard for making API calls on behalf of individual users. Requests are authenticated with an Access Token sent in an HTTP header (or as a request parameter if you must).\n\nAll interaction with the API must be done over HTTPS.\n\nStart by directing a user of your application to Genius's authentication page at with the following query parameters:\n• : Your application's Client ID, as listed on the API Client management page\n• : The URI Genius will redirect the user to after they've authorized your application; it must be the same as the one set for the API client on the management page\n• : The permissions your application is requesting as a space-separated list (see available scopes below)\n• : A value that will be returned with the code redirect for maintaining arbitrary state through the authorization process\n\nOn the authentication page the user can choose to allow your application to access Genius on their behalf. They'll be asked to sign in (or, if necessary, create an account) first. Then the user is redirected to .\n\nYour application can exchange the query parameter from the redirect for an access token by making a request to with the following request body data:\n• : The query parameter from the redirect to your\n• : Your application's Client Secret, as listed on the API Client management page\n\nMost of these are the same values as used in the initial request.\n\nThe response body will be an object with the token as the value for the key. Save the token and use it to make requests on behalf of the authorizing user.\n\nAn alternative authentication flow is available for browser-based, client-only applications. This mechanism is much less secure than the full code exchange process and should only be used by applications without a server or native platform to execute the full code flow. Where \"code\" is used as the value in the instructions above, use . Instead of being redirected with a code that your application exchanges for an access token, the user is redirected to . Extract the access token from the URL hash fragment and use it to make requests. With the token response type, the user's access token is exposed in the browser, where it could be accessed by malicious JavaScript or otherwise intercepted much more easily than when it's only exchanged between servers. The client secret isn't used, so it's much easier for potential attackers to fake authorization requests. Don't use the token flow if you don't have to.\n\nAccess tokens can only be used for resources that are covered by the scopes provided when they created. These are the available scopes and the endpoints they grant permission for:\n\nTo make authenticated requests with an access token, include it in an HTTP header preceded by the word \"Bearer\" and a space. For example, the value of the header could be .\n\nPassing the token in the authorization header is the preferred way to authenticate API requests. However, the API also supports providing the token as the query parameter of a request or element of a body."
    },
    {
        "link": "https://lyricsgenius.readthedocs.io/en/master/reference/api.html",
        "document": "The Genius class inherits this class, and it’s recommended to call the methods using the Genius class rather than accessing this class directly. The class is in charge of making all the requests to the developers’ API (api.genius.com) Use the methods of this class if you already have information such as song ID to make direct requests to the API. Otherwise the class provides a friendlier front-end to search and retrieve data from Genius.com. All methods of this class are available through the class.\n• None retries ( , optional) – Number of retries in case of timeouts and errors with a >= 500 response code. By default, requests are only made once. Number of retries in case of timeouts and errors with a >= 500 response code. By default, requests are only made once. An object of the class. Gets details about the current user. Gets details about the current user. text_format ( , optional) – Text format of the results (‘dom’, ‘html’, ‘markdown’ or ‘plain’). Deletes an annotation created by the authenticated user.\n• None text_format ( , optional) – Text format of the results (‘dom’, ‘html’, ‘markdown’ or ‘plain’).\n• None raw_annotatable_url ( ) – The original URL of the page.\n• None before_html ( , optional) – The HTML before the highlighted fragment (prefer up to 200 characters).\n• None after_html ( , optional) – The HTML after the highlighted fragment (prefer up to 200 characters).\n• None canonical_url ( , optional) – The href property of the tag on the page.\n• None og_url ( , optional) – The content property of the tag on the page.\n• None title ( , optional) – The title of the page.\n• None text_format ( , optional) – Text format of the response (‘dom’, ‘html’, ‘markdown’ or ‘plain’). Deletes an annotation created by the authenticated user. 204 - which is the response’s status code\n• None text_format ( , optional) – Text format of the response (‘dom’, ‘html’, ‘markdown’ or ‘plain’).\n• None text_format ( , optional) – Text format of the response (‘dom’, ‘html’, ‘markdown’ or ‘plain’).\n• None text_format ( , optional) – Text format of the response (‘dom’, ‘html’, ‘markdown’ or ‘plain’).\n• None text_format ( , optional) – Text format of the results (‘dom’, ‘html’, ‘markdown’ or ‘plain’).\n• None sort ( , optional) – Sorting preference. Either based on ‘title’, ‘popularity’ or ‘release_date’.\n• None per_page ( , optional) – Number of results to return per request. It can’t be more than 50. # getting all artist songs based on popularity\n• None created_by_id ( , optional) – User ID of the contributer who created the annotation(s).\n• None per_page ( , optional) – Number of results to return per page. It can’t be more than 50.\n• None text_format ( , optional) – Text format of the results (‘dom’, ‘html’, ‘markdown’ or ‘plain’). You may pass only one of and , not both. # getting all verified annotations of a song (artist annotations)\n• None per_page ( , optional) – Number of results to return per page. It can’t be more than 5 for this method.\n• None text_format ( , optional) – Text format of the results (‘dom’, ‘html’, ‘markdown’ or ‘plain’).\n• None raw_annotatable_url ( ) – The URL as it would appear in a browser.\n• None canonical_url ( ) – The URL as specified by an appropriate <link> tag in a page’s <head>.\n• None og_url ( ) – The URL as specified by an og:url <meta> tag in a page’s <head>.\n• None Data is only available for pages that already have at least one annotation.\n• None You must at least pass one argument to the method.\n• None You can pass more than one or all arguments (provided they’re the address of the same webpage).\n\nThe Genius class inherits this class, and it’s recommended to call the methods using the Genius class rather than accessing this class directly. The class is in charge of making all the requests to the public API (genius.com/api) You can use this method without an access token since calls are made to the public API. All methods of this class are available through the class.\n• None retries ( , optional) – Number of retries in case of timeouts and errors with a >= 500 response code. By default, requests are only made once. Number of retries in case of timeouts and errors with a >= 500 response code. By default, requests are only made once. An object of the class. Gets the comments on an album page. Gets the leaderboard of an album. Gets the tracks of a specific album.\n• None text_format ( , optional) – Text format of the results (‘dom’, ‘html’, ‘markdown’ or ‘plain’).\n• None time_period ( , optional) – Time period of the results (‘day’, ‘week’, ‘month’ or ‘all_time’).\n• None chart_genre ( , optional) – The genre of the results.\n• None per_page ( , optional) – Number of results to return per request. It can’t be more than 50.\n• None text_format ( , optional) – Text format of the results (‘dom’, ‘html’, ‘markdown’ or ‘plain’). Gets the comments on an album page.\n• None per_page ( , optional) – Number of results to return per request. It can’t be more than 50.\n• None text_format ( , optional) – Text format of the results (‘dom’, ‘html’, ‘markdown’ or ‘plain’).\n• None text_format ( , optional) – Text format of the results (‘dom’, ‘html’, ‘markdown’ or ‘plain’). Defines the text formatting for the annotation of the cover arts, if there are any. Gets the leaderboard of an album.\n• None per_page ( , optional) – Number of results to return per request. It can’t be more than 50. Gets the tracks of a specific album.\n• None per_page ( , optional) – Number of results to return per request. It can’t be more than 50.\n• None text_format ( , optional) – Text format of the results (‘dom’, ‘html’, ‘markdown’ or ‘plain’). Gets the edits on annotation (its versions). Gets the comments on an annotation.\n• None text_format ( , optional) – Text format of the results (‘dom’, ‘html’, ‘markdown’ or ‘plain’). Gets the edits on annotation (its versions).\n• None text_format ( , optional) – Text format of the results (‘dom’, ‘html’, ‘markdown’ or ‘plain’). Gets the comments on an annotation.\n• None per_page ( , optional) – Number of results to return per request. It can’t be more than 50.\n• None text_format ( , optional) – Text format of the results (‘dom’, ‘html’, ‘markdown’ or ‘plain’). Gets the comments on an article. Gets the latest articles on the homepage.\n• None text_format ( , optional) – Text format of the results (‘dom’, ‘html’, ‘markdown’ or ‘plain’). Gets the comments on an article.\n• None per_page ( , optional) – Number of results to return per request. It can’t be more than 50.\n• None text_format ( , optional) – Text format of the results (‘dom’, ‘html’, ‘markdown’ or ‘plain’). Gets the latest articles on the homepage. This method will return the featured articles that are placed on top of the Genius.com page.\n• None per_page ( , optional) – Number of results to return per request. It can’t be more than 50.\n• None text_format ( , optional) – Text format of the results (‘dom’, ‘html’, ‘markdown’ or ‘plain’). Gets contribution opportunities related to the artist.\n• None text_format ( , optional) – Text format of the results (‘dom’, ‘html’, ‘markdown’ or ‘plain’).\n• None per_page ( , optional) – Number of results to return per request. It can’t be more than 50.\n• None text_format ( , optional) – Text format of the results (‘dom’, ‘html’, ‘markdown’ or ‘plain’).\n• None per_page ( , optional) – Number of results to return per request. It can’t be more than 50. Gets contribution opportunities related to the artist.\n• None per_page ( , optional) – Number of results to return per request. It can’t be more than 50.\n• None next_cursor ( , optional) – Paginated offset (address of the next cursor).\n• None text_format ( , optional) – Text format of the results (‘dom’, ‘html’, ‘markdown’ or ‘plain’). This method requires a logged in user and will raise .\n• None per_page ( , optional) – Number of results to return per request. It can’t be more than 50.\n• None per_page ( , optional) – Number of results to return per request. It can’t be more than 50.\n• None per_page ( , optional) – Number of results to return per request. It can’t be more than 50.\n• None per_page ( , optional) – Number of results to return per request. It can’t be more than 50. Gets the cover arts of an album or a song. Gets the cover arts of an album or a song. You must supply one of or .\n• None text_format ( , optional) – Text format of the results (‘dom’, ‘html’, ‘markdown’ or ‘plain’). Defines the text formatting for the annotation of the cover arts, if there are any. Gets the replies on a discussion.\n• None text_format ( , optional) – Text format of the results (‘dom’, ‘html’, ‘markdown’ or ‘plain’). This request returns a 403 error and will raise . Gets the replies on a discussion.\n• None per_page ( , optional) – Number of results to return per request. It can’t be more than 50.\n• None text_format ( , optional) – Text format of the results (‘dom’, ‘html’, ‘markdown’ or ‘plain’). This request returns a 403 error and will raise . This method gets data of the community charts on the Genius.com page.\n• None time_period ( , optional) – Time period of the results. (‘day’, ‘week’, ‘month’ or ‘all_time’).\n• None per_page ( , optional) – Number of results to return per request. It can’t be more than 50.\n• None text_format ( , optional) – Text format of the results (‘dom’, ‘html’, ‘markdown’ or ‘plain’). This method gets data of the chart on the Genius.com page.\n• None time_period ( , optional) – Time period of the results. The default is . (‘day’, ‘week’, ‘month’ or ‘all_time’).\n• None chart_genre ( , optional) – The genre of the results. The default value is . (‘all’, ‘rap’, ‘pop’, ‘rb’, ‘rock’ or ‘country’)\n• None per_page ( , optional) – Number of results to return per request. It can’t be more than 50.\n• None text_format ( , optional) – Text format of the results (‘dom’, ‘html’, ‘markdown’ or ‘plain’).\n• None type ( , optional) – The type to get the charts for. The default is . (‘songs’, ‘albums’, ‘artists’ or ‘referents’). The referents mentioned in the description of the argument is shown as Lyrics in the drop-down menu on Genius.com where you choose the Type. Gets the questions on an album or a song. Gets the questions on an album or a song. You must supply one of or .\n• None time_period ( , optional) – Time period of the results (‘day’, ‘week’, ‘month’ or ‘all_time’).\n• None per_page ( , optional) – Number of results to return per request. It can’t be more than 50.\n• None text_format ( , optional) – Text format of the results (‘dom’, ‘html’, ‘markdown’ or ‘plain’). Gets data of one or more referents. Gets data of one or more referents. This method can get multiple referents in one call, thus increasing performance.\n• None text_format ( , optional) – Text format of the results (‘dom’, ‘html’, ‘markdown’ or ‘plain’). Using this method you can get the referent itself instead of the referents of a song or webpage which is what gets. You must supply , , or .\n• None created_by_id ( , optional) – User ID of the contributer who created the annotation(s).\n• None per_page ( , optional) – Number of results to return per page. It can’t be more than 50.\n• None text_format ( , optional) – Text format of the results (‘dom’, ‘html’, ‘markdown’ or ‘plain’).\n• None time_period ( , optional) – Time period of the results (‘day’, ‘week’, ‘month’ or ‘all_time’).\n• None chart_genre ( , optional) – The genre of the results.\n• None per_page ( , optional) – Number of results to return per request. It can’t be more than 50.\n• None text_format ( , optional) – Text format of the results (‘dom’, ‘html’, ‘markdown’ or ‘plain’).\n• None per_page ( , optional) – Number of results to return per request. It can’t be more than 50.\n• None text_format ( , optional) – Text format of the results (‘dom’, ‘html’, ‘markdown’ or ‘plain’).\n• None type ( , optional) – Type of item to search for (‘song’, ‘lyric’, ‘artist’, ‘album’, ‘video’, ‘article’, ‘user’ or ‘multi’). Specifying no parameter (which defaults to ) or setting it as will return the same results. Both will return songs. The only different is they return the hits in different keys: By Setting the type as the method will perform a search for all the other types and return an extra section called . Instead of calling this method directly and specifying a type, you can use the alias methods.\n• None per_page ( , optional) – Number of results to return per page. It can’t be more than 5 for this method. This method will also return a section alongside other types.\n• None per_page ( , optional) – Number of results to return per request. It can’t be more than 50.\n• None text_format ( , optional) – Text format of the results (‘dom’, ‘html’, ‘markdown’ or ‘plain’).\n• None per_page ( , optional) – Number of results to return per request. It can’t be more than 50.\n• None text_format ( , optional) – Text format of the results (‘dom’, ‘html’, ‘markdown’ or ‘plain’).\n• None per_page ( , optional) – Number of results to return per request. It can’t be more than 50.\n• None text_format ( , optional) – Text format of the results (‘dom’, ‘html’, ‘markdown’ or ‘plain’).\n• None per_page ( , optional) – Number of results to return per request. It can’t be more than 50.\n• None text_format ( , optional) – Text format of the results (‘dom’, ‘html’, ‘markdown’ or ‘plain’).\n• None per_page ( , optional) – Number of results to return per request. It can’t be more than 50.\n• None text_format ( , optional) – Text format of the results (‘dom’, ‘html’, ‘markdown’ or ‘plain’).\n• None per_page ( , optional) – Number of results to return per request. It can’t be more than 50.\n• None text_format ( , optional) – Text format of the results (‘dom’, ‘html’, ‘markdown’ or ‘plain’). Gets the comments on a song. Gets the contributors of a song.\n• None text_format ( , optional) – Text format of the results (‘dom’, ‘html’, ‘markdown’ or ‘plain’).\n• None per_page ( , optional) – Number of results to return per request. It can’t be more than 50.\n• None text_format ( , optional) – Text format of the results (‘dom’, ‘html’, ‘markdown’ or ‘plain’). Gets the comments on a song.\n• None per_page ( , optional) – Number of results to return per request. It can’t be more than 50.\n• None text_format ( , optional) – Text format of the results (‘dom’, ‘html’, ‘markdown’ or ‘plain’). Gets the contributors of a song. This method will return users who have contributed to this song by editing lyrics or song details. Gets the accounts user follows.\n• None text_format ( , optional) – Text format of the results (‘dom’, ‘html’, ‘markdown’ or ‘plain’). This methods gets the section titled “TOP ACCOMPLISHMENTS” in the user’s profile.\n• None per_page ( , optional) – Number of results to return per request. It can’t be more than 50.\n• None next_cursor ( , optional) – Paginated offset (address of the next cursor). Gets the accounts user follows.\n• None per_page ( , optional) – Number of results to return per request. It can’t be more than 50.\n• None per_page ( , optional) – Number of results to return per request. It can’t be more than 50.\n• None per_page ( , optional) – Number of results to return per request. It can’t be more than 50.\n• None next_cursor ( , optional) – Paginated offset (address of the next cursor).\n• None text_format ( , optional) – Text format of the results (‘dom’, ‘html’, ‘markdown’ or ‘plain’).\n• None type ( , optional) – Type of the contribution (‘annotations’, ‘articles’, ‘pyongs’, ‘questions_and_answers’, ‘comments’, ‘transcriptions’ or ‘unreviewed annotations’). Not all types support a sorting preference. Setting the for these types won’t result in erros, but won’t make a difference in the results either. To find out which types support which features, look at the alias methods. Setting no value for the will return the user’s contributions (regardless of its type) in chronological order; just like visting a user’s profile page and scrolling down, looking at their contributions over time.\n• None per_page ( , optional) – Number of results to return per request. It can’t be more than 50.\n• None next_cursor ( , optional) – Paginated offset (address of the next cursor).\n• None text_format ( , optional) – Text format of the results (‘dom’, ‘html’, ‘markdown’ or ‘plain’).\n• None per_page ( , optional) – Number of results to return per request. It can’t be more than 50.\n• None next_cursor ( , optional) – Paginated offset (address of the next cursor).\n• None text_format ( , optional) – Text format of the results (‘dom’, ‘html’, ‘markdown’ or ‘plain’).\n• None per_page ( , optional) – Number of results to return per request. It can’t be more than 50.\n• None next_cursor ( , optional) – Paginated offset (address of the next cursor).\n• None text_format ( , optional) – Text format of the results (‘dom’, ‘html’, ‘markdown’ or ‘plain’).\n• None per_page ( , optional) – Number of results to return per request. It can’t be more than 50.\n• None next_cursor ( , optional) – Paginated offset (address of the next cursor).\n• None text_format ( , optional) – Text format of the results (‘dom’, ‘html’, ‘markdown’ or ‘plain’).\n• None per_page ( , optional) – Number of results to return per request. It can’t be more than 50.\n• None next_cursor ( , optional) – Paginated offset (address of the next cursor).\n• None text_format ( , optional) – Text format of the results (‘dom’, ‘html’, ‘markdown’ or ‘plain’).\n• None per_page ( , optional) – Number of results to return per request. It can’t be more than 50.\n• None next_cursor ( , optional) – Paginated offset (address of the next cursor).\n• None text_format ( , optional) – Text format of the results (‘dom’, ‘html’, ‘markdown’ or ‘plain’). This method gets user annotations that have the “This annotations is unreviewed” sign above them.\n• None per_page ( , optional) – Number of results to return per request. It can’t be more than 50.\n• None next_cursor ( , optional) – Paginated offset (address of the next cursor).\n• None text_format ( , optional) – Text format of the results (‘dom’, ‘html’, ‘markdown’ or ‘plain’). Gets the videos of an album, article or song or the featured videos.\n• None text_format ( , optional) – Text format of the results (‘dom’, ‘html’, ‘markdown’ or ‘plain’). Gets the videos of an album, article or song or the featured videos.\n• None per_page ( , optional) – Number of results to return per request. It can’t be more than 50.\n• None Genius original video series that the item has been mentioned in. (of) – If you specify no album, article or song, the method will return a series of videos. In this case, if , the results will be the videos in the VIDEOS section on the homepage. But if , the method returns another set of videos that we are not sure what they are at the moment. Miscellaneous methods that are mostly standalones. Gets the voters of an item.\n• None text_format ( , optional) – Text format of the results (‘dom’, ‘html’, ‘markdown’ or ‘plain’). This method requires a logged in user and will raise . Gets the voters of an item. You must supply one of , , or ."
    },
    {
        "link": "https://lyricsgenius.readthedocs.io/en/master/reference/genius.html",
        "document": "The Genius class provides a high-level interface to the Genius API. This class provides convenient access to the standard API ( ), the public API ( ), and additional features such as downloading lyrics.\n\nSearches for a specific artist and gets their songs. Searches for a specific song and gets its lyrics.\n• None per_page ( , optional) – Number of results to return per request. It can’t be more than 50.\n• None text_format ( , optional) – Text format of the results (‘dom’, ‘html’, ‘markdown’ or ‘plain’).\n• None type ( , optional) – Type of item to search for (‘song’, ‘lyric’, ‘artist’, ‘album’, ‘video’, ‘article’, ‘user’ or ‘multi’). Specifying no parameter (which defaults to ) or setting it as will return the same results. Both will return songs. The only different is they return the hits in different keys: By Setting the type as the method will perform a search for all the other types and return an extra section called . Instead of calling this method directly and specifying a type, you can use the alias methods.\n• None per_page ( , optional) – Number of results to return per page. It can’t be more than 5 for this method. This method will also return a section alongside other types.\n• None per_page ( , optional) – Number of results to return per request. It can’t be more than 50.\n• None text_format ( , optional) – Text format of the results (‘dom’, ‘html’, ‘markdown’ or ‘plain’). Searches for a specific artist and gets their songs. This method looks for the artist by the name or by the ID if it’s provided in . It returrns an object if the search is successful. If is True, the name of the artist is changed to the artist name on Genius.\n• None artist_name ( ) – Name of the artist to search for.\n• None (obj (max_songs) – , optional): Maximum number of songs to search for.\n• None per_page ( , optional) – Number of results to return per search page. It can’t be more than 50.\n• None get_full_info ( , optional) – Get full info for each song (slower).\n• None allow_name_change ( , optional) – If True, search attempts to switch to intended artist name.\n• None artist_id ( , optional) – Allows user to pass an artist ID. # printing the lyrics of all of the artist's songs\n• None per_page ( , optional) – Number of results to return per request. It can’t be more than 50.\n• None text_format ( , optional) – Text format of the results (‘dom’, ‘html’, ‘markdown’ or ‘plain’).\n• None per_page ( , optional) – Number of results to return per request. It can’t be more than 50.\n• None text_format ( , optional) – Text format of the results (‘dom’, ‘html’, ‘markdown’ or ‘plain’). Searches for a specific song and gets its lyrics. You must pass either a or a .\n• None artist ( , optional) – Name of the artist.\n• None get_full_info ( , optional) – Get full info for each song (slower). On success, the song object is returned, otherwise . Set to to read why the search fails. # same as: song = genius.search_song('To You', 'Andy Shauf')\n• None per_page ( , optional) – Number of results to return per page. It can’t be more than 5 for this method.\n• None per_page ( , optional) – Number of results to return per request. It can’t be more than 50.\n• None text_format ( , optional) – Text format of the results (‘dom’, ‘html’, ‘markdown’ or ‘plain’).\n• None per_page ( , optional) – Number of results to return per request. It can’t be more than 50.\n• None text_format ( , optional) – Text format of the results (‘dom’, ‘html’, ‘markdown’ or ‘plain’).\n\nReturn song’s annotations with associated fragment in list of tuple. Gets the comments on a song. Gets the contributors of a song. Uses BeautifulSoup to scrape song info off of a Genius song URL\n• None text_format ( , optional) – Text format of the results (‘dom’, ‘html’, ‘markdown’ or ‘plain’).\n• None per_page ( , optional) – Number of results to return per request. It can’t be more than 50.\n• None text_format ( , optional) – Text format of the results (‘dom’, ‘html’, ‘markdown’ or ‘plain’). Return song’s annotations with associated fragment in list of tuple.\n• None text_format ( , optional) – Text format of the results (‘dom’, ‘html’, ‘markdown’ or ‘plain’). This method uses , but provides convenient access to fragments (annotated text) and the corresponding annotations (Some fragments may have more than one annotation, because sometimes both artists and Genius users annotate them). Gets the comments on a song.\n• None per_page ( , optional) – Number of results to return per request. It can’t be more than 50.\n• None text_format ( , optional) – Text format of the results (‘dom’, ‘html’, ‘markdown’ or ‘plain’). Gets the contributors of a song. This method will return users who have contributed to this song by editing lyrics or song details. Uses BeautifulSoup to scrape song info off of a Genius song URL You must supply either or song_url`.\n• None remove_section_headers ( , optional) – If , removes [Chorus], [Bridge], etc. headers from lyrics. If it can find the lyrics, otherwise If you pass a song ID, the method will have to make an extra request to obtain the song’s URL and scrape the lyrics off of it. So it’s best to pass the method the song’s URL if it’s available. If you want to get a song’s lyrics by searching for it, use instead. This method removes the song headers based on the value of the attribute.\n\nGets the accounts user follows.\n• None text_format ( , optional) – Text format of the results (‘dom’, ‘html’, ‘markdown’ or ‘plain’). This methods gets the section titled “TOP ACCOMPLISHMENTS” in the user’s profile.\n• None per_page ( , optional) – Number of results to return per request. It can’t be more than 50.\n• None next_cursor ( , optional) – Paginated offset (address of the next cursor). Gets the accounts user follows.\n• None per_page ( , optional) – Number of results to return per request. It can’t be more than 50.\n• None per_page ( , optional) – Number of results to return per request. It can’t be more than 50.\n• None per_page ( , optional) – Number of results to return per request. It can’t be more than 50.\n• None next_cursor ( , optional) – Paginated offset (address of the next cursor).\n• None text_format ( , optional) – Text format of the results (‘dom’, ‘html’, ‘markdown’ or ‘plain’).\n• None type ( , optional) – Type of the contribution (‘annotations’, ‘articles’, ‘pyongs’, ‘questions_and_answers’, ‘comments’, ‘transcriptions’ or ‘unreviewed annotations’). Not all types support a sorting preference. Setting the for these types won’t result in erros, but won’t make a difference in the results either. To find out which types support which features, look at the alias methods. Setting no value for the will return the user’s contributions (regardless of its type) in chronological order; just like visting a user’s profile page and scrolling down, looking at their contributions over time.\n• None per_page ( , optional) – Number of results to return per request. It can’t be more than 50.\n• None next_cursor ( , optional) – Paginated offset (address of the next cursor).\n• None text_format ( , optional) – Text format of the results (‘dom’, ‘html’, ‘markdown’ or ‘plain’).\n• None per_page ( , optional) – Number of results to return per request. It can’t be more than 50.\n• None next_cursor ( , optional) – Paginated offset (address of the next cursor).\n• None text_format ( , optional) – Text format of the results (‘dom’, ‘html’, ‘markdown’ or ‘plain’).\n• None per_page ( , optional) – Number of results to return per request. It can’t be more than 50.\n• None next_cursor ( , optional) – Paginated offset (address of the next cursor).\n• None text_format ( , optional) – Text format of the results (‘dom’, ‘html’, ‘markdown’ or ‘plain’).\n• None per_page ( , optional) – Number of results to return per request. It can’t be more than 50.\n• None next_cursor ( , optional) – Paginated offset (address of the next cursor).\n• None text_format ( , optional) – Text format of the results (‘dom’, ‘html’, ‘markdown’ or ‘plain’).\n• None per_page ( , optional) – Number of results to return per request. It can’t be more than 50.\n• None next_cursor ( , optional) – Paginated offset (address of the next cursor).\n• None text_format ( , optional) – Text format of the results (‘dom’, ‘html’, ‘markdown’ or ‘plain’).\n• None per_page ( , optional) – Number of results to return per request. It can’t be more than 50.\n• None next_cursor ( , optional) – Paginated offset (address of the next cursor).\n• None text_format ( , optional) – Text format of the results (‘dom’, ‘html’, ‘markdown’ or ‘plain’). This method gets user annotations that have the “This annotations is unreviewed” sign above them.\n• None per_page ( , optional) – Number of results to return per request. It can’t be more than 50.\n• None next_cursor ( , optional) – Paginated offset (address of the next cursor).\n• None text_format ( , optional) – Text format of the results (‘dom’, ‘html’, ‘markdown’ or ‘plain’).\n\nGets the videos of an album, article or song or the featured videos.\n• None text_format ( , optional) – Text format of the results (‘dom’, ‘html’, ‘markdown’ or ‘plain’). Gets the videos of an album, article or song or the featured videos.\n• None per_page ( , optional) – Number of results to return per request. It can’t be more than 50.\n• None Genius original video series that the item has been mentioned in. (of) – If you specify no album, article or song, the method will return a series of videos. In this case, if , the results will be the videos in the VIDEOS section on the homepage. But if , the method returns another set of videos that we are not sure what they are at the moment.\n\nMiscellaneous methods that are mostly standalones. Gets the voters of an item. This method parses HTML to extract the hits on the page, so it’s slower than a normal API call which returns the results as JSON.\n• None name ( ) – Name of the tag e.g. or . The name should be as it appears in the URL. For example, the name supplied for R&B is as its URL is https://genius.com/tags/r-b. A dictionary with the following keys: : A list of dictionaries. : Either or . # getting the lyrics of all the songs in the pop tag.\n• None text_format ( , optional) – Text format of the results (‘dom’, ‘html’, ‘markdown’ or ‘plain’). This method requires a logged in user and will raise . Gets the voters of an item. You must supply one of , , or ."
    },
    {
        "link": "https://bigishdata.com/2016/09/27/getting-song-lyrics-from-geniuss-api-scraping",
        "document": "Genius is a great resource. At a high level, Genius has song lyrics and allows users to comment on what the artist meant. Starting as Rap Genius, where users annotated rap lyrics, the site rebranded as “Genius”, allowing all songs to be talked about. According to their website, “Genius is the world’s biggest collection of song lyrics and crowdsourced musical knowledge.” Recently even, they’ve moved to allowing annotations of pretty much anything posted online.\n\nI’ve have used it a bunch recently while trying to figure out what the hell Frank Ocean was trying to say in his new album Blond. Users of the site explained tons of Frank’s references that went whoosh right over my head when I listened the first time and all the times after.\n\nAnd recently, when I had some ideas for mini projects using song lyrics, I was pretty happy to find that Genius had a API for getting the data on their site. Whenever I’m trying to get data elsewhere, I’m much happier with an API, or at least being able to get it from JSON responses rather than parsing HTML. It’s just cleaner to look at, and with an API, I can expect good documentation that isn’t going to change with css updates.\n\nTheir API docs looked pretty good at first glance, with endpoints for artists, songs, albums, and annotations. One things I did notice was that they don’t have an artist entry point. A lot of what I want to do is artist based, meaning I need to know the artist id for everyone. And in order for me to get that, I have to search the artist, grab a song from the results, hit the song endpoint for that song’s information, and then grab the artist id from there. It’d be nice if you could specify what I’m searching for when I hit the search endpoint so I don’t have to go through that whole charade just to get the artist. But that’s a blog post for another time. Overall, they give out tons of information pretty easily.\n\nBut why, Genius, why don’t you have an endpoint for getting the raw lyrics of a song?! You have a songs endpoint on the API, and you give me a ton of information from there — the song title, album name, featured artists on the song, number of annotations, images associated with the song, album information, page views for that song, and a whole host of more data. But the one thing you don’t give me, and the one thing that people using the API probably want the most, is plain text lyrics!\n\nPre-Genius, I was stuck with these jankily laid out sites with super old looking css that would have the lyrics, but not necessarily correct, and definitely no annotations. Those sites are probably easily scrapeable considering their simplicity, but searching for the right song would be more difficult, and the lyrics might not be correct. Genius solved this all now for a web user, but dammit, I want the lyrics in the API!\n\nNow you might be able to get the entire set of lyrics by using the annotations endpoint, which had information about all the annotations for a certain song or article, but that would require a song to have annotations for every word in the song. For someone like Chance the Rapper who like Frank Ocean (and most other hip hop artists uses tons of references in his lyrics, having complete annotations might not be an issue. But of Jake Owen, who’s new single “American Country Love Song” has probably the most self explanatory lyrics ever (sorry for throwing you under the bus here, Jake. Still a fan), there’s no need to annotate anything, and getting the lyrics in this manner wouldn’t work.\n\nThe lyrics are there on the internet however, and I can get at them by hitting the song endpoint, and using the web url that it returns. The rest of this article will show you how to do that using Python and it’s requests and BeautifulSoup libraries. But I don’t have to have to resort to HTML parsing, and I don’t think Genius wants users doing that either.\n\nI’m left here wondering why they don’t want to give up the lyrics so easily, and I really don’t have much to go on. Genius’s goal seems to be wanting to annotate the internet. It has already moved on from their initial site of Rap Genius, into all music, and now into speech transcripts, as well as pretty much any other content on the web. Their value comes from those annotations themselves, not the information they’re annotating. They give away the annotations freely, but not the information (lyrics) in this case.\n\nEnough speculation on why Genius doesn’t spit out the lyrics to a song when you get the other information. And as I’m writing this, I realize I easily could have overlooked something in their API and Genius might return the full lyrics, but I overlooked it. In that case, half of this article will be pointless and I’ll hold my head in shame from yelling at them like I did.\n\nFor purposes here, I’m going to show you how to get the song lyrics from Genius if you have the song title, and also talk through my process of getting there.\n\nNote of clarification, just to make sure I’m not violating their terms of service, this post is for informational purposes only. Hopefully this can help programmers out there learn. Don’t do something bad with this knowledge. Code time!\n\nFirst thing you’re going to need is an account set up with Genius. You can sign up from the upper right hand corner of the genius.com homepage. After that, navigate to the api docs where you’ll then see your Bearer token that you’ll need for all API requests.\n\nI’m using the requests library here, and once you have the bearer token, here’s what all the API requests to Genius should look like if, for example, you’re searching for a song title.\n\nThe response, according to the Genius API, would be a list of songs that match that string passed in, with the first result being the Tom Misch song that I was going for. By changing around the url that is passed into the request method, you can access all the information that Genius supplies from the API (pretty much everything but the lyrics).\n\nLooking at that code above, you’ll probably be wondering how I can confirm that the song I picked off is the correct song I was looking for. For example, if I was looking for the song Capsized by Andrew Bird, and I used that as the search term, I’m probably going to get back more than a few songs titled Capsized. So now, I’m going to add in a little more information to make sure that we get the correct song we’re looking for.\n\nCool, artist disambiguation. Final step here is getting the lyrics for the song itself. And this is going to involve BeautifulSoup. In this case, I want the lyrics from the Decemberists’ “Lake Song”.\n\nRunning the above code with the correct API token, and you should see the lyrics printed out to your console! Great song, listen to it.\n\nIf you look at the raw text within Python, you’ll see that there are some newlines in there that we can remove using a simple text replace for example. Formatting just depends on what you want to do with the output.\n\nAnd with that above code, you should be able to get the lyrics to any song by supplying the name and the artist’s name.\n\nNow one comment I’m sure someone will make is that Genius uses pretty simple url paths, and by knowing the artist and song names, we can probably figure out the path for the lyrics without using the api at all. For example, the song above’s url path that we generate is “http://genius.com/The-decemberists-lake-song-lyrics”. Pretty sure that’s just the artist name, song name and lyrics all sluggified together. But really I’m not just trying to get lyrics for songs here, but rather I’m trying to set up a general way to get info for artists and their songs for future, more complicated use.\n\nComment or let me know if I messed anything up here, or if I read the docs wrong and Genius supplies the lyrics somewhere in the API and I just missed it. I easily could have overlooked it, and I’d like to have this info be correct!\n\nStay tuned for more interesting posts including, but not limited to, which country artist talks about trucks the most."
    },
    {
        "link": "https://genius.com/discussions/277279-Get-the-lyrics-of-a-song",
        "document": "As is well known, we are shipping changes to support Multiple Primary Artists (MPA) in songs and albums\n\nHow to see my User_ID? Hello everyone. I was just trying to build a code that I personally use and I needed my User_ID. The\n\nIs there any chance we’ll see lyric proposal support in the API? Obviously the API doesn’t expose lyrics\n\nHey there! I’ve developed a Music Smart Links creator, and I was wondering if there would be a way to\n\nHey,is there any way of creating a song page without being manual? What I mean is, is there some endpoint\n\nHey all, Is there an API (even if undocumented) that allows for you to query a list of songs by a tag’s\n\nHi, I am trying to create an API which would be used through power bi to generate a report. I am having\n\nProblem with following/unfollowing users (not appears the options) and with sending messages. Hi, I have a big problem with the follow/unfollow users. It does not appear the options to do it\n\nMore specifically, Kraftwerk’s 3-D The Catalogue: several of the songs are simply referred to as their\n\nGetting a list of songs an artist is only featured in? I am looking for a way to be able to get a list of songs that an artist is only featured in. When I\n\nHi, Does it exist any redirect for numeric IDs on Genius? Like on Twitter you can use https://twitter."
    },
    {
        "link": "https://gist.github.com/sinewalker/c636025bfc4bf3cc3e9992f212a40afa",
        "document": "You signed in with another tab or window. Reload to refresh your session.\n\nYou signed out in another tab or window. Reload to refresh your session.\n\nYou switched accounts on another tab or window. Reload to refresh your session."
    },
    {
        "link": "https://stackoverflow.com/questions/23591990/setting-an-id3-comment-using-eyed3-in-python",
        "document": "I don't pretend to understand why this is the way it is, but check out how comments are set in the handy example file:\n\nI believe this has to do with comments being placed into frames, but others may have to chime in with corrections on that. Note that this will fail unless you pass it unicode."
    },
    {
        "link": "https://eyed3.readthedocs.io",
        "document": "eyeD3 is a Python tool for working with audio files, specifically MP3 files containing ID3 metadata (i.e. song info).\n\nIt provides a command-line tool ( ) and a Python library ( ) that can be used to write your own applications or plugins that are callable from the command-line tool.\n\nFor example, to set some song information in an mp3 file called :\n\nWith this command we’ve set the artist ( ), album ( ), title ( ), and track number ( ) properties in the ID3 tag of the file. This is the standard interface that eyeD3 has always had in the past, therefore it is also the default plugin when no other is specified.\n\nThe results of this command can be seen by running the with no options.\n\nThe same can be accomplished using Python.\n\neyeD3 is written and maintained by Travis Shirk and is licensed under version 3 of the GPL."
    },
    {
        "link": "https://stackoverflow.com/questions/41495351/eyed3-package-for-python-not-properly-setting-id3-metadata",
        "document": "For this I am using Python 2.7.13, Windows 10, and the eyed3 package as documented here.\n\nGoal: I am trying to create a script that can input any desired ID3 metadata for MP3 files that are missing information.\n\nProblem: The script appears to update the metadata correctly but fails to add the information to the \"Details\" screen of the MP3 properties (MP3 Details screen). However, if I first manually input data in those fields before running the script, it correctly both adds the metadata and shows it on the Details screen! Another thing I've noticed is that I only need to enter data in at least one field for the script to then populate all of the fields correctly. Doing this seems to initialize and allow access to the fields in some way...\n\nThe eyed3 documentation lists sample code which I have more or less followed exactly in my code here:\n• Is there some hidden separation between ID3 metadata and the actual fields seen on the Details screen of the MP3 properties that I am unaware of?\n• I saw another question regarding an eyed3 issue that was solved by using initTag() when the file doesn't have ID3 tags to begin with. Although I haven't gotten the same error, could my issue be related?\n• Could I be missing an import statement?\n• Should I just try a different Python module for manipulating ID3 metadata?\n\nI've tried all sorts of tests but can't come up with any different results that might point towards a solution.\n\nThanks in advance to anyone who happens to take the time to read this! Any help is appreciated:)"
    },
    {
        "link": "https://eyed3.readthedocs.io/en/latest/plugins/classic_plugin.html",
        "document": ""
    }
]