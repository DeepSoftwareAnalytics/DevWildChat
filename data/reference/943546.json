[
    {
        "link": "https://www3.ntu.edu.sg/home/smitha/fyp_gerald/lwinstruction.html",
        "document": "The LW instruction loads data from the data memory through a , with a , to the \n\n .\n\nThe sample LW instruction demonstrated in the datapath above is LW $26, ($30).\n\nThe instruction's equivalent in binary is:\n\nInformation on the content of the registers used:"
    },
    {
        "link": "https://stackoverflow.com/questions/31563768/mips-lw-load-word-instruction",
        "document": "They are not the same, although in some circumstances they will behave alike. The format of the instruction is as follows:\n\nwhere RegDest and RegSource are MIPS registers, and Offset is an immediate.\n\nIt means, load into register RegDest the word contained in the address resulting from adding the contents of register RegSource and the Offset specified. The resulting source address must be word-aligned (i.e. multiple of 4)\n\nTherefore, means to load in the contents of the word located at address specified by plus 8. As is register which will always contain the constant zero, it will load the word located in absolute address 8 into .\n\nmeans to load in the contents of the word located at the address specified by . If contains the value 8 then both instructions have the same effect. If is not a multiple of 4, the instruction will generate an addressing trap.\n\nUsually is a pseudoinstruction in the sense that the assembler may emmit more than one instruction to accomplish the instruction. The offset (displacement) has to be a 16-bit signed value. If your instruction has an immediate with more bits, the assembler will usually use a temporary register ( ) to hold the contents of the immediate and then emmit equivalent instructions to perform the intended behavior. You may see this in action using a dissassembler or a MIPS monitor (also inspecting the code with MARS simulator)."
    },
    {
        "link": "https://dsi.unive.it/~gasparetto/materials/MIPS_Instruction_Set.pdf",
        "document": ""
    },
    {
        "link": "https://stackoverflow.com/questions/66318645/what-exactly-does-a-mips-lw-instruction-do",
        "document": "Help! I am new to assembly and I am trying to find out what this command does\n\nAlso I understand that the left is the destination and the right is the source\n\nI believe that it write data from one place to another but I do not understand the details.\n\nCould someone please explain the command to me or point me to the right direction?"
    },
    {
        "link": "https://minnie.tuhs.org/CompArch/Resources/mips_quick_tutorial.html",
        "document": "\n• register preceded by $ in assembly language instruction\n\n two formats for addressing:\n• special registers Lo and Hi used to store result of multiplication and division\n• not directly addressable; contents accessed with special instruction mfhi (\"move from Hi\") and mflo (\"move from Lo\")\n• create storage for variable of specified type with given name and specified value\n• value(s) usually gives initial value(s); for storage type .space, gives number of spaces to be allocated\n\nNote: labels always followed by colon ( : ) example var1: .word 3 # create a single integer variable with initial value 3 array1: .byte 'a','b' # create a 2-element character array with elements initialized # to a and b array2: .space 40 # allocate 40 consecutive bytes, with storage uninitialized # could be used as a 40-element character array, or a # 10-element integer array; a comment should indicate which!\n\n#load immediate value into destination register\n• Used only with load and store instructions\n• copy RAM address of var1 (presumably a label defined in the program) into register $t0\n• load word at RAM address contained in $t0 into $t2\n• store word in register $t2 into RAM at address contained in $t0\n• \"4\" gives offset from address in register $t0\n• store word in register $t2 into RAM at address ($t0 - 12) Note: based addressing is especially useful for:\n• stacks; easy to access elements at offset from stack pointer or frame pointer example .data array1: .space 12 # declare 12 bytes of storage to hold array of 3 integers .text __start: la $t0, array1 # load base address of array into register $t0 li $t1, 5 # $t1 = 5 (\"load immediate\") sw $t1, ($t0) # first array element set to 5; indirect addressing li $t1, 13 # $t1 = 13 sw $t1, 4($t0) # second array element set to 13 li $t1, -7 # $t1 = -7 sw $t1, 8($t0) # third array element set to -7 done\n• all operands are registers; no RAM or indirect addressing\n• comparison for conditional branches is built into instruction b target # unconditional branch to program label target beq $t0,$t1,target # branch to target if $t0 = $t1 blt $t0,$t1,target # branch to target if $t0 < $t1 ble $t0,$t1,target # branch to target if $t0 <= $t1 bgt $t0,$t1,target # branch to target if $t0 > $t1 bge $t0,$t1,target # branch to target if $t0 >= $t1 bne $t0,$t1,target # branch to target if $t0 <> $t1 j target # unconditional jump to program label target\n\n jr $t3 # jump to address contained in $t3 (\"jump register\")\n• jump to return address in $ra (stored by jal instruction) Note: return address stored in register $ra; if subroutine will call other subroutines, or is recursive, return address should be copied from $ra onto stack to preserve it, since jal always places return address in this register and hence will overwrite previous value\n• used to read or print values or strings from input/output window, and indicate program end\n• first supply appropriate values in registers $v0 and $a0-$a1\n• result value (if any) returned in register $v0\n• The print_string service expects the address to start a null-terminated character string. The directive .asciiz creates a null-terminated character string.\n• The read_int, read_float and read_double services read an entire line of input up to and including the newline character.\n• The read_string service has the same semantices as the UNIX library routine fgets.\n• It reads up to n-1 characters into a buffer and terminates the string with a null character.\n• If fewer than n-1 characters are in the current line, it reads up to and including the newline and terminates the string with a null character.\n• The sbrk service returns the address to a block of memory containing n additional bytes. This would be used for dynamic memory allocation."
    },
    {
        "link": "https://stackoverflow.com/questions/47373971/mips-assembly-accessing-an-array-while-using-a-variable-as-the-offset",
        "document": "Is there anyway to use a variable as the offset number for an array? For example, I know the normal offset and array works like this:\n\nWhere the index at zero would be loaded into t7, but what I want to do is this:\n\nThis way I could increment the variable t7 as I wanted to in code without having to hard-code the offset. I keep getting a syntax error, so I guess what I am trying to do is wrong. Is there anyway I can do something like this so that I can increment the index of the array?"
    },
    {
        "link": "https://stackoverflow.com/questions/30868639/how-can-i-access-the-individual-elements-of-an-array-in-a-loop",
        "document": "Here is my best attempt at a solution for what you are after.\n\nDisclaimer: I do not know MIPS assembly, I tried to pick up as much as I could to research your question. I could only test this program in an online emulator that did not support printing to the screen (syscall). Do not just blindly paste this code and respond with \"Nope, doesn't work\". If there are any problems please try to be specific and I'll try to figure out the issue.\n\nEditor's notes: looks ok to me, after fixing to make sure there's a zero terminator even if other non-zero data is placed right after it in the .data section.\n\n/ leaves unmodified, so the can be hoisted out of the loop. Some system calls put a return value in , but this one doesn't. (MARS syscall docs)\n\nInstead of a counter starting at 0, we could directly increment the pointer.\n\nTo make this more efficient, we could \"rotate\" the loop so there was a at the bottom (no needed), probably by peeling the first iteration: load and check a char before the loop, then fall into the loop with printing as the first thing. Then increment, load and check the next char and either fall out of the loop or jump to the top to print it, too."
    },
    {
        "link": "https://geeksforgeeks.org/addressing-modes",
        "document": "Addressing modes are the techniques used by the CPU to identify where the data needed for an operation is stored. They provide rules for interpreting or modifying the address field in an instruction before accessing the operand.\n\nAddressing modes for 8086 instructions are divided into two categories:\n\nThe 8086 memory addressing modes provide flexible access to memory, allowing us to easily access variables, arrays, records, pointers, and other complex data types. The key to good assembly language programming is the proper use of memory addressing modes.\n\nAn assembly language program instruction consists of two parts\n\nThe memory address of an operand consists of two components:\n• Effective address or Offset : An offset is determined by adding any combination of three address elements: displacement, base and index.\n• Displacement: It is an 8 bit or 16 bit immediate value given in the instruction.\n\nAccording to different ways of specifying an operand by 8086 microprocessor, different addressing modes are used by 8086.\n• None They allow flexibility in data handling, such as accessing arrays, records, or pointers.\n• None They support program control with techniques like loops, branches, and jumps.\n• None They enable efficient memory usage and program relocation during runtime.\n• None They reduce the complexity of programming by offering multiple ways to access data.\n\nAddressing Modes used by 8086 microprocessor are discussed below:\n\nIn implied addressing the operand is specified in the instruction itself. In this mode the data is 8 bits or 16 bits long and data is the part of instruction. Zero address instruction are designed with implied addressing mode.\n\nIn this mode data is present in address field of instruction .Designed like one address instruction format. Note: Limitation in the immediate mode is that the range of constants are restricted by size of address field.\n\nIn register addressing the operand is placed in one of 8 bit or 16 bit general purpose registers. The data is in the register that is specified by the instruction. Here one register reference is required to access the data.\n\nIn this addressing the operand’s offset is placed in any one of the registers BX,BP,SI,DI as specified in the instruction. The effective address of the data is in the base register or an index register that is specified by the instruction. Here two register reference is required to access the data. The 8086 CPUs let you access memory indirectly through a register using the register indirect addressing modes.\n\nEffective address of the operand is the contents of a register specified in the instruction. After accessing the operand, the contents of this register are automatically incremented to point to the next consecutive memory location.(R1)+. Here one register reference, one memory reference and one ALU operation is required to access the data. Example:\n\nUseful for stepping through arrays in a loop. R2 – start of array d – size of an element\n\nEffective address of the operand is the contents of a register specified in the instruction. Before accessing the operand, the contents of this register are automatically decremented to point to the previous consecutive memory location. –(R1)Here one register reference, one memory reference and one ALU operation is required to access the data. Example:\n\nAuto decrement mode is same as auto increment mode. Both can also be used to implement a stack as push and pop . Auto increment and Auto decrement modes are useful for implementing “Last-In-First-Out” data structures.\n\nThe operand’s offset is given in the instruction as an 8 bit or 16 bit displacement element. In this addressing mode the 16 bit effective address of the data is the part of the instruction. Here only one memory reference operation is required to access the data.\n\nIn this mode address field of instruction contains the address of effective address. Here two references are required. 1st reference to get effective address. 2nd reference to access the data. Based on the availability of Effective address, Indirect mode is of two kind:\n• Register Indirect: In this mode effective address is in the register, and corresponding register name will be maintained in the address field of an instruction. Here one register reference, one memory reference is required to access the data.\n• Memory Indirect : In this mode effective address is in the memory, and corresponding memory address will be maintained in the address field of an instruction. Here two memory reference is required to access the data.\n\nThe operand’s offset is the sum of the content of an index register SI or DI and an 8 bit or 16 bit displacement.\n\nThe operand’s offset is sum of the content of a base register BX and an index register SI or DI.\n\nBased on Transfer of control, addressing modes are:\n\nPC relative addressing mode is used to implement intra segment transfer of control, In this mode effective address is obtained by adding displacement to PC.\n\nBase register addressing mode is used to implement inter segment transfer of control. In this mode effective address is obtained by adding base register value to address field value.\n• None PC relative and based register both addressing modes are suitable for program relocation at runtime.\n• None Based register addressing mode is best suitable to write position independent codes.\n• None Enable advanced programming techniques like pointers and counters for loops.\n• None Reduce the size of the instruction field, making the program more efficient.\n\nWhat are the addressing modes of 8085?\n\nWhat is opcode and operand?\n\nWhat is an effective address?\n\nMatch each of the high level language statements given on the left hand side with the most natural addressing mode from those listed on the right hand side.\n\nHence (C) is correct solution"
    },
    {
        "link": "https://web.engr.oregonstate.edu/~walkiner/cs271-wi13/slides/07-MoreAssemblyProgramming.pdf",
        "document": ""
    },
    {
        "link": "https://reddit.com/r/learnprogramming/comments/1a11wb/mips_help_with_incrementing_through_an_array",
        "document": "I am using notepad to write the code, then save it as a .s file to be loaded and run in QTSpim. The program is meant to look at each element in the array, and count up the number of positive and negative numbers (the number of positive being stored in $s0, and the number of negative being stored in $s7). The code is below:\n\nLOOP: beq $t0,$t4,OUT # go to label 'OUT' when out of array bounds\n\nWhen I try to load it, QTSpim returns an error window that reads \"spim (parser) syntax error on line 9 of file\" with an arrow pointing specifically to the section of the code above placed in <> brackets (line 1 below label: LOOP).\n\nI think I'm having a problem with the way I'm trying to load words out of the array, but I'm not sure if I'm incrementing through it correctly either. Any help would be appreciated, thanks.\n\nEDIT: I made a change in the error line to lw $t1,array and the program now runs in QTSpim, but $s0 ends up with value a, while $s7 has value 0 meaning either it is counting all of the numbers as positive, or the branches aren't working correctly. I've been busy most of the day, but I will continue working on it now. Thanks to everyone for the help."
    }
]