[
    {
        "link": "https://stackoverflow.com/questions/8800/best-implementation-for-key-value-pair-data-structure",
        "document": "So I've been poking around with C# a bit lately, and all the Generic Collections have me a little confused. Say I wanted to represent a data structure where the head of a tree was a key value pair, and then there is one optional list of key value pairs below that (but no more levels than these). Would this be suitable?\n\nIt's only really a simple shunt for passing around data."
    },
    {
        "link": "https://geeksforgeeks.org/c-sharp-dictionary-with-examples",
        "document": "Dictionary in C# is a generic collection that stores key-value pairs. The working of Dictionary is quite similar to the non-generic hashtable. The advantage of a Dictionary is, that it is a generic type. A dictionary is defined under System.Collections.Generic namespace. It is dynamic in nature means the size of the dictionary is growing according to the need.\n• Key-Value Pair: The value is stored in the Key-Value pair.\n• Efficient Lookup : It provides fast lookups for values based on keys.\n\nThe dictionary can be created in different ways using Dictionary Class. Here, we are using the Dictionary<TKey, TValue>() constructor used to create an instance of the Dictionary<TKey, TValue> class by default initial capacity is empty, and uses the default equality comparison for the key type.\n• Add(): This method to add key/value pairs in your Dictionary.\n• Collection-Initializer: We can also use a collection initializer to add elements to the dictionary.\n• Using Indexers: We can directly add the elements by indexes.\n\nThe key-value pair of the Dictionary is accessed using three different ways:\n\nUsing For Loop: We can use a to access the key-value pairs of the Dictionary.\n\nUsing Index: We can access individual key-value pairs of the Dictionary by using its index value. We can specify the key in the index to get the value from the given dictionary, no need to specify the index. The indexer always takes the key as a parameter\n\nNote: If the given key is not available in the dictionary, then it gives KeyNotFoundException.\n\nExample: Creating and Displaying a Dictionary with Add()\n\nIn the Dictionary, we are allowed to remove elements from the Dictionary. Dictionary<TKey, TValue> class provides two different methods to remove elements that are:\n• Clear: This method removes all keys and values from the Dictionary<TKey, TValue>.\n• Remove: This method removes the value with the specified key from the Dictionary<TKey, TValue>.\n\nIn Dictionary, we can check whether the given key or value is present in the specified dictionary or not. The Dictionary<TKey, TValue> class provides two different methods which are:\n• ContainsKey: This method is used to check whether the Dictionary<TKey, TValue> contains the specified key.\n• ContainsValue: This method is used to check whether the Dictionary<TKey TValue> contains a specific value.\n• None In theDictionary, the key cannot be null, but the value can be.\n• None In Duplicate keys are not allowed. If we add a duplicate key then the compiler will throw an exception.\n• None In the Dictionary, we can only store the same types of elements.\n• None The capacity of a Dictionary is the number of elements that a Dictionary can hold."
    },
    {
        "link": "https://stackoverflow.com/questions/9890822/best-way-to-add-key-value-pairs-to-a-dictionary-in-c-sharp",
        "document": "I am using a dictionary in C# to store some key-value pairs and had a question on the best way to populate the dictionary.\n\nI need to do some other operations in order to find and add my key-value pairs to my dictionary. After those operations I may have found a key-value to add to the dictionary or I could have found nothing.\n\nMy question is how I should populate the dictionary?\n• None Should I use a function that returns a key-value pair if found and otherwise an empty one contained within a dictionary.Add(function()) call? I don't want to add an empty key-value pair to the dictionary, so I'm not sure how the return call for that function would work, or\n• None Should I pass the dictionary to the function and add to it if needed? Like:"
    },
    {
        "link": "https://medium.com/@devnurai/complete-guide-to-dictionaries-in-c-939cea760531",
        "document": "In C#, the class in provides an efficient way to store and retrieve data in key-value pairs. This data structure is powerful, versatile, and highly optimized for quick data lookups, making it ideal for various real-world programming scenarios.\n\nThis article will give you an in-depth understanding of the in C#—its structure, properties, methods, and usage examples.\n\nWhat is a Dictionary in C#?\n\nA is a generic collection that stores data as key-value pairs. Each key in the dictionary is unique and maps to a value. Dictionaries in C# provide O(1) time complexity for operations like adding, retrieving, and deleting data if an efficient hash function is in place, making them an excellent choice for high-performance applications.\n\nTo declare a dictionary, specify two types:\n• TKey: the type of keys in the dictionary.\n• TValue: the type of values associated with each key.\n\nIn this example, uses as the key type and as the value type.\n• Count: Returns the number of key-value pairs in the dictionary.\n• Keys: Returns a collection of all keys in the dictionary.\n• Values: Returns a collection of all values in the dictionary.\n• Comparer: Gets the equality comparer used for comparing keys.\n\nHere’s an example showing how to use these properties:\n\nTo add elements to a dictionary, use the method or the indexer syntax :\n\nNote: If you attempt to add a duplicate key with , an will be thrown. However, the indexer syntax will update the value if the key already exists.\n\nThe most common way to retrieve a value is by using the key:\n\nIf the key does not exist, a will be thrown. To handle this safely, use , which returns if the key exists and sets the parameter to the associated value:\n\nTo update an existing value, use the indexer syntax with the key:\n\nIf the key exists, the associated value will be updated; if the key doesn’t exist, a new key-value pair will be added.\n\nTo remove an item by its key, use :\n\nThis method returns if the element was successfully removed; otherwise, it returns .\n\nChecking for the Existence of a Key or Value\n\nTo check if a specific key or value exists in the dictionary, use or :\n\nA can be iterated using , where each element is a :\n\nAlternatively, you can iterate over just the keys or values using and properties.\n\nDictionaries can be initialized at the time of declaration using a collection initializer:\n\nThe class offers multiple constructors for different scenarios:\n\nDictionary(int capacity): Initializes a dictionary with a specified capacity, which can improve performance if the size is known.\n\nDictionary(IEqualityComparer<TKey>): Initializes a dictionary with a specified equality comparer for custom key comparisons.\n\nBy default, dictionaries use the default equality comparer for the key type. You can provide a custom equality comparer by implementing . This can be particularly useful for case-insensitive string keys:\n\nThe class is not thread-safe. If multiple threads are modifying a dictionary concurrently, it could cause unpredictable behavior. For thread-safe operations, use the from .\n\nDictionaries are highly efficient due to their O(1) complexity for retrieval, insertion, and deletion in most cases, thanks to hashing. However, performance can degrade with poor hash functions, leading to increased collisions and slower operations.\n\nDictionaries in C# can throw the following exceptions:\n• ArgumentNullException: If a null key is used.\n• ArgumentException: If a duplicate key is added with .\n• KeyNotFoundException: If a key not present in the dictionary is accessed.\n\nThe following example demonstrates basic dictionary operations:\n\nSummary of Dictionary in C#\n\nIn C#, the class is an essential data structure for storing key-value pairs with high efficiency. It provides a wide range of functionalities for adding, retrieving, updating, and removing elements and is optimized for rapid data access. The dictionary allows for customization through equality comparers and supports various initialization methods, making it versatile for many use cases.\n\nWhile dictionaries are not inherently thread-safe, the offers a safe alternative for multi-threaded applications. Whether you’re developing simple or complex applications, dictionaries in C# are a robust, high-performance solution for organizing data as key-value pairs."
    },
    {
        "link": "https://stackify.com/c-dictionary-how-to-create-one-and-best-practices",
        "document": "C# Dictionary: How to Create One and Best Practices\n\nThe C# dictionary is one of the most important collection types/data structures you’ll use while developing your applications. You can use a dictionary to solve certain kinds of problems in a way that’s much more natural and elegant than using, say, a list. There are also significant performance gains you can obtain by using dictionaries.\n\nThat’s what this post is about: a detailed introduction to this powerful collection type. We’ll cover:\n• How to create and initialize a dictionary\n• What are the main methods you must know\n• Performance considerations, common use cases, and best practices\n\nLet’s start by covering some C# dictionary fundamentals.\n\nWhat Is a Dictionary in C#?\n\nIn C#, the dictionary class allows you to create a collection of key-value pairs. A key is a unique identifier through which you can later retrieve the value. And the value is whatever you need to store and later retrieve.\n\nWhat is a dictionary good for? There are certain performance-sensitive scenarios in which dictionaries shine, and we’ll cover more of that later. But in general, dictionaries are well-suited for when you need to retrieve a unique value based on its identifier, in an efficient way.\n\nUsing a dictionary in C# allows you to:\n• Add elements associating them with a given key\n• Retrieve an element by its key\n• Verifying whether a given key is already present in the dictionary\n• Count how many elements are in the dictionary\n• Iterate through all key-value pairs using a foreach loop\n• Obtain a list of all the keys, values, and key-value pairs\n\nTime to roll up your sleeves and learn how to work with a C# dictionary.\n\nHow to Declare and Initialize a Dictionary\n\nThe easiest way to declare a dictionary is using the class’s constructor to initialize an empty one:\n\nIn the example above, we create a dictionary whose keys are of type int and values are of type string.\n\nLet’s say that you would like to use the dictionary from the previous example to store the names of the months, in relation to their numbers, in a one-based fashion. Use the Add method, passing first the key and then the value as arguments:\n\nAlternatively, it is also possible to create the dictionary and add the items in one go:\n\nThe astute readers will remember that, when defining the dictionary, the key must be unique. So, what happens when you try to add an element with an already existing key? You get an exception, of course. Let’s say that after initializing the dictionary with all twelve months, you try to add another value with the key 12.\n\nYou would get a System.ArgumentException with the following message: ‘An item with the same key has already been added. Key: 12’.\n\nThese aren’t all the ways you can initialize a dictionary, but the examples are certainly the most common ones.\n\nLet’s cover the most common methods from the Dictionary class.\n\nYou access dictionary elements using its indexer and providing a key. In the following example, we retrieve the names of all months by using numbers from 1 to 12 as the keys:\n\nWhat happens if you pass the dictionary a key it doesn’t contain? You get an exception. More specifically, a System.Collections.Generic.KeyNotFoundException. And that ties nicely with the next topic.\n\nChecking for Key or Value Existence\n\nIf, within your code, you can’t know for sure whether a key exists, then you should verify its presence before you try to access it. The same applies when adding elements: if you don’t know whether a key has already been added to the dictionary, check first. You can do that by using the ContainsKey() method:\n\nUnlike keys, it’s completely valid for a dictionary to have duplicated values. Duplicate values may or may not make sense for your specific use case, and that’s why you might have to use the ContainsValue() method to check for a value’s presence.\n\nAlternatively, a more performant way to test for the existence of a value and getting it at the same time is using the TryGetValue() method.\n\nThe regular Dictionary class in C# is mutable, which means you can change the values you added to it. See the following example:\n\nUse the Remove() method to remove an element from a dictionary. This method has a few overloads, but the most well-known one receives a single argument, representing the key for the pair you wish to remove.\n\nThis method returns true if the specified key was found and the associate pair was removed, and false otherwise. That means this method, unlike others we’ve seen before, doesn’t throw an error when you provide a key that can’t be found.\n\nWhat if you wanted to remove all items from the dictionary in one go? In that case, the Clear() method is what you’re looking for:\n\nThere are several ways to iterate over a dictionary using a foreach loop. For starters, here’s our sample dictionary for this example:\n\nNotice two things of interest here:\n• We’ve used the target type new expressions feature of C#\n• We’ve used a different, simpler syntax to add elements to our dictionary\n\nWith that in place, let’s start by first iterating through the key-value pairs (the code below uses explicit typing for the foreach variable, but of course, we can type inference as well):\n\nLet’s do it again, but this time using the deconstruction syntax introduced in C# 7:\n\nFinally, let’s see how to iterate over only the keys and then only the values:\n\nGenerally speaking, dictionaries are fast. Here’s what .NET’s documentation has to say about element retrieval:\n\nIf you don’t know what “O(1)” means, you should learn about “time complexity” and “Big-O notation.” In short, the sentence above means that retrieving a value by its key takes a fixed time, regardless of the number of elements in the dictionary.\n\nThat isn’t true 100% of the time, though:\n\nThe type used as key should have a sound algorithm for its GetHashCode() method. If different objects return the same code – in other words if there are collisions – the performance of lookups will be impacted.\n\nDictionaries excel in scenarios in which you need fast retrieval of an element based on its associated key. Considering this, here’s a non-exhaustive list of common use cases for dictionaries:\n• Counting occurrences of certain pieces of data\n\nBest Practices for Using Dictionaries\n\nBefore wrapping up, let’s cover some dictionary best practices you should be aware of:\n• Avoid exceptions when working with keys by proactively checking in scenarios in which you can’t know for sure\n• Prefer TryGetValue() when retrieving elements, because it’s faster than using Contains() then indexer, in scenarios where it’s very common for values to not be in the dictionary\n• When it comes to key types, choose immutable types that implement GetHashCode correctly\n• Consider setting an initial capacity when initializing the dictionary, if you know the maximum length the dictionary will get. This avoids internal resizes and improves performance\n• When dictionary is no longer needed, you can use Clear() to remove all key-value pairs, relieving some pressure from the garbage collector\n\nIn this post, you’ve learned what a dictionary is and how and when to use it. As you’ve seen, dictionaries are great when you need a fast lookup of values. That doesn’t mean, however, that dictionaries are entirely free of potential pitfalls when it comes to performance. For instance, dictionaries have a bigger memory footprint than, say, lists, because of how they’re implemented internally (dictionaries potentially need to have several arrays and linked lists).\n\nSo, this bigger overhead is something you should be aware of and, in scenarios where the fast lookup of dictionaries doesn’t make a difference, consider picking another type.\n\nAlso, regardless of whether you’re using dictionaries, it’s great to have the support of an application monitoring tool for your applications that alerts you at the first sign of potential performance problems. In that spirit, we invite you to start your free trial of Stackify today."
    },
    {
        "link": "https://medium.com/@hanxuyang0826/mastering-dfs-and-bfs-in-c-techniques-implementations-and-leetcode-examples-57dbe66a140c",
        "document": "In this blog post, we will explore two fundamental graph traversal algorithms: Depth-First Search (DFS) and Breadth-First Search (BFS). These algorithms are essential tools for solving many programming problems that involve traversing or searching through data structures such as trees and graphs. Both DFS and BFS have distinct ways of exploring nodes and edges, making them suitable for different types of problems, from finding the shortest path in a maze to counting connected components in a network.\n\nWe will cover the core concepts behind DFS and BFS, how they work, and the scenarios where one is preferred over the other. Additionally, we will implement these algorithms in C# and dive into real-world applications, particularly in geometry and pathfinding. We will also look at common problems on platforms like LeetCode, where DFS and BFS can be used to effectively solve challenges such as traversing matrices, finding islands in grids, and solving puzzles. Understanding how and when to use these algorithms will help improve both your problem-solving skills and code efficiency."
    },
    {
        "link": "https://geeksforgeeks.org/depth-first-search-or-dfs-for-a-graph",
        "document": "Depth First Search or DFS for a Graph\n\nIn Depth First Search (or DFS) for a graph, we traverse all adjacent vertices one by one. When we traverse an adjacent vertex, we completely finish the traversal of all vertices reachable through that adjacent vertex. This is similar to a tree, where we first completely traverse the left subtree and then move to the right subtree. The key difference is that, unlike trees, graphs may contain cycles (a node may be visited more than once). To avoid processing a node multiple times, we use a boolean visited array.\n\nNote : There can be multiple DFS traversals of a graph according to the order in which we pick adjacent vertices. Here we pick vertices as per the insertion order. Output: 1 0 2 3 4\n\nExplanation: The source vertex s is 1. We visit it first, then we visit an adjacent. \n\nStart at 1: Mark as visited. Output: 1\n\nMove to 0: Mark as visited. Output: 0 (backtrack to 1)\n\nMove to 2: Mark as visited. Output: 2 (backtrack to 0)\n\nMove to 3: Mark as visited. Output: 3 (backtrack to 2)\n\nMove to 4: Mark as visited. Output: 4 (backtrack to 2) Not that there can be more than one DFS Traversals of a Graph. For example, after 1, we may pick adjacent 2 instead of 0 and get a different DFS. Here we pick in the insertion order. Start at 0: Mark as visited. Output: 0\n\nMove to 2: Mark as visited. Output: 2\n\nMove to 4: Mark as visited. Output: 4 (backtrack to 2, then backtrack to 0)\n\nMove to 3: Mark as visited. Output: 3 (backtrack to 0)\n\nMove to 1: Mark as visited. Output: 1\n\nDFS from a Given Source of Undirected Graph:\n\nThe algorithm starts from a given source and explores all reachable vertices from the given source. It is similar to Preorder Tree Traversal where we visit the root, then recur for its children. In a graph, there might be loops. So we use an extra visited array to make sure that we do not process a vertex again.\n\nLet us understand the working of Depth First Search with the help of the following illustration: for the source as 0.\n\nBelow is the implementation of the above approach:\n\n// that are not visited yet // To add an edge in an undirected graph // Traverse all adjacent vertices that are not visited yet // Function to add an edge to the adjacency list // Define the edges of the graph // Recursively visit all adjacent vertices that are // Function to add an edge to the adjacency list // Number of vertices in the graph // Create an adjacency list for the graph // Define the edges of the graph # that are not visited yet # Create an adjacency list for the graph # Define the edges of the graph // that are not visited yet // Create an adjacency list for the graph // Define the edges of the graph // Recursively visit all adjacent vertices that are not // Number of vertices in the graph // Create an adjacency list for the graph // Define the edges of the graph\n\nTime complexity: O(V + E), where V is the number of vertices and E is the number of edges in the graph.\n\nAuxiliary Space: O(V + E), since an extra visited array of size V is required, And stack size for recursive calls to DFSRec function.\n\nPlease refer Complexity Analysis of Depth First Search: for details.\n\nThe above implementation takes a source as an input and prints only those vertices that are reachable from the source and would not print all vertices in case of disconnected graph. Let us now talk about the algorithm that prints all vertices without any source and the graph maybe disconnected.\n\nThe idea is simple, instead of calling DFS for a single vertex, we call the above implemented DFS for all all non-visited vertices one by one.\n\n// Recursively visit all adjacent vertices that are not visited yet // Main DFS function to perform DFS for the entire graph // Loop through all vertices to handle disconnected graph // If vertex i has not been visited, // Create an adjacency list for the graph // Define the edges of the graph // Function to add an edge to the adjacency list // Add edge from t to s (for undirected graph) // Traverse all adjacent vertices that are not visited yet // Main DFS function to perform DFS for the entire graph // Loop through all vertices to handle disconnected graph // If vertex i has not been visited, // Define the edges of the graph // Function to add an edge to the adjacency list // Recursively visit all adjacent vertices that are // Main DFS function to perform DFS for the entire graph // Loop through all vertices to handle disconnected // Create an adjacency list for the graph // Define the edges of the graph # that are not visited yet # Loop through all vertices to handle disconnected # Define the edges of the graph // Function to add an edge to the adjacency list // that are not visited yet // Main DFS function to perform DFS for the entire graph // Loop through all vertices to handle // If vertex i has not been visited, // Create an adjacency list for the graph // Define the edges of the graph using tuples // Recursively visit all adjacent vertices that are not // Main DFS function to perform DFS for the entire graph // Loop through all vertices to handle disconnected // Create an adjacency list for the graph // Define the edges of the graph\n\nTime complexity: O(V + E). Note that the time complexity is same here because we visit every vertex at most once and every edge is traversed at most once (in directed) and twice in undirected.\n\nAuxiliary Space: O(V + E), since an extra visited array of size V is required, And stack size for recursive calls to DFSRec function.\n• None Depth First Search or DFS on Directed Graph\n• None Breadth First Search or BFS for a Graph"
    },
    {
        "link": "https://stackoverflow.com/questions/5804844/implementing-depth-first-search-into-c-sharp-using-list-and-stack",
        "document": "As others have noted, you are pushing the nodes-to-visit-next on the stack in order from left to right. That means they get popped off right-to-left, since a stack reverses the order. Stacks are last-in-first-out.\n\nYou can fix the problem by making GetConnectedVertices build a stack, not a list. That way the connected vertices are reversed twice, once when they go on the returned stack and once when they go on the real stack.\n\nThe implementation works, I suppose, but it has a great many fundamental problems. If I were presented that code for review, here's what I'd say:\n\nFirst off, suppose you wanted to do two depth-first searches of this data structure at the same time. Either because you were doing it on multiple threads, or because you have a nested loop in which the inner loop does a DFS for a different element than the outer loop. What happens? They interfere with each other because both try to mutate the \"State\" and \"VisitNumber\" fields. It is a really bad idea to have what should be a \"clean\" operation like searching actually make your data structure \"dirty\".\n\nDoing so also makes it impossible for you to use persistent immutable data to represent redundant portions of your graph.\n\nAlso, I notice that you omit the code that cleans up. When is \"State\" ever set back to its original value? What if you did a second DFS? It would immediately fail since the root is already visited.\n\nA better choice for all these reasons is to keep the \"visited\" state in its own object, not in each vertex.\n\nNext, why are all the state objects private variables of a class? This is a simple algorithm; there's no need to build an entire class for it. A depth first search algorithm should take the graph to search as a formal parameter, not as object state, and it should maintain its own local state as necessary in local variables, not fields.\n\nNext, the abstraction of the graph is... well, its not an abstraction. It's two lists, one of vertices and one of edges. How do we know that those two lists are even consistent? Suppose there are vertices that are not in the vertex list but are on the edge list. How do you prevent that? What you want is a graph abstraction. Let the graph abstraction implementation worry about how to represent edges and find neighbours.\n\nNext, your use of ForEach is both legal and common, but it makes my head hurt. It is hard to read your code and reason about it with all the lambdas. We have a perfectly good \"foreach\" statement. Use it.\n\nNext, you are mutating a \"parent\" property but it is not at all clear what this property is for or why it is being mutated during a traversal. Vertices in an arbitrary graph do not have \"parents\" unless the graph is a tree, and if the graph is a tree then there is no need to keep track of the \"visited\" state; there are no loops in a tree. What is going on here? This code is just bizarre, and it is not necessary to perform a DFS.\n\nNext, your helper method named GetConnectedVertices is a lie. It does not get connected vertices, it gets connected not-already-visited vertices. Methods whose names lie are very confusing.\n\nFinally, this claims to be a depth first search but it doesn't search for anything! Where is the thing being searched for? Where is the result returned? This isn't a search at all, it's a traversal.\n\nStart over. What do you want? A depth-first traversal of a graph given a starting vertex. Then implement that. Start by defining what you are traversing. A graph. What service do you need from a graph? A way of getting the set of neighbouring vertices:\n\nWhat is your method returning? A sequence of Vertices in depth-first order. What does it take? A starting vertex. OK:\n\nWe now have a trivial implementation of depth first search; you can now use the Where clause:\n\nOK, so how are we going to implement that method so it does a traversal without wrecking the graph's state? Maintain your own external state:\n\nSee how much cleaner and shorter that is? No mutation of state. No mucking around with edge lists. No badly-named helper functions. And the code actually does what it says it does: traverses a graph.\n\nWe also get the benefits of iterator blocks; namely, if someone is using this for a DF search, then the iteration is abandoned when the search criteria are met. We don't have to do a full traversal if we find the result early."
    },
    {
        "link": "https://medium.com/@sadigrzazada20/depth-first-search-dfs-c8658b7c2421",
        "document": "Depth-First Search (DFS) is a fundamental graph traversal algorithm that explores a graph or tree structure by visiting nodes as deeply as possible along each branch before backtracking. It’s often used to traverse and search through data structures like graphs and trees. DFS can be implemented using recursion or an explicit stack data structure.\n• Start at the initial node (or root node) of the graph/tree.\n• Mark the current node as visited to avoid revisiting it later.\n• Explore each unvisited neighbor of the current node by recursively applying the DFS algorithm to them.\n• If there are no unvisited neighbors, backtrack to the previous node and continue exploring other branches.\n• Repeat steps 2–4 until all nodes have been visited.\n\nDFS has two main variants: the standard DFS and the recursive DFS. The recursive version is often easier to implement and understand, while the explicit stack version can be more memory-efficient and avoids potential stack overflow issues in deep graphs.\n\nSure, here’s a simple implementation of Depth-First Search (DFS) in C# for traversing a graph represented using an adjacency list:"
    },
    {
        "link": "https://programiz.com/dsa/graph-dfs",
        "document": "Depth first Search or Depth first traversal is a recursive algorithm for searching all the vertices of a graph or tree data structure. Traversal means visiting all the nodes of a graph.\n\nA standard DFS implementation puts each vertex of the graph into one of two categories:\n\nThe purpose of the algorithm is to mark each vertex as visited while avoiding cycles.\n\nThe DFS algorithm works as follows:\n• Start by putting any one of the graph's vertices on top of a stack.\n• Take the top item of the stack and add it to the visited list.\n• Create a list of that vertex's adjacent nodes. Add the ones which aren't in the visited list to the top of the stack.\n• Keep repeating steps 2 and 3 until the stack is empty.\n\nLet's see how the Depth First Search algorithm works with an example. We use an undirected graph with 5 vertices.\n\nWe start from vertex 0, the DFS algorithm starts by putting it in the Visited list and putting all its adjacent vertices in the stack.\n\nNext, we visit the element at the top of stack i.e. 1 and go to its adjacent nodes. Since 0 has already been visited, we visit 2 instead.\n\nVertex 2 has an unvisited adjacent vertex in 4, so we add that to the top of the stack and visit it.\n\nAfter we visit the last element 3, it doesn't have any unvisited adjacent nodes, so we have completed the Depth First Traversal of the graph.\n\nThe pseudocode for DFS is shown below. In the init() function, notice that we run the DFS function on every node. This is because the graph might have two different disconnected parts so to make sure that we cover every vertex, we can also run the DFS algorithm on every node.\n\nThe code for the Depth First Search Algorithm with an example is shown below. The code has been simplified so that we can focus on the algorithm rather than other details.\n\nThe time complexity of the DFS algorithm is represented in the form of , where is the number of nodes and is the number of edges.\n\nThe space complexity of the algorithm is .\n• To test if the graph is bipartite\n• For finding the strongly connected components of a graph"
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.dictionary-2?view=net-9.0",
        "document": "The following code example creates an empty Dictionary<TKey,TValue> of strings with string keys and uses the Add method to add some elements. The example demonstrates that the Add method throws an ArgumentException when attempting to add a duplicate key.\n\nThe example uses the Item[] property (the indexer in C#) to retrieve values, demonstrating that a KeyNotFoundException is thrown when a requested key is not present, and showing that the value associated with a key can be replaced.\n\nThe example shows how to use the TryGetValue method as a more efficient way to retrieve values if a program often must try key values that are not in the dictionary, and it shows how to use the ContainsKey method to test whether a key exists before calling the Add method.\n\nThe example shows how to enumerate the keys and values in the dictionary and how to enumerate the keys and values alone using the Keys property and the Values property.\n\nFinally, the example demonstrates the Remove method.\n\nThe Dictionary<TKey,TValue> generic class provides a mapping from a set of keys to a set of values. Each addition to the dictionary consists of a value and its associated key. Retrieving a value by using its key is very fast, close to O(1), because the Dictionary<TKey,TValue> class is implemented as a hash table.\n\nAs long as an object is used as a key in the Dictionary<TKey,TValue>, it must not change in any way that affects its hash value. Every key in a Dictionary<TKey,TValue> must be unique according to the dictionary's equality comparer. A key cannot be , but a value can be, if its type is a reference type.\n\nDictionary<TKey,TValue> requires an equality implementation to determine whether keys are equal. You can specify an implementation of the IEqualityComparer<T> generic interface by using a constructor that accepts a parameter; if you do not specify an implementation, the default generic equality comparer EqualityComparer<T>.Default is used. If type implements the System.IEquatable<T> generic interface, the default equality comparer uses that implementation.\n\nThe capacity of a Dictionary<TKey,TValue> is the number of elements the Dictionary<TKey,TValue> can hold. As elements are added to a Dictionary<TKey,TValue>, the capacity is automatically increased as required by reallocating the internal array.\n\n.NET Framework only: For very large Dictionary<TKey,TValue> objects, you can increase the maximum capacity to 2 billion elements on a 64-bit system by setting the attribute of the configuration element to in the run-time environment.\n\nFor purposes of enumeration, each item in the dictionary is treated as a KeyValuePair<TKey,TValue> structure representing a value and its key. The order in which the items are returned is undefined.\n\nThe statement of the C# language ( in C++, in Visual Basic) returns an object of the type of the elements in the collection. Since the Dictionary<TKey,TValue> is a collection of keys and values, the element type is not the type of the key or the type of the value. Instead, the element type is a KeyValuePair<TKey,TValue> of the key type and the value type. For example:\n\nThe statement is a wrapper around the enumerator, which allows only reading from the collection, not writing to it.\n\nA Dictionary<TKey,TValue> can support multiple readers concurrently, as long as the collection is not modified. Even so, enumerating through a collection is intrinsically not a thread-safe procedure. In the rare case where an enumeration contends with write accesses, the collection must be locked during the entire enumeration. To allow the collection to be accessed by multiple threads for reading and writing, you must implement your own synchronization.\n\nFor thread-safe alternatives, see the ConcurrentDictionary<TKey,TValue> class or ImmutableDictionary<TKey,TValue> class.\n\nPublic static ( in Visual Basic) members of this type are thread safe."
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/collections",
        "document": "The .NET runtime provides many collection types that store and manage groups of related objects. Some of the collection types, such as System.Array, System.Span<T>, and System.Memory<T> are recognized in the C# language. In addition, interfaces like System.Collections.Generic.IEnumerable<T> are recognized in the language for enumerating the elements of a collection.\n\nCollections provide a flexible way to work with groups of objects. You can classify different collections by these characteristics:\n• Element access: Every collection can be enumerated to access each element in order. Some collections access elements by index, the element's position in an ordered collection. The most common example is System.Collections.Generic.List<T>. Other collections access elements by key, where a value is associated with a single key. The most common example is System.Collections.Generic.Dictionary<TKey,TValue>. You choose between these collection types based on how your app accesses elements.\n• Performance profile: Every collection has different performance profiles for actions like adding an element, finding an element, or removing an element. You can pick a collection type based on the operations used most in your app.\n• Grow and shrink dynamically: Most collections support adding or removing elements dynamically. Notably, Array, System.Span<T>, and System.Memory<T> don't.\n\nIn addition to those characteristics, the runtime provides specialized collections that prevent adding or removing elements or modifying the elements of the collection. Other specialized collections provide safety for concurrent access in multi-threaded apps.\n\nYou can find all the collection types in the .NET API reference. For more information, see Commonly Used Collection Types and Selecting a Collection Class.\n\nArrays are represented by System.Array and have syntax support in the C# language. This syntax provides more concise declarations for array variables.\n\nSystem.Span<T> is a type that provides a snapshot over a sequence of elements without copying those elements. The compiler enforces safety rules to ensure the can't be accessed after the sequence it references is no longer in scope. It's used in many .NET APIs to improve performance. Memory<T> provides similar behavior when you can't use a type.\n\nBeginning with C# 12, all of the collection types can be initialized using a Collection expression.\n\nAn indexable collection is one where you can access each element using its index. Its index is the number of elements before it in the sequence. Therefore, the element reference by index is the first element, index is the second, and so on. These examples use the List<T> class. It's the most common indexable collection.\n\nThe following example creates and initializes a list of strings, removes an element, and adds an element to the end of the list. After each modification, it iterates through the strings by using a foreach statement or a loop:\n\nThe following example removes elements from a list by index. Instead of a statement, it uses a statement that iterates in descending order. The RemoveAt method causes elements after a removed element to have a lower index value.\n\nFor the type of elements in the List<T>, you can also define your own class. In the following example, the class that is used by the List<T> is defined in the code.\n\nThese examples use the Dictionary<TKey,TValue> class. It's the most common dictionary collection. A dictionary collection enables you to access elements in the collection by using the key of each element. Each addition to the dictionary consists of a value and its associated key.\n\nThe following example creates a collection and iterates through the dictionary by using a statement.\n\nThe following example uses the ContainsKey method and the Item[] property of to quickly find an item by key. The property enables you to access an item in the collection by using the in C#.\n\nThe following example instead uses the TryGetValue method to quickly find an item by key.\n\nAn iterator is used to perform a custom iteration over a collection. An iterator can be a method or a accessor. An iterator uses a yield return statement to return each element of the collection one at a time.\n\nYou call an iterator by using a foreach statement. Each iteration of the loop calls the iterator. When a statement is reached in the iterator, an expression is returned, and the current location in code is retained. Execution is restarted from that location the next time that the iterator is called.\n\nFor more information, see Iterators (C#).\n\nThe following example uses an iterator method. The iterator method has a statement that is inside a loop. In the method, each iteration of the statement body creates a call to the iterator method, which proceeds to the next statement.\n\nLanguage-integrated query (LINQ) can be used to access collections. LINQ queries provide filtering, ordering, and grouping capabilities. For more information, see Getting Started with LINQ in C#.\n\nThe following example runs a LINQ query against a generic . The LINQ query returns a different collection that contains the results."
    },
    {
        "link": "https://stackoverflow.com/questions/2283455/how-is-this-dictionarytkey-tvalue-exception-possible",
        "document": "Threading might well be the cause, but it was a red herring in our case. You can also seem to have this problem if you have a Release build where a function was inlined. Consider this repro:\n\nOn my machine this gives the following Debug build stack trace:\n\nBut, it gives this stack trace in Release build:\n\nYou'd be tempted to think with that last stack trace that it has to be that causes the exception, when in fact it was the function that got inlined in .\n\nSo if you land here, please consider if you have a similar issue. (I realize this may not be a straight up answer to OP's question, but wanted to share nonetheless as it might help a future visitor.)"
    },
    {
        "link": "https://github.com/dotnet/runtime/blob/main/src/libraries/System.Private.CoreLib/src/System/Collections/Generic/Dictionary.cs",
        "document": ""
    },
    {
        "link": "https://geeksforgeeks.org/c-sharp-dictionary-class",
        "document": "In C#, the Dictionary class is the part of the System.Collections.Generic namespace. It is a Collection that stores Key-value pairs. Each key in the dictionary is unique and each key maps to a single value.\n• None In Dictionary, each entry consists of a key and its associated value.\n• None It provides constant time complexity for insertion, deletion, and lookups.\n• None It provides generic support (which means it can work with any data type for both keys and values.\n\nExample: This example, demonstrates how to create a Dictionary, insert key-value pairs and iterate through them to display the keys and their corresponding values.\n\nIn C#, the declaration of Dictionary can be done as:\n• TKey : Denotes the type of the keys in the dictionary.\n• TValue : Denotes the type of the values in the dictionary.\n\nNote: Tkey is the type of the keys and Tvalue is the type of the values\n\nSince the Dictionary<TKey, TValue> is a collection of keys and values, the element type is not the type of the key or the type of the value. Instead, the element type is a KeyValuePair <TKey, TValue> of the key type and the value type.\n\nExample: This example demonstrates the count of pairs and displaying all the key-value pairs.\n\nExample 1: This program demonstrates how to retrieve and display all the keys from the dictionary.\n\nExample 2: This program demonstrates how to retrieve and display all the values from the dictionary.\n\nAdds the specified key and value to the dictionary. \n\n Removes all keys and values from the Dictionary<TKey, TValue>. Determines whether the Dictionary<TKey, TValue> contains the specified key. Determines whether the Dictionary<TKey, TValue> contains a specific value. Determines whether the specified object is equal to the current object. \n\n Returns an enumerator that iterates through the Dictionary<TKey, TValue> . Implements the ISerializable interface and returns the data needed to serialize the Dictionary<TKey,TValue> instance. Gets the Type of the current instance. Implements the ISerializable interface and raises the deserialization event when the deserialization is complete. Removes the value with the specified key from the Dictionary<TKey, TValue>. Gets the value associated with the specified key.\n\nExample 1: This example demonstrates how to use clear() to remove all the elements from the dictionary.\n\nExample 2: This example demonstrates how to remove entries based on their keys."
    }
]