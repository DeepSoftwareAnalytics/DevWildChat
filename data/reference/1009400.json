[
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/api/system.diagnostics.process.getprocesses?view=net-9.0",
        "document": "An array of type Process that represents all the process resources running on the local computer.\n\nThe following example retrieves information of the current process, processes running on the local computer, all instances of Notepad running on the local computer, and a specific process on the local computer. It then retrieves information for the same processes on a remote computer.\n\nUse this method to create an array of new Process components and associate them with all the process resources on the local computer. The process resources must already exist on the local computer, because GetProcesses does not create system resources but rather associates resources with application-generated Process components. Because the operating system itself is running background processes, this array is never empty.\n\nIf you do not want to retrieve all the processes running on the computer, you can restrict their number by using the GetProcessById or GetProcessesByName method. GetProcessById creates a Process component that is associated with the process identified on the system by the process identifier that you pass to the method. GetProcessesByName creates an array of Process components whose associated process resources share the executable file you pass to the method."
    },
    {
        "link": "https://stackoverflow.com/questions/262280/how-can-i-know-if-a-process-is-running",
        "document": "When I get a reference to a System.Diagnostics.Process , how can I know if a process is currently running?\n\nThis is a way to do it with the name: You can loop all process to get the ID for later manipulation:\n\nThis is the simplest way I found after using reflector. I created an extension method for that: public static class ProcessExtensions { public static bool IsRunning(this Process process) { if (process == null) throw new ArgumentNullException(\"process\"); try { Process.GetProcessById(process.Id); } catch (ArgumentException) { return false; } return true; } } The method calls the method and throws in case the process does not exist. For some reason the class is internal...\n\nreshefm had a pretty nice answer; however, it does not account for a situation in which the process was never started to begin with. Here is a a modified version of what he posted. public static bool IsRunning(this Process process) { try { Process.GetProcessById(process.Id).Dispose(); } catch (Exception e) when (e is ArgumentException or InvalidOperationException) { return false; } return true; } I removed his ArgumentNullException because its actually suppose to be a null reference exception and it gets thrown by the system anyway and I also accounted for the situation in which the process was never started to begin with or the close() method was used to close the process.\n\nIt depends on how reliable you want this function to be. If you want to know if the particular process instance you have is still running and available with 100% accuracy then you are out of luck. The reason being that from the managed process object there are only 2 ways to identify the process. The first is the Process Id. Unfortunately, process ids are not unique and can be recycled. Searching the process list for a matching Id will only tell you that there is a process with the same id running, but it's not necessarily your process. The second item is the Process Handle. It has the same problem though as the Id and it's more awkward to work with. If you're looking for medium level reliability then checking the current process list for a process of the same ID is sufficient.\n\nThere are many problems associated with this, as other have seemed to partially address:\n• Any instance members are not guaranteed to be thread safe. Meaning there are race conditions that may occur with the lifetime of the snapshot while trying to evaluate the properties of the object.\n• The process handle will throw Win32Exception for ACCESS DENIED where permissions for evaluating this and other such properties aren't allowed.\n• For ISN'T RUNNING status, an ArgumentException will also be raised when trying to evaluate some of its properties. Whether the properties others have mentioned are internal or not, you can still obtain information from them via reflection if permission allows. You could pinvoke Win32 code for Snapshot or you can use WMI which is slower. Another option would be to OpenProcess / CloseProcess, but you will still run into the same issues with exceptions being thrown same as before.\n\nMaybe (probably) I am reading the question wrongly, but are you looking for the HasExited property that will tell you that the process represented by your Process object has exited (either normally or not). If the process you have a reference to has a UI you can use the Responding property to determine if the UI is currently responding to user input or not. You can also set EnableRaisingEvents and handle the Exited event (which is sent asychronously) or call WaitForExit() if you want to block.\n\nYou can instantiate a Process instance once for the process you want and keep on tracking the process using that .NET Process object (it will keep on tracking till you call Close on that .NET object explicitly, even if the process it was tracking has died [this is to be able to give you time of process close, aka ExitTime etc.]) When an associated process exits (that is, when it is shut down by the operation system through a normal or abnormal termination), the system stores administrative information about the process and returns to the component that had called WaitForExit. The Process component can then access the information, which includes the ExitTime, by using the Handle to the exited process. Because the associated process has exited, the Handle property of the component no longer points to an existing process resource. Instead, the handle can be used only to access the operating system’s information about the process resource. The system is aware of handles to exited processes that have not been released by Process components, so it keeps the ExitTime and Handle information in memory until the Process component specifically frees the resources. For this reason, any time you call Start for a Process instance, call Close when the associated process has terminated and you no longer need any administrative information about it. Close frees the memory allocated to the exited process.\n\nSafe query a list of all active processes by name. If you are looking for all active processes that are not terminated or just traces of remout ones, then try this safe query without failures, in the style of try without exceptions... You will get the result in any case and without failures... If the method returned “true”, then the list will contain all the searched processes, otherwise - “false” and an empty list, and if the list is null, the name argument was not set correctly and there was no search... /// <summary> /// Safe Try... /// </summary> /// <param name=\"processName\"></param> /// <param name=\"processList\"></param> /// <returns></returns> public static bool ProcessIsAnyRunning(this string processName, out List<Process> processList) { processList = null; var ret = !string.IsNullOrWhiteSpace(processName); if (ret) { var processArr = Process.GetProcessesByName(processName); ret = processArr.Length > 0; if (ret) { processList = new List<Process>(); foreach (var process in processArr) try { process.Refresh(); if (process.HasExited) process.Dispose(); else processList.Add(process); } catch { continue; } ret = processList.Count > 0; } } return ret; }"
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/api/system.diagnostics.process.getprocessesbyname?view=net-9.0",
        "document": "An array of type Process that represents the process resources running the specified application or file.\n\nThe following example retrieves information of the current process, processes running on the local computer, all instances of Notepad running on the local computer, and a specific process on the local computer. It then retrieves information for the same processes on a remote computer.\n\nUse this method to create an array of new Process components and associate them with all the process resources that are running the same executable file on the specified computer. The process resources must already exist on the computer, because GetProcessesByName does not create system resources but rather associates them with application-generated Process components. A can be specified for an executable file that is not currently running on the local computer, so the array the method returns can be empty.\n\nThe process name is a friendly name for the process, such as Outlook, that does not include the .exe extension or the path. GetProcessesByName is helpful for getting and manipulating all the processes that are associated with the same executable file. For example, you can pass an executable file name as the parameter, in order to shut down all the running instances of that executable file.\n\nAlthough a process Id is unique to a single process resource on the system, multiple processes on the local computer can be running the application specified by the parameter. Therefore, GetProcessById returns one process at most, but GetProcessesByName returns an array containing all the associated processes. If you need to manipulate the process using standard API calls, you can query each of these processes in turn for its identifier. You cannot access process resources through the process name alone but, once you have retrieved an array of Process components that have been associated with the process resources, you can start, terminate, and otherwise manipulate the system resources.\n\nYou can use this overload to get processes on the local computer as well as on a remote computer. Use \".\" to specify the local computer. Another overload exists that uses the local computer by default.\n\nYou can access processes on remote computers only to view information, such as statistics, about the processes. You cannot close, terminate (using Kill), or start processes on remote computers."
    },
    {
        "link": "https://stackoverflow.com/questions/34521524/what-order-is-process-getprocesses-getting-the-processes",
        "document": "The underlying Win32 APIs that are used are and . Neither of these APIs document that they will be returned in order, thus you cannot depend on them being given to you in a particular order every time. If you need them sorted, then sort them using LINQ or any other means."
    },
    {
        "link": "https://codemag.com/article/1309031/Listing-Processes-Running-on-a-Computer",
        "document": "By Paul Sheriff\n\n Published in: CODE Magazine: 2013 - September/October\n\n Publication Date: August 6, 2013\n\n Last updated: April 25, 2022\n\nI have a client that has a few Windows Services and some EXEs that run on a computer to perform various business functions. Every once in a while, the processes fail and need to be restarted. I helped the client write a Windows Service to monitor their running processes and ensure that they are up and running and to notify them and to attempt to restart those processes. As part of this process, I had to write a class to get a list of all of the processes running on the current computer or on another computer on their network.\n\nTo read all processes running on a computer, use the .NET class located in the namespace. The method returns a string array of objects from the current (or a remote) computer. From this object, you can retrieve information about the process (Figure 1) such as its unique ID, its name, whether or not it is running, and how much memory that process is consuming.\n\nYou can pass a computer name to the method to have it attempt to read the processes running on that remote computer. You must have the appropriate network/computer permissions to read the processes on the other computer or this call will fail. Certain properties for the remote process cannot be filled in because they cannot be retrieved remotely.\n\nThe code in Listing 1 is what fills in the process information on the XAML screen shown in Figure 1. A Process array is initialized as a variable named . Another variable, , is used to hold the computer's name that is entered into the text box on the form. A call to the method, with or without the computer name, returns the array of objects into the variable. This string array is placed into the property of the ListView control to display all the properties from each object.\n\nListing 1: Read all processes on a specified computer\n\nThere are a couple of things missing from the .NET class that you will probably want to add. First, the property is filled in with a period (.) when you are running on the current computer. You probably want this to be filled in with the current computer's name. Another important property is whether or not this object was retrieved from a remote computer. A useful set of properties is the amount of memory used, expressed in both kilobytes and megabytes. All of these properties are easy to add by creating your own process class.\n\nIn order to work more effectively with a collection of processes, create a couple of new classes for your process listing service that can add additional properties and functionality. I have called mine and , but feel free to name them what you want. The class inherits from the class. The Base class implements the event and adds two properties called and . These two properties can be used to keep track of the last display or error message and the last exception object when you are loading your process objects. You can look at the sample source code that comes with this article to see the implementation of the class.\n\nNOTE: Using in XAML applications is a well-known design pattern and there are many articles on the subject, so I won't cover it here.\n\nListing 2 shows the class but with some of the normal property methods not fully documented because they are all the same. You will see the full code for those properties that have special code in Listing 2. Notice the “property set” procedure calls the method. Also note the calculations for the and properties.\n\nListing 2: Your own custom process class will let you add more information than you can get from the .NET Process class.\n\nThe end result of creating the class is shown in Figure 2. As you can see, there is better information displayed in the ListView control and the data displayed is sorted by the process name.\n\nThe class also has many of the same properties as the .NET class, but the properties in this class raise the property changed event for use with XAML applications. Notice that the property shown in Figure 2 displays the current computer name rather than the period (.) that is reported by the .NET class. In the procedure of the property, a private method called is called to set the current computer name and to set the property at the same time.\n\nTo load the custom process collection shown in Figure 2, click on the Load All Processes button shown on the form. The button's event procedure fires and runs the code shown in the following code snippet:\n\nCheck the text box to see if the user entered a computer name or not. If they have entered one, pass in the computer name to a method called . If there is no computer name in the text box, pass in an empty string to the method. Listing 3 shows the code to load the processes from the .NET object into a object and then into an ObservableCollection of those objects.\n\nListing 3: Load all processes using a simple loop and create your ObservableCollection of PDSAProcess objects.\n\nThe code in the method is fairly straight-forward. You are primarily moving the properties from the .NET class into the corresponding properties in the class. The class takes care of filling in the real computer name, and setting whether or not the computer is remote Be careful accessing the property on the .NET class because it is not available on remote objects. In fact, if you try to access this property, an exception is thrown. That is why you see an “if” statement surrounding the code that attempts to access the property.\n\nThe .NET method does not return the processes in any sort of order. Most users like to see sorted data, so it is probably a good idea to sort your process collection by the process name. Toward the bottom of Listing 3, you can see the following code snippet:\n\nThis line of code uses the method of the class to create a new ObservableCollection of objects. You pass a lambda expression that informs the method the name of the property by which to sort the collection.\n\nInstead of writing the code to load a ListView or other list-type of control, you might want to move the code you just wrote in the XAML window to a method in a class. Create a “Manager” class with the appropriate method to manage the process of creating a collection of process objects.\n\nIn preparation for creating a Manager class, move the and properties from the class into the class. Move the method into the class as well, because the property of the property relies on this method. The Manager class you are going to write needs these two properties and , so you might as well take advantage of inheritance by placing them into the Base class. The following code snippet shows the declaration for your new process manager class.\n\nIn this new process Manager class, you are going to add a method to retrieve memory instead of merely accessing the property of the .NET class. The property does not report the same amount of memory as the Task Manager utility and it can sometimes be confusing if you are looking at Task Manager, and then at your program, and you see different memory values. The method you are going to write will use a object in .NET to get the same value reported by Task Manager. The basics of how to retrieve memory using a performance counter is coded like this:\n\nAlthough the above code works, you may also need to pass in a computer name to the constructor of the if you are accessing a remote computer. Be aware that in order to access a performance counter on another computer, you need to either be a member of the Performance Monitor Users group or have administrative privileges on that computer.\n\nWithin the new class, add a constant called that holds the name of the performance counter you use. Add an ObservableCollection of classes to hold the list of objects as well. These two items are shown in the following code snippet:\n\nYou are now ready to write the method in your process Manager class. Listing 4 shows the complete method. As you will notice when you read the code, there are a few differences from the method you wrote earlier in this article.\n\nListing 4: The LoadAllProcesses method uses LINQ to create a collection of PDSAProcess objects.\n\nThe first difference is that you are using LINQ to create a collection of objects. LINQ simplifies the process of creating a collection and is more concise than looping through the string array of .NET objects. However, if you like using a loop, you can modify this code to use the loop like you did in Listing 3. The second difference is the call to set the property on the object by calling a method named .\n\nThe method is where you attempt to get the object from either the local or the remote computer. You need to wrap up the creation of the object into a try...catch block in case you can't access the performance counter for one of the reasons stated above. Also notice that you need a finally block when accessing a performance counter, in order to close and dispose of the performance counter object properly. You can wrap this call into a using block if you prefer. If, for some reason, you can't access the performance counter to get the memory and you still want to have a valid memory value, and if the memory value is not set, get the property on the .NET object to set the return value from this method. See Listing 5.\n\nListing 5: A more accurate measure of a process' memory can be retrieved using a performance counter.\n\nNow that you have this process Manager class written, you can use it as a view model on your WPF Window. (Some of the XAML has been removed in the code snippet below because it was not important to show it.) You create an XML namespace to reference the .NET namespace that the is contained within. In the section of the XAML, create an instance of the class and assign it a key of “viewModel”. Bind the property of the ListView to the property in the class. This is the collection of process objects retrieved when you call the method. Finally, you bind each of the objects in the ListView to each property of the class that you wish to display.\n\nTo load the process collection into the property, call the method when the user clicks on the Load All Processes button shown in Figure 2. The property of the class is bound to the TextBox shown on Figure 2. In the constructor of this main window, you bind the instance of the view model class created in the XAML to a variable called . Call the method, as shown in the following code snippet:\n\nThe method retrieves all the processes on the specified computer, builds the collection class, sorts the collection class, and sets the property. As the property is an ObservableCollection, any bindings to it are automatically updated when the collection changes. Thus, the ListView control is refreshed once it is set in the method.\n\nIn this article, you learned how to read the list of processes running on the current computer or a remote computer using the .NET class. Create your own process class so that you can add additional properties and functionality that is not available with the .NET class. One feature you might want to add includes returning the amount of memory in both kilobytes and megabytes. Also, whether or not the process was read from a remote computer is very useful. Setting the computer name is more readable than displaying a period (.) as the .NET class does. Sorting the data using an ObservableCollection makes the display of the data easier for the user. Finally, wrapping the loading of process classes into a Manager class makes creating a list of processes quick and easy."
    },
    {
        "link": "https://stackify.com/c-dictionary-how-to-create-one-and-best-practices",
        "document": "C# Dictionary: How to Create One and Best Practices\n\nThe C# dictionary is one of the most important collection types/data structures you’ll use while developing your applications. You can use a dictionary to solve certain kinds of problems in a way that’s much more natural and elegant than using, say, a list. There are also significant performance gains you can obtain by using dictionaries.\n\nThat’s what this post is about: a detailed introduction to this powerful collection type. We’ll cover:\n• How to create and initialize a dictionary\n• What are the main methods you must know\n• Performance considerations, common use cases, and best practices\n\nLet’s start by covering some C# dictionary fundamentals.\n\nWhat Is a Dictionary in C#?\n\nIn C#, the dictionary class allows you to create a collection of key-value pairs. A key is a unique identifier through which you can later retrieve the value. And the value is whatever you need to store and later retrieve.\n\nWhat is a dictionary good for? There are certain performance-sensitive scenarios in which dictionaries shine, and we’ll cover more of that later. But in general, dictionaries are well-suited for when you need to retrieve a unique value based on its identifier, in an efficient way.\n\nUsing a dictionary in C# allows you to:\n• Add elements associating them with a given key\n• Retrieve an element by its key\n• Verifying whether a given key is already present in the dictionary\n• Count how many elements are in the dictionary\n• Iterate through all key-value pairs using a foreach loop\n• Obtain a list of all the keys, values, and key-value pairs\n\nTime to roll up your sleeves and learn how to work with a C# dictionary.\n\nHow to Declare and Initialize a Dictionary\n\nThe easiest way to declare a dictionary is using the class’s constructor to initialize an empty one:\n\nIn the example above, we create a dictionary whose keys are of type int and values are of type string.\n\nLet’s say that you would like to use the dictionary from the previous example to store the names of the months, in relation to their numbers, in a one-based fashion. Use the Add method, passing first the key and then the value as arguments:\n\nAlternatively, it is also possible to create the dictionary and add the items in one go:\n\nThe astute readers will remember that, when defining the dictionary, the key must be unique. So, what happens when you try to add an element with an already existing key? You get an exception, of course. Let’s say that after initializing the dictionary with all twelve months, you try to add another value with the key 12.\n\nYou would get a System.ArgumentException with the following message: ‘An item with the same key has already been added. Key: 12’.\n\nThese aren’t all the ways you can initialize a dictionary, but the examples are certainly the most common ones.\n\nLet’s cover the most common methods from the Dictionary class.\n\nYou access dictionary elements using its indexer and providing a key. In the following example, we retrieve the names of all months by using numbers from 1 to 12 as the keys:\n\nWhat happens if you pass the dictionary a key it doesn’t contain? You get an exception. More specifically, a System.Collections.Generic.KeyNotFoundException. And that ties nicely with the next topic.\n\nChecking for Key or Value Existence\n\nIf, within your code, you can’t know for sure whether a key exists, then you should verify its presence before you try to access it. The same applies when adding elements: if you don’t know whether a key has already been added to the dictionary, check first. You can do that by using the ContainsKey() method:\n\nUnlike keys, it’s completely valid for a dictionary to have duplicated values. Duplicate values may or may not make sense for your specific use case, and that’s why you might have to use the ContainsValue() method to check for a value’s presence.\n\nAlternatively, a more performant way to test for the existence of a value and getting it at the same time is using the TryGetValue() method.\n\nThe regular Dictionary class in C# is mutable, which means you can change the values you added to it. See the following example:\n\nUse the Remove() method to remove an element from a dictionary. This method has a few overloads, but the most well-known one receives a single argument, representing the key for the pair you wish to remove.\n\nThis method returns true if the specified key was found and the associate pair was removed, and false otherwise. That means this method, unlike others we’ve seen before, doesn’t throw an error when you provide a key that can’t be found.\n\nWhat if you wanted to remove all items from the dictionary in one go? In that case, the Clear() method is what you’re looking for:\n\nThere are several ways to iterate over a dictionary using a foreach loop. For starters, here’s our sample dictionary for this example:\n\nNotice two things of interest here:\n• We’ve used the target type new expressions feature of C#\n• We’ve used a different, simpler syntax to add elements to our dictionary\n\nWith that in place, let’s start by first iterating through the key-value pairs (the code below uses explicit typing for the foreach variable, but of course, we can type inference as well):\n\nLet’s do it again, but this time using the deconstruction syntax introduced in C# 7:\n\nFinally, let’s see how to iterate over only the keys and then only the values:\n\nGenerally speaking, dictionaries are fast. Here’s what .NET’s documentation has to say about element retrieval:\n\nIf you don’t know what “O(1)” means, you should learn about “time complexity” and “Big-O notation.” In short, the sentence above means that retrieving a value by its key takes a fixed time, regardless of the number of elements in the dictionary.\n\nThat isn’t true 100% of the time, though:\n\nThe type used as key should have a sound algorithm for its GetHashCode() method. If different objects return the same code – in other words if there are collisions – the performance of lookups will be impacted.\n\nDictionaries excel in scenarios in which you need fast retrieval of an element based on its associated key. Considering this, here’s a non-exhaustive list of common use cases for dictionaries:\n• Counting occurrences of certain pieces of data\n\nBest Practices for Using Dictionaries\n\nBefore wrapping up, let’s cover some dictionary best practices you should be aware of:\n• Avoid exceptions when working with keys by proactively checking in scenarios in which you can’t know for sure\n• Prefer TryGetValue() when retrieving elements, because it’s faster than using Contains() then indexer, in scenarios where it’s very common for values to not be in the dictionary\n• When it comes to key types, choose immutable types that implement GetHashCode correctly\n• Consider setting an initial capacity when initializing the dictionary, if you know the maximum length the dictionary will get. This avoids internal resizes and improves performance\n• When dictionary is no longer needed, you can use Clear() to remove all key-value pairs, relieving some pressure from the garbage collector\n\nIn this post, you’ve learned what a dictionary is and how and when to use it. As you’ve seen, dictionaries are great when you need a fast lookup of values. That doesn’t mean, however, that dictionaries are entirely free of potential pitfalls when it comes to performance. For instance, dictionaries have a bigger memory footprint than, say, lists, because of how they’re implemented internally (dictionaries potentially need to have several arrays and linked lists).\n\nSo, this bigger overhead is something you should be aware of and, in scenarios where the fast lookup of dictionaries doesn’t make a difference, consider picking another type.\n\nAlso, regardless of whether you’re using dictionaries, it’s great to have the support of an application monitoring tool for your applications that alerts you at the first sign of potential performance problems. In that spirit, we invite you to start your free trial of Stackify today."
    },
    {
        "link": "https://stackoverflow.com/questions/2363801/what-would-be-the-best-way-to-implement-change-tracking-on-an-object",
        "document": "If any value is assingned to any of these fields, an another value (for example IsDIrty) would change to true.\n\nTo do this you can't really use automatic getter & setters, and you need to set IsDirty in each setter. I generally have a \"setProperty\" generic method that takes a ref parameter, the property name and the new value. I call this in the setter, allows a single point where I can set isDirty and raise Change notification events e.g. protected bool SetProperty<T>(string name, ref T oldValue, T newValue) where T : System.IComparable<T> { if (oldValue == null || oldValue.CompareTo(newValue) != 0) { oldValue = newValue; PropertyChanged?.Invoke(this, new System.ComponentModel.PropertyChangedEventArgs(name)); isDirty = true; return true; } return false; } // For nullable types protected void SetProperty<T>(string name, ref Nullable<T> oldValue, Nullable<T> newValue) where T : struct, System.IComparable<T> { if (oldValue.HasValue != newValue.HasValue || (newValue.HasValue && oldValue.Value.CompareTo(newValue.Value) != 0)) { oldValue = newValue; PropertyChanged?.Invoke(this, new System.ComponentModel.PropertyChangedEventArgs(name)); } }\n\nYou can implement the or interfaces, now included in .NET Standard 2.0. Implementation is as follows: class Entity : IChangeTracking { string _FirstName; public string FirstName { get => _FirstName; set { if (_FirstName != value) { _FirstName = value; IsChanged = true; } } } string _LastName; public string LastName { get => _LastName; set { if (_LastName != value) { _LastName = value; IsChanged = true; } } } public bool IsChanged { get; private set; } public void AcceptChanges() => IsChanged = false; } class Entity : IRevertibleChangeTracking { Dictionary<string, object> _Values = new Dictionary<string, object>(); string _FirstName; public string FirstName { get => _FirstName; set { if (_FirstName != value) { if (!_Values.ContainsKey(nameof(FirstName))) _Values[nameof(FirstName)] = _FirstName; _FirstName = value; IsChanged = true; } } } string _LastName; public string LastName { get => _LastName; set { if (_LastName != value) { if (!_Values.ContainsKey(nameof(LastName))) _Values[nameof(LastName)] = _LastName; _LastName = value; IsChanged = true; } } } public bool IsChanged { get; private set; } public void RejectChanges() { foreach (var property in _Values) GetType().GetRuntimeProperty(property.Key).SetValue(this, property.Value); AcceptChanges(); } public void AcceptChanges() { _Values.Clear(); IsChanged = false; } } Another option, which I like the most, is to use a change tracking library, such as TrackerDog, that generates all the boilerplate code for you, while just need to provide POCO entities. There are more ways to achieve this if you don't want to implement all the properties by hand. One option is to use a weaving library, such as Fody.PropertyChanged and Fody.PropertyChanging, and handle the change methods to cache old values and track object state. Another option is to have the object's graph stored as MD5 or some other hash, and reset it upon any change, you might be surprised, but if you don't expect zillion changes and if you request it only on demand, it can work really fast. Here is an example implementation (Note: requires Json.NET and Fody/PropertyChanged: [AddINotifyPropertyChangedInterface] class Entity : IChangeTracking { public string UserName { get; set; } public string LastName { get; set; } public bool IsChanged { get; private set; } string hash; string GetHash() { if (hash == null) using (var md5 = MD5.Create()) using (var stream = new MemoryStream()) using (var writer = new StreamWriter(stream)) { _JsonSerializer.Serialize(writer, this); var hash = md5.ComputeHash(stream); this.hash = Convert.ToBase64String(hash); } return hash; } string acceptedHash; public void AcceptChanges() => acceptedHash = GetHash(); static readonly JsonSerializer _JsonSerializer = CreateSerializer(); static JsonSerializer CreateSerializer() { var serializer = new JsonSerializer(); serializer.Converters.Add(new EmptyStringConverter()); return serializer; } class EmptyStringConverter : JsonConverter { public override bool CanConvert(Type objectType) => objectType == typeof(string); public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer) => throw new NotSupportedException(); public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer) { if (value is string str && str.All(char.IsWhiteSpace)) value = null; writer.WriteValue(value); } public override bool CanRead => false; } }\n\nAnother option to consider if you're going to have to do this on multiple classes (or maybe you want an external class to \"listen\" for changes to the properties):\n• Implement the interface in an abstract class\n• Move the property to your abstract class\n• Have and all other classes that require this functionality to extend your abstract class\n• Have all your setters fire the event implemented by your abstract class, passing in their name to the event\n• In your base class, listen for the event and set to true when it fires It's a bit of work initially to create the abstract class, but it's a better model for watching for data changes as any other class can see when (or any other property) changes. My base class for this looks like the following: public abstract class BaseModel : INotifyPropertyChanged { /// <summary> /// Initializes a new instance of the BaseModel class. /// </summary> protected BaseModel() { } /// <summary> /// Fired when a property in this class changes. /// </summary> public event PropertyChangedEventHandler PropertyChanged; /// <summary> /// Triggers the property changed event for a specific property. /// </summary> /// <param name=\"propertyName\">The name of the property that has changed.</param> public void NotifyPropertyChanged(string propertyName) { if (this.PropertyChanged != null) { this.PropertyChanged.Invoke(this, new PropertyChangedEventArgs(propertyName)); } } } Any other model then just extends , and calls in each setter.\n\nIf there are a very large number of such classes, all having that same pattern, and you frequently have to update their definitions, consider using code generation to automatically spit out the C# source files for all the classes, so that you don't have to manually maintain them. The input to the code generator would just be a simple text file format that you can easily parse, stating the names and types of the properties needed in each class. If there are just a small number of them, or the definitions change very infrequently during your development process, then it's unlikely to be worth the effort, in which case you may as well maintain them by hand. This is probably way over the top for a simple example, but it was fun to figure out! In Visual Studio 2008, if you add a file called to your project and then paste this stuff into it, you'll have the makings of a code generation system: <#@ template debug=\"false\" hostspecific=\"true\" language=\"C#v3.5\" #> <#@ output extension=\".cs\" #> <#@ assembly name=\"System.Core\" #> <#@ import namespace=\"System.Linq\" #> <# // You \"declare\" your classes here, as in these examples: var src = @\" Foo: string Prop1, int Prop2; Bar: string FirstName, string LastName, int Age; \"; // Parse the source text into a model of anonymous types Func<string, bool> notBlank = str => str.Trim() != string.Empty; var classes = src.Split(';').Where(notBlank).Select(c => c.Split(':')) .Select(c => new { Name = c.First().Trim(), Properties = c.Skip(1).First().Split(',').Select(p => p.Split(' ').Where(notBlank)) .Select(p => new { Type = p.First(), Name = p.Skip(1).First() }) }); #> // Do not edit this file by hand! It is auto-generated. namespace Generated { <# foreach (var cls in classes) {#> class <#= cls.Name #> { public bool IsDirty { get; private set; } <# foreach (var prop in cls.Properties) { #> private <#= prop.Type #> _storage<#= prop.Name #>; public <#= prop.Type #> <#= prop.Name #> { get { return _storage<#= prop.Name #>; } set { IsDirty = true; _storage<#= prop.Name #> = value; } } <# } #> } <# } #> } There's a simple string literal called in which you declare the classes you need, in a simple format: So you can easily add hundreds of similar declarations. Whenever you save your changes, Visual Studio will execute the template and produce as output, which contains the C# source for the classes, complete with the logic. You can change the template of what is produced by altering the last section, where it loops through the model and produces the code. If you've used ASP.NET, it's similar to that, except generating C# source instead of HTML.\n\nBoth Dan's and Andy Shellam's answers are my favorites. In anyway, if you wanted to keep TRACK of you changes, like in a log or so, you might consider the use of a Dictionary that would add all of your property changes when they are notified to have changed. So, you could add the change into your Dictionary with a unique key, and keep track of your changes. Then, if you wish to Roolback in-memory the state of your object, you could this way. EDIT Here's what Bart de Smet uses to keep track on property changes throughout LINQ to AD. Once the changes have been committed to AD, he clears the Dictionary. So, when a property changes, because he implemented the INotifyPropertyChanged interface, when a property actually changed, he uses a Dictionary> as follows: /// <summary> /// Update catalog; keeps track of update entity instances. /// </summary> private Dictionary<object, HashSet<string>> updates = new Dictionary<object, HashSet<string>>(); public void UpdateNotification(object sender, PropertyChangedEventArgs e) { T source = (T)sender; if (!updates.ContainsKey(source)) updates.Add(source, new HashSet<string>()); updates[source].Add(e.PropertyName); } So, I guess that if Bart de Smet did that, this is somehow a practice to consider.\n\nThere are multiple ways for change tracking with their pros and cons. Here are some ideas: In .NET, the most common approach is to implement , , and/or (see also Introduction to Rx). Tipp: The easiest way to do this is to use from the ReactiveUI library as base object. Using this interfaces, you can track when a property is changing or has changed. So this is the best method to react to changes in „real-time“. You can also implement a change tracker to keep track of everything for more complex scenarios. The change tracker might have a list of the changes—listing property names, values, and timestamps as needed—internally. You can than query this list for the information you need. Think of something like the EventSourcing pattern. If you want to see if an object has changed and what has changed, you could serialize the original version and the current version. One version of this is to serialize to JSON and calculate an JSON Patch. You can use the class (see also JsonPatchDocument Class) for this. The diff will tell you what has changed. (see also this question) Then there is also the method of having multiple properties to keep the original state and the current state, and maybe an boolean that tells you if the field has changed but was changed back to the original value later. This is very easy to implement, but might not be the best approach when handling more complex scenarios."
    },
    {
        "link": "https://medium.com/programming-with-c/mastering-c-dictionary-14-essential-tips-for-smarter-programming-4ff6a3220e00",
        "document": "In the world of C# programming, the is a powerhouse collection that developers rely on for efficient key-value data management.\n\nWhether you're storing configuration settings, implementing caching mechanisms, or creating lookup tables, the is often your go-to tool.\n\nWhile many developers use dictionaries daily, few fully leverage their potential. Did you know there are advanced techniques and little-known features that can optimize your use of dictionaries, making your code not only cleaner but also significantly faster?\n\nThis blog is here to change that. We’ll explore 14 essential tips to help you master the C# —from performance optimizations and safe key-value handling to thread-safe operations and beyond. These tips will elevate your programming skills and help you write smarter, more efficient code.\n\nReady to take your dictionary game to the next level? Let’s dive in and unlock the secrets of this versatile data structure!\n\nA C# Dictionary is a generic collection in the .NET framework, defined as , which is used to store and manage data as key-value pairs. It provides fast lookups, additions…"
    },
    {
        "link": "https://stackoverflow.com/questions/378465/retrieving-dictionary-value-best-practices",
        "document": "I just recently noticed and was curious as to which is the better approach to retrieving a value from the Dictionary.\n\nunless I know it has to be in there.\n\nIs it better to just do:\n\nWhich is the better practice? Is one faster than the other? I would imagine that the Try version would be slower as its 'swallowing' a try/catch inside itself and using that as logic, no?"
    },
    {
        "link": "https://medium.com/@vosarat1995/how-c-dictionary-actually-works-47f3a156055b",
        "document": "is a very popular data structure in C# and a popular choice for interview questions. I've used a billion times and I was pretty sure I understand how they work. However, when I delve even deeper into them and check out the actual code I've figured out they work even better than I thought (and perhaps you, too). In this article, we'll make a deep dive together and even write our own educational replica of the dictionary. So join me and let's get going!\n\nTo ensure our replica matches the actual code we’ll start by exploring what we’ll have in the original code and then just remove everything not essential and add logs ( ) wherever needed. It's enough to replicate just two primary methods: Add and GetValueOrDefault to recreate all the essentials of the , so this is what we are going to do. But first, let's check out the fields we have in a :\n\nThe and properties are part of an optimization technique, that is not essential for the functioning of a - we'll pass on them for our replica. is just a changes counter, we'll pass on it, too. For simplicity, we will also use instead of allowing external provision. Adding methods for printing the current state (values of all the properties), we'll get:\n\nThe method in the source code is essentially a call to another method:\n\nThe method may look scary, but don't worry, we'll dissect it bit by bit:\n\nIt also calls other methods:\n\nAnd finally, they, call methods on . We'll replicate those since they are very trivial if you don't handle edge cases. Here's what our version will look like:\n\nFor we’ll remove the logic after and print state after the resizing is done. To be honest, the code is not very important it essentially rearranges and for the new size. This is what our result looks like:\n\nWe’ll move initialization logic from straight to the constructor (since it will nullability handling much easier):\n\nFor the here's the list of changes we'll perform:\n• Remove logic under since we removed the parameter anyway\n• Remove the loop, checking for already set keys:\n\nLooks way simpler now, right? Now let’s finalize our class, implementing .\n\nGetting the value\n\nThis time the implementation is rather simple even in the original code of :\n\nAnd in the search itself (in the method):\n\nThere’s not much to clean up here. But we will add a lot of logs since it’s the most essential logic we have\n\nThis finishes up our . Now let's use it and see the detailed logs we've prepared!\n\nWe’ll add 4 records, search for each of this record, plus one non-existing key, which should return , indicating that it couldn't find it. Here's how the test might look like:\n\nAnd this is the log we’ll get from running the test:\n\n🚀 Initialized, state:\n\nbuckets: [-1, -1, -1]\n\nentries:\n\n [0] = 0 - null + (next = 0)\n\n [1] = 0 - null + (next = 0)\n\n [2] = 0 - null + (next = 0)\n\ncount: 0\n\n\n\n📥 Add: 48 - John. hashCode = 48, targetBucket = 0, state:\n\nbuckets: [0, -1, -1]\n\nentries:\n\n [0] = 48 - John + (next = -1)\n\n [1] = 0 - null + (next = 0)\n\n [2] = 0 - null + (next = 0)\n\ncount: 1\n\n\n\n📥 Add: 34 - Josh. hashCode = 34, targetBucket = 1, state:\n\nbuckets: [0, 1, -1]\n\nentries:\n\n [0] = 48 - John + (next = -1)\n\n [1] = 34 - Josh + (next = -1)\n\n [2] = 0 - null + (next = 0)\n\ncount: 2\n\n\n\n📥 Add: 22 - Jack. hashCode = 22, targetBucket = 1, state:\n\nbuckets: [0, 2, -1]\n\nentries:\n\n [0] = 48 - John + (next = -1)\n\n [1] = 34 - Josh + (next = -1)\n\n [2] = 22 - Jack + (next = 1)\n\ncount: 3\n\n\n\n↔️ Resize, state:\n\nbuckets: [-1, 2, -1, -1, -1, -1, 1]\n\nentries:\n\n [0] = 48 - John + (next = -1)\n\n [1] = 34 - Josh + (next = 0)\n\n [2] = 22 - Jack + (next = -1)\n\n [3] = 0 - null + (next = 0)\n\n [4] = 0 - null + (next = 0)\n\n [5] = 0 - null + (next = 0)\n\n [6] = 0 - null + (next = 0)\n\ncount: 3\n\n\n\n📥 Add: 11 - Alex. hashCode = 11, targetBucket = 4, state:\n\nbuckets: [-1, 2, -1, -1, 3, -1, 1]\n\nentries:\n\n [0] = 48 - John + (next = -1)\n\n [1] = 34 - Josh + (next = 0)\n\n [2] = 22 - Jack + (next = -1)\n\n [3] = 11 - Alex + (next = -1)\n\n [4] = 0 - null + (next = 0)\n\n [5] = 0 - null + (next = 0)\n\n [6] = 0 - null + (next = 0)\n\ncount: 4\n\n\n\n🔎 Search. Key = 48. Initial Bucket Index 6\n\n\n\nComparing key from entries[1] (34 - Josh + (next = 0)) to 48\n\nKey is not equal, moving to the next linked index (0)\n\n\n\nComparing key from entries[0] (48 - John + (next = -1)) to 48\n\nKey is equal returning 0\n\n\n\n🔎 Search. Key = 34. Initial Bucket Index 6\n\n\n\nComparing key from entries[1] (34 - Josh + (next = 0)) to 34\n\nKey is equal returning 1\n\n\n\n🔎 Search. Key = 22. Initial Bucket Index 1\n\n\n\nComparing key from entries[2] (22 - Jack + (next = -1)) to 22\n\nKey is equal returning 2\n\n\n\n🔎 Search. Key = 11. Initial Bucket Index 4\n\n\n\nComparing key from entries[3] (11 - Alex + (next = -1)) to 11\n\nKey is equal returning 3\n\n\n\n🔎 Search. Key = 50. Initial Bucket Index 1\n\n\n\nComparing key from entries[2] (22 - Jack + (next = -1)) to 50\n\nKey is not equal, moving to the next linked index (-1)\n\n\n\nSearch exit condition met (i >= 0). Returning -1 (as not found)\n\nWith code and logs in place let’s put in words what we found out about for a works.\n\nWith the code and logs above we can explain how a searches for values:\n• Index of a bucket — - is calculated based on the hash code of the key.\n• The value of the contains the index of a record in\n• The matching entry either matches the key or has another entry in the links chain that does (or the key doesn’t exist in a dictionary)\n• To find the actual value cycles by the links until it finds a matching key or stops at the dead-end ( or in ).\n\nWith the algorithm, both search and insert operations are pretty fast and don’t require much memory! To play around with the yourself check out the source code here. And by the way ... claps are appreciated 👏"
    }
]