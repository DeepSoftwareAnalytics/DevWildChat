[
    {
        "link": "https://developers.cloudflare.com/workers/runtime-apis/handlers/fetch",
        "document": "Incoming HTTP requests to a Worker are passed to the handler as a object. To respond to the request with a response, return a object:\n\nThe Workers runtime does not support (XHR). Learn the difference between and in the MDN ↗ documentation.\n• \n• The bindings available to the Worker. As long as the environment has not changed, the same object (equal by identity) may be passed to multiple requests."
    },
    {
        "link": "https://developers.cloudflare.com/workers/runtime-apis/handlers/scheduled",
        "document": "You can test the behavior of your handler in local development using Wrangler.\n\nCron Triggers can be tested using by passing in the flag to . This will expose a route which can be used to test using a http request. To simulate different cron patterns, a query parameter can be passed in."
    },
    {
        "link": "https://community.cloudflare.com/t/should-i-use-event-waituntil-or-await-fetch-or-just-fetch/56183",
        "document": "Please see the code below: const res = await fetch(request); if (res.status === 404) { return new Response('', { status: 404, headers: { 'Location': 'https://go.tallyfy.com/404.html' } }); } else { return res; } Would this actually be the right way of doing it, instead? const res = event.waitUntil(fetch(request)); if (res.status === 404) { return new Response('', { status: 404, headers: { 'Location': 'https://go.tallyfy.com/404.html' } }); } else { return res; } There’s nothing else I want to do other than to fetch the response from the origin, check it’s a 404 or not and then proceed to finish.\n\nOr perhaps, is this the correct blocking way to do this? const res = fetch(request); if (res.status === 404) { return new Response('', { status: 404, headers: { 'Location': 'https://go.tallyfy.com/404.html' } }); } else { return res; }\n\nis the correct version. returns a promise for a response – to get the actual response, it must either be ed or have called on it, like . Using is typically the more natural of the two options, as the code turns out easier to read. is only useful if you have some asynchronous task that you want to keep running after returning a response to the visitor. Usually the Workers runtime will cancel any background tasks spawned from a particular FetchEvent once it detects that the response has been sent. tells the runtime to wait for another promise in addition to the visitor response before canceling any tasks. This probably doesn’t apply to your immediate needs. Further, doesn’t return anything, so treating its return value as anything other than will lead to an exception. CF worker to log all REST API activity in a non-blocking way to an external service - including response time\n\nThanks @harris - this is Amit from Tallyfy. To clarify further, is (1) and (2) precisely functionally equivalent? In the case of (1) does code carry on executing, or does it block at that point until the promise is returned? I require the code to pause until the promise if fulfilled, otherwise there’s no point checking for a 404 on an empty object."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/API/ExtendableEvent/waitUntil",
        "document": "This feature is well established and works across many devices and browser versions. It’s been available across browsers since April 2018 .\n\nThe method tells the event dispatcher that work is ongoing. It can also be used to detect whether that work was successful. In service workers, tells the browser that work is ongoing until the promise settles, and it shouldn't terminate the service worker if it wants that work to complete.\n\nThe events in service workers use to hold the service worker in the phase until tasks complete. If the promise passed to rejects, the install is considered a failure, and the installing service worker is discarded. This is primarily used to ensure that a service worker is not considered installed until all of the core caches it depends on are successfully populated.\n\nThe events in service workers use to buffer functional events such as and until the promise passed to settles. This gives the service worker time to update database schemas and delete outdated , so other events can rely on a completely upgraded state.\n\nThe method must be initially called within the event callback, but after that it can be called multiple times, until all the promises passed to it settle."
    },
    {
        "link": "https://developers.cloudflare.com/workers/runtime-apis/context",
        "document": "The Context API provides methods to manage the lifecycle of your Worker or Durable Object.\n\nContext is exposed via the following places:\n• As the third parameter in all handlers, including the handler. ( )\n• As a class property of the class\n\nextends the lifetime of your Worker, allowing you to perform work without blocking returning a response, and that may continue after a response is returned. It accepts a , which the Workers runtime will continue executing, even after a response has been returned by the Worker's handler.\n\nis commonly used to:\n• Fire off events to external analytics providers. (note that when you use Workers Analytics Engine, you do not need to use )\n• Put items into cache using the Cache API\n\nIf you are using to emit logs or exceptions, we recommend using Tail Workers instead. Even if your Worker throws an uncaught exception, the Tail Worker will execute, ensuring that you can emit logs or exceptions regardless of the Worker's invocation status. Cloudflare Queues is purpose-built for performing work out-of-band, without blocking returning a response back to the client Worker.\n\nYou can call multiple times. Similar to , even if a promise passed to one call is rejected, promises passed to other calls will still continue to execute.\n\nThe Workers Runtime uses streaming for request and response bodies. It does not buffer the body. Hence, if an exception occurs after the body has been consumed, cannot send the body again. If this causes issues, we recommend cloning the request body and handling exceptions in code. This will protect against uncaught code exceptions. However some exception times such as exceed CPU or memory limits will not be mitigated.\n\nThe method allows a Worker to fail open ↗, and pass a request through to an origin server when a Worker throws an unhandled exception. This can be useful when using Workers as a layer in front of an existing service, allowing the service behind the Worker to handle any unexpected error cases that arise in your Worker."
    },
    {
        "link": "https://core.telegram.org/bots/api",
        "document": "All queries to the Telegram Bot API must be served over HTTPS and need to be presented in this form: . Like this for example:\n\nThe boost was obtained by the creation of a Telegram Premium or a Telegram Star giveaway. This boosts the chat 4 times for the duration of the corresponding Telegram Premium subscription for Telegram Premium giveaways and prize_star_count / 500 times for one year for Telegram Star giveaways.\n• Provide Telegram with an HTTP URL for the file to be sent. Telegram will download and send the file. 5 MB max size for photos and 20 MB max for other types of content.\n\nUse this method to get basic information about a file and prepare it for downloading. For the moment, bots can download files of up to 20MB in size. On success, a File object is returned. The file can then be downloaded via the link , where is taken from the response. It is guaranteed that the link will be valid for at least 1 hour. When the link expires, a new one can be requested by calling getFile again.\n\nUse this method to set a new profile photo for the chat. Photos can't be changed for private chats. The bot must be an administrator in the chat for this to work and must have the appropriate administrator rights. Returns True on success."
    },
    {
        "link": "https://telegram-bot-sdk.readme.io/reference/sendvideo",
        "document": "Use this method to send video files, Telegram clients support mp4 videos (other formats may be sent as Document). On success, the sent Message is returned. Bots can currently send video files of up to 50 MB in size, this limit may be changed in the future.\n\nSee sendVideo official docs for a list of supported parameters and other info."
    },
    {
        "link": "https://docs.rs/telegram-bot-api/latest/telegram_bot_api/methods/struct.SendVideo.html",
        "document": "Use this method to send video files, Telegram clients support MPEG4 videos (other formats may be sent as Document). On success, the sent Message is returned. Bots can currently send video files of up to 50 MB in size, this limit may be changed in the future.\n\nUnique identifier for the target chat or username of the target channel (in the format @channelusername)\n\nVideo to send. Pass a file_id as String to send a video that exists on the Telegram servers (recommended), pass an HTTP URL as a String for Telegram to get a video from the Internet, or upload a new video using multipart/form-data. More information on Sending Files »\n\nThumbnail of the file sent; can be ignored if thumbnail generation for the file is supported server-side. The thumbnail should be in JPEG format and less than 200 kB in size. A thumbnail’s width and height should not exceed 320. Ignored if the file is not uploaded using multipart/form-data. Thumbnails can’t be reused and can be only uploaded as a new file, so you can pass “attach://<file_attach_name>” if the thumbnail was uploaded using multipart/form-data under <file_attach_name>. More information on Sending Files »\n\nVideo caption (may also be used when resending videos by file_id), 0-1024 characters after entities parsing\n\nMode for parsing entities in the video caption. See formatting options for more details.\n\nA JSON-serialized list of special entities that appear in the caption, which can be specified instead of parse_mode\n\nProtects the contents of the sent message from forwarding and saving\n\nPass True if the message should be sent even if the specified replied-to message is not found\n\nAdditional interface options. A JSON-serialized object for an inline keyboard, custom reply keyboard, instructions to remove reply keyboard or to force a reply from the user."
    },
    {
        "link": "https://hackage.haskell.org/package/telegram-bot-api/docs/Telegram-Bot-API-Methods-SendVideo.html",
        "document": "\n• None Unique identifier of the business connection on behalf of which the message will be sent.\n• None Unique identifier for the target chat or username of the target channel (in the format @channelusername)\n• None Unique identifier for the target message thread (topic) of the forum; for forum supergroups only.\n• None Video to send. Pass a file_id as String to send an video that exists on the Telegram servers (recommended), pass an HTTP URL as a String for Telegram to get a video from the Internet, or upload a new video using multipart/form-data. More info on Sending Files »\n• None Thumbnail of the file sent; can be ignored if thumbnail generation for the file is supported server-side. The thumbnail should be in JPEG format and less than 200 kB in size. A thumbnail's width and height should not exceed 320. Ignored if the file is not uploaded using multipartform-data. Thumbnails can't be reused and can be only uploaded as a new file, so you can pass “attach:file_attach_name” if the thumbnail was uploaded using multipartform-data under file_attach_name. More info on Sending Files »\n• None A JSON-serialized list of special entities that appear in the caption, which can be specified instead of .\n• None Pass , if the caption must be shown above the message media.\n• None Protects the contents of the sent message from forwarding and saving.\n• None Unique identifier of the message effect to be added to the message; for private chats only.\n• None If the message is a reply, ID of the original message\n• None Additional interface options. A JSON-serialized object for an inline keyboard, custom reply keyboard, instructions to remove reply keyboard or to force a reply from the user."
    },
    {
        "link": "https://pipedream.com/apps/telegram-bot-api/actions/send-video",
        "document": ""
    }
]