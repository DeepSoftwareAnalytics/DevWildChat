[
    {
        "link": "https://router.vuejs.org/api",
        "document": ""
    },
    {
        "link": "https://router.vuejs.org/guide/advanced/composition-api",
        "document": "The introduction of Vue's Composition API opened up new possibilities, but to be able to get the full potential out of Vue Router, we will need to use a few new functions to replace access to and in-component navigation guards.\n\nBecause we don't have access to inside of , we cannot directly access or . Instead, we use the and composables:\n\nThe object is a reactive object. In most scenarios, you should avoid watching the whole object. Instead, you can directly watch the properties you are expecting to change:\n\nNote we still have access to and in templates, so there's no need to use or if we only need those objects in the template.\n\nComposition API guards can also be used in any component rendered by , they don't have to be used directly on the route component like in-component guards.\n\nVue Router exposes the internal behavior of RouterLink as a composable. It accepts a reactive object like the props of and exposes low-level properties to build your own component or generate custom links:\n\nNote that the RouterLink's gives access to the same properties as the composable."
    },
    {
        "link": "https://router.vuejs.org/guide",
        "document": "Vue Router is the official client-side routing solution for Vue.\n\nClient-side routing is used by single-page applications (SPAs) to tie the browser URL to the content seen by the user. As users navigate around the application, the URL updates accordingly, but the page doesn't need to be reloaded from the server.\n\nVue Router is built on Vue's component system. You configure routes to tell Vue Router which components to show for each URL path.\n\nTo introduce some of the main ideas, we're going to consider this example:\n\nLet's start by looking at the root component, .\n\nThis template is using two components provided by Vue Router, and .\n\nInstead of using regular tags, we use the custom component to create links. This allows Vue Router to change the URL without reloading the page, handle URL generation, encoding, and various other features. We'll go into more detail about in later sections of the guide.\n\nThe component tells Vue Router where to render the current route component. That's the component that corresponds to the current URL path. It doesn't have to be in , you can put it anywhere to adapt it to your layout, but it does need to be included somewhere, otherwise Vue Router won't render anything.\n\nThe example above also uses . You can use in your component templates to access an object that represents the current route.\n\nThe router instance is created by calling the function :\n\nThe option defines the routes themselves, mapping URL paths to components. The component specified by the option is the one that will be rendered by the in our earlier . These route components are sometimes referred to as , though they are just normal Vue components.\n\nRoutes support various other options that we'll see later in the guide, but for now we only need and .\n\nThe option controls how routes are mapped onto URLs and vice versa. For the Playground example we're using , which ignores the browser URL entirely and uses its own internal URL instead. That works well for the Playground, but it's unlikely to be what you'd want in a real application. Typically, you'd want to use instead, or perhaps . We'll cover that topic in more detail in the guide to History modes.\n\nOnce we've created our router instance, we need to register it as a plugin by calling on our application:\n\nLike with most Vue plugins, the call to needs to happen before the call to .\n\nIf you're curious about what this plugin does, some of its responsibilities include:\n• Triggering the router to resolve the initial route.\n\nYou'll likely want to access the router from elsewhere in your application.\n\nIf you're exporting the router instance from an ES module, you could import the router instance directly where you need it. In some cases this is the best approach, but we have other options if we're inside a component.\n\nIn component templates, the router instance is exposed as . This is similar to the property we saw earlier, but note the extra on the end.\n\nIf we're using the Options API, we can access these same two properties as and in our JavaScript code. The component in the Playground example accesses the router that way:\n\nThis method is calling , which is used for programmatic navigation. We'll learn more about that later.\n\nWith the Composition API, we don't have access to the component instance via , so Vue Router includes some composables that we can use instead. in the Playground example is using that approach:\n\nIt's not necessary to understand all of that code right now. The key thing to notice is that the composables and are used to access the router instance and current route respectively.\n\nIf you'd like to see a complete example using Vite, you can use the create-vue scaffolding tool, which has the option to include Vue Router in its example project:\n\nThe example project created by create-vue uses similar features to the ones we've seen here. You may find that a useful starting point for exploring the features introduced in the next few pages of this guide.\n\nVue Router is most commonly used in applications built using a bundler (e.g. Vite) and SFCs (i.e. files). Most of the examples in this guide will be written in that style, but Vue Router itself doesn't require you to use build tools or SFCs.\n\nFor example, if you're using the of Vue and Vue Router, the libraries are exposed via global objects, rather than imports:\n\nVue Router can be used with both the Composition API and the Options API. Where relevant, the examples in this guide will show components written in both styles. Composition API examples will typically use , rather than an explicit function.\n\nIf you need a refresher about the two styles, see Vue - API Styles.\n\nThroughout the guide, we will often refer to the router instance as . This is the object returned by . How you access that object in your application will depend on the context. For example, in a component using the Composition API, it can be accessed by calling . With the Options API, it can be accessed using .\n\nSimilarly, the current route will be referred to as . It can be accessed in components using or , depending on which API the component is using.\n\nThe components and are both registered globally, so they don't need to be imported before using them in component templates. However, if you prefer, you can import them locally, e.g. .\n\nIn templates, component names can be written in either PascalCase or kebab-case. Vue's template compiler supports either format, so and are usually equivalent. You should follow whatever convention is used within your project.\n\nIf you're using in-DOM templates then the usual caveats apply: component names must be written in kebab-case and self-closing tags are not supported. So rather than writing , you would need to use instead."
    },
    {
        "link": "https://stackoverflow.com/questions/71886269/vue-3-and-vue-router-4-how-to-pass-prop-when-using-router-view-only-for-specific",
        "document": "The use case here seems a little silly but it will work for any data that needs to be passed to a component as a prop or param be it static or dynamically set per route so I think it is good information to know.\n\nAnswer by @tony19 Has other purpose according to the docs such as using along with the beforeEach Navigation Guard for an authentication check but it works well for simply adding a field/value to the specific route that can be accessed from the component.\n\nI could also just add a prop to the route as long as I don't need to do anything dynamic with it. Props can be passed in each route but not accessed in a beforeEach hook like to.meta and to.params can.\n\n2. Params and Dynamic Routing in the routes.js File\n\nAs suggested by @Witold we can use the beforeEach hook and add params dynamically. Here is what I came up with based on some research. setParams() is just a real simple way of setting params that could probably be done better but it works for demo.\n\nFor in App.vue I'm using the new v-slot way. The docs make it look like it is only neccessary for transitions and v-for and the old method even without a key attribute works for what I'm doing here. In fact all 3 methods shown in my App.vue work fine for this use case. But from this SO question and from some little info I saw in some github issues, I think the new way with v-slot is the preferred way and covers all the bases for more complex situations. Not 100% sure yet though.\n\nIn routes.js the route gets the 2 params set by my setParams method. causes the params to be copied to props. However in HomePage.vue I've only declared msg2 and msg3(set in App.vue) so msg1 has to be accessed as a param and msg2 is a prop. msg1 will show a warning in console if you try to access it as a prop since it was not declared in the props:{} property of the component.\n\nThe route is a regular route param so I make sure not to overwrite it in my setParams method so it is also available in HomePage.vue as a param\n\nI'm not sure about older versions but the current version of Vue Router works asynchronously, so life cycle hooks will not work to access $route.name. I could not find this in the docs but found the same repeating situation several times in closed github issues. We can either use something like beforeEach in the routes file as in option 2. Or we can create a watcher to watch for the change in $route.name which is what I've done for msg3.\n\nmsg3 is stored as data in App.vue will trigger the re-render of the message when it changes. The watcher calls setMsg() which is another simple, non-realistic js method that works for the demo. changeMsg() is just a method for the button in HomePage.vue to see that it works any time msg3 is changed.\n\nInstead of a watcher you can use router.isReady() in the main Vue instance.\n\nI think this waiting for the router to be ready would cause a flash of white screen though I'm not seeing it in this quick simple demo. Loading the page and watching for the route.name change would avoid that.\n\nWe can set an array, object, or array of objects globally on window or better yet, as a Vue global accessible by all components.\n\nThen access it in App.vue and set dynamic messages. Then access the global on the page component to retrieve and display the message without passing it as a prop or param.\n\nWe could also use axios or fetch API in the root app or in the page component to retrieve messages just like any other data from a database."
    },
    {
        "link": "https://bytewax.io/blog/child-routes-tabs-vue-3",
        "document": "Connect to your streaming data source and write the events to partitioned Parquet Files"
    },
    {
        "link": "https://quasar.dev/vue-components/img",
        "document": "The QImg component makes working with images (any picture format) easy and also adds a nice loading effect to it along with many other features (example: the ability to set an aspect ratio).\n\nIn the example below, we add a blur and sepia effect. Furthermore, we make use of the CSS helper class.\n\nThere are multiple ways in which the image can be displayed through the property: ‘cover’, ‘fill’ (default), ‘contain’, ‘none’, ‘scale-down’. It is basically the same thing as the CSS prop called object-fit .\n\nSome modes lead to empty space (horizontally or vertically) besides the image.\n\nYou can also configure the position through property, which is equivalent to the CSS object-position one. Its default value is “50% 50%”.\n\nWhen you have big-sized images, you can use a placeholder image (recommended to be specified in base64 encoding) like in the example below. The placeholder will be displayed until the target image gets loaded. We’re toggling the QImg tag so you can see the placeholder image in action.\n\nFor browsers that natively support the loading=“lazy” DOM attribute you can take advantage of it. Quasar will use it and tell the browser to request the image and render it only if the image is currently being displayed on screen (or when it is scrolled into the screen).\n\nOne alternative is to use the QIntersection component as a wrapper or Intersection directive.\n\nIn the example below we disable the native context menu on the images."
    },
    {
        "link": "https://github.com/quasarframework/quasar/discussions/12548",
        "document": "To see all available qualifiers, see our documentation .\n\nSaved searches Use saved searches to filter your results more quickly\n\nWe read every piece of feedback, and take your input very seriously.\n\nYou signed in with another tab or window. Reload to refresh your session.\n\nYou signed out in another tab or window. Reload to refresh your session.\n\nYou switched accounts on another tab or window. Reload to refresh your session."
    },
    {
        "link": "https://quasar.dev/options/the-q-object",
        "document": "Quasar supplies a object that you can use for various purposes. You will notice it throughout the docs.\n\nThe following sections will teach you how to use it in .vue files (with both Composition API and Options API) and outside of them.\n\nThe following is a .vue file:\n\nThe following is a .vue file:\n\nThe following is a .vue file:"
    },
    {
        "link": "https://stackoverflow.com/questions/74147049/use-prop-for-dynamic-load-image-in-quasar-vue-3",
        "document": "Im trying to pass a prop into a component to dynamic load an image with the hname fetched from a database. Im trying to use the prop as an index but Im getting error. Should be pretty straightforward but something is wrong.\n\nThe url is correct ... And if I just display\n\nIn template it shows up so the prop should be ok\n\nI have also tried pass the url for the image and the text as props. It works with the text but not the image."
    },
    {
        "link": "https://github.com/quasarframework/quasar/discussions/17308",
        "document": "To see all available qualifiers, see our documentation .\n\nSaved searches Use saved searches to filter your results more quickly\n\nWe read every piece of feedback, and take your input very seriously.\n\nYou signed in with another tab or window. Reload to refresh your session.\n\nYou signed out in another tab or window. Reload to refresh your session.\n\nYou switched accounts on another tab or window. Reload to refresh your session."
    }
]