[
    {
        "link": "https://openvpn.net/community-resources/how-to",
        "document": "OpenVPN is a full-featured SSL VPN which implements OSI layer 2 or 3 secure network extension using the industry standard SSL/TLS protocol, supports flexible client authentication methods based on certificates, smart cards, and/or username/password credentials, and allows user or group-specific access control policies using firewall rules applied to the VPN virtual interface. OpenVPN is not a web application proxy and does not operate through a web browser.\n\nOpenVPN 2.0 expands on the capabilities of OpenVPN 1.x by offering a scalable client/server mode, allowing multiple clients to connect to a single OpenVPN server process over a single TCP or UDP port. OpenVPN 2.3 includes a large number of improvements, including full IPv6 support and PolarSSL support.\n\nThis document provides step-by-step instructions for configuring an OpenVPN 2.x client/server VPN, including:\n\nThe impatient may wish to jump straight to the sample configuration files:\n\nThis HOWTO assumes that readers possess a prior understanding of basic networking concepts such as IP addresses, DNS names, netmasks, subnets, IP routing, routers, network interfaces, LANs, gateways, and firewall rules.\n\nPlease take a look at the OpenVPN books page.\n\nThe original OpenVPN 1.x HOWTO is still available, and remains relevant for point-to-point or static-key configurations.\n\nFor additional documentation, see the articles page and the OpenVPN wiki.\n\nWhile this HOWTO will guide you in setting up a scalable client/server VPN using an X509 PKI (public key infrastruction using certificates and private keys), this might be overkill if you are only looking for a simple VPN setup with a server that can handle a single client.\n\nIf you would like to get a VPN running quickly with minimal configuration, you might check out the Static Key Mini-HOWTO.\n\nOpenVPN source code and Windows installers can be downloaded here. Recent releases (2.2 and later) are also available as Debian and RPM packages; see the OpenVPN wiki for details.\n\nFor security, it's a good idea to check the file release signature after downloading.\n\nThe OpenVPN executable should be installed on both server and client machines, since the single executable provides both client and server functions.\n\nIf you are using a Linux distribution which supports RPM packages (SuSE, Fedora, Redhat, etc.), it's best to install using this mechanism. The easiest method is to find an existing binary RPM file for your distribution. You can also build your own binary RPM file:\n\nOnce you have the .rpm file, you can install it with the usual\n\nor upgrade an existing installation with\n\nInstalling OpenVPN from a binary RPM package has these dependencies:\n\nFurthermore, if you are building your own binary RPM package, there are several additional dependencies:\n\nSee the openvpn.spec file for additional notes on building an RPM package for Red Hat Linux 9 or building with reduced dependencies.\n\nIf you are using Debian, Gentoo, or a non-RPM-based Linux distribution, use your distro-specific packaging mechanism such as apt-get on Debian or emerge on Gentoo.\n\nIt is also possible to install OpenVPN on Linux using the universal ./configure method. First expand the .tar.gz file:\n\nThen cd to the top-level directory and type:\n\nOpenVPN for Windows can be installed from the self-installing exe file on the OpenVPN download page. Remember that OpenVPN will only run on Windows XP or later. Also note that OpenVPN must be installed and run by a user who has administrative privileges (this restriction is imposed by Windows, not OpenVPN). The restriction can be sidestepped by running OpenVPN in the background as a service, in which case even non-admin users will be able to access the VPN, once it is installed. More discussion on OpenVPN + Windows privilege issues.\n\nOfficial OpenVPN Windows installers include OpenVPN-GUI, which allows managing OpenVPN connections from a system tray applet. Other GUI applications are also available.\n\nAfter you've run the Windows installer, OpenVPN is ready for use and will associate itself with files having the .ovpn extension. To run OpenVPN, you can:\n\nOnce running in a command prompt window, OpenVPN can be stopped by the F4 key.\n\nAngelo Laub and Dirk Theisen have developed an OpenVPN GUI for OS X.\n\nSome notes are available in the INSTALL file for specific OSes. In general, the\n\nmethod can be used, or you can search for an OpenVPN port or package which is specific to your OS/distribution.\n\nSee FAQ for an overview of Routing vs. Ethernet Bridging. See also the OpenVPN Ethernet Bridging page for more notes and details on bridging.\n\nOverall, routing is probably a better choice for most people, as it is more efficient and easier to set up (as far as the OpenVPN configuration itself) than bridging. Routing also provides a greater ability to selectively control access rights on a client-specific basis.\n\nI would recommend using routing unless you need a specific feature which requires bridging, such as:\n\nSetting up a VPN often entails linking together private subnets from different locations.\n\nThe Internet Assigned Numbers Authority (IANA) has reserved the following three blocks of the IP address space for private internets (codified in RFC 1918):\n\nWhile addresses from these netblocks should normally be used in VPN configurations, it's important to select addresses that minimize the probability of IP address or subnet conflicts. The types of conflicts that need to be avoided are:\n\nFor example, suppose you use the popular 192.168.0.0/24 subnet as your private LAN subnet. Now you are trying to connect to the VPN from an internet cafe which is using the same subnet for its WiFi LAN. You will have a routing conflict because your machine won't know if 192.168.0.1 refers to the local WiFi gateway or to the same address on the VPN.\n\nAs another example, suppose you want to link together multiple sites by VPN, but each site is using 192.168.0.0/24 as its LAN subnet. This won't work without adding a complexifying layer of NAT translation, because the VPN won't know how to route packets between multiple sites if those sites don't use a subnet which uniquely identifies them.\n\nThe best solution is to avoid using 10.0.0.0/24 or 192.168.0.0/24 as private LAN network addresses. Instead, use something that has a lower probability of being used in a WiFi cafe, airport, or hotel where you might expect to connect from remotely. The best candidates are subnets in the middle of the vast 10.0.0.0/8 netblock (for example 10.66.77.0/24).\n\nAnd to avoid cross-site IP numbering conflicts, always use unique numbering for your LAN subnets.\n\nThe first step in building an OpenVPN 2.x configuration is to establish a PKI (public key infrastructure). The PKI consists of:\n\nOpenVPN supports bidirectional authentication based on certificates, meaning that the client must authenticate the server certificate and the server must authenticate the client certificate before mutual trust is established.\n\nBoth server and client will authenticate the other by first verifying that the presented certificate was signed by the master certificate authority (CA), and then by testing information in the now-authenticated certificate header, such as the certificate common name or certificate type (client or server).\n\nThis security model has a number of desirable features from the VPN perspective:\n\nNote that the server and client clocks need to be roughly in sync or certificates might not work properly.\n\nIn this section we will generate a master CA certificate/key, a server certificate/key, and certificates/keys for 3 separate clients.\n\nFor PKI management, we will use easy-rsa 2, a set of scripts which is bundled with OpenVPN 2.2.x and earlier. If you're using OpenVPN 2.3.x, you need to download easy-rsa 2 separately from here.\n\nFor PKI management, we will use easy-rsa 2, a set of scripts which is bundled with OpenVPN 2.2.x and earlier. If you're using OpenVPN 2.3.x, you may need to download easy-rsa 2 separately from the easy-rsa-old project page. On *NIX platforms you should look into using easy-rsa 3 instead; refer to its own documentation for details.\n\nIf you are using Linux, BSD, or a unix-like OS, open a shell and cd to the easy-rsa subdirectory. If you installed OpenVPN from an RPM or DEB file, the easy-rsa directory can usually be found in /usr/share/doc/packages/openvpn or /usr/share/doc/openvpn(it's best to copy this directory to another location such as /etc/openvpn, before any edits, so that future OpenVPN package upgrades won't overwrite your modifications). If you installed from a .tar.gz file, the easy-rsa directory will be in the top level directory of the expanded source tree.\n\nIf you are using Windows, open up a Command Prompt window and cd to \\Program Files\\OpenVPN\\easy-rsa. Run the following batch file to copy configuration files into place (this will overwrite any preexisting vars.bat and openssl.cnf files):\n\nNow edit the vars file (called vars.bat on Windows) and set the KEY_COUNTRY, KEY_PROVINCE, KEY_CITY, KEY_ORG, and KEY_EMAIL parameters. Don't leave any of these parameters blank.\n\nNext, initialize the PKI. On Linux/BSD/Unix:\n\nThe final command (build-ca) will build the certificate authority (CA) certificate and key by invoking the interactive opensslcommand:\n\nNote that in the above sequence, most queried parameters were defaulted to the values set in the varsor vars.bat files. The only parameter which must be explicitly entered is the Common Name. In the example above, I used \"OpenVPN-CA\".\n\nNext, we will generate a certificate and private key for the server. On Linux/BSD/Unix:\n\nAs in the previous step, most parameters can be defaulted. When the Common Name is queried, enter \"server\". Two other queries require positive responses, \"Sign the certificate? [y/n]\" and \"1 out of 1 certificate requests certified, commit? [y/n]\".\n\nGenerating client certificates is very similar to the previous step. On Linux/BSD/Unix:\n\nIf you would like to password-protect your client keys, substitute the build-key-pass script.\n\nRemember that for each client, make sure to type the appropriate Common Name when prompted, i.e. \"client1\", \"client2\", or \"client3\". Always use a unique common name for each client.\n\nDiffie Hellman parameters must be generated for the OpenVPN server. On Linux/BSD/Unix:\n\nNow we will find our newly-generated keys and certificates in the keys subdirectory. Here is an explanation of the relevant files:\n\nThe final step in the key generation process is to copy all files to the machines which need them, taking care to copy secret files over a secure channel.\n\nNow wait, you may say. Shouldn't it be possible to set up the PKI without a pre-existing secure channel?\n\nThe answer is ostensibly yes. In the example above, for the sake of brevity, we generated all private keys in the same place. With a bit more effort, we could have done this differently. For example, instead of generating the client certificate and keys on the server, we could have had the client generate its own private key locally, and then submit a Certificate Signing Request (CSR) to the key-signing machine. In turn, the key-signing machine could have processed the CSR and returned a signed certificate to the client. This could have been done without ever requiring that a secret .key file leave the hard drive of the machine on which it was generated.\n\nIt's best to use the OpenVPN sample configuration files as a starting point for your own configuration. These files can also be found in\n\nNote that on Linux, BSD, or unix-like OSes, the sample configuration files are named server.conf and client.conf. On Windows they are named server.ovpn and client.ovpn.\n\nThe sample server configuration file is an ideal starting point for an OpenVPN server configuration. It will create a VPN using a virtual TUN network interface (for routing), will listen for client connections on UDP port 1194 (OpenVPN's official port number), and distribute virtual addresses to connecting clients from the 10.8.0.0/24 subnet.\n\nBefore you use the sample configuration file, you should first edit the ca, cert, key, and dh parameters to point to the files you generated in the PKI section above.\n\nAt this point, the server configuration file is usable, however you still might want to customize it further:\n\nIf you want to run multiple OpenVPN instances on the same machine, each using a different configuration file, it is possible if you:\n\nThe sample client configuration file (client.conf on Linux/BSD/Unix or client.ovpn on Windows) mirrors the default directives set in the sample server configuration file.\n\nFirst, make sure the OpenVPN server will be accessible from the internet. That means:\n\nNext, make sure that the TUN/TAP interface is not firewalled.\n\nTo simplify troubleshooting, it's best to initially start the OpenVPN server from the command line (or right-click on the .ovpn file on Windows), rather than start it as a daemon or service:\n\nA normal server startup should look like this (output will vary across platforms):\n\nAs in the server configuration, it's best to initially start the OpenVPN server from the command line (or on Windows, by right-clicking on the client.ovpn file), rather than start it as a daemon or service:\n\nA normal client startup on Windows will look similar to the server output above, and should end with the Initialization Sequence Completed message.\n\nNow, try a ping across the VPN from the client. If you are using routing (i.e. dev tun in the server config file), try:\n\nIf you are using bridging (i.e. dev tap in the server config file), try to ping the IP address of a machine on the server's ethernet subnet.\n\nIf the ping succeeds, congratulations! You now have a functioning VPN.\n\nIf the ping failed or the OpenVPN client initialization failed to complete, here is a checklist of common symptoms and their solutions:\n• You get the error message: TLS Error: TLS key negotiation failed to occur within 60 seconds (check your network connectivity). This error indicates that the client was unable to establish a network connection with the server.Solutions:\n• Make sure the client is using the correct hostname/IP address and port number which will allow it to reach the OpenVPN server.\n• If the OpenVPN server machine is a single-NIC box inside a protected LAN, make sure you are using a correct port forward rule on the server's gateway firewall. For example, suppose your OpenVPN box is at 192.168.4.4 inside the firewall, listening for client connections on UDP port 1194. The NAT gateway servicing the 192.168.4.x subnet should have a port forward rule that says forward UDP port 1194 from my public IP address to 192.168.4.4.\n• Open up the server's firewall to allow incoming connections to UDP port 1194 (or whatever TCP/UDP port you have configured in the server config file).\n• You get the error message: Initialization Sequence Completed with errors-- This error can occur on Windows if (a) You don't have the DHCP client service running, or (b) You are using certain third-party personal firewalls on XP SP2.Solution: Start the DHCP client server and make sure that you are using a personal firewall which is known to work correctly on XP SP2.\n• You get the Initialization Sequence Completedmessage but the ping test fails -- This usually indicates that a firewall on either server or client is blocking VPN network traffic by filtering on the TUN/TAP interface.Solution: Disable the client firewall (if one exists) from filtering the TUN/TAP interface on the client. For example on Windows XP SP2, you can do this by going to Windows Security Center -> Windows Firewall -> Advanced and unchecking the box which corresponds to the TAP-Windows adapter (disabling the client firewall from filtering the TUN/TAP adapter is generally reasonable from a security perspective, as you are essentially telling the firewall not to block authenticated VPN traffic). Also make sure that the TUN/TAP interface on the server is not being filtered by a firewall (having said that, note that selective firewalling of the TUN/TAP interface on the server side can confer certain security benefits. See the access policies section below).\n• The connection stalls on startup when using a proto udpconfiguration, the server log file shows this line:\n\n however the client log does not show an equivalent line. Solution: You have a one-way connection from client to server. The server to client direction is blocked by a firewall, usually on the client side. The firewall can either be (a) a personal software firewall running on the client, or (b) the NAT router gateway for the client. Modify the firewall to allow returning UDP packets from the server to reach the client.\n\nSee the FAQ for additional troubleshooting information.\n\nThe lack of standards in this area means that most OSes have a different way of configuring daemons/services for autostart on boot. The best way to have this functionality configured by default is to install OpenVPN as a package, such as via RPM on Linux or using the Windows installer.\n\nIf you install OpenVPN via an RPM or DEB package on Linux, the installer will set up an initscript. When executed, the initscript will scan for .conf configuration files in /etc/openvpn, and if found, will start up a separate OpenVPN daemon for each file.\n\nThe Windows installer will set up a Service Wrapper, but leave it turned off by default. To activate it, go to Control Panel / Administrative Tools / Services, select the OpenVPN service, right-click on properties, and set the Startup Type to Automatic. This will configure the service for automatic start on the next reboot.\n\nWhen started, the OpenVPN Service Wrapper will scan the \\Program Files\\OpenVPN\\config folder for .ovpn configuration files, starting a separate OpenVPN process on each file.\n\nUse the writepid directive to write the OpenVPN daemon's PID to a file, so that you know where to send the signal (if you are starting openvpn with an initscript, the script may already be passing a --writepid directive on the openvpn command line).\n\nOn Windows, you can start OpenVPN by right clicking on an OpenVPN configuration file (.ovpn file) and selecting \"Start OpenVPN on this config file\".\n\nOnce running in this fashion, several keyboard commands are available:\n\nWhen OpenVPN is started as a service on Windows, the only way to control it is:\n• Via the service control manager (Control Panel / Administrative Tools / Services) which gives start/stop control.\n• Via the management interface (see below).\n\nWhile most configuration changes require you to restart the server, there are two directives in particular which refer to files which can be dynamically updated on-the-fly, and which will take immediate effect on the server without needing to restart the server process.\n\nclient-config-dir -- This directive sets a client configuration directory, which the OpenVPN server will scan on every incoming connection, searching for a client-specific configuration file (see the the manual page for more information). Files in this directory can be updated on-the-fly, without restarting the server. Note that changes in this directory will only take effect for new connections, not existing connections. If you would like a client-specific configuration file change to take immediate effect on a currently connected client (or one which has disconnected, but where the server has not timed-out its instance object), kill the client instance object by using the management interface (described below). This will cause the client to reconnect and use the new client-config-dir file.\n\ncrl-verify -- This directive names a Certificate Revocation List file, described below in the Revoking Certificates section. The CRL file can be modified on the fly, and changes will take effect immediately for new connections, or existing connections which are renegotiating their SSL/TLS channel (occurs once per hour by default). If you would like to kill a currently connected client whose certificate has just been added to the CRL, use the management interface (described below).\n\nwhich will output a list of current client connections to the file openvpn-status.log once per minute.\n\nThe OpenVPN management interface allows a great deal of control over a running OpenVPN process. You can use the management interface directly, by telneting to the management interface port, or indirectly by using an OpenVPN GUI which itself connects to the management interface.\n\nTo enable the management interface on either an OpenVPN server or client, add this to the configuration file:\n\nThis tells OpenVPN to listen on TCP port 7505 for management interface clients (port 7505 is an arbitrary choice -- you can use any free port).\n\nOnce OpenVPN is running, you can connect to the management interface using a telnet client. For example:\n\nFor more information, see the OpenVPN Management Interface Documentation.\n\nExpanding the scope of the VPN to include additional machines on either the client or server subnet.\n\nIncluding multiple machines on the server side when using a routed VPN (dev tun)\n\nOnce the VPN is operational in a point-to-point capacity between client and server, it may be desirable to expand the scope of the VPN so that clients can reach multiple machines on the server network, rather than only the server machine itself.\n\nFor the purpose of this example, we will assume that the server-side LAN uses a subnet of 10.66.0.0/24and the VPN IP address pool uses 10.8.0.0/24 as cited in the server directive in the OpenVPN server configuration file.\n\nFirst, you must advertise the 10.66.0.0/24 subnet to VPN clients as being accessible through the VPN. This can easily be done with the following server-side config file directive:\n\nNext, you must set up a route on the server-side LAN gateway to route the VPN client subnet (10.8.0.0/24) to the OpenVPN server (this is only necessary if the OpenVPN server and the LAN gateway are different machines).\n\nMake sure that you've enabled IP and TUN/TAP forwarding on the OpenVPN server machine.\n\nIncluding multiple machines on the server side when using a bridged VPN (dev tap)\n\nOne of the benefits of using ethernet bridging is that you get this for free without needing any additional configuration.\n\nIncluding multiple machines on the client side when using a routed VPN (dev tun)\n\nIn a typical road-warrior or remote access scenario, the client machine connects to the VPN as a single machine. But suppose the client machine is a gateway for a local LAN (such as a home office), and you would like each machine on the client LAN to be able to route through the VPN.\n\nFor this example, we will assume that the client LAN is using the 192.168.4.0/24 subnet, and that the VPN client is using a certificate with a common name of client2. Our goal is to set up the VPN so that any machine on the client LAN can communicate with any machine on the server LAN through the VPN.\n\nBefore setup, there are some basic prerequisites which must be followed:\n• The client LAN subnet (192.168.4.0/24 in our example) must not be exported to the VPN by the server or any other client sites which are using the same subnet. Every subnet which is joined to the VPN via routing must be unique.\n• The client must have a unique Common Name in its certificate (\"client2\" in our example), and the duplicate-cn flag must not be used in the OpenVPN server configuration file.\n\nFirst, make sure that IP and TUN/TAP forwarding is enabled on the client machine.\n\nNext, we will deal with the necessary configuration changes on the server side. If the server configuration file does not currently reference a client configuration directory, add one now:\n\nIn the above directive, ccd should be the name of a directory which has been pre-created in the default directory where the OpenVPN server daemon runs. On Linux this tends to be /etc/openvpn and on Windows it is usually \\Program Files\\OpenVPN\\config. When a new client connects to the OpenVPN server, the daemon will check this directory for a file which matches the common name of the connecting client. If a matching file is found, it will be read and processed for additional configuration file directives to be applied to the named client.\n\nThe next step is to create a file called client2 in the ccd directory. This file should contain the line:\n\nThis will tell the OpenVPN server that the 192.168.4.0/24 subnet should be routed to client2.\n\nNext, add the following line to the main server config file (not the ccd/client2 file):\n\nWhy the redundant route and iroute statements, you might ask? The reason is that route controls the routing from the kernel to the OpenVPN server (via the TUN interface) while iroute controls the routing from the OpenVPN server to the remote clients. Both are necessary.\n\nNext, ask yourself if you would like to allow network traffic between client2's subnet (192.168.4.0/24) and other clients of the OpenVPN server. If so, add the following to the server config file.\n\nThis will cause the OpenVPN server to advertise client2's subnet to other connecting clients.\n\nThe last step, and one that is often forgotten, is to add a route to the server's LAN gateway which directs 192.168.4.0/24 to the OpenVPN server box (you won't need this if the OpenVPN server box is the gateway for the server LAN). Suppose you were missing this step and you tried to ping a machine (not the OpenVPN server itself) on the server LAN from 192.168.4.8? The outgoing ping would probably reach the machine, but then it wouldn't know how to route the ping reply, because it would have no idea how to reach 192.168.4.0/24. The rule of thumb to use is that when routing entire LANs through the VPN (when the VPN server is not the same machine as the LAN gateway), make sure that the gateway for the LAN routes all VPN subnets to the VPN server machine.\n\nSimilarly, if the client machine running OpenVPN is not also the gateway for the client LAN, then the gateway for the client LAN must have a route which directs all subnets which should be reachable through the VPN to the OpenVPN client machine.\n\nIncluding multiple machines on the client side when using a bridged VPN (dev tap)\n\nThis requires a more complex setup (maybe not more complex in practice, but more complicated to explain in detail):\n• You must bridge the client TAP interface with the LAN-connected NIC on the client.\n• You must manually set the IP/netmask of the TAP interface on the client.\n• You must configure client-side machines to use an IP/netmask that is inside of the bridged subnet, possibly by querying a DHCP server on the OpenVPN server side of the VPN.\n\nThe OpenVPN server can push DHCP options such as DNS and WINS server addresses to clients (some caveats to be aware of). Windows clients can accept pushed DHCP options natively, while non-Windows clients can accept them by using a client-side up script which parses the foreign_option_nenvironmental variable list. See the man page for non-Windows foreign_option_n documentation and script examples.\n\nFor example, suppose you would like connecting clients to use an internal DNS server at 10.66.0.4 or 10.66.0.5 and a WINS server at 10.66.0.8. Add this to the OpenVPN server configuration:\n\nTo test this feature on Windows, run the following from a command prompt window after the machine has connected to an OpenVPN server:\n\nThe entry for the TAP-Windows adapter should show the DHCP options which were pushed by the server.\n\nSuppose we are setting up a company VPN, and we would like to establish separate access policies for 3 different classes of users:\n• System administrators -- full access to all machines on the network\n\nThe basic approach we will take is (a) segregate each user class into its own virtual IP address range, and (b) control access to machines by setting up firewall rules which key off the client's virtual IP address.\n\nIn our example, suppose that we have a variable number of employees, but only one system administrator, and two contractors. Our IP allocation approach will be to put all employees into an IP address pool, and then allocate fixed IP addresses for the system administrator and contractors.\n\nNote that one of the prerequisites of this example is that you have a software firewall running on the OpenVPN server machine which gives you the ability to define specific firewall rules. For our example, we will assume the firewall is Linux iptables.\n\nFirst, let's create a virtual IP address map according to user class:\n\nNext, let's translate this map into an OpenVPN server configuration. First of all, make sure you've followed the steps above for making the 10.66.4.0/24 subnet available to all clients (while we will configure routing to allow client access to the entire 10.66.4.0/24 subnet, we will then impose access restrictions using firewall rules to implement the above policy table).\n\nFirst, define a static unit number for our tun interface, so that we will be able to refer to it later in our firewall rules:\n\nIn the server configuration file, define the Employee IP address pool:\n\nAdd routes for the System Administrator and Contractor IP ranges:\n\nBecause we will be assigning fixed IP addresses for specific System Administrators and Contractors, we will use a client configuration directory:\n\nNow place special configuration files in the ccd subdirectory to define the fixed IP address for each non-Employee VPN client.\n\nEach pair of ifconfig-push addresses represent the virtual client and server IP endpoints. They must be taken from successive /30 subnets in order to be compatible with Windows clients and the TAP-Windows driver. Specifically, the last octet in the IP address of each endpoint pair must be taken from this set:\n\nThis completes the OpenVPN configuration. The final step is to add firewall rules to finalize the access policy. For this example, we will use firewall rules in the Linux iptables syntax:\n\nOpenVPN 2.0 and later include a feature that allows the OpenVPN server to securely obtain a username and password from a connecting client, and to use that information as a basis for authenticating the client.\n\nTo use this authentication method, first add the auth-user-pass directive to the client configuration. It will direct the OpenVPN client to query the user for a username/password, passing it on to the server over the secure TLS channel.\n\nNext, configure the server to use an authentication plugin, which may be a script, shared object, or DLL. The OpenVPN server will call the plugin every time a VPN client tries to connect, passing it the username/password entered on the client. The authentication plugin can control whether or not the OpenVPN server allows the client to connect by returning a failure (1) or success (0) value.\n\nScript plugins can be used by adding the auth-user-pass-verify directive to the server-side configuration file. For example:\n\nwill use the auth-pam.pl perl script to authenticate the username/password of connecting clients. See the description of auth-user-pass-verify in the manual page for more information.\n\nThe auth-pam.pl script is included in the OpenVPN source file distribution in the sample-scriptssubdirectory. It will authenticate users on a Linux server using a PAM authentication module, which could in turn implement shadow password, RADIUS, or LDAP authentication. auth-pam.pl is primarily intended for demonstration purposes. For real-world PAM authentication, use the openvpn-auth-pamshared object plugin described below.\n\nShared object or DLL plugins are usually compiled C modules which are loaded by the OpenVPN server at run time. For example if you are using an RPM-based OpenVPN package on Linux, the openvpn-auth-pam plugin should be already built. To use it, add this to the server-side config file:\n\nThis will tell the OpenVPN server to validate the username/password entered by clients using the loginPAM module.\n\nFor real-world production use, it's better to use the openvpn-auth-pam plugin, because it has several advantages over the auth-pam.pl script:\n• The shared object openvpn-auth-pam plugin uses a split-privilege execution model for better security. This means that the OpenVPN server can run with reduced privileges by using the directives user nobody, group nobody, and chroot, and will still be able to authenticate against the root-readable-only shadow password file.\n• OpenVPN can pass the username/password to a plugin via virtual memory, rather than via a file or the environment, which is better for local security on the server machine.\n\nIf you would like more information on developing your own plugins for use with OpenVPN, see the README files in the plugin subdirectory of the OpenVPN source distribution.\n\nTo build the openvpn-auth-pam plugin on Linux, cd to the plugin/auth-pam directory in the OpenVPN source distribution and run make.\n\nUsing username/password authentication as the only form of client authentication\n\nBy default, using auth-user-pass-verify or a username/password-checking plugin on the server will enable dual authentication, requiring that both client-certificate and username/password authentication succeed in order for the client to be authenticated.\n\nWhile it is discouraged from a security perspective, it is also possible to disable the use of client certificates, and force username/password authentication only. On the server:\n\nSuch configurations should usually also set:\n\nwhich will tell the server to use the username for indexing purposes as it would use the Common Name of a client which was authenticating via a client certificate.\n\nNote that client-cert-not-required will not obviate the need for a server certificate, so a client connecting to a server which uses client-cert-not-required may remove the cert and key directives from the client configuration file, but not the ca directive, because it is necessary for the client to verify the server certificate.\n\nHow to add dual-factor authentication to an OpenVPN configuration using client-side smart cards\n• How to modify an OpenVPN configuration to make use of cryptographic tokens\n\nDual-factor authentication is a method of authentication that combines two elements: something you have and something you know.\n\nSomething you have should be a device that cannot be duplicated; such a device can be a cryptographic token that contains a private secret key. This private key is generated inside the device and never leaves it. If a user possessing this token attempts to access protected services on a remote network, the authorization process which grants or denies network access can establish, with a high degree of certainty, that the user seeking access is in physical possession of a known, certified token.\n\nSomething you know can be a password presented to the cryptographic device. Without presenting the proper password you cannot access the private secret key. Another feature of cryptographic devices is to prohibit the use of the private secret key if the wrong password had been presented more than an allowed number of times. This behavior ensures that if a user lost his device, it would be infeasible for another person to use it.\n\nCryptographic devices are commonly called \"smart cards\" or \"tokens\", and are used in conjunction with a PKI (Public Key Infrastructure). The VPN server can examine a X.509 certificate and verify that the user holds the corresponding private secret key. Since the device cannot be duplicated and requires a valid password, the server is able to authenticate the user with a high degree of confidence.\n\nDual-factor authentication is much stronger than password-based authentication, because in the worst-case scenario, only one person at a time can use the cryptographic token. Passwords can be guessed and can be exposed to other users, so in the worst-case scenario an infinite number of people could attempt to gain unauthorized access when resources are protected using password-only authentication.\n\nIf you store the secret private key in a file, the key is usually encrypted by a password. The problem with this approach is that the encrypted key is exposed to decryption attacks or spyware/malware running on the client machine. Unlike when using a cryptographic device, the file cannot erase itself automatically after several failed decryption attempts.\n\nThis standard specifies an API, called Cryptoki, to devices which hold cryptographic information and perform cryptographic functions. Cryptoki, pronounced \"crypto-key\" and short for cryptographic token interface, follows a simple object-based approach, addressing the goals of technology independence (any kind of device) and resource sharing (multiple applications accessing multiple devices), presenting to applications a common, logical view of the device called a cryptographic token.\n\nTo summarize, PKCS#11 is a standard that can be used by application software to access cryptographic tokens such as smart cards and other devices. Most device vendors provide a library that implements the PKCS#11 provider interface -- this library can be used by applications in order to access these devices. PKCS#11 is a cross-platform, vendor-independent free standard.\n\nThe first thing you need to do is to find the provider library, it should be installed with the device drivers. Each vendor has its own library. For example, the OpenSC PKCS#11 provider is located at /usr/lib/pkcs11/opensc-pkcs11.so on Unix or at opensc-pkcs11.dll on Windows.\n\nYou should follow an enrollment procedure:\n• Create a certificate request based on the key pair, you can use OpenSC and OpenSSL in order to do that.\n• Submit the certificate request to a certificate authority, and receive a certificate.\n• Load the certificate onto the token, while noting that the id and label attributes of the certificate must match those of the private key.\n\nA configured token is a token that has a private key object and a certificate object, where both share the same id and label attributes.\n\nA simple enrollment utility is Easy-RSA 2.0 which is part of OpenVPN 2.1 series. Follow the instructions specified in the README file, and then use the pkitool in order to enroll.\n\nInitialize a token using the following command:\n\nEnroll a certificate using the following command:\n\nHow to modify an OpenVPN configuration to make use of cryptographic tokens\n\nYou should have OpenVPN 2.1 or above in order to use the PKCS#11 features.\n\nEach PKCS#11 provider can support multiple devices. In order to view the available object list you can use the following command:\n\nEach certificate/private key pair have unique \"Serialized id\" string. The serialized id string of the requested certificate should be specified to the pkcs11-id option using single quote marks.\n\nThis will select the object which matches the pkcs11-id string.\n\nThis will load two providers into OpenVPN, use the certificate specified on pkcs11-id option, and use the management interface in order to query passwords. The daemon will resume into hold state on the event when token cannot be accessed. The token will be used for 300 seconds after which the password will be re-queried, session will disconnect if management session disconnects.\n\nMany PKCS#11 providers make use of threads, in order to avoid problems caused by implementation of LinuxThreads (setuid, chroot), it is highly recommend to upgrade to Native POSIX Thread Library (NPTL) enabled glibc if you intend to use PKCS#11.\n\nOpenSC PKCS#11 provider is located at /usr/lib/pkcs11/opensc-pkcs11.so on Unix or at opensc-pkcs11.dll on Windows.\n\nPKCS#11 is a free, cross-platform vendor independent standard. CryptoAPI is a Microsoft specific API. Most smart card vendors provide support for both interfaces. In the Windows environment, the user should select which interface to use.\n\nThe current implementation of OpenVPN that uses the MS CryptoAPI (cryptoapicert option) works well as long as you don't run OpenVPN as a service. If you wish to run OpenVPN in an administrative environment using a service, the implementation will not work with most smart cards because of the following reasons:\n• Most smart card providers do not load certificates into the local machine store, so the implementation will be unable to access the user certificate.\n• If the OpenVPN client is running as a service without direct interaction with the end-user, the service cannot query the user to provide a password for the smart card, causing the password-verification process on the smart card to fail.\n\nUsing the PKCS#11 interface, you can use smart cards with OpenVPN in any implementation, since PKCS#11 does not access Microsoft stores and does not necessarily require direct interaction with the end-user.\n\nRouting all client traffic (including web-traffic) through the VPN\n\nBy default, when an OpenVPN client is active, only network traffic to and from the OpenVPN server site will pass over the VPN. General web browsing, for example, will be accomplished with direct connections that bypass the VPN.\n\nIn certain cases this behavior might not be desirable -- you might want a VPN client to tunnel all network traffic through the VPN, including general internet web browsing. While this type of VPN configuration will exact a performance penalty on the client, it gives the VPN administrator more control over security policies when a client is simultaneously connected to both the public internet and the VPN at the same time.\n\nAdd the following directive to the server configuration file:\n\nIf your VPN setup is over a wireless network, where all clients and the server are on the same wireless subnet, add the local flag:\n\nPushing the redirect-gateway option to clients will cause all IP network traffic originating on client machines to pass through the OpenVPN server. The server will need to be configured to deal with this traffic somehow, such as by NATing it to the internet, or routing it through the server site's HTTP proxy.\n\nOn Linux, you could use a command such as this to NAT the VPN client traffic to the internet:\n\nThis command assumes that the VPN subnet is 10.8.0.0/24 (taken from the server directive in the OpenVPN server configuration) and that the local ethernet interface is eth0.\n\nWhen redirect-gateway is used, OpenVPN clients will route DNS queries through the VPN, and the VPN server will need handle them. This can be accomplished by pushing a DNS server address to connecting clients which will replace their normal DNS server settings during the time that the VPN is active. For example:\n\nwill configure Windows clients (or non-Windows clients with some extra server-side scripting) to use 10.8.0.1 as their DNS server. Any address which is reachable from clients may be used as the DNS server address.\n\nRedirecting all network traffic through the VPN is not entirely a problem-free proposition. Here are some typical gotchas to be aware of:\n• Many OpenVPN client machines connecting to the internet will periodically interact with a DHCP server to renew their IP address leases. The redirect-gateway option might prevent the client from reaching the local DHCP server (because DHCP messages would be routed over the VPN), causing it to lose its IP address lease.\n• Issues exist with respect to pushing DNS addresses to Windows clients.\n• Web browsing performance on the client will be noticably slower.\n\nFor more information on the mechanics of the redirect-gateway directive, see the manual page.\n\nWhile OpenVPN clients can easily access the server via a dynamic IP address without any special configuration, things get more interesting when the server itself is on a dynamic address. While OpenVPN has no trouble handling the situation of a dynamic server, some extra configuration is required.\n\nThe first step is to get a dynamic DNS address which can be configured to \"follow\" the server every time the server's IP address changes. There are several dynamic DNS service providers available, such as dyndns.org.\n\nThe next step is to set up a mechanism so that every time the server's IP address changes, the dynamic DNS name will be quickly updated with the new IP address, allowing clients to find the server at its new IP address. There are two basic ways to accomplish this:\n• Use a NAT router appliance with dynamic DNS support (such as the Linksys BEFSR41). Most of the inexpensive NAT router appliances that are widely available have the capability to update a dynamic DNS name every time a new DHCP lease is obtained from the ISP. This setup is ideal when the OpenVPN server box is a single-NIC machine inside the firewall.\n• Use a dynamic DNS client application such as ddclient to update the dynamic DNS address whenever the server IP address changes. This setup is ideal when the machine running OpenVPN has multiple NICs and is acting as a site-wide firewall/gateway. To implement this setup, you need to set up a script to be run by your DHCP client software every time an IP address change occurs. This script should (a) run ddclientto notify your dynamic DNS provider of your new IP address and (b) restart the OpenVPN server daemon.\n\nThe OpenVPN client by default will sense when the server's IP address has changed, if the client configuration is using a remote directive which references a dynamic DNS name. The usual chain of events is that (a) the OpenVPN client fails to receive timely keepalive messages from the server's old IP address, triggering a restart, and (b) the restart causes the DNS name in the remote directive to be re-resolved, allowing the client to reconnect to the server at its new IP address.\n\nMore information can be found in the FAQ.\n\nConnecting to an OpenVPN server via an HTTP proxy.\n\nOpenVPN supports connections through an HTTP proxy, with the following authentication modes:\n\nFirst of all, HTTP proxy usage requires that you use TCP as the tunnel carrier protocol. So add the following to both client and server configurations:\n\nMake sure that any proto udp lines in the config files are deleted.\n\nNext, add the http-proxy directive to the client configuration file (see the manual page for a full description of this directive).\n\nFor example, suppose you have an HTTP proxy server on the client LAN at 192.168.4.1, which is listening for connections on port 1080. Add this to the client config:\n\nThe two authentication examples above will cause OpenVPN to prompt for a username/password from standard input. If you would instead like to place these credentials in a file, replace stdin with a filename, and place the username on line 1 of this file and the password on line 2.\n\nThis example is intended show how OpenVPN clients can connect to a Samba share over a routed dev tun tunnel. If you are ethernet bridging (dev tap), you probably don't need to follow these instructions, as OpenVPN clients should see server-side machines in their network neighborhood.\n\nFor this example, we will assume that:\n• the server-side LAN uses a subnet of 10.66.0.0/24,\n• the VPN IP address pool uses 10.8.0.0/24 (as cited in the server directive in the OpenVPN server configuration file),\n• the Samba server has an IP address of 10.66.0.4, and\n• the Samba server has already been configured and is reachable from the local LAN.\n\nIf the Samba and OpenVPN servers are running on different machines, make sure you've followed the section on expanding the scope of the VPN to include additional machines.\n\nNext, edit your Samba configuration file (smb.conf). Make sure the hosts allow directive will permit OpenVPN clients coming from the 10.8.0.0/24 subnet to connect. For example:\n\nIf you are running the Samba and OpenVPN servers on the same machine, you may want to edit the interfaces directive in the smb.conf file to also listen on the TUN interface subnet of 10.8.0.0/24:\n\nIf you are running the Samba and OpenVPN servers on the same machine, connect from an OpenVPN client to a Samba share using the folder name:\n\nIf the Samba and OpenVPN servers are on different machines, use folder name:\n\nFor example, from a command prompt window:\n\nThe OpenVPN client configuration can refer to multiple servers for load balancing and failover. For example:\n\nwill direct the OpenVPN client to attempt a connection with server1, server2, and server3 in that order. If an existing connection is broken, the OpenVPN client will retry the most recently connected server, and if that fails, will move on to the next server in the list. You can also direct the OpenVPN client to randomize its server list on startup, so that the client load will be probabilistically spread across the server pool.\n\nIf you would also like DNS resolution failures to cause the OpenVPN client to move to the next server in the list, add the following:\n\nThe 60 parameter tells the OpenVPN client to try resolving each remote DNS name for 60 seconds before moving on to the next server in the list.\n\nThe server list can also refer to multiple OpenVPN server daemons running on the same machine, each listening for connections on a different port, for example:\n\nIf your servers are multi-processor machines, running multiple OpenVPN daemons on each server can be advantageous from a performance standpoint.\n\nOpenVPN also supports the remote directive referring to a DNS name which has multiple A records in the zone configuration for the domain. In this case, the OpenVPN client will randomly choose one of the A records every time the domain is resolved.\n\nThe simplest approach to a load-balanced/failover configuration on the server is to use equivalent configuration files on each server in the cluster, except use a different virtual IP address pool for each server. For example:\n\nOne of the often-repeated maxims of network security is that one should never place so much trust in a single security component that its failure causes a catastrophic security breach. OpenVPN provides several mechanisms to add additional security layers to hedge against such an outcome.\n\nThe tls-auth directive adds an additional HMAC signature to all SSL/TLS handshake packets for integrity verification. Any UDP packet not bearing the correct HMAC signature can be dropped without further processing. The tls-auth HMAC signature provides an additional level of security above and beyond that provided by SSL/TLS. It can protect against:\n• DoS attacks or port flooding on the OpenVPN UDP port.\n• Port scanning to determine which server UDP ports are in a listening state.\n• SSL/TLS handshake initiations from unauthorized machines (while such handshakes would ultimately fail to authenticate, tls-auth can cut them off at a much earlier point).\n\nUsing tls-auth requires that you generate a shared-secret key that is used in addition to the standard RSA certificate/key:\n\nThis command will generate an OpenVPN static key and write it to the file ta.key. This key should be copied over a pre-existing secure channel to the server and all client machines. It can be placed in the same directory as the RSA .key and .crt files.\n\nWhile OpenVPN allows either the TCP or UDP protocol to be used as the VPN carrier connection, the UDP protocol will provide better protection against DoS attacks and port scanning than TCP:\n\nOpenVPN has been very carefully designed to allow root privileges to be dropped after initialization, and this feature should always be used on Linux/BSD/Solaris. Without root privileges, a running OpenVPN server daemon provides a far less enticing target to an attacker.\n\nOn Linux OpenVPN can be run completely unprivileged. This configuration is a little more complex, but provides best security.\n\nIn order to work with this configuration, OpenVPN must be configured to use iproute interface, this is done by specifying --enable-iproute2 to configure script. sudo package should also be available on your system.\n\nThis configuration uses the Linux ability to change the permission of a tun device, so that unprivileged user may access it. It also uses sudo in order to execute iproute so that interface properties and routing table may be modified.\n• \n• Write the following script and place it at: /usr/local/sbin/unpriv-ip:\n• \n• Execute visudo, and add the followings to allow user 'user1' to execute /sbin/ip:\n• You can also enable a group of users with the following command:\n• \n• Add the following to your OpenVPN configuration:\n• Please note that you must select constant X and specify tun or tap not both.\n• As root add persistant interface, and permit user and/or group to manage it, the following create tunX (replace with your own) and allow user1 and group users to access it.\n• Run OpenVPN in the context of the unprivileged user.\n\nFurther security constraints may be added by examining the parameters at the /usr/local/sbin/unpriv-ip script.\n\nThe chroot directive allows you to lock the OpenVPN daemon into a so-called chroot jail, where the daemon would not be able to access any part of the host system's filesystem except for the specific directory given as a parameter to the directive. For example,\n\nwould cause the OpenVPN daemon to cd into the jail subdirectory on initialization, and would then reorient its root filesystem to this directory so that it would be impossible thereafter for the daemon to access any files outside of jail and its subdirectory tree. This is important from a security perspective, because even if an attacker were able to compromise the server with a code insertion exploit, the exploit would be locked out of most of the server's filesystem.\n\nCaveats: because chroot reorients the filesystem (from the perspective of the daemon only), it is necessary to place any files which OpenVPN might need after initialization in the jail directory, such as:\n\nThe RSA key size is controlled by the KEY_SIZE variable in the easy-rsa/vars file, which must be set before any keys are generated. Currently set to 1024 by default, this value can reasonably be increased to 2048 with no negative impact on VPN tunnel performance, except for a slightly slower SSL/TLS renegotiation handshake which occurs once per client per hour, and a much slower one-time Diffie Hellman parameters generation process using the easy-rsa/build-dh script.\n\nOpenVPN automatically supports any cipher which is supported by the OpenSSL library, and as such can support ciphers which use large key sizes. For example, the 256-bit version of AES (Advanced Encryption Standard) can be used by adding the following to both server and client configuration files:\n\nKeep the root key (ca.key) on a standalone machine without a network connection\n\nOne of the security benefits of using an X509 PKI (as OpenVPN does) is that the root CA key (ca.key) need not be present on the OpenVPN server machine. In a high security environment, you might want to specially designate a machine for key signing purposes, keep the machine well-protected physically, and disconnect it from all networks. Floppy disks can be used to move key files back and forth, as necessary. Such measures make it extremely difficult for an attacker to steal the root key, short of physical theft of the key signing machine.\n\nRevoking a certificate means to invalidate a previously signed certificate so that it can no longer be used for authentication purposes.\n• The private key associated with the certificate is compromised or stolen.\n• The user of an encrypted private key forgets the password on the key.\n• You want to terminate a VPN user's access.\n\nAs an example, we will revoke the client2 certificate, which we generated above in the \"key generation\" section of the HOWTO.\n\nFirst open up a shell or command prompt window and cd to the easy-rsa directory as you did in the \"key generation\" section above. On Linux/BSD/Unix:\n\nYou should see output similar to this:\n\nNote the \"error 23\" in the last line. That is what you want to see, as it indicates that a certificate verification of the revoked certificate failed.\n\nThe revoke-full script will generate a CRL (certificate revocation list) file called crl.pem in the keyssubdirectory. The file should be copied to a directory where the OpenVPN server can access it, then CRL verification should be enabled in the server configuration:\n\nNow all connecting clients will have their client certificates verified against the CRL, and any positive match will result in the connection being dropped.\n• When the crl-verify option is used in OpenVPN, the CRL file will be re-read any time a new client connects or an existing client renegotiates the SSL/TLS connection (by default once per hour). This means that you can update the CRL file while the OpenVPN server daemon is running, and have the new CRL take effect immediately for newly connecting clients. If the client whose certificate you are revoking is already connected, you can restart the server via a signal (SIGUSR1 or SIGHUP) and flush all clients, or you can telnet to the management interfaceand explicitly kill the specific client instance object on the server without disturbing other clients.\n• While the crl-verify directive can be used on both the OpenVPN server and clients, it is generally unnecessary to distribute a CRL file to clients unless a server certificate has been revoked. Clients don't need to know about other client certificates which have been revoked because clients shouldn't be accepting direct connections from other clientsin the first place.\n• The CRL file is not secret, and should be made world-readable so that the OpenVPN daemon can read it after root privileges have been dropped.\n• If you are using the chrootdirective, make sure to put a copy of the CRL file in the chroot directory, since unlike most other files which OpenVPN reads, the CRL file will be read after the chroot call is executed, not before.\n• A common reason why certificates need to be revoked is that the user encrypts their private key with a password, then forgets the password. By revoking the original certificate, it is possible to generate a new certificate/key pair with the user's original common name.\n\nImportant Note on possible \"Man-in-the-Middle\" attack if clients do not verify the certificate of the server they are connecting to.\n\nTo avoid a possible Man-in-the-Middle attack where an authorized client tries to connect to another client by impersonating the server, make sure to enforce some kind of server certificate verification by clients. There are currently five different ways of accomplishing this, listed in the order of preference:\n• [OpenVPN 2.1 and above]Build your server certificates with specific key usage and extended key usage. The RFC3280 determine that the following attributes should be provided for TLS connections:\n\n You can build your server certificates with the build-key-server script (see the easy-rsadocumentation for more info). This will designate the certificate as a server-only certificate by setting the right attributes. Now add the following line to your client configuration:\n• [OpenVPN 2.0 and below] Build your server certificates with the build-key-server script (see the easy-rsa documentation for more info). This will designate the certificate as a server-only certificate by setting nsCertType=server. Now add the following line to your client configuration:\n\n This will block clients from connecting to any server which lacks the nsCertType=server designation in its certificate, even if the certificate has been signed by the ca file in the OpenVPN configuration file.\n• Use the tls-remotedirective on the client to accept/reject the server connection based on the common name of the server certificate.\n• Use a tls-verifyscript or plugin to accept/reject the server connection based on a custom test of the server certificate's embedded X509 subject details.\n• Sign server certificates with one CA and client certificates with a different CA. The client configuration ca directive should reference the server-signing CA file, while the server configuration cadirective should reference the client-signing CA file."
    },
    {
        "link": "https://ubuntu.com/server/docs/how-to-install-and-use-openvpn",
        "document": "You should have been redirected."
    },
    {
        "link": "https://openvpn.net/as-docs/linux.html",
        "document": "Use the references here to connect to a popular Linux VPN option, OpenVPN Access Server, from a Linux client or device.\n\nConnecting to Access Server from Linux requires a client program. It captures the traffic you want to send through the OpenVPN tunnel, encrypts it, passes it to the OpenVPN server, and decrypts the return traffic.\n\nAccess Server also supports VPN connections from Windows, macOS, Android, and iOS devices, typically through our official VPN client, OpenVPN Connect.\n\nHowever, with Linux, you use an open-source client or the NetworkManager GUI instead. You provide the client or VPN plugin with your connection profile and start the VPN session."
    },
    {
        "link": "https://openvpn.net/cloud-docs/tutorials/configuration-tutorials/connectors/operating-systems/linux/tutorial--learn-to-install-and-control-the-openvpn-3-client.html",
        "document": "This tutorial shows how to install the OpenVPN 3 client on various Linux distributions. In addition, commands to control the client are documented.\n\nThe OpenVPN 3 Linux project is a new client built on top of the OpenVPN 3 Core Library, which is also used in the various OpenVPN Connect clients. For more information on the project, refer to the Community Wiki.\n\nThis client is built around a completely different architecture regarding usage. It builds heavily on D-Bus and allows unprivileged users to start and manage their own VPN tunnels out-of-the-box. System Administrators wanting more control can also control and restrict this access both by hardening the default OpenVPN 3 D-Bus policy or facilitating features in OpenVPN 3 Linux.\n\nEven though the project name carries “Linux,” it doesn’t mean it is restricted to Linux only. Any platform with D-Bus available should be capable of running this client theoretically. However, since D-Bus is most commonly used in Linux environments, this will naturally be the project's primary focus.\n\nThe release notes are stored in git tags in the project git repository. They can also be viewed here: https://github.com/OpenVPN/openvpn3-linux/releases (expand the tag to see the full text).\n\nPlease note that by this point, you should have downloaded a connection profile to your machine.\n• None Download a connection profile and import it into the Configuration Manager: This stores the file under the name CloudConnexa. This flag ensures the connection profile is preserved when the system reboots. This command can be run by an ordinary, unprivileged user on the system; the user who runs this command becomes the owner of the configuration profile.\n• None Grant the root user access to the imported CloudConnexa connection profile: The --lock-down true argument is optional, but restricts the root user from extracting the contents of the connection profile via the openvpn3 commands (or via D-Bus APIs).\n• None By adding --transfer-owner-session true to the command above, the current User running this command (the owner of the Profile) also becomes the “VPN session owner” if the root is the User starting the VPN session (typically via the systemd openvpn3-session@.service).\n• None This tells systemd to enable an OpenVPN session service (openvpn3-session) to be started when the system is booting, using the configuration profile name CloudConnexa. The --now argument also instructs systemd to start the session instantly. Start the VPN session and create the necessary symlinks in system directories to ensure the service starts whenever the system reboots: The --now arguments instructs systemd to start the session immediately. This is the OpenVPN session service, openvpn3-session. At this point, the OpenVPN session can be managed via either the systemctl command using the openvpn3-session@CloudConnexa.service or using the openvpn3 session-manage, openvpn3 session-acl and openvpn3 sessions-list commands. If the connection profile ACL has --transfer-owner-session enabled, the end-user can also manage the VPN session completely without needing root privileges.\n• None To start a one-shot configuration Profile, type the following command into the Terminal: A one-shot configuration Profile means that the configuration file is parsed, loaded, and deleted from the configuration manager as soon as the VPN session has been started. No configuration file is available for re-use after this approach. This is achieved by giving the configuration file to the command directly.\n• None To import a configuration file for re-use and start a VPN session, type the following command into the Terminal: Using this approach, an imported configuration file can be used several times, and access to the configuration file itself is not needed to start VPN tunnels. By default, configuration profiles imported are only available to the User who imported the configuration file. But OpenVPN 3 Linux also provides an Access Control List feature via to grant access to specific or all users on the system. This loads the configuration Profile and stores it in memory only. That means if the system is rebooted, the configuration Profile is not preserved. If the –persistent argument is added to the command line above, the configuration Profile will be saved to disk in a directory only accessible by the User. Whenever the Configuration Manager is started, configuration files imported with –persistent will be automatically loaded as well.\n• None To start a new VPN session from an imported configuration Profile, run the following command: When a configuration Profile is available via , it can quickly be started via using the configuration Profile name (typically the filename used during the import)"
    },
    {
        "link": "https://digitalocean.com/community/tutorials/how-to-set-up-and-configure-an-openvpn-server-on-ubuntu-20-04",
        "document": "A Virtual Private Network (VPN) allows you to traverse untrusted networks as if you were on a private network. It gives you the freedom to access the internet safely and securely from your smartphone or laptop when connected to an untrusted network, like the WiFi at a hotel or coffee shop.\n\nWhen combined with HTTPS connections, this setup allows you to secure your wireless logins and transactions. You can circumvent geographical restrictions and censorship, and shield your location and any unencrypted HTTP traffic from untrusted networks.\n\nOpenVPN is a full featured, open-source Transport Layer Security (TLS) VPN solution that accommodates a wide range of configurations. In this tutorial, you will set up OpenVPN on an Ubuntu 20.04 server, and then configure it to be accessible from a client machine.\n\nTo follow this tutorial, you will need:\n• One Ubuntu 20.04 server with a sudo non-root user and a firewall enabled. To set this up, you can follow our Initial Server Setup with Ubuntu 20.04 tutorial. We will refer to this as the OpenVPN Server throughout this guide.\n• A separate Ubuntu 20.04 server set up as a private Certificate Authority (CA), which we will refer to as the CA Server throughout this guide. After executing the steps from the Initial Server Setup Guide on this server, you can follow steps 1 to 3 of our guide on How To Set Up and Configure a Certificate Authority (CA) on Ubuntu 20.04 to accomplish that.\n\nIn addition to that, you’ll need a client machine which you will use to connect to your OpenVPN Server. In this guide, we’ll call this the OpenVPN Client. For the purposes of this tutorial, it’s recommended that you use your local machine as the OpenVPN client.\n\nWith these prerequisites in place, you are ready to begin setting up and configuring an OpenVPN Server on Ubuntu 20.04.\n\nThe first step in this tutorial is to install OpenVPN and Easy-RSA. Easy-RSA is a public key infrastructure (PKI) management tool that you will use on the OpenVPN Server to generate a certificate request that you will then verify and sign on the CA Server.\n\nTo start off, update your OpenVPN Server’s package index and install OpenVPN and Easy-RSA. Both packages are available in Ubuntu’s default repositories, so you can use for the installation:\n\nNext you will need to create a new directory on the OpenVPN Server as your non-root user called :\n\nNow you will need to create a symlink from the script that the package installed into the directory that you just created:\n\nFinally, ensure the directory’s owner is your non-root sudo user and restrict access to that user using :\n\nOnce these programs are installed and have been moved to the right locations on your system, the next step is to create a Public Key Infrastructure (PKI) on the OpenVPN server so that you can request and manage TLS certificates for clients and other servers that will connect to your VPN.\n\nBefore you can create your OpenVPN server’s private key and certificate, you need to create a local Public Key Infrastructure directory on your OpenVPN server. You will use this directory to manage the server and clients’ certificate requests instead of making them directly on your CA server.\n\nTo build a PKI directory on your OpenVPN server, you’ll need to populate a file called with some default values. First you will into the directory, then you will create and edit the file using nano or your preferred text editor.\n\nOnce the file is opened, paste in the following two lines:\n\nThese are the only two lines that you need in this file on your OpenVPN server since it will not be used as a Certificate Authority. They will ensure that your private keys and certificate requests are configured to use modern Elliptic Curve Cryptography (ECC) to generate keys and secure signatures for your clients and OpenVPN server.\n\nConfiguring your OpenVPN & CA servers to use ECC means when a client and server attempt to establish a shared symmetric key, they can use Elliptic Curve algorithms to do their exchange. Using ECC for a key exchange is significantly faster than using plain Diffie-Hellman with the classic RSA algorithm since the numbers are much smaller and the computations are faster.\n\nOnce you have populated the file you can proceed with creating the PKI directory. To do so, run the script with the option. Although you already ran this command on the CA server as part of the prerequisites, it’s necessary to run it here because your OpenVPN server and CA server have separate PKI directories:\n\nNote that on your OpenVPN server there is no need to create a Certificate Authority. Your CA server is solely responsible for validating and signing certificates. The PKI on your VPN server is only used as a convenient and centralized place to store certificate requests and public certificates.\n\nAfter you’ve initialized your PKI on the OpenVPN server, you are ready to move on to the next step, which is creating an OpenVPN server certificate request and private key.\n\nNow that your OpenVPN server has all the prerequisites installed, the next step is to generate a private key and Certificate Signing Request (CSR) on your OpenVPN server. After that you’ll transfer the request over to your CA to be signed, creating the required certificate. Once you have a signed certificate, you’ll transfer it back to the OpenVPN server and install it for the server to use.\n\nTo start, navigate to the directory on your OpenVPN Server as your non-root user:\n\nNow you’ll call the with the option followed by a Common Name (CN) for the machine. The CN can be anything you like but it can be helpful to make it something descriptive. Throughout this tutorial, the OpenVPN Server’s CN will be . Be sure to include the option as well. Failing to do so will password-protect the request file which could lead to permissions issues later on.\n\nThis will create a private key for the server and a certificate request file called . Copy the server key to the directory:\n\nAfter completing these steps, you have successfully created a private key for your OpenVPN server. You have also generated a Certificate Signing Request for the OpenVPN server. The CSR is now ready for signing by your CA. In the next section of this tutorial you will learn how to sign a CSR with your CA server’s private key.\n\nIn the previous step you created a Certificate Signing Request (CSR) and private key for the OpenVPN server. Now the CA server needs to know about the certificate and validate it. Once the CA validates and relays the certificate back to the OpenVPN server, clients that trust your CA will be able to trust the OpenVPN server as well.\n\nOn the OpenVPN server, as your non-root user, use SCP or another transfer method to copy the certificate request to the CA server for signing:\n\nIf you followed the prerequisite How To Set Up and Configure a Certificate Authority (CA) on Ubuntu 20.04 tutorial, the next step is to log in to the CA server as the non-root user that you created to manage your CA. You’ll to the directory where you created your PK and then import the certificate request using the script:\n\nNext, sign the request by running the script with the option, followed by the request type and the Common Name. The request type can either be or . Since we’re working with the OpenVPN server’s certificate request, be sure to use the request type:\n\nIn the output, you’ll be prompted to verify that the request comes from a trusted source. Type then press to confirm:\n\nNote that if you encrypted your CA private key, you’ll be prompted for your password at this point.\n\nWith those steps complete, you have signed the OpenVPN server’s certificate request using the CA server’s private key. The resulting file contains the OpenVPN server’s public encryption key, as well as a signature from the CA server. The point of the signature is to tell anyone who trusts the CA server that they can also trust the OpenVPN server when they connect to it.\n\nTo finish configuring the certificates, copy the and files from the CA server to the OpenVPN server:\n\nNow back on your OpenVPN server, copy the files from to :\n\nNow your OpenVPN server is nearly ready to accept connections. In the next step you’ll perform some additional steps to increase the security of the server.\n\nFor an additional layer of security, we’ll add an extra shared secret key that the server and all clients will use with OpenVPN’s directive. This option is used to obfuscate the TLS certificate that is used when a server and client connect to each other initially. It is also used by the OpenVPN server to perform quick checks on incoming packets: if a packet is signed using the pre-shared key, then the server processes it; if it is not signed, then the server knows it is from an untrusted source and can discard it without having to perform additional decryption work.\n\nThis option will help ensure that your OpenVPN server is able to cope with unauthenticated traffic, port scans, and Denial of Service attacks, which can tie up server resources. It also makes it harder to identify OpenVPN network traffic.\n\nTo generate the pre-shared key, run the following on the OpenVPN server in the directory:\n\nThe result will be a file called . Copy it to the directory:\n\nWith these files in place on the OpenVPN server you are ready to create client certificates and key files for your users, which you will use to connect to the VPN.\n\nAlthough you can generate a private key and certificate request on your client machine and then send it to the CA to be signed, this guide outlines a process for generating the certificate request on the OpenVPN server. The benefit of this approach is that we can create a script that will automatically generate client configuration files that contain all of the required keys and certificates. This lets you avoid having to transfer keys, certificates, and configuration files to clients and streamlines the process of joining the VPN.\n\nWe will generate a single client key and certificate pair for this guide. If you have more than one client, you can repeat this process for each one. Please note, though, that you will need to pass a unique name value to the script for every client. Throughout this tutorial, the first certificate/key pair is referred to as .\n\nGet started by creating a directory structure within your home directory to store the client certificate and key files:\n\nSince you will store your clients’ certificate/key pairs and configuration files in this directory, you should lock down its permissions now as a security measure:\n\nNext, navigate back to the EasyRSA directory and run the script with the and options, along with the common name for the client:\n\nPress to confirm the common name. Then, copy the file to the directory you created earlier:\n\nNext, transfer the file to your CA Server using a secure method:\n\nNow log in to your CA Server. Then, navigate to the EasyRSA directory, and import the certificate request:\n\nNext, sign the request the same way as you did for the server in the previous step. This time, though, be sure to specify the request type:\n\nWhen prompted, enter to confirm that you intend to sign the certificate request and that it came from a trusted source:\n\nAgain, if you encrypted your CA key, you’ll be prompted for your password here.\n\nThis will create a client certificate file named . Transfer this file back to the server:\n\nBack on your OpenVPN server, copy the client certificate to the directory:\n\nNext, copy the and files to the directory as well, and set the appropriate permissions for your sudo user:\n\nWith that, your server and client’s certificates and keys have all been generated and are stored in the appropriate directories on your OpenVPN server. There are still a few actions that need to be performed with these files, but those will come in a later step. For now, you can move on to configuring OpenVPN.\n\nLike many other widely used open-source tools, OpenVPN has numerous configuration options available to customize your server for your specific needs. In this section, we will provide instructions on how to set up an OpenVPN server configuration based on one of the sample configuration files that is included within this software’s documentation.\n\nFirst, copy the sample file as a starting point for your own configuration file:\n\nOpen the new file for editing with the text editor of your choice. We’ll use nano in our example:\n\nWe’ll need to change a few lines in this file. First, find the section of the configuration by searching for the directive. This line will be enabled by default. Comment it out by adding a to the beginning of the line. Then add a new line after it containing the value only:\n\nNext, find the section on cryptographic ciphers by looking for the lines. The default value is set to , however, the cipher offers a better level of encryption, performance, and is well supported in up-to-date OpenVPN clients. We’ll comment out the default value by adding a sign to the beginning of this line, and then we’ll add another line after it containing the updated value of :\n\nRight after this line, add an directive to select the HMAC message digest algorithm. For this, is a good choice:\n\nNext, find the line containing a directive, which defines Diffie-Hellman parameters. Since we’ve configured all the certificates to use Elliptic Curve Cryptography, there is no need for a Diffie-Hellman seed file. Comment out the existing line that looks like or . The filename for the Diffie-Hellman key may be different than what is listed in the example server configuration file. Then add a line after it with the contents :\n\nNext, we want OpenVPN to run with no privileges once it has started, so we need to tell it to run with a user nobody and group nogroup. To enable this, find and uncomment the and lines by removing the sign from the beginning of each line:\n\n(Optional) Push DNS Changes to Redirect All Traffic Through the VPN\n\nThe settings above will create the VPN connection between your client and server, but will not force any connections to use the tunnel. If you wish to use the VPN to route all of your client traffic over the VPN, you will likely want to push some extra settings to the client computers.\n\nTo get started, find and uncomment the line containing . Doing this will tell your client to redirect all of its traffic through your OpenVPN Server. Be aware that enabling this functionality can cause connectivity issues with other network services, like SSH:\n\nJust below this line, find the section. Again, remove the from the beginning of both of the lines to uncomment them:\n\nThese lines will tell your client to use the free OpenDNS resolvers at the listed IP addresses. If you prefer other DNS resolvers you can substitute them in place of the highlighted IPs.\n\nThis will assist clients in reconfiguring their DNS settings to use the VPN tunnel as the default gateway.\n\nBy default, the OpenVPN server uses port and the UDP protocol to accept client connections. If you need to use a different port because of restrictive network environments that your clients might be in, you can change the option. If you are not hosting web content on your OpenVPN server, port is a popular choice since it is usually allowed through firewall rules.\n\nTo change OpenVPN to listen on port 443, open the file and find the line that looks like this:\n\nEdit it so that the port is 443:\n\nOftentimes, the protocol is restricted to that port as well. If so, find the line below the line and change the protocol from to :\n\nIf you do switch the protocol to TCP, you will need to change the directive’s value from to , as this directive is only used by UDP. Failing to do so while using TCP will cause errors when you start the OpenVPN service.\n\nFind the line at the end of the file and change the value to :\n\nIf you have no need to use a different port and protocol, it is best to leave these settings unchanged.\n\nIf you selected a different name during the command earlier, modify the and lines in the configuration file so that they point to the appropriate and files. If you used the default name, , this is already set correctly:\n\nWhen you are finished, save and close the file.\n\nYou have now finished configuring your OpenVPN general settings. In the next step, we’ll customize the server’s networking options.\n\nThere are some aspects of the server’s networking configuration that need to be tweaked so that OpenVPN can correctly route traffic through the VPN. The first of these is IP forwarding, a method for determining where IP traffic should be routed. This is essential to the VPN functionality that your server will provide.\n\nTo adjust your OpenVPN server’s default IP forwarding setting, open the file using or your preferred editor:\n\nThen add the following line at the bottom of the file:\n\nSave and close the file when you are finished.\n\nTo read the file and load the new values for the current session, type:\n\nNow your OpenVPN server will be able to forward incoming traffic from one ethernet device to another. This setting makes sure the server can direct traffic from clients that connect on the virtual VPN interface out over its other physical ethernet devices. This configuration will route all web traffic from your client via your server’s IP address, and your client’s public IP address will effectively be hidden.\n\nIn the next step you will need to configure some firewall rules to ensure that traffic to and from your OpenVPN server flows properly.\n\nSo far, you’ve installed OpenVPN on your server, configured it, and generated the keys and certificates needed for your client to access the VPN. However, you have not yet provided OpenVPN with any instructions on where to send incoming web traffic from clients. You can stipulate how the server should handle client traffic by establishing some firewall rules and routing configurations.\n\nAssuming you followed the prerequisites at the start of this tutorial, you should already have installed and running on your server. To allow OpenVPN through the firewall, you’ll need to enable masquerading, an iptables concept that provides on-the-fly dynamic network address translation (NAT) to correctly route client connections.\n\nBefore opening the firewall configuration file to add the masquerading rules, you must first find the public network interface of your machine. To do this, type:\n\nYour public interface is the string found within this command’s output that follows the word “dev”. For example, this result shows the interface named , which is highlighted below:\n\nWhen you have the interface associated with your default route, open the file to add the relevant configuration:\n\nUFW rules are typically added using the command. Rules listed in the file, though, are read and put into place before the conventional UFW rules are loaded. Towards the top of the file, add the highlighted lines below. This will set the default policy for the chain in the table and masquerade any traffic coming from the VPN. Remember to replace in the line below with the interface you found in the above command:\n\nSave and close the file when you are finished.\n\nNext, you need to tell UFW to allow forwarded packets by default as well. To do this, open the file:\n\nInside, find the directive and change the value from to :\n\nSave and close the file when you are finished.\n\nNext, adjust the firewall itself to allow traffic to OpenVPN. If you did not change the port and protocol in the file, you will need to open up UDP traffic to port . If you modified the port and/or protocol, substitute the values you selected here.\n\nIn case you forgot to add the SSH port when following the prerequisite tutorial, add it here as well:\n\nAfter adding those rules, disable and re-enable UFW to restart it and load the changes from all of the files you’ve modified:\n\nYour server is now configured to correctly handle OpenVPN traffic. With the firewall rules in place, we can start the OpenVPN service on the server.\n\nOpenVPN runs as a service, so we can use to manage it. We will configure OpenVPN to start up at boot so you can connect to your VPN at any time as long as your server is running. To do this, enable the OpenVPN service by adding it to :\n\nDouble check that the OpenVPN service is active with the following command. You should see in the output:\n\nWe’ve now completed the server-side configuration for OpenVPN. Next, you will configure your client machine and connect to the OpenVPN Server.\n\nCreating configuration files for OpenVPN clients can be somewhat involved, as every client must have its own config and each must align with the settings outlined in the server’s configuration file. Rather than writing a single configuration file that can only be used on one client, this step outlines a process for building a client configuration infrastructure which you can use to generate config files on-the-fly. You will first create a “base” configuration file then build a script which will allow you to generate unique client config files, certificates, and keys as needed.\n\nGet started by creating a new directory where you will store client configuration files within the directory you created earlier:\n\nNext, copy an example client configuration file into the directory to use as your base configuration:\n\nOpen this new file using or your preferred text editor:\n\nInside, locate the directive. This points the client to your OpenVPN server address — the public IP address of your OpenVPN server. If you decided to change the port that the OpenVPN server is listening on, you will also need to change to the port you selected:\n\nBe sure that the protocol matches the value you are using in the server configuration:\n\nNext, uncomment the and directives by removing the sign at the beginning of each line:\n\nFind the directives that set the , , and . Comment out these directives since you will add the certs and keys within the file itself shortly:\n\nSimilarly, comment out the directive, as you will add directly into the client configuration file (and the server is set up to use ):\n\nMirror the and settings that you set in the file:\n\nNext, add the directive somewhere in the file. You must set this to “1” for the VPN to function correctly on the client machine:\n\nFinally, add a few commented out lines to handle various methods that Linux based VPN clients will use for DNS resolution. You’ll add two similar, but separate sets of commented out lines. The first set is for clients that do not use to manage DNS. These clients rely on the utility to update DNS information for Linux clients.\n\nNow add another set of lines for clients that use for DNS resolution:\n\nSave and close the file when you are finished.\n\nLater in Step 13 - Installing the Client Configuration step of this tutorial you will learn how to determine how DNS resolution works on Linux clients and which section to uncomment.\n\nNext, we’ll create a script that will compile your base configuration with the relevant certificate, key, and encryption files and then place the generated configuration in the directory. Open a new file called within the directory:\n\nSave and close the file when you are finished.\n\nBefore moving on, be sure to mark this file as executable by typing:\n\nThis script will make a copy of the file you made, collect all the certificate and key files you’ve created for your client, extract their contents, append them to the copy of the base configuration file, and export all of this content into a new client configuration file. This means that, rather than having to manage the client’s configuration, certificate, and key files separately, all the required information is stored in one place. The benefit of using this method is that if you ever need to add a client in the future, you can run this script to quickly create a new config file and ensure that all the important information is stored in a single, easy-to-access location.\n\nPlease note that any time you add a new client, you will need to generate new keys and certificates for it before you can run this script and generate its configuration file. You will get some practice using this script in the next step.\n\nIf you followed along with the guide, you created a client certificate and key named and , respectively, in Step 6. You can generate a config file for these credentials by moving into your directory and running the script you made at the end of the previous step:\n\nThis will create a file named in your directory:\n\nYou need to transfer this file to the device you plan to use as the client. For instance, this could be your local computer or a mobile device.\n\nWhile the exact applications used to accomplish this transfer will depend on your device’s operating system and your personal preferences, a dependable and secure method is to use SFTP (SSH file transfer protocol) or SCP (Secure Copy) on the backend. This will transport your client’s VPN authentication files over an encrypted connection.\n\nHere is an example SFTP command which you can run from your local computer (macOS or Linux). This will copy the file we’ve created in the last step to your home directory:\n\nHere are several tools and tutorials for securely transferring files from the OpenVPN server to a local computer:\n• How To Use SFTP to Securely Transfer Files with a Remote Server\n• How To Use Filezilla to Transfer and Manage Files Securely on your VPS\n\nThis section covers how to install a client VPN profile on Windows, macOS, Linux, iOS, and Android. None of these client instructions are dependent on one another, so feel free to skip to whichever is applicable to your device.\n\nThe OpenVPN connection will have the same name as whatever you called the file. In regards to this tutorial, this means that the connection is named , aligning with the first client file you generated.\n\nDownload the OpenVPN client application for Windows from OpenVPN’s Downloads page. Choose the appropriate installer version for your version of Windows.\n\nAfter installing OpenVPN, copy the file to:\n\nWhen you launch OpenVPN, it will automatically locate the profile and make it available.\n\nYou must run OpenVPN as an administrator each time it’s used, even by administrative accounts. To do this without having to right-click and select Run as administrator every time you use the VPN, you must preset this from an administrative account. This also means that standard users will need to enter the administrator’s password to use OpenVPN. On the other hand, standard users can’t properly connect to the server unless the OpenVPN application on the client has admin rights, so the elevated privileges are necessary.\n\nTo set the OpenVPN application to always run as an administrator, right-click on its shortcut icon and go to Properties. At the bottom of the Compatibility tab, click the button to Change settings for all users. In the new window, check Run this program as an administrator.\n\nEach time you launch the OpenVPN GUI, Windows will ask if you want to allow the program to make changes to your computer. Click Yes. Launching the OpenVPN client application only puts the applet in the system tray so that you can connect and disconnect the VPN as needed; it does not actually make the VPN connection.\n\nOnce OpenVPN is started, initiate a connection by going into the system tray applet and right-clicking on the OpenVPN applet icon. This opens the context menu. Select client1 at the top of the menu (that’s your profile) and choose Connect.\n\nA status window will open showing the log output while the connection is established, and a message will show once the client is connected.\n\nDisconnect from the VPN the same way: Go into the system tray applet, right-click the OpenVPN applet icon, select the client profile and click Disconnect.\n\nTunnelblick is a free, open source OpenVPN client for macOS. You can download the latest disk image from the Tunnelblick Downloads page. Double-click the downloaded file and follow the prompts to install.\n\nTowards the end of the installation process, Tunnelblick will ask if you have any configuration files. Answer I have configuration files and let Tunnelblick finish. Open a Finder window and double-click . Tunnelblick will install the client profile. Administrative privileges are required.\n\nLaunch Tunnelblick by double-clicking the Tunnelblick icon in the Applications folder. Once Tunnelblick has been launched, there will be a Tunnelblick icon in the menu bar at the top right of the screen for controlling connections. Click on the icon, and then the Connect client1 menu item to initiate the VPN connection. If you are using custom DNS settings with Tunnelblick, you may need check “Allow changes to manually-set network settings” in the advanced configuration dialog.\n\nIf you are using Linux, there are a variety of tools that you can use depending on your distribution. Your desktop environment or window manager might also include connection utilities.\n\nThe most universal way of connecting, however, is to just use the OpenVPN software.\n\nOn Ubuntu or Debian, you can install it just as you did on the server by typing:\n\nOn CentOS you can enable the EPEL repositories and then install it by typing:\n\nFirst determine if your system is using to handle DNS resolution by checking the file:\n\nIf your system is configured to use for DNS resolution, the IP address after the option will be . There should also be comments in the file like the output that is shown that explain how is managing the file. If you have a different IP address than then chances are your system is not using and you can go to the next section on configuring Linux clients that have an script instead.\n\nTo support these clients, first install the package. It provides scripts that will force to use the VPN server for DNS resolution.\n\nOne that package is installed, configure the client to use it, and to send all DNS queries over the VPN interface. Open the client’s VPN file:\n\nNow uncomment the following lines that you added earlier:\n\nIf your system is not using to manage DNS, check to see if your distribution includes an script instead:\n\nIf your client includes the file, then edit the OpenVPN client configuration file that you transferred earlier:\n\nUncomment the three lines you added to adjust the DNS settings:\n\nIf you are using CentOS, change the directive from to to match the distribution’s available groups:\n\nNow, you can connect to the VPN by just pointing the command to the client configuration file:\n\nThis should connect you to your VPN.\n\nFrom the iTunes App Store, search for and install OpenVPN Connect, the official iOS OpenVPN client application. To transfer your iOS client configuration onto the device, connect it directly to a computer.\n\nThe process of completing the transfer with iTunes is outlined here. Open iTunes on the computer and click on iPhone > apps. Scroll down to the bottom to the File Sharing section and click the OpenVPN app. The blank window to the right, OpenVPN Documents, is for sharing files. Drag the file to the OpenVPN Documents window.\n\nNow launch the OpenVPN app on the iPhone. You will receive a notification that a new profile is ready to import. Tap the green plus sign to import it.\n\nOpenVPN is now ready to use with the new profile. Start the connection by sliding the Connect button to the On position. Disconnect by sliding the same button to Off.\n\nOpen the Google Play Store. Search for and install Android OpenVPN Connect, the official Android OpenVPN client application.\n\nYou can transfer the profile by connecting the Android device to your computer by USB and copying the file over. Alternatively, if you have an SD card reader, you can remove the device’s SD card, copy the profile onto it and then insert the card back into the Android device.\n\nStart the OpenVPN app and tap the menu to import the profile.\n\nThen navigate to the location of the saved profile (the screenshot uses ) and select your file. Tap the button to finish importing this profile.\n\nConnecting Once the profile is added, you will see a screen like this:\n\nTo connect, tap the toggle button close to the profile you want to use. You’ll see real time stats of your connection and traffic being routed through your OpenVPN server:\n\nTo disconnect, just tap the toggle button on the top left once again. You will be prompted to confirm that you want to disconnect from your VPN.\n\nOnce everything is installed, a simple check confirms everything is working properly. Without having a VPN connection enabled, open a browser and go to DNSLeakTest.\n\nThe site will return the IP address assigned by your internet service provider and as you appear to the rest of the world. To check your DNS settings through the same website, click on Extended Test and it will tell you which DNS servers you are using.\n\nNow connect the OpenVPN client to your Droplet’s VPN and refresh the browser. A completely different IP address (that of your VPN server) should now appear, and this is how you appear to the world. Again, DNSLeakTest’s Extended Test will check your DNS settings and confirm you are now using the DNS resolvers pushed by your VPN.\n\nOccasionally, you may need to revoke a client certificate to prevent further access to the OpenVPN server.\n\nTo do so, follow the example in the prerequisite tutorial on How to Set Up and Configure a Certificate Authority on Ubuntu 20.04 under the Revoking a Certificate section.\n\nOnce you have revoked a certificate for a client using those instructions, you’ll need to copy the generated file to your OpenVPN server in the directory:\n\nAt the bottom of the file, add the option, which will instruct the OpenVPN server to check the certificate revocation list that we’ve created each time a connection attempt is made:\n\nThe client should no longer be able to successfully connect to the server using the old credential.\n• Revoke the certificate with the command\n• Transfer the new file to your OpenVPN server and copy it to the directory to overwrite the old list.\n\nYou can use this process to revoke any certificates that you’ve previously issued for your server.\n\nYou should now have a fully operational virtual private network running on your OpenVPN Server. You can browse the web and download content without worrying about malicious actors tracking your activity.\n\nThere are several steps you could take to customize your OpenVPN installation even further, such as configuring your client to connect to the VPN automatically or configuring client-specific rules and access policies. For these and other OpenVPN customizations, you should consult the official OpenVPN documentation.\n\nTo configure more clients, you only need to follow steps 6 and 11-13 for each additional device. To revoke access to clients, follow step 15."
    },
    {
        "link": "https://openvpn.net/community-resources/how-to",
        "document": "OpenVPN is a full-featured SSL VPN which implements OSI layer 2 or 3 secure network extension using the industry standard SSL/TLS protocol, supports flexible client authentication methods based on certificates, smart cards, and/or username/password credentials, and allows user or group-specific access control policies using firewall rules applied to the VPN virtual interface. OpenVPN is not a web application proxy and does not operate through a web browser.\n\nOpenVPN 2.0 expands on the capabilities of OpenVPN 1.x by offering a scalable client/server mode, allowing multiple clients to connect to a single OpenVPN server process over a single TCP or UDP port. OpenVPN 2.3 includes a large number of improvements, including full IPv6 support and PolarSSL support.\n\nThis document provides step-by-step instructions for configuring an OpenVPN 2.x client/server VPN, including:\n\nThe impatient may wish to jump straight to the sample configuration files:\n\nThis HOWTO assumes that readers possess a prior understanding of basic networking concepts such as IP addresses, DNS names, netmasks, subnets, IP routing, routers, network interfaces, LANs, gateways, and firewall rules.\n\nPlease take a look at the OpenVPN books page.\n\nThe original OpenVPN 1.x HOWTO is still available, and remains relevant for point-to-point or static-key configurations.\n\nFor additional documentation, see the articles page and the OpenVPN wiki.\n\nWhile this HOWTO will guide you in setting up a scalable client/server VPN using an X509 PKI (public key infrastruction using certificates and private keys), this might be overkill if you are only looking for a simple VPN setup with a server that can handle a single client.\n\nIf you would like to get a VPN running quickly with minimal configuration, you might check out the Static Key Mini-HOWTO.\n\nOpenVPN source code and Windows installers can be downloaded here. Recent releases (2.2 and later) are also available as Debian and RPM packages; see the OpenVPN wiki for details.\n\nFor security, it's a good idea to check the file release signature after downloading.\n\nThe OpenVPN executable should be installed on both server and client machines, since the single executable provides both client and server functions.\n\nIf you are using a Linux distribution which supports RPM packages (SuSE, Fedora, Redhat, etc.), it's best to install using this mechanism. The easiest method is to find an existing binary RPM file for your distribution. You can also build your own binary RPM file:\n\nOnce you have the .rpm file, you can install it with the usual\n\nor upgrade an existing installation with\n\nInstalling OpenVPN from a binary RPM package has these dependencies:\n\nFurthermore, if you are building your own binary RPM package, there are several additional dependencies:\n\nSee the openvpn.spec file for additional notes on building an RPM package for Red Hat Linux 9 or building with reduced dependencies.\n\nIf you are using Debian, Gentoo, or a non-RPM-based Linux distribution, use your distro-specific packaging mechanism such as apt-get on Debian or emerge on Gentoo.\n\nIt is also possible to install OpenVPN on Linux using the universal ./configure method. First expand the .tar.gz file:\n\nThen cd to the top-level directory and type:\n\nOpenVPN for Windows can be installed from the self-installing exe file on the OpenVPN download page. Remember that OpenVPN will only run on Windows XP or later. Also note that OpenVPN must be installed and run by a user who has administrative privileges (this restriction is imposed by Windows, not OpenVPN). The restriction can be sidestepped by running OpenVPN in the background as a service, in which case even non-admin users will be able to access the VPN, once it is installed. More discussion on OpenVPN + Windows privilege issues.\n\nOfficial OpenVPN Windows installers include OpenVPN-GUI, which allows managing OpenVPN connections from a system tray applet. Other GUI applications are also available.\n\nAfter you've run the Windows installer, OpenVPN is ready for use and will associate itself with files having the .ovpn extension. To run OpenVPN, you can:\n\nOnce running in a command prompt window, OpenVPN can be stopped by the F4 key.\n\nAngelo Laub and Dirk Theisen have developed an OpenVPN GUI for OS X.\n\nSome notes are available in the INSTALL file for specific OSes. In general, the\n\nmethod can be used, or you can search for an OpenVPN port or package which is specific to your OS/distribution.\n\nSee FAQ for an overview of Routing vs. Ethernet Bridging. See also the OpenVPN Ethernet Bridging page for more notes and details on bridging.\n\nOverall, routing is probably a better choice for most people, as it is more efficient and easier to set up (as far as the OpenVPN configuration itself) than bridging. Routing also provides a greater ability to selectively control access rights on a client-specific basis.\n\nI would recommend using routing unless you need a specific feature which requires bridging, such as:\n\nSetting up a VPN often entails linking together private subnets from different locations.\n\nThe Internet Assigned Numbers Authority (IANA) has reserved the following three blocks of the IP address space for private internets (codified in RFC 1918):\n\nWhile addresses from these netblocks should normally be used in VPN configurations, it's important to select addresses that minimize the probability of IP address or subnet conflicts. The types of conflicts that need to be avoided are:\n\nFor example, suppose you use the popular 192.168.0.0/24 subnet as your private LAN subnet. Now you are trying to connect to the VPN from an internet cafe which is using the same subnet for its WiFi LAN. You will have a routing conflict because your machine won't know if 192.168.0.1 refers to the local WiFi gateway or to the same address on the VPN.\n\nAs another example, suppose you want to link together multiple sites by VPN, but each site is using 192.168.0.0/24 as its LAN subnet. This won't work without adding a complexifying layer of NAT translation, because the VPN won't know how to route packets between multiple sites if those sites don't use a subnet which uniquely identifies them.\n\nThe best solution is to avoid using 10.0.0.0/24 or 192.168.0.0/24 as private LAN network addresses. Instead, use something that has a lower probability of being used in a WiFi cafe, airport, or hotel where you might expect to connect from remotely. The best candidates are subnets in the middle of the vast 10.0.0.0/8 netblock (for example 10.66.77.0/24).\n\nAnd to avoid cross-site IP numbering conflicts, always use unique numbering for your LAN subnets.\n\nThe first step in building an OpenVPN 2.x configuration is to establish a PKI (public key infrastructure). The PKI consists of:\n\nOpenVPN supports bidirectional authentication based on certificates, meaning that the client must authenticate the server certificate and the server must authenticate the client certificate before mutual trust is established.\n\nBoth server and client will authenticate the other by first verifying that the presented certificate was signed by the master certificate authority (CA), and then by testing information in the now-authenticated certificate header, such as the certificate common name or certificate type (client or server).\n\nThis security model has a number of desirable features from the VPN perspective:\n\nNote that the server and client clocks need to be roughly in sync or certificates might not work properly.\n\nIn this section we will generate a master CA certificate/key, a server certificate/key, and certificates/keys for 3 separate clients.\n\nFor PKI management, we will use easy-rsa 2, a set of scripts which is bundled with OpenVPN 2.2.x and earlier. If you're using OpenVPN 2.3.x, you need to download easy-rsa 2 separately from here.\n\nFor PKI management, we will use easy-rsa 2, a set of scripts which is bundled with OpenVPN 2.2.x and earlier. If you're using OpenVPN 2.3.x, you may need to download easy-rsa 2 separately from the easy-rsa-old project page. On *NIX platforms you should look into using easy-rsa 3 instead; refer to its own documentation for details.\n\nIf you are using Linux, BSD, or a unix-like OS, open a shell and cd to the easy-rsa subdirectory. If you installed OpenVPN from an RPM or DEB file, the easy-rsa directory can usually be found in /usr/share/doc/packages/openvpn or /usr/share/doc/openvpn(it's best to copy this directory to another location such as /etc/openvpn, before any edits, so that future OpenVPN package upgrades won't overwrite your modifications). If you installed from a .tar.gz file, the easy-rsa directory will be in the top level directory of the expanded source tree.\n\nIf you are using Windows, open up a Command Prompt window and cd to \\Program Files\\OpenVPN\\easy-rsa. Run the following batch file to copy configuration files into place (this will overwrite any preexisting vars.bat and openssl.cnf files):\n\nNow edit the vars file (called vars.bat on Windows) and set the KEY_COUNTRY, KEY_PROVINCE, KEY_CITY, KEY_ORG, and KEY_EMAIL parameters. Don't leave any of these parameters blank.\n\nNext, initialize the PKI. On Linux/BSD/Unix:\n\nThe final command (build-ca) will build the certificate authority (CA) certificate and key by invoking the interactive opensslcommand:\n\nNote that in the above sequence, most queried parameters were defaulted to the values set in the varsor vars.bat files. The only parameter which must be explicitly entered is the Common Name. In the example above, I used \"OpenVPN-CA\".\n\nNext, we will generate a certificate and private key for the server. On Linux/BSD/Unix:\n\nAs in the previous step, most parameters can be defaulted. When the Common Name is queried, enter \"server\". Two other queries require positive responses, \"Sign the certificate? [y/n]\" and \"1 out of 1 certificate requests certified, commit? [y/n]\".\n\nGenerating client certificates is very similar to the previous step. On Linux/BSD/Unix:\n\nIf you would like to password-protect your client keys, substitute the build-key-pass script.\n\nRemember that for each client, make sure to type the appropriate Common Name when prompted, i.e. \"client1\", \"client2\", or \"client3\". Always use a unique common name for each client.\n\nDiffie Hellman parameters must be generated for the OpenVPN server. On Linux/BSD/Unix:\n\nNow we will find our newly-generated keys and certificates in the keys subdirectory. Here is an explanation of the relevant files:\n\nThe final step in the key generation process is to copy all files to the machines which need them, taking care to copy secret files over a secure channel.\n\nNow wait, you may say. Shouldn't it be possible to set up the PKI without a pre-existing secure channel?\n\nThe answer is ostensibly yes. In the example above, for the sake of brevity, we generated all private keys in the same place. With a bit more effort, we could have done this differently. For example, instead of generating the client certificate and keys on the server, we could have had the client generate its own private key locally, and then submit a Certificate Signing Request (CSR) to the key-signing machine. In turn, the key-signing machine could have processed the CSR and returned a signed certificate to the client. This could have been done without ever requiring that a secret .key file leave the hard drive of the machine on which it was generated.\n\nIt's best to use the OpenVPN sample configuration files as a starting point for your own configuration. These files can also be found in\n\nNote that on Linux, BSD, or unix-like OSes, the sample configuration files are named server.conf and client.conf. On Windows they are named server.ovpn and client.ovpn.\n\nThe sample server configuration file is an ideal starting point for an OpenVPN server configuration. It will create a VPN using a virtual TUN network interface (for routing), will listen for client connections on UDP port 1194 (OpenVPN's official port number), and distribute virtual addresses to connecting clients from the 10.8.0.0/24 subnet.\n\nBefore you use the sample configuration file, you should first edit the ca, cert, key, and dh parameters to point to the files you generated in the PKI section above.\n\nAt this point, the server configuration file is usable, however you still might want to customize it further:\n\nIf you want to run multiple OpenVPN instances on the same machine, each using a different configuration file, it is possible if you:\n\nThe sample client configuration file (client.conf on Linux/BSD/Unix or client.ovpn on Windows) mirrors the default directives set in the sample server configuration file.\n\nFirst, make sure the OpenVPN server will be accessible from the internet. That means:\n\nNext, make sure that the TUN/TAP interface is not firewalled.\n\nTo simplify troubleshooting, it's best to initially start the OpenVPN server from the command line (or right-click on the .ovpn file on Windows), rather than start it as a daemon or service:\n\nA normal server startup should look like this (output will vary across platforms):\n\nAs in the server configuration, it's best to initially start the OpenVPN server from the command line (or on Windows, by right-clicking on the client.ovpn file), rather than start it as a daemon or service:\n\nA normal client startup on Windows will look similar to the server output above, and should end with the Initialization Sequence Completed message.\n\nNow, try a ping across the VPN from the client. If you are using routing (i.e. dev tun in the server config file), try:\n\nIf you are using bridging (i.e. dev tap in the server config file), try to ping the IP address of a machine on the server's ethernet subnet.\n\nIf the ping succeeds, congratulations! You now have a functioning VPN.\n\nIf the ping failed or the OpenVPN client initialization failed to complete, here is a checklist of common symptoms and their solutions:\n• You get the error message: TLS Error: TLS key negotiation failed to occur within 60 seconds (check your network connectivity). This error indicates that the client was unable to establish a network connection with the server.Solutions:\n• Make sure the client is using the correct hostname/IP address and port number which will allow it to reach the OpenVPN server.\n• If the OpenVPN server machine is a single-NIC box inside a protected LAN, make sure you are using a correct port forward rule on the server's gateway firewall. For example, suppose your OpenVPN box is at 192.168.4.4 inside the firewall, listening for client connections on UDP port 1194. The NAT gateway servicing the 192.168.4.x subnet should have a port forward rule that says forward UDP port 1194 from my public IP address to 192.168.4.4.\n• Open up the server's firewall to allow incoming connections to UDP port 1194 (or whatever TCP/UDP port you have configured in the server config file).\n• You get the error message: Initialization Sequence Completed with errors-- This error can occur on Windows if (a) You don't have the DHCP client service running, or (b) You are using certain third-party personal firewalls on XP SP2.Solution: Start the DHCP client server and make sure that you are using a personal firewall which is known to work correctly on XP SP2.\n• You get the Initialization Sequence Completedmessage but the ping test fails -- This usually indicates that a firewall on either server or client is blocking VPN network traffic by filtering on the TUN/TAP interface.Solution: Disable the client firewall (if one exists) from filtering the TUN/TAP interface on the client. For example on Windows XP SP2, you can do this by going to Windows Security Center -> Windows Firewall -> Advanced and unchecking the box which corresponds to the TAP-Windows adapter (disabling the client firewall from filtering the TUN/TAP adapter is generally reasonable from a security perspective, as you are essentially telling the firewall not to block authenticated VPN traffic). Also make sure that the TUN/TAP interface on the server is not being filtered by a firewall (having said that, note that selective firewalling of the TUN/TAP interface on the server side can confer certain security benefits. See the access policies section below).\n• The connection stalls on startup when using a proto udpconfiguration, the server log file shows this line:\n\n however the client log does not show an equivalent line. Solution: You have a one-way connection from client to server. The server to client direction is blocked by a firewall, usually on the client side. The firewall can either be (a) a personal software firewall running on the client, or (b) the NAT router gateway for the client. Modify the firewall to allow returning UDP packets from the server to reach the client.\n\nSee the FAQ for additional troubleshooting information.\n\nThe lack of standards in this area means that most OSes have a different way of configuring daemons/services for autostart on boot. The best way to have this functionality configured by default is to install OpenVPN as a package, such as via RPM on Linux or using the Windows installer.\n\nIf you install OpenVPN via an RPM or DEB package on Linux, the installer will set up an initscript. When executed, the initscript will scan for .conf configuration files in /etc/openvpn, and if found, will start up a separate OpenVPN daemon for each file.\n\nThe Windows installer will set up a Service Wrapper, but leave it turned off by default. To activate it, go to Control Panel / Administrative Tools / Services, select the OpenVPN service, right-click on properties, and set the Startup Type to Automatic. This will configure the service for automatic start on the next reboot.\n\nWhen started, the OpenVPN Service Wrapper will scan the \\Program Files\\OpenVPN\\config folder for .ovpn configuration files, starting a separate OpenVPN process on each file.\n\nUse the writepid directive to write the OpenVPN daemon's PID to a file, so that you know where to send the signal (if you are starting openvpn with an initscript, the script may already be passing a --writepid directive on the openvpn command line).\n\nOn Windows, you can start OpenVPN by right clicking on an OpenVPN configuration file (.ovpn file) and selecting \"Start OpenVPN on this config file\".\n\nOnce running in this fashion, several keyboard commands are available:\n\nWhen OpenVPN is started as a service on Windows, the only way to control it is:\n• Via the service control manager (Control Panel / Administrative Tools / Services) which gives start/stop control.\n• Via the management interface (see below).\n\nWhile most configuration changes require you to restart the server, there are two directives in particular which refer to files which can be dynamically updated on-the-fly, and which will take immediate effect on the server without needing to restart the server process.\n\nclient-config-dir -- This directive sets a client configuration directory, which the OpenVPN server will scan on every incoming connection, searching for a client-specific configuration file (see the the manual page for more information). Files in this directory can be updated on-the-fly, without restarting the server. Note that changes in this directory will only take effect for new connections, not existing connections. If you would like a client-specific configuration file change to take immediate effect on a currently connected client (or one which has disconnected, but where the server has not timed-out its instance object), kill the client instance object by using the management interface (described below). This will cause the client to reconnect and use the new client-config-dir file.\n\ncrl-verify -- This directive names a Certificate Revocation List file, described below in the Revoking Certificates section. The CRL file can be modified on the fly, and changes will take effect immediately for new connections, or existing connections which are renegotiating their SSL/TLS channel (occurs once per hour by default). If you would like to kill a currently connected client whose certificate has just been added to the CRL, use the management interface (described below).\n\nwhich will output a list of current client connections to the file openvpn-status.log once per minute.\n\nThe OpenVPN management interface allows a great deal of control over a running OpenVPN process. You can use the management interface directly, by telneting to the management interface port, or indirectly by using an OpenVPN GUI which itself connects to the management interface.\n\nTo enable the management interface on either an OpenVPN server or client, add this to the configuration file:\n\nThis tells OpenVPN to listen on TCP port 7505 for management interface clients (port 7505 is an arbitrary choice -- you can use any free port).\n\nOnce OpenVPN is running, you can connect to the management interface using a telnet client. For example:\n\nFor more information, see the OpenVPN Management Interface Documentation.\n\nExpanding the scope of the VPN to include additional machines on either the client or server subnet.\n\nIncluding multiple machines on the server side when using a routed VPN (dev tun)\n\nOnce the VPN is operational in a point-to-point capacity between client and server, it may be desirable to expand the scope of the VPN so that clients can reach multiple machines on the server network, rather than only the server machine itself.\n\nFor the purpose of this example, we will assume that the server-side LAN uses a subnet of 10.66.0.0/24and the VPN IP address pool uses 10.8.0.0/24 as cited in the server directive in the OpenVPN server configuration file.\n\nFirst, you must advertise the 10.66.0.0/24 subnet to VPN clients as being accessible through the VPN. This can easily be done with the following server-side config file directive:\n\nNext, you must set up a route on the server-side LAN gateway to route the VPN client subnet (10.8.0.0/24) to the OpenVPN server (this is only necessary if the OpenVPN server and the LAN gateway are different machines).\n\nMake sure that you've enabled IP and TUN/TAP forwarding on the OpenVPN server machine.\n\nIncluding multiple machines on the server side when using a bridged VPN (dev tap)\n\nOne of the benefits of using ethernet bridging is that you get this for free without needing any additional configuration.\n\nIncluding multiple machines on the client side when using a routed VPN (dev tun)\n\nIn a typical road-warrior or remote access scenario, the client machine connects to the VPN as a single machine. But suppose the client machine is a gateway for a local LAN (such as a home office), and you would like each machine on the client LAN to be able to route through the VPN.\n\nFor this example, we will assume that the client LAN is using the 192.168.4.0/24 subnet, and that the VPN client is using a certificate with a common name of client2. Our goal is to set up the VPN so that any machine on the client LAN can communicate with any machine on the server LAN through the VPN.\n\nBefore setup, there are some basic prerequisites which must be followed:\n• The client LAN subnet (192.168.4.0/24 in our example) must not be exported to the VPN by the server or any other client sites which are using the same subnet. Every subnet which is joined to the VPN via routing must be unique.\n• The client must have a unique Common Name in its certificate (\"client2\" in our example), and the duplicate-cn flag must not be used in the OpenVPN server configuration file.\n\nFirst, make sure that IP and TUN/TAP forwarding is enabled on the client machine.\n\nNext, we will deal with the necessary configuration changes on the server side. If the server configuration file does not currently reference a client configuration directory, add one now:\n\nIn the above directive, ccd should be the name of a directory which has been pre-created in the default directory where the OpenVPN server daemon runs. On Linux this tends to be /etc/openvpn and on Windows it is usually \\Program Files\\OpenVPN\\config. When a new client connects to the OpenVPN server, the daemon will check this directory for a file which matches the common name of the connecting client. If a matching file is found, it will be read and processed for additional configuration file directives to be applied to the named client.\n\nThe next step is to create a file called client2 in the ccd directory. This file should contain the line:\n\nThis will tell the OpenVPN server that the 192.168.4.0/24 subnet should be routed to client2.\n\nNext, add the following line to the main server config file (not the ccd/client2 file):\n\nWhy the redundant route and iroute statements, you might ask? The reason is that route controls the routing from the kernel to the OpenVPN server (via the TUN interface) while iroute controls the routing from the OpenVPN server to the remote clients. Both are necessary.\n\nNext, ask yourself if you would like to allow network traffic between client2's subnet (192.168.4.0/24) and other clients of the OpenVPN server. If so, add the following to the server config file.\n\nThis will cause the OpenVPN server to advertise client2's subnet to other connecting clients.\n\nThe last step, and one that is often forgotten, is to add a route to the server's LAN gateway which directs 192.168.4.0/24 to the OpenVPN server box (you won't need this if the OpenVPN server box is the gateway for the server LAN). Suppose you were missing this step and you tried to ping a machine (not the OpenVPN server itself) on the server LAN from 192.168.4.8? The outgoing ping would probably reach the machine, but then it wouldn't know how to route the ping reply, because it would have no idea how to reach 192.168.4.0/24. The rule of thumb to use is that when routing entire LANs through the VPN (when the VPN server is not the same machine as the LAN gateway), make sure that the gateway for the LAN routes all VPN subnets to the VPN server machine.\n\nSimilarly, if the client machine running OpenVPN is not also the gateway for the client LAN, then the gateway for the client LAN must have a route which directs all subnets which should be reachable through the VPN to the OpenVPN client machine.\n\nIncluding multiple machines on the client side when using a bridged VPN (dev tap)\n\nThis requires a more complex setup (maybe not more complex in practice, but more complicated to explain in detail):\n• You must bridge the client TAP interface with the LAN-connected NIC on the client.\n• You must manually set the IP/netmask of the TAP interface on the client.\n• You must configure client-side machines to use an IP/netmask that is inside of the bridged subnet, possibly by querying a DHCP server on the OpenVPN server side of the VPN.\n\nThe OpenVPN server can push DHCP options such as DNS and WINS server addresses to clients (some caveats to be aware of). Windows clients can accept pushed DHCP options natively, while non-Windows clients can accept them by using a client-side up script which parses the foreign_option_nenvironmental variable list. See the man page for non-Windows foreign_option_n documentation and script examples.\n\nFor example, suppose you would like connecting clients to use an internal DNS server at 10.66.0.4 or 10.66.0.5 and a WINS server at 10.66.0.8. Add this to the OpenVPN server configuration:\n\nTo test this feature on Windows, run the following from a command prompt window after the machine has connected to an OpenVPN server:\n\nThe entry for the TAP-Windows adapter should show the DHCP options which were pushed by the server.\n\nSuppose we are setting up a company VPN, and we would like to establish separate access policies for 3 different classes of users:\n• System administrators -- full access to all machines on the network\n\nThe basic approach we will take is (a) segregate each user class into its own virtual IP address range, and (b) control access to machines by setting up firewall rules which key off the client's virtual IP address.\n\nIn our example, suppose that we have a variable number of employees, but only one system administrator, and two contractors. Our IP allocation approach will be to put all employees into an IP address pool, and then allocate fixed IP addresses for the system administrator and contractors.\n\nNote that one of the prerequisites of this example is that you have a software firewall running on the OpenVPN server machine which gives you the ability to define specific firewall rules. For our example, we will assume the firewall is Linux iptables.\n\nFirst, let's create a virtual IP address map according to user class:\n\nNext, let's translate this map into an OpenVPN server configuration. First of all, make sure you've followed the steps above for making the 10.66.4.0/24 subnet available to all clients (while we will configure routing to allow client access to the entire 10.66.4.0/24 subnet, we will then impose access restrictions using firewall rules to implement the above policy table).\n\nFirst, define a static unit number for our tun interface, so that we will be able to refer to it later in our firewall rules:\n\nIn the server configuration file, define the Employee IP address pool:\n\nAdd routes for the System Administrator and Contractor IP ranges:\n\nBecause we will be assigning fixed IP addresses for specific System Administrators and Contractors, we will use a client configuration directory:\n\nNow place special configuration files in the ccd subdirectory to define the fixed IP address for each non-Employee VPN client.\n\nEach pair of ifconfig-push addresses represent the virtual client and server IP endpoints. They must be taken from successive /30 subnets in order to be compatible with Windows clients and the TAP-Windows driver. Specifically, the last octet in the IP address of each endpoint pair must be taken from this set:\n\nThis completes the OpenVPN configuration. The final step is to add firewall rules to finalize the access policy. For this example, we will use firewall rules in the Linux iptables syntax:\n\nOpenVPN 2.0 and later include a feature that allows the OpenVPN server to securely obtain a username and password from a connecting client, and to use that information as a basis for authenticating the client.\n\nTo use this authentication method, first add the auth-user-pass directive to the client configuration. It will direct the OpenVPN client to query the user for a username/password, passing it on to the server over the secure TLS channel.\n\nNext, configure the server to use an authentication plugin, which may be a script, shared object, or DLL. The OpenVPN server will call the plugin every time a VPN client tries to connect, passing it the username/password entered on the client. The authentication plugin can control whether or not the OpenVPN server allows the client to connect by returning a failure (1) or success (0) value.\n\nScript plugins can be used by adding the auth-user-pass-verify directive to the server-side configuration file. For example:\n\nwill use the auth-pam.pl perl script to authenticate the username/password of connecting clients. See the description of auth-user-pass-verify in the manual page for more information.\n\nThe auth-pam.pl script is included in the OpenVPN source file distribution in the sample-scriptssubdirectory. It will authenticate users on a Linux server using a PAM authentication module, which could in turn implement shadow password, RADIUS, or LDAP authentication. auth-pam.pl is primarily intended for demonstration purposes. For real-world PAM authentication, use the openvpn-auth-pamshared object plugin described below.\n\nShared object or DLL plugins are usually compiled C modules which are loaded by the OpenVPN server at run time. For example if you are using an RPM-based OpenVPN package on Linux, the openvpn-auth-pam plugin should be already built. To use it, add this to the server-side config file:\n\nThis will tell the OpenVPN server to validate the username/password entered by clients using the loginPAM module.\n\nFor real-world production use, it's better to use the openvpn-auth-pam plugin, because it has several advantages over the auth-pam.pl script:\n• The shared object openvpn-auth-pam plugin uses a split-privilege execution model for better security. This means that the OpenVPN server can run with reduced privileges by using the directives user nobody, group nobody, and chroot, and will still be able to authenticate against the root-readable-only shadow password file.\n• OpenVPN can pass the username/password to a plugin via virtual memory, rather than via a file or the environment, which is better for local security on the server machine.\n\nIf you would like more information on developing your own plugins for use with OpenVPN, see the README files in the plugin subdirectory of the OpenVPN source distribution.\n\nTo build the openvpn-auth-pam plugin on Linux, cd to the plugin/auth-pam directory in the OpenVPN source distribution and run make.\n\nUsing username/password authentication as the only form of client authentication\n\nBy default, using auth-user-pass-verify or a username/password-checking plugin on the server will enable dual authentication, requiring that both client-certificate and username/password authentication succeed in order for the client to be authenticated.\n\nWhile it is discouraged from a security perspective, it is also possible to disable the use of client certificates, and force username/password authentication only. On the server:\n\nSuch configurations should usually also set:\n\nwhich will tell the server to use the username for indexing purposes as it would use the Common Name of a client which was authenticating via a client certificate.\n\nNote that client-cert-not-required will not obviate the need for a server certificate, so a client connecting to a server which uses client-cert-not-required may remove the cert and key directives from the client configuration file, but not the ca directive, because it is necessary for the client to verify the server certificate.\n\nHow to add dual-factor authentication to an OpenVPN configuration using client-side smart cards\n• How to modify an OpenVPN configuration to make use of cryptographic tokens\n\nDual-factor authentication is a method of authentication that combines two elements: something you have and something you know.\n\nSomething you have should be a device that cannot be duplicated; such a device can be a cryptographic token that contains a private secret key. This private key is generated inside the device and never leaves it. If a user possessing this token attempts to access protected services on a remote network, the authorization process which grants or denies network access can establish, with a high degree of certainty, that the user seeking access is in physical possession of a known, certified token.\n\nSomething you know can be a password presented to the cryptographic device. Without presenting the proper password you cannot access the private secret key. Another feature of cryptographic devices is to prohibit the use of the private secret key if the wrong password had been presented more than an allowed number of times. This behavior ensures that if a user lost his device, it would be infeasible for another person to use it.\n\nCryptographic devices are commonly called \"smart cards\" or \"tokens\", and are used in conjunction with a PKI (Public Key Infrastructure). The VPN server can examine a X.509 certificate and verify that the user holds the corresponding private secret key. Since the device cannot be duplicated and requires a valid password, the server is able to authenticate the user with a high degree of confidence.\n\nDual-factor authentication is much stronger than password-based authentication, because in the worst-case scenario, only one person at a time can use the cryptographic token. Passwords can be guessed and can be exposed to other users, so in the worst-case scenario an infinite number of people could attempt to gain unauthorized access when resources are protected using password-only authentication.\n\nIf you store the secret private key in a file, the key is usually encrypted by a password. The problem with this approach is that the encrypted key is exposed to decryption attacks or spyware/malware running on the client machine. Unlike when using a cryptographic device, the file cannot erase itself automatically after several failed decryption attempts.\n\nThis standard specifies an API, called Cryptoki, to devices which hold cryptographic information and perform cryptographic functions. Cryptoki, pronounced \"crypto-key\" and short for cryptographic token interface, follows a simple object-based approach, addressing the goals of technology independence (any kind of device) and resource sharing (multiple applications accessing multiple devices), presenting to applications a common, logical view of the device called a cryptographic token.\n\nTo summarize, PKCS#11 is a standard that can be used by application software to access cryptographic tokens such as smart cards and other devices. Most device vendors provide a library that implements the PKCS#11 provider interface -- this library can be used by applications in order to access these devices. PKCS#11 is a cross-platform, vendor-independent free standard.\n\nThe first thing you need to do is to find the provider library, it should be installed with the device drivers. Each vendor has its own library. For example, the OpenSC PKCS#11 provider is located at /usr/lib/pkcs11/opensc-pkcs11.so on Unix or at opensc-pkcs11.dll on Windows.\n\nYou should follow an enrollment procedure:\n• Create a certificate request based on the key pair, you can use OpenSC and OpenSSL in order to do that.\n• Submit the certificate request to a certificate authority, and receive a certificate.\n• Load the certificate onto the token, while noting that the id and label attributes of the certificate must match those of the private key.\n\nA configured token is a token that has a private key object and a certificate object, where both share the same id and label attributes.\n\nA simple enrollment utility is Easy-RSA 2.0 which is part of OpenVPN 2.1 series. Follow the instructions specified in the README file, and then use the pkitool in order to enroll.\n\nInitialize a token using the following command:\n\nEnroll a certificate using the following command:\n\nHow to modify an OpenVPN configuration to make use of cryptographic tokens\n\nYou should have OpenVPN 2.1 or above in order to use the PKCS#11 features.\n\nEach PKCS#11 provider can support multiple devices. In order to view the available object list you can use the following command:\n\nEach certificate/private key pair have unique \"Serialized id\" string. The serialized id string of the requested certificate should be specified to the pkcs11-id option using single quote marks.\n\nThis will select the object which matches the pkcs11-id string.\n\nThis will load two providers into OpenVPN, use the certificate specified on pkcs11-id option, and use the management interface in order to query passwords. The daemon will resume into hold state on the event when token cannot be accessed. The token will be used for 300 seconds after which the password will be re-queried, session will disconnect if management session disconnects.\n\nMany PKCS#11 providers make use of threads, in order to avoid problems caused by implementation of LinuxThreads (setuid, chroot), it is highly recommend to upgrade to Native POSIX Thread Library (NPTL) enabled glibc if you intend to use PKCS#11.\n\nOpenSC PKCS#11 provider is located at /usr/lib/pkcs11/opensc-pkcs11.so on Unix or at opensc-pkcs11.dll on Windows.\n\nPKCS#11 is a free, cross-platform vendor independent standard. CryptoAPI is a Microsoft specific API. Most smart card vendors provide support for both interfaces. In the Windows environment, the user should select which interface to use.\n\nThe current implementation of OpenVPN that uses the MS CryptoAPI (cryptoapicert option) works well as long as you don't run OpenVPN as a service. If you wish to run OpenVPN in an administrative environment using a service, the implementation will not work with most smart cards because of the following reasons:\n• Most smart card providers do not load certificates into the local machine store, so the implementation will be unable to access the user certificate.\n• If the OpenVPN client is running as a service without direct interaction with the end-user, the service cannot query the user to provide a password for the smart card, causing the password-verification process on the smart card to fail.\n\nUsing the PKCS#11 interface, you can use smart cards with OpenVPN in any implementation, since PKCS#11 does not access Microsoft stores and does not necessarily require direct interaction with the end-user.\n\nRouting all client traffic (including web-traffic) through the VPN\n\nBy default, when an OpenVPN client is active, only network traffic to and from the OpenVPN server site will pass over the VPN. General web browsing, for example, will be accomplished with direct connections that bypass the VPN.\n\nIn certain cases this behavior might not be desirable -- you might want a VPN client to tunnel all network traffic through the VPN, including general internet web browsing. While this type of VPN configuration will exact a performance penalty on the client, it gives the VPN administrator more control over security policies when a client is simultaneously connected to both the public internet and the VPN at the same time.\n\nAdd the following directive to the server configuration file:\n\nIf your VPN setup is over a wireless network, where all clients and the server are on the same wireless subnet, add the local flag:\n\nPushing the redirect-gateway option to clients will cause all IP network traffic originating on client machines to pass through the OpenVPN server. The server will need to be configured to deal with this traffic somehow, such as by NATing it to the internet, or routing it through the server site's HTTP proxy.\n\nOn Linux, you could use a command such as this to NAT the VPN client traffic to the internet:\n\nThis command assumes that the VPN subnet is 10.8.0.0/24 (taken from the server directive in the OpenVPN server configuration) and that the local ethernet interface is eth0.\n\nWhen redirect-gateway is used, OpenVPN clients will route DNS queries through the VPN, and the VPN server will need handle them. This can be accomplished by pushing a DNS server address to connecting clients which will replace their normal DNS server settings during the time that the VPN is active. For example:\n\nwill configure Windows clients (or non-Windows clients with some extra server-side scripting) to use 10.8.0.1 as their DNS server. Any address which is reachable from clients may be used as the DNS server address.\n\nRedirecting all network traffic through the VPN is not entirely a problem-free proposition. Here are some typical gotchas to be aware of:\n• Many OpenVPN client machines connecting to the internet will periodically interact with a DHCP server to renew their IP address leases. The redirect-gateway option might prevent the client from reaching the local DHCP server (because DHCP messages would be routed over the VPN), causing it to lose its IP address lease.\n• Issues exist with respect to pushing DNS addresses to Windows clients.\n• Web browsing performance on the client will be noticably slower.\n\nFor more information on the mechanics of the redirect-gateway directive, see the manual page.\n\nWhile OpenVPN clients can easily access the server via a dynamic IP address without any special configuration, things get more interesting when the server itself is on a dynamic address. While OpenVPN has no trouble handling the situation of a dynamic server, some extra configuration is required.\n\nThe first step is to get a dynamic DNS address which can be configured to \"follow\" the server every time the server's IP address changes. There are several dynamic DNS service providers available, such as dyndns.org.\n\nThe next step is to set up a mechanism so that every time the server's IP address changes, the dynamic DNS name will be quickly updated with the new IP address, allowing clients to find the server at its new IP address. There are two basic ways to accomplish this:\n• Use a NAT router appliance with dynamic DNS support (such as the Linksys BEFSR41). Most of the inexpensive NAT router appliances that are widely available have the capability to update a dynamic DNS name every time a new DHCP lease is obtained from the ISP. This setup is ideal when the OpenVPN server box is a single-NIC machine inside the firewall.\n• Use a dynamic DNS client application such as ddclient to update the dynamic DNS address whenever the server IP address changes. This setup is ideal when the machine running OpenVPN has multiple NICs and is acting as a site-wide firewall/gateway. To implement this setup, you need to set up a script to be run by your DHCP client software every time an IP address change occurs. This script should (a) run ddclientto notify your dynamic DNS provider of your new IP address and (b) restart the OpenVPN server daemon.\n\nThe OpenVPN client by default will sense when the server's IP address has changed, if the client configuration is using a remote directive which references a dynamic DNS name. The usual chain of events is that (a) the OpenVPN client fails to receive timely keepalive messages from the server's old IP address, triggering a restart, and (b) the restart causes the DNS name in the remote directive to be re-resolved, allowing the client to reconnect to the server at its new IP address.\n\nMore information can be found in the FAQ.\n\nConnecting to an OpenVPN server via an HTTP proxy.\n\nOpenVPN supports connections through an HTTP proxy, with the following authentication modes:\n\nFirst of all, HTTP proxy usage requires that you use TCP as the tunnel carrier protocol. So add the following to both client and server configurations:\n\nMake sure that any proto udp lines in the config files are deleted.\n\nNext, add the http-proxy directive to the client configuration file (see the manual page for a full description of this directive).\n\nFor example, suppose you have an HTTP proxy server on the client LAN at 192.168.4.1, which is listening for connections on port 1080. Add this to the client config:\n\nThe two authentication examples above will cause OpenVPN to prompt for a username/password from standard input. If you would instead like to place these credentials in a file, replace stdin with a filename, and place the username on line 1 of this file and the password on line 2.\n\nThis example is intended show how OpenVPN clients can connect to a Samba share over a routed dev tun tunnel. If you are ethernet bridging (dev tap), you probably don't need to follow these instructions, as OpenVPN clients should see server-side machines in their network neighborhood.\n\nFor this example, we will assume that:\n• the server-side LAN uses a subnet of 10.66.0.0/24,\n• the VPN IP address pool uses 10.8.0.0/24 (as cited in the server directive in the OpenVPN server configuration file),\n• the Samba server has an IP address of 10.66.0.4, and\n• the Samba server has already been configured and is reachable from the local LAN.\n\nIf the Samba and OpenVPN servers are running on different machines, make sure you've followed the section on expanding the scope of the VPN to include additional machines.\n\nNext, edit your Samba configuration file (smb.conf). Make sure the hosts allow directive will permit OpenVPN clients coming from the 10.8.0.0/24 subnet to connect. For example:\n\nIf you are running the Samba and OpenVPN servers on the same machine, you may want to edit the interfaces directive in the smb.conf file to also listen on the TUN interface subnet of 10.8.0.0/24:\n\nIf you are running the Samba and OpenVPN servers on the same machine, connect from an OpenVPN client to a Samba share using the folder name:\n\nIf the Samba and OpenVPN servers are on different machines, use folder name:\n\nFor example, from a command prompt window:\n\nThe OpenVPN client configuration can refer to multiple servers for load balancing and failover. For example:\n\nwill direct the OpenVPN client to attempt a connection with server1, server2, and server3 in that order. If an existing connection is broken, the OpenVPN client will retry the most recently connected server, and if that fails, will move on to the next server in the list. You can also direct the OpenVPN client to randomize its server list on startup, so that the client load will be probabilistically spread across the server pool.\n\nIf you would also like DNS resolution failures to cause the OpenVPN client to move to the next server in the list, add the following:\n\nThe 60 parameter tells the OpenVPN client to try resolving each remote DNS name for 60 seconds before moving on to the next server in the list.\n\nThe server list can also refer to multiple OpenVPN server daemons running on the same machine, each listening for connections on a different port, for example:\n\nIf your servers are multi-processor machines, running multiple OpenVPN daemons on each server can be advantageous from a performance standpoint.\n\nOpenVPN also supports the remote directive referring to a DNS name which has multiple A records in the zone configuration for the domain. In this case, the OpenVPN client will randomly choose one of the A records every time the domain is resolved.\n\nThe simplest approach to a load-balanced/failover configuration on the server is to use equivalent configuration files on each server in the cluster, except use a different virtual IP address pool for each server. For example:\n\nOne of the often-repeated maxims of network security is that one should never place so much trust in a single security component that its failure causes a catastrophic security breach. OpenVPN provides several mechanisms to add additional security layers to hedge against such an outcome.\n\nThe tls-auth directive adds an additional HMAC signature to all SSL/TLS handshake packets for integrity verification. Any UDP packet not bearing the correct HMAC signature can be dropped without further processing. The tls-auth HMAC signature provides an additional level of security above and beyond that provided by SSL/TLS. It can protect against:\n• DoS attacks or port flooding on the OpenVPN UDP port.\n• Port scanning to determine which server UDP ports are in a listening state.\n• SSL/TLS handshake initiations from unauthorized machines (while such handshakes would ultimately fail to authenticate, tls-auth can cut them off at a much earlier point).\n\nUsing tls-auth requires that you generate a shared-secret key that is used in addition to the standard RSA certificate/key:\n\nThis command will generate an OpenVPN static key and write it to the file ta.key. This key should be copied over a pre-existing secure channel to the server and all client machines. It can be placed in the same directory as the RSA .key and .crt files.\n\nWhile OpenVPN allows either the TCP or UDP protocol to be used as the VPN carrier connection, the UDP protocol will provide better protection against DoS attacks and port scanning than TCP:\n\nOpenVPN has been very carefully designed to allow root privileges to be dropped after initialization, and this feature should always be used on Linux/BSD/Solaris. Without root privileges, a running OpenVPN server daemon provides a far less enticing target to an attacker.\n\nOn Linux OpenVPN can be run completely unprivileged. This configuration is a little more complex, but provides best security.\n\nIn order to work with this configuration, OpenVPN must be configured to use iproute interface, this is done by specifying --enable-iproute2 to configure script. sudo package should also be available on your system.\n\nThis configuration uses the Linux ability to change the permission of a tun device, so that unprivileged user may access it. It also uses sudo in order to execute iproute so that interface properties and routing table may be modified.\n• \n• Write the following script and place it at: /usr/local/sbin/unpriv-ip:\n• \n• Execute visudo, and add the followings to allow user 'user1' to execute /sbin/ip:\n• You can also enable a group of users with the following command:\n• \n• Add the following to your OpenVPN configuration:\n• Please note that you must select constant X and specify tun or tap not both.\n• As root add persistant interface, and permit user and/or group to manage it, the following create tunX (replace with your own) and allow user1 and group users to access it.\n• Run OpenVPN in the context of the unprivileged user.\n\nFurther security constraints may be added by examining the parameters at the /usr/local/sbin/unpriv-ip script.\n\nThe chroot directive allows you to lock the OpenVPN daemon into a so-called chroot jail, where the daemon would not be able to access any part of the host system's filesystem except for the specific directory given as a parameter to the directive. For example,\n\nwould cause the OpenVPN daemon to cd into the jail subdirectory on initialization, and would then reorient its root filesystem to this directory so that it would be impossible thereafter for the daemon to access any files outside of jail and its subdirectory tree. This is important from a security perspective, because even if an attacker were able to compromise the server with a code insertion exploit, the exploit would be locked out of most of the server's filesystem.\n\nCaveats: because chroot reorients the filesystem (from the perspective of the daemon only), it is necessary to place any files which OpenVPN might need after initialization in the jail directory, such as:\n\nThe RSA key size is controlled by the KEY_SIZE variable in the easy-rsa/vars file, which must be set before any keys are generated. Currently set to 1024 by default, this value can reasonably be increased to 2048 with no negative impact on VPN tunnel performance, except for a slightly slower SSL/TLS renegotiation handshake which occurs once per client per hour, and a much slower one-time Diffie Hellman parameters generation process using the easy-rsa/build-dh script.\n\nOpenVPN automatically supports any cipher which is supported by the OpenSSL library, and as such can support ciphers which use large key sizes. For example, the 256-bit version of AES (Advanced Encryption Standard) can be used by adding the following to both server and client configuration files:\n\nKeep the root key (ca.key) on a standalone machine without a network connection\n\nOne of the security benefits of using an X509 PKI (as OpenVPN does) is that the root CA key (ca.key) need not be present on the OpenVPN server machine. In a high security environment, you might want to specially designate a machine for key signing purposes, keep the machine well-protected physically, and disconnect it from all networks. Floppy disks can be used to move key files back and forth, as necessary. Such measures make it extremely difficult for an attacker to steal the root key, short of physical theft of the key signing machine.\n\nRevoking a certificate means to invalidate a previously signed certificate so that it can no longer be used for authentication purposes.\n• The private key associated with the certificate is compromised or stolen.\n• The user of an encrypted private key forgets the password on the key.\n• You want to terminate a VPN user's access.\n\nAs an example, we will revoke the client2 certificate, which we generated above in the \"key generation\" section of the HOWTO.\n\nFirst open up a shell or command prompt window and cd to the easy-rsa directory as you did in the \"key generation\" section above. On Linux/BSD/Unix:\n\nYou should see output similar to this:\n\nNote the \"error 23\" in the last line. That is what you want to see, as it indicates that a certificate verification of the revoked certificate failed.\n\nThe revoke-full script will generate a CRL (certificate revocation list) file called crl.pem in the keyssubdirectory. The file should be copied to a directory where the OpenVPN server can access it, then CRL verification should be enabled in the server configuration:\n\nNow all connecting clients will have their client certificates verified against the CRL, and any positive match will result in the connection being dropped.\n• When the crl-verify option is used in OpenVPN, the CRL file will be re-read any time a new client connects or an existing client renegotiates the SSL/TLS connection (by default once per hour). This means that you can update the CRL file while the OpenVPN server daemon is running, and have the new CRL take effect immediately for newly connecting clients. If the client whose certificate you are revoking is already connected, you can restart the server via a signal (SIGUSR1 or SIGHUP) and flush all clients, or you can telnet to the management interfaceand explicitly kill the specific client instance object on the server without disturbing other clients.\n• While the crl-verify directive can be used on both the OpenVPN server and clients, it is generally unnecessary to distribute a CRL file to clients unless a server certificate has been revoked. Clients don't need to know about other client certificates which have been revoked because clients shouldn't be accepting direct connections from other clientsin the first place.\n• The CRL file is not secret, and should be made world-readable so that the OpenVPN daemon can read it after root privileges have been dropped.\n• If you are using the chrootdirective, make sure to put a copy of the CRL file in the chroot directory, since unlike most other files which OpenVPN reads, the CRL file will be read after the chroot call is executed, not before.\n• A common reason why certificates need to be revoked is that the user encrypts their private key with a password, then forgets the password. By revoking the original certificate, it is possible to generate a new certificate/key pair with the user's original common name.\n\nImportant Note on possible \"Man-in-the-Middle\" attack if clients do not verify the certificate of the server they are connecting to.\n\nTo avoid a possible Man-in-the-Middle attack where an authorized client tries to connect to another client by impersonating the server, make sure to enforce some kind of server certificate verification by clients. There are currently five different ways of accomplishing this, listed in the order of preference:\n• [OpenVPN 2.1 and above]Build your server certificates with specific key usage and extended key usage. The RFC3280 determine that the following attributes should be provided for TLS connections:\n\n You can build your server certificates with the build-key-server script (see the easy-rsadocumentation for more info). This will designate the certificate as a server-only certificate by setting the right attributes. Now add the following line to your client configuration:\n• [OpenVPN 2.0 and below] Build your server certificates with the build-key-server script (see the easy-rsa documentation for more info). This will designate the certificate as a server-only certificate by setting nsCertType=server. Now add the following line to your client configuration:\n\n This will block clients from connecting to any server which lacks the nsCertType=server designation in its certificate, even if the certificate has been signed by the ca file in the OpenVPN configuration file.\n• Use the tls-remotedirective on the client to accept/reject the server connection based on the common name of the server certificate.\n• Use a tls-verifyscript or plugin to accept/reject the server connection based on a custom test of the server certificate's embedded X509 subject details.\n• Sign server certificates with one CA and client certificates with a different CA. The client configuration ca directive should reference the server-signing CA file, while the server configuration cadirective should reference the client-signing CA file."
    },
    {
        "link": "https://forums.openvpn.net/viewtopic.php?t=15602",
        "document": "how to set up OpenVPN server via dynamic ip address\n\nI am having a hard time filling out server.conf\n\n \n\n Let me describe my problem in a little more detail: I am running OpenVPN on Ubuntu 12.04. Everything seems to work great except my clients couldn't connect to the server. I figure something must be wrong in my server.conf file, but I have no way of know which part went wrong.\n\n \n\n I have a dynamic public ip and I would like to gain access to 192.168.0.162:8069(a website that I host) from a client who has a different public ip adress.\n\n \n\n Can someone point me to the right direction? Perhaps a guide to fill out my server.conf file.\n\n \n\n Thanks everyone!"
    },
    {
        "link": "https://superuser.com/questions/1071465/openvpn-dynamic-ip-on-client-side-static-ip-on-server-side",
        "document": "Stack Exchange network consists of 183 Q&A communities including Stack Overflow, the largest, most trusted online community for developers to learn, share their knowledge, and build their careers."
    },
    {
        "link": "https://serverfault.com/questions/1102148/openvpn-adding-static-ip-for-client-dynamically-based-on-a-script",
        "document": "Stack Exchange network consists of 183 Q&A communities including Stack Overflow, the largest, most trusted online community for developers to learn, share their knowledge, and build their careers."
    },
    {
        "link": "https://reddit.com/r/selfhosted/comments/5mgcjj/tutorial_a_solution_to_dynamic_ip_addresses_using",
        "document": "This also hides whatever you are doing from your ISP.\n\nOn the VPS set it up as an openVPN server, then generate and download the .ovpn file.\n\nThe only configuration you have to do is this on the VPN server assuming your running linux:\n\nAlso enable forwarding however you want to, but I just do this this way which it is not permanent but since the server never reboots it is ok:\n\nON YOUR SERVER AT HOME:\n\nOn your server just install openvpn client and connect that's it.\n\nPoint your A/AAAA records or whatnot to your VPS IP address.\n\nThat's it you're done.\n\nEdit: As requested by u/Shamalamadindong remember to configure your security settings and install software like fail2ban, ufw ect.\n\nEdit2: This method is also network agnostic so if it works in your test environment it will work in production. It doesn't matter what's between your server and the VPN."
    }
]