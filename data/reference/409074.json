[
    {
        "link": "https://zenrows.com/blog/puppeteer-extra",
        "document": ""
    },
    {
        "link": "https://pptr.dev/api/puppeteer.launchoptions",
        "document": "If specified for Chrome, looks for a regular Chrome installation at a known system location instead of using the bundled Chrome binary.\n\nWhether to auto-open a DevTools panel for each tab. If this is set to , then will be forced to .\n\nIf true, pipes the browser process stdout and stderr to and .\n\nSpecify environment variables that will be visible to the browser.\n\nPath to a browser executable to use instead of the bundled browser. Note that Puppeteer is only guaranteed to work with the bundled browser, so use this setting at your own risk. When using this is recommended to set the property as well as Puppeteer will default to by default.\n\nWhether to run the browser in headless mode.\n‚Ä¢ launches the browser in the new headless mode.\n‚Ä¢ launches shell known as the old headless mode.\n\nIf , do not use when creating a browser. If an array is provided, these args will be filtered out. Use this with care - you probably want the default arguments Puppeteer uses.\n\nWhether to wait for the initial page to be ready. Useful when a user explicitly disables that (e.g. for Chrome)."
    },
    {
        "link": "https://github.com/berstend/puppeteer-extra/blob/master/packages/puppeteer-extra-plugin-stealth/readme.md",
        "document": "If this is your first puppeteer-extra plugin here's everything you need:\n\nPlease note: I consider this a friendly competition in a rather interesting cat and mouse game. If the other team (üëã) wants to detect headless chromium there are still ways to do that (at least I noticed a few, which I'll tackle in future updates).\n\nIt's probably impossible to prevent all ways to detect headless chromium, but it should be possible to make it so difficult that it becomes cost-prohibitive or triggers too many false-positives to be feasible.\n\nIf something new comes up or you experience a problem, please do your homework and create a PR in a respectful way (this is Github, not reddit) or I might not be motivated to help. :)\n‚Ä¢ New: - Used to set a stealthy UA string, language & platform. This also fixes issues with the prior method of setting the header through request interception (#104, kudos to @Niek)\n‚Ä¢ New: - Makes it possible to optionally override navigator.vendor (#110, thanks @Niek)\n‚Ä¢ Improved: : Now uses ES6 Proxies to pass tests (#117, thanks @aabbccsmith)\n‚Ä¢ Improved: - We now proxy the original window object and smartly redirect calls that might reveal it's true identity, as opposed to mocking it like peasants :)\n‚Ä¢ Improved: - More robust and it's now possible to set a custom locale if needed.\n\nLet's ring the bell for round 2 in this cat and mouse fight üòÑ\n‚Ä¢ New: All evasions now have a specific before and after test to make make this whole topic less voodoo\n‚Ä¢ New: - we spoof the presence of proprietary codecs in Chromium now\n‚Ä¢ New & improved: - Found a way to fix frame based detection without breaking recaptcha inline popup & other iframes (please report any issues)\n‚Ä¢ New: - Adds a missing header in headless (capitalized correctly, is all lowercase which can be detected)\n‚Ä¢ Improved: - More extensive mocking of the chrome object\n‚Ä¢ ‚≠êÔ∏è All fpscanner tests are now green, as well as all intoli tests and the test\n\nTests have been done using this test site and these scripts.\n\nUsing stealth also seems to help with maintaining a normal reCAPTCHA v3 score.\n\nNote: The official test is to be taken with a grain of salt, as the score is calculated individually per site and multiple other factors (past behaviour, IP address, etc). Based on anecdotal observations it still seems to work as a rough indicator.\n\nTip: Have a look at the recaptcha plugin if you have issues with reCAPTCHAs.\n‚Ä¢ Object? Options (optional, default )\n‚Ä¢ Set<string>? Specify which evasions to use (by default all)\n\nStealth mode: Applies various techniques to make detection of headless puppeteer harder. üíØ\n\nThere are a couple of ways the use of puppeteer can easily be detected by a target website. The addition of to the user-agent being only the most obvious one.\n\nThe goal of this plugin is to be the definite companion to puppeteer to avoid detection, applying new techniques as they surface.\n\nAs this cat & mouse game is in it's infancy and fast-paced the plugin is kept as flexibile as possible, to support quick testing and iterations.\n\nThis plugin uses 's dependency system to only require code mods for evasions that have been enabled, to keep things modular and efficient.\n\nThe plugin is a convenience wrapper that requires multiple evasion techniques automatically and comes with defaults. You could also bypass the main module and require specific evasion plugins yourself, if you whish to do so (as they're standalone plugins):\n\nPRs are welcome, if you want to add a new evasion technique I suggest you look at the template to kickstart things.\n\nThanks to Evan Sangaline and Paul Irish for kickstarting the discussion!\n\nGet all available evasions.\n\nPlease look into the evasions directory for an up to date list.\n\nEnabled evasions can be configured either through or by modifying this property.\n‚Ä¢ Object? Options\n‚Ä¢ Set<string>? Specify which evasions to use (by default all)"
    },
    {
        "link": "https://npmjs.com/package/puppeteer-extra",
        "document": "// it augments the installed puppeteer with plugin functionality. // Any number of plugins can be added through `puppeteer.use()` // Add stealth plugin and use defaults (all tricks to hide puppeteer usage) // Add adblocker plugin to block all ads and trackers (saves bandwidth) : // That's it, the rest is puppeteer usage as normal üòä : : : : : : : `All done, check the screenshots. ‚ú®`\n\nThe above example uses the and plugin, which need to be installed as well:\n\nIf you'd like to see debug output just run your script like so:\n\n\n\n puppeteer-cluster allows you to create a cluster of puppeteer workers and plays well together with . Cluster addExtra // so we could create additional ones with different plugin config. puppeteer : : page : hostname captchas : : `All done, check the screenshots. ‚ú®` For using with TypeScript, just change your imports to:\n‚Ä¢ Applies various evasion techniques to make detection of puppeteer harder.\n‚Ä¢ Solves reCAPTCHAs and hCaptchas automatically, using a single line of code: .\n‚Ä¢ Very fast & efficient blocker for ads and trackers. Reduces bandwidth & load times.\n‚Ä¢ Makes puppeteer browser debugging possible from anywhere.\n‚Ä¢ Creates a secure tunnel to make the devtools frontend (incl. screencasting) accessible from the public internet\n‚Ä¢ Makes quick puppeteer debugging and exploration fun with an interactive REPL.\n‚Ä¢ Supports all resource types, blocking can be toggled dynamically.\n‚Ä¢ Allows flash content to run on all sites without user interaction.\n‚Ä¢ Anonymizes the user-agent on all pages.\n‚Ä¢ Supports dynamic replacing, so the browser version stays intact and recent.\n‚Ä¢ Has itself a plugin interface which is used by e.g. .\n\nThese plugins have been generously contributed by members of the community. Please note that they're hosted outside the main project and not under our control or supervision.\n‚Ä¢ Use the Chromium screencast API to remotely view and interact with puppeteer sessions.\n‚Ä¢ Great for remotely intervening when an automated task gets stuck, like captchas.\n\n\n\n PRs and new plugins are welcome! The plugin API for is clean and fun to use. Have a look the PuppeteerExtraPlugin base class documentation to get going and check out the existing plugins (minimal example is the anonymize-ua plugin) for reference. We use a monorepo powered by Lerna (and yarn workspaces), ava for testing, TypeScript for the core, the standard style for linting and JSDoc heavily to auto-generate markdown documentation based on code. :-)\n\n\n\n and all plugins are tested continously in a matrix of current (stable & LTS) NodeJS and puppeteer versions. We never broke compatibility and still support puppeteer down to very early versions from 2018. A few plugins won't work in headless mode (it's noted if that's the case) due to Chrome limitations (e.g. the plugin), look into if you still require a headless experience in these circumstances.\n\nBig refactor, the core is now written in TypeScript That means out of the box type safety for fellow TS users and nice auto-completion in VSCode for JS users. Also:\n‚Ä¢ A new export, to patch any puppeteer compatible library with plugin functionality ( , etc). This also allows for multiple puppeteer instances with different plugins. The API is backwards compatible, I bumped the major version just in case I missed something. Please report any issues you might find with the new release. :)\n\nThis module acts as a drop-in replacement for .\n\nAllows PuppeteerExtraPlugin's to register themselves and to extend puppeteer with additional functionality.\n\nReturns: this The same instance (for optional chaining)\n\nThe method launches a browser instance with given arguments. The browser will be closed when the parent node.js process is closed.\n\nAll registered plugins that have a method will be called in sequence to potentially update the Object before launching the browser.\n\nAll registered plugins that have a method will be called in sequence to potentially update the Object before launching the browser.\n\nThe default flags that Chromium will be launched with.\n\nThis methods attaches Puppeteer to an existing Chromium instance.\n\nGet a list of all registered plugins.\n\nCollects the exposed property of all registered plugins. Will be reduced/flattened to a single array.\n\nCan be accessed by plugins that listed the requirement.\n\nImplemented mainly for plugins that need data from other plugins (e.g. ).\n\nThe default export will behave exactly the same as the regular puppeteer (just with extra plugin functionality) and can be used as a drop-in replacement.\n\nBehind the scenes it will try to require either or from the installed dependencies.\n\nAn alternative way to use : Augments the provided puppeteer with extra plugin functionality.\n\nThis is useful in case you need multiple puppeteer instances with different plugins or to add plugins to a non-standard puppeteer package."
    },
    {
        "link": "https://stackoverflow.com/questions/63818869/why-does-headless-need-to-be-false-for-puppeteer-to-work",
        "document": "The reason it might work in UI mode but not headless is that sites who aggressively fight scraping will detect that you are running in a headless browser.\n\nFound here: https://github.com/berstend/puppeteer-extra Check out their docs for how to use it. It has a couple plugins that might help in getting past headless-mode detection:\n‚Ä¢ -- anonymizes your User Agent. Note that this might help with getting past headless mode detection, but as you'll see if you visit https://amiunique.org/ it is unlikely to be enough to keep you from being identified as a repeat visitor.\n‚Ä¢ -- this might help win the cat-and-mouse game of not being detected as headless. There are many tricks that are employed to detect headless mode, and as many tricks to evade them.\n\nIt's possible to run a single browser UI in a manner that let's you attach puppeteer to that running instance. Here's an article that explains it: https://medium.com/@jaredpotter1/connecting-puppeteer-to-existing-chrome-window-8a10828149e0\n\nEssentially you're starting Chrome or Chromium (or Edge?) from the command line with (or any old port?) plus other command line switches depending on what environment you're running it in. Then you use puppeteer to connect to that running instance instead of having it do the default behavior of launching a headless Chromium instance: . Read the puppeteer docs here for more info: https://pptr.dev/#?product=Puppeteer&version=v5.2.1&show=api-puppeteerlaunchoptions\n\nThe is displayed in the terminal when you launch the browser from the command line with the option.\n\nThis option is going to require some server/ops mojo, so be prepared to do a lot more Stack Overflow searches. :-)\n\nThere are other strategies I'm sure but those are the two I'm most familiar with. Good luck!"
    },
    {
        "link": "https://stackoverflow.com/questions/64178037/how-to-implement-plugin-stealth-in-puppeteer-sharp",
        "document": "I would like to know how and if it is possible to use inside of visual studio project. As far as I read there is a project called: but they didn't showed how to use the plugin stealth, as this is best browser which is not detectable as a \" \".\n\nIn my other compiled by I have this code to load installed :\n\nBUT THIS is my C# Form where I don't know how to use or load or implement"
    },
    {
        "link": "https://zenrows.com/blog/puppeteer-stealth",
        "document": ""
    },
    {
        "link": "https://scrapingbee.com/blog/puppeteer-stealth-tutorial-with-examples",
        "document": "Puppeteer is a robust headless browser library created mainly to automate user interactions. However, it can be easily detected and blocked by anti-scraping measures due to its lack of built-in stealth capabilities. This is where Puppeteer Extra comes in, offering plugins like Stealth to address this limitation.\n\nThis tutorial will explore how to utilize Puppeteer Stealth to attempt to evade detection while scraping websites effectively. We also cover solutions and alternatives for by-passing the latest cutting edge anti-bot tech which Puppeteer Stealth sometimes struggles to evade.\n\nWithout further ado, let‚Äôs get started!\n\nWhat is puppeteer stealth and how does it work?\n\nPuppeteer Stealth, also known as , is a powerful extension for Puppeteer, built on top of Puppeteer Extra. It is designed to address browser fingerprinting and evasion issues, enhancing Puppeteer's ability to avoid detection by anti-scraping mechanisms used by many websites. With 17 evasion modules, this plugin tackles various fingerprinting discrepancies that can lead to bot detection.\n‚Ä¢ Browser Fingerprint Modification: Puppeteer Stealth modifies key browser properties, or \"fingerprints\", that websites use to detect and block automated requests. It masks default headless properties such as and , making the browser appear more like a regular browser. It also changes other properties and behaviors that might reveal automation.\n‚Ä¢ Built-In Evasion Modules: This plugin comes packed with several evasion modules that address various detection techniques. For instance, it hides the attribute and alters the property to simulate a standard Chrome browser. You can find a complete list of these modules in the Puppeteer Stealth documentation.\n‚Ä¢ Human-Like Behavior: To further avoid triggering anti-scraping scripts, Puppeteer Stealth mimics real user interactions, such as mouse movements and keyboard inputs.\n\nPuppeteer Stealth is effective at bypassing many anti-scraping mechanisms, but it's not foolproof. According to the official documentation, some advanced detection systems may still be able to detect automated activity. However, the goal of the project is to make detection so challenging and resource-intensive that it becomes impractical.\n\nHow to scrape with puppeteer stealth enabled\n\nLet's see how to integrate Puppeteer Stealth into a scraping script to avoid getting blocked. Before diving into stealth mode, let's run two tests to see how easily the default Puppeteer setup is detected.\n\nFirst, we'll check how a website detects a headless browser. We'll use the bot detection test by Antoine Vastel. If you open this page in a regular browser, you'll see a message confirming that you are not using a headless browser, which is expected.\n\nNow, let‚Äôs try visiting the same site using Puppeteer with the following script:\n\nWhen you run this script, the website detects that you are using a headless browser, and the result looks like this:\n\nThis confirms that the test failed, as the page successfully detected the headless browser.\n\nTest 2: Detecting Browser Automation Next, let's examine another bot detection test on Sannysoft. We'll use the following script to test if Puppeteer‚Äôs default setup can bypass the detection.\n\nThe below screenshot shows red bars, which indicate that bot fingerprints were detected, highlighting how the default Puppeteer setup fails the Browser Fingerprinting tests.\n\nBy default, Puppeteer has limited ability to bypass bot detection. To work around these detection mechanisms, you would typically need to manually tweak and override its default settings.\n\nLet's do this using the Puppeteer Stealth plugin from Puppeteer Extra.\n\nFirst, you need to install Puppeteer Extra and the Puppeteer Stealth plugin. is required because it allows you to add plugins like to extend Puppeteer's capabilities. Install both packages using the following command:\n\nNext, import the from :\n\nIf you‚Äôre using CommonJS, use the following instead:\n\nAdd the Stealth plugin and apply it using the default settings, which include all evasion techniques:\n\nNote: If you want to customize the evasion modules, refer to this README file.\n\nNext, launch Puppeteer Stealth with the headless option and open an function to write your code:\n\nLet‚Äôs set the viewport size and navigate to the target website.\n\nNext, capture a screenshot and close the browser instance.\n\nPutting it all together, here‚Äôs the code so far:\n\nHere's what our result looks like:\n\nGreat! You've successfully avoided bot detection using Puppeteer Extra Stealth. Now, let's take it a step further and scrape the page.\n\nIn this step, we‚Äôll extract key product data such as the title, price, ratings, reviews, product description, and image URL.\n\nThe product title is located in a element with the ID \"productTitle\".\n\nTo extract it, use the following code:\n\nThe method selects the element with the ID and retrieves its text content, trimming any extra whitespace.\n\nThe product price can be found in a element with the class , typically located near the Buy Now box.\n\nUse the following code to extract it:\n\nThis code selects the element with the class and retrieves its text content, ensuring it‚Äôs properly cleaned.\n\nTo scrape the product rating and number of reviews:\n\nThe rating is retrieved from the attribute of the element with the ID , while the number of reviews is obtained from the element with the ID .\n\nThe URL of the product image is found in an element with the ID .\n\nUse the following code to get it:\n\nThis code retrieves the URL from the attribute of the image element.\n\nThe product description is contained in an element with the ID \"productDescription\".\n\nHere‚Äôs how to extract it:\n\nStore all the extracted information in a dictionary:\n\nSaving data to a JSON file: Save the scraped data to a JSON file using the module:\n\nFinally, close the browser to free up resources:\n\nPutting it all together:\n\nHere‚Äôs the full code for extracting and saving product data:\n\nOnce executed, this code will save all the extracted product data to a JSON file.\n\nAwesome! You‚Äôve successfully scraped all the desired data from Amazon and stored it in a JSON file. The data looks clean and readable, ready for further analysis or processing.\n\nIn this test, we'll use Puppeteer Stealth to check if our browser automation is detectable.\n\nThe browser is not detected as headless, indicating that the stealth mode is functioning correctly.\n\nIn the second test, we will use a different website to further ensure that our browser automation is undetectable.\n\nThe stealth mode successfully prevents detection, as shown in the screenshot above.\n\nBoth tests passed successfully, demonstrating that Puppeteer‚Äôs Stealth Plugin effectively masks browser automation, making it undetectable by most fingerprinting techniques.\n\nThe Puppeteer-Extra-Plugin-Stealth is a tool designed to make headless Puppeteer scripts less detectable by anti-bot mechanisms. However, it has certain drawbacks:\n‚Ä¢ Challenges with Advanced Anti-Bot Systems: Even with the stealth plugin, sophisticated anti-bot services like Cloudflare and DataDome can still detect and block Puppeteer scripts.\n‚Ä¢ Performance Overheads: Using the stealth plugin can introduce additional overhead, potentially slowing down the execution of scripts.\n‚Ä¢ Maintenance Complexity: The plugin needs to be configured correctly, and keeping it up to date with the latest anti-bot detection methods can be time-consuming.\n\nWhen scraping data from Amazon, making too many requests in a short amount of time can trigger anti-bot mechanisms. This can lead to challenges such as having to complete CAPTCHA verifications. For example, when attempting to run a web scraper multiple times, I encountered Amazon's CAPTCHA as shown in the image below.\n\nTo address this issue, you can consider the following approaches:\n‚Ä¢ Throttling Requests: Reduce the frequency of your requests or introduce delays between them to avoid triggering CAPTCHA.\n‚Ä¢ Rotating Proxies: Utilize rotating proxies to distribute requests across different IP addresses.\n‚Ä¢ CAPTCHA Solving Services: Integrate a CAPTCHA-solving service to automatically handle CAPTCHA challenges when they arise.\n\nWhile the strategies mentioned can help reduce detection, advanced anti-bot solutions such as Cloudflare and DataDome are continually evolving. These systems may still block your requests despite the use of Puppeteer Stealth or other evasion techniques.\n\nGiven these challenges, it‚Äôs important to explore alternative solutions to Puppeteer Stealth for more robust scraping operations. Let‚Äôs examine some of these alternatives next.\n\nWhen dealing with advanced anti-bot systems, relying solely on Puppeteer Stealth may not be enough. Luckily, several alternatives offer enhanced capabilities for bypassing detection mechanisms. Here are some of the most effective options:\n\nAnti-bot systems can easily detect Selenium's built-in automation features and command-line flags. This is where the Selenium Stealth plugin becomes useful. Selenium Stealth helps you bypass many common anti-bot detection mechanisms by masking various detection leaks.\n\nThe Selenium Undetected ChromeDriver is an enhanced version of the standard ChromeDriver which is designed to bypass anti-bot services such as Cloudflare, Distill Network, Imperva, or DataDome. Undetectable ChromeDriver is capable of patching most of the ways through which anti-bot systems can detect your Selenium bot or scraper. It enables your bot to appear more human-like as compared to a regular one.\n\nNodriver is a Python library derived from Undetected ChromeDriver, designed specifically to bypass CAPTCHAs and Web Application Firewalls (WAFs) like Cloudflare. Nodriver is an asynchronous tool that replaces traditional components such as Selenium or webdriver binaries, providing direct communication with browsers. This approach not only reduces the detection rate by most anti-bot solutions but also significantly improves the tool's performance.\n\nCloudscraper is a Python library implemented with the Requests library, designed to bypass Cloudflare's anti-bot challenges. It is specifically created to scrape data from websites protected by Cloudflare. Cloudflare uses various browser fingerprinting challenges and checks to distinguish between genuine users and scrapers/bots. Cloudscraper circumvents these challenges by mimicking the behavior of a real web browser.\n\nOne major challenge with open-source packages, such as the ones mentioned, is that anti-bot companies can detect their methods for bypassing anti-bot protection systems and easily fix the vulnerabilities they exploit. This leads to an ongoing arms race where these packages come up with new workarounds, and anti-bot companies patch these workarounds as well. Therefore, it's important to find a long-term effective solution.\n\nThere's an ultimate solution: with ScrapingBee, you can bypass any anti-bot system, regardless of its complexity, and frequent updates.\n\nScrapingBee is an all-in-one web scraping solution that handles all anti-bot bypasses for you, allowing you to focus on getting the data you want.\n\nTo start, sign up for a free ScrapingBee trial no credit card is needed, and you'll receive 1000 credits to begin. Each request costs approximately 25 credits.\n\nNext, import the ScrapingBee client and create a new instance using your API key.\n\nYes, it‚Äôs that simple! The status code 200 indicates that the G2 anti-bot has been bypassed.\n\nYou have learned about the challenges Puppeteer faces with bot detection and how to address them. By using Puppeteer Extra, you can expand Puppeteer‚Äôs capabilities with various plugins. In this discussion, you have learned about the stealth plugin, which effectively bypasses bot detection mechanisms.\n\nHowever, even with a sophisticated Puppeteer Extra script, advanced anti-bot technologies like Cloudflare can still detect and block your scripts. In such cases, consider simple solutions like ScrapingBee üöÄ"
    },
    {
        "link": "https://crawlee.dev/docs/examples/crawler-plugins",
        "document": "and are community-built libraries that bring in a plugin system to enhance the usage of and respectively (bringing in extra functionality, like improving stealth for example by using the Puppeteer Stealth plugin ( )).\n\nYou can see a list of available plugins on the s plugin list. For , please see s plugin list instead.\n\nIn this example, we'll show you how to use the Puppeteer Stealth ( ) plugin to help you avoid bot detections when crawling your target website.\n\nMake sure you've installed the Puppeteer Extra ( ) and Puppeteer Stealth plugin( ) packages via your preferred package manager To run this example on the Apify Platform, select the image for your Dockerfile. Make sure you've installed the and packages via your preferred package manager To run this example on the Apify Platform, select the image for your Dockerfile."
    },
    {
        "link": "https://github.com/Overmiind/Puppeteer-sharp-extra",
        "document": "Puppeteer extra sharp is a .NET port of the Node.js library\n‚Ä¢ Applies various evasion techniques to make detection of headless puppeteer harder.\n‚Ä¢ Anonymizes the user-agent on all pages.\n\nAdds a new plugin to plugins list and register it.\n‚Ä¢ Returns the same instance of puppeteer extra\n‚Ä¢ Return the new puppeteer browser instance with launch options\n‚Ä¢ Connect to the exiting browser with connect options\n‚Ä¢ Get plugin from plugin list by type"
    }
]