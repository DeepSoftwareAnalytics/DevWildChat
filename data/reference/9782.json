[
    {
        "link": "https://autohotkey.com/docs/commands/ListView.htm",
        "document": "\n• Options and Styles for the Options Parameter\n• ImageLists (the means by which icons are added to a ListView)\n\nA ListView is one of the most elaborate controls provided by the operating system. In its most recognizable form, it displays a tabular view of rows and columns, the most common example of which is Explorer's list of files and folders (detail view).\n\nA ListView usually looks like this:\n\nThough it may be elaborate, a ListView's basic features are easy to use. The syntax for creating a ListView is:\n\nHere is a working script that creates and displays a ListView containing a list of files in the user's \"My Documents\" folder:\n\nOptions and Styles for the Options Parameter\n\nAltSubmit: Notifies the script for more types of ListView events than normal. In other words, the g-label is launched more often. See ListView Notifications for details.\n\nBackground: Specify the word Background followed immediately by a color name (see color chart) or RGB value (the 0x prefix is optional). Examples: , . If this option is not present, the ListView initially defaults to the background color set by the last parameter of Gui Color (or if none, the system's default background color). Specifying applies the system's default background color (usually white). For example, a ListView can be restored to the default color via .\n\nC: Text color. Specify the letter C followed immediately by a color name (see color chart) or RGB value (the 0x prefix is optional). Examples: , , , .\n\nChecked: Provides a checkbox at the left side of each row. When adding a row, specify the word Check in its options to have the box to start off checked instead of unchecked. The user may either click the checkbox or press the spacebar to check or uncheck a row.\n\nCount: Specify the word Count followed immediately by the total number of rows that the ListView will ultimately contain. This is not a limit: rows beyond the count can still be added. Instead, this option serves as a hint to the control that allows it to allocate memory only once rather than each time a row is added, which greatly improves row-adding performance (it may also improve sorting performance). To improve performance even more, use prior to adding a large number of rows. Afterward, use to re-enable redrawing (which also repaints the control).\n\nGrid: Provides horizontal and vertical lines to visually indicate the boundaries between rows and columns.\n\nHdr: Specify (minus Hdr) to omit the header (the special top row that contains column titles). To make it visible later, use .\n\nLV: Specify the string LV followed immediately by the number of an extended ListView style. These styles are entirely separate from generic extended styles. For example, specifying would remove the generic extended style WS_EX_CLIENTEDGE to eliminate the control's default border. By contrast, specifying would remove LVS_EX_FULLROWSELECT.\n\nLV0x10: Specify to prevent the user from dragging column headers to the left or right to reorder them. However, it is usually not necessary to do this because the physical reordering of columns does not affect the column order seen by the script. For example, the first column will always be column 1 from the script's point of view, even if the user has physically moved it to the right of other columns.\n\nLV0x20: Specify to require that a row be clicked at its first field to select it (normally, a click on any field will select it). The advantage of this is that it makes it easier for the user to drag a rectangle around a group of rows to select them.\n\nMulti: Specify (minus Multi) to prevent the user from selecting more than one row at a time.\n\nNoSortHdr: Prevents the header from being clickable. It will take on a flat appearance rather than its normal button-like appearance. Unlike most other ListView styles, this one cannot be changed after the ListView is created.\n\nNoSort: Turns off the automatic sorting that occurs when the user clicks a column header. However, the header will still behave visually like a button (unless the NoSortHdr option above has been specified). In addition, the g-label will still receive the ColClick notification, to which it can respond with a custom sort or other action.\n\nReadOnly: Specify (minus ReadOnly) to allow editing of the text in the first column of each row. To edit a row, select it then press (see the WantF2 option below). Alternatively, you can click a row once to select it, wait at least half a second, then click the same row again to edit it.\n\nR: Rows of height (upon creation). Specify the letter R followed immediately by the number of rows for which to make room inside the control. For example, would make the control 10 rows tall. If the ListView is created with a view mode other than report view, the control is sized to fit rows of icons instead of rows of text. Note: adding icons to a ListView's rows will increase the height of each row, which will make this option inaccurate.\n\nSort: The control is kept alphabetically sorted according to the contents of the first column.\n\nSortDesc: Same as above except in descending order.\n\nWantF2: In [v1.0.44+], specify (minus WantF2) to prevent from editing the currently focused row. This setting is ignored unless -ReadOnly is also in effect. Regardless of this setting, the g-label still receives F2 notifications.\n\n(Unnamed numeric styles): Since styles other than the above are rarely used, they do not have names. See the ListView styles table for a list.\n\nA ListView has five viewing modes, of which the most common is report view (which is the default). To use one of the other views, specify its name in the options list. The view can also be changed after the control is created; for example: .\n\nIcon: Shows a large-icon view. In this view and all the others except Report, the text in columns other than the first is not visible. To display icons in this mode, the ListView must have a large-icon ImageList assigned to it.\n\nTile: Shows a large-icon view but with ergonomic differences such as displaying each item's text to the right of the icon rather than underneath it. Checkboxes do not function in this view. Also, attempting to show this view on operating systems older than Windows XP has no effect.\n\nList: Shows a small-icon view in list format, which displays the icons in columns. The number of columns depends on the width of the control and the width of the widest text item in it.\n\nReport: Switches back to report view, which is the initial default. For example: .\n\nAll of the following ListView functions operate upon the current thread's default GUI window (which can be changed via ). If the default window does not exist or has no ListView controls, all functions return zero to indicate the problem.\n\nIf the window has more than one ListView control, by default the functions operate upon the one most recently added. To change this, specify , where ListViewName is the name of the ListView's associated variable, its ClassNN as shown by Window Spy or in [v1.1.04+] its HWND. Once changed, all existing and future threads will use the indicated ListView. [v1.1.23+]: A_DefaultListView contains the current setting.\n\nWhen the phrase \"row number\" is used on this page, it refers to a row's current position within the ListView. The top row is 1, the second row is 2, and so on. After a row is added, its row number tends to change due to sorting, deleting, and inserting of other rows. Therefore, to locate specific row(s) based on their contents, it is usually best to use LV_GetText() in a loop.\n• LV_Add: Adds a new row to the bottom of the list.\n• LV_Insert: Inserts a new row at the specified row number.\n• LV_Delete: Deletes the specified row or all rows.\n• LV_ModifyCol: Modifies the attributes and/or text of the specified column and its header.\n• LV_InsertCol: Inserts a new column at the specified column number.\n• LV_DeleteCol: Deletes the specified column and all of the contents beneath it.\n• LV_GetCount: Returns the number of rows or columns in the control.\n• LV_GetNext: Returns the row number of the next selected, checked, or focused row.\n• LV_GetText: Retrieves the text at the specified row and column number.\n• LV_SetImageList: Sets or replaces an ImageList for displaying icons.\n\nAdds a new row to the bottom of the list.\n\nOn success, this function returns the new row number, which is not necessarily the last row if the ListView has the Sort or SortDesc style. On failure, it returns 0.\n\nInserts a new row at the specified row number.\n\nOn success, this function returns the specified row number. On failure, it returns 0.\n\nOn success, this function returns the specified row number. On failure, it returns 0. If RowNumber is 0 to modify all rows, it returns 1 on complete success and 0 if any part of the operation failed.\n\nWhen only the first two parameters are present, only the row's attributes and not its text are changed.\n\nDeletes the specified row or all rows.\n\nOn success, this function returns 1 (true). On failure, it returns 0 (false).\n\nModifies the attributes and/or text of the specified column and its header.\n\nIf this and the other parameters are all omitted, the width of every column is adjusted to fit the contents of the rows. This has no effect when not in Report (Details) view. Otherwise, specify the number of the column to modify. The first column is 1 (not 0). If omitted, it defaults to Auto (adjusts the column's width to fit its contents). Otherwise, specify one or more options from the list below (not case-sensitive). Separate each option from the next with a space or tab. To remove an option, precede it with a minus sign. To add an option, a plus sign is permitted but not required. N: Specify for N the new width of the column, in pixels. This number can be unquoted if is the only option. For example, the following are both valid: and . Auto: Adjusts the column's width to fit its contents. This has no effect when not in Report (Details) view. AutoHdr: Adjusts the column's width to fit its contents and the column's header text, whichever is wider. If applied to the last column, it will be made at least as wide as all the remaining space in the ListView. It is usually best to apply this setting only after the rows have been added because that allows any newly-arrived vertical scroll bar to be taken into account when sizing the last column. This has no effect when not in Report (Details) view. Icon: Specify the word Icon followed immediately by the number of the ImageList's icon to display next to the column header's text. Specify (minus icon) to remove any existing icon. IconRight: Puts the icon on the right side of the column rather than the left. Float: For sorting purposes, indicates that this column contains floating point numbers (hexadecimal format is not supported). Sorting performance for Float and Text columns is up to 25 times slower than it is for integers. Integer: For sorting purposes, indicates that this column contains integers. To be sorted properly, each integer must be 32-bit; that is, within the range -2147483648 to 2147483647. If any of the values are not integers, they will be considered zero when sorting (unless they start with a number, in which case that number is used). Numbers may appear in either decimal or hexadecimal format (e.g. ). Text: Changes the column back to text-mode sorting, which is the initial default for every column. Only the first 8190 characters of text are significant for sorting purposes (except for the Logical option, in which case the limit is 4094). Center: Centers the text in the column. To center an Integer or Float column, specify the word Center after the word Integer or Float. Left: Left-aligns the column's text, which is the initial default for every column. On older operating systems, the first column might have a forced left-alignment. Right: Right-aligns the column's text. This attribute need not be specified for Integer and Float columns because they are right-aligned by default. That default can be overridden by specifying something such as or . Case: The sorting of the column is case-sensitive (affects only text columns). If the options Case, CaseLocale, and Logical are all omitted, the uppercase letters A-Z are considered identical to their lowercase counterparts for the purpose of the sort. CaseLocale [v1.0.43.03+]: The sorting of the column is case-insensitive based on the current user's locale (affects only text columns). For example, most English and Western European locales treat the letters A-Z and ANSI letters like Ä and Ü as identical to their lowercase counterparts. This method also uses a \"word sort\", which treats hyphens and apostrophes in such a way that words like \"coop\" and \"co-op\" stay together. Desc: Descending order. The column starts off in descending order the first time the user sorts it. Logical [v1.0.44.12+]: Same as CaseLocale except that any sequences of digits in the text are treated as true numbers rather than mere characters. For example, the string \"T33\" would be considered greater than \"T4\". Logical requires Windows XP or later (on older OSes, CaseLocale is automatically used instead). In addition, Logical and Case are currently mutually exclusive: only the one most recently specified will be in effect. NoSort: Prevents a user's click on this column from having any automatic sorting effect. To disable sorting for all columns rather than only a subset, include NoSort in the ListView's options. If the ListView has a g-label, the ColClick notification will still be received when the user clicks a no-sort column. Sort: Immediately sorts the column in ascending order (even if it has the Desc option). Uni: Unidirectional sort. This prevents a second click on the same column from reversing the sort direction. If omitted, the current header is left unchanged. Otherwise, specify the new header of the column.\n\nOn success, this function returns 1 (true). On failure, it returns 0 (false).\n\nInserts a new column at the specified column number.\n\nOn success, this function returns the new column's position number. On failure, it returns 0.\n\nThe newly inserted column starts off with empty contents beneath it unless it is the first column, in which case it inherits the old first column's contents and the old first column acquires blank contents.\n\nThe maximum number of columns in a ListView is 200.\n\nDeletes the specified column and all of the contents beneath it.\n\nOn success, this function returns 1 (true). On failure, it returns 0 (false). On operating systems older than Windows XP, attempting to delete the original first column might fail and return 0.\n\nReturns the number of rows or columns in the control.\n\nThis function returns the number of rows or columns in the control. The value is always returned immediately because the control keeps track of these counts.\n\nThis function is often used in the top line of a Loop, in which case the function would get called only once (prior to the first iteration). For example:\n\nTo retrieve the widths of a ListView's columns -- for uses such as saving them to an INI file to be remembered between sessions -- follow this example:\n\nReturns the row number of the next selected, checked, or focused row.\n\nThis function returns the row number of the next selected, checked, or focused row. If none is found, it returns 0.\n\nThe following example reports all selected rows in the ListView:\n\nAn alternate method to find out if a particular row number is checked is the following:\n\nRetrieves the text at the specified row and column number.\n\nOn success, this function returns 1 (true). On failure, it returns 0 (false).\n\nColumn numbers seen by the script are not altered by any dragging and dropping of columns the user may have done. For example, the original first column is still number 1 even if the user drags it to the right of other columns.\n\nSets or replaces an ImageList for displaying icons.\n\nOn success, this function returns the ImageList ID that was previously associated with the ListView. On failure, it returns 0. Any such detached ImageList should normally be destroyed via IL_Destroy().\n\nThis function is normally called prior to adding any rows to the ListView. It sets the ImageList whose icons will be displayed by the ListView's rows (and optionally, its columns).\n\nA ListView may have up to two ImageLists: small-icon and/or large-icon. This is useful when the script allows the user to switch to and from the large-icon view. To add more than one ImageList to a ListView, call LV_SetImageList() a second time, specifying the ImageList ID of the second list. A ListView with both a large-icon and small-icon ImageList should ensure that both lists contain the icons in the same order. This is because the same ID number is used to reference both the large and small versions of a particular icon.\n\nAlthough it is traditional for all viewing modes except Icon and Tile to show small icons, this can be overridden by passing a large-icon list to LV_SetImageList() and specifying 1 (small-icon) for the second parameter. This also increases the height of each row in the ListView to fit the large icon.\n\nA g-label such as may be listed in the control's options. This would cause the MySubroutine label to be launched automatically whenever the user performs an action in the control. This subroutine may consult the built-in variables A_Gui and A_GuiControl to find out which window and ListView generated the event. More importantly, it may consult A_GuiEvent, which contains one of the following strings or letters (for compatibility with future versions, a script should not assume these are the only possible values):\n\nDoubleClick: The user has double-clicked within the control. The variable A_EventInfo contains the focused row number. LV_GetNext() can be used to instead get the first selected row number, which is 0 if the user double-clicked on empty space.\n\nR: The user has double-right-clicked within the control. The variable A_EventInfo contains the focused row number.\n\nColClick: The user has clicked a column header. The variable A_EventInfo contains the column number, which is the original number assigned when the column was created; that is, it does not reflect any dragging and dropping of columns done by the user. One possible response to a column click is to sort by a hidden column (zero width) that contains data in a sort-friendly format (such as a YYYYMMDD integer date). Such a hidden column can mirror some other column that displays the same data in a more friendly format (such as MM/DD/YY). For example, a script could hide column 3 via , then disable automatic sorting in the visible column 2 via . Then in response to the ColClick notification for column 2, the script would sort the ListView by the hidden column via .\n\nD: The user has attempted to start dragging a row or icon (there is currently no built-in support for dragging rows or icons). The variable A_EventInfo contains the focused row number. [v1.0.44+]: This notification occurs even without AltSubmit.\n\nd (lowercase D): Same as above except a right-click-drag rather than a left-drag.\n\ne (lowercase E): The user has finished editing the first field of a row (the user may edit it only when the ListView has in its options). The variable A_EventInfo contains the row number.\n\nIf the ListView has the word AltSubmit in its options, its g-label is launched more often and A_GuiEvent may contain the following additional values:\n\nNormal: The user has left-clicked a row. The variable A_EventInfo contains the focused row number.\n\nRightClick: The user has right-clicked a row. The variable A_EventInfo contains the focused row number. In most cases, it is best not to display a menu in response to this. Instead, use the GuiContextMenu label because it also recognizes the Apps key. For example:\n\nA: A row has been activated, which by default occurs when it is double clicked. The variable A_EventInfo contains the row number.\n\nC: The ListView has released mouse capture.\n\nE: The user has begun editing the first field of a row (the user may edit it only when the ListView has -ReadOnly in its options). The variable A_EventInfo contains the row number.\n\nI: Item changed. A row has changed by becoming selected/deselected, checked/unchecked, etc. If the user selects a new row, at least two such notifications are received: one for the de-selection of the previous row, and one for the selection of the new row. [v1.0.44+]: The variable A_EventInfo contains the row number. [v1.0.46.10+]: ErrorLevel contains zero or more of the following letters to indicate how the item changed: S (select) or s (de-select), and/or F (focus) or f (de-focus), and/or C (checkmark) or c (uncheckmark). For example, SF means that the row has been selected and focused. To detect whether a particular letter is present, use a parsing loop or the case-sensitive option of InStr(); for example: . Note: For compatibility with future versions, a script should not assume that \"SsFfCc\" are the only possible letters. Also, specifying Critical as the g-label's first line ensures that all \"I\" notifications are received (otherwise, some might be lost if the script cannot keep up with them).\n\nK: The user has pressed a key while the ListView has focus. A_EventInfo contains the virtual key code of the key, which is a number between 1 and 255. This can be translated to a key name or character via GetKeyName(). For example, . On most keyboard layouts, keys A-Z can be translated to the corresponding character via . is received regardless of WantF2. However, is not received; to receive it, use a default button as described below.\n\nM: Marquee. The user has started to drag a selection-rectangle around a group of rows or icons.\n\nS: The user has begun scrolling the ListView.\n\ns (lowercase S): The user has finished scrolling the ListView.\n\nAn Image-List is a group of identically sized icons stored in memory. Upon creation, each ImageList is empty. The script calls IL_Add() repeatedly to add icons to the list, and each icon is assigned a sequential number starting at 1. This is the number to which the script refers to display a particular icon in a row or column header. Here is a working example that demonstrates how to put icons into a ListView's rows:\n\nCreates a new ImageList that is initially empty.\n\nOn success, this function returns the unique ID of the newly created ImageList. On failure, it returns 0.\n\nAdds an icon or picture to the specified ImageList.\n\nOn success, this function returns the new icon's index (1 is the first icon, 2 is the second, and so on). On failure, it returns 0.\n\nOn success, this function returns 1 (true). On failure, it returns 0 (false).\n\nIt is normally not necessary to destroy ImageLists because once attached to a ListView, they are destroyed automatically when the ListView or its parent window is destroyed. However, if the ListView shares ImageLists with other ListViews (by having 0x40 in its options), the script should explicitly destroy the ImageList after destroying all the ListViews that use it. Similarly, if the script replaces one of a ListView's old ImageLists with a new one, it should explicitly destroy the old one.\n\nThe Gui Submit command has no effect on a ListView control. Therefore, the script may use the ListView's associated variable (if any) to store other data without concern that it will ever be overwritten.\n\nAfter a column is sorted -- either by means of the user clicking its header or the script calling -- any subsequently added rows will appear at the bottom of the list rather than obeying the sort order. The exception to this is the Sort and SortDesc styles, which move newly added rows into the correct positions.\n\nTo detect when the user has pressed while a ListView has focus, use a default button (which can be hidden if desired). For example:\n\nIn addition to navigating from row to row with the keyboard, the user may also perform incremental search by typing the first few characters of an item in the first column. This causes the selection to jump to the nearest matching row.\n\nAlthough any length of text can be stored in each field of a ListView, only the first 260 characters are displayed.\n\nAlthough the maximum number of rows in a ListView is limited only by available system memory, row-adding performance can be greatly improved as described in the Count option.\n\nA picture may be used as a background around a ListView (that is, to frame the ListView). To do this, create the picture control after the ListView and include 0x4000000 (which is WS_CLIPSIBLINGS) in the picture's Options.\n\nA script may create more than one ListView per window. To operate upon a ListView other than the default one, see built-in functions.\n\nIt is best not to insert or delete columns directly with SendMessage. This is because the program maintains a collection of sorting preferences for each column, which would then get out of sync. Instead, use the built-in column functions.\n\nTo perform actions such as resizing, hiding, or changing the font of a ListView, use GuiControl.\n\nTo extract text from external ListViews (those not owned by the script), use ControlGet List.\n\nThe following is a working script that is more elaborate than the one near the top of this page. It displays the files in a folder chosen by the user, with each file assigned the icon associated with its type. The user can double-click a file, or right-click one or more files to display a context menu. ; Allow the user to maximize or drag-resize the window: Gui +Resize ; Create some buttons: Gui, Add, Button, Default gButtonLoadFolder, Load a folder Gui, Add, Button, x+20 gButtonClear, Clear List Gui, Add, Button, x+20, Switch View ; Create the ListView and its columns via Gui Add: Gui, Add, ListView, xm r20 w700 vMyListView gMyListView, Name|In Folder|Size (KB)|Type LV_ModifyCol(3, \"Integer\") ; For sorting, indicate that the Size column is an integer. ; Create an ImageList so that the ListView can display some icons: ImageListID1 := IL_Create(10) ImageListID2 := IL_Create(10, 10, true) ; A list of large icons to go with the small ones. ; Attach the ImageLists to the ListView so that it can later display the icons: LV_SetImageList(ImageListID1) LV_SetImageList(ImageListID2) ; Create a popup menu to be used as the context menu: Menu, MyContextMenu, Add, Open, ContextOpenFile Menu, MyContextMenu, Add, Properties, ContextProperties Menu, MyContextMenu, Add, Clear from ListView, ContextClearRows Menu, MyContextMenu, Default, Open ; Make \"Open\" a bold font to indicate that double-click does the same thing. ; Display the window and return. The OS will notify the script whenever the user ; performs an eligible action: Gui, Show return ButtonLoadFolder: Gui +OwnDialogs ; Forces user to dismiss the following dialog before using main window. FileSelectFolder, Folder,, 3, Select a folder to read: if not Folder ; The user canceled the dialog. return ; Check if the last character of the folder name is a backslash, which happens for root ; directories such as C:\\. If it is, remove it to prevent a double-backslash later on. LastChar := SubStr(Folder, 0) if (LastChar = \"\\\") Folder := SubStr(Folder, 1, -1) ; Remove the trailing backslash. ; Calculate buffer size required for SHFILEINFO structure. sfi_size := A_PtrSize + 8 + (A_IsUnicode ? 680 : 340) VarSetCapacity(sfi, sfi_size) ; Gather a list of file names from the selected folder and append them to the ListView: GuiControl, -Redraw, MyListView ; Improve performance by disabling redrawing during load. Loop %Folder%\\*.* { FileName := A_LoopFileFullPath ; Must save it to a writable variable for use below. ; Build a unique extension ID to avoid characters that are illegal in variable names, ; such as dashes. This unique ID method also performs better because finding an item ; in the array does not require search-loop. SplitPath, FileName,,, FileExt ; Get the file's extension. if FileExt in EXE,ICO,ANI,CUR { ExtID := FileExt ; Special ID as a placeholder. IconNumber := 0 ; Flag it as not found so that these types can each have a unique icon. } else ; Some other extension/file-type, so calculate its unique ID. { ExtID := 0 ; Initialize to handle extensions that are shorter than others. Loop 7 ; Limit the extension to 7 characters so that it fits in a 64-bit value. { ExtChar := SubStr(FileExt, A_Index, 1) if not ExtChar ; No more characters. break ; Derive a Unique ID by assigning a different bit position to each character: ExtID := ExtID | (Asc(ExtChar) << (8 * (A_Index - 1))) } ; Check if this file extension already has an icon in the ImageLists. If it does, ; several calls can be avoided and loading performance is greatly improved, ; especially for a folder containing hundreds of files: IconNumber := IconArray%ExtID% } if not IconNumber ; There is not yet any icon for this extension, so load it. { ; Get the high-quality small-icon associated with this file extension: if not DllCall(\"Shell32\\SHGetFileInfo\" . (A_IsUnicode ? \"W\":\"A\"), \"Str\", FileName , \"UInt\", 0, \"Ptr\", &sfi, \"UInt\", sfi_size, \"UInt\", 0x101) ; 0x101 is SHGFI_ICON+SHGFI_SMALLICON IconNumber := 9999999 ; Set it out of bounds to display a blank icon. else ; Icon successfully loaded. { ; Extract the hIcon member from the structure: hIcon := NumGet(sfi, 0) ; Add the HICON directly to the small-icon and large-icon lists. ; Below uses +1 to convert the returned index from zero-based to one-based: IconNumber := DllCall(\"ImageList_ReplaceIcon\", \"Ptr\", ImageListID1, \"Int\", -1, \"Ptr\", hIcon) + 1 DllCall(\"ImageList_ReplaceIcon\", \"Ptr\", ImageListID2, \"Int\", -1, \"Ptr\", hIcon) ; Now that it's been copied into the ImageLists, the original should be destroyed: DllCall(\"DestroyIcon\", \"Ptr\", hIcon) ; Cache the icon to save memory and improve loading performance: IconArray%ExtID% := IconNumber } } ; Create the new row in the ListView and assign it the icon number determined above: LV_Add(\"Icon\" . IconNumber, A_LoopFileName, A_LoopFileDir, A_LoopFileSizeKB, FileExt) } GuiControl, +Redraw, MyListView ; Re-enable redrawing (it was disabled above). LV_ModifyCol() ; Auto-size each column to fit its contents. LV_ModifyCol(3, 60) ; Make the Size column at little wider to reveal its header. return ButtonClear: LV_Delete() ; Clear the ListView, but keep icon cache intact for simplicity. return ButtonSwitchView: if not IconView GuiControl, +Icon, MyListView ; Switch to icon view. else GuiControl, +Report, MyListView ; Switch back to details view. IconView := not IconView ; Invert in preparation for next time. return MyListView: if (A_GuiEvent = \"DoubleClick\") ; There are many other possible values the script can check. { LV_GetText(FileName, A_EventInfo, 1) ; Get the text of the first field. LV_GetText(FileDir, A_EventInfo, 2) ; Get the text of the second field. Run %FileDir%\\%FileName%,, UseErrorLevel if ErrorLevel MsgBox Could not open \"%FileDir%\\%FileName%\". } return GuiContextMenu: ; Launched in response to a right-click or press of the Apps key. if (A_GuiControl != \"MyListView\") ; Display the menu only for clicks inside the ListView. return ; Show the menu at the provided coordinates, A_GuiX and A_GuiY. These should be used ; because they provide correct coordinates even if the user pressed the Apps key: Menu, MyContextMenu, Show, %A_GuiX%, %A_GuiY% return ContextOpenFile: ; The user selected \"Open\" in the context menu. ContextProperties: ; The user selected \"Properties\" in the context menu. ; For simplicitly, operate upon only the focused row rather than all selected rows: FocusedRowNumber := LV_GetNext(0, \"F\") ; Find the focused row. if not FocusedRowNumber ; No row is focused. return LV_GetText(FileName, FocusedRowNumber, 1) ; Get the text of the first field. LV_GetText(FileDir, FocusedRowNumber, 2) ; Get the text of the second field. if InStr(A_ThisMenuItem, \"Open\") ; User selected \"Open\" from the context menu. Run %FileDir%\\%FileName%,, UseErrorLevel else ; User selected \"Properties\" from the context menu. Run Properties \"%FileDir%\\%FileName%\",, UseErrorLevel if ErrorLevel MsgBox Could not perform requested action on \"%FileDir%\\%FileName%\". return ContextClearRows: ; The user selected \"Clear\" in the context menu. RowNumber := 0 ; This causes the first iteration to start the search at the top. Loop { ; Since deleting a row reduces the RowNumber of all other rows beneath it, ; subtract 1 so that the search includes the same row number that was previously ; found (in case adjacent rows are selected): RowNumber := LV_GetNext(RowNumber - 1) if not RowNumber ; The above returned zero, so there are no more selected rows. break LV_Delete(RowNumber) ; Clear the row from the ListView. } return GuiSize: ; Expand or shrink the ListView in response to the user's resizing of the window. if (A_EventInfo = 1) ; The window has been minimized. No action needed. return ; Otherwise, the window has been resized or maximized. Resize the ListView to match. GuiControl, Move, MyListView, % \"W\" . (A_GuiWidth - 20) . \" H\" . (A_GuiHeight - 40) return GuiClose: ; When the window is closed, exit the script automatically: ExitApp"
    },
    {
        "link": "https://autohotkey.com/docs/v1/lib/ListView.htm",
        "document": "\n• Options and Styles for the Options Parameter\n• ImageLists (the means by which icons are added to a ListView)\n\nA ListView is one of the most elaborate controls provided by the operating system. In its most recognizable form, it displays a tabular view of rows and columns, the most common example of which is Explorer's list of files and folders (detail view).\n\nA ListView usually looks like this:\n\nThough it may be elaborate, a ListView's basic features are easy to use. The syntax for creating a ListView is:\n\nHere is a working script that creates and displays a ListView containing a list of files in the user's \"My Documents\" folder:\n\nOptions and Styles for the Options Parameter\n\nAltSubmit: Notifies the script for more types of ListView events than normal. In other words, the g-label is launched more often. See ListView Notifications for details.\n\nBackground: Specify the word Background followed immediately by a color name (see color chart) or RGB value (the 0x prefix is optional). Examples: , . If this option is not present, the ListView initially defaults to the background color set by the last parameter of Gui Color (or if none, the system's default background color). Specifying applies the system's default background color (usually white). For example, a ListView can be restored to the default color via .\n\nC: Text color. Specify the letter C followed immediately by a color name (see color chart) or RGB value (the 0x prefix is optional). Examples: , , , .\n\nChecked: Provides a checkbox at the left side of each row. When adding a row, specify the word Check in its options to have the box to start off checked instead of unchecked. The user may either click the checkbox or press the spacebar to check or uncheck a row.\n\nCount: Specify the word Count followed immediately by the total number of rows that the ListView will ultimately contain. This is not a limit: rows beyond the count can still be added. Instead, this option serves as a hint to the control that allows it to allocate memory only once rather than each time a row is added, which greatly improves row-adding performance (it may also improve sorting performance). To improve performance even more, use prior to adding a large number of rows. Afterward, use to re-enable redrawing (which also repaints the control).\n\nGrid: Provides horizontal and vertical lines to visually indicate the boundaries between rows and columns.\n\nHdr: Specify (minus Hdr) to omit the header (the special top row that contains column titles). To make it visible later, use .\n\nLV: Specify the string LV followed immediately by the number of an extended ListView style. These styles are entirely separate from generic extended styles. For example, specifying would remove the generic extended style WS_EX_CLIENTEDGE to eliminate the control's default border. By contrast, specifying would remove LVS_EX_FULLROWSELECT.\n\nLV0x10: Specify to prevent the user from dragging column headers to the left or right to reorder them. However, it is usually not necessary to do this because the physical reordering of columns does not affect the column order seen by the script. For example, the first column will always be column 1 from the script's point of view, even if the user has physically moved it to the right of other columns.\n\nLV0x20: Specify to require that a row be clicked at its first field to select it (normally, a click on any field will select it). The advantage of this is that it makes it easier for the user to drag a rectangle around a group of rows to select them.\n\nMulti: Specify (minus Multi) to prevent the user from selecting more than one row at a time.\n\nNoSortHdr: Prevents the header from being clickable. It will take on a flat appearance rather than its normal button-like appearance. Unlike most other ListView styles, this one cannot be changed after the ListView is created.\n\nNoSort: Turns off the automatic sorting that occurs when the user clicks a column header. However, the header will still behave visually like a button (unless the NoSortHdr option above has been specified). In addition, the g-label will still receive the ColClick notification, to which it can respond with a custom sort or other action.\n\nReadOnly: Specify (minus ReadOnly) to allow editing of the text in the first column of each row. To edit a row, select it then press (see the WantF2 option below). Alternatively, you can click a row once to select it, wait at least half a second, then click the same row again to edit it.\n\nR: Rows of height (upon creation). Specify the letter R followed immediately by the number of rows for which to make room inside the control. For example, would make the control 10 rows tall. If the ListView is created with a view mode other than report view, the control is sized to fit rows of icons instead of rows of text. Note: adding icons to a ListView's rows will increase the height of each row, which will make this option inaccurate.\n\nSort: The control is kept alphabetically sorted according to the contents of the first column.\n\nSortDesc: Same as above except in descending order.\n\nWantF2: In [v1.0.44+], specify (minus WantF2) to prevent from editing the currently focused row. This setting is ignored unless -ReadOnly is also in effect. Regardless of this setting, the g-label still receives F2 notifications.\n\n(Unnamed numeric styles): Since styles other than the above are rarely used, they do not have names. See the ListView styles table for a list.\n\nA ListView has five viewing modes, of which the most common is report view (which is the default). To use one of the other views, specify its name in the options list. The view can also be changed after the control is created; for example: .\n\nIcon: Shows a large-icon view. In this view and all the others except Report, the text in columns other than the first is not visible. To display icons in this mode, the ListView must have a large-icon ImageList assigned to it.\n\nTile: Shows a large-icon view but with ergonomic differences such as displaying each item's text to the right of the icon rather than underneath it. Checkboxes do not function in this view. Also, attempting to show this view on operating systems older than Windows XP has no effect.\n\nList: Shows a small-icon view in list format, which displays the icons in columns. The number of columns depends on the width of the control and the width of the widest text item in it.\n\nReport: Switches back to report view, which is the initial default. For example: .\n\nAll of the following ListView functions operate upon the current thread's default GUI window (which can be changed via ). If the default window does not exist or has no ListView controls, all functions return zero to indicate the problem.\n\nIf the window has more than one ListView control, by default the functions operate upon the one most recently added. To change this, specify , where ListViewName is the name of the ListView's associated variable, its ClassNN as shown by Window Spy or in [v1.1.04+] its HWND. Once changed, all existing and future threads will use the indicated ListView. [v1.1.23+]: A_DefaultListView contains the current setting.\n\nWhen the phrase \"row number\" is used on this page, it refers to a row's current position within the ListView. The top row is 1, the second row is 2, and so on. After a row is added, its row number tends to change due to sorting, deleting, and inserting of other rows. Therefore, to locate specific row(s) based on their contents, it is usually best to use LV_GetText() in a loop.\n• LV_Add: Adds a new row to the bottom of the list.\n• LV_Insert: Inserts a new row at the specified row number.\n• LV_Delete: Deletes the specified row or all rows.\n• LV_ModifyCol: Modifies the attributes and/or text of the specified column and its header.\n• LV_InsertCol: Inserts a new column at the specified column number.\n• LV_DeleteCol: Deletes the specified column and all of the contents beneath it.\n• LV_GetCount: Returns the number of rows or columns in the control.\n• LV_GetNext: Returns the row number of the next selected, checked, or focused row.\n• LV_GetText: Retrieves the text at the specified row and column number.\n• LV_SetImageList: Sets or replaces an ImageList for displaying icons.\n\nAdds a new row to the bottom of the list.\n\nOn success, this function returns the new row number, which is not necessarily the last row if the ListView has the Sort or SortDesc style. On failure, it returns 0.\n\nInserts a new row at the specified row number.\n\nOn success, this function returns the specified row number. On failure, it returns 0.\n\nOn success, this function returns the specified row number. On failure, it returns 0. If RowNumber is 0 to modify all rows, it returns 1 on complete success and 0 if any part of the operation failed.\n\nWhen only the first two parameters are present, only the row's attributes and not its text are changed.\n\nDeletes the specified row or all rows.\n\nOn success, this function returns 1 (true). On failure, it returns 0 (false).\n\nModifies the attributes and/or text of the specified column and its header.\n\nIf this and the other parameters are all omitted, the width of every column is adjusted to fit the contents of the rows. This has no effect when not in Report (Details) view. Otherwise, specify the number of the column to modify. The first column is 1 (not 0). If omitted, it defaults to Auto (adjusts the column's width to fit its contents). Otherwise, specify one or more options from the list below (not case-sensitive). Separate each option from the next with a space or tab. To remove an option, precede it with a minus sign. To add an option, a plus sign is permitted but not required. N: Specify for N the new width of the column, in pixels. This number can be unquoted if is the only option. For example, the following are both valid: and . Auto: Adjusts the column's width to fit its contents. This has no effect when not in Report (Details) view. AutoHdr: Adjusts the column's width to fit its contents and the column's header text, whichever is wider. If applied to the last column, it will be made at least as wide as all the remaining space in the ListView. It is usually best to apply this setting only after the rows have been added because that allows any newly-arrived vertical scroll bar to be taken into account when sizing the last column. This has no effect when not in Report (Details) view. Icon: Specify the word Icon followed immediately by the number of the ImageList's icon to display next to the column header's text. Specify (minus icon) to remove any existing icon. IconRight: Puts the icon on the right side of the column rather than the left. Float: For sorting purposes, indicates that this column contains floating point numbers (hexadecimal format is not supported). Sorting performance for Float and Text columns is up to 25 times slower than it is for integers. Integer: For sorting purposes, indicates that this column contains integers. To be sorted properly, each integer must be 32-bit; that is, within the range -2147483648 to 2147483647. If any of the values are not integers, they will be considered zero when sorting (unless they start with a number, in which case that number is used). Numbers may appear in either decimal or hexadecimal format (e.g. ). Text: Changes the column back to text-mode sorting, which is the initial default for every column. Only the first 8190 characters of text are significant for sorting purposes (except for the Logical option, in which case the limit is 4094). Center: Centers the text in the column. To center an Integer or Float column, specify the word Center after the word Integer or Float. Left: Left-aligns the column's text, which is the initial default for every column. On older operating systems, the first column might have a forced left-alignment. Right: Right-aligns the column's text. This attribute need not be specified for Integer and Float columns because they are right-aligned by default. That default can be overridden by specifying something such as or . Case: The sorting of the column is case-sensitive (affects only text columns). If the options Case, CaseLocale, and Logical are all omitted, the uppercase letters A-Z are considered identical to their lowercase counterparts for the purpose of the sort. CaseLocale [v1.0.43.03+]: The sorting of the column is case-insensitive based on the current user's locale (affects only text columns). For example, most English and Western European locales treat the letters A-Z and ANSI letters like Ä and Ü as identical to their lowercase counterparts. This method also uses a \"word sort\", which treats hyphens and apostrophes in such a way that words like \"coop\" and \"co-op\" stay together. Desc: Descending order. The column starts off in descending order the first time the user sorts it. Logical [v1.0.44.12+]: Same as CaseLocale except that any sequences of digits in the text are treated as true numbers rather than mere characters. For example, the string \"T33\" would be considered greater than \"T4\". Logical requires Windows XP or later (on older OSes, CaseLocale is automatically used instead). In addition, Logical and Case are currently mutually exclusive: only the one most recently specified will be in effect. NoSort: Prevents a user's click on this column from having any automatic sorting effect. To disable sorting for all columns rather than only a subset, include NoSort in the ListView's options. If the ListView has a g-label, the ColClick notification will still be received when the user clicks a no-sort column. Sort: Immediately sorts the column in ascending order (even if it has the Desc option). Uni: Unidirectional sort. This prevents a second click on the same column from reversing the sort direction. If omitted, the current header is left unchanged. Otherwise, specify the new header of the column.\n\nOn success, this function returns 1 (true). On failure, it returns 0 (false).\n\nInserts a new column at the specified column number.\n\nOn success, this function returns the new column's position number. On failure, it returns 0.\n\nThe newly inserted column starts off with empty contents beneath it unless it is the first column, in which case it inherits the old first column's contents and the old first column acquires blank contents.\n\nThe maximum number of columns in a ListView is 200.\n\nDeletes the specified column and all of the contents beneath it.\n\nOn success, this function returns 1 (true). On failure, it returns 0 (false). On operating systems older than Windows XP, attempting to delete the original first column might fail and return 0.\n\nReturns the number of rows or columns in the control.\n\nThis function returns the number of rows or columns in the control. The value is always returned immediately because the control keeps track of these counts.\n\nThis function is often used in the top line of a Loop, in which case the function would get called only once (prior to the first iteration). For example:\n\nTo retrieve the widths of a ListView's columns -- for uses such as saving them to an INI file to be remembered between sessions -- follow this example:\n\nReturns the row number of the next selected, checked, or focused row.\n\nThis function returns the row number of the next selected, checked, or focused row. If none is found, it returns 0.\n\nThe following example reports all selected rows in the ListView:\n\nAn alternate method to find out if a particular row number is checked is the following:\n\nRetrieves the text at the specified row and column number.\n\nOn success, this function returns 1 (true). On failure, it returns 0 (false).\n\nColumn numbers seen by the script are not altered by any dragging and dropping of columns the user may have done. For example, the original first column is still number 1 even if the user drags it to the right of other columns.\n\nSets or replaces an ImageList for displaying icons.\n\nOn success, this function returns the ImageList ID that was previously associated with the ListView. On failure, it returns 0. Any such detached ImageList should normally be destroyed via IL_Destroy().\n\nThis function is normally called prior to adding any rows to the ListView. It sets the ImageList whose icons will be displayed by the ListView's rows (and optionally, its columns).\n\nA ListView may have up to two ImageLists: small-icon and/or large-icon. This is useful when the script allows the user to switch to and from the large-icon view. To add more than one ImageList to a ListView, call LV_SetImageList() a second time, specifying the ImageList ID of the second list. A ListView with both a large-icon and small-icon ImageList should ensure that both lists contain the icons in the same order. This is because the same ID number is used to reference both the large and small versions of a particular icon.\n\nAlthough it is traditional for all viewing modes except Icon and Tile to show small icons, this can be overridden by passing a large-icon list to LV_SetImageList() and specifying 1 (small-icon) for the second parameter. This also increases the height of each row in the ListView to fit the large icon.\n\nA g-label such as may be listed in the control's options. This would cause the MySubroutine label to be launched automatically whenever the user performs an action in the control. This subroutine may consult the built-in variables A_Gui and A_GuiControl to find out which window and ListView generated the event. More importantly, it may consult A_GuiEvent, which contains one of the following strings or letters (for compatibility with future versions, a script should not assume these are the only possible values):\n\nDoubleClick: The user has double-clicked within the control. The variable A_EventInfo contains the focused row number. LV_GetNext() can be used to instead get the first selected row number, which is 0 if the user double-clicked on empty space.\n\nR: The user has double-right-clicked within the control. The variable A_EventInfo contains the focused row number.\n\nColClick: The user has clicked a column header. The variable A_EventInfo contains the column number, which is the original number assigned when the column was created; that is, it does not reflect any dragging and dropping of columns done by the user. One possible response to a column click is to sort by a hidden column (zero width) that contains data in a sort-friendly format (such as a YYYYMMDD integer date). Such a hidden column can mirror some other column that displays the same data in a more friendly format (such as MM/DD/YY). For example, a script could hide column 3 via , then disable automatic sorting in the visible column 2 via . Then in response to the ColClick notification for column 2, the script would sort the ListView by the hidden column via .\n\nD: The user has attempted to start dragging a row or icon (there is currently no built-in support for dragging rows or icons). The variable A_EventInfo contains the focused row number. [v1.0.44+]: This notification occurs even without AltSubmit.\n\nd (lowercase D): Same as above except a right-click-drag rather than a left-drag.\n\ne (lowercase E): The user has finished editing the first field of a row (the user may edit it only when the ListView has in its options). The variable A_EventInfo contains the row number.\n\nIf the ListView has the word AltSubmit in its options, its g-label is launched more often and A_GuiEvent may contain the following additional values:\n\nNormal: The user has left-clicked a row. The variable A_EventInfo contains the focused row number.\n\nRightClick: The user has right-clicked a row. The variable A_EventInfo contains the focused row number. In most cases, it is best not to display a menu in response to this. Instead, use the GuiContextMenu label because it also recognizes the Apps key. For example:\n\nA: A row has been activated, which by default occurs when it is double clicked. The variable A_EventInfo contains the row number.\n\nC: The ListView has released mouse capture.\n\nE: The user has begun editing the first field of a row (the user may edit it only when the ListView has -ReadOnly in its options). The variable A_EventInfo contains the row number.\n\nI: Item changed. A row has changed by becoming selected/deselected, checked/unchecked, etc. If the user selects a new row, at least two such notifications are received: one for the de-selection of the previous row, and one for the selection of the new row. [v1.0.44+]: The variable A_EventInfo contains the row number. [v1.0.46.10+]: ErrorLevel contains zero or more of the following letters to indicate how the item changed: S (select) or s (de-select), and/or F (focus) or f (de-focus), and/or C (checkmark) or c (uncheckmark). For example, SF means that the row has been selected and focused. To detect whether a particular letter is present, use a parsing loop or the case-sensitive option of InStr(); for example: . Note: For compatibility with future versions, a script should not assume that \"SsFfCc\" are the only possible letters. Also, specifying Critical as the g-label's first line ensures that all \"I\" notifications are received (otherwise, some might be lost if the script cannot keep up with them).\n\nK: The user has pressed a key while the ListView has focus. A_EventInfo contains the virtual key code of the key, which is a number between 1 and 255. This can be translated to a key name or character via GetKeyName(). For example, . On most keyboard layouts, keys A-Z can be translated to the corresponding character via . is received regardless of WantF2. However, is not received; to receive it, use a default button as described below.\n\nM: Marquee. The user has started to drag a selection-rectangle around a group of rows or icons.\n\nS: The user has begun scrolling the ListView.\n\ns (lowercase S): The user has finished scrolling the ListView.\n\nAn Image-List is a group of identically sized icons stored in memory. Upon creation, each ImageList is empty. The script calls IL_Add() repeatedly to add icons to the list, and each icon is assigned a sequential number starting at 1. This is the number to which the script refers to display a particular icon in a row or column header. Here is a working example that demonstrates how to put icons into a ListView's rows:\n\nCreates a new ImageList that is initially empty.\n\nOn success, this function returns the unique ID of the newly created ImageList. On failure, it returns 0.\n\nAdds an icon or picture to the specified ImageList.\n\nOn success, this function returns the new icon's index (1 is the first icon, 2 is the second, and so on). On failure, it returns 0.\n\nOn success, this function returns 1 (true). On failure, it returns 0 (false).\n\nIt is normally not necessary to destroy ImageLists because once attached to a ListView, they are destroyed automatically when the ListView or its parent window is destroyed. However, if the ListView shares ImageLists with other ListViews (by having 0x40 in its options), the script should explicitly destroy the ImageList after destroying all the ListViews that use it. Similarly, if the script replaces one of a ListView's old ImageLists with a new one, it should explicitly destroy the old one.\n\nThe Gui Submit command has no effect on a ListView control. Therefore, the script may use the ListView's associated variable (if any) to store other data without concern that it will ever be overwritten.\n\nAfter a column is sorted -- either by means of the user clicking its header or the script calling -- any subsequently added rows will appear at the bottom of the list rather than obeying the sort order. The exception to this is the Sort and SortDesc styles, which move newly added rows into the correct positions.\n\nTo detect when the user has pressed while a ListView has focus, use a default button (which can be hidden if desired). For example:\n\nIn addition to navigating from row to row with the keyboard, the user may also perform incremental search by typing the first few characters of an item in the first column. This causes the selection to jump to the nearest matching row.\n\nAlthough any length of text can be stored in each field of a ListView, only the first 260 characters are displayed.\n\nAlthough the maximum number of rows in a ListView is limited only by available system memory, row-adding performance can be greatly improved as described in the Count option.\n\nA picture may be used as a background around a ListView (that is, to frame the ListView). To do this, create the picture control after the ListView and include 0x4000000 (which is WS_CLIPSIBLINGS) in the picture's Options.\n\nA script may create more than one ListView per window. To operate upon a ListView other than the default one, see built-in functions.\n\nIt is best not to insert or delete columns directly with SendMessage. This is because the program maintains a collection of sorting preferences for each column, which would then get out of sync. Instead, use the built-in column functions.\n\nTo perform actions such as resizing, hiding, or changing the font of a ListView, use GuiControl.\n\nTo extract text from external ListViews (those not owned by the script), use ControlGet List.\n\nThe following is a working script that is more elaborate than the one near the top of this page. It displays the files in a folder chosen by the user, with each file assigned the icon associated with its type. The user can double-click a file, or right-click one or more files to display a context menu. ; Allow the user to maximize or drag-resize the window: Gui +Resize ; Create some buttons: Gui, Add, Button, Default gButtonLoadFolder, Load a folder Gui, Add, Button, x+20 gButtonClear, Clear List Gui, Add, Button, x+20, Switch View ; Create the ListView and its columns via Gui Add: Gui, Add, ListView, xm r20 w700 vMyListView gMyListView, Name|In Folder|Size (KB)|Type LV_ModifyCol(3, \"Integer\") ; For sorting, indicate that the Size column is an integer. ; Create an ImageList so that the ListView can display some icons: ImageListID1 := IL_Create(10) ImageListID2 := IL_Create(10, 10, true) ; A list of large icons to go with the small ones. ; Attach the ImageLists to the ListView so that it can later display the icons: LV_SetImageList(ImageListID1) LV_SetImageList(ImageListID2) ; Create a popup menu to be used as the context menu: Menu, MyContextMenu, Add, Open, ContextOpenFile Menu, MyContextMenu, Add, Properties, ContextProperties Menu, MyContextMenu, Add, Clear from ListView, ContextClearRows Menu, MyContextMenu, Default, Open ; Make \"Open\" a bold font to indicate that double-click does the same thing. ; Display the window and return. The OS will notify the script whenever the user ; performs an eligible action: Gui, Show return ButtonLoadFolder: Gui +OwnDialogs ; Forces user to dismiss the following dialog before using main window. FileSelectFolder, Folder,, 3, Select a folder to read: if not Folder ; The user canceled the dialog. return ; Check if the last character of the folder name is a backslash, which happens for root ; directories such as C:\\. If it is, remove it to prevent a double-backslash later on. LastChar := SubStr(Folder, 0) if (LastChar = \"\\\") Folder := SubStr(Folder, 1, -1) ; Remove the trailing backslash. ; Calculate buffer size required for SHFILEINFO structure. sfi_size := A_PtrSize + 8 + (A_IsUnicode ? 680 : 340) VarSetCapacity(sfi, sfi_size) ; Gather a list of file names from the selected folder and append them to the ListView: GuiControl, -Redraw, MyListView ; Improve performance by disabling redrawing during load. Loop %Folder%\\*.* { FileName := A_LoopFileFullPath ; Must save it to a writable variable for use below. ; Build a unique extension ID to avoid characters that are illegal in variable names, ; such as dashes. This unique ID method also performs better because finding an item ; in the array does not require search-loop. SplitPath, FileName,,, FileExt ; Get the file's extension. if FileExt in EXE,ICO,ANI,CUR { ExtID := FileExt ; Special ID as a placeholder. IconNumber := 0 ; Flag it as not found so that these types can each have a unique icon. } else ; Some other extension/file-type, so calculate its unique ID. { ExtID := 0 ; Initialize to handle extensions that are shorter than others. Loop 7 ; Limit the extension to 7 characters so that it fits in a 64-bit value. { ExtChar := SubStr(FileExt, A_Index, 1) if not ExtChar ; No more characters. break ; Derive a Unique ID by assigning a different bit position to each character: ExtID := ExtID | (Asc(ExtChar) << (8 * (A_Index - 1))) } ; Check if this file extension already has an icon in the ImageLists. If it does, ; several calls can be avoided and loading performance is greatly improved, ; especially for a folder containing hundreds of files: IconNumber := IconArray%ExtID% } if not IconNumber ; There is not yet any icon for this extension, so load it. { ; Get the high-quality small-icon associated with this file extension: if not DllCall(\"Shell32\\SHGetFileInfo\" . (A_IsUnicode ? \"W\":\"A\"), \"Str\", FileName , \"UInt\", 0, \"Ptr\", &sfi, \"UInt\", sfi_size, \"UInt\", 0x101) ; 0x101 is SHGFI_ICON+SHGFI_SMALLICON IconNumber := 9999999 ; Set it out of bounds to display a blank icon. else ; Icon successfully loaded. { ; Extract the hIcon member from the structure: hIcon := NumGet(sfi, 0) ; Add the HICON directly to the small-icon and large-icon lists. ; Below uses +1 to convert the returned index from zero-based to one-based: IconNumber := DllCall(\"ImageList_ReplaceIcon\", \"Ptr\", ImageListID1, \"Int\", -1, \"Ptr\", hIcon) + 1 DllCall(\"ImageList_ReplaceIcon\", \"Ptr\", ImageListID2, \"Int\", -1, \"Ptr\", hIcon) ; Now that it's been copied into the ImageLists, the original should be destroyed: DllCall(\"DestroyIcon\", \"Ptr\", hIcon) ; Cache the icon to save memory and improve loading performance: IconArray%ExtID% := IconNumber } } ; Create the new row in the ListView and assign it the icon number determined above: LV_Add(\"Icon\" . IconNumber, A_LoopFileName, A_LoopFileDir, A_LoopFileSizeKB, FileExt) } GuiControl, +Redraw, MyListView ; Re-enable redrawing (it was disabled above). LV_ModifyCol() ; Auto-size each column to fit its contents. LV_ModifyCol(3, 60) ; Make the Size column at little wider to reveal its header. return ButtonClear: LV_Delete() ; Clear the ListView, but keep icon cache intact for simplicity. return ButtonSwitchView: if not IconView GuiControl, +Icon, MyListView ; Switch to icon view. else GuiControl, +Report, MyListView ; Switch back to details view. IconView := not IconView ; Invert in preparation for next time. return MyListView: if (A_GuiEvent = \"DoubleClick\") ; There are many other possible values the script can check. { LV_GetText(FileName, A_EventInfo, 1) ; Get the text of the first field. LV_GetText(FileDir, A_EventInfo, 2) ; Get the text of the second field. Run %FileDir%\\%FileName%,, UseErrorLevel if ErrorLevel MsgBox Could not open \"%FileDir%\\%FileName%\". } return GuiContextMenu: ; Launched in response to a right-click or press of the Apps key. if (A_GuiControl != \"MyListView\") ; Display the menu only for clicks inside the ListView. return ; Show the menu at the provided coordinates, A_GuiX and A_GuiY. These should be used ; because they provide correct coordinates even if the user pressed the Apps key: Menu, MyContextMenu, Show, %A_GuiX%, %A_GuiY% return ContextOpenFile: ; The user selected \"Open\" in the context menu. ContextProperties: ; The user selected \"Properties\" in the context menu. ; For simplicitly, operate upon only the focused row rather than all selected rows: FocusedRowNumber := LV_GetNext(0, \"F\") ; Find the focused row. if not FocusedRowNumber ; No row is focused. return LV_GetText(FileName, FocusedRowNumber, 1) ; Get the text of the first field. LV_GetText(FileDir, FocusedRowNumber, 2) ; Get the text of the second field. if InStr(A_ThisMenuItem, \"Open\") ; User selected \"Open\" from the context menu. Run %FileDir%\\%FileName%,, UseErrorLevel else ; User selected \"Properties\" from the context menu. Run Properties \"%FileDir%\\%FileName%\",, UseErrorLevel if ErrorLevel MsgBox Could not perform requested action on \"%FileDir%\\%FileName%\". return ContextClearRows: ; The user selected \"Clear\" in the context menu. RowNumber := 0 ; This causes the first iteration to start the search at the top. Loop { ; Since deleting a row reduces the RowNumber of all other rows beneath it, ; subtract 1 so that the search includes the same row number that was previously ; found (in case adjacent rows are selected): RowNumber := LV_GetNext(RowNumber - 1) if not RowNumber ; The above returned zero, so there are no more selected rows. break LV_Delete(RowNumber) ; Clear the row from the ListView. } return GuiSize: ; Expand or shrink the ListView in response to the user's resizing of the window. if (A_EventInfo = 1) ; The window has been minimized. No action needed. return ; Otherwise, the window has been resized or maximized. Resize the ListView to match. GuiControl, Move, MyListView, % \"W\" . (A_GuiWidth - 20) . \" H\" . (A_GuiHeight - 40) return GuiClose: ; When the window is closed, exit the script automatically: ExitApp"
    },
    {
        "link": "https://documentation.help/AutoHotKey-Functions/ListView.htm",
        "document": "\n• Built-in Functions:\n• Getting data out of a ListView\n• ImageLists (the means by which icons are added to a ListView)\n\nA List-View is one of the most elaborate controls provided by the operating system. In its most recognizable form, it displays a tabular view of rows and columns, the most common example of which is Explorer's list of files and folders (detail view).\n\nThough it may be elaborate, a ListView's basic features are easy to use. The syntax for creating a ListView is:\n\nHere is a working script that creates and displays a ListView containing a list of files in the user's \"My Documents\" folder:\n\nAltSubmit: Notifies the script for more types of ListView events than normal. In other words, the g-label is launched more often. See ListView Notifications for details.\n\nBackground: Specify the word Background followed immediately by a color name (see color chart) or RGB value (the 0x prefix is optional). Examples: , . If this option is not present, the ListView initially defaults to the background color set by the last parameter of Gui Color (or if none, the system's default background color). Specifying applies the system's default background color (usually white). For example, a ListView can be restored to the default color via .\n\nC: Text color. Specify the letter C followed immediately by a color name (see color chart) or RGB value (the 0x prefix is optional). Examples: , , , .\n\nChecked: Provides a checkbox at the left side of each row. When adding a row, specify the word Check in its options to have the box to start off checked instead of unchecked. The user may either click the checkbox or press the spacebar to check or uncheck a row.\n\nCount: Specify the word Count followed immediately by the total number of rows that the ListView will ultimately contain. This is not a limit: rows beyond the count can still be added. Instead, this option serves as a hint to the control that allows it to allocate memory only once rather than each time a row is added, which greatly improves row-adding performance (it may also improve sorting performance). To improve performance even more, use prior to adding a large number of rows. Afterward, use to re-enable redrawing (which also repaints the control).\n\nGrid: Provides horizontal and vertical lines to visually indicate the boundaries between rows and columns.\n\nHdr: Specify (minus Hdr) to omit the special top row that contains column titles. To make it visible later, use .\n\nLV: Specify the string LV followed immediately by the number of an extended ListView style. These styles are entirely separate from generic extended styles. For example, specifying would remove the generic extended style WS_EX_CLIENTEDGE to eliminate the control's default border. By contrast, specifying would remove LVS_EX_FULLROWSELECT.\n\nLV0x10: Specify to prevent the user from dragging column headers to the left or right to reorder them. However, it is usually not necessary to do this because the physical reordering of columns does not affect the column order seen by the script. For example, the first column will always be column 1 from the script's point of view, even if the user has physically moved it to the right of other columns.\n\nLV0x20: Specify to require that a row be clicked at its first field to select it (normally, a click on any field will select it). The advantage of this is that it makes it easier for the user to drag a rectangle around a group of rows to select them.\n\nMulti: Specify (minus Multi) to prevent the user from selecting more than one row at a time.\n\nNoSortHdr: Prevents the header from being clickable. It will take on a flat appearance rather than its normal button-like appearance. Unlike most other ListView styles, this one cannot be changed after the ListView is created.\n\nNoSort: Turns off the automatic sorting that occurs when the user clicks a column header. However, the header will still behave visually like a button (unless NoSortHdr has been specified). In addition, the g-label will still receive the ColClick notification, to which it can respond with a custom sort or other action.\n\nReadOnly: Specify (minus ReadOnly) to allow editing of the text in the first column of each row. To edit a row, select it then press the F2 key. Alternatively, you can click a row once to select it, wait at least half a second, then click the same row again to edit it.\n\nR: Rows of height (upon creation). Specify the letter R followed immediately by the number of rows for which to make room inside the control. For example, would make the control 10 rows tall. If the ListView is created with a view mode other than report view, the control is sized to fit rows of icons instead of rows of text. Note: adding icons to a ListView's rows will increase the height of each row, which will make this option inaccurate.\n\nSort: The control is kept alphabetically sorted according to the contents of the first column.\n\nSortDesc: Same as above except in descending order.\n\nWantF2 [v1.0.44+]: Specify (minus WantF2) to prevent an F2 keystroke from editing the currently focused row. This setting is ignored unless is also in effect. Regardless of this setting, the g-label still receives F2 notifications.\n\n(Unnamed numeric styles): Since styles other than the above are rarely used, they do not have names. See the ListView styles table for a list.\n\nA ListView has five viewing modes, of which the most common is report view (which is the default). To use one of the other views, specify its name in the options list. The view can also be changed after the control is created; for example: .\n\nIcon: Shows a large-icon view. In this view and all the others except Report, the text in columns other than the first is not visible. To display icons in this mode, the ListView must have a large-icon ImageList assigned to it.\n\nTile: Shows a large-icon view but with ergonomic differences such as displaying each item's text to the right of the icon rather than underneath it. Checkboxes do not function in this view. Also, attempting to show this view on operating systems older than Windows XP has no effect.\n\nList: Shows a small-icon view in list format, which displays the icons in columns. The number of columns depends on the width of the control and the width of the widest text item in it.\n\nReport: Switches back to report view, which is the initial default. For example: .\n\nAll of the ListView functions operate upon the current thread's default GUI window (which can be changed via ). If the default window does not exist or has no ListView controls, all functions return zero to indicate the problem.\n\nIf the window has more than one ListView control, by default the functions operate upon the one most recently added. To change this, specify , where ListViewName is the name of the ListView's associated variable, its ClassNN as shown by Window Spy or [in v1.1.04+] its HWND. Once changed, all existing and future threads will use the indicated ListView. [v1.1.23+]: A_DefaultListView contains the current setting.\n\nWhen the phrase \"row number\" is used on this page, it refers to a row's current position within the ListView. The top row is 1, the second row is 2, and so on. After a row is added, its row number tends to change due to sorting, deleting, and inserting of other rows. Therefore, to locate specific row(s) based on their contents, it is usually best to use LV_GetText() in a loop.\n\nAdds a new row to the bottom of the list. The parameters Field1 and beyond are the columns of the new row, which can be text or numeric (including numeric expression results). To make any field blank, specify \"\" or the equivalent. If there are too few fields to fill all the columns, the columns at the end are left blank. If there are too many fields, the fields at the end are completely ignored.\n\nUpon failure, LV_Add() returns 0. Upon success, it returns the new row number, which is not necessarily the last row if the ListView has the Sort or SortDesc style.\n\nThe Options parameter is a string containing zero or more words from the list below (not case sensitive). Separate each word from the next with a space or tab. To remove an option, precede it with a minus sign. To add an option, a plus sign is permitted but not required.\n\nCheck: Shows a checkmark in the row (if the ListView has checkboxes). To later uncheck it, use .\n\nCol: Specify the word Col followed immediately by the column number at which to begin applying the parameters Col1 and beyond. This is most commonly used with LV_Modify() to alter individual fields in a row without affecting those that lie to their left.\n\nFocus: Sets keyboard focus to the row (often used in conjunction with Select). To later de-focus it, use .\n\nIcon: Specify the word Icon followed immediately by the number of this row's icon, which is displayed in the left side of the first column. If this option is absent, the first icon in the ImageList is used. To display a blank icon, specify a number that is larger than the number of icons in the ImageList. If the control lacks a small-icon ImageList, no icon is displayed nor is any space reserved for one in report view.\n\nSelect: Selects the row. To later deselect it, use . When selecting rows, it is usually best to ensure that at least one row always has the focus property because that allows the Apps key to display its context menu (if any) near the focused row. The word Select may optionally be followed immediately by a 0 or 1 to indicate the starting state. In other words, both and are the same (the period used here is the concatenation operator). This technique also works with Focus and Check above.\n\nVis [v1.0.44+]: Ensures that the specified row is completely visible by scrolling the ListView, if necessary. This has an effect only for LV_Modify(); for example: .\n\nBehaves identically to LV_Add() except for its different first parameter, which specifies the row number for the newly inserted row. Any rows at or beneath RowNumber are shifted downward to make room for the new row. If RowNumber is greater than the number of rows in the list (even as high as 2147483647), the new row is added to the end of the list. For Options, see row options.\n\nModifies the attributes and/or text of a row, and returns 1 upon success and 0 upon failure. If RowNumber is 0, rows in the control are modified (in this case the function returns 1 on complete success and 0 if any part of the operation failed). When only the first two parameters are present, only the row's attributes and not its text are changed. Similarly, if there are too few parameters to cover all the columns, the columns at the end are not changed. The ColN option may be used to update specific columns without affecting the others. For other options, see row options.\n\nIf the parameter is omitted, all rows in the ListView are deleted. Otherwise, only the specified RowNumber is deleted. It returns 1 upon success and 0 upon failure.\n\nModifies the attributes and/or text of the specified column and its header. The first column is number 1 (not 0). If all parameters are omitted, the width of every column is adjusted to fit the contents of the rows. If only the first parameter is present, only the specified column is auto-sized. Auto-sizing has no effect when not in Report (Details) view. This function returns 1 upon success and 0 upon failure.\n\nThe Options parameter is a string containing zero or more words from the list below (not case sensitive). Separate each word from the next with a space or tab. To remove an option, precede it with a minus sign. To add an option, a plus sign is permitted but not required.\n\nN: Specify for N the new width of the column, in pixels. This number can be unquoted if is the only option. For example, the following are both valid: and .\n\nAuto: Adjusts the column's width to fit its contents. This has no effect when not in Report (Details) view.\n\nAutoHdr: Adjusts the column's width to fit its contents and the column's header text, whichever is wider. If applied to the last column, it will be made at least as wide as all the remaining space in the ListView. It is usually best to apply this setting only after the rows have been added because that allows any newly-arrived vertical scroll bar to be taken into account when sizing the last column. This option has no effect when not in Report (Details) view.\n\nIcon: Specify the word Icon followed immediately by the number of the ImageList's icon to display next to the column header's text. Specify (minus icon) to remove any existing icon.\n\nIconRight: Puts the icon on the right side of the column rather than the left.\n\nFloat: For sorting purposes, indicates that this column contains floating point numbers (hexadecimal format is not supported). Sorting performance for Float and Text columns is up to 25 times slower than it is for integers.\n\nInteger: For sorting purposes, indicates that this column contains integers. To be sorted properly, each integer must be 32-bit; that is, within the range -2147483648 to 2147483647. If any of the values are not integers, they will be considered zero when sorting (unless they start with a number, in which case that number is used). Numbers may appear in either decimal or hexadecimal format (e.g. ).\n\nText: Changes the column back to text-mode sorting, which is the initial default for every column. Only the first 8190 characters of text are significant for sorting purposes (except for the Logical option, in which case the limit is 4094).\n\nCenter: Centers the text in the column. To center an Integer or Float column, specify the word Center after the word Integer or Float.\n\nLeft: Left-justifies the column's text, which is the initial default for every column. On older operating systems, the first column might have a forced left-justification.\n\nRight: Right-justifies the column's text. This attribute need not be specified for Integer and Float columns because they are right-justified by default. That default can be overridden by specifying something such as or .\n\nCase: The sorting of the column is case sensitive (affects only text columns). If the options Case, CaseLocale, and Logical are all omitted, the uppercase letters A-Z are considered identical to their lowercase counterparts for the purpose of the sort.\n\nCaseLocale [v1.0.43.03+]: The sorting of the column is case insensitive based on the current user's locale (affects only text columns). For example, most English and Western European locales treat the letters A-Z and ANSI letters like Ä and Ü as identical to their lowercase counterparts. This method also uses a \"word sort\", which treats hyphens and apostrophes in such a way that words like \"coop\" and \"co-op\" stay together.\n\nDesc: Descending order. The column starts off in descending order the first time the user sorts it.\n\nLogical [v1.0.44.12+]: Same as CaseLocale except that any sequences of digits in the text are treated as true numbers rather than mere characters. For example, the string \"T33\" would be considered greater than \"T4\". Logical requires Windows XP or later (on older OSes, CaseLocale is automatically used instead). In addition, Logical and Case are currently mutually exclusive: only the one most recently specified will be in effect.\n\nNoSort: Prevents a user's click on this column from having any automatic sorting effect. To disable sorting for all columns rather than only a subset, include NoSort in the ListView's options. If the ListView has a g-label, the ColClick notification will still be received when the user clicks a no-sort column.\n\nSort: Immediately sorts the column in ascending order (even if it has the Desc option).\n\nUni: Unidirectional sort. This prevents a second click on the same column from reversing the sort direction.\n\nCreates a new column, inserting it as the specified ColumnNumber (shifting any other columns to the right to make room). The first column is 1 (not 0). If ColumnNumber is larger than the number of columns currently in the control, the new column is added to the end of the list. The newly inserted column starts off with empty contents beneath it unless it is the first column, in which case it inherits the old first column's contents and the old first column acquires blank contents. The new column's attributes -- such as whether or not it uses integer sorting -- always start off at their defaults unless changed via Options. This function returns the new column's position number (or 0 upon failure). The maximum number of columns in a ListView is 200.\n\nDeletes the specified column and all of the contents beneath it. It returns 1 upon success and 0 upon failure. Once a column is deleted, the column numbers of any that lie to its right are reduced by 1. Consequently, calling twice would delete the second and third columns. On operating systems older than Windows XP, attempting to delete the original first column might fail and return 0.\n\nGetting Data Out of a ListView\n\nWhen the parameter is omitted, the function returns the total number of rows in the control. When the parameter is \"S\" or \"Selected\", the count includes only the selected/highlighted rows. When the parameter is \"Col\" or \"Column\", the function returns the number of columns in the control. This function is always instantaneous because the control keeps track of these counts.\n\nThis function is often used in the top line of a Loop, in which case the function would get called only once (prior to the first iteration). For example:\n\nTo retrieve the widths of a ListView's columns -- for uses such as saving them to an INI file to be remembered between sessions -- follow this example:\n\nReturns the row number of the next selected, checked, or focused row. If none is found, zero is returned. If StartingRowNumber is omitted or less than 1, the search begins at the top of the list. Otherwise, the search begins at the row after StartingRowNumber. If the second parameter is omitted, the function searches for the next selected/highlighted row. Otherwise, specify \"C\" or \"Checked\" to find the next checked row; or \"F\" or \"Focused\" to find the focused row (there is never more than one focused row in the entire list, and sometimes there is none at all). The following example reports all selected rows in the ListView:\n\nAn alternate method to find out if a particular row number is checked is the following:\n\nRetrieves the text at the specified RowNumber and ColumnNumber and stores it in OutputVar. If ColumnNumber is omitted, it defaults to 1 (the text in the first column). If RowNumber is 0, the column header text is retrieved. If the text is longer than 8191, only the first 8191 characters are retrieved. The function returns 1 upon success and 0 upon failure. Upon failure, OutputVar is also made blank.\n\nColumn numbers seen by the script are not altered by any dragging and dropping of columns the user may have done. For example, the original first column is still number 1 even if the user drags it to the right of other columns.\n\nA g-label such as may be listed in the control's options. This would cause the MySubroutine label to be launched automatically whenever the user performs an action in the control. This subroutine may consult the built-in variables A_Gui and A_GuiControl to find out which window and ListView generated the event. More importantly, it may consult A_GuiEvent, which contains one of the following strings or letters (for compatibility with future versions, a script should not assume these are the only possible values):\n\nDoubleClick: The user has double-clicked within the control. The variable A_EventInfo contains the focused row number. LV_GetNext() can be used to instead get the first selected row number, which is 0 if the user double-clicked on empty space.\n\nR: The user has double-right-clicked within the control. The variable A_EventInfo contains the focused row number.\n\nColClick: The user has clicked a column header. The variable A_EventInfo contains the column number, which is the original number assigned when the column was created; that is, it does not reflect any dragging and dropping of columns done by the user. One possible response to a column click is to sort by a hidden column (zero width) that contains data in a sort-friendly format (such as a YYYYMMDD integer date). Such a hidden column can mirror some other column that displays the same data in a more friendly format (such as MM/DD/YY). For example, a script could hide column 3 via , then disable automatic sorting in the visible column 2 via . Then in response to the ColClick notification for column 2, the script would sort the ListView by the hidden column via .\n\nD: The user has attempted to start dragging a row or icon (there is currently no built-in support for dragging rows or icons). The variable A_EventInfo contains the focused row number. [v1.0.44+]: This notification occurs even without AltSubmit.\n\nd (lowercase D): Same as above except a right-click-drag rather than a left-drag.\n\ne (lowercase E): The user has finished editing the first field of a row (the user may edit it only when the ListView has in its options). The variable A_EventInfo contains the row number.\n\nIf the ListView has the word AltSubmit in its options, its g-label is launched more often and A_GuiEvent may contain the following additional values:\n\nNormal: The user has left-clicked a row. The variable A_EventInfo contains the focused row number.\n\nRightClick: The user has right-clicked a row. The variable A_EventInfo contains the focused row number. In most cases, it is best not to display a menu in response to this. Instead, use the GuiContextMenu label because it also recognizes the Apps key. For example:\n\nA: A row has been activated, which by default occurs when it is double clicked. The variable A_EventInfo contains the row number.\n\nC: The ListView has released mouse capture.\n\nE: The user has begun editing the first field of a row (the user may edit it only when the ListView has in its options). The variable A_EventInfo contains the row number.\n\nI: Item changed. A row has changed by becoming selected/deselected, checked/unchecked, etc. If the user selects a new row, at least two such notifications are received: one for the de-selection of the previous row, and one for the selection of the new row. [v1.0.44+]: The variable A_EventInfo contains the row number. [v1.0.46.10+]: ErrorLevel contains zero or more of the following letters to indicate how the item changed: S (select) or s (de-select), and/or F (focus) or f (de-focus), and/or C (checkmark) or c (uncheckmark). For example, SF means that the row has been selected and focused. To detect whether a particular letter is present, use a parsing loop or the case-sensitive option of InStr(); for example: . Note: For compatibility with future versions, a script should not assume that \"SsFfCc\" are the only possible letters. Also, specifying Critical as the g-label's first line ensures that all \"I\" notifications are received (otherwise, some might be lost if the script cannot keep up with them).\n\nK: The user has pressed a key while the ListView has focus. A_EventInfo contains the virtual key code of the key, which is a number between 1 and 255. This can be translated to a key name or character via GetKeyName. For example, . On most keyboard layouts, keys A-Z can be translated to the corresponding character via . F2 keystrokes are received regardless of WantF2. However, the Enter keystroke is not received; to receive it, use a default button as described below.\n\nM: Marquee. The user has started to drag a selection-rectangle around a group of rows or icons.\n\nS: The user has begun scrolling the ListView.\n\ns (lowercase S): The user has finished scrolling the ListView.\n\nAn Image-List is a group of identically sized icons stored in memory. Upon creation, each ImageList is empty. The script calls IL_Add() repeatedly to add icons to the list, and each icon is assigned a sequential number starting at 1. This is the number to which the script refers to display a particular icon in a row or column header. Here is a working example that demonstrates how to put icons into a ListView's rows:\n\nCreates a new ImageList, initially empty, and returns the unique ID of the ImageList (or 0 upon failure). InitialCount is the number of icons you expect to put into the list immediately (if omitted, it defaults to 2). GrowCount is the number of icons by which the list will grow each time it exceeds the current list capacity (if omitted, it defaults to 5). LargeIcons should be a numeric value: If non-zero, the ImageList will contain large icons. If zero, it will contain small icons (this is the default when omitted). Icons added to the list are scaled automatically to conform to the system's dimensions for small and large icons.\n\nThis function is normally called prior to adding any rows to the ListView. It sets the ImageList whose icons will be displayed by the ListView's rows (and optionally, its columns). ImageListID is the number returned from a previous call to IL_Create(). If the second parameter is omitted, the type of icons in the ImageList is detected automatically as large or small. Otherwise, specify 0 for large icons, 1 for small icons, and 2 for state icons (state icons are not yet directly supported, but they could be used via SendMessage).\n\nA ListView may have up to two ImageLists: small-icon and/or large-icon. This is useful when the script allows the user to switch to and from the large-icon view. To add more than one ImageList to a ListView, call LV_SetImageList() a second time, specifying the ImageListID of the second list. A ListView with both a large-icon and small-icon ImageList should ensure that both lists contain the icons in the same order. This is because the same ID number is used to reference both the large and small versions of a particular icon.\n\nAlthough it is traditional for all viewing modes except Icon and Tile to show small icons, this can be overridden by passing a large-icon list to LV_SetImageList and specifying 1 (small-icon) for the second parameter. This also increases the height of each row in the ListView to fit the large icon.\n\nIf successful, LV_SetImageList() returns the ImageListID that was previously associated with the ListView (or 0 if none). Any such detached ImageList should normally be destroyed via IL_Destroy(ImageListID).\n\nAdds an icon or picture to the specified ImageListID and returns the new icon's index (1 is the first icon, 2 is the second, and so on). Filename is the name of an icon (.ICO), cursor (.CUR), or animated cursor (.ANI) file (animated cursors will not actually be animated when displayed in a ListView). Other sources of icons include the following types of files: EXE, DLL, CPL, SCR, and other types that contain icon resources. To use an icon group other than the first one in the file, specify its number for IconNumber. If IconNumber is negative, its absolute value is assumed to be the resource ID of an icon within an executable file. In the following example, the default icon from the second icon group would be used: .\n\nNon-icon images such as BMP, GIF and JPG may also be loaded. However, in this case the last two parameters should be specified to ensure correct behavior: IconNumber should be the mask/transparency color number (0xFFFFFF [the color white] might be best for most pictures); and ResizeNonIcon should be non-zero to cause the picture to be scaled to become a single icon, or zero to divide up the image into however many icons can fit into its actual width.\n\nAll operating systems support GIF, JPG, BMP, ICO, CUR, and ANI images. On Windows XP or later, additional image formats such as PNG, TIF, Exif, WMF, and EMF are supported. Operating systems older than XP can be given support by copying Microsoft's free GDI+ DLL into the AutoHotkey.exe folder (but in the case of a compiled script, copy the DLL into the script's folder). To download the DLL, search for the following phrase at www.microsoft.com: gdi redistributable\n\n[v1.1.23+]: A bitmap or icon handle can be used instead of a filename. For example, .\n\nDeletes the specified ImageList and returns 1 upon success and 0 upon failure. It is normally not necessary to destroy ImageLists because once attached to a ListView, they are destroyed automatically when the ListView or its parent window is destroyed. However, if the ListView shares ImageLists with other ListViews (by having in its options), the script should explicitly destroy the ImageList after destroying all the ListViews that use it. Similarly, if the script replaces one of a ListView's old ImageLists with a new one, it should explicitly destroy the old one.\n\nThe Gui Submit command has no effect on a ListView control. Therefore, the script may use the ListView's associated variable (if any) to store other data without concern that it will ever be overwritten.\n\nAfter a column is sorted -- either by means of the user clicking its header or the script calling -- any subsequently added rows will appear at the bottom of the list rather than obeying the sort order. The exception to this is the Sort and SortDesc styles, which move newly added rows into the correct positions.\n\nTo detect when the user has pressed Enter while a ListView has focus, use a default button (which can be hidden if desired). For example:\n\nIn addition to navigating from row to row with the keyboard, the user may also perform incremental search by typing the first few characters of an item in the first column. This causes the selection to jump to the nearest matching row.\n\nAlthough any length of text can be stored in each field of a ListView, only the first 260 characters are displayed.\n\nAlthough the maximum number of rows in a ListView is limited only by available system memory, row-adding performance can be greatly improved as described in the Count option.\n\nA picture may be used as a background around a ListView (that is, to frame the ListView). To do this, create the picture control after the ListView and include (which is WS_CLIPSIBLINGS) in the picture's Options.\n\nA script may create more than one ListView per window. To operate upon a ListView other than the default one, see built-in functions.\n\nIt is best not to insert or delete columns directly with SendMessage. This is because the program maintains a collection of sorting preferences for each column, which would then get out of sync. Instead, use the built-in column functions.\n\nTo perform actions such as resizing, hiding, or changing the font of a ListView, use GuiControl.\n\nTo extract text from external ListViews (those not owned by the script), use ControlGet List."
    },
    {
        "link": "https://autohotkey.com/boards/viewtopic.php?t=14408",
        "document": "Thanks for all the help, but I think I'm not explaining my issue well enough. I copied your code and I understand how if works, however, it creates a new listview and I want to refer to the one that I have that is on the form that I have open. Maybe it would help if I add some of my code:\n\n \n\n ;find the control and get the count of records.\n\n jobsearch_win := WinActive(wfxWindowSuffix)\n\n ControlGet, recCount, List,Count, SysListView322, ahk_id %jobsearch_win%\n\n \n\n ;then I loop through the records moving the mouse down 14 pixels only for the amount of records displayed on the control (in this case 15 records) after that the mouse remains in the same spot until the look is finished\n\n Loop, %recCount%\n\n {\n\n ;first record no need to move\n\n if(A_Index = 1){\n\n MouseMove, mouseX, mouseY\n\n }\n\n ;records once the page starts scrolling, the mouse needs to double click the same spot\n\n else if (A_Index > 15)\n\n { \n\n Send {Down}\n\n MouseMove, mouseX, mouseY\n\n }\n\n ;the first 15 records (after the first) need to have the mouse move 15 pixels down to be able to double click the record\n\n else\n\n { \n\n mouseY := mouseY + 14\n\n Send {Down}\n\n MouseMove, mouseX, mouseY \n\n }\n\n sleep 1000\n\n ;double click and then process the data. using click with mouse x and y in case someone moves the mouse\n\n Click, %mouseX%, %mouseY%\n\n Click, %mouseX%, %mouseY%\n\n \n\n ;sets the path of the csv file we are building\n\n csvfilePrefix := A_Scriptdir \"\\\" filePrefix\n\n csvfileSuffix := fileSuffix \".csv\" \n\n \n\n ;process the job data\n\n ScrapeJob(csvfilePrefix, csvfileSuffix)\n\n \n\n ;need a click to select record so down arrow works\n\n Click, %mouseX%, %mouseY%\n\n \n\n I would like to get rid of this entire block of code, so it's not dependent on the number of records on the screen, mouse clicks and down keys. Unless I'm wrong, I believe that this can be done with code and referencing the listview that I have on the form (SysListView322) and some help by great people like you.\n\n \n\n thanks\n\n Penguin"
    },
    {
        "link": "https://autohotkey.com/boards/viewtopic.php?t=9392",
        "document": "I try to get some infomration from a running program.The information I want to see, is in a listview with the name \"ListBox1\".If I use \"AutoIt3 Windows Spy\", only the name of the list view are displayed.Depending on who is log in the program, different number of choices appears (3-15)If I'm reading the ListView with the program \"WinSpy ++\", can you see how many rows as \"ListBox1\" contains.Under \"Properties\", you can read information about the window.There is a tip \"Window Properties are entires Stored in an window's property list, by using the SetProp API call.\" But I do not know how I can use the hint.Under the headingit saysI have tried with someting like this .:No information is displayed"
    },
    {
        "link": "https://reddit.com/r/AutoHotkey/comments/99u5rm/lets_talk_guis_how_do_you_organize_your",
        "document": "So, I've been working on some scripts recently that are GUI oriented.\n\nI've been trying all kinds of different ways of organizing and structuring the code for them.\n\nMy question is this:\n\nIs there any kind of generalized standards or best practices for doing GUIs? Even if it's not specific to AHK.\n\nLike how do you guys structure your data for larger GUIs?\n\nWhat methods do you use to store your variables?\n\nHow do you group/sort your functions?\n\nDo you create your GUIs in their own file and just import them?\n\nMy current go-to is using multiple objects (multidimensional arrays) to store all my info and functions to process whatever I need. I have one object for the main GUI, one for the options section, one for the save section, one for the sliders/adjustment area, one for the header, etc...But it seems like there should be better ways of doing this.\n\nIt's not that I'm struggling to do this or make something happen, I just feel like I'm not donig it the best way or efficiently. So, that's why I'm asking for everyone's opinions, examples, etc.\n\nSo, what do you guys do for bigger GUIs?\n\nFeel free to post examples or link to GUIs you've made. Pics are welcome. Tips and tricks you've learned are never a bad thing.\n\nI'm just wanting to scrape ideas and habits from people who have a lot of experience with making UIs and be more efficient with writing these things. Teach me some best practices and some effective GUI programming habits."
    },
    {
        "link": "https://autohotkey.com/docs/v2/lib/ListView.htm",
        "document": "\n• Options and Styles for the Options Parameter\n• ImageLists (the means by which icons are added to a ListView)\n\nA ListView is one of the most elaborate controls provided by the operating system. In its most recognizable form, it displays a tabular view of rows and columns, the most common example of which is Explorer's list of files and folders (detail view).\n\nA ListView usually looks like this:\n\nThough it may be elaborate, a ListView's basic features are easy to use. The syntax for creating a ListView is:\n\nHere is a working script that creates and displays a ListView containing a list of files in the user's \"My Documents\" folder:\n\nOptions and Styles for the Options Parameter\n\nBackground: Specify the word Background followed immediately by a color name (see color chart) or RGB value (the 0x prefix is optional). Examples: , . If this option is not present, the ListView initially defaults to the system's default background color. Specifying or applies the system's default background color (usually white). For example, a ListView can be restored to the default color via .\n\nC: Text color. Specify the letter C followed immediately by a color name (see color chart) or RGB value (the 0x prefix is optional). Examples: , , , .\n\nChecked: Provides a checkbox at the left side of each row. When adding a row, specify the word Check in its options to have the box to start off checked instead of unchecked. The user may either click the checkbox or press the spacebar to check or uncheck a row.\n\nCount: Specify the word Count followed immediately by the total number of rows that the ListView will ultimately contain. This is not a limit: rows beyond the count can still be added. Instead, this option serves as a hint to the control that allows it to allocate memory only once rather than each time a row is added, which greatly improves row-adding performance (it may also improve sorting performance). To improve performance even more, use prior to adding a large number of rows and afterward. See Redraw for more details.\n\nGrid: Provides horizontal and vertical lines to visually indicate the boundaries between rows and columns.\n\nHdr: Specify (minus Hdr) to omit the header (the special top row that contains column titles). To make it visible later, use .\n\nLV: Specify the string LV followed immediately by the number of an extended ListView style. These styles are entirely separate from generic extended styles. For example, specifying would remove the generic extended style WS_EX_CLIENTEDGE to eliminate the control's default border. By contrast, specifying would remove LVS_EX_FULLROWSELECT.\n\nLV0x10: Specify to prevent the user from dragging column headers to the left or right to reorder them. However, it is usually not necessary to do this because the physical reordering of columns does not affect the column order seen by the script. For example, the first column will always be column 1 from the script's point of view, even if the user has physically moved it to the right of other columns.\n\nLV0x20: Specify to require that a row be clicked at its first field to select it (normally, a click on any field will select it). The advantage of this is that it makes it easier for the user to drag a rectangle around a group of rows to select them.\n\nMulti: Specify (minus Multi) to prevent the user from selecting more than one row at a time.\n\nNoSortHdr: Prevents the header from being clickable. It will take on a flat appearance rather than its normal button-like appearance. Unlike most other ListView styles, this one cannot be changed after the ListView is created.\n\nNoSort: Turns off the automatic sorting that occurs when the user clicks a column header. However, the header will still behave visually like a button (unless the NoSortHdr option above has been specified). In addition, the ColClick event is still raised, so the script can respond with a custom sort or other action.\n\nReadOnly: Specify (minus ReadOnly) to allow editing of the text in the first column of each row. To edit a row, select it then press (see the WantF2 option below). Alternatively, you can click a row once to select it, wait at least half a second, then click the same row again to edit it.\n\nR: Rows of height (upon creation). Specify the letter R followed immediately by the number of rows for which to make room inside the control. For example, would make the control 10 rows tall. If the ListView is created with a view mode other than report view, the control is sized to fit rows of icons instead of rows of text. Note: adding icons to a ListView's rows will increase the height of each row, which will make this option inaccurate.\n\nSort: The control is kept alphabetically sorted according to the contents of the first column.\n\nSortDesc: Same as above except in descending order.\n\nWantF2: Specify (minus WantF2) to prevent from editing the currently focused row. This setting is ignored unless -ReadOnly is also in effect.\n\n(Unnamed numeric styles): Since styles other than the above are rarely used, they do not have names. See the ListView styles table for a list.\n\nA ListView has five viewing modes, of which the most common is report view (which is the default). To use one of the other views, specify its name in the options list. The view can also be changed after the control is created; for example: .\n\nIcon: Shows a large-icon view. In this view and all the others except Report, the text in columns other than the first is not visible. To display icons in this mode, the ListView must have a large-icon ImageList assigned to it.\n\nTile: Shows a large-icon view but with ergonomic differences such as displaying each item's text to the right of the icon rather than underneath it. Checkboxes do not function in this view.\n\nList: Shows a small-icon view in list format, which displays the icons in columns. The number of columns depends on the width of the control and the width of the widest text item in it.\n\nReport: Switches back to report view, which is the initial default. For example: .\n\nIn addition to the default methods/properties of a GUI control, ListView controls have the following methods (defined in the Gui.ListView class).\n\nWhen the phrase \"row number\" is used on this page, it refers to a row's current position within the ListView. The top row is 1, the second row is 2, and so on. After a row is added, its row number tends to change due to sorting, deleting, and inserting of other rows. Therefore, to locate specific row(s) based on their contents, it is usually best to use the GetText method in a loop.\n• Add: Adds a new row to the bottom of the list.\n• Insert: Inserts a new row at the specified row number.\n• Delete: Deletes the specified row or all rows.\n• ModifyCol: Modifies the attributes and/or text of the specified column and its header.\n• InsertCol: Inserts a new column at the specified column number.\n• DeleteCol: Deletes the specified column and all of the contents beneath it.\n• GetCount: Returns the number of rows or columns in the control.\n• GetNext: Returns the row number of the next selected, checked, or focused row.\n• GetText: Retrieves the text at the specified row and column number.\n• SetImageList: Sets or replaces an ImageList for displaying icons.\n\nModifies the attributes and/or text of the specified column and its header. If this and the other parameters are all omitted, the width of every column is adjusted to fit the contents of the rows. This has no effect when not in Report (Details) view. Otherwise, specify the number of the column to modify. The first column is 1 (not 0). If omitted, it defaults to Auto (adjusts the column's width to fit its contents). Otherwise, specify one or more options from the list below (not case-sensitive). Separate each option from the next with a space or tab. To remove an option, precede it with a minus sign. To add an option, a plus sign is permitted but not required. N: Specify for N the new width of the column, in pixels. This number can be unquoted if is the only option. For example, the following are both valid: and . Auto: Adjusts the column's width to fit its contents. This has no effect when not in Report (Details) view. AutoHdr: Adjusts the column's width to fit its contents and the column's header text, whichever is wider. If applied to the last column, it will be made at least as wide as all the remaining space in the ListView. It is usually best to apply this setting only after the rows have been added because that allows any newly-arrived vertical scroll bar to be taken into account when sizing the last column. This has no effect when not in Report (Details) view. Icon: Specify the word Icon followed immediately by the number of the ImageList's icon to display next to the column header's text. Specify (minus icon) to remove any existing icon. IconRight: Puts the icon on the right side of the column rather than the left. Float: For sorting purposes, indicates that this column contains floating point numbers (hexadecimal format is not supported). Sorting performance for Float and Text columns is up to 25 times slower than it is for integers. Integer: For sorting purposes, indicates that this column contains integers. To be sorted properly, each integer must be 32-bit; that is, within the range -2147483648 to 2147483647. If any of the values are not integers, they will be considered zero when sorting (unless they start with a number, in which case that number is used). Numbers may appear in either decimal or hexadecimal format (e.g. ). Text: Changes the column back to text-mode sorting, which is the initial default for every column. Only the first 8190 characters of text are significant for sorting purposes (except for the Logical option, in which case the limit is 4094). Center: Centers the text in the column. To center an Integer or Float column, specify the word Center after the word Integer or Float. Left: Left-aligns the column's text, which is the initial default for every column. On older operating systems, the first column might have a forced left-alignment. Right: Right-aligns the column's text. This attribute need not be specified for Integer and Float columns because they are right-aligned by default. That default can be overridden by specifying something such as or . Case: The sorting of the column is case-sensitive (affects only text columns). If the options Case, CaseLocale, and Logical are all omitted, the uppercase letters A-Z are considered identical to their lowercase counterparts for the purpose of the sort. CaseLocale: The sorting of the column is case-insensitive based on the current user's locale (affects only text columns). For example, most English and Western European locales treat the letters A-Z and ANSI letters like Ä and Ü as identical to their lowercase counterparts. This method also uses a \"word sort\", which treats hyphens and apostrophes in such a way that words like \"coop\" and \"co-op\" stay together. Desc: Descending order. The column starts off in descending order the first time the user sorts it. Logical: Same as CaseLocale except that any sequences of digits in the text are treated as true numbers rather than mere characters. For example, the string \"T33\" would be considered greater than \"T4\". Logical and Case are currently mutually exclusive: only the one most recently specified will be in effect. NoSort: Prevents a user's click on this column from having any automatic sorting effect. However, the ColClick event is still raised, so the script can respond with a custom sort or other action. To disable sorting for all columns rather than only a subset, include NoSort in the ListView's options. Sort: Immediately sorts the column in ascending order (even if it has the Desc option). Uni: Unidirectional sort. This prevents a second click on the same column from reversing the sort direction. If omitted, the current header is left unchanged. Otherwise, specify the new header of the column.\n\nThe following events can be detected by calling OnEvent to register a callback function or method:\n\nAdditional (rarely-used) notifications can be detected by using OnNotify. These notifications are documented at Microsoft Docs. Microsoft Docs does not show the numeric value of each notification code; those can be found in the Windows SDK or by searching the Internet.\n\nAn Image-List is a group of identically sized icons stored in memory. Upon creation, each ImageList is empty. The script calls IL_Add repeatedly to add icons to the list, and each icon is assigned a sequential number starting at 1. This is the number to which the script refers to display a particular icon in a row or column header. Here is a working example that demonstrates how to put icons into a ListView's rows:\n\nCreates a new ImageList that is initially empty.\n\nOn success, this function returns the unique ID of the newly created ImageList. On failure, it returns 0.\n\nAdds an icon or picture to the specified ImageList.\n\nOn success, this function returns the new icon's index (1 is the first icon, 2 is the second, and so on). On failure, it returns 0.\n\nOn success, this function returns 1 (true). On failure, it returns 0 (false).\n\nIt is normally not necessary to destroy ImageLists because once attached to a ListView, they are destroyed automatically when the ListView or its parent window is destroyed. However, if the ListView shares ImageLists with other ListViews (by having 0x40 in its options), the script should explicitly destroy the ImageList after destroying all the ListViews that use it. Similarly, if the script replaces one of a ListView's old ImageLists with a new one, it should explicitly destroy the old one.\n\nGui.Submit has no effect on a ListView control.\n\nAfter a column is sorted -- either by means of the user clicking its header or the script calling -- any subsequently added rows will appear at the bottom of the list rather than obeying the sort order. The exception to this is the Sort and SortDesc styles, which move newly added rows into the correct positions.\n\nTo detect when the user has pressed while a ListView has focus, use a default button (which can be hidden if desired). For example:\n\nIn addition to navigating from row to row with the keyboard, the user may also perform incremental search by typing the first few characters of an item in the first column. This causes the selection to jump to the nearest matching row.\n\nAlthough any length of text can be stored in each field of a ListView, only the first 260 characters are displayed.\n\nAlthough the maximum number of rows in a ListView is limited only by available system memory, row-adding performance can be greatly improved as described in the Count option.\n\nA picture may be used as a background around a ListView (that is, to frame the ListView). To do this, create the picture control after the ListView and include 0x4000000 (which is WS_CLIPSIBLINGS) in the picture's Options.\n\nA script may create more than one ListView per window.\n\nIt is best not to insert or delete columns directly with SendMessage. This is because the program maintains a collection of sorting preferences for each column, which would then get out of sync. Instead, use the built-in column methods.\n\nTo perform actions such as resizing, hiding, or changing the font of a ListView, see GuiControl object.\n\nTo extract text from external ListViews (those not owned by the script), use ListViewGetContent.\n\nThe following is a working script that is more elaborate than the one near the top of this page. It displays the files in a folder chosen by the user, with each file assigned the icon associated with its type. The user can double-click a file, or right-click one or more files to display a context menu. ; Create a GUI window: MyGui := Gui(\"+Resize\") ; Allow the user to maximize or drag-resize the window. ; Create some buttons: B1 := MyGui.Add(\"Button\", \"Default\", \"Load a folder\") B2 := MyGui.Add(\"Button\", \"x+20\", \"Clear List\") B3 := MyGui.Add(\"Button\", \"x+20\", \"Switch View\") ; Create the ListView and its columns via Gui.Add: LV := MyGui.Add(\"ListView\", \"xm r20 w700\", [\"Name\", \"In Folder\", \"Size (KB)\", \"Type\"]) LV.ModifyCol(3, \"Integer\") ; For sorting, indicate that the Size column is an integer. ; Create an ImageList so that the ListView can display some icons: ImageListID1 := IL_Create(10) ImageListID2 := IL_Create(10, 10, true) ; A list of large icons to go with the small ones. ; Attach the ImageLists to the ListView so that it can later display the icons: LV.SetImageList(ImageListID1) LV.SetImageList(ImageListID2) ; Apply control events: LV.OnEvent(\"DoubleClick\", RunFile) LV.OnEvent(\"ContextMenu\", ShowContextMenu) B1.OnEvent(\"Click\", LoadFolder) B2.OnEvent(\"Click\", (*) => LV.Delete()) B3.OnEvent(\"Click\", SwitchView) ; Apply window events: MyGui.OnEvent(\"Size\", Gui_Size) ; Create a popup menu to be used as the context menu: ContextMenu := Menu() ContextMenu.Add(\"Open\", ContextOpenOrProperties) ContextMenu.Add(\"Properties\", ContextOpenOrProperties) ContextMenu.Add(\"Clear from ListView\", ContextClearRows) ContextMenu.Default := \"Open\" ; Make \"Open\" a bold font to indicate that double-click does the same thing. ; Display the window: MyGui.Show() LoadFolder(*) { static IconMap := Map() MyGui.Opt(\"+OwnDialogs\") ; Forces user to dismiss the following dialog before using main window. Folder := DirSelect(, 3, \"Select a folder to read:\") if not Folder ; The user canceled the dialog. return ; Check if the last character of the folder name is a backslash, which happens for root ; directories such as C:\\. If it is, remove it to prevent a double-backslash later on. if SubStr(Folder, -1, 1) = \"\\\" Folder := SubStr(Folder, 1, -1) ; Remove the trailing backslash. ; Calculate buffer size required for SHFILEINFO structure. sfi_size := A_PtrSize + 688 sfi := Buffer(sfi_size) ; Gather a list of file names from the selected folder and append them to the ListView: LV.Opt(\"-Redraw\") ; Improve performance by disabling redrawing during load. Loop Files, Folder \"\\*.*\" { FileName := A_LoopFilePath ; Must save it to a writable variable for use below. ; Build a unique extension ID to avoid characters that are illegal in variable names, ; such as dashes. This unique ID method also performs better because finding an item ; in the array does not require search-loop. SplitPath(FileName,,, &FileExt) ; Get the file's extension. if FileExt ~= \"i)\\A(EXE|ICO|ANI|CUR)\\z\" { ExtID := FileExt ; Special ID as a placeholder. IconNumber := 0 ; Flag it as not found so that these types can each have a unique icon. } else ; Some other extension/file-type, so calculate its unique ID. { ExtID := 0 ; Initialize to handle extensions that are shorter than others. Loop 7 ; Limit the extension to 7 characters so that it fits in a 64-bit value. { ExtChar := SubStr(FileExt, A_Index, 1) if not ExtChar ; No more characters. break ; Derive a Unique ID by assigning a different bit position to each character: ExtID := ExtID | (Ord(ExtChar) << (8 * (A_Index - 1))) } ; Check if this file extension already has an icon in the ImageLists. If it does, ; several calls can be avoided and loading performance is greatly improved, ; especially for a folder containing hundreds of files: IconNumber := IconMap.Has(ExtID) ? IconMap[ExtID] : 0 } if not IconNumber ; There is not yet any icon for this extension, so load it. { ; Get the high-quality small-icon associated with this file extension: if not DllCall(\"Shell32\\SHGetFileInfoW\", \"Str\", FileName , \"Uint\", 0, \"Ptr\", sfi, \"UInt\", sfi_size, \"UInt\", 0x101) ; 0x101 is SHGFI_ICON+SHGFI_SMALLICON IconNumber := 9999999 ; Set it out of bounds to display a blank icon. else ; Icon successfully loaded. { ; Extract the hIcon member from the structure: hIcon := NumGet(sfi, 0, \"Ptr\") ; Add the HICON directly to the small-icon and large-icon lists. ; Below uses +1 to convert the returned index from zero-based to one-based: IconNumber := DllCall(\"ImageList_ReplaceIcon\", \"Ptr\", ImageListID1, \"Int\", -1, \"Ptr\", hIcon) + 1 DllCall(\"ImageList_ReplaceIcon\", \"Ptr\", ImageListID2, \"Int\", -1, \"Ptr\", hIcon) ; Now that it's been copied into the ImageLists, the original should be destroyed: DllCall(\"DestroyIcon\", \"Ptr\", hIcon) ; Cache the icon to save memory and improve loading performance: IconMap[ExtID] := IconNumber } } ; Create the new row in the ListView and assign it the icon number determined above: LV.Add(\"Icon\" . IconNumber, A_LoopFileName, A_LoopFileDir, A_LoopFileSizeKB, FileExt) } LV.Opt(\"+Redraw\") ; Re-enable redrawing (it was disabled above). LV.ModifyCol() ; Auto-size each column to fit its contents. LV.ModifyCol(3, 60) ; Make the Size column at little wider to reveal its header. } SwitchView(*) { static IconView := false if not IconView LV.Opt(\"+Icon\") ; Switch to icon view. else LV.Opt(\"+Report\") ; Switch back to details view. IconView := not IconView ; Invert in preparation for next time. } RunFile(LV, RowNumber) { FileName := LV.GetText(RowNumber, 1) ; Get the text of the first field. FileDir := LV.GetText(RowNumber, 2) ; Get the text of the second field. try Run(FileDir \"\\\" FileName) catch MsgBox(\"Could not open \" FileDir \"\\\" FileName \".\") } ShowContextMenu(LV, Item, IsRightClick, X, Y) ; In response to right-click or Apps key. { ; Show the menu at the provided coordinates, X and Y. These should be used ; because they provide correct coordinates even if the user pressed the Apps key: ContextMenu.Show(X, Y) } ContextOpenOrProperties(ItemName, *) ; The user selected \"Open\" or \"Properties\" in the context menu. { ; For simplicitly, operate upon only the focused row rather than all selected rows: FocusedRowNumber := LV.GetNext(0, \"F\") ; Find the focused row. if not FocusedRowNumber ; No row is focused. return FileName := LV.GetText(FocusedRowNumber, 1) ; Get the text of the first field. FileDir := LV.GetText(FocusedRowNumber, 2) ; Get the text of the second field. try { if (ItemName = \"Open\") ; User selected \"Open\" from the context menu. Run(FileDir \"\\\" FileName) else Run(\"properties \" FileDir \"\\\" FileName) } catch MsgBox(\"Could not perform requested action on \" FileDir \"\\\" FileName \".\") } ContextClearRows(*) ; The user selected \"Clear\" in the context menu. { RowNumber := 0 ; This causes the first iteration to start the search at the top. Loop { ; Since deleting a row reduces the RowNumber of all other rows beneath it, ; subtract 1 so that the search includes the same row number that was previously ; found (in case adjacent rows are selected): RowNumber := LV.GetNext(RowNumber - 1) if not RowNumber ; The above returned zero, so there are no more selected rows. break LV.Delete(RowNumber) ; Clear the row from the ListView. } } Gui_Size(thisGui, MinMax, Width, Height) ; Expand/Shrink ListView in response to the user's resizing. { if MinMax = -1 ; The window has been minimized. No action needed. return ; Otherwise, the window has been resized or maximized. Resize the ListView to match. LV.Move(,, Width - 20, Height - 40) }"
    },
    {
        "link": "https://autohotkey.com/boards/viewtopic.php?t=57567",
        "document": "You might want to download AHK Studio ( https://autohotkey.com/boards/viewtopic.php?f=62&t=300 ) and AutoGUI ( https://autohotkey.com/boards/viewtopic ... 64&t=10157 ). With AutoGui, you can design almost whatever GUI that you like.As for code that goes with the GUI to do useful things, study the help file and look for existing GUI code on the forums or using Google search, so you can understand how things are put together. Don't forget to study about InputBox as well, because sometimes when you want something quick and simple, those can work too. Another huge advantage is that both AHK Studio and AutoGUI use the AutoHotkey language, so you can even use them as examples about how to build GUIs by studying their source code. AutoHotkey is probably one of the easiest languages to make GUIs with and to write code for it do something. One more thing, try to build small GUI test programs or get sample source code of such, this way you are more likely to understand and get comfortable with the code."
    },
    {
        "link": "https://autohotkey.com/boards/viewtopic.php?style=19&t=109701",
        "document": "That will let you write what you want into a listview. You would put all your hotkeys and hotstrings just below #Singleinstance Force, then on the ControlSetText Edit one line write whatever you want your hints to look like. it all has to be on that one line though. I used it just to be reminded of something, which is why I have it Exitapp. If you want this to be your main script you should put a Return there instead."
    },
    {
        "link": "https://autohotkey.com/boards/viewtopic.php?t=70779",
        "document": "First off, It's been a while since I was active in this community! I was 14 when I was here last, and I used IRC as well as this forum quite a bit. 7 years later, I've got a lot more experience under my belt.This isn't really a request for support, rather a request for your recommendations. I'd like to know what you would personally feel inclined to do if you wanted to create a custom control in a graphical user interface using AHK.This goes for any control really (such as a button, scrollbar, checkbox, etc.), but specifically I want to know what you would personally do to create a custom ListView (example: Windows Media Player definitely has tweaked its main interface for its specific application).Something else?Thank you for reading and thank you in advance for giving me your recommendations/experiences!"
    }
]