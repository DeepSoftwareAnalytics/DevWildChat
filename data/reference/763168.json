[
    {
        "link": "https://leejjon.medium.com/handling-exceptions-and-error-responses-in-java-rest-services-afda273c9d2f",
        "document": "I often see presentations about best practices to detect bugs early on and prevent them. Obviously preventing is better than fixing. However, things can always go wrong. Even if your code is perfect the following things can happen:\n• The client can do invalid requests\n• The database might have incorrect data\n\nIn this post I will talk about handling errors. Handling errors nicely will inform users that something went wrong and that they should try again or wait until things have been fixed. If the errors are properly logged the developers can investigate and fix the problems faster.\n\nIf you know a bit of Java you’ll probably think of try-catch statements to handle exceptions. It’s important to know that Java has Checked and Unchecked exceptions. You can read more about Java Exceptions in the Oracle docs on Exceptions.\n\nHere is a bit of Java code where I run two methods from the main thread. One can possibly throw a checked SQLException, while the other can throw a UncheckedException (in this code, the chance for it to happen is 50%):\n\nAs you can see the checked exception needs a throws declaration, while the unchecked exception doesn’t. I used to like checked exceptions when I started to learn Java as it gave me information on what could go wrong in my code. While there are situations where this is useful, most Java REST services nowadays only use unchecked exceptions. I hope to make clear why in the next section.\n\nIt’s only useful to catch an Exception in a method if the method can still fulfill its purpose. Let’s say we have a system like the design below:\n\nThe database service tries to execute an SQL query but it fails. This happens a lot in the real world. The query could have a syntax error, or attempt to retrieve data from a table that no longer exists.\n\nWe could put a try catch statement in the database service, but what needs to happen to nicely handle this error? Probably the controller needs to decide to send an HTTP 500 response. The database service is not able to do that, and neither does the business logic. So let’s put the try catch statement in the controller.\n\nHere is how that looks in some simplified example code:\n\nGetting rid of the checked exception\n\nSee how the BusinessLogic class now has a “throws SQLException” declaration on the doBusinessLogic method? It does nothing with this SQLException, it just gets thrown to the controller. Yet it still makes the code depend on the java.sql package.\n\nYour business logic ultimately shouldn’t care if you use a SQL database, NoSQL database or another REST API to fetch the data from. So it’s definitely not nice that this checked SQLException causes the Business logic to know about the java.sql package.\n\nWe can solve this by using the @SneakyThrows annotation from the Lombok library:\n\nWhen the executeQuery method is annotated with @SneakyThrows, it is no longer forced by the compiler to put throws SQLException behind the consuming methods.\n\nLuckily, @SneakyThrows is only needed in very few places. If you use the Spring framework (like 90% of the Java backends use), you will most likely use the JdbcTemplate instead of the original JDBC classes. The JdbcTemplate already catches all SqlExceptions and rethrows them as unchecked exceptions.\n\nThe above examples are not real “controllers”. Here is an example of catching Exceptions in a RestController using Spring:\n\nNow we are catching any exception at the system boundary right? Great! Well this is usually not how Exception handling in Spring works.\n\nSee this this Spring boot example code from Baeldung:\n\nThey have no ResponseEntity objects in the return types, and they don’t have have try catch statements in the controller either. We could add the try catch, but with the return type Book we can’t return a ResponseEntity object with an INTERNAL_ERROR (500) HTTP status.\n\nWe can modify our Spring example to leave out the ResponseEntity class, and throw a ResponseStatusException (available since Spring 5) to make Spring respond with a 500 response:\n\nHowever this still clutters your controller code. Especially if your controller has 10 methods that all have this try catch pattern. Instead we can define a method just for handling Exceptions and annotate it with the @ExceptionHandler annotation.\n\nSuch a method handles exceptions that occur in all GET/POST/PUT (or any other) mappings in the controller. You could even define a global one that applies to all controllers.\n\nMy previous code snippets already gave it away, we should put logging in the Exception handler. I’m using the @Slf4j annotation from Lombok for logging:\n\nIf you now run your project with you should see exceptions in your logs.\n\nWhy logging on the boundaries sometimes isn’t enough…\n\nI know I just talked you into catching and logging the exceptions on the system boundaries. But sometimes to troubleshoot you need more. You might want to log the values of certain query parameters when a database query fails. If we try to log at the system boundary (the controller), we don’t have these parameters anymore! So we must do this in the database service itself.\n\nHere is my DatabaseService.java that uses the JdbcTemplate of the Spring framework. This query will fail in my project simply because there is no “records” table.\n\nWhen running this you’ll see that actually a SQLSyntaxErrorException (extends SQLException and thus is a checked exception) is happening. The spring JDBC wraps it in a BadSqlGrammarException, which is a runtime exception so we don’t have to put @SneakyThrows above the runQuery method.\n\nLet’s alter the code to log the error and the parameter:\n\nBut wait, if you test with this code, the error is logged twice! Once in the DatabaseService and once in the Controller. That is confusing. We can fix that by creating an AlreadyLoggedException class to wrap around the exception.\n\nMake sure to wrap the DataAccessException into this AlreadyLoggedException when rethrowing:\n\nAnd finally add an extra @ExceptionHandler method in the controller to handle all AlreadyLoggedExceptions:\n\nDone, no more duplicate error logging.\n\nTracing back client errors to the correct Exception and Stack trace in the logs\n\nIn all companies I’ve worked for, it was normal to respond with a HTTP 500 status in case of exceptions. But how do you troubleshoot this when such things happen on production? Imagine the following situation:\n\nLet’s say you’re the backend guy. The support desk tells you users are complaining that the button on the frontend gives generic errors.\n\nWhat typically happens is that you’re going to ask one user the moment he got the error. If this user bothers to reply, he might give an inaccurate timestamp. If your log is full different of errors, it might be hard to find out what’s happening.\n\nAt the last few companies I’ve worked I have advocated to generate an ID for every exception and add it to the logs (along with the stacktrace). In the HTTP response, return this ID. That way your frontend can display it to the end user. When the end user complains to your customer service, the customer service can ask for this ID and pass it to the developer. With that ID, the developer can do a simple search in the logs to find the exact log message that caused the user’s problem.\n\nImplementing logging id’s and putting them in the HTTP response\n\nWe can generate a unique identifier (UUID) in Java to make sure we generate something that is hopefully unique within our logs:\n\nLet’s add it to our exception handler method.\n\nTo make this work for the exceptions that are caught on other places in the code such as the DatabaseService, we need to alter our AlreadyLoggedException so it can bring the UUID to the controller.\n\nNow we can update our DatabaseService to pass the UUID to the AlreadyLoggedException.\n\nIf you have to do this on many places, you might want to create a utility method to log the error and generate a UUID in there.\n\nFinally, we can update the AlreadyLoggedException handler in the controller and make it pass the UUID to the HTTP response.\n\nHere is what is looks like when you run the code:\n\nIn my example, I’ve not defined a whole API spec to keep it simple. If you have an API based on an OpenAPI spec, you want to define the JSON of the error responses and include this error UUID.\n\nWhen I wanted to implement passing a UUID back to the frontend at work I noticed that our project already used Sleuth for tracing. Sleuth provides autoconfiguration for distributed tracing. Distributed tracing is way beyond the scope of this article, but it does automatically add an id to every log message in your code. This id is unique for every incoming request.\n\nTo get this behavior, all you need to do is add this dependency to your spring boot application:\n\nYou might also need to add this to your dependencyManagement if you haven’t already:\n\nYou can easily auto wire the Sleuth “tracer” in any Spring component to get the uuid and put it in your HTTP response:\n\nYou could also add a filter to add a header with the trace ID in any response. That way you can track any request, not just the ones that give an error:\n\nWhen you run the application again with you should see the response header being added.\n\nIn the GET request of my examples there is no validation. If you add POST or PUT requests you might need to add it. When we add a POST call to our RestController, we can put the @Valid annotation before the SomePost parameter to make Spring validate it:\n\nWe need to define the SomePost class with some validation annotations to tell Spring how to validate it:\n\nIf we now run our application with and execute a curl command with an invalid e-mail in the request body:\n\nWhen Spring attempts to validate this request it will fail the validation and throw a MethodArgumentNotValidException. Our exception handler logs the stacktrace below and throws a 500:\n\nApart from this stacktrace not being useful as our application is not doing anything wrong, the service should respond with 400 (BAD_REQUEST).\n\nNow the curl command will get a 400 response with the following body:\n• Catch all exceptions at the system boundaries. In a REST service this means the controller.\n• Return the generated UUID to the consumer of your service. If they complain that something doesn’t work, ask for this UUID so you can find to the related exception in your logs.\n• Don’t log validation failures. Provide good API documentation so the consumer of your API can figure out what to do if they get 400’s back from your service.\n\nThe full code can be found on GitHub. There might be a 100 ways to improve this. If you think I might be missing something essential, let me know!"
    },
    {
        "link": "https://stackoverflow.com/questions/76386463/how-to-implement-error-handling-in-java-8-when-dealing-with-different-kind-of-er",
        "document": "This question has been asked many times but I couldn't find a satisfying answer.\n\nI am trying to find a way to handle errors in java 8 without limiting too much the shape of the error.\n\nA generic procedure which retrieves data from different sources and produces a result of type T might look like this:\n\nAll these sources can fail to return a result, so I am trying to find a \"general enough\" solution to handle the possible errors.\n\nTo choose the \"strategy\" I am focusing on three main non-indipendent concerns:\n• how the error is returned to the caller\n• how the error is handled\n• how much freedom I have in the representation of the error\n\nThere are essentially 2 strategies I can think of:\n\nResult object. This is essentially a wrapper object (Result<E,T> or Result<T>) which contains a \"response code\" and, optionally, a value of type T if everything worked fine.\n\nThis solution allows for the error to be returned in a \"procedural\" fashion\n\nor in a \"functional\" one.\n\nThe functional solution is \"conceptually\" cleaner but a lot harder to read and i think it looks a bit out of place in java. The procedural one looks fine but it's a lot more prone to programming error considering that no one forces you to check the result with isOK before calling getValue/getCode.\n\nHere the handling depends directly on how I choose to represent the error/status. The simplest solution would be to use an enum. In that case the caller would handle everything with a switch-case\n\nThis is a bit limiting because enums are not very customizable. If I need different data for different errors, I have to define one class for each error which would not be a problem if it wasn't for the complexity required to handle the cases. The only way to handle errors belonging to different classes I can think of is to use what is essentially a visitor pattern and I would like to avoid it. I am not the only one working on the code and how to use correctly the pattern is something that needs to be learned and I know for a fact no one can be bothered to do it.\n\nA variation on this might be some sort of C-like status:\n\nOr an \"inverted\" version of the same idea:\n\nBut they present the same issues as Result and more.\n\nChecked Exceptions. Here the errors can have whatever shape they want and are easily returned and handled with the famous goto shenanigans.\n\nOn paper this look like the better solution (note that I like the \"errors annotations\" in the method signature even if it's a bit verbose) but there are 2 problems:\n• in java using exception as an \"alternative return\" is considered bad practice (by some an anti-pattern even) because an exception signals an exceptional occurrence and should not be used for \"expected behaviour\".\n\nThis might actually be just a matter of preference. What worries me is:\n• the exceptions are slow. From what I found it seems this is caused by the construction of the stack trace. In order to alleviate this problem I found out that you can make the stacktrace non-writable but this looks very non-standard and I am not even sure it would make that much of a difference.\n\nSo, at the end of all this, my questions are:\n• do you know a better solution to a similar problem which solves some of this issues?\n• Is the checked exceptions with non-writable stacktrace a bad idea?"
    },
    {
        "link": "https://theserverside.com/blog/Coffee-Talk-Java-News-Stories-and-Opinions/Java-Exception-handling-best-practices",
        "document": ""
    },
    {
        "link": "https://stackoverflow.com/questions/32545270/best-practice-for-java-exception-handling",
        "document": "First of all the problem with \"best practice\" advice is that it tends to over-simplify the question and the answer. Then someone (like yourself) comes along and notices that it is contradictory1.\n\nIMO, best practice is to take \"best practice\" advice and people who regularly use that phrase with a healthy level of suspicion. Try to understand the real issues yourself, and reach your own conclusions ... rather than just relying someone else to tell you what is \"best practice\".\n\n1 - Or worse ... they don't notice the contradictions, edge-cases, etc, and blindly follow the so-called \"best practice\". And occasionally, they find themselves in a dark place, because the \"best practice\" recommendation was inappropriate.\n\nSo what's the problem here? It is this statement:\n\nIn fact, it is not normally good coding practice to catch generic exceptions like . But it is the right thing to do in some circumstances. And your example is one where it is appropriate.\n\nWell lets look a case where catching is a bad idea:\n\nWhy is that a bad idea? Because that is going to catch and handle unexpected exceptions; i.e. exceptions that you (the developer) did not think were possible, or that you did not even consider. That's OK ... but then the code logs the exception, and continues running as if nothing happened.\n\nThat's the real problem ... attempting to recover from an unexpected exception.\n\nThe (so-called) \"best practice\" advice to \"never catch generic exceptions\" deals with the issue, but in a crude way that doesn't deal with the edge cases. One of the edge cases is that catching (and logging) a generic exception is OK if you then immediately shut the application down ... like you are doing.\n\nNow contrast that with the (supposedly) good practice version in your question. What is the difference?\n• Your version produces more user friendly / less alarming diagnostics ... up to a point.\n• Your version is significantly more code.\n• Your version is unhelpful to someone trying to diagnose the problem because the stacktraces are not recorded.\n\nAnd the counterpoints to 1 and 2 are:\n• You can spend limitless time honing the \"user friendly\" diagnostics for an application, and still fail to help the kind of user who can't or won't understand ...\n• It also depends on who the typical user is.\n\nAs you can see, this is far more nuanced than \"catching generic exceptions is bad practice\"."
    },
    {
        "link": "https://stackify.com/best-practices-exceptions-java",
        "document": "9 Best Practices to Handle Exceptions in Java\n\nException handling in Java isn’t an easy topic. Beginners find it hard to understand and even experienced developers can spend hours discussing how and which Java exceptions should be thrown or handled.\n\nThat’s why most development teams have their own set of rules on how to use them.\n\nAnd if you’re new to a team, you might be surprised how different these rules can be to the ones you’ve used before.\n\nNevertheless, there are several best practices that are used by most teams. Today’s post is going to show you nine of the most important ones you can use to get started or improve your exception handling.\n\nBefore we dive into that, though, we’ll quickly cover the concept of exceptions itself.\n• What are exceptions and exception handling?\n• Why do we need them?\n\nAfter answering these questions we’ll be ready to talk about the best practices. Of course, if you’d like to skip right to the best practices themselves, you can just click here.\n\nWhat is exception handling? What are exceptions?\n\nBefore diving into our list of exceptions best practices, we need to understand what those things are and what we use them for.\n\nSo, what are exceptions?\n\nIn a nutshell, exceptions are anomalous situations during a program’s execution.\n\nAn exception happens when something goes wrong. Tried to open a file but it doesn’t exist? You’ve got an exception. Attempted to call a method on an object but the variable was null?\n\nExceptions are bad things that weren’t supposed to happen. But since they do happen we need to deal with them. And that “dealing” is what we call exception handling.\n\nException handling is an error-handling mechanism. When something goes wrong, an exception is thrown. If you do nothing, the exception causes your application to crash.\n\nOr you can choose to handle the exception. That is, you acknowledge that the problem happened, prevent the application from crashing, and take the steps necessaries in order to either recover from the error or fail gracefully.\n\nError Handling as It Used to Be\n\nAs you’ve just read, exception handling is an error-handling mechanism, but it’s not the only one.\n\nNowadays, the vast majority of programming languages offer exception handling as a feature, but things weren’t always this way.\n\nHow do languages that don’t have exceptions deal with errors?\n\nOne popular approach is to return error codes. For instance, suppose you have a C function that takes an array of integers and a single integer and then searches and return the index of the first item that matches the specified number.\n\nWhat to do when the item isn’t found in the array? A popular choice would be to return -1.\n\nThis approach has the advantage of keeping the code easy to reason about: there’s no interrupting and jumping around the code. Just good old functions returning values.\n\nOn the other hand, this error-handling strategy encourages the consumer of a function to always check for error values.\n\nThe sheer number of those verifications can make the code polluted. Lots of defensive checks might hide important business logic, making the code less readable and maintainable.\n\nAnother serious disavantage of error codes is their lack of context. You might know that code “-5” means that some file wasn’t found…but which file? An integer can’t easily carry that information.\n\nYet another problem of this approach is the fact that, sometimes, you just can’t return a value (e.g. think of constructors). Something went wrong while initializing an object? With error codes, you’re helpless.\n\nExceptions came about to solve the problems you’ve just read about.\n\nWhen an exception is thrown, the control flow of the program is interrupted. If no one handles the exception, it causes the program to crash.\n\nThe user will see the exception’s message, which they most likely won’t understand. The message might not even be localized to their language.\n\nSo, you’ll want to handle exception (even if it’s just for logging the problem, displaying a more user-friendly error message, and then exiting the application anyways).\n\nTo handle the exception that was thrown, we have to catch it. We do this by using an exception-handling block.\n\nWhen we catch the exception, the program’s flow control is handled to the exception-handling block. There, we can make the necessary arrangement in order to deal with the exception.\n\nStill sounds too abstract? Keep reading. You’ll see practical examples when we get to the specifics of Java exceptions.\n\nConsider the following excerpt of code:\n\nThe code above prints some innocuous messages that only say which line they are.\n\nAfter printing the third line, the code initializes an array with three integers, and pass it as an argument to a private method. The method tries to print the fourth item in the array, which doesn’t exist. This causes the exception to be thrown.\n\nWhen that happens, the program’s execution is stopped and the exception’s message is shown. The fourth and fifth messages are never displayed. Neither is executed the second line in of the method.\n\nThis is the resulting output:\n\nNow, let’s change the example, adding some exception handling:\n\nNow, after running the code, this is the output we get:\n\nThis time, the exception still happens, same as before. The execution of the private method stops immediately—that’s why the line “Fourth element successfully displayed!” isn’t shown.\n\nThe flow control of the program is then handed to the catch block. Inside the catch block, the code just prints a message explaining that the array doesn’t have four items. Then, execution is resumed.\n\nWhat we’ve just covered is just the tip of the iceberg.\n\nWhen it comes to handling exceptions in Java, there’s a lot more to it than our brief introduction.\n\nFortunately, for you, we have another post in which we cover at length the details of how to handle exceptions. Go check that out if you need to learn more!\n\nAnd without further ado, here are the list of best practices we promised you.\n\n1. Clean Up Resources in a Finally Block or Use a Try-With-Resource Statement\n\nIt happens quite often that you use a resource in your try block, like an , which you need to close afterward. A common mistake in these situations is to close the resource at the end of the try block.\n\nThe problem is that this approach seems to work perfectly fine as long as no exception gets thrown. All statements within the try block will get executed, and the resource gets closed.\n\nBut you added the try block for a reason.\n\nYou call one or more methods which might throw an exception, or maybe you throw the exception yourself. That means you might not reach the end of the try block. And as a result, you will not close the resources.\n\nYou should, therefore, put all your clean up code into the finally block or use a try-with-resource statement.\n\nIn contrast to the last few lines of your try block, the finally block gets always executed. That happens either after the successful execution of the try block or after you handled an exception in a catch block. Due to this, you can be sure that you clean up all the opened resources.\n\nAnother option is the try-with-resource statement which I explained in more detail in my introduction to Java exception handling.\n\nYou can use it if your resource implements the interface. That’s what most Java standard resources do.\n\nWhen you open the resource in the clause, it will get automatically closed after the block got executed, or an exception handled.\n\nThe more specific the exception that you throw is, the better. Always keep in mind that a coworker who doesn’t know your code (or maybe you in a few months) may need to call your method and handle the exception.\n\nTherefore make sure to provide them as much information as possible. That makes your API easier to understand.\n\nAnd as a result, the caller of your method will be able to handle the exception better or avoid it with an additional check.\n\nSo, always try to find the class that fits best to your exceptional event, e.g. throw a instead of an . And avoid throwing an unspecific .\n\n3. Document the Exceptions You Specify\n\nWhenever you specify an exception in your method signature, you should also document it in your Javadoc.\n\nThat has the same goal as the previous best practice: Provide the caller as many information as possible so that he can avoid or handle the exception.\n\nSo, make sure to add a declaration to your Javadoc and to describe the situations that can cause the exception.\n\nThe idea behind this best practice is similar to the two previous ones. But this time, you don’t provide the information to the caller of your method.\n\nThe exception’s message gets read by everyone who has to understand what had happened when the exception was reported in the log file or your monitoring tool.\n\nIt should, therefore, describe the problem as precisely as possible and provide the most relevant information to understand the exceptional event.\n\nDon’t get me wrong; you shouldn’t write a paragraph of text. But you should explain the reason for the exception in 1-2 short sentences.\n\nThat helps your operations team to understand the severity of the problem, and it also makes it easier for you to analyze any service incidents.\n\nIf you throw a specific exception, its class name will most likely already describe the kind of error. So, you don’t need to provide a lot of additional information.\n\nA good example for that is the . It gets thrown by the constructor of the class when you provide a in a wrong format.\n\nThe name of the class already tells you the kind of problem. Its message only needs to provide the input string that caused the problem.\n\nIf the name of the exception class isn’t that expressive, you need to provide the required information in the message.\n\n5. Catch the Most Specific Exception First\n\nMost IDEs help you with this best practice. They report an unreachable code block when you try to catch the less specific exception first.\n\nThe problem is that only the first catch block that matches the exception gets executed.\n\nSo, if you catch an first, you will never reach the catch block that should handle the more specific because it’s a subclass of the .\n\nAlways catch the most specific exception class first and add the less specific catch blocks to the end of your list.\n\nYou can see an example of such a try-catch statement in the following code snippet. The first catch block handles all s and the second one all s which are not a .\n\nis the superclass of all exceptions and errors. You can use it in a catch clause, but you should never do it!\n\nIf you use in a catch clause, it will not only catch all exceptions; it will also catch all errors.\n\nErrors are thrown by the JVM to indicate serious problems that are not intended to be handled by an application.\n\nTypical examples for that are the or the . Both are caused by situations that are outside of the control of the application and can’t be handled.\n\nSo, better don’t catch a unless you’re absolutely sure that you’re in an exceptional situation in which you’re able or required to handle an error.\n\nHave you ever analyzed a bug report where only the first part of your use case got executed?\n\nThat’s often caused by an ignored exception. The developer was probably pretty sure that it would never be thrown and added a catch block that doesn’t handle or logs it.\n\nAnd when you find this block, you most likely even find one of the famous “This will never happen” comments:\n\nWell, you might be analyzing a problem in which the impossible happened.\n\nSo, please, never ignore an exception.\n\nYou don’t know how the code will change in the future. Someone might remove the validation that prevented the exceptional event without recognizing that this creates a problem. Or the code that throws the exception gets changed and now throws multiple exceptions of the same class, and the calling code doesn’t prevent all of them.\n\nYou should at least write a log message telling everyone that the unthinkable just had happened and that someone needs to check it.\n\nDon’t log and throw is probably the most often ignored best practice in this list. You can find lots of code snippets and even libraries in which an exception gets caught, logged, and rethrown.\n\nIt might feel intuitive to log an exception when it occurred and then rethrow it so that the caller can handle it appropriately. But it will write multiple error messages for the same exception.\n\nThe additional messages also don’t add any information.\n\nAs explained in best practice #4, the exception message should describe the exceptional event. And the stack trace tells you in which class, method, and line the exception was thrown.\n\nIf you need to add additional information, you should catch the exception and wrap it in a custom one. But make sure to follow best practice number 9.\n\nSo, only catch an exception if you want to handle it. Otherwise, specify it in the method signature and let the caller take care of it.\n\nTry Stackify’s free code profiler, Prefix, to write better code on your workstation. Prefix works with .NET, Java, PHP, Node.js, Ruby, and Python.\n\n9. Wrap the Exception Without Consuming It\n\nIt’s sometimes better to catch a standard exception and to wrap it into a custom one.\n\nA typical example for such an exception is an application or framework specific business exception. That allows you to add additional information and you can also implement a special handling for your exception class.\n\nWhen you do that, make sure to set the original exception as the cause. The class provides specific constructor methods that accept a as a parameter.\n\nOtherwise, you lose the stack trace and message of the original exception which will make it difficult to analyze the exceptional event that caused your exception.\n\nAs you’ve seen, there are lots of different things you should consider when you throw or catch an exception. Most of them have the goal to improve the readability of your code or the usability of your API.\n\nExceptions are most often an error handling mechanism and a communication medium at the same time.\n\nYou should, therefore, make sure to discuss the Java exception handling best practices and rules you want to apply with your coworkers so that everyone understands the general concepts and uses them in the same way.\n\nWhen using Retrace APM with code profiling, you can collect exceptions directly from Java, without any code changes!"
    },
    {
        "link": "https://stackoverflow.com/questions/32567208/best-way-to-verify-string-is-empty-or-null",
        "document": "i am sure this must have been asked before in different ways - as isEmptyOrNull is so common yet people implement it differently. but i have below curious query in terms of best available approach which is good for memory and performance both.\n\n1) Below does not account for all spaces like in case of empty XML tag\n\n2) Below one takes care but trim can eat some performance + memory\n\n3) Combining one and two can save some performance + memory (As Chris suggested in comments)\n\n4) Converted to pattern matcher (invoked only when string is non zero length)\n\n5) Using libraries like - Apache Commons ( ) or Spring ( ) or Guava ( ) or any other option?"
    },
    {
        "link": "https://stackoverflow.com/questions/66552413/java-8-streams-filtering-out-empty-string-from-liststring",
        "document": "Assuming we have 2 test String[], something like:\n\nAnd then we append them to a list like this:\n\nThe goal of what I am trying to do is to find the sum of the dollars paid, in index 2 of each String[] using Java 8 streams. But I can't seem to filter out the String[] containing empty values in each indice. Here is my attempt:\n\nMy attempt to filter it was using\n\nThe error it throws is still:"
    },
    {
        "link": "https://geeksforgeeks.org/check-if-a-value-is-present-in-an-array-in-java",
        "document": "Check if a value is present in an Array in Java\n\nGiven an array, the task is to write a Java program to check whether a specific element is present in this Array or not.\n\nAn array is a data structure that contains a group of elements. Typically these elements are all of the same data type, such as an integer or string. Arrays are commonly used in computer programs to organize data so that a related set of values can be quickly sorted or searched. All the items of the array are stored at contiguous memory locations.\n\nThere are numerous approaches to check whether a specific element is present in this Array or not in Java. These are –\n\nIn Linear Search, the list or array is traversed sequentially, and every element is checked.\n\nComplexity of the above method:\n\nIn Binary Search Method, search a sorted array by repeatedly dividing the search interval in half. Begin with an interval covering the whole array. If the value of the search key is less than the item in the middle of the interval, narrow the interval to the lower half. Otherwise, narrow it to the upper half. Repeatedly check until the value is found or the interval is empty.\n\nIn this example, the Arrays.binarySearch() method is used for Binary Search.\n\nComplexity of the above method:\n\nList contains() method in Java is used for checking if the specified element exists in the given list or not.\n\nwhere object-element to be searched for.\n\nComplexity of the above method:\n\nStream anyMatch(Predicate predicate) returns whether any elements of this stream match the provided predicate. It may not evaluate the predicate on all elements if not necessary for determining the result.\n\nExample 1: Using Stream.of() method to create Stream\n\nComplexity of the above method:\n\nExample 2: Using Arrays.stream() method to create Stream\n\nComplexity of the above method:"
    },
    {
        "link": "https://docs.oracle.com/javaee/7/tutorial/bean-validation002.htm",
        "document": "The Java programming language distinguishes between null and empty strings. An empty string is a string instance of zero length, whereas a null string has no value at all.\n\nAn empty string is represented as . It is a character sequence of zero characters. A null string is represented by . It can be described as the absence of a string instance.\n\nManaged bean elements represented as a JavaServer Faces text component such as are initialized with the value of the empty string by the JavaServer Faces implementation. Validating these strings can be an issue when user input for such fields is not required. Consider the following example, in which the string is a bean variable that will be set using input entered by the user. In this case, the user input for the field is not required.\n\nBy default, the method is called even when the user enters no data, because the element has been initialized with the value of an empty string.\n\nIn order for the Bean Validation model to work as intended, you must set the context parameter to in the web deployment descriptor file, :\n\nThis parameter enables the JavaServer Faces implementation to treat empty strings as null.\n\nSuppose, on the other hand, that you have a constraint on an element, meaning that input is required. In this case, an empty string will pass this validation constraint. However, if you set the context parameter to , the value of the managed bean attribute is passed to the Bean Validation runtime as a null value, causing the constraint to fail."
    },
    {
        "link": "https://picocli.info",
        "document": "Picocli 4.0 introduces a new annotation and its programmatic equivalent. Argument Groups can be used to define:\n• option sections in the usage help message To create a group using the annotations API, annotate a field or method with . The field’s type refers to the class containing the options and positional parameters in the group. (For annotated interface methods this would be the return type, for annotated setter methods in a concrete class this would be the setter’s parameter type.) Picocli will instantiate this class when needed to capture command line argument values in the and -annotated fields and methods of this class. Inherited Options currently cannot be used in Argument Groups. Applications that want to reuse Argument Groups across subcommands need to use Mixins. See this example for sharing an Argument Group defining global options between subcommands. Annotate a field or method with to create a group of mutually exclusive options and positional parameters. For example: The above example defines a command with mutually exclusive options , and . The group itself has a attribute that defines how many times the group may be specified within the command. The default is , meaning that by default a group may be omitted or specified once. In this example the group has , so the group must occur once: one of the exclusive options must occur on the command line. The synopsis of this command is: When one of the options in the group is matched, picocli creates an instance of the class and assigns it to the -annotated field. Note that the options are defined as ; this means required within the group, not required within the command. As of picocli 4.1.2, all options in an exclusive group are automatically considered required, even if they are not marked as in the annotations. Applications using older versions of picocli should mark all options in exclusive groups as required. Picocli will validate the arguments and throw a if multiple mutually exclusive arguments were specified. For example: \"Error: -a=<a>, -b=<b> are mutually exclusive (specify only one)\" \"Error: -a=<a>, -b=<b> are mutually exclusive (specify only one)\" For the above group, only one of the options can be specified. Any other combination of options, or the absence of options, is invalid. Picocli will not initialize the -annotated field if none of the group options is specified on the command line. For optional groups (groups with - the default) this means that the -annotated field may remain . Annotate a field or method with to create a group of dependent options and positional parameters that must co-occur. For example: The above example defines a command with dependent options , and that must co-occur. The group itself has a attribute that defines how many times the group may be specified within the command. In this example the group uses the default multiplicity, , meaning that the group may be omitted or specified once. The synopsis of this command is: When the first option in the group is matched, picocli creates an instance of the class and assigns it to the -annotated field. Note that the options are defined as ; this means required within the group, not required within the command. Picocli will validate the arguments and throw a if not all dependent arguments were specified. For example: Picocli will not initialize the -annotated field if none of the group options is specified on the command line. For optional groups (groups with - the default) this means that the -annotated field may remain . In mutually dependent groups it is possible to have one or more options that are not required. This is different from exclusive groups, where all options are always required. It is useful to be able to define a co-occurring group as so that both and are valid on the command line, but not for example. This can be implemented by marking the optional option with , as in the below example: More than one option can be optional in mutually dependent groups, but it is recommended to have at least one required option in the group (or there is not much point in using a mutually dependent group). The example below uses groups to define options sections in the usage help. When a group has a non-null (or ), the options in the group are given the specified heading in the usage help message. The attribute can be used to get the heading text from the command’s resource bundle. This works for mutually exclusive or co-occurring groups, but it is also possible to define a group that does no validation but only creates an option section in the usage help. Annotate a field or method with to create a group for display purposes only. For example: \"This is the first section%n\" \"This is the second section%n\" \"This is the first section%n\" \"This is the second section%n\" This prints the following usage help message: Usage: sectiondemo [-a=<a>] [-b=<b>] [-c=<c>] [-x=<x>] [-y=<y>] [-z=<z>] Section demo This is the first section -a=<a> Option A -b=<b> Option B -c=<c> Option C This is the second section -x=<x> Option X -y=<y> Option Y -z=<z> Option Z Note that the heading text must end with to insert a newline between the heading text and the first option. This is for consistency with other headings in the usage help, like . Picocli will not initialize the -annotated field if none of the group options is specified on the command line. For optional groups (groups with - the default) this means that the -annotated field may remain . Options that are not in any argument group are always displayed before any group option sections. The ordering of group option sections can be controlled with the attribute. For example: Note that setting means that picocli won’t validate user input for the group. For example, even for groups with , when the end user specifies the group multiple times, no error is shown. If the group is a single-value field, only the last occurrence is stored and previous occurrences are silently dropped. If validation is needed, the recommendation is to make the field holding the group a collection, and doing Custom Validation. For example to ensure that this collection holds only a single element: \"This is the first section%n\" \"Group [-a=<a>] [-b=<b>] [-c=<c>] can be specified at most once.\" The below example shows how groups can be composed of other groups, and how arrays and collections can be used to capture repeating groups (with a greater than one): In the above example, the annotated field defines a composite group that must be specified at least once, and may be specified many times ( ), on the command line. Notice that for multi-value groups the type of the -annotated field must be a collection or an array to capture the multiple instances that hold the values that were matched on the command line. The synopsis of this command is: Each time the group is matched, picocli creates an instance of the class and adds it to the list. The class itself contains two groups: an optional ( ) group of dependent options that must co-occur, and another group of mutually exclusive options, which is mandatory ( ). The below example illustrates: Picocli will not initialize the -annotated field if none of the group options is specified on the command line. For optional groups (groups with - the default) this means that the -annotated field may remain . If the application assigned a non- Collection in the field declaration (e.g., ), then the collection will remain empty if none of the group options is specified on the command line. The default values of options in an argument group are applied when at least one option in the group is matched on the command line and picocli instantiates the user object of the group. Picocli will not initialize the -annotated field (and so no default values are applied) if none of the group options is specified on the command line. Options used in argument groups should define default values via the annotation. When default values are defined in the annotation, the variable can be used to show the default value in the description of options in an argument group. For example: \"usage help shows the default value\" \"usage help shows the default value\" When the default value is defined in the annotation, the usage help shows the correct default value: Usage: good [[-x=<x>]] usage help shows the default value -x=<x> Default: 123 Picocli will not be able to retrieve the default values that are defined by assigning a value in the declaration of an -annotated field in a group. For example: // value not found until `BadGroup` is instantiated \"usage help shows the wrong default value\" // value not found until `BadGroup` is instantiated When the default value is defined in the field declaration and not in the annotation, usage help for the options in the group incorrectly shows as the default value: Usage: bad [[-x=<x>]] usage help shows the wrong default value -x=<x> Default: null Applications need to do extra work for argument group options with default values. Picocli does not instantiate the group if none of the options in the group is specified on the command line, so applications need to do this manually. Below are some recommendations for using default values in argument group options and positional parameters:\n• specify default values in both the annotation, and in the initial value of the -annotated field. Yes, that means some duplication. This recommendation also holds for positional .\n• the application needs to manually instantiate the -annotated field. More details follow below. The default value in the or annotation means that picocli can show the default value in the usage help, and the initial value means that any new instance of the group that contains the option will already have the default value assigned to that option field. The example below shows an option that defines the default value in the annotation as well as in the initial value of the field: // specify default values both in the annotation and in the initial value // specify default values both in the annotation and in the initial value Next, the application needs to manually instantiate the -annotated field. There is a trade-off:\n• instantiating the -annotated field in the declaration is simple and short but applications cannot easily detect whether a group option was specified on the command line or not\n• leaving the -annotated field in the declaration allows applications to easily detect whether a group option was specified on the command line, but is a bit more code The example below shows the first idea: instantiating the group object in the declaration. This way, the group object is never and (if you followed the previous recommendation) all option fields in this group object will have the default value as their initial value. // instantiating the group in the declaration: // all options in this group now also have their initial (default) value // instantiating the group in the declaration: // all options in this group now also have their initial (default) value Alternatively, applications can initialize the group objects in the business logic: in the or method. This allows the application to determine whether the user specified a value for any of the options in the group. The example below demonstrates initializing the group objects in the business logic: // -x option was not specified on command line // perform any logic that needs to happen if -x is missing // neither -a nor -b was specified // perform any logic that needs to happen if -a or -b is missing // -x option was not specified on command line // perform any logic that needs to happen if -x is missing // neither -a nor -b was specified // perform any logic that needs to happen if -a or -b is missing When a positional parameter is part of a group, its is the index within the group, not within the command. Below is an example of an application that uses a repeating group of positional parameters: Running the above program with this input:\n• Options with the same name cannot be defined in multiple groups. Similarly, it is not possible to define an option outside of a group with the same name as a different option that is part of a group.\n• Positional parameters in a single group work fine, but take care (or avoid) defining positional parameters in multiple groups or positional parameters in a group as well as outside a group. Positional parameters are matched by index, and while the index of a group is reset when a new group multiple is encountered, the index of positional parameters outside a group only increases and is never reset.\n• Some relationships between options cannot be expressed with picocli argument groups. In general, picocli argument groups can only express relationship for which you can write a command line synopsis with every option occurring only once. For example, it is not possible to use argument groups to create a relationship with exclusive options , where requires another option : , while at the same time is independent of : . The application may need to do some programmatic validation in such cases.\n\nBy default, all options and subcommands are case sensitive. From picocli 4.3, case sensitivity is configurable. Case sensitivity can be switched off globally, as well as on a per-command basis. To toggle case sensitivity for all commands, use the and methods. Use the and methods to give some commands a different case sensitivity than others. Where possible, picocli will try to prevent ambiguity: when multiple options with the same name are registered in a command, a is thrown. When multiple subcommands with the same name are registered in a command, a is thrown. With case sensitivity switched off, the same principle applies: multiple options whose names differ only in case cannot be registered in a command. Similarly, multiple subcommands cannot be registered when their names differ only in case. When a combination of POSIX options resembles a long option, picocli will prioritize the long option. This is the case regardless of case sensitivity, but be aware that with case sensitivity switched off, the chance of such collisions increases. For example, if a command has POSIX options , , and , and a long option , then, when the user specifies , picocli will recognize it as the long option , not as the POSIX options. See the casesensitivity package in for some examples. Since picocli 4.4, the parser can recognize abbreviated options and subcommands. This needs to be enabled explicitly with and . When abbreviations are enabled, users can specify the initial letter(s) of the first component and optionally of one or more subsequent components of an option or subcommand name. \"Components\" are separated by dash characters or by case, so for example, both and have two components. When case sensitivity is disabled only the dash character can be used to separate components. When the user specifies input that can match multiple options or subcommands, the parser throws a . When applications use the method, an error message and the usage help is displayed to the user. For example, given a command with subcommands and , then ambiguous user input like will show this error message: Error: 'hel' is not unique: it matches 'hello', 'help' When an argument can match both an abbreviated long option and a set of clustered short options, picocli matches the long option. This is the case regardless of abbreviations, but be aware that with abbreviated options enabled, the chance of such collisions increases. // the long option is matched from abbreviated input -AB // the long option is matched from abbreviated input -AB When abbreviated options are enabled, user input will match the long option, but not the and options. When a single-value option is specified multiple times on the command line, the default parser behaviour is to throw an . For example: The following input results in an : Applications can change this by calling with before parsing the input. When overwritten options are allowed, the last specified value takes effect (the above input will set the field to ) and a WARN level message is printed to the console. (See Tracing for how to switch off the warnings.) By default, positional parameters can be mixed with options on the command line, but this is not always desirable. From picocli 2.3, applications can call with to force the parser to treat all values following the first positional parameter as positional parameters. When this flag is set, the first positional parameter effectively serves as an \"end of options\" marker. From picocli 2.3, applications can call with to force the parser to stop interpreting options and positional parameters as soon as it encounters an unmatched argument. When this flag is set, the first unmatched argument and all subsequent command line arguments are added to the unmatched arguments list returned by . By default, an is thrown when a command line argument cannot be assigned to an option or positional parameter. For example: The command has only one annotated field, , and it expects exactly three arguments, so the following input results in an : Applications can change this by calling with before parsing the input. When unmatched arguments are allowed, the above input will be accepted and a WARN level message is printed to the console. (See Tracing for how to switch off the warnings.) The unmatched argument values can be obtained with the method. As of picocli 3.0, fields annotated with will be populated with the unmatched arguments. The field must be of type or . If picocli finds a field annotated with , it automatically sets to so no is thrown when a command line argument cannot be assigned to an option or positional parameter. If no unmatched arguments are found, the value of the field annotated with is unchanged. A special case of unmatched input are arguments that resemble options but don’t match any of the defined options. Picocli determines if a value \"resembles an option\" by comparing its leading characters to the prefix characters of the known options. Negative numbers are not considered to be unknown options, so values like , , , and will not be treated specially for resembling an option name. For example, the value is considered an unknown option when we have a command that only defines options and : The above defines options and , but no option . So what should the parser do when the user gives input like this? One possibility is to silently accept such values as positional parameters, but this is often not desirable. By default, when the value resembles an option, picocli throws an rather than treating it as a positional parameter. Picocli 3.0 introduced the method that can be used to force the parser to treat arguments resembling an option as positional parameters. For example: When is set to , the unknown option is treated as a positional parameter. The next argument is recognized and processed as a known option like you would expect. An alternative is to call with , this will accept and store such values separately as described in Unmatched Input. By default, options accept parameter values that \"resemble\" (but don’t exactly match) an option. Picocli 4.4 introduced a method that makes it possible to configure the parser to reject values that resemble options as option parameters. Setting this to will result in values resembling option names being rejected as option values. By default, a value like , which resembles an option, is accepted as the parameter for : After setting the parser option to , values resembling an option are rejected as parameter for : This will throw an with message: 11.9.1. By Default Options Do Not Consume Option Names or Subcommands Since picocli 4.4, the parser will no longer assign values that match a subcommand name or an option name to options that take a parameter, unless the value is in quotes. For example: In previous versions of picocli, the above command would accept input , and the value would be assigned to the String field. As of picocli 4.4, the above input will be rejected with an error message indicating that the option requires a parameter. If it is necessary to accept values that match option names, such values need to be quoted. For example: This will print the following output: Picocli 4.7.0 introduces two parser configuration options to change this behaviour: When set to , all options in the command (options that take a parameter) can consume values that match option names or subcommand names. This means that any option will consume the maximum number of arguments possible for its arity. If an option is defined as , this option will consume all remaining command line arguments following this option (until the End-of-options delimiter) as parameters of this option. The parser configuration options in the previous section apply to all options in the command. Some applications may want to enable options consuming option names or subcommands for some options, but not for all options in the command. Such applications can replace or augment picocli’s parser by doing custom parameter processing for such options. For example: The above code assigns whatever command line argument that follows the option to that option, and allows input like the following: When a flag option is specified on the command line picocli will set its value to the opposite of its default value. Prior to 4.0, the default was to \"toggle\" boolean flags to the opposite of their current value: if the previous value was it is set to , and when the value was it is set to . Applications can call with to enable toggling. Note that when toggling is enabled, specifying a flag option twice on the command line will have no effect because they cancel each other out. By default, the picocli parser allows POSIX clustered short options, so short options like can be clustered together like . From picocli 3.0, applications can call with to enforce that options must be separated with whitespace on the command line. (This also means that option parameters must be separated from the option name by whitespace or the separator character, so and will be recognized but will not.) From picocli 3.2, the parser can be configured to continue parsing invalid input to the end. When is set to , and a problem occurs during parsing, an is added to the list returned by and parsing continues. The default behaviour (when is ) is to abort parsing by throwing the . This is useful when generating completion candidates on partial input, and is also useful when using picocli in languages like Clojure where idiomatic error handling does not involve throwing and catching exceptions. When using this feature, applications are responsible for actively verifying that no errors occurred before executing the business logic. Use with care! From picocli 3.7, quotes around command line parameters are preserved by default (previously they were removed). This can be configured with , or the parser configuration . From picocli 4.0, quoted arguments can contain nested quoted substrings, to give end users fine-grained control over how values are split. If , or the parser configuration is set to , picocli will remove quotes from the command line arguments, as follows:\n• As each command line argument is processed, the below smart unquote procedure is used to trim the outermost quotes.\n• Next, if the option or positional parameter has a regex defined, the parameter value is split while respecting quotes: the regex is not matched if it occurs in a quoted substring of the parameter value. Each of the parts found by the splitting process will have its quotes removed using the below \"smart unquote\" procedure. See the Splitting Quoted Parameters section below for examples.\n• If the command line argument contains just the leading and trailing quote, these quotes are removed.\n• If the command line argument contains unescaped quotes, other than the leading and trailing quote, the argument is unchanged (the leading and trailing quotes remain).\n• If a quoted command line argument contains backslash-escaped quotes, the leading and trailing quotes are removed, backslash-escaped quotes are converted to unescaped quotes, and backslash-escaped backslashes are converted to unescaped backslashes. By default, if the option or positional parameter has a regex defined, parameter values are split into parts while respecting quotes: the regular expression is not matched inside a quoted region. This results in the array having the following values, assuming the parser configuration is (the default): If the parser configuration is , the above example would be split into the following values (with quotes trimmed from the resulting parts): This results in the array having the following values: Or, if the parser configuration is : To preserve quotes when is , specify additional nested quotes on the command line. For example: With parser configuration set to , the above input gives the following values: This \"smart splitting\" (respecting quotes) can be switched off with : setting the parser attribute to switches off smart splitting, and the regex is applied to the parameter value regardless of quotes. is mostly for backwards compatibility, for applications that want the pre-3.7 behaviour of simply splitting regardless of quotes. Most applications should leave this setting to the default ( ). When this setting is , the above input is parsed as: Negatable options can be customized via the interface: /** * Returns the negative form of the specified option name for the parser to recognize * when parsing command line arguments. * @param optionName the option name to create a negative form for, * for example {@code --force} * @param cmd the command that the option is part of * @return the negative form of the specified option name, for example {@code --no-force} */ /** * Returns the documentation string to show in the synopsis and usage help message for * the specified option. The returned value should be concise and clearly suggest that * both the positive and the negative form are valid option names. * @param optionName the option name to create a documentation string for, * for example {@code --force}, or {@code -XX:+<option>} * @param cmd the command that the option is part of * @return the documentation string for the negatable option, * for example {@code --[no-]force}, or {@code -XX:(+|-)<option>} */ This allows you to control:\n• which option names should have a negative form\n• the negative form recognized by the parser while parsing the command line\n• the documentation string showing both the positive and the negative form in the usage help message By default, a set of regular expressions is used to control the above. Use to replace the with a custom version. See the JavaDoc for details. As of version 4.6, picocli offers two different parser plugins for custom parameter processing: while the is a powerful and flexible tool, the serves as a simpler alternative. Options or positional parameters can be assigned an that implements custom logic to process the parameters for this option or this position. When an option or positional parameter with a custom is matched on the command line, picocli’s internal parser is temporarily suspended, and the custom parameter consumer becomes responsible for consuming and processing as many command line arguments as needed. This can be useful when passing options through to another command. For example, the unix command has a option to execute some action for each file found. Any arguments following the option until a or argument are not options for the command itself, but are interpreted as a separate command and its options. The example below demonstrates how to implement using this API: Make sure any nested classes are , or picocli will not be able to instantiate them. Introduced in picocli 4.6, the is also a parser plugin, similar to , but more flexible. Options, positional parameters and commands can be assigned an that implements custom logic to preprocess the parameters for this option, position or command. When an option, positional parameter or command with a custom is matched on the command line, picocli’s internal parser is temporarily suspended, and this custom logic is invoked. This custom logic may completely replace picocli’s internal parsing for this option, positional parameter or command, or augment it by doing some preprocessing before picocli’s internal parsing is resumed for this option, positional parameter or command. The \"preprocessing\" actions can include modifying the stack of command line parameters, or modifying the model. This may be useful when disambiguating input for commands that have both a positional parameter and an option with an optional parameter. For example, suppose we have a command with the following synopsis: One of the limitations of options with an optional parameter is that they are difficult to combine with positional parameters. With a custom parser plugin, we can customize the parser, such that in is interpreted as the option parameter, and in (without the separator), VALUE is interpreted as the positional parameter. The code below demonstrates this: \"Optionally specify the editor to use (${COMPLETION-CANDIDATES}). \" \"If omitted the default editor is used. \" \" edit --open FILE opens the specified file in the default editor\" // we need to decide whether the next arg is the file to edit // or the name of the editor to use... // parameter was not attached to option // act as if the user specified --open=defaultEditor // picocli's internal parsing is resumed for this option \"Optionally specify the editor to use (\\${COMPLETION-CANDIDATES}). \" \"If omitted the default editor is used. \" \" opens the specified file in the default editor\" // we need to decide whether the next arg is the file to edit // or the name of the editor to use ... // parameter was not attached to option // act as if the user specified --open=defaultEditor // picocli's internal parsing is resumed for this option Make sure any nested classes are , or picocli will not be able to instantiate them. With this preprocessor in place the user can now specify his editor of choice (e.g. ). If no editor is given, the default editor is used: Either augment (return ) or replace (return ) picocli parsing logic for the matched element. Commands as well as options and positional parameters. Yes, information may be received via the map Yes, via modifying the map\n\nA default picocli usage help message looks like this: Usage: cat [-AbeEnstTuv] [--help] [--version] [FILE...] Concatenate FILE(s), or standard input, to standard output. FILE Files whose contents to display -A, --show-all equivalent to -vET -b, --number-nonblank number nonempty output lines, overrides -n -e equivalent to -vE -E, --show-ends display $ at end of each line -n, --number number all output lines -s, --squeeze-blank suppress repeated empty output lines -t equivalent to -vT -T, --show-tabs display TAB characters as ^I -u (ignored) -v, --show-nonprinting use ^ and M- notation, except for LFD and TAB --help display this help and exit --version output version information and exit Copyright(c) 2017 The usage help message is generated from annotation attributes, like below: \"display this help and exit\" \"display this help and exit\" In the above example, the program name is taken from the attribute of the annotation: Without a attribute, picocli will show a generic in the synopsis: Non-boolean options require a value. The usage help should explain this, and picocli shows the option parameter in the synopsis and in the option list. By default, the field name is shown in and fish brackets. Use the attribute to display a different name. For example: Some annotated fields in the below example class have a attribute and others don’t: For demonstration purposes the above example mixes the all-uppercase (e.g., ) style label and the fish bracket (e.g., ) style labels. For real applications, mixing these label styles should be avoided. An application should consistently use only one style. By default, the options list in the usage help message displays options in alphabetical order. Use the attribute to display options in the order they are declared in your class. Sorting on declaration order is done on a best effort basis, see the Reordering Options section below. Note that picocli cannot reliably detect declaration order in commands that have both -annotated methods and -annotated fields. The attribute can be used to explicitly control the position in the usage help message at which the option should be shown. Options with a lower number are shown before options with a higher number. By default, the synopsis of the usage help message displays options in alphabetical order. Picocli 4.7.0 introduced a attribute to let the synopsis display options in the order they are declared in your class, or sorted by their attribute. Regardless of the sorting strategy, boolean short options are shown first as a single clustered group in the synopsis, followed by options that take parameters, unless the parser is configured to disallow clustered boolean short options. Required options can be marked in the option list by the character specified with the attribute. By default options are not marked because the synopsis shows users which options are required and which are optional. This feature may be useful in combination with the attribute. For example: Produces the following usage help message: The default layout shows short options and long options in separate columns, followed by the description column. Only POSIX short options are shown in the first column, that is, options that start with a single dash and are one character long. Options with two characters are not considered short options and are shown in the long option column. This is a common layout for Unix utilities, and can enhance usability: applications can give a subtle hint to end users that an option is common and encouraged by providing both a short and a long name for the option. Conversely, the absence of a short option can signal that the option is unusual or perhaps should be used with care. It is possible to left-align all options by using a custom layout. See LeftAlignOptions.java in the module for an example. The default layout shows short options and long options in separate columns, followed by the description column. The width of the long options column shrinks automatically if all long options are very short, but by default this column does not grow larger than 20 characters. If the long option with its option parameter is longer than 20 characters (for example: ), the long option overflows into the description column, and the option description is shown on the next line. This (the default) looks like this: Usage: myapp [-hV] [-o=<outputFolder>] -h, --help Show this help message and exit. -o, --output=<outputFolder> Output location full path. -V, --version Print version information and exit. As of picocli 4.2, there is programmatic API to change this via the and methods. In the above example, if we call before printing the usage help, we get this result: Usage: myapp [-hV] [-o=<outputFolder>] -h, --help Show this help message and exit. -o, --output=<outputFolder> Output location full path. -V, --version Print version information and exit. The minimum value that can be specified for is 20, the maximum value is the usage width minus 20. The default width of the usage help message is 80 characters. Commands defined with in the annotations will use the specified width. Picocli 3.0 also introduced programmatic API for this via the and methods. End users can use the system property to specify a custom width that overrides the programmatically set value. The minimum width that can be configured is 55 characters. As of picocli 4.0, commands defined with will try to adjust the usage message help layout to the terminal width. There is also programmatic API to control this via the and methods. End users may enable this by setting the system property to , and may disable this by setting this system property to a numeric value. Options and parameters may have a attribute to split each parameter into smaller substrings. Regular expressions may contain literal text, but may also contain special characters. The regular expression in the attribute may be quite different from what end users need to type. The example below uses the plus ( ) character as a separator. The regular expression in the attribute uses backslash ( ) characters to make sure that the plus character is treated as a literal. However, end users can type simply (using the plus character separator), not . We want the usage help message to show this. The attribute, introduced in picocli 4.3, controls what is shown in the synopsis of the usage help message. With the example above, the synopsis of the usage help looks like this: If a command is very complex and has many options, it is sometimes desirable to suppress details from the synopsis with the attribute. For example: Note that the positional parameters are not abbreviated. For even more control of the synopsis, use the attribute to specify one or more synopsis lines. For example: Usage: ln [OPTION]... [-T] TARGET LINK_NAME (1st form) or: ln [OPTION]... TARGET (2nd form) or: ln [OPTION]... TARGET... DIRECTORY (3rd form) or: ln [OPTION]... -t DIRECTORY TARGET... (4th form) To produce a synopsis like the above, specify the literal text in the attribute: \"\"\" Usage: ln [OPTION]... [-T] TARGET LINK_NAME (1st form) or: ln [OPTION]... TARGET (2nd form) or: ln [OPTION]... TARGET... DIRECTORY (3rd form) or: ln [OPTION]... -t DIRECTORY TARGET... (4th form)\"\"\" For commands with subcommands, the string is appended to the end of the synopsis (whether the synopsis is abbreviated or not). This looks something like this: As of picocli 4.0, this can be customized with the attribute. For example, to clarify that a subcommand is mandatory, an application may specify , without the and brackets: An application with a limited number of subcommands may want to show them all in the synopsis, for example: This will show the following synopsis: The will be shown at the top of the usage help message (before the synopsis). The first header line is also the line shown in the subcommand list if your command has subcommands (see Usage Help for Subcommands). Use the attribute to specify one or more lines to show below the generated usage help message. Each element of the attribute array is displayed on a separate line. By default, the usage help message does not display exit code information. Applications that call need to configure the and annotation attributes. For example: \"64:Usage error: user input for the command was incorrect, \" \"the business logic of this command.\" \"64:Usage error: user input for the command was incorrect,\" \"the business logic of this command.\" This will print the following usage help message to the console: Usage: <main class> Exit Codes: 0 Successful program execution 64 Usage error: user input for the command was incorrect, e.g., the wrong number of arguments, a bad flag, a bad syntax in a parameter, etc. 70 Internal software error: an exception occurred when invoking the business logic of this command. All usage help message elements can have embedded line separator ( ) format specifiers. These are converted to the platform-specific line separator when the usage help message is printed. Version help may have format specifiers that format additional arguments passed to the method. See the java.util.Formatter JavaDoc for details. Note that to show percent characters in the usage help message, they need to be escaped with another . For example: is rendered as . An alternative way to control the layout of the usage help message is that some sections ( , , and ) can be specified as an array of Strings, where each element of the array is displayed on a separate line in the usage help message. Section headers can be used to make usage message layout appear more spacious. The example below demonstrates the use of embedded line separator ( ) format specifiers: \"Record changes to the repository.\" \"Stores the current contents of the index in a new commit \" \"along with a log message from the user describing the changes.\" \"Record changes to the repository.\" \"Stores the current contents of the index in a new commit \" \"along with a log message from the user describing the changes.\" The usage help message generated from this class is shown below in Expanded Example. The below example demonstrates what a customized usage message can look like. Note how section headings with line separators can create a more spacious usage message, and also that options are listed in declaration order (instead of in alphabetic order). Usage: Record changes to the repository. git commit [-ap] [--fixup=<commit>] [--squash=<commit>] [-c=<commit>] [-C=<commit>] [-F=<file>] [-m[=<msg>...]] [<files>...] Description: Stores the current contents of the index in a new commit along with a log message from the user describing the changes. Parameters: <files> the files to commit Options: -a, --all Tell the command to automatically stage files that have been modified and deleted, but new files you have not told Git about are not affected. -p, --patch Use the interactive patch selection interface to chose which changes to commit -C, --reuse-message=<commit> Take an existing commit object, and reuse the log message and the authorship information (including the timestamp) when creating the commit. -c, --reedit-message=<commit> Like -C, but with -c the editor is invoked, so that the user can further edit the commit message. --fixup=<commit> Construct a commit message for use with rebase --autosquash. --squash=<commit> Construct a commit message for use with rebase --autosquash. The commit message subject line is taken from the specified commit with a prefix of \"squash! \". Can be used with additional commit message options (-m/-c/-C/-F). -F, --file=<file> Take the commit message from the given file. Use - to read the message from the standard input. -m, --message[=<msg>...] Use the given <msg> as the commit message. If multiple -m options are given, their values are concatenated as separate paragraphs. The annotated class that this usage help message is generated from is shown in Section Headings. The separator displayed between options and option parameters ( by default) in the synopsis and the option list can be configured with the attribute. The annotation also affects how picocli parses the command line. See also Custom Separators. Options and Parameters with the attribute set to will not be shown in the usage help message. This is useful for example when a parameter at some index is captured into multiple fields: by default each of these fields would be shown in the usage message, which would be confusing for users. For example, the field below is annotated as : The above will generate the following usage help message, where the field is not shown: As of picocli 4.2, an entry for can be shown in the options and parameters list of the usage help message of a command with the annotation. The usage help message for this command looks like this: Usage: myapp [-hV] [@<filename>...] <file> Example command. [@<filename>...] One or more argument files containing options. <file> A file. -h, --help Show this help message and exit. -V, --version Print version information and exit. By default, the entry is shown before the positional parameters in the synopsis as well as in the parameters list. This can be changed with the Help API for reordering sections. For example: The resulting usage help message shows the entry has moved to the bottom, following the options list: Usage: myapp [-hV] [@<filename>...] <file> Example command. <file> A file. -h, --help Show this help message and exit. -V, --version Print version information and exit. [@<filename>...] One or more argument files containing options. Both the label and the description of the entry have been defined with custom variables, to allow applications to change the text. The variables are: By setting the above variables in either system properties, environment variables or the resource bundle for a command, the text can be customized. For example, if we define these system properties: then the usage help for our above example changes to this: Usage: myapp [-hV] [my@@@@file...] <file> Example command. [my@@@@file...] @files rock! <file> A file. -h, --help Show this help message and exit. -V, --version Print version information and exit. The description of the entry can also be specified in a resource bundle for internationalization and localization. The for the entry in resource bundles is: As of picocli 4.3, an entry for the End of Options delimiter can be shown in the options list of the usage help message of a command with the annotation. The usage help message for this command looks like this: Usage: myapp [-hV] [--] <file> Example command. <file> A file. -h, --help Show this help message and exit. -V, --version Print version information and exit. -- This option can be used to separate command-line options from the list of positional parameters. By default, the End of Options entry is shown between the options and the positional parameters in the synopsis, and at the end of the options list. This can be changed with the Help API for reordering sections. For example: The resulting usage help message shows the End of Options entry has moved up, to the beginning the options list: Usage: myapp [-hV] [--] <file> Example command. <file> A file. -- This option can be used to separate command-line options from the list of positional parameters. -h, --help Show this help message and exit. -V, --version Print version information and exit. The description of the End of Options delimiter entry has been defined with a custom variable, to allow applications to change the text. The variable is: By setting the above variable in either system properties, environment variables or the resource bundle for a command, the text can be customized. For example, if we define this system property: then the usage help for our above example changes to this: Usage: myapp [-hV] [--] <file> Example command. <file> A file. -h, --help Show this help message and exit. -V, --version Print version information and exit. -- End of options. Remainder are positional parameters. The description of the End of Options delimiter entry can also be specified in a resource bundle for internationalization and localization. The for the End of Options delimiter entry in resource bundles is: From picocli 3.2, it is possible to embed the default values in the description for an option or positional parameter by specifying the variable in the description text. Picocli uses reflection to get the default values from the annotated fields. The variable is replaced with the default value regardless of the attribute and regardless of the or attribute. \"the file to use (default: ${DEFAULT-VALUE})\" \"the file to use (default: \\${DEFAULT-VALUE})\" This produces the following usage help: Usage: <main class> [-f=<file>] -f, --file=<file> the file to use (default: config.xml) Similarly, it is possible to embed the completion candidates in the description for an option or positional parameter by specifying the variable in the description text. This works for java classes and for options or positional parameters of non-enum types for which completion candidates are specified. This produces the following usage help: Prior to picocli 3.2, you need to use the attribute to append the default value of all non- options and positional parameters to the description column. Additionally, picocli 3.0 introduced a attribute to the and annotation. This allows you to specify for each individual option and positional parameter whether its default value should be shown in the usage help. This attribute accepts three values:\n• - always display the default value of this option or positional parameter, even values, regardless what value of was specified on the command\n• - don’t show the default value for this option or positional parameter, regardless what value of was specified on the command\n• - (this is the default) only show the default value for this option or positional parameter if was specified on the command These legacy mechanisms still work but for maximum flexibility use the variables explained above.\n\nSophisticated command-line tools, like the prominent tool, have many subcommands (e.g., , , …), each with its own set of options and positional parameters. Picocli makes it very easy to have commands with subcommands, and sub-subcommands, to any level of depth. If you want to jump ahead and see some examples first, these resources may be helpful:\n• The Executing Subcommands section below has an example that uses both the syntax and the -annotated method syntax.\n• The Quick Guide has an example application featuring subcommands, with a detailed explanation.\n• The code module has a subcommand section with several minimal code samples, explaining the use of subcommands both via methods and when defined in their own class.\n• The code module also shows subcommand examples in other languages, like Scala and Kotlin, as well as Java. Subcommands can be registered declaratively with the annotation’s attribute since picocli 0.9.8. This is the recommended way when you want to use the picocli annotation processor to generate documentation, autocompletion scripts or GraalVM configuration files. Subcommands referenced in a attribute must have a annotation with a attribute, or an exception is thrown from the constructor. This name will be used both for generating usage help and for recognizing subcommands when parsing the command line. Command names are case-sensitive by default, but this is customizable. Custom type converters registered on a instance will apply to all subcommands that were declared on the main command with the annotation. Subcommands referenced in a attribute need to have a public no-argument constructor to be instantiated, unless a Custom Factory is installed to instantiate classes. Prior to picocli 4.2, the declared subcommands were instantiated immediately when the top-level (the object in the above example) was constructed. From picocli 4.2, the declared subcommands are not instantiated until they are matched on the command line, unless they have a or -annotated field; these are injected during initialization, and in order to inject them the subcommand is instantiated during initialization. As of picocli 3.6 it is possible to register subcommands in a very compact manner by having a class with -annotated methods. The methods are automatically registered as subcommands of the enclosing class. See the command methods section for more details and examples. The module has an minimal example application, demonstrating the definition of subcommands via methods. This example was coded in Java, Kotlin and Scala. Subcommands can be registered with the method. You pass in the name of the command and the annotated object to populate with the subcommand options. The specified name is used by the parser to recognize subcommands in the command line arguments. It is strongly recommended that subcommands have a annotation with and attributes. From picocli 3.1, the usage help synopsis of the subcommand shows not only the subcommand name but also the parent command name. For example, if the command has a subcommand, the usage help for the subcommand shows . Note on custom type converters: custom type converters are registered only with the subcommands and nested sub-subcommands that were added before the custom type was registered. To ensure a custom type converter is available to all subcommands, register the type converter last, after adding subcommands. The easiest way to design an application with subcommands is to let each command and subcommand either be a class that implements or , or a -annotated method. This will allow you to parse the command line, deal with requests for help and requests for version information, deal with invalid user input, and invoke the business logic of the user-specified subcommand - all of that - in one line of code: the method. To test our example on Linux, we created an alias that invokes our Java application. This could also be a script or a function that calls our Java program: Next, we call our top-level command with an option like this: We can also specify a subcommand: And finally, we can also specify a sub-subcommand: As you can see, the last specified command or subcommand is executed and its exit code is returned. See also Executing Commands with Subcommands for details on configuring this. Sometimes an application needs to take some action before execution. With a single command, you can simply do this in the beginning of the or method, but in an application with subcommands you don’t want to repeat this code in every subcommand. One idea is to put the shared initialization logic in a custom execution strategy. For example: // A reference to this method can be used as a custom execution strategy // that first calls the init() method, // and then delegates to the default execution strategy. // custom initialization to be done before executing any command or subcommand // A reference to this method can be used as a custom execution strategy // that first calls the init() method, // and then delegates to the default execution strategy. // custom initialization to be done before executing any command or subcommand // A reference to this method can be used as a custom execution strategy // that first calls the init() method, // and then delegates to the default execution strategy. // custom initialization to be done before executing any command or subcommand // A reference to this method can be used as a custom execution strategy // that first calls the init() method, // and then delegates to the default execution strategy. // custom initialization to be done before executing any command or subcommand This ensures the method is called after the command line is parsed (so all options and positional parameters are assigned) but before the user-specified subcommand is executed. The logging example in shows how this can be used to configure the Log4j log level based on a option, prior to execution. In command line applications with subcommands, options of the top level command are often intended as \"global\" options that apply to all the subcommands. Prior to picocli 2.2, subcommands had no easy way to access their parent command options unless the parent command made these values available in a global variable. The annotation introduced in picocli 2.2 makes it easy for subcommands to access their parent command options: subcommand fields annotated with are initialized with a reference to the parent command. For example: \"this option applies to all subcommands\" \"this option applies to all subcommands\" \"this option applies to all subcommands\" \"this option applies to all subcommands\" The above top-level command has a option that applies to its subcommands. The subcommand can use the annotation to get a reference to the parent command, so it can easily access the parent command options. Commands may optionally define an attribute to provide alternate names that will be recognized by the parser. Aliases are displayed in the default help output. For example: Would result in this help fragment: Picocli 4.6 adds support for inheriting attributes with the annotation. Commands with this scope have their attributes copied to all subcommands (and sub-subcommands, to any level of depth). When a subcommand specifies an explicit value in its annotation, this value is used instead of the inherited value. For example: \"(c) Copyright by the authors\" \"(c) Copyright by the authors\" The command in the above example has , so its properties are inherited by the subcommand. The subcommand defines its own and , so these are not inherited from the parent command. The help message for the subcommand looks like this: Subcommand header Usage: app sub [-hV] [-y=<arg0>] [@<filename>...] Subcommand description [@<filename>...] One or more argument files containing options. -h, --help Show this help message and exit. -V, --version Print version information and exit. -y=<arg0> Copyright (c) Copyright by the authors Note that the subcommand has inherited the mixed-in standard help options ( and ), the usage help, and the footer and footer heading. It also inherited the version string, shown when the user invokes . When a command has , the following attributes are copied to its subcommands:\n• all usage help attributes: description, descriptionHeading, header, headerHeading, footer, footerHeading, customSynopsis, synopsisHeading, synopsisSubcommandLabel, abbreviateSynopsis, optionListHeading, parameterListHeading, commandListHeading, exitCodeList, exitCodeListHeading, requiredOptionMarker, showDefaultValues, sortOptions, autoWidth, width, showAtFileInUsageHelp, showEndOfOptionsDelimiterInUsageHelp, and hidden\n• the help and version options mixed in by\n• whether this command is a Attributes that are not copied include:\n• options and parameters (other than the help and version options mixed in by ) Picocli 4.3 adds support for \"inherited\" options. Options defined with are shared with all subcommands (and sub-subcommands, to any level of depth). Applications can define an inherited option on the top-level command, in one place, to allow end users to specify this option anywhere: not only on the top-level command, but also on any of the subcommands and nested sub-subcommands. Inherited options currently cannot be used in Argument Groups. Applications that want to reuse Argument Groups across subcommands need to use Mixins. See this example for sharing an Argument Group defining global options between subcommands. Below is an example where an inherited option is used to configure logging. // option is not shared: this is the default // (This is a simplistic example: a real application may use more levels and // perhaps configure only the ConsoleAppender level instead of the root log level.) // option is not shared by default // (This is a simplistic example: a real application may use more levels and // perhaps configure only the ConsoleAppender level instead of the root log level.) Users can specify the option on either the top-level command or on the subcommand, and it will have the same effect. # the -v option can be specified on the top-level command java App -x=3 -v sub -y=4 Specifying the option on the subcommand will have the same effect. For example: # specifying the -v option on the subcommand also changes the log level java App -x=3 sub -y=4 -v Subcommands don’t need to do anything to receive inherited options, but a potential drawback is that subcommands do not get a reference to inherited options. Subcommands that need to inspect the value of an inherited option can use the annotation to get a reference to their parent command, and access the inherited option via the parent reference. Alternatively, for such subcommands, sharing options via mixins may be a more suitable mechanism. For the following example, we assume we created an alias that invokes our Java application. This could also be a script or a function that calls our Java program: Next, we call our command with some arguments like this: Where (actually ) is the top-level command, followed by a global option and a subcommand with its own options. Setting up the parser and parsing the command line could look like this: // add subcommands programmatically (not necessary if the parent command // Invoke the parseArgs method to parse the arguments // add subcommands programmatically (not necessary if the parent command // Invoke the parseArgs method to parse the arguments The method returns a that can be queried to get information about the top-level command (the Java class invoked by in this example). The method returns a nested if the parser found a subcommand. This can be recursively queried until the last nested subcommand was found and the method returns . \"at least 1 command and 1 subcommand found\" \"at least 1 command and 1 subcommand found\" You may be interested in the execute method to reduce error handling and other boilerplate code in your application. See also the section, Executing Subcommands. When registering subcommands declaratively, subcommands can be nested by specifying the attribute on subcommand classes: When registering subcommands programmatically, the object passed to the method can be an annotated object or a instance with its own nested subcommands. For example: By default, the usage help message only shows the subcommands of the specified command, and not the nested sub-subcommands. This can be customized by specifying your own for the command list section. The module has an example that shows how to accomplish this. To get usage help for nested subcommands, either set in all commands in the hierarchy, and/or add to the subcommands of all commands. Then you can get help message for a nested (sub-)subcommand like this: From picocli 4.2, it is possible to specify that a command’s subcommands can be specified multiple times by marking it with . Below is an example where the top-level command is marked as . This command has three subcommands, , and : The above example command allows users to specify one or more of its subcommands multiple time. For example, this would be a valid invocation: In the above command line invocation, the top-level command is followed by its subcommand . Next, this is followed by another two occurrences of , followed by and . These are all \"sibling\" commands, that share the same parent command . This invocation is valid because is marked with . Normally, is , so for each command, only one of its subcommands can be specified, potentially followed by only one sub-subcommand of that subcommand, etc. In mathematical terms, a valid sequence of commands and subcommands can be represented by a directed rooted tree that starts at the top-level command. This is illustrated by the diagram below. Figure 1. By default, valid sequences of commands and subcommands form a directed rooted tree. When is set to on a command, the subcommands of this command may appear multiple times. Also, a subcommand can be followed by a \"sibling\" command (another command with the same parent command). In mathematical terms, when a parent command has this property, the additional valid sequences of its subcommands form a fully connected subgraph (a complete digraph). The blue and green dotted arrows in the diagram below illustrate the additional sequences that are allowed when a command has repeatable subcommands. Figure 2. If a command is marked to allow repeatable subcommands, the additional valid sequences of its subcommands form a fully connected subgraph. Note that it is not valid to specify a subcommand followed by its parent command: # invalid: cannot move _up_ the hierarchy myapp add item1 0.2 myapp The default ( ) only executes the last subcommands with the same parent. For example, if is invoked, only the last two sub-subcommands and (who both have parent command ) are executed by default. You can set a different execution strategy if this does not meet your needs. After registering subcommands, calling the method will show a usage help message that includes all registered subcommands. For example: // add subcommands programmatically (not necessary if the parent command // add subcommands programmatically (not necessary if the parent command The usage help message shows the commands in the order they were registered: Usage: git [-hV] [--git-dir=<gitDir>] [COMMAND] Git is a fast, scalable, distributed revision control system with an unusually rich command set that provides both high-level operations and full access to internals. --git-dir=<gitDir> Set the path to the repository. -h, --help Show this help message and exit. -V, --version Print version information and exit. Commands: The most commonly used git commands are: help Display help information about the specified command. status Show the working tree status. commit Record changes to the repository. add Add file contents to the index. branch List, create, or delete branches. checkout Checkout a branch or paths to the working tree. clone Clone a repository into a new directory. diff Show changes between commits, commit and working tree, etc. merge Join two or more development histories together. push Update remote refs along with associated objects. rebase Forward-port local commits to the updated upstream head. tag Create, list, delete or verify a tag object signed with GPG. The description of each subcommand in the command list is taken from the subcommand’s first line, or the first line if it does not have a defined. The above usage help message is produced from the annotations on the class below: \"system with an unusually rich command set that provides both \" \"Set the path to the repository.\" \"system with an unusually rich command set that provides both \" \"Set the path to the repository.\" The above example uses the mixinStandardHelpOptions attribute to mix in and options and registers the subcommand. Use the annotation for subcommands that need to show the usage help message explicitly. From picocli 3.1, the usage help synopsis of the subcommand shows not only the subcommand name but also the parent command name. For example, if the command has a subcommand, the usage help for the subcommand shows . If a subcommand explicitly wants to show the usage help message, the annotation may be useful. The injected has its parent command initialized correctly, so the usage help can show the fully qualified name of the subcommand. For example, see Section Headings for an example subcommand ( ), which produces the help message shown in Expanded Example. Commands with the attribute set to will not be shown in the usage help message of their parent command. For example, the subcommand below is annotated as : The usage help message for looks like the below. Note that the subcommand is not shown: Commands with the attribute set to are treated as help commands. When picocli encounters a help command on the command line, required options and required positional parameters of the parent command are not validated (similar to help options). See Custom Help Subcommands for more details on creating help subcommands. For some command suites, it does not make sense to invoke the top-level command by itself, and the user is required to specify a subcommand. From version 4.3, picocli makes it easy to accomplish this: simply use the method to start your application, and make the top-level command a class that does not implement or . Then, when the user specifies only the top-level command, without a subcommand, while this top-level command does not implement or , picocli internally throws a with the error message . This will cause the to be called, which will display this message to the user. Prior to picocli 4.3, applications could indicate that subcommands are required by letting the top-level command throw a . For example: By default, the synopsis of a command with subcommands shows a trailing , indicating that a subcommand can optionally be specified. To show that the subcommand is mandatory, use the attribute to replace this string with (without the and brackets). There are some scenarios where picocli can not parse an option with a default value which is the same as a subcommand name. To work around this, you can parse the option yourself using . A simple implementation is shown below. See this issue for more details.\n\nPicocli also provides a programmatic API, in addition to the annotations API. The programmatic API allows applications to dynamically create command line options on the fly, where not all options are known in advance. It also makes it possible to use picocli in other JVM languages that do not support annotations. Another use case is creating idiomatic domain-specific languages for processing command line arguments. For example, Groovy’s CliBuilder DSL is implemented using picocli’s programmatic API. As of version 3.2, and annotations can be added to methods as well as fields of a class. For concrete classes, annotate \"setter\" methods (methods that accept a parameter) and when the option is specified on the command line, picocli will invoke the method with the value specified on the command line, converted to the type of the method parameter. Alternatively, you may annotate \"getter-like\" methods (methods that return a value) on an interface, and picocli will create an instance of the interface that returns the values specified on the command line, converted to the method return type. The and annotations can be used on methods of an interface that return a value. For example: You use it by specifying the class of the interface: The and annotations can be used on methods of a class that accept a parameter. For example: You use it by passing an instance of the class: // method was invoked with command line value // method was invoked with command line value Methods annotated with and can do simple input validation by throwing a when invalid values are specified on the command line. Applications that reuse a single instance for multiple or invocations should be aware of the following: Annotated setter method options that explicitly set will get a call with a parameter when the command line did not include that option. If the setter method annotation does not explicitly set , then this method will not be called when the command line did not include that option. This means that the value will retain the value of the previous or invocation, which may not be desirable. (This only happens for applications that reuse a single instance for multiple or invocations.) // reset to null when option not specified // retains value of previous parseArgs invocation when option not specified // reset to null when option not specified // retains value of previous parseArgs invocation when option not specified As of picocli 3.6, methods can be annotated with . The method parameters provide the command options and parameters. For example: The usage help of the above command looks like this: Usage: cat [-EhnTvV] [FILE...] Concatenate FILE(s) to standard output. [FILE...] -E, --show-ends -h, --help Show this help message and exit. -n, --number -T, --show-tabs -v, --show-nonprinting -V, --version Print version information and exit. See below for an example that uses a resource bundle to define usage help descriptions outside the code. For positional parameters, the annotation may be omitted on method parameters. If compiled with the flag on Java 8 or higher, the of positional parameters is obtained from the method parameter name using reflection instead of the generic arg0, arg1, etc. If the enclosing class is annotated with , method commands are automatically added as subcommands to the class command, unless the class command has attribute . For example: Use on the class annotation if the -annotated methods in this class should not be added as subcommands. The usage help of the above example command is very minimal: You can use a resource bundle to move the descriptions out of the code: # shared between all commands help = Show this help message and exit. version = Print version information and exit. # command-specific strings git.usage.description = Version control system git.GITDIR = Set the path to the repository git.commit.usage.description = Record changes to the repository git.commit.message = Use the given <msg> as the commit message. git.commit.squash = Construct a commit message for use with rebase --autosquash. git.commit.<file>[0..*] = The files to commit. With this resource bundle, the usage help for the command looks like this: Usage: git commit [--squash=<commit>] [-m=<arg0>] [<file>...] Record changes to the repository [<file>...] The files to commit. --squash=<commit> Construct a commit message for use with rebase --autosquash. -m, --message=<arg0> Use the given <msg> as the commit message. As of picocli 3.8, methods accept parameters. All options and positional parameters defined in the mixin class are added to the command. In the above example, the and options are added to the -option of the command. Picocli 3.2 introduces a annotation for injecting the model of the command into a command field. From picocli 4.6, -annotated elements can be used in ArgGroup classes. This is useful when a command needs to use the picocli API, for example to walk the command hierarchy and iterate over its sibling commands. This complements the annotation; the annotation injects a user-defined command object, whereas this annotation injects a picocli class. // do something with the injected spec // do something with the injected spec \"My full name is ${commandSpec.qualifiedName()}\" As of picocli 4.3, the annotation has a element. The value is by default, meaning that the of the enclosing class is injected into the -annotated field. For classes that are used as a mixin, there is another value that may be useful. When is specified in a mixin class, the of the command receiving this mixin (the \"mixee\") is injected into the -annotated field. This can be useful when a mixin contains logic that is common to many commands. See Accessing the Mixee from a Mixin for more details. Declaratively registered subcommands, type converters and version providers must be instantiated somehow. As of picocli 2.2, a custom factory can be specified when constructing a instance. This allows full control over object creation and opens possibilities for Inversion of Control and Dependency Injection (see next section). For example: Custom factories need to implement the interface: /** * Creates and returns an instance of the specified class. * @param clazz the class to instantiate * @param <K> the type to instantiate * @return the new instance * @throws Exception an exception detailing what went wrong when creating the instance */ If no factory is specified, a default factory is used. The default factory requires that the classes to instantiate have a public no-argument constructor: it instantiates the class by first calling , and if that fails, . From version 4.0, picocli delegates all object creation to the factory, including creating instances to capture multi-value values. Previously, objects were instantiated separately without involving the factory. It is recommended that custom factories should fall back to the default factory. Something like this: From picocli 4.6, it is possible to use the annotations API to modify the model (commands, options, subcommands, etc.) dynamically at runtime. The annotation now has a attribute where applications can specify a class that implements the interface: /** * Given an original CommandSpec, return the object that should be used * instead. Implementors may modify the specified CommandSpec and return it, * or create a full or partial copy of the specified CommandSpec, and return * that, or even return a completely new CommandSpec. * <p> * Implementors are free to add or remove options, positional parameters, * subcommands or modify the command in any other way. * </p><p> * This method is called once, after the full command hierarchy is * constructed, and before any command line arguments are parsed. * </p> * @return the CommandSpec to use instead of the specified one */ This allows applications to dynamically add or remove options, positional parameters or subcommands, or modify the command in any other way, based on some runtime condition. All transformers are called once, after the full command hierarchy is constructed, and before any command line arguments are parsed. If your model transformer is declared as nested class, make sure you mark this class as , or picocli will not be able to instantiate your transformer class. Positional parameters have an attribute that determines which command line argument(s) are captured. It is possible to omit the attribute and let picocli automatically assign an index. This means different things for single-value and for multi-value positional parameters. For multi-value positional parameters (arrays or collections), omitting the attribute means the field captures all positional parameters (the equivalent of ). For single-value positional parameters, picocli’s behaviour has changed since version 4.3: prior to picocli 4.3, the default index for single-value positional parameters was also , even though only one value (usually the first argument) can be captured. From version 4.3, the default index is , which tells picocli to assign an index automatically, starting from zero, based on the other positional parameters defined in the same command. A simple example can look like this: // \"hidden\": don't show this parameter in usage help message // \"hidden\": don't show this parameter in usage help message Picocli initializes fields with the values at the specified index in the arguments array. Automatic indexes depend on the ability of Java reflection and Java annotation processors to iterate over fields in declaration order in the source code. Officially this is not guaranteed by the Java spec. In practice this has worked in Oracle JVMs and OpenJDK from Java 6, but there is some risk this may not work in the future or on other JVMs. In general, for single-value positional parameters, using explicit indexes is the safer option. (Multi-value positional parameters can safely omit the attribute.) Methods cannot be iterated over in predictable order. For applications with -annotated methods or combinations of -annotated methods and -annotated fields, we recommend using explicit indexes for single-value positional parameters. The default automatic index ( ) for single-value positional parameters is \"anchored at zero\": it starts at zero, and is increased with each additional positional parameter. Sometimes you want to have indexes assigned automatically from a different starting point than zero. This can be useful when defining Mixins with positional parameters. To accomplish this, specify an index with the anchor point and a character to indicate that picocli should start to automatically assign indexes from that anchor point. For example: If a command defines a positional parameter with an explicit index at the anchor point, then automatic indexes anchored at that point will start from the explicit index plus 1. For example: Sometimes you want to have indexes assigned automatically to come at the end. This can be useful when defining Mixins with positional parameters. To accomplish this, specify an index with a character to indicate that picocli should automatically assign indexes that come at the end. For example: 21.7.5. Do Not Combine Unanchored Indexes with Open-ended Indexes It is not possible to combine unanchored indexes ( ) with open-ended explicit indexes ( ): the parameter with the open-ended index will capture all arguments, and there is no position \"after the other indexes\" that can be assigned. The below example will always give a error: Picocli will align the usage help message to fit within some user-defined width (80 columns by default). A number of characters in Chinese, Japanese and Korean (CJK) are wider than others. If those characters are treated to have the same width as other characters, the usage help message may extend past the right margin. From 4.0, picocli will use 2 columns for these wide characters when calculating where to put line breaks, resulting in better usage help message text. This can be switched off with . By default the value of a boolean field is set to the logical negative of its default value when the option is specified on the command line. It is possible to let end users explicitly specify \"true\" or \"false\" as a parameter for a boolean option by defining an explicit Arity attribute. A boolean option with accepts zero to one parameters, means the option must have one parameter. For example: The following ways to invoke the program will be accepted (values are not case sensitive): But trying to specify the option without a parameter, or with a value other than \"true\" or \"false\" (case insensitive) will result in a . Numeric values are interpreted as decimal numbers by default. If you want picocli to be more flexible, you can register a custom type converter that delegates to the decode method to convert strings to numbers. The method looks at the prefix to determine the radix, so numbers starting with , or are interpreted as hexadecimal numbers, numbers starting with are interpreted as octal numbers, and otherwise the number is interpreted as a decimal number. Options may take an option parameter (also called option-argument). For POSIX-style short options (like or ), the option parameter may be attached to the option, or it may be separated by a space or the separator string ( by default). That is, all of the below are equivalent: Long option names (like ) must be separated from their option parameter by a space or the separator string ( by default). That is, the first two below examples are valid but the last example is invalid: // valid separator between and its parameter < output.txt < output.txt // invalid picocli will not recognize the option when attached to its parameter < .txt The separator string can be customized programmatically or declaratively. Use the attribute of the annotation to declaratively set a separator string: Alternatively, the separator string can be changed programmatically with the method. For example: Picocli makes it easy to follow this new and modern set of Command Line Interface Guidelines. Slightly older, but a classic: when designing your command line application, the GNU recommendations for command line interfaces and POSIX Utility Guidelines may be useful. Generally, many applications use options for optional values and parameters for mandatory values. However, picocli lets you make options required if you want to, see Required Arguments. When writing your command line program, you can use Java 15’s new \"Text Block\" feature. Multi-line text blocks can be used in command and option descriptions, headers and footers. For more details, see this article by Java Language Architect Brian Goetz."
    }
]