[
    {
        "link": "https://stackoverflow.com/questions/16210707/c-vector-of-template-class",
        "document": "The reason why this is NOT possible in C++, but possible in Java/Python is because: in a C++ vector, the STL container's storage (returned by vector::data()) contains all the object instantiations sequentially packed. In which each element must have the same size. This makes addressing fast and convenient. Therefore, suppose you define a template class A,\n\nIts size will depend on the template variable \"T obj\". Pushing the same class A of a different template type T will make each element in the vector have different sizes, thus, this is impossible. The only way is to use the vector of shared_ptr or unique_ptr of a base class. Both shared_ptr and unique_ptr are supported by C++11 and Boost. Each derived-class element can have different template types. In this way, when the base class pointer's destructor is called, the derived class's destructor will be invoked. For example,\n\nRemember to compile with -std=c++11 to enable C++11.\n\nAnd you get what you want! :)\n\nIn Java/Python, every class-object variable is actually a pointer, thus, a Java Array of A or a Python list of A is equivalent to a C++ array of pointers of A. Thus, you get essentially the same functionality without explicitly creating shared_ptrs."
    },
    {
        "link": "https://stackoverflow.com/questions/51961438/c-vector-of-templated-class-objects",
        "document": "I don't know if it's possible to achieve what I'm trying but maybe someone can guide me in the right direction. Sidenote: this is on an embedded system.\n\nI have an SPI communication that returns a representing a set of registers. This is done in a separate thread so asynch. To handle this, I create an object on every call containing a (and some other information) and directly return the of it, so the caller can wait for the result.\n\nOnce the SPI transfer is complete, I set the value of the promise accordingly. So far so good.\n\nNow what I'd like to do is to not always return a future of type but do some preprocessing on the vector and return either or or even a . I thought I can achieve that by handing an anonymous function to the function and store a reference in the object. This function would then be called before the promise is assigned.\n\nThe problem I now have is that the return type of this function directly affects the return type of my promise and the object storing them is not always the same anymore. So I thought I just template it\n\nBut now I have to problem that my vector containing these objects (the SPI queue) that was of type cannot hold objects of different types.\n\nIs there a proper way to solve that?\n\nedit: I'd use the vector in a way like"
    },
    {
        "link": "https://en.cppreference.com/w/cpp/container/vector",
        "document": "The elements are stored contiguously, which means that elements can be accessed not only through iterators, but also using offsets to regular pointers to elements. This means that a pointer to an element of a vector may be passed to any function that expects a pointer to an element of an array.\n\nThe storage of the vector is handled automatically, being expanded as needed. Vectors usually occupy more space than static arrays, because more memory is allocated to handle future growth. This way a vector does not need to reallocate each time an element is inserted, but only when the additional memory is exhausted. The total amount of allocated memory can be queried using capacity() function. Extra memory can be returned to the system via a call to shrink_to_fit()[1].\n\nReallocations are usually costly operations in terms of performance. The reserve() function can be used to eliminate reallocations if the number of elements is known beforehand.\n\nThe complexity (efficiency) of common operations on vectors is as follows:\n• Insertion or removal of elements at the end - amortized constant .\n• Insertion or removal of elements - linear in the distance to the end of the vector .\n\n(for other than bool) meets the requirements of Container, AllocatorAwareContainer(since C++11), SequenceContainer, ContiguousContainer(since C++17) and ReversibleContainer.\n\nAll member functions of are constexpr: it is possible to create and use objects in the evaluation of a constant expression. However, objects generally cannot be constexpr, because any dynamically allocated storage must be released in the same evaluation of constant expression.\n• is In libstdc++,is not available in C++98 mode.\n\nThe type of the elements. must meet the requirements of and . The requirements that are imposed on the elements depend on the actual operations performed on the container. Generally, it is required that element type is a complete type and meets the requirements of , but many member functions impose stricter requirements. The requirements that are imposed on the elements depend on the actual operations performed on the container. Generally, it is required that element type meets the requirements of Erasable, but many member functions impose stricter requirements. This container (but not its members) can be instantiated with an incomplete element type if the allocator satisfies the allocator completeness requirements. An allocator that is used to acquire/release memory and to construct/destroy the elements in that memory. The type must meet the requirements of . if is not the same as .\n\nThe standard library provides a specialization of for the type bool, which may be optimized for space efficiency.\n\nThe following behavior-changing defect reports were applied retroactively to previously published C++ standards."
    },
    {
        "link": "https://geeksforgeeks.org/vector-in-cpp-stl",
        "document": "In C++, vector is a dynamic array that stores collection of elements same type in contiguous memory. It has the ability to resize itself automatically when an element is inserted or deleted.\n\nVector is defined as the std::vector class template inside the <vector> header file.\n\nwhere T is the type of elements and v is the name assigned to the vector.\n\nCreating a vector involves creating an instance of std::vector class. This requires us to provide the type of elements as template parameter.\n\nWe can also provide the values to be stored in the vector inside {} curly braces. This process is called initialization.\n\nIn the above example,\n• vector<int> v2(5, 9) creates a vector of size 5 where each element initialized to 9.\n\nMore ways to declare and initialize vectors are discussed in this article – 8 Ways to Initialize Vector in C++\n\nAn element can be inserted into a vector using vector insert() method which takes linear time. But for the insertion at the end, the vector push_back() method can be used. It is much faster, taking only constant time.\n\nMore ways to insert an element in the vector are discussed in the article – Different Ways to Add Elements in a Vector\n\nJust like arrays, vector elements can be accessed using their index inside the [] subscript operator. This method is fast but doesn’t check whether the given index exists in the vector or not. So, there is another member method vector at() for safely accessing elements.\n\nTo know more about accessing vector elements, refer to the article – Different Ways to Access Elements in Vector\n\nUpdating elements is very similar to the accessing except that we use an assignment operator to assign a new value. It uses the same methods: [] subscript operator and vector at().\n\nMore methods to update vector elements are discussed in this article – Different Ways to Update Vector Elements\n\nOne of the common problems with arrays was to keep a separate variable to store the size information. Vector provides the solution to this problem by providing size() method.\n\nVector in C++ can be traversed using indexes in a loop. The indexes start from 0 and go up to vector size – 1. To iterate through this range, we can use a loop and determine the size of the vector using the vector size()method.\n\nWe can also use a range-based loop for simple traversal. More ways to traverse vectors are discussed in this article – Different Ways to Iterate Through Vector\n\nAn element can be deleted from a vector using vector erase() but this method needs iterator to the element to be deleted. If only the value of the element is known, then find() function is used to find the position of this element.\n\nFor the deletion at the end, the vector pop_back() method can be used, and it is much faster, taking only constant time.\n\nTo know more about the deletion of an element in the vector, refer to this article – Different Ways to Remove Elements from Vector\n\nVector is one of the most frequently used containers in C++. It is used in many situations for different purposes. The following examples aim to help you master vector operations beyond the basics.\n\nThe below table lists the time complexity of the above operations on a vector:\n\nVectors can be passed to a function as arguments just like any other variable in C++. But it is recommended to pass the vector by reference so as to avoid the copying of all elements which can be expensive if the vector is large. Refer to this article to know more – Passing Vector to a Function\n\nVector internal working is very interesting and useful to select and optimize its usage. Understanding the internal memory management also helps in modifying the default mechanism of vector to suits our needs. Refer to this article to know more – Internal Working of Vector\n\nJust like arrays, we can also create multidimensional vectors in C++. Each element of multidimensional vector can be visualized as the collection of vectors with dimension one less that the current vector. For example, 2D vectors are the collection of 1D vectors, while 3D vectors are the collection of 2D vectors and so on.\n\nWith the addition of each dimension, the complexity of operations on the vectors also increases.\n\nRefer to this article to know more – Multidimensional Vectors in C++\n\nFollowing is the list of all member functions of std::vector class in C++:\n\nAdds an element to the end of the vector. Removes the last element of the vector. Returns the number of elements in the vector. Returns the maximum number of elements that the vector can hold. Changes the size of the vector. Checks if the vector is empty. Accesses the element at a specific position, with bounds checking. Accesses the first element of the vector. Accesses the last element of the vector. Returns an iterator pointing to the first element of the vector. Returns an iterator pointing to the past-the-end element of the vector. Returns a reverse iterator pointing to the last element of the vector. Returns a reverse iterator pointing to the element preceding the first element of the vector. Inserts elements at a specific position in the vector. Removes elements from a specific position or range in the vector. Swaps the contents of the vector with those of another vector. Removes all elements from the vector. Constructs and inserts an element in the vector. Constructs and inserts an element at the end of the vector. Assigns new values to the vector elements by replacing old ones. Returns the size of the storage space currently allocated to the vector. Requests that the vector capacity be at least enough to contain a specified number of elements. Returns a direct pointer to the memory array used internally by the vector to store its owned elements. Returns a copy of the allocator object associated with the vector."
    },
    {
        "link": "https://cplusplus.com/forum/beginner/181429",
        "document": "However, while the above works perfectly well I am having difficulty choosing a manner in which to apply it (or something similar) to all classes. As I said, each class maps to a particular table in the database, and its members to the values in the columns. In order to decrease the size of the database I have elected to store categorical information as `int`s and more specific (non-recurring) information as `string`s. For example the above is the implementation that corresponds to the following class `Car`. \n\n The header:\n\n \n\n \n\n \n\n The `std::vector` containing the data for each class is then used to display it (again specific to the above) as such:\n\n \n\n < T> displayList( vector<T> &ex) { (vector<T>::const_iterator it = ex.begin(); it != ex.end(); ++it) { cout << it->displayCarID() << endl; cout << it->displayCarModelName() << endl; cout << it->displayCarModelYear() << endl; cout << it->displayCarColor() << endl; cout << it->displayCarEngineManufacturer() << endl; cout << it->displayEngineDisplacement() << endl; cout << << endl; } } \n\n \n\n On to the question. Is it possible to use a template for the above `query` function in order to avoid replicating it for each individual class? If not, what is the preferred design (or your own personal advice) for simplifying a problem like this?\n\n \n\n Restrictions:\n\n \n\n 1) The `sqlite3` C++ interface returns queries in `C` style datatypes. For example in the first code snippet in order to get the string `carEngineManufacturer` required for the constructor of `Car` a C style cast is required as `(char*)sqlite3_column_text(statement, index[1])`.\n\n \n\n 2) Since the classes vary, another constructor may require a different order or number or arguments. IE creating a vector of planes. `Plane(int planeName, string planeModelName, int planeModelYear, string countryOfOrigin, int planeType);`\n\n \n\n Considerations:\n\n \n\n I considered creating a `base` class to derive from as all classes will share at least an `ID` and `Name` member, however it seems as though that would not be altogether very beneficial. Moreover, as none of the classes have, or are aware of a `vector` class member adding a specific function to their implementations would give a `non-static` or `storage` error.\n\n \n\n I also thought about specializing the template for each data class type, which at the moment is the best solution I am aware of. Albeit, that would require the majority of the same code to be copied more than 10 times changing only that is within the `if (result == SQLITE_ROW) { }` brackets, and was curious if there is a better/simpler solution I am overlooking. I would greatly appreciate any other insight or advice, thanks in advance.\n\n \n\n *Note – If it helps, the `int cols = sqlite3_column_count(statement);` line the template function returns the number of columns for the specific query which could possibly be used to determine the class.\n\n Hi, first post. I've recently been introduced to templates and am hoping to implement them into a project I am working on; however, I've run into a few problems with design. The program I am writing uses an `Sqlite3` database, for which I am creating a wrapper to complete and store queries in an `std::vector`. I have a number of different classes to handle each table in the database, and created the function below to handle any class type.However, while the above works perfectly well I am having difficulty choosing a manner in which to apply it (or something similar) to all classes. As I said, each class maps to a particular table in the database, and its members to the values in the columns. In order to decrease the size of the database I have elected to store categorical information as `int`s and more specific (non-recurring) information as `string`s. For example the above is the implementation that corresponds to the following class `Car`.The header:The `std::vector` containing the data for each class is then used to display it (again specific to the above) as such:On to the question.Restrictions:1) The `sqlite3` C++ interface returns queries in `C` style datatypes. For example in the first code snippet in order to get the string `carEngineManufacturer` required for the constructor of `Car` a C style cast is required as `(char*)sqlite3_column_text(statement, index[1])`.2) Since the classes vary, another constructor may require a different order or number or arguments. IE creating a vector of planes. `Plane(int planeName, string planeModelName, int planeModelYear, string countryOfOrigin, int planeType);`Considerations:I considered creating a `base` class to derive from as all classes will share at least an `ID` and `Name` member, however it seems as though that would not be altogether very beneficial. Moreover, as none of the classes have, or are aware of a `vector` class member adding a specific function to their implementations would give a `non-static` or `storage` error.I also thought about specializing the template for each data class type, which at the moment is the best solution I am aware of. Albeit, that would require the majority of the same code to be copied more than 10 times changing only that is within the `if (result == SQLITE_ROW) { }` brackets, and was curious if there is a better/simpler solution I am overlooking. I would greatly appreciate any other insight or advice, thanks in advance.*Note – If it helps, the `int cols = sqlite3_column_count(statement);` line the template function returns the number of columns for the specific query which could possibly be used to determine the class.\n\n\n\n \n\n The idea is simple: Create an interface filled with methods which all your other classes should implement\n\n \n\n Example of such a class:\n\n \n\n \n\n Now what you can do is that for each table you have in your db, create the tables as normal, but have them implement this interface as well. In that way, you have no code duplication and every class will have the same methods required for working with it.\n\n Continuing with the Car class:\n\n \n\n Car : Table { : _carID; std::string _carModelName, _carEngineManufacturer; _carModelYear, _carColor, _carEngineDisplacement; : display(std::ostream& oss) { } : Car (sqlite3_stmt *statement) : Table(statement) { // Do all sql stuff here } }; \n\n \n\n Finally your query method should look like this:\n\n \n\n query(sqlite3* db, * query, std::vector<std::shared_ptr<Table>> & vec) { sqlite3_stmt *statement; (sqlite3_prepare_v2(db, query, -1, &statement, 0) == SQLITE_OK) { ( result = sqlite3_step(statement); result == SQLITE_ROW; result = sqlite3_step(statement)) { // In here you have to somehow know the object you are dealing with. For this // example, let's assume Car object as before vec.push_back(std::make_shared<Car>(statement)); } sqlite3_finalize(statement); } std::string error = sqlite3_errmsg(db); (error != ) { std::cout << query << << error << std::endl; } sqlite3_close(db); } \n\n \n\n And display method should look like this:\n\n \n\n displayList( std::vector<std::shared_ptr<Table>> &ex) { (std::vector<std::shared_ptr<Table>>::const_iterator it = ex.begin(); it != ex.end(); ++it) { std::cout << *(it->get()) << std::endl; } } \n\n \n\n Note all this is untested but should any compiler errors arise they should be easy enough fixes The answer is Polymorphism.The idea is simple: Create an interface filled with methods which all your other classes should implementExample of such a class:Now what you can do is that for each table you have in your db, create the tables as normal, but have them implement this interface as well. In that way, you have no code duplication and every class will have the same methods required for working with it.Continuing with the Car class:Finally your query method should look like this:And display method should look like this:Note all this is untested but should any compiler errors arise they should be easy enough fixes\n\n1)\n\n From the responses I have developed the following two functions:\n\n \n\n < T> showQList( vector<std::shared_ptr<T>> &vec) { (vector<std::shared_ptr<T>>::const_iterator it = vec.begin(); it != vec.end(); ++it) { cout << *(it->get()) << endl; } } \n\n \n\n \n\n \n\n And the following alternative to the query above:\n\n \n\n \n\n \n\n All three methods work well, and I am grateful for the responses that helped me arrive at forming them. I have been utilizing the first (`query`) because in my current implementation (see part 2 below) it resolves successfully. I would appreciate any other advice or criticism on the functions above.\n\n \n\n *Note – I have based my classes on a suggestion from @Smac89 (Thank you!) and used an abstract base to form a heritable interface for display.\n\n \n\n 2)\n\n \n\n One other quick question (I would otherwise open another topic but since the majority of the specific circumstance is here it seems appropriate). I am using two `switch statements` in order to build the text of database query (one for the operation, the following for the table to be used). I was curious about what manner (or otherwise) would be best suited to simplify the initialization of the `vector` with its members. Currently I am using the following:\n\n \n\n \n\n \n\n A call to which looks as such:\n\n \n\n \n\n \n\n I was wondering, and forgive me if this seems like an odd question, if it is possible to return the `vector` (and its type) directly instead of casting it like above. I.E. something like:\n\n \n\n \n\n \n\n And a corresponding call:\n\n \n\n \n\n \n\n In any case, thanks to all for your input and how quick you were to offer it. I greatly appreciate it. From the responses I have developed the following two functions:And the following alternative to the query above:All three methods work well, and I am grateful for the responses that helped me arrive at forming them. I have been utilizing the first (`query`) because in my current implementation (see part 2 below) it resolves successfully. I would appreciate any other advice or criticism on the functions above.One other quick question (I would otherwise open another topic but since the majority of the specific circumstance is here it seems appropriate). I am using two `switch statements` in order to build the text of database query (one for the operation, the following for the table to be used). I was curious about what manner (or otherwise) would be best suited to simplify the initialization of the `vector` with its members. Currently I am using the following:A call to which looks as such:I was wondering, and forgive me if this seems like an odd question, if it is possible to return the `vector` (and its type) directly instead of casting it like above. I.E. something like:And a corresponding call:In any case, thanks to all for your input and how quick you were to offer it. I greatly appreciate it.\n\n\n\n \n\n I am a bit of novice, (especially when compared to you and the others here) I read previously that the when possible to prefer initialization to assignment. I also checked up on the documentation for `emplace_back` and it seems that it is preferred when construction (non-primitive types) takes place to add to the vector? I did some of my own bench marking with `emplace` and `push` back with some mixed results.\n\n \n\n In your example the `extract` methods returns a `Car`, is that why `emplace` is preferred in this case? I have set the constructor for the classes as so: \n\n \n\n \n\n \n\n Is beneficial in this case?\n\n \n\n Called to as: \n\n \n\n Also, I was wondering if the way it is currently implemented (`query` not `queryAlt`), that is with a reference argument after the vector has been previously declared is more taxing/strenuous than initializing directly using auto as you did in your response? IE:\n\n \n\n Initializing a vector as a return from a function like \n\n \n\n \n\n \n\n V.S.\n\n \n\n Declaring the vector and then populating it by passing it as a reference to a function\n\n \n\n \n\n \n\n Again thanks for your help! @cire Thanks for your response. I partially favored @Smac89’s answer because I required some way to display the input universally as well as that for some reason, perhaps my own fault, I could not get the `result vector` to populate. Nevertheless, your example helped a great deal; influence that is reflected in what I posted above. I was curious about your use of `emplace_back` and your choice for the related structuring.I am a bit of novice, (especially when compared to you and the others here) I read previously that the when possible to prefer initialization to assignment. I also checked up on the documentation for `emplace_back` and it seems that it is preferred when construction (non-primitive types) takes place to add to the vector? I did some of my own bench marking with `emplace` and `push` back with some mixed results.In your example the `extract` methods returns a `Car`, is that why `emplace` is preferred in this case? I have set the constructor for the classes as so:IsbeneficialCalled to as:Also, I was wondering if the way it is currently implemented (`query` not `queryAlt`), that is with a reference argument after the vector has been previously declared is more taxing/strenuous than initializing directly using auto as you did in your response? IE:Initializing a vector as a return from a function likeV.S.Declaring the vector and then populating it by passing it as a reference to a functionAgain thanks for your help!\n\nIn your example the `extract` methods returns a `Car`, is that why `emplace` is preferred in this case? I have set the constructor for the classes as so: \n\n There is no reason to prefer for this particular use case. They've equivalent semantics for rvalue references. I just prefer to use emplace generally, since there are fewer \"gotchas\" with regards to generated temporaries in its use.\n\n \n\n \n\n Also, I was wondering if the way it is currently implemented (`query` not `queryAlt`), that is with a reference argument after the vector has been previously declared is more taxing/strenuous than initializing directly using auto as you did in your response? IE: \n\n What happens when you send a non-empty vector in? What should happen? Should it even be allowed? The alternate form handles that rather nicely, doesn't it? It also allows for type deduction on the return type (the use of , which may be good or bad here, depending on your views.)\n\n \n\n You should reconsider the use of shared_ptr. Do you really need shared ownership? There is no reason to preferfor this particular use case. They've equivalent semantics for rvalue references. I just prefer to use emplace generally, since there are fewer \"gotchas\" with regards to generated temporaries in its use.What happens when you send a non-empty vector in? Whathappen? Should it even be allowed? The alternate form handles that rather nicely, doesn't it? It also allows for type deduction on the return type (the use of, which may be good or bad here, depending on your views.)You should reconsider the use of shared_ptr. Do you really need shared ownership?\n\n\n\n \n\n There is another solution you can adopt which is as follows:\n\n \n\n If you use the method proposed by @cire, i.e. this definition of query (with a little modification):\n\n \n\n \n\n \n\n This will solve the problem you are facing.\n\n \n\n Then in main, to collect them all you do this:\n\n \n\n \n\n Now your tables vector will contain all Tables\n\n \n\n Your setList method can be modified like so:\n\n \n\n \n\n \n\n Last but not least, the display method should also be modified to accept vector of tables rather than vector of pointers cire is right in that you may not need shared_ptr. I am not very familiar with the way smart pointers work, but I don't think this is required in this instance. Maybe using a unique_ptr or some other type of smart pointer might work better. This part is up to you to decide, but the bottom line is that if pointers are stored in a vector, they have to be manually deleted when the vector goes out of scope; and smart pointers help with this.There is another solution you can adopt which is as follows:If you use the method proposed by, i.e. this definition of query (with a little modification):This will solve the problem you are facing.Then in main, to collect them all you do this:Now your tables vector will contain all TablesYour setList method can be modified like so:Last but not least, the display method should also be modified to accept vector of tables rather than vector of pointers\n\n@TheIdeasMan thanks for the input. The initialization list was a valuable suggestion. I will look into the range loop.\n\n \n\n @cire again that is a valid point, duly noted. Thank you.\n\n \n\n @Smac89 I will hold onto the idea of collecting the tables in a single vector. Such could be useful at a later point, however my goal would be collect them separately in different vectors and/or an instance of an which contains the results from only one query at a time (to avoid later separation/sorting).\n\n \n\n How would you call to ? \n\n \n\n As ?\n\n \n\n I believe I have some problem arising from inheritance. Presently I get the following error when trying to implement it:\n\n \n\n no suitable user-defined conversion from to exists \n\n \n\n My `Table` class is as verbatim from your first response, and all (derived) classes (with the exception of the overridden display function) are also structured as you did in your `Car` example."
    },
    {
        "link": "https://stackoverflow.com/questions/19817522/circular-dequeue-implementation-error",
        "document": "Basically a dynamic array, which has circular rotation when is full. You have access to every element and you can change it's value, however you can insert and remove only from both ends.(constant time). Most of the methods seem to be working fine, however at certain \"push\" numbers I get wrong output.\n\n For example first input is then I insert at the end. Next output is: However after I insert at the end the output is\n\nI have no idea what is causing this. I am posting the entire source code below (atleast the functions which have to do with the tests where the error must hide). There is some documentation in the file and an example of the error in case I haven't explained things clearly."
    },
    {
        "link": "https://geeksforgeeks.org/implement-dynamic-deque-using-templates-class-and-a-circular-array",
        "document": "The task is to implement a dynamic Deque using templates class and a circular array, having the following functionalities:\n• front(): Get the front item from the deque.\n• back(): Get the last item from the deque.\n• push_back(X): Push X at the end of the deque.\n• push_front(X): Push X at the start of the deque.\n• pop_front(): Delete an element from the start of the deque.\n• pop_back(): Delete an element from the end of the deque\n• empty(): Checks whether deque is empty or not\n• size(): Number of elements in the deque\n\nBelow is the step by step illustration:\n• Insert 1 to the back of deque\n• Insert elements 2, 3 to the back of deque\n• Insert 4 to the front of deque\n• Insert 5 to the back of deque\n• Pop 2 elements from front and 2 elements from the back of deque\n• Pop 1 element from the front of deque\n\nApproach: The idea is to double the size of the array used every time the capacity of the array gets full and copy the elements of the previous array into the new array. Follow the steps below to solve the problem:\n• Initialize 4 variables say frontIndex, backIndex, sizeVar, and capacityVar, and an array say arr[] to implement the deque.\n• Define a function say capacity() to find the size of the current array used and return the value of the variable, capacityVar.\n• Define a function say size() to find the count of elements in the deque and return the value of the variable, sizeVar.\n• Define a function say full() to find if the deque is full or not and return true if sizeVar is equal to capacityVar. Otherwise, return false.\n• Define a function say empty() to find if the deque is empty or not and return true if frontIndex and backIndex are equal to -1. Otherwise, return false.\n• Define a function say Front() to print the front element of the deque. If deque is not empty(), print the element of arr[frontIndex].\n• Define a function say Back() to print the last element of the deque. If deque is not empty(), print the element of arr[BackIndex].\n• Define a function say push_back(X) to insert an element at the end of the deque:\n• If the deque is full, then double the size of the current array and copy the elements of the previous array into the new array.\n• If deque is empty(), then assign frontIndex = backIndex = 0 and then assign X to both arr[frontIndex] and arr[backIndex] and then increment sizeVar by one.\n• Else, update backIndex as backIndex = (backIndex+1) %capacityVar and then assign X to arr[backIndex] and increment sizeVar by one.\n• Define a function say push_front(X) to insert an element at the start of the deque:\n• If the deque is full, then double the size of the current array and copy the elements of the previous array into the new array.\n• If deque is empty(), then assign frontIndex = backIndex = 0 and then assign X to both arr[frontIndex] and arr[backIndex] and then increment sizeVar by one.\n• Else, update frontIndex as frontIndex = (frontIndex-1 + capacityVar)%capacityVar and then assign X to arr[frontIndex] and increment sizeVar by one.\n• Define a function say pop_front() to delete an element at the front of the deque:\n• If the deque is empty, print “Underflow”.\n• Else if sizeVar is equal to 1 then assign -1 to frontIndex and backIndex both and then decrement sizeVar by one.\n• Else, Update frontIndex as frontIndex = (frontIndex+1)%capacityVar and decrement sizeVar by one.\n• Define a function say pop_back() to delete an element at the front of the deque:\n• If the deque is empty, print “Underflow”.\n• Else if sizeVar is equal to 1 then assign -1 to frontIndex and backIndex both and then decrement sizeVar by one.\n• Else, Update backIndex as backIndex = (backndex-1 + capacityVar) %capacityVar and decrement sizeVar by one.\n\nBelow is the implementation of the above approach:"
    },
    {
        "link": "https://stackoverflow.com/questions/58383843/implementing-circular-array-queue",
        "document": "I am to implement a Circular Array Queue But I a having logical errors and I am not getting the correct result. I need help implementing bool dequeue() in ArrayQueueP4.h. I doubt if it is correct.\n\nI have tried different solutions as well as search through previous questions on stack overflow and online yet it did not give me any ideas on what I am looking for\n\nBased on my main program file, the output supposed to now 1 when I call the enqueue function. But instead of getting 2 as my answer, I am getting -858993460 as my result when I delete the first item using dequeue(). I do not know if that is how Queues behave but isn't the second number supposed to be the next first item in line when I delete the first number?"
    },
    {
        "link": "https://geeksforgeeks.org/cpp-implementation-double-ended-queue",
        "document": "A Double-Ended Queue (Deque) is an abstract data structure that generalizes a queue, for which elements can be added to or removed from either the front (head) or back (tail). It is also often called a head-tail linked list. In this article, we will learn how to implement a Deque in C++ along with its basic operations.\n\nA Deque (pronounced \"deck\") is a linear collection of elements that supports insertion and deletion at both ends. The name \"deque\" is short for \"double-ended queue\". It can be thought of as a combination of a stack and a queue that allows insertion and deletion of elements from both ends.\n• None Elements can be added to both the front and rear ends of the queue.\n• None Elements can be removed from both the front and rear ends of the queue.\n• None Deques support both LIFO (Last In First Out) and FIFO (First In First Out) operations.\n• None Deques can be implemented using either arrays or linked lists.\n\nImplementation of Double Ended Queue in C++\n\nA Deque can be implemented using either an array or a doubly linked list. For this implementation, we'll use a to allow for efficient insertions and deletions at both ends.\n\nRepresentation of Double Ended Queue in C++\n\nThe following diagram represents the structure of deque in C++:\n\nTo represent a Deque in C++, we'll implement a class Deque that contains the required definition: a structure to represent each node and member functions to provide basic functionality. We have used templates to keep the deque generic so that it can support multiple data types.\n• data: stores the value in the node.\n• prev and next: store pointers to the previous and next nodes.\n• front and rear: store pointers to the front and rear of the deque.\n• size: stores the current number of elements in the deque.\n\nBasic Operations of Double Ended Queue in C++\n\nFollowing are some of the basic operations of a Deque that are required to manipulate its elements:\n\nInserts an element at the front of the deque Inserts an element at the rear of the deque Removes an element from the front of the deque Removes an element from the rear of the deque Returns the element at the front of the deque Returns the element at the rear of the deque Checks if the deque is empty or not Returns the number of elements in the deque\n\nImplementation of Insertion at Front in Deque in C++\n\nImplementation of Insertion at Rear in Deque in C++\n\nImplementation of Deletion at Front in Deque in C++\n\nImplementation of Deletion at Rear in Deque in C++\n\nThe following program demonstrates the implementation of a Double Ended Queue in C++.\n\n// Node structure representing each element in the Deque // Pointer to the next node // Constructor to initialize a Node with a given // Pointer to the front of the Deque // Pointer to the rear of the Deque // Number of elements in the Deque // Destructor to clean up memory by removing all // Function to add an element to the front of the Deque // If Deque is empty, both front and rear point to // Link the new node to the current front // Link the current front to the new node // Update front to the new node // Increment the size of the Deque // Function to add an element to the back of the Deque // If Deque is empty, both front and rear point // Link the new node to the current rear // Link the current rear to the new node // Update rear to the new node // Increment the size of the Deque // Function to remove an element from the front of the // Throw an error if Deque is empty // Move front to the next node // If Deque is now empty, set rear to null // Otherwise, unlink the old front node // Free the memory of the old front node // Decrement the size of the Deque // Function to remove an element from the back of the // Throw an error if Deque is empty // If Deque is now empty, set front to null // Otherwise, unlink the old rear node // Free the memory of the old rear node // Decrement the size of the Deque // Function to get the element at the front of the Deque // Throw an error if Deque is empty // Return the data of the front node // Function to get the element at the rear of the Deque // Throw an error if Deque is empty // Return the data of the rear node // Function to check if the Deque is empty // Deque is empty if size is 0 // Function to get the number of elements in the Deque // Return the current size of the Deque // Function to display the elements of the Deque // Print the data of the current node // Push elements to the front and back // Get and display the front and rear elements // Pop elements from the front and back // Display the size of the Deque\n\nFollowing are some of the common applications of deque:\n• None Deque is used to efficiently check if a string is a palindrome by comparing characters from both ends simultaneously.\n• None Deque is used to implement undo/redo operations in text editors and other applications by maintaining a history of actions.\n• None Deque is used to implement forward and backward navigation in web browsers, allowing efficient movement through browsing history.\n• None Deque is used in round-robin scheduling algorithms, where tasks can be added or removed from either end of the queue.\n• None Deque is used to solve sliding window maximum/minimum problems efficiently in algorithmic challenges and data processing.\n• None Deque is used in certain graph traversal algorithms, such as breadth-first search variations that require bidirectional exploration."
    },
    {
        "link": "https://embeddedartistry.com/blog/2017/05/17/creating-a-circular-buffer-in-c-and-c",
        "document": "Due to the resource constrained nature of embedded systems, circular buffer data structures can be found in most projects.\n\nCircular buffers (also known as ring buffers) are fixed-size buffers that work as if the memory is contiguous & circular in nature. As memory is generated and consumed, data does not need to be reshuffled – rather, the head/tail pointers are adjusted. When data is added, the head pointer advances. When data is consumed, the tail pointer advances. If you reach the end of the buffer, the pointers simply wrap around to the beginning.\n\nFor a more detailed summary of circular buffer operation, please refer to the Wikipedia article. The rest of the article assumes you have an understanding of how circular buffers work.\n• Putting It All Together\n\nCircular buffers are often used as fixed-sized queues. The fixed size is beneficial for embedded systems, as developers often try to use static data storage methods rather than dynamic allocations.\n\nCircular buffers are also useful structures for situations where data production and consumption happen at different rates: the most recent data is always available. If the consumer cannot keep up with production, the stale data will be overwritten with more recent data. By using a circular buffer, we can ensure that we are always consuming the most recent data.\n\nFor additional use cases, check out Ring Buffer Basics on Embedded.com.\n\nWe will start with a C implementation, as this exposes us to some of the design challenges and tradeoffs when creating a circular buffer library.\n\nSince we are creating a circular buffer library, we want to make sure users work with our library APIs instead of modifying the structure directly. We also want to keep the implementation contained within our library so we can change it as needed, without requiring end users to update their code. The user doesn’t need to know any details about our structure, only that it exists.\n\nIn of our library header, we will forward declare the structure:\n\nWe don’t want users to work with a pointer directly, as they might get the impression that they can dereference the value. We will create a handle type that they can use instead.\n\nThe simplest approach for our handle is to the as a pointer to the circular buffer. This will prevent us from needing to cast the pointer within our function implementation.\n\nAn alternative approach would be to make the handle a or value. Inside of our interface, we would handle the translation to the appropriate pointer type. We keep the circular buffer type hidden from users, and the only way to interact with the data is through the handle.\n\nWe’re going to stick with the simple handle implementation to keep our example code simple and straightforward.\n\nFirst, we should think about how users will interact with a circular buffer:\n• They need to initialize the circular buffer container with a buffer and size\n• They need to destroy a circular buffer container\n• They need to reset the circular buffer container\n• They need to be able to add data to the buffer\n• They need to be able to get the next value from the buffer\n• They need to know whether the buffer is full or empty\n• They need to know the current number of elements in the buffer\n• They need to know the max capacity of the buffer\n\nUsing this list, we can put together an API for our library. Users will interact with the circular buffer library using our opaque handle type, which is created during initialization.\n\nI have chosen as the underlying data type in this implementation. You can use any particular type that you like – just be careful to handle the underlying buffer and number of bytes appropriately.\n\nBefore we proceed, we should take a moment to discuss the method we will use to determine whether or buffer is full or empty.\n\nBoth the “full” and “empty” cases of the circular buffer look the same: and pointer are equal. There are two approaches to differentiating between full and empty:\n• Use a flag and additional logic to differentiate states::\n\nWe should also consider thread safety. By using a single empty cell to detect the “full” case, we can support a single producer and single consumer without a lock (as long as and don’t modify the same variables). The queue is thread-safe because the producer will only modify the index, and the consumer will only modify the index. While either index might be slightly out-of-date in a given context, this will not impact the thread safety of the queue. Using the flag, however, creates a requirement for mutual exclusion. This is because the flag is shared by both the producer and consumer.\n\nOf course, the decision has its tradeoffs. If your buffer element has a large memory footprint (such as a buffer that is sized for a camera i-frame), wasting a slot may not be reasonable on your system. If you have multiple producers/consumers interacting with a queue, you will need a lock anyway, so wasting a slot doesn’t make sense. If you do not have mutual exclusion available (e.g., because you’re not using an OS) but you are using interrupts, then you will want to use the version without the full flag. The memory model used on your system may also have an impact on your decision to go without a lock.\n\nThe implementation below uses the flag. Using the flag requires additional logic in the and routines to update the flag. I will also describe how to make the modifications for a single producer/consumer that does not use the flag.\n\nNow that we have a grasp on the operations we’ll need to support, we can design our circular buffer container.\n\nWe use the container structure for managing the state of the buffer. To preserve encapsulation, the container structure is defined inside of our library file, rather than in the header.\n\nWe will need to keep track of:\n• The maximum size of the buffer\n• The current “head” position (incremented when elements are added)\n• The current “tail” (incremented when elements are removed)\n• A flag indicating whether the buffer is full or not\n\nNow that our container is designed, we are ready to implement the library functions.\n\nOne important detail to note is that each of our APIs requires an initialized buffer handle. Rather than litter our code with conditional statements, we will utilize assertions to enforce our API requirements in the “Design by Contract” style.\n\nIf the interfaces are improperly used, the program will fail immediately rather than requiring the user to check and handle the error code.\n\nAnother important note is that the implementation shown below is not thread-safe. No locks have been added to the underlying circular buffer library.\n\nLet’s start at the beginning: initializing a circular buffer. Our API has clients provide the underlying buffer and buffer size, and we return a circular buffer handle to them. The reason we want our users to provide the buffer is that this allows for a statically allocated buffer. If our API created the buffer under the hood, we would need to make use of dynamic memory allocation, which is often disallowed in embedded systems programs.\n\nWe are required to provide a circular buffer structure instance within the library so that we can return a pointer to the user. I have used for simplicity. Systems which cannot use dynamic memory simply need to modify the function to use a different method, such as allocation from a static pool of pre-allocated circular buffer structures.\n\nAnother approach would be to break encapsulation, allowing users to statically declare circular buffer container structures outside of the library. In this case, needs to be updated to take a struct pointer. We could also have our function create a container structure on the stack and return it wholesale. However, since encapsulation is broken, users will be able to modify the structure without using the library routines. If you want to preserve encapsulation, you need to work with pointers instead of concrete structure instances.\n\nWe will be returning a handle to a structure that is allocated inside of the library. Once we’ve created our container, we need populate the values and call on it. Before we return from , we ensure that the buffer container has been created in an empty state.\n\nThe purpose of the reset function is to put the buffer into an “empty” state, which requires updating , , and :\n\nSince we have a method to create a circular buffer container, we need an equivalent method for destroying the container. In this case, we call on our container. We do not attempt to free the underlying buffer, since we do not own it.\n\nNext, we’ll implement the functions related to the state of the buffer container.\n\nThe full function is the easiest to implement, since we have a flag representing the state:\n\nSince we have the flag to differentiate between full or empty state, we combine the flag with a check that :\n\nThe capacity of our buffer was supplied during initialization, so we just return that value to the user:\n\nCalculating the number of elements in the buffer was a trickier problem than I expected. Many proposed size calculations use modulo, but I ran into strange corner cases when testing that out. I opted for a simplified calculation using conditional statements.\n\nIf the buffer is full, we know that our capacity is at the maximum. If is greater-than-or-equal-to the , we simply subtract the two values to get our size. If is greater than , we need to offset the difference with to get the correct size.\n\nWith the bookkeeping functions out of the way, it’s time to dig into the meat: adding and removing data from the queue.\n\nAdding and removing data from a circular buffer requires manipulation of the and pointers. When adding data to the buffer, we insert the new value at the current location, then we advance . When we remove data from the buffer, we retrieve the value of the current pointer and then advance .\n\nAdding data to the buffer requires a bit more thought, however. If the buffer is , we need to advance our pointer as well as . We also need to check whether inserting a value triggers the condition.\n\nWe are going to implement two versions of the function, so let’s extract our pointer advancement logic into a helper function. If our buffer is already full, we advance . We always advance by one. After the pointer has been advanced, we populate the flag by checking whether .\n\nNote the use of the modulo operator ( ) below. Modulo will cause the and values to reset to 0 when the maximum size is reached. This ensures that and are always valid indices of the underlying data buffer.\n\nAs Miro Samek helpfully pointed out, this is an expensive computational operation. Instead, we can use conditional logic to reduce the total number of instructions. Miro’s recommended approach is:\n\nNow, will look like this:\n\nWe can make a similar helper function which is called when removing a value from the buffer. When we remove a value, the flag is set to , and the tail pointer is advanced.\n\nWe’ll create two versions of the function. The first version inserts a value into the buffer and advances the pointer. If the buffer is full, the oldest value will be overwritten. This is the standard use case for a circular buffer\n\nThe second version of the function returns an error if the buffer is full. This is provided for demonstration purposes, but we do not use this variant in our systems.\n\nTo remove data from the buffer, we access the value at the and then update the pointer. If the buffer is empty we do not return a value or modify the pointer. Instead, we return an error to the user.\n\nThat completes the implementation of our circular buffer library.\n\nWhen using the library, the client is responsible for creating the underlying data buffer to , and a is returned:\n\nThis handle is used to interact with all remaining library functions:\n\nDon’t forget to free both the underlying data buffer and the container when you are done:\n\nA test program which uses the circular buffer library can be found in the embedded-resources repository.\n\nIf you wanted to ditch the flag, you would instead check that the is one position behind the tail to determine if the buffer is full:\n\nNow, if we wanted to avoid the modulo operation, we can use conditional logic instead:\n\nThe empty case is then that and are the same:\n\nWhen getting data from the buffer, we will advance the tail pointer, wrapping around if necessary:\n\nWhen adding data to the buffer, we will store the data and advance the head pointer, wrapping around if necessary:\n\nOther references to can be eliminated.\n\nC++ lends itself to a cleaner circular buffer implementation than C.\n\nWe’ll start off by defining our C++ class. We want our C++ implementation to support any type of data, so we are going to make it a templated class.\n\nOur APIs are going to be similar to the C implementation. Our class will provide interfaces for:\n• Checking the current number of elements in the buffer\n• Checking the total capacity of the buffer\n\nWe will also utilize C++ smart pointers to ensure sure we don’t leave any data around once our buffer is destroyed. This means we can manage the buffer for the user.\n\nAnother benefit of C++ is the triviality of making this class thread-safe: we can rely on the type (assuming this is defined for your platform).\n\nOur C++ circular buffer mimics much of the logic from the C implementation, but results in a much cleaner and more reusable design. Also, the C++ buffer utilizes to provide a thread-safe implementation.\n\nWhen constructing our class, we allocate the data for our underlying buffer and set the buffer size. This removes the overhead required with the C implementation.\n\nUnlike the C implementation, the C++ constructor does not call . Because we specify initial values for our member variables, our circular buffer starts out in the correct state.\n\nOur reset behavior puts the buffer back to an empty state ( ).\n\nThe logic of the and cases is the same as the C example:\n\nIn the C++ circular buffer implementation, and report the number of elements in the queue rather than the size in bytes. This allows us to be agnostic to the underlying details of the type.\n\nThe logic for matches the C implementation. This implementation uses the “overwrite the oldest value” behavioral pattern.\n\nThe logic behind matches the C implementation. Unlike the C implementation, an empty value is returned if the buffer is empty.\n\nThe C++ circular buffer is much simpler to use than the C implementation.\n\nTo instantiate a circular buffer, we just declare an object and specify the templated type for our buffer. Here’s an example using a buffer of 10 entries:\n\nAnd getting data is equally easy:\n\nRemember that since this is a templated class, you can create a circular buffer of any type that you need.\n\nIn C++17, we have access to , which enables us to represent a value that may or may not be present. Our function would return a . We would also return instead of a default-constructed if the queue is empty.\n\nIn the calling code, you could check for a valid value using the boolean operator or the member function. If a valid value is present, it can be accessed using the or operators, ur using the member function.\n\nPutting it All Together\n\nExample implementations can be found in the Github repository.\n\nIf you are looking to extend this library, a useful exercise is to add additional APIs to enable users to add/remove multiple elements with a single operation. You can also make the C implementation thread-safe.\n\nOne approach for thread-safety without a mutex is the “lookahead” method. This method supports a single producer thread and single consumer thread; multiple producers or consumers will require a lock.\n\nInstead of using the boolean flag to differentiate between the full and empty cases, we will always leave one cell empty. By using a single empty cell to detect the “full” case, we can support a single producer and single consumer without a lock (as long as and don’t modify the same variables).\n\nYou may be concerned about wasting a slot, but this tradeoff is often much cheaper than the cost of using an OS lock primitive.\n\nHere are other circular buffer implementations:\n\nFor more information on circular buffers:\n• C++: Performance of a Circular Buffer vs Vector, Deque, and List\n\nThere is a proposal for adding a circular buffer type to the C++ standard library:\n• P0059: A Proposal to Add Ring Span to the Standard Library\n• 20210321\n• Fixed error with where should have been used\n• Added clarifying text regarding why the buffer is passed in by the user\n• 20210213\n• Added further discussion about tradeoff between full flag vs using a “wasted” slot\n• Add notes on use with C++17\n• 20191016\n• Updated Major Revisions section formatting for consistency across the site\n• Demoted headers for consistency across the site\n• 20190604\n• Fixed a typo (thanks Chris Svec!) and changed some wording related to the opaque type.\n• 20181219\n• Added note about avoiding concurrency problems with a single producer and single consumer using an empty slot.\n• 20180804\n• The article was restructured and rewritten.Thanks to everyone who provided feedback along the way. The examples have been updated to:\n• Expand the APIs, including a calculation for the current circular buffer size\n• Update the library so it didn’t waste a slot"
    }
]