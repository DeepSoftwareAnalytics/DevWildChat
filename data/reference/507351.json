[
    {
        "link": "https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-changedisplaysettingsexa",
        "document": "The ChangeDisplaySettingsEx function changes the settings of the specified display device to the specified graphics mode.\n\nA pointer to a null-terminated string that specifies the display device whose graphics mode will change. Only display device names as returned by EnumDisplayDevices are valid. See EnumDisplayDevices for further information on the names associated with these display devices.\n\nThe lpszDeviceName parameter can be NULL. A NULL value specifies the default display device. The default device can be determined by calling EnumDisplayDevices and checking for the DISPLAY_DEVICE_PRIMARY_DEVICE flag.\n\nA pointer to a DEVMODE structure that describes the new graphics mode. If lpDevMode is NULL, all the values currently in the registry will be used for the display setting. Passing NULL for the lpDevMode parameter and 0 for the dwFlags parameter is the easiest way to return to the default mode after a dynamic mode change.\n\nThe dmSize member must be initialized to the size, in bytes, of the DEVMODE structure. The dmDriverExtra member must be initialized to indicate the number of bytes of private driver data following the DEVMODE structure. In addition, you can use any of the following members of the DEVMODE structure.\n\nIn addition to using one or more of the preceding DEVMODE members, you must also set one or more of the following values in the dmFields member to change the display settings.\n\nIndicates how the graphics mode should be changed. This parameter can be one of the following values.\n\nSpecifying CDS_TEST allows an application to determine which graphics modes are actually valid, without causing the system to change to them.\n\nIf CDS_UPDATEREGISTRY is specified and it is possible to change the graphics mode dynamically, the information is stored in the registry and DISP_CHANGE_SUCCESSFUL is returned. If it is not possible to change the graphics mode dynamically, the information is stored in the registry and DISP_CHANGE_RESTART is returned.\n\nIf CDS_UPDATEREGISTRY is specified and the information could not be stored in the registry, the graphics mode is not changed and DISP_CHANGE_NOTUPDATED is returned.\n\nIf dwFlags is CDS_VIDEOPARAMETERS, lParam is a pointer to a VIDEOPARAMETERS structure. Otherwise lParam must be NULL.\n\nThe ChangeDisplaySettingsEx function returns one of the following values.\n\nTo ensure that the DEVMODE structure passed to ChangeDisplaySettingsEx is valid and contains only values supported by the display driver, use the DEVMODE returned by the EnumDisplaySettings function.\n\nWhen adding a display monitor to a multiple-monitor system programmatically, set DEVMODE.dmFields to DM_POSITION and specify a position (in DEVMODE.dmPosition) for the monitor you are adding that is adjacent to at least one pixel of the display area of an existing monitor. To detach the monitor, set DEVMODE.dmFields to DM_POSITION but set DEVMODE.dmPelsWidth and DEVMODE.dmPelsHeight to zero. For more information, see Multiple Display Monitors.\n\nWhen the display mode is changed dynamically, the WM_DISPLAYCHANGE message is sent to all running applications with the following message parameters.\n\nTo change the settings for more than one display at the same time, first call ChangeDisplaySettingsEx for each device individually to update the registry without applying the changes. Then call ChangeDisplaySettingsEx once more, with a NULL device, to apply the changes. For example, to change the settings for two displays, do the following:\n\nThis API does not participate in DPI virtualization. The input given is always in terms of physical pixels, and is not related to the calling context."
    },
    {
        "link": "https://stackoverflow.com/questions/195267/use-windows-api-from-c-sharp-to-set-primary-monitor",
        "document": "I ran into exactly the same problem, both from C# and after following the advice here to try it in C++. I eventually discovered that the thing the Microsoft documentation doesn't make clear is that the request to set the primary monitor will be ignored (but with the operation reported as successful!) unless you also set the position of the monitor to (0, 0) on the DEVMODE struct. Of course, this means that you also need to shift the positions of your other monitors so that they stay in the same place relative to the new primary monitor. Per the documentation (http://msdn.microsoft.com/en-us/library/windows/desktop/dd183413%28v=vs.85%29.aspx), call ChangeDisplaySettingsEx for each monitor with the CDS_NORESET flag and then make a final call with everything null.\n\nThe following code worked for me:\n\nNote that a signature for ChangeDisplaySettingsEx with a DEVMODE struct as the second parameter obviously won't allow you to pass in IntPtr.Zero. Create yourself two different signatures for the same extern call, i.e."
    },
    {
        "link": "https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-changedisplaysettingsexw",
        "document": "The ChangeDisplaySettingsEx function changes the settings of the specified display device to the specified graphics mode.\n\nA pointer to a null-terminated string that specifies the display device whose graphics mode will change. Only display device names as returned by EnumDisplayDevices are valid. See EnumDisplayDevices for further information on the names associated with these display devices.\n\nThe lpszDeviceName parameter can be NULL. A NULL value specifies the default display device. The default device can be determined by calling EnumDisplayDevices and checking for the DISPLAY_DEVICE_PRIMARY_DEVICE flag.\n\nA pointer to a DEVMODE structure that describes the new graphics mode. If lpDevMode is NULL, all the values currently in the registry will be used for the display setting. Passing NULL for the lpDevMode parameter and 0 for the dwFlags parameter is the easiest way to return to the default mode after a dynamic mode change.\n\nThe dmSize member must be initialized to the size, in bytes, of the DEVMODE structure. The dmDriverExtra member must be initialized to indicate the number of bytes of private driver data following the DEVMODE structure. In addition, you can use any of the following members of the DEVMODE structure.\n\nIn addition to using one or more of the preceding DEVMODE members, you must also set one or more of the following values in the dmFields member to change the display settings.\n\nIndicates how the graphics mode should be changed. This parameter can be one of the following values.\n\nSpecifying CDS_TEST allows an application to determine which graphics modes are actually valid, without causing the system to change to them.\n\nIf CDS_UPDATEREGISTRY is specified and it is possible to change the graphics mode dynamically, the information is stored in the registry and DISP_CHANGE_SUCCESSFUL is returned. If it is not possible to change the graphics mode dynamically, the information is stored in the registry and DISP_CHANGE_RESTART is returned.\n\nIf CDS_UPDATEREGISTRY is specified and the information could not be stored in the registry, the graphics mode is not changed and DISP_CHANGE_NOTUPDATED is returned.\n\nIf dwFlags is CDS_VIDEOPARAMETERS, lParam is a pointer to a VIDEOPARAMETERS structure. Otherwise lParam must be NULL.\n\nThe ChangeDisplaySettingsEx function returns one of the following values.\n\nTo ensure that the DEVMODE structure passed to ChangeDisplaySettingsEx is valid and contains only values supported by the display driver, use the DEVMODE returned by the EnumDisplaySettings function.\n\nWhen adding a display monitor to a multiple-monitor system programmatically, set DEVMODE.dmFields to DM_POSITION and specify a position (in DEVMODE.dmPosition) for the monitor you are adding that is adjacent to at least one pixel of the display area of an existing monitor. To detach the monitor, set DEVMODE.dmFields to DM_POSITION but set DEVMODE.dmPelsWidth and DEVMODE.dmPelsHeight to zero. For more information, see Multiple Display Monitors.\n\nWhen the display mode is changed dynamically, the WM_DISPLAYCHANGE message is sent to all running applications with the following message parameters.\n\nTo change the settings for more than one display at the same time, first call ChangeDisplaySettingsEx for each device individually to update the registry without applying the changes. Then call ChangeDisplaySettingsEx once more, with a NULL device, to apply the changes. For example, to change the settings for two displays, do the following:\n\nThis API does not participate in DPI virtualization. The input given is always in terms of physical pixels, and is not related to the calling context."
    },
    {
        "link": "https://stackoverflow.com/questions/61429285/enable-a-disabled-screen-using-changedisplaysettingsex",
        "document": "I'm using WinAPI ChangeDisplaySettingsEx to switch my windows 10 screens config. \n\n There are more than two screens, so ScreenSwitch.exe is not enough for me.\n\nhttps://www.codeproject.com/Articles/178027/How-to-create-a-display-switcher-for-Windows-XP?msg=3850767#xx3850767xx \n\n \n\n and successed disable a screen in these code:\n\nChangeDisplaySettingsEx got -1 result means CHANGE_FAILED \n\n \n\n I guess that screen has disabled, so enable it need more information? \n\n \n\n I tried save DEVMODE when the screen enabled, and send it to ChangeDisplaySettingsEx when screen disabled. Not works. \n\n \n\n Thanks for any suggest"
    },
    {
        "link": "http://pinvoke.net/default.aspx/user32/ChangeDisplaySettingsEx.html",
        "document": "Type a page name and press Enter. You'll jump to the page if it exists, or you can create it if it doesn't.\n\n To create a page in a module other than user32, prefix the name with the module name and a period. <DllImport(\"user32.dll\")> _\n\n Private Shared Function ChangeDisplaySettingsEx(ByVal lpszDeviceName As String, ByRef lpDevMode As DEVMODE, ByVal hwnd As IntPtr, ByVal dwflags As UInteger, ByVal lParam As IntPtr) As DISP_CHANGE\n\n End Function\n\n \n\n To change the postion of a secondary device it is very important to use dmPositionX and dmPositionY from DEVMODE (see structs). First i tried it with a PointL struct dmPosition.x and dmPosition.y until i luckily found this page: DISPLAY_DEVICE d = new DISPLAY_DEVICE();\n\n DEVMODE dm = new DEVMODE(); \n\n d.cb = Marshal.SizeOf(d);\n\n int deviceID=1; // This is only for my device setting. Go through the whole EnumDisplayDevices to find your device \n\n EnumDisplayDevices(null,deviceID, ref d, 0); // \n\n EnumDisplaySettings(d.DeviceName, 0, ref dm);\n\n dm.dmPelsWidth = 1024;\n\n dm.dmPelsHeight = 768;\n\n dm.dmPositionX = Screen.PrimaryScreen.Bounds.Right;\n\n dm.dmFields = DM.Position | DM.PelsWidth | DM.PelsHeight;\n\n ChangeDisplaySettingsEx(d.DeviceName, ref dm, IntPtr.Zero, CDS_UPDATEREGISTRY, IntPtr.Zero);\n\n \n\n Do you know one? Please contribute it! Contains information about the initialization and environment of a printer or a display device. Changes the display settings via a DEVMODE struct.\n• helpful tips or sample code to share for using this API in managed code?\n• variations of the signature you want to share?\n• additional languages you want to include? Select \"Edit This Page\" on the right hand toolbar and edit it! Or add new pages containing supporting types needed for this API (structures, delegates, and more)."
    },
    {
        "link": "https://stackoverflow.com/questions/15897847/how-to-change-screen-resolution-programmatically",
        "document": "Changing the resolution is more difficult.\n\nThis CodeProject describes how to do it in C# http://www.codeproject.com/KB/dotnet/changing-display-settings.aspx and you can use this\n\nfollowing website to help you translate the C# code to VB http://www.developerfusion.com/tools/convert/csharp-to-vb/"
    },
    {
        "link": "https://stackoverflow.com/questions/4678733/how-to-change-screen-resolution-when-application-launches",
        "document": "i am working on a POS applciation with WPF,C#, SQLCE , VS 2010 . I created a bill entry form with fixed window of 800 * 600 width and height.\n\nbut other windows in the project are made to work with system resolutions. now i want to change the system resolution to 800*600 when this bill entry form opens in My POS application . For reporting and maintenance of Stocks & Inventory i used rich UI Controls with Window size maximazed but for BILL ENTRY FORM ( considering my needs) i kept its window size to 800*600 . when i open the form it looks very small in 1440*900 resolution. so i want to change system resolution to 800*600 whn this window opens and when this window closes it should return back to 1400*900 resolution .. is there any way to do this"
    },
    {
        "link": "https://learn.microsoft.com/en-us/answers/questions/252411/how-to-scale-wpf-application-according-to-screen-r",
        "document": "An object-oriented and type-safe programming language that has its roots in the C family of languages and includes support for component-oriented programming."
    },
    {
        "link": "https://codeproject.com/Articles/36664/Changing-Display-Settings-Programmatically",
        "document": "Learn how to change display settings programmatically via an API and the .NET Framework.\n\nToday, we are talking about how to change display settings via an API. We will change the screen resolution (bounds,) color system (bit count), rotation (orientation), and refresh rate (frequency) via an API with C# and the .NET Framework.\n\nThis article firstly discusses the required functions and structures. Then, it focuses on how to retrieve the current display settings. After that, it discusses how to get all the modes supported by your display. As you already know, a mode is a combination of many display settings including bounds, bit count, orientation, and frequency; therefore, we will refer to display settings as display modes.\n\nFinally, this article discusses how to change the current display settings. Along with the discussion, you will learn additional techniques like how to PInvoke Win32 API functions and to marshal unmanaged data types.\n\nThis article also comes with a sample application used for changing the display settings.\n\nNow, we are going to discuss the required functions and structures and how to use them. After that, we will focus on the implementation code. Get ready.\n\nThis function resides in user32.dll. It is used to retrieve one of the modes supported by a graphics device.\n\nThe definition of this function is as follows:\n\nThis function accepts only three parameters:\n• : Specifies the display device name that will be used to retrieve its modes. This parameter can be either to indicate the default device, or the name of the display device. You can enumerate display devices using the function.\n• : Specifies the type of information to retrieve. It could be either a mode index or one of these values:\n• = -2: Retrieves the current display mode stored in the Registry.\n• : A reference (In/Out) parameter representing the object that encapsulates the retrieved display mode information. The 's member is used for input to represent the structure size, while other members are used for output.\n\nAs you might expect, to retrieve the current mode (settings) of the current display device, you will need to pass a value as the parameter to indicate the current display, and the value -1 to the parameter to indicate the current mode.\n\nUnfortunately, can return only one mode per call, and that mode is encapsulated into the object. To retrieve all modes (or a few) supported by a display device, you need to call many times specifying as the mode index. Mode indexes start from zero. Therefore, to retrieve all modes, you will need to call the function many times, specifying 0 for on the first time, and increment that index in every call until returns , which indicates that the previous mode was the last mode supported.\n\nIf you want to retrieve a mode (or all modes) supported by other display devices, you will need to change to the name of that device. You can get a list of all devices connected using the function.\n\nNow, it is the time for the PInvoke method. We can PInvoke this function in C# as follows:\n\nWhat is Platform Invocation (PInvoke)? You already know, there is no compatibility between managed code (.NET) and unmanaged code (Win32 API, in our case.) Therefore, they cannot call each other directly. Rather, you make use of the PInvoke service to call unmanaged functions from the managed environment.\n\nWhat is Marshaling? Marshaling is another service of the CLR. Again, there is no compatibility between managed code and unmanaged code. Therefore, they cannot communicate directly. To send data between a managed client and an unmanaged server, and vice versa, you will need to use marshaling to allow sending and receiving the data. Marshaling converts managed data types to unmanaged data and vice versa.\n\nNow, we will talk about the structure.\n\nThis structure encapsulates information about a printer or a display device. This is a fairly complex structure, but we will try to break it down to be simple and easier to marshal. The definition of this structure is as follows:\n\nReally complex, isn't it? Yeah, is one of the largest and most complex structures.\n\nYou might have noticed the two unions defined inside the structure. In addition, a structure is defined inside the first union - note that this structure is only available if it is a printer device. Plus, the union defined in the structure is for printer devices only. Therefore, for display devices, you can omit the structure and define other members of the union sequentially, no additional work is required.\n\nIn addition, the last eight members are not supported by Windows NT, while the last two members are not supported by Windows ME and its ascendants. To solve this dilemma and support all versions, you can define three versions of the structure: one for Windows ME and its ascendants, one for Windows NT, and the last for Windows 2000 and higher versions. In addition, you will need to create three overloads of the function for the three structures. For simplicity, we will marshal the whole structure for Windows 2000 and higher versions.\n\nNotice that there are arrays that are defined with the length which equals 32.\n\nLast but not least, the second union of structures defines two members inside: and . For simplicity, we will take away the union and one of its members and define the other. Because both members are 4-bytes wide, we can omit anyone of them.\n\nWe can marshal that structure in C# as follows:\n\nWe will cover the structure soon.\n\nActually, these dozens of attributes are not all required. Honestly, it is not required for marshaling into because they are counterparts. On the other hand, the attribute must be applied to arrays.\n\nFrom all of those members, we are interested only in a few:\n• and : Represent the bounds (width and height) of the display. These values can be used to determine whether the display orientation is portrait or landscape.\n• : Represents the bit count (color system) of the display.\n• : Represents the orientation (rotation) of the display. This member can be one of these values:\n• = 0: The display is in the natural orientation. It is the default.\n• = 1: The display is rotated 90 degrees (measured clockwise) from .\n• = 2: The display is rotated 180 degrees (measured clockwise) from .\n• = 3: The display is rotated 270 degrees (measured clockwise) from .\n• : Represents the frequency (refresh rate) of the display.\n\nThe 's member represents the location of the display device in reference to the desktop area. It is always located at (0, 0). This member is of the structure which represents the coordinates (x and y) of a point. As you might expect, this structure is very simple. It is defined as follows:\n\nWe can marshal this structure easily, as follows:\n\nHowever, for code clarity, we have a workaround. You can omit the structure and replace the member with two members; you can call them and , and that will work fine because you know that the size and layout (position of members) of structures is very important. And, doing that will not break this rule.\n\nThis function resides in user32.dll. It is used to change the display settings to the mode specified, but only if the mode is valid.\n\nThe definition of this function is as follows:\n\nThis function accepts only two arguments:\n• : A reference (In/Out) argument of the type that represents the new settings (mode) that will be applied to the display device. After retrieving the current settings using the function, you can change the desired members of the object and use this function to change the display device to the new settings. Again, this argument is an In/Out argument, which means that it is used for input and output. 's member is used for input, and other members are used for output.\n• : Indicates how the mode should be changed. Actually, in this example, we are not interested in this argument, so we will set it to zero. If you want more help on this argument, consult the MSDN documentation.\n\nThe return value of this function varies based on the success or failure of the settings change. This function can return one of several values including:\n• = 0: Indicates that the function succeeded.\n• = -2: The graphics mode is not supported.\n• = -1: The display driver failed the specified graphics mode.\n• = 1: The computer must be restarted for the graphics mode to work.\n\nConsult the MSDN documentation to know more about the return value. The last section of this article is devoted for this.\n\nAnother point of interest is that only changes the default display. If you want to change another display device, you can use the function. It is very similar to . Consult the MSDN documentation for more help.\n\nNow, it is time for creating the PInvoke method for the function.\n\nNow, we are going to mix things together and talk about the implementation code. Get ready.\n\nThe code that obtains the current display settings is very easy. We use the function, passing it (-1) in the parameter to get the current settings, and in the parameter to indicate the current display device.\n\nHere is the code (code abbreviated for clarity):\n\nAs a refresher, to get the current mode or even another supported mode of the display device, you make use of the function. If you pass (-1) in the parameter, you get the current mode. On the other hand, you can enumerate through the list of supported modes by passing the mode index in this parameter. We start by 0, which indicates the first mode, and increment it in every call to enumerate through the list of supported modes. If the function returns , that means that the mode with the index specified is not found. Therefore, the previous mode was the last one. Here is the code.\n\nNow, we are going to change the current display settings. This can be done through the function.\n\nThe following code example loads the current settings and changes only the resolution and the bit count. Actually, you are free to change all the settings or a few of them; that is up to you. However, for the sake of simplicity, we are going to change the screen resolution and bit count in this section, and the orientation in the next section.\n\nNow, we are going to change the screen orientation clockwise and anti-clockwise.\n\nThe code sample is a simple application used to change the display settings and to rotate the screen. It is available for download using the link at the top of this article.\n\nIt is a pleasure receiving your feedback and comments."
    },
    {
        "link": "https://vbforums.com/showthread.php?348114-Change-Screen-Resolution-in-NET",
        "document": "\n• I write all of my code in 1024x768 since that is the default for XP. However, not everyone has XP (this is 2005 right?) and even some that do still choose to use 800x600. I scoured the net and asked fellow programers and few had any good solutions. I found a little code in C# and a lot in VB6, nothing good for .Net. So, I took what I could find on the net, converted some C# into VB.Net, had some help from co-workers, and added some of my own and got something that works really good, with minimal effort.\n\n \n\n This code will check the current screen resolution to determine if it is 1024x768 (you can use any resolution here). If it is not, then it will prompt the user and change the resolution on their pc for them, and change it back when the program exits. \n\n \n\n Create this class, I called it Resolution.vb.\n• None Public Shared Function EnumDisplaySettings(ByVal deviceName As String, ByVal modeNum As Integer, ByRef devMode As DEVMODE1) As Integer\n• None Public Shared Function ChangeDisplaySettings(ByRef devMode As DEVMODE1, ByVal flags As Integer) As Integer\n• None Public Sub New(ByVal a As Integer, ByVal b As Integer)\n• None If Not (0 = User_32.EnumDisplaySettings(Nothing, User_32.ENUM_CURRENT_SETTINGS, dm)) Then\n• None MessageBox.Show(\"Description: Unable To Process Your Request. Sorry For This Inconvenience.\", \"Information\", MessageBoxButtons.OK, MessageBoxIcon.Information)\n• None MessageBox.Show(\"Description: You Need To Reboot For The Change To Happen.\" & Microsoft.VisualBasic.Chr(10) & \" If You Feel Any Problem After Rebooting Your Machine\" & Microsoft.VisualBasic.Chr(10) & \"Then Try To Change Resolution In Safe Mode.\", \"Information\", MessageBoxButtons.OK, MessageBoxIcon.Information) \n\n Then I put this in my main menu form (you can put it where ever).\n• None Private Sub mainmenu_Load(ByVal sender As System.Object, ByVal e As System.EventArgs) Handles MyBase.Load\n• None If XRes <> 1024 And YRes <> 768 Then\n• None MsgBox(\"Screen resolution must be changed to 1024x768 to properly view the application\") \n\n Then I used this to set the resolution back when the program quits.\n• None Private Sub mainmenu_Closing(ByVal sender As Object, ByVal e As System.ComponentModel.CancelEventArgs) Handles MyBase.Closing\n• None MsgBox(\"This will change your screen size back to it's original resolution\") End Sub\n• You may not post new threads\n• You may not post replies\n• You may not post attachments\n• You may not edit your posts\n\n\n\n \n\n \n\n Click Here to Expand Forum to Full Width"
    }
]