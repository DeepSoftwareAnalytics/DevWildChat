[
    {
        "link": "https://github.com/bdsx/bdsx",
        "document": "BDSX is a modification of Minecraft Bedrock Dedicated Server, supporting node.js. Because it is based on the offical BDS software, it includes all the features of vanilla Minecraft, but includes other features as well, such as hooking functions and packets to change behavior.\n• All node.js features (*that are supported by ChakraCore. See this page for more information)\n• Debug with Visual Studio Code (You can debug plugins too)\n• Get IP Address & XUID (Example below)\n• Requirements\n• node.js Please make sure your node is up to date.\n\nWhen starting BDSX with VSCode, you need to\n• Install the legacy debugger. the suggestion dialog will be opened up on the right bottom corner.\n• Press to build and run in VSCode\n\nRun (or on Linux) to start BDSX\n• Use to compile the typescript and use in the directory. If on Linux, use instead.\n\n[bdsx project] ├ [bdsx] ├ [example_and_test] Examples for using the BDSX API and tests of the BDSX API ├ [bedrock_server] ├ launcher.ts ├ index.ts Main entry point. This file is required by the launcher when BDS is fully started. ├ bdsx.sh └ bdsx.bat\n\nFor examples, see the folder. There are some plugins available on npm in the @bdsx organization as well."
    },
    {
        "link": "https://github.com/bdsx/bdsx/blob/master/README.md",
        "document": "BDSX is a modification of Minecraft Bedrock Dedicated Server, supporting node.js. Because it is based on the offical BDS software, it includes all the features of vanilla Minecraft, but includes other features as well, such as hooking functions and packets to change behavior.\n• All node.js features (*that are supported by ChakraCore. See this page for more information)\n• Debug with Visual Studio Code (You can debug plugins too)\n• Get IP Address & XUID (Example below)\n• Requirements\n• node.js Please make sure your node is up to date.\n\nWhen starting BDSX with VSCode, you need to\n• Install the legacy debugger. the suggestion dialog will be opened up on the right bottom corner.\n• Press to build and run in VSCode\n\nRun (or on Linux) to start BDSX\n• Use to compile the typescript and use in the directory. If on Linux, use instead.\n\n[bdsx project] ├ [bdsx] ├ [example_and_test] Examples for using the BDSX API and tests of the BDSX API ├ [bedrock_server] ├ launcher.ts ├ index.ts Main entry point. This file is required by the launcher when BDS is fully started. ├ bdsx.sh └ bdsx.bat\n\nFor examples, see the folder. There are some plugins available on npm in the @bdsx organization as well."
    },
    {
        "link": "https://wsj.com/public/resources/documents/7a7j90E3xfeCo7a6Z0EP-WSJNewsPaper-1-2-2025.pdf",
        "document": ""
    },
    {
        "link": "https://jimp-dev.github.io/jimp",
        "document": "Jimp is just JavaScript, so you can use it in anywhere that JavaScript can be used."
    },
    {
        "link": "https://npmjs.com/package/jimp",
        "document": "An image processing library for Node written entirely in JavaScript, with zero native dependencies."
    },
    {
        "link": "https://github.com/jimp-dev/jimp",
        "document": "If you want to extend jimp or omit types or functions visit @jimp/custom.\n\nThanks goes to these wonderful people (emoji key):\n\nThis project follows the all-contributors specification. Contributions of any kind welcome!"
    },
    {
        "link": "https://blog.logrocket.com/image-processing-with-node-and-jimp",
        "document": "If your web application supports user-uploaded images, you probably need to transform them to fit the design specification of your app.\n\nJavaScript Image Manipulation Program (Jimp) allows you to easily manipulate and transform your images into any required format, style, or dimension. It also optimizes images for minimal file size, ensures high visual quality for an improved user experience, and reduces bandwidth.\n\nWith Jimp, you can resize and crop images, convert them to the image format that fits your needs, and apply filters and effects. In this tutorial, we’ll go over how the library works and describe some common use cases for Jimp image manipulation.\n\nJimp can only be used on a limited range of image formats. Before you start working with the library, you’ll want to make sure it supports the formats you plan to include in your app.\n\nJimp offers both callback- and Promise-based APIs for manipulating images. For the purpose of this post, we’ll use Jimp’s Promise API.\n\n​​The static ​ method accepts an image as an input. The input could be the location of an image file in the file system, a web address (URL), dimension (width and height), Jimp instance, or buffer. Then, it returns a Promise.\n\nJimp’s method alters the height and/or width of an image via a two-pass bilinear algorithm.\n\ncan be passed as the value for the height or width and the image will be resized accordingly while maintaining aspect ratio. You cannot pass as the value for both height and width.\n\nIf no resizing algorithm is passed, Jimp uses as the default resizing algorithm. Other resizing algorithms that Jimp allows include:\n\nThe function is used to crop an image to specified and coordinates and dimensions.\n\nThe method rotates an image clockwise by a given number of degrees. The dimensions of the image remain the same.\n\nThe method flips an image either horizontally or vertically. The default setting is to flip the image horizontally.\n\nThe method multiplies the opacity of each pixel by a factor within the range of 0 and 1.\n\nThe greyscale modifier desaturates or removes color from an image and turns it to grayscale.\n\nThe method blurs an image by pixels using a blur algorithm that produces an effect similar to a Gaussian blur, only much faster.\n\nThe method overlays an image over another Jimp image at , .\n\nYou can write text on an image with the API. Jimp supports only the Bitmap font format (.fnt). Fonts in other formats must be converted to .fnt to be compatible with Jimp.\n\nWe’ve only scratched the surface of use cases for Jimp. If you’re considering using Jimp as your primary image processor, check out the full documentation on the official GitHub and npm pages.\n\n200s only Monitor failed and slow network requests in production Deploying a Node-based web app or website is the easy part. Making sure your Node instance continues to serve resources to your app is where things get tougher. If you’re interested in ensuring requests to the backend or third-party services are successful, try LogRocket. LogRocket is like a DVR for web and mobile apps, recording literally everything that happens while a user interacts with your app. Instead of guessing why problems happen, you can aggregate and report on problematic network requests to quickly understand the root cause. LogRocket instruments your app to record baseline performance timings such as page load time, time to first byte, slow network requests, and also logs Redux, NgRx, and Vuex actions/state. Start monitoring for free."
    },
    {
        "link": "https://geeksforgeeks.org/node-js-jimp",
        "document": "Jimp is a node module used to do image processing which is provided by the npm installer. The Jimp – Javascript Image Manipulation Program is a library written entirely in JavaScript for Node, without any external or native dependencies. \n\nVarious Image manipulation options available in this library are blit, blur, color, contain, and many more.\n\nImage types supported by Jimp :\n\nNodejs syntax is easy to handle and people with backgrounds in Python or C++ can get easily used to it. The compilation time in nodejs is faster than any other.\n\nExample 1: In this example, we will see the use of Jimp.\n\n\n\nExample 2: In this example, we will see the use of blur on the image."
    },
    {
        "link": "https://stackoverflow.com/questions/48973871/gis-app-with-nodeexpressgdalbigtiff",
        "document": "I'm a newbie to the GIS world but after few weeks of hard searching/trying I feel stuck. I am building an app to analyse landcover to assess terrain roughness. All the logic will come later but now I try to design the architecture. A sample raster image is under the link: Africa landcover 20m resolution - small sample\n\nGoal: - read raster file (BigTIFF/GeoTIFF, ...around 6GB) from a cloud storage, like AWS S3 - use a javascript library to process the file, like node-gdal, geotiff.js, etc. - apply a vector polygon to the raster and count the different pixels within the polygon. THis will be a \"circle\" with a radius of 3km for instance. Also make some histograms, so to see which pixels are dominant within a quadrant or 1/8 of the area. - do some maths in JS with the data (about this I have no concerns) - visualize the raster image on a map including the vector polygon - push the code to production for multi users.\n\nMy skillset and limited experience is with the following as also my preferences to solve the challange:\n\nSo far I have got the following issues when finding the right architecture or functioning codes:\n• node-gdal library can read only from the file system\n• geotiff.js can do the job but less documentation and I cannot see how to handle the specific tasks later\n• PostGIS should be very powerfull but a bit cumbersome to setup. Furthermore I am not sure if it is worth for a single tiff raster to be feeded\n• Rasterio in Python can do very nice jobs and I managed in a Jupyter Notebook but I have no experience with Flask or others. Prefer Node JS\n• Turf.js can do a lot but more for vectors, I could not find modules for raster analysis\n\nThank you for your suggestions."
    },
    {
        "link": "https://learn.microsoft.com/en-us/bing/search-apis/bing-image-search/quickstarts/rest/nodejs",
        "document": "Quickstart: Search for images using Bing Image Search REST API and Node.js\n\nUse this quickstart to learn how to send search requests to Bing Image Search API. This JavaScript application sends a search query to the API, and displays the URL of the first image in the results. Although this application is written in JavaScript, the API is a RESTful web service compatible with most programming languages.\n\nThe source code for this sample is available on GitHub with additional error handling and annotations.\n• None Create a new JavaScript file in your favorite IDE or editor, and set the strictness and HTTPS requirements.\n• None Create variables for the API endpoint, image API search path, your subscription key, and search term. let subscriptionKey = 'enter key here'; let host = 'api.bing.microsoft.com'; let path = '/v7.0/images/search'; let term = 'tropical ocean';\n• None Use the variables from the last step to format a search URL for the API request. URL-encode your search term before you send it to the API.\n• None Use the request library to send your query to the API.\n• None Define a function named that takes an HTTP call, , as a parameter.\n• None Within this function, define a variable to contain the body of the JSON response.\n• None Store the body of the response when the flag is called.\n• None When an flag is signaled, get the first result from the JSON response. Print the URL for the first image, along with the total number of returned images.\n\nResponses from the Bing Image Search API are returned as JSON. This sample response has been truncated to show a single result."
    },
    {
        "link": "https://forum.freecodecamp.org/t/image-search-abstraction-layer-modules-to-use-for-image-search-with-node-js/21526",
        "document": "fcc-image-search-abstraction-layer - A microservice for abstracting search data from Imgur api, including pagination support and recent search history."
    },
    {
        "link": "https://github.com/geotiffjs/geotiff.js",
        "document": "Read (geospatial) metadata and raw array data from a wide variety of different (Geo)TIFF files types.\n• Parsing TIFFs from various sources:\n• from the filesystem (on Browsers using the and on node using the filesystem functions)\n• Parsing the headers of all possible TIFF files\n• Automatic selection of overview level to read from\n• Subsetting via an image window or bounding box and selected bands\n• Reading of samples into separate arrays or a single pixel-interleaved array\n\nFurther documentation can be found here.\n\nGeotiff gives you access to all GeoTIFF metadata, but does not offer any one specific higher level API (such as GDAL) for things like transforms or data extraction. However, you can write your own higher level API using this library, given your specific dataset needs.\n\nAs an example, here is how you would resolve GPS coordinates to elevation in a GeoTIFF that encodes WGS-84 compliant geo data:\n\n? : // Load our data tile from url, arraybuffer, or blob, so we can work with it: ... // by default, the first image is read. : : // Convert a GPS coordinate to a pixel coordinate in our tile: // And as each pixel in the tile covers a geographic area, not a single // GPS coordinate, get the area that this pixel covers: // Finally, retrieve the elevation associated with this pixel's geographic area: width : `The elevation at ( , ) is m`\n\nFor more advanced examples of in larger codebases, please have a look at the following projects:\n\nTo setup the repository do the following steps:\n\nIn order to run the tests you first have to set up the test data. This requires the GDAL and ImageMagick tools. Installation of these tools varies according to the operating system, the following listing shows the installation on Ubuntu (using the ubuntugis-unstable repository):\n\nTo install GDAL and ImageMagick on MacOS X, please use Homebrew. The setup script also needs on MacOS X\n\nWhen GDAL and ImageMagick is installed, the test data setup script can be run:\n\nTo test the library (using PhantomJS, karma, mocha and chai) do the following:\n\nTo do some in-browser testing do:\n\nTo build the library do:\n\nThe output is written to and .\n\nYou can install geotiff.js using npm:\n\nor you can use the prebuilt version with a CDN:\n\ngeotiff.js works with both , and the global variable :\n\nTo parse a GeoTIFF, first a data source is required. To help with the development, there are shortcuts available. The following creates a source that reads from a remote GeoTIFF referenced by a URL:\n\nNote: the interactions with geotiff.js objects are oftentimes asynchronous. For the sake of brevity we will only show the async/await syntax and not the based one in the following examples.\n\nAccessing remote images is just one way to open TIFF images with geotiff.js. Other options are reading from a local :\n\nNow that we have opened the TIFF file, we can inspect it. The TIFF is structured in a small header and a list of one or more images (Image File Directory, IFD to use the TIFF nomenclature). To get one image by index the function must be used. This is again an asynchronous operation, as the IFDs are loaded lazily:\n\nNow that we have obtained a object we can inspect its metadata (like size, tiling, number of samples, geographical information, etc.). All the metadata is parsed once the IFD is first parsed, thus the access to that is synchronous:\n\nThe actual raster data is not fetched and parsed automatically. This is because it is usually much more spacious and the decoding of the pixels can be time consuming due to the necessity of decompression.\n\nTo read a whole image into one big array of arrays the following method call can be used:\n\nFor convenience the result always has a and attribute:\n\nBy default, the raster is split to a separate array for each component. For an RGB image for example, we'd get three arrays, one for red, green and blue.\n\nIf we want instead all the bands interleaved in one big array, we have to pass the option:\n\nIf we are only interested in a specific region of the image, the option can be used to limit reading in that bounding box. Note: the bounding box is in 'image coordinates' not geographical ones:\n\nThis image window can go beyond the image bounds. In that case it might be usefull to supply a option (can also be an array, one value for each sample).\n\nIt is also possible to just read specific samples for each pixel. For example, we can only read the red component from an RGB image:\n\nWhen you want your output in a specific size, you can use the and options. This defaults of course to the size of your supplied or the image size if no was supplied.\n\nAs the data now needs to be resampled, a can be specified. This defaults to the nearest neighbour method, but also the method is supported:\n\nDecoding compressed images can be a time consuming process. To minimize this geotiff.js provides the mechanism which uses WebWorkers to split the amount of work on multiple 'threads'.\n\nIt is possible to provide a pool size (i.e: number of workers), by default the number of available processors is used.\n\nThe TIFF specification provides various ways to encode visual data. In the specification this is called photometric interpretation. The simplest case we already dealt with is the RGB one. Others are grayscale, paletted images, CMYK, YCbCr, and CIE Lab.\n\ngeotiff.js provides a method to automatically convert these images to RGB: . This method is very similar to the method with distinction that the option is now always and the are automatically chosen.\n\nWhen dealing with images that have internal (or even external, see the next section) overviews, objects provide a separate method. This method works very similar to the method on the objects with the same name. By default, it uses the larges image available (highest resolution), but when either , , , or are specified, then the best fitting image will be used for reading.\n\nAdditionally, it allows the instead of the parameter. This works similarly, but uses geographic coordinates instead of pixel ones.\n\nEspecially for certain kinds of high resolution images it is not uncommon to separate the highest resolution from the lower resolution overviews (usually using the extension). With geotiff.js it is possible to use files of this setup, just as you would use single-file images by taking advantage of the objects. They behave exactly the same as the before mentioned objects: you can select images by index or read data using . Toget such a file use the factory function:\n\nGeotiff.js supports the use of s. Calls to , and will throw an with name similar to the browser's behavior.\n\nYou can create a binary representation of a GeoTIFF using . This function returns an ArrayBuffer which you can then save as a .tif file. :warning: writeArrayBuffer currently writes the values uncompressed\n\nYou can also customize the metadata using names found in the TIFF Spec and GeoTIFF spec.\n\nThere is a nice HTML 5/WebGL based rendering library called plotty, that allows for some really nice on the fly rendering of the data contained in a GeoTIFF.\n\nThere's also a library called geotiff-geokeys-to-proj4, that allows for reprojecting pixel coordinates and, therefore, consuming geospatial data contained in GeoTIFF.\n\ngeotiff.js has a limited support for files in the BigTIFF format. The limitations originate in the capabilities of current JavaScript implementations regarding 64 bit integer parsers and structures: there are no functions to read 64 bit integers from a stream and no such typed arrays. As BigTIFF relies on 64 bit offsets and also allows tag values of those types. In order to still provide a reasonable support, the following is implemented:\n• 64 bit integers are read as two 32 bit integers and then combined. As numbers in JavaScript are typically implemented as 64 bit floats, there might be inaccuracies for very large values.\n• For 64 bit integer arrays, the default type is used. This might cause problems for some compression algorithms if those arrays are used for pixel values.\n\ngeotiff.js has some n-bit support which means that it supports unsigned integer data reading with each element using a non-multiple of 8 bit depth. This only works with band interleaved images (see this related issue).\n\nThe open issues can be found on GitHub.\n\nIf you have an idea, found a bug or have a remark, please open a ticket, we will look into it ASAP.\n\nPull requests are welcome as well!\n\nA list of community packages can be found in COMMUNITY.md\n\nThis library was inspired by GeotiffParser. It provided a great starting point, but lacked the capabilities to read the raw raster data which is the aim of geotiff.js."
    },
    {
        "link": "https://timescale.com/blog/how-to-build-an-image-search-application-with-openai-clip-postgresql-in-javascript",
        "document": "Learn how to make PostgreSQL faster with our documentation\n\nLearn how to use PostgreSQL for Al with our documentation"
    }
]