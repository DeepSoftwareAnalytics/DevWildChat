[
    {
        "link": "https://go.dev/ref/spec",
        "document": "This is the reference manual for the Go programming language. The pre-Go1.18 version, without generics, can be found here. For more information and other documents, see go.dev.\n\nGo is a general-purpose language designed with systems programming in mind. It is strongly typed and garbage-collected and has explicit support for concurrent programming. Programs are constructed from packages, whose properties allow efficient management of dependencies.\n\nThe syntax is compact and simple to parse, allowing for easy analysis by automatic tools such as integrated development environments.\n\nThe syntax is specified using a variant of Extended Backus-Naur Form (EBNF):\n\nProductions are expressions constructed from terms and the following operators, in increasing precedence:\n\nLowercase production names are used to identify lexical (terminal) tokens. Non-terminals are in CamelCase. Lexical tokens are enclosed in double quotes or back quotes .\n\nThe form represents the set of characters from through as alternatives. The horizontal ellipsis is also used elsewhere in the spec to informally denote various enumerations or code snippets that are not further specified. The character (as opposed to the three characters ) is not a token of the Go language.\n\nA link of the form [Go 1.xx] indicates that a described language feature (or some aspect of it) was changed or added with language version 1.xx and thus requires at minimum that language version to build. For details, see the linked section in the appendix.\n\nSource code is Unicode text encoded in UTF-8. The text is not canonicalized, so a single accented code point is distinct from the same character constructed from combining an accent and a letter; those are treated as two code points. For simplicity, this document will use the unqualified term character to refer to a Unicode code point in the source text.\n\nEach code point is distinct; for instance, uppercase and lowercase letters are different characters.\n\nImplementation restriction: For compatibility with other tools, a compiler may disallow the NUL character (U+0000) in the source text.\n\nImplementation restriction: For compatibility with other tools, a compiler may ignore a UTF-8-encoded byte order mark (U+FEFF) if it is the first Unicode code point in the source text. A byte order mark may be disallowed anywhere else in the source.\n\nThe following terms are used to denote specific Unicode character categories:\n\nIn The Unicode Standard 8.0, Section 4.5 \"General Category\" defines a set of character categories. Go treats all characters in any of the Letter categories Lu, Ll, Lt, Lm, or Lo as Unicode letters, and those in the Number category Nd as Unicode digits.\n\nComments serve as program documentation. There are two forms:\n• Line comments start with the character sequence and stop at the end of the line.\n• General comments start with the character sequence and stop with the first subsequent character sequence .\n\nA comment cannot start inside a rune or string literal, or inside a comment. A general comment containing no newlines acts like a space. Any other comment acts like a newline.\n\nTokens form the vocabulary of the Go language. There are four classes: identifiers, keywords, operators and punctuation, and literals. White space, formed from spaces (U+0020), horizontal tabs (U+0009), carriage returns (U+000D), and newlines (U+000A), is ignored except as it separates tokens that would otherwise combine into a single token. Also, a newline or end of file may trigger the insertion of a semicolon. While breaking the input into tokens, the next token is the longest sequence of characters that form a valid token.\n\nThe formal syntax uses semicolons as terminators in a number of productions. Go programs may omit most of these semicolons using the following two rules:\n• When the input is broken into tokens, a semicolon is automatically inserted into the token stream immediately after a line's final token if that token is\n• one of the keywords , , , or\n• one of the operators and punctuation , , , , or\n• To allow complex statements to occupy a single line, a semicolon may be omitted before a closing or .\n\nTo reflect idiomatic use, code examples in this document elide semicolons using these rules.\n\nIdentifiers name program entities such as variables and types. An identifier is a sequence of one or more letters and digits. The first character in an identifier must be a letter.\n\nThe following keywords are reserved and may not be used as identifiers.\n\nThe following character sequences represent operators (including assignment operators) and punctuation [Go 1.18]:\n\nAn integer literal is a sequence of digits representing an integer constant. An optional prefix sets a non-decimal base: or for binary, , , or for octal, and or for hexadecimal [Go 1.13]. A single is considered a decimal zero. In hexadecimal literals, letters through and through represent values 10 through 15.\n\nFor readability, an underscore character may appear after a base prefix or between successive digits; such underscores do not change the literal's value.\n\nA floating-point literal is a decimal or hexadecimal representation of a floating-point constant.\n\nA decimal floating-point literal consists of an integer part (decimal digits), a decimal point, a fractional part (decimal digits), and an exponent part ( or followed by an optional sign and decimal digits). One of the integer part or the fractional part may be elided; one of the decimal point or the exponent part may be elided. An exponent value exp scales the mantissa (integer and fractional part) by 10exp.\n\nA hexadecimal floating-point literal consists of a or prefix, an integer part (hexadecimal digits), a radix point, a fractional part (hexadecimal digits), and an exponent part ( or followed by an optional sign and decimal digits). One of the integer part or the fractional part may be elided; the radix point may be elided as well, but the exponent part is required. (This syntax matches the one given in IEEE 754-2008 §5.12.3.) An exponent value exp scales the mantissa (integer and fractional part) by 2exp [Go 1.13].\n\nFor readability, an underscore character may appear after a base prefix or between successive digits; such underscores do not change the literal value.\n\nAn imaginary literal represents the imaginary part of a complex constant. It consists of an integer or floating-point literal followed by the lowercase letter . The value of an imaginary literal is the value of the respective integer or floating-point literal multiplied by the imaginary unit i [Go 1.13]\n\nFor backward compatibility, an imaginary literal's integer part consisting entirely of decimal digits (and possibly underscores) is considered a decimal integer, even if it starts with a leading .\n\nA rune literal represents a rune constant, an integer value identifying a Unicode code point. A rune literal is expressed as one or more characters enclosed in single quotes, as in or . Within the quotes, any character may appear except newline and unescaped single quote. A single quoted character represents the Unicode value of the character itself, while multi-character sequences beginning with a backslash encode values in various formats.\n\nThe simplest form represents the single character within the quotes; since Go source text is Unicode characters encoded in UTF-8, multiple UTF-8-encoded bytes may represent a single integer value. For instance, the literal holds a single byte representing a literal , Unicode U+0061, value , while holds two bytes ( ) representing a literal -dieresis, U+00E4, value .\n\nSeveral backslash escapes allow arbitrary values to be encoded as ASCII text. There are four ways to represent the integer value as a numeric constant: followed by exactly two hexadecimal digits; followed by exactly four hexadecimal digits; followed by exactly eight hexadecimal digits, and a plain backslash followed by exactly three octal digits. In each case the value of the literal is the value represented by the digits in the corresponding base.\n\nAlthough these representations all result in an integer, they have different valid ranges. Octal escapes must represent a value between 0 and 255 inclusive. Hexadecimal escapes satisfy this condition by construction. The escapes and represent Unicode code points so within them some values are illegal, in particular those above and surrogate halves.\n\nAn unrecognized character following a backslash in a rune literal is illegal.\n\nA string literal represents a string constant obtained from concatenating a sequence of characters. There are two forms: raw string literals and interpreted string literals.\n\nRaw string literals are character sequences between back quotes, as in . Within the quotes, any character may appear except back quote. The value of a raw string literal is the string composed of the uninterpreted (implicitly UTF-8-encoded) characters between the quotes; in particular, backslashes have no special meaning and the string may contain newlines. Carriage return characters ('\\r') inside raw string literals are discarded from the raw string value.\n\nInterpreted string literals are character sequences between double quotes, as in . Within the quotes, any character may appear except newline and unescaped double quote. The text between the quotes forms the value of the literal, with backslash escapes interpreted as they are in rune literals (except that is illegal and is legal), with the same restrictions. The three-digit octal ( nnn) and two-digit hexadecimal ( nn) escapes represent individual bytes of the resulting string; all other escapes represent the (possibly multi-byte) UTF-8 encoding of individual characters. Thus inside a string literal and represent a single byte of value =255, while , , and represent the two bytes of the UTF-8 encoding of character U+00FF.\n\nThese examples all represent the same string:\n\nIf the source code represents a character as two code points, such as a combining form involving an accent and a letter, the result will be an error if placed in a rune literal (it is not a single code point), and will appear as two code points if placed in a string literal.\n\nThere are boolean constants, rune constants, integer constants, floating-point constants, complex constants, and string constants. Rune, integer, floating-point, and complex constants are collectively called numeric constants.\n\nA constant value is represented by a rune, integer, floating-point, imaginary, or string literal, an identifier denoting a constant, a constant expression, a conversion with a result that is a constant, or the result value of some built-in functions such as or applied to constant arguments, applied to certain values, or applied to some expressions, and applied to a complex constant and applied to numeric constants. The boolean truth values are represented by the predeclared constants and . The predeclared identifier iota denotes an integer constant.\n\nIn general, complex constants are a form of constant expression and are discussed in that section.\n\nNumeric constants represent exact values of arbitrary precision and do not overflow. Consequently, there are no constants denoting the IEEE 754 negative zero, infinity, and not-a-number values.\n\nConstants may be typed or untyped. Literal constants, , , , and certain constant expressions containing only untyped constant operands are untyped.\n\nA constant may be given a type explicitly by a constant declaration or conversion, or implicitly when used in a variable declaration or an assignment statement or as an operand in an expression. It is an error if the constant value cannot be represented as a value of the respective type. If the type is a type parameter, the constant is converted into a non-constant value of the type parameter.\n\nAn untyped constant has a default type which is the type to which the constant is implicitly converted in contexts where a typed value is required, for instance, in a short variable declaration such as where there is no explicit type. The default type of an untyped constant is , , , , , or respectively, depending on whether it is a boolean, rune, integer, floating-point, complex, or string constant.\n\nImplementation restriction: Although numeric constants have arbitrary precision in the language, a compiler may implement them using an internal representation with limited precision. That said, every implementation must:\n• Represent integer constants with at least 256 bits.\n• Represent floating-point constants, including the parts of a complex constant, with a mantissa of at least 256 bits and a signed binary exponent of at least 16 bits.\n• Give an error if unable to represent an integer constant precisely.\n• Give an error if unable to represent a floating-point or complex constant due to overflow.\n• Round to the nearest representable constant if unable to represent a floating-point or complex constant due to limits on precision.\n\nThese requirements apply both to literal constants and to the result of evaluating constant expressions.\n\nA variable is a storage location for holding a value. The set of permissible values is determined by the variable's type.\n\nA variable declaration or, for function parameters and results, the signature of a function declaration or function literal reserves storage for a named variable. Calling the built-in function or taking the address of a composite literal allocates storage for a variable at run time. Such an anonymous variable is referred to via a (possibly implicit) pointer indirection.\n\nStructured variables of array, slice, and struct types have elements and fields that may be addressed individually. Each such element acts like a variable.\n\nThe static type (or just type) of a variable is the type given in its declaration, the type provided in the call or composite literal, or the type of an element of a structured variable. Variables of interface type also have a distinct dynamic type, which is the (non-interface) type of the value assigned to the variable at run time (unless the value is the predeclared identifier , which has no type). The dynamic type may vary during execution but values stored in interface variables are always assignable to the static type of the variable.\n\nA variable's value is retrieved by referring to the variable in an expression; it is the most recent value assigned to the variable. If a variable has not yet been assigned a value, its value is the zero value for its type.\n\nA type determines a set of values together with operations and methods specific to those values. A type may be denoted by a type name, if it has one, which must be followed by type arguments if the type is generic. A type may also be specified using a type literal, which composes a type from existing types.\n\nThe language predeclares certain type names. Others are introduced with type declarations or type parameter lists. Composite types—array, struct, pointer, function, interface, slice, map, and channel types—may be constructed using type literals.\n\nPredeclared types, defined types, and type parameters are called named types. An alias denotes a named type if the type given in the alias declaration is a named type.\n\nA boolean type represents the set of Boolean truth values denoted by the predeclared constants and . The predeclared boolean type is ; it is a defined type.\n\nAn integer, floating-point, or complex type represents the set of integer, floating-point, or complex values, respectively. They are collectively called numeric types. The predeclared architecture-independent numeric types are:\n\nThe value of an n-bit integer is n bits wide and represented using two's complement arithmetic.\n\nThere is also a set of predeclared integer types with implementation-specific sizes:\n\nTo avoid portability issues all numeric types are defined types and thus distinct except , which is an alias for , and , which is an alias for . Explicit conversions are required when different numeric types are mixed in an expression or assignment. For instance, and are not the same type even though they may have the same size on a particular architecture.\n\nA string type represents the set of string values. A string value is a (possibly empty) sequence of bytes. The number of bytes is called the length of the string and is never negative. Strings are immutable: once created, it is impossible to change the contents of a string. The predeclared string type is ; it is a defined type.\n\nThe length of a string can be discovered using the built-in function . The length is a compile-time constant if the string is a constant. A string's bytes can be accessed by integer indices 0 through . It is illegal to take the address of such an element; if is the 'th byte of a string, is invalid.\n\nAn array is a numbered sequence of elements of a single type, called the element type. The number of elements is called the length of the array and is never negative.\n\nThe length is part of the array's type; it must evaluate to a non-negative constant representable by a value of type . The length of array can be discovered using the built-in function . The elements can be addressed by integer indices 0 through . Array types are always one-dimensional but may be composed to form multi-dimensional types.\n\nAn array type may not have an element of type , or of a type containing as a component, directly or indirectly, if those containing types are only array or struct types.\n\nA slice is a descriptor for a contiguous segment of an underlying array and provides access to a numbered sequence of elements from that array. A slice type denotes the set of all slices of arrays of its element type. The number of elements is called the length of the slice and is never negative. The value of an uninitialized slice is .\n\nThe length of a slice can be discovered by the built-in function ; unlike with arrays it may change during execution. The elements can be addressed by integer indices 0 through . The slice index of a given element may be less than the index of the same element in the underlying array.\n\nA slice, once initialized, is always associated with an underlying array that holds its elements. A slice therefore shares storage with its array and with other slices of the same array; by contrast, distinct arrays always represent distinct storage.\n\nThe array underlying a slice may extend past the end of the slice. The capacity is a measure of that extent: it is the sum of the length of the slice and the length of the array beyond the slice; a slice of length up to that capacity can be created by slicing a new one from the original slice. The capacity of a slice can be discovered using the built-in function .\n\nA new, initialized slice value for a given element type may be made using the built-in function , which takes a slice type and parameters specifying the length and optionally the capacity. A slice created with always allocates a new, hidden array to which the returned slice value refers. That is, executing\n\nproduces the same slice as allocating an array and slicing it, so these two expressions are equivalent:\n\nLike arrays, slices are always one-dimensional but may be composed to construct higher-dimensional objects. With arrays of arrays, the inner arrays are, by construction, always the same length; however with slices of slices (or arrays of slices), the inner lengths may vary dynamically. Moreover, the inner slices must be initialized individually.\n\nA struct is a sequence of named elements, called fields, each of which has a name and a type. Field names may be specified explicitly (IdentifierList) or implicitly (EmbeddedField). Within a struct, non-blank field names must be unique.\n\nA field declared with a type but no explicit field name is called an embedded field. An embedded field must be specified as a type name or as a pointer to a non-interface type name , and itself may not be a pointer type or type parameter. The unqualified type name acts as the field name.\n\nThe following declaration is illegal because field names must be unique in a struct type:\n\nA field or method of an embedded field in a struct is called promoted if is a legal selector that denotes that field or method .\n\nPromoted fields act like ordinary fields of a struct except that they cannot be used as field names in composite literals of the struct.\n\nGiven a struct type and a type name , promoted methods are included in the method set of the struct as follows:\n• If contains an embedded field , the method sets of and both include promoted methods with receiver . The method set of also includes promoted methods with receiver .\n• If contains an embedded field , the method sets of and both include promoted methods with receiver or .\n\nA field declaration may be followed by an optional string literal tag, which becomes an attribute for all the fields in the corresponding field declaration. An empty tag string is equivalent to an absent tag. The tags are made visible through a reflection interface and take part in type identity for structs but are otherwise ignored.\n\nA struct type may not contain a field of type , or of a type containing as a component, directly or indirectly, if those containing types are only array or struct types.\n\nA pointer type denotes the set of all pointers to variables of a given type, called the base type of the pointer. The value of an uninitialized pointer is .\n\nA function type denotes the set of all functions with the same parameter and result types. The value of an uninitialized variable of function type is .\n\nWithin a list of parameters or results, the names (IdentifierList) must either all be present or all be absent. If present, each name stands for one item (parameter or result) of the specified type and all non-blank names in the signature must be unique. If absent, each type stands for one item of that type. Parameter and result lists are always parenthesized except that if there is exactly one unnamed result it may be written as an unparenthesized type.\n\nThe final incoming parameter in a function signature may have a type prefixed with . A function with such a parameter is called variadic and may be invoked with zero or more arguments for that parameter.\n\nAn interface type defines a type set. A variable of interface type can store a value of any type that is in the type set of the interface. Such a type is said to implement the interface. The value of an uninitialized variable of interface type is .\n\nAn interface type is specified by a list of interface elements. An interface element is either a method or a type element, where a type element is a union of one or more type terms. A type term is either a single type or a single underlying type.\n\nIn its most basic form an interface specifies a (possibly empty) list of methods. The type set defined by such an interface is the set of types which implement all of those methods, and the corresponding method set consists exactly of the methods specified by the interface. Interfaces whose type sets can be defined entirely by a list of methods are called basic interfaces.\n\nThe name of each explicitly specified method must be unique and not blank.\n\nMore than one type may implement an interface. For instance, if two types and have the method set\n\n(where stands for either or ) then the interface is implemented by both and , regardless of what other methods and may have or share.\n\nEvery type that is a member of the type set of an interface implements that interface. Any given type may implement several distinct interfaces. For instance, all types implement the empty interface which stands for the set of all (non-interface) types:\n\nFor convenience, the predeclared type is an alias for the empty interface. [Go 1.18]\n\nSimilarly, consider this interface specification, which appears within a type declaration to define an interface called :\n\nIf and also implement\n\nthey implement the interface as well as the interface.\n\nIn a slightly more general form an interface may use a (possibly qualified) interface type name as an interface element. This is called embedding interface in [Go 1.14]. The type set of is the intersection of the type sets defined by 's explicitly declared methods and the type sets of ’s embedded interfaces. In other words, the type set of is the set of all types that implement all the explicitly declared methods of and also all the methods of [Go 1.18].\n\nWhen embedding interfaces, methods with the same names must have identical signatures.\n\nIn their most general form, an interface element may also be an arbitrary type term , or a term of the form specifying the underlying type , or a union of terms [Go 1.18]. Together with method specifications, these elements enable the precise definition of an interface's type set as follows:\n• The type set of the empty interface is the set of all non-interface types.\n• The type set of a non-empty interface is the intersection of the type sets of its interface elements.\n• The type set of a method specification is the set of all non-interface types whose method sets include that method.\n• The type set of a non-interface type term is the set consisting of just that type.\n• The type set of a term of the form is the set of all types whose underlying type is .\n• The type set of a union of terms is the union of the type sets of the terms.\n\nThe quantification \"the set of all non-interface types\" refers not just to all (non-interface) types declared in the program at hand, but all possible types in all possible programs, and hence is infinite. Similarly, given the set of all non-interface types that implement a particular method, the intersection of the method sets of those types will contain exactly that method, even if all types in the program at hand always pair that method with another method.\n\nBy construction, an interface's type set never contains an interface type.\n\nIn a term of the form , the underlying type of must be itself, and cannot be an interface.\n\nThe type in a term of the form or cannot be a type parameter, and the type sets of all non-interface terms must be pairwise disjoint (the pairwise intersection of the type sets must be empty). Given a type parameter :\n\nImplementation restriction: A union (with more than one term) cannot contain the predeclared identifier or interfaces that specify methods, or embed or interfaces that specify methods.\n\nInterfaces that are not basic may only be used as type constraints, or as elements of other interfaces used as constraints. They cannot be the types of values or variables, or components of other, non-interface types.\n\nAn interface type may not embed a type element that is, contains, or embeds , directly or indirectly.\n• is not an interface and is an element of the type set of ; or\n• is an interface and the type set of is a subset of the type set of .\n\nA value of type implements an interface if implements the interface.\n\nA map is an unordered group of elements of one type, called the element type, indexed by a set of unique keys of another type, called the key type. The value of an uninitialized map is .\n\nThe comparison operators and must be fully defined for operands of the key type; thus the key type must not be a function, map, or slice. If the key type is an interface type, these comparison operators must be defined for the dynamic key values; failure will cause a run-time panic.\n\nThe number of map elements is called its length. For a map , it can be discovered using the built-in function and may change during execution. Elements may be added during execution using assignments and retrieved with index expressions; they may be removed with the and built-in function.\n\nA new, empty map value is made using the built-in function , which takes the map type and an optional capacity hint as arguments:\n\nThe initial capacity does not bound its size: maps grow to accommodate the number of items stored in them, with the exception of maps. A map is equivalent to an empty map except that no elements may be added.\n\nA channel provides a mechanism for concurrently executing functions to communicate by sending and receiving values of a specified element type. The value of an uninitialized channel is .\n\nThe optional operator specifies the channel direction, send or receive. If a direction is given, the channel is directional, otherwise it is bidirectional. A channel may be constrained only to send or only to receive by assignment or explicit conversion.\n\nThe operator associates with the leftmost possible:\n\nA new, initialized channel value can be made using the built-in function , which takes the channel type and an optional capacity as arguments:\n\nThe capacity, in number of elements, sets the size of the buffer in the channel. If the capacity is zero or absent, the channel is unbuffered and communication succeeds only when both a sender and receiver are ready. Otherwise, the channel is buffered and communication succeeds without blocking if the buffer is not full (sends) or not empty (receives). A channel is never ready for communication.\n\nA channel may be closed with the built-in function . The multi-valued assignment form of the receive operator reports whether a received value was sent before the channel was closed.\n\nA single channel may be used in send statements, receive operations, and calls to the built-in functions and by any number of goroutines without further synchronization. Channels act as first-in-first-out queues. For example, if one goroutine sends values on a channel and a second goroutine receives them, the values are received in the order sent.\n\nValues of predeclared types (see below for the interfaces and ), arrays, and structs are self-contained: Each such value contains a complete copy of all its data, and variables of such types store the entire value. For instance, an array variable provides the storage (the variables) for all elements of the array. The respective zero values are specific to the value's types; they are never .\n\nNon-nil pointer, function, slice, map, and channel values contain references to underlying data which may be shared by multiple values:\n• A pointer value is a reference to the variable holding the pointer base type value.\n• A function value contains references to the (possibly anonymous) function and enclosed variables.\n• A slice value contains the slice length, capacity, and a reference to its underlying array.\n• A map or channel value is a reference to the implementation-specific data structure of the map or channel.\n\nAn interface value may be self-contained or contain references to underlying data depending on the interface's dynamic type. The predeclared identifier is the zero value for types whose values can contain references.\n\nWhen multiple values share underlying data, changing one value may change another. For instance, changing an element of a slice will change that element in the underlying array for all slices that share the array.\n\nEach type has an underlying type: If is one of the predeclared boolean, numeric, or string types, or a type literal, the corresponding underlying type is itself. Otherwise, 's underlying type is the underlying type of the type to which refers in its declaration. For a type parameter that is the underlying type of its type constraint, which is always an interface.\n\nThe underlying type of , , , , and is . The underlying type of , , and is . The underlying type of is .\n\nEach non-interface type has a core type, which is the same as the underlying type of .\n\nAn interface has a core type if one of the following conditions is satisfied:\n• There is a single type which is the underlying type of all types in the type set of ; or\n• the type set of contains only channel types with identical element type , and all directional channels have the same direction.\n\nNo other interfaces have a core type.\n\nThe core type of an interface is, depending on the condition that is satisfied, either:\n• the type if contains only bidirectional channels, or the type or depending on the direction of the directional channels present.\n\nBy definition, a core type is never a defined type, type parameter, or interface type.\n\nSome operations (slice expressions, and ) rely on a slightly more loose form of core types which accept byte slices and strings. Specifically, if there are exactly two types, and , which are the underlying types of all types in the type set of interface , the core type of is called .\n\nNote that is not a real type; it cannot be used to declare variables or compose other types. It exists solely to describe the behavior of some operations that read from a sequence of bytes, which may be a byte slice or a string.\n\nTwo types are either identical or different.\n\nA named type is always different from any other type. Otherwise, two types are identical if their underlying type literals are structurally equivalent; that is, they have the same literal structure and corresponding components have identical types. In detail:\n• Two array types are identical if they have identical element types and the same array length.\n• Two slice types are identical if they have identical element types.\n• Two struct types are identical if they have the same sequence of fields, and if corresponding pairs of fields have the same names, identical types, and identical tags, and are either both embedded or both not embedded. Non-exported field names from different packages are always different.\n• Two pointer types are identical if they have identical base types.\n• Two function types are identical if they have the same number of parameters and result values, corresponding parameter and result types are identical, and either both functions are variadic or neither is. Parameter and result names are not required to match.\n• Two interface types are identical if they define the same type set.\n• Two map types are identical if they have identical key and element types.\n• Two channel types are identical if they have identical element types and the same direction.\n• Two instantiated types are identical if their defined types and all type arguments are identical.\n\nand are different because they are new types created by distinct type definitions; and are different because is different from ; and and are different because they are different type parameters. and are different because the former is an instantiated defined type while the latter is a type literal (but they are still assignable).\n\nA value of type is assignable to a variable of type (\" is assignable to \") if one of the following conditions applies:\n• and have identical underlying types but are not type parameters and at least one of or is not a named type.\n• and are channel types with identical element types, is a bidirectional channel, and at least one of or is not a named type.\n• is an interface type, but not a type parameter, and implements .\n• is the predeclared identifier and is a pointer, function, slice, map, channel, or interface type, but not a type parameter.\n• is an untyped constant representable by a value of type .\n\nAdditionally, if 's type or are type parameters, is assignable to a variable of type if one of the following conditions applies:\n• is the predeclared identifier , is a type parameter, and is assignable to each type in 's type set.\n• is not a named type, is a type parameter, and is assignable to each type in 's type set.\n• is a type parameter and is not a named type, and values of each type in 's type set are assignable to .\n\nA constant is representable by a value of type , where is not a type parameter, if one of the following conditions applies:\n• is in the set of values determined by .\n• is a floating-point type and can be rounded to 's precision without overflow. Rounding uses IEEE 754 round-to-even rules but with an IEEE negative zero further simplified to an unsigned zero. Note that constant values never result in an IEEE negative zero, NaN, or infinity.\n• is a complex type, and 's components and are representable by values of 's component type ( or ).\n\nIf is a type parameter, is representable by a value of type if is representable by a value of each type in 's type set.\n\nThe method set of a type determines the methods that can be called on an operand of that type. Every type has a (possibly empty) method set associated with it:\n• The method set of a defined type consists of all methods declared with receiver type .\n• The method set of a pointer to a defined type (where is neither a pointer nor an interface) is the set of all methods declared with receiver or .\n• The method set of an interface type is the intersection of the method sets of each type in the interface's type set (the resulting method set is usually just the set of declared methods in the interface).\n\nFurther rules apply to structs (and pointer to structs) containing embedded fields, as described in the section on struct types. Any other type has an empty method set.\n\nIn a method set, each method must have a unique non-blank method name.\n\nA block is a possibly empty sequence of declarations and statements within matching brace brackets.\n\nIn addition to explicit blocks in the source code, there are implicit blocks:\n• The universe block encompasses all Go source text.\n• Each package has a package block containing all Go source text for that package.\n• Each file has a file block containing all Go source text in that file.\n• Each \"if\", \"for\", and \"switch\" statement is considered to be in its own implicit block.\n• Each clause in a \"switch\" or \"select\" statement acts as an implicit block.\n\nA declaration binds a non-blank identifier to a constant, type, type parameter, variable, function, label, or package. Every identifier in a program must be declared. No identifier may be declared twice in the same block, and no identifier may be declared in both the file and package block.\n\nThe blank identifier may be used like any other identifier in a declaration, but it does not introduce a binding and thus is not declared. In the package block, the identifier may only be used for function declarations, and like the blank identifier it does not introduce a new binding.\n\nThe scope of a declared identifier is the extent of source text in which the identifier denotes the specified constant, type, variable, function, label, or package.\n\nGo is lexically scoped using blocks:\n• The scope of a predeclared identifier is the universe block.\n• The scope of an identifier denoting a constant, type, variable, or function (but not method) declared at top level (outside any function) is the package block.\n• The scope of the package name of an imported package is the file block of the file containing the import declaration.\n• The scope of an identifier denoting a method receiver, function parameter, or result variable is the function body.\n• The scope of an identifier denoting a type parameter of a function or declared by a method receiver begins after the name of the function and ends at the end of the function body.\n• The scope of an identifier denoting a type parameter of a type begins after the name of the type and ends at the end of the TypeSpec.\n• The scope of a constant or variable identifier declared inside a function begins at the end of the ConstSpec or VarSpec (ShortVarDecl for short variable declarations) and ends at the end of the innermost containing block.\n• The scope of a type identifier declared inside a function begins at the identifier in the TypeSpec and ends at the end of the innermost containing block.\n\nAn identifier declared in a block may be redeclared in an inner block. While the identifier of the inner declaration is in scope, it denotes the entity declared by the inner declaration.\n\nThe package clause is not a declaration; the package name does not appear in any scope. Its purpose is to identify the files belonging to the same package and to specify the default package name for import declarations.\n\nLabels are declared by labeled statements and are used in the \"break\", \"continue\", and \"goto\" statements. It is illegal to define a label that is never used. In contrast to other identifiers, labels are not block scoped and do not conflict with identifiers that are not labels. The scope of a label is the body of the function in which it is declared and excludes the body of any nested function.\n\nThe blank identifier is represented by the underscore character . It serves as an anonymous placeholder instead of a regular (non-blank) identifier and has special meaning in declarations, as an operand, and in assignment statements.\n\nThe following identifiers are implicitly declared in the universe block [Go 1.18] [Go 1.21]:\n\nAn identifier may be exported to permit access to it from another package. An identifier is exported if both:\n• the first character of the identifier's name is a Unicode uppercase letter (Unicode character category Lu); and\n• the identifier is declared in the package block or it is a field name or method name.\n\nAll other identifiers are not exported.\n\nGiven a set of identifiers, an identifier is called unique if it is different from every other in the set. Two identifiers are different if they are spelled differently, or if they appear in different packages and are not exported. Otherwise, they are the same.\n\nA constant declaration binds a list of identifiers (the names of the constants) to the values of a list of constant expressions. The number of identifiers must be equal to the number of expressions, and the nth identifier on the left is bound to the value of the nth expression on the right.\n\nIf the type is present, all constants take the type specified, and the expressions must be assignable to that type, which must not be a type parameter. If the type is omitted, the constants take the individual types of the corresponding expressions. If the expression values are untyped constants, the declared constants remain untyped and the constant identifiers denote the constant values. For instance, if the expression is a floating-point literal, the constant identifier denotes a floating-point constant, even if the literal's fractional part is zero.\n\nWithin a parenthesized declaration list the expression list may be omitted from any but the first ConstSpec. Such an empty list is equivalent to the textual substitution of the first preceding non-empty expression list and its type if any. Omitting the list of expressions is therefore equivalent to repeating the previous list. The number of identifiers must be equal to the number of expressions in the previous list. Together with the constant generator this mechanism permits light-weight declaration of sequential values:\n\nWithin a constant declaration, the predeclared identifier represents successive untyped integer constants. Its value is the index of the respective ConstSpec in that constant declaration, starting at zero. It can be used to construct a set of related constants:\n\nBy definition, multiple uses of in the same ConstSpec all have the same value:\n\nThis last example exploits the implicit repetition of the last non-empty expression list.\n\nA type declaration binds an identifier, the type name, to a type. Type declarations come in two forms: alias declarations and type definitions.\n\nAn alias declaration binds an identifier to the given type [Go 1.9].\n\nWithin the scope of the identifier, it serves as an alias for the given type.\n\nIf the alias declaration specifies type parameters [Go 1.24], the type name denotes a generic alias. Generic aliases must be instantiated when they are used.\n\nIn an alias declaration the given type cannot be a type parameter.\n\nA type definition creates a new, distinct type with the same underlying type and operations as the given type and binds an identifier, the type name, to it.\n\nThe new type is called a defined type. It is different from any other type, including the type it is created from.\n\nA defined type may have methods associated with it. It does not inherit any methods bound to the given type, but the method set of an interface type or of elements of a composite type remains unchanged:\n\nType definitions may be used to define different boolean, numeric, or string types and associate methods with them:\n\nIf the type definition specifies type parameters, the type name denotes a generic type. Generic types must be instantiated when they are used.\n\nIn a type definition the given type cannot be a type parameter.\n\nA generic type may also have methods associated with it. In this case, the method receivers must declare the same number of type parameters as present in the generic type definition.\n\nA type parameter list declares the type parameters of a generic function or type declaration. The type parameter list looks like an ordinary function parameter list except that the type parameter names must all be present and the list is enclosed in square brackets rather than parentheses [Go 1.18].\n\nAll non-blank names in the list must be unique. Each name declares a type parameter, which is a new and different named type that acts as a placeholder for an (as of yet) unknown type in the declaration. The type parameter is replaced with a type argument upon instantiation of the generic function or type.\n\nJust as each ordinary function parameter has a parameter type, each type parameter has a corresponding (meta-)type which is called its type constraint.\n\nA parsing ambiguity arises when the type parameter list for a generic type declares a single type parameter with a constraint such that the text forms a valid expression:\n\nIn these rare cases, the type parameter list is indistinguishable from an expression and the type declaration is parsed as an array type declaration. To resolve the ambiguity, embed the constraint in an interface or use a trailing comma:\n\nType parameters may also be declared by the receiver specification of a method declaration associated with a generic type.\n\nWithin a type parameter list of a generic type , a type constraint may not (directly, or indirectly through the type parameter list of another generic type) refer to .\n\nA type constraint is an interface that defines the set of permissible type arguments for the respective type parameter and controls the operations supported by values of that type parameter [Go 1.18].\n\nIf the constraint is an interface literal of the form where is an embedded type element (not a method), in a type parameter list the enclosing may be omitted for convenience:\n\nThe predeclared interface type denotes the set of all non-interface types that are strictly comparable [Go 1.18].\n\nEven though interfaces that are not type parameters are comparable, they are not strictly comparable and therefore they do not implement . However, they satisfy .\n\nThe interface and interfaces that (directly or indirectly) embed may only be used as type constraints. They cannot be the types of values or variables, or components of other, non-interface types.\n\nA type argument satisfies a type constraint if is an element of the type set defined by ; in other words, if implements . As an exception, a strictly comparable type constraint may also be satisfied by a comparable (not necessarily strictly comparable) type argument [Go 1.20]. More precisely:\n• can be written in the form , where is a basic interface and is comparable and implements .\n\nBecause of the exception in the constraint satisfaction rule, comparing operands of type parameter type may panic at run-time (even though comparable type parameters are always strictly comparable).\n\nA variable declaration creates one or more variables, binds corresponding identifiers to them, and gives each a type and an initial value.\n\nIf a list of expressions is given, the variables are initialized with the expressions following the rules for assignment statements. Otherwise, each variable is initialized to its zero value.\n\nIf a type is present, each variable is given that type. Otherwise, each variable is given the type of the corresponding initialization value in the assignment. If that value is an untyped constant, it is first implicitly converted to its default type; if it is an untyped boolean value, it is first implicitly converted to type . The predeclared identifier cannot be used to initialize a variable with no explicit type.\n\nImplementation restriction: A compiler may make it illegal to declare a variable inside a function body if the variable is never used.\n\nIt is shorthand for a regular variable declaration with initializer expressions but no types:\n\nUnlike regular variable declarations, a short variable declaration may redeclare variables provided they were originally declared earlier in the same block (or the parameter lists if the block is the function body) with the same type, and at least one of the non-blank variables is new. As a consequence, redeclaration can only appear in a multi-variable short declaration. Redeclaration does not introduce a new variable; it just assigns a new value to the original. The non-blank variable names on the left side of must be unique.\n\nShort variable declarations may appear only inside functions. In some contexts such as the initializers for \"if\", \"for\", or \"switch\" statements, they can be used to declare local temporary variables.\n\nA function declaration binds an identifier, the function name, to a function.\n\nIf the function's signature declares result parameters, the function body's statement list must end in a terminating statement.\n\nIf the function declaration specifies type parameters, the function name denotes a generic function. A generic function must be instantiated before it can be called or used as a value.\n\nA function declaration without type parameters may omit the body. Such a declaration provides the signature for a function implemented outside Go, such as an assembly routine.\n\nA method is a function with a receiver. A method declaration binds an identifier, the method name, to a method, and associates the method with the receiver's base type.\n\nThe receiver is specified via an extra parameter section preceding the method name. That parameter section must declare a single non-variadic parameter, the receiver. Its type must be a defined type or a pointer to a defined type , possibly followed by a list of type parameter names enclosed in square brackets. is called the receiver base type. A receiver base type cannot be a pointer or interface type and it must be defined in the same package as the method. The method is said to be bound to its receiver base type and the method name is visible only within selectors for type or .\n\nA non-blank receiver identifier must be unique in the method signature. If the receiver's value is not referenced inside the body of the method, its identifier may be omitted in the declaration. The same applies in general to parameters of functions and methods.\n\nFor a base type, the non-blank names of methods bound to it must be unique. If the base type is a struct type, the non-blank method and field names must be distinct.\n\nbind the methods and , with receiver type , to the base type .\n\nIf the receiver base type is a generic type, the receiver specification must declare corresponding type parameters for the method to use. This makes the receiver type parameters available to the method. Syntactically, this type parameter declaration looks like an instantiation of the receiver base type: the type arguments must be identifiers denoting the type parameters being declared, one for each type parameter of the receiver base type. The type parameter names do not need to match their corresponding parameter names in the receiver base type definition, and all non-blank parameter names must be unique in the receiver parameter section and the method signature. The receiver type parameter constraints are implied by the receiver base type definition: corresponding type parameters have corresponding constraints.\n\nIf the receiver type is denoted by (a pointer to) an alias, the alias must not be generic and it must not denote an instantiated generic type, neither directly nor indirectly via another alias, and irrespective of pointer indirections.\n\nAn expression specifies the computation of a value by applying operators and functions to operands.\n\nOperands denote the elementary values in an expression. An operand may be a literal, a (possibly qualified) non-blank identifier denoting a constant, variable, or function, or a parenthesized expression.\n\nAn operand name denoting a generic function may be followed by a list of type arguments; the resulting operand is an instantiated function.\n\nThe blank identifier may appear as an operand only on the left-hand side of an assignment statement.\n\nImplementation restriction: A compiler need not report an error if an operand's type is a type parameter with an empty type set. Functions with such type parameters cannot be instantiated; any attempt will lead to an error at the instantiation site.\n\nA qualified identifier is an identifier qualified with a package name prefix. Both the package name and the identifier must not be blank.\n\nA qualified identifier accesses an identifier in a different package, which must be imported. The identifier must be exported and declared in the package block of that package.\n\nComposite literals construct new composite values each time they are evaluated. They consist of the type of the literal followed by a brace-bound list of elements. Each element may optionally be preceded by a corresponding key.\n\nThe LiteralType's core type must be a struct, array, slice, or map type (the syntax enforces this constraint except when the type is given as a TypeName). The types of the elements and keys must be assignable to the respective field, element, and key types of type ; there is no additional conversion. The key is interpreted as a field name for struct literals, an index for array and slice literals, and a key for map literals. For map literals, all elements must have a key. It is an error to specify multiple elements with the same field name or constant key value. For non-constant map keys, see the section on evaluation order.\n\nFor struct literals the following rules apply:\n• A key must be a field name declared in the struct type.\n• An element list that does not contain any keys must list an element for each struct field in the order in which the fields are declared.\n• If any element has a key, every element must have a key.\n• An element list that contains keys does not need to have an element for each struct field. Omitted fields get the zero value for that field.\n• A literal may omit the element list; such a literal evaluates to the zero value for its type.\n• It is an error to specify an element for a non-exported field of a struct belonging to a different package.\n\nFor array and slice literals the following rules apply:\n• Each element has an associated integer index marking its position in the array.\n• An element with a key uses the key as its index. The key must be a non-negative constant representable by a value of type ; and if it is typed it must be of integer type.\n• An element without a key uses the previous element's index plus one. If the first element has no key, its index is zero.\n\nTaking the address of a composite literal generates a pointer to a unique variable initialized with the literal's value.\n\nNote that the zero value for a slice or map type is not the same as an initialized but empty value of the same type. Consequently, taking the address of an empty slice or map composite literal does not have the same effect as allocating a new slice or map value with new.\n\nThe length of an array literal is the length specified in the literal type. If fewer elements than the length are provided in the literal, the missing elements are set to the zero value for the array element type. It is an error to provide elements with index values outside the index range of the array. The notation specifies an array length equal to the maximum element index plus one.\n\nA slice literal describes the entire underlying array literal. Thus the length and capacity of a slice literal are the maximum element index plus one. A slice literal has the form\n\nand is shorthand for a slice operation applied to an array:\n\nWithin a composite literal of array, slice, or map type , elements or map keys that are themselves composite literals may elide the respective literal type if it is identical to the element or key type of . Similarly, elements or keys that are addresses of composite literals may elide the when the element or key type is .\n\nA parsing ambiguity arises when a composite literal using the TypeName form of the LiteralType appears as an operand between the keyword and the opening brace of the block of an \"if\", \"for\", or \"switch\" statement, and the composite literal is not enclosed in parentheses, square brackets, or curly braces. In this rare case, the opening brace of the literal is erroneously parsed as the one introducing the block of statements. To resolve the ambiguity, the composite literal must appear within parentheses.\n\nA function literal can be assigned to a variable or invoked directly.\n\nFunction literals are closures: they may refer to variables defined in a surrounding function. Those variables are then shared between the surrounding function and the function literal, and they survive as long as they are accessible.\n\nPrimary expressions are the operands for unary and binary expressions.\n\nFor a primary expression that is not a package name, the selector expression\n\ndenotes the field or method of the value (or sometimes ; see below). The identifier is called the (field or method) selector; it must not be the blank identifier. The type of the selector expression is the type of . If is a package name, see the section on qualified identifiers.\n\nA selector may denote a field or method of a type , or it may refer to a field or method of a nested embedded field of . The number of embedded fields traversed to reach is called its depth in . The depth of a field or method declared in is zero. The depth of a field or method declared in an embedded field in is the depth of in plus one.\n\nThe following rules apply to selectors:\n• For a value of type or where is not a pointer or interface type, denotes the field or method at the shallowest depth in where there is such an . If there is not exactly one with shallowest depth, the selector expression is illegal.\n• For a value of type where is an interface type, denotes the actual method with name of the dynamic value of . If there is no method with name in the method set of , the selector expression is illegal.\n• As an exception, if the type of is a defined pointer type and is a valid selector expression denoting a field (but not a method), is shorthand for .\n• In all other cases, is illegal.\n• If is of pointer type and has the value and denotes a struct field, assigning to or evaluating causes a run-time panic.\n• If is of interface type and has the value , calling or evaluating the method causes a run-time panic.\n\nFor example, given the declarations:\n\nbut the following is invalid:\n\nIf is in the method set of type , is a function that is callable as a regular function with the same arguments as prefixed by an additional argument that is the receiver of the method.\n\nConsider a struct type with two methods, , whose receiver is of type , and , whose receiver is of type .\n\nyields a function equivalent to but with an explicit receiver as its first argument; it has signature\n\nThat function may be called normally with an explicit receiver, so these five invocations are equivalent:\n\nFor a method with a value receiver, one can derive a function with an explicit pointer receiver, so\n\nSuch a function indirects through the receiver to create a value to pass as the receiver to the underlying method; the method does not overwrite the value whose address is passed in the function call.\n\nThe final case, a value-receiver function for a pointer-receiver method, is illegal because pointer-receiver methods are not in the method set of the value type.\n\nFunction values derived from methods are called with function call syntax; the receiver is provided as the first argument to the call. That is, given , is invoked as not . To construct a function that binds the receiver, use a function literal or method value.\n\nIt is legal to derive a function value from a method of an interface type. The resulting function takes an explicit receiver of that interface type.\n\nIf the expression has static type and is in the method set of type , is called a method value. The method value is a function value that is callable with the same arguments as a method call of . The expression is evaluated and saved during the evaluation of the method value; the saved copy is then used as the receiver in any calls, which may be executed later.\n\nThe type may be an interface or non-interface type.\n\nAs in the discussion of method expressions above, consider a struct type with two methods, , whose receiver is of type , and , whose receiver is of type .\n\nThese two invocations are equivalent:\n\nAs with selectors, a reference to a non-interface method with a value receiver using a pointer will automatically dereference that pointer: is equivalent to .\n\nAs with method calls, a reference to a non-interface method with a pointer receiver using an addressable value will automatically take the address of that value: is equivalent to .\n\nAlthough the examples above use non-interface types, it is also legal to create a method value from a value of interface type.\n\ndenotes the element of the array, pointer to array, slice, string or map indexed by . The value is called the index or map key, respectively. The following rules apply:\n\nIf is neither a map nor a type parameter:\n• the index must be an untyped constant or its core type must be an integer\n• a constant index must be non-negative and representable by a value of type\n• a constant index that is untyped is given type\n• the index is in range if , otherwise it is out of range\n• a constant index must be in range\n• if is out of range at run time, a run-time panic occurs\n• is the array element at index and the type of is the element type of\n\nFor of pointer to array type:\n• if is out of range at run time, a run-time panic occurs\n• is the slice element at index and the type of is the element type of\n• a constant index must be in range if the string is also constant\n• if is out of range at run time, a run-time panic occurs\n• is the non-constant byte value at index and the type of is\n• may not be assigned to\n• 's type must be assignable to the key type of\n• if the map contains an entry with key , is the map element with key and the type of is the element type of\n• if the map is or does not contain such an entry, is the zero value for the element type of\n• The index expression must be valid for values of all types in 's type set.\n• The element types of all types in 's type set must be identical. In this context, the element type of a string type is .\n• If there is a map type in the type set of , all types in that type set must be map types, and the respective key types must be all identical.\n• is the array, slice, or string element at index , or the map element with key of the type argument that is instantiated with, and the type of is the type of the (identical) element types.\n• may not be assigned to if 's type set includes string types.\n\nAn index expression on a map of type used in an assignment statement or initialization of the special form\n\nyields an additional untyped boolean value. The value of is if the key is present in the map, and otherwise.\n\nAssigning to an element of a map causes a run-time panic.\n\nSlice expressions construct a substring or slice from a string, array, pointer to array, or slice. There are two variants: a simple form that specifies a low and high bound, and a full form that also specifies a bound on the capacity.\n\nconstructs a substring or slice. The core type of must be a string, array, pointer to array, slice, or a . The indices and select which elements of operand appear in the result. The result has indices starting at 0 and length equal to - . After slicing the array\n\nthe slice has type , length 3, capacity 4, and elements\n\nFor convenience, any of the indices may be omitted. A missing index defaults to zero; a missing index defaults to the length of the sliced operand:\n\nIf is a pointer to an array, is shorthand for .\n\nFor arrays or strings, the indices are in range if <= <= <= , otherwise they are out of range. For slices, the upper index bound is the slice capacity rather than the length. A constant index must be non-negative and representable by a value of type ; for arrays or constant strings, constant indices must also be in range. If both indices are constant, they must satisfy . If the indices are out of range at run time, a run-time panic occurs.\n\nExcept for untyped strings, if the sliced operand is a string or slice, the result of the slice operation is a non-constant value of the same type as the operand. For untyped string operands the result is a non-constant value of type . If the sliced operand is an array, it must be addressable and the result of the slice operation is a slice with the same element type as the array.\n\nIf the sliced operand of a valid slice expression is a slice, the result is a slice. Otherwise, if the result is a slice, it shares its underlying array with the operand.\n\nconstructs a slice of the same type, and with the same length and elements as the simple slice expression . Additionally, it controls the resulting slice's capacity by setting it to . Only the first index may be omitted; it defaults to 0. The core type of must be an array, pointer to array, or slice (but not a string). After slicing the array\n\nthe slice has type , length 2, capacity 4, and elements\n\nAs for simple slice expressions, if is a pointer to an array, is shorthand for . If the sliced operand is an array, it must be addressable.\n\nThe indices are in range if , otherwise they are out of range. A constant index must be non-negative and representable by a value of type ; for arrays, constant indices must also be in range. If multiple indices are constant, the constants that are present must be in range relative to each other. If the indices are out of range at run time, a run-time panic occurs.\n\nFor an expression of interface type, but not a type parameter, and a type , the primary expression\n\nasserts that is not and that the value stored in is of type . The notation is called a type assertion.\n\nMore precisely, if is not an interface type, asserts that the dynamic type of is identical to the type . In this case, must implement the (interface) type of ; otherwise the type assertion is invalid since it is not possible for to store a value of type . If is an interface type, asserts that the dynamic type of implements the interface .\n\nIf the type assertion holds, the value of the expression is the value stored in and its type is . If the type assertion is false, a run-time panic occurs. In other words, even though the dynamic type of is known only at run time, the type of is known to be in a correct program.\n\nA type assertion used in an assignment statement or initialization of the special form\n\nyields an additional untyped boolean value. The value of is if the assertion holds. Otherwise it is and the value of is the zero value for type . No run-time panic occurs in this case.\n\nGiven an expression with a core type of function type,\n\ncalls with arguments . Except for one special case, arguments must be single-valued expressions assignable to the parameter types of and are evaluated before the function is called. The type of the expression is the result type of . A method invocation is similar but the method itself is specified as a selector upon a value of the receiver type for the method.\n\nIf denotes a generic function, it must be instantiated before it can be called or used as a function value.\n\nIn a function call, the function value and arguments are evaluated in the usual order. After they are evaluated, new storage is allocated for the function's variables, which includes its parameters and results. Then, the arguments of the call are passed to the function, which means that they are assigned to their corresponding function parameters, and the called function begins execution. The return parameters of the function are passed back to the caller when the function returns.\n\nAs a special case, if the return values of a function or method are equal in number and individually assignable to the parameters of another function or method , then the call will invoke after passing the return values of to the parameters of in order. The call of must contain no parameters other than the call of , and must have at least one return value. If has a final parameter, it is assigned the return values of that remain after assignment of regular parameters.\n\nA method call is valid if the method set of (the type of) contains and the argument list can be assigned to the parameter list of . If is addressable and 's method set contains , is shorthand for :\n\nThere is no distinct method type and there are no method literals.\n\nIf is variadic with a final parameter of type , then within the type of is equivalent to type . If is invoked with no actual arguments for , the value passed to is . Otherwise, the value passed is a new slice of type with a new underlying array whose successive elements are the actual arguments, which all must be assignable to . The length and capacity of the slice is therefore the number of arguments bound to and may differ for each call site.\n\nGiven the function and calls\n\nwithin , will have the value in the first call, and in the second.\n\nIf the final argument is assignable to a slice type and is followed by , it is passed unchanged as the value for a parameter. In this case no new slice is created.\n\nGiven the slice and call\n\nwithin , will have the same value as with the same underlying array.\n\nA generic function or type is instantiated by substituting type arguments for the type parameters [Go 1.18]. Instantiation proceeds in two steps:\n• Each type argument is substituted for its corresponding type parameter in the generic declaration. This substitution happens across the entire function or type declaration, including the type parameter list itself and any types in that list.\n• After substitution, each type argument must satisfy the constraint (instantiated, if necessary) of the corresponding type parameter. Otherwise instantiation fails.\n\nInstantiating a type results in a new non-generic named type; instantiating a function produces a new non-generic function.\n\nWhen using a generic function, type arguments may be provided explicitly, or they may be partially or completely inferred from the context in which the function is used. Provided that they can be inferred, type argument lists may be omitted entirely if the function is:\n• assigned to a variable with a known type\n• passed as an argument to another function, or\n\nIn all other cases, a (possibly partial) type argument list must be present. If a type argument list is absent or partial, all missing type arguments must be inferrable from the context in which the function is used.\n\nA partial type argument list cannot be empty; at least the first argument must be present. The list is a prefix of the full list of type arguments, leaving the remaining arguments to be inferred. Loosely speaking, type arguments may be omitted from \"right to left\".\n\nFor a generic type, all type arguments must always be provided explicitly.\n\nA use of a generic function may omit some or all type arguments if they can be inferred from the context within which the function is used, including the constraints of the function's type parameters. Type inference succeeds if it can infer the missing type arguments and instantiation succeeds with the inferred type arguments. Otherwise, type inference fails and the program is invalid.\n\nType inference uses the type relationships between pairs of types for inference: For instance, a function argument must be assignable to its respective function parameter; this establishes a relationship between the type of the argument and the type of the parameter. If either of these two types contains type parameters, type inference looks for the type arguments to substitute the type parameters with such that the assignability relationship is satisfied. Similarly, type inference uses the fact that a type argument must satisfy the constraint of its respective type parameter.\n\nEach such pair of matched types corresponds to a type equation containing one or multiple type parameters, from one or possibly multiple generic functions. Inferring the missing type arguments means solving the resulting set of type equations for the respective type parameters.\n\nFor example, given\n\nthe variable of type must be assignable to the function parameter type for the program to be valid. To reduce complexity, type inference ignores the directionality of assignments, so the type relationship between and can be expressed via the (symmetric) type equation (or for that matter), where the in indicates that the LHS and RHS types must match per assignability rules (see the section on type unification for details). Similarly, the type parameter must satisfy its constraint . This can be expressed as where stands for \" satisfies constraint \". These observations lead to a set of two equations\n\nwhich now can be solved for the type parameters and . From (1) a compiler can infer that the type argument for is . Similarly, because the underlying type of is and must match of the constraint, a compiler can infer that must be . Thus, for these two equations, type inference infers\n\nGiven a set of type equations, the type parameters to solve for are the type parameters of the functions that need to be instantiated and for which no explicit type arguments is provided. These type parameters are called bound type parameters. For instance, in the example above, the type parameters and are bound to . An argument to a generic function call may be a generic function itself. The type parameters of that function are included in the set of bound type parameters. The types of function arguments may contain type parameters from other functions (such as a generic function enclosing a function call). Those type parameters may also appear in type equations but they are not bound in that context. Type equations are always solved for the bound type parameters only.\n\nType inference supports calls of generic functions and assignments of generic functions to (explicitly function-typed) variables. This includes passing generic functions as arguments to other (possibly also generic) functions, and returning generic functions as results. Type inference operates on a set of equations specific to each of these cases. The equations are as follows (type argument lists are omitted for clarity):\n• For a function call where or a function argument is a generic function: \n\n Each pair of corresponding function arguments and parameters where is not an untyped constant yields an equation . \n\n If is an untyped constant , and is a bound type parameter , the pair is collected separately from the type equations.\n• For an assignment of a generic function to a (non-generic) variable of function type: \n\n .\n• For a return statement where is a generic function returned as a result to a (non-generic) result variable of function type: \n\n .\n\nAdditionally, each type parameter and corresponding type constraint yields the type equation .\n\nType inference gives precedence to type information obtained from typed operands before considering untyped constants. Therefore, inference proceeds in two phases:\n• The type equations are solved for the bound type parameters using type unification. If unification fails, type inference fails.\n• For each bound type parameter for which no type argument has been inferred yet and for which one or more pairs with that same type parameter were collected, determine the constant kind of the constants in all those pairs the same way as for constant expressions. The type argument for is the default type for the determined constant kind. If a constant kind cannot be determined due to conflicting constant kinds, type inference fails.\n\nIf not all type arguments have been found after these two phases, type inference fails.\n\nIf the two phases are successful, type inference determined a type argument for each bound type parameter:\n\nA type argument may be a composite type, containing other bound type parameters as element types (or even be just another bound type parameter). In a process of repeated simplification, the bound type parameters in each type argument are substituted with the respective type arguments for those type parameters until each type argument is free of bound type parameters.\n\nIf type arguments contain cyclic references to themselves through bound type parameters, simplification and thus type inference fails. Otherwise, type inference succeeds.\n\nType inference solves type equations through type unification. Type unification recursively compares the LHS and RHS types of an equation, where either or both types may be or contain bound type parameters, and looks for type arguments for those type parameters such that the LHS and RHS match (become identical or assignment-compatible, depending on context). To that effect, type inference maintains a map of bound type parameters to inferred type arguments; this map is consulted and updated during type unification. Initially, the bound type parameters are known but the map is empty. During type unification, if a new type argument is inferred, the respective mapping from type parameter to argument is added to the map. Conversely, when comparing types, a known type argument (a type argument for which a map entry already exists) takes the place of its corresponding type parameter. As type inference progresses, the map is populated more and more until all equations have been considered, or until unification fails. Type inference succeeds if no unification step fails and the map has an entry for each type parameter.\n\nFor example, given the type equation with the bound type parameter\n\ntype inference starts with an empty map. Unification first compares the top-level structure of the LHS and RHS types. Both are arrays of the same length; they unify if the element types unify. Both element types are structs; they unify if they have the same number of fields with the same names and if the field types unify. The type argument for is not known yet (there is no map entry), so unifying with adds the mapping to the map. Unifying the types of the field requires unifying and and thus and . Since the type argument for is known at this point (there is a map entry for ), its type argument takes the place of . And since is identical to , this unification step succeeds as well. Unification of the LHS and RHS of the equation is now finished. Type inference succeeds because there is only one type equation, no unification step failed, and the map is fully populated.\n\nUnification uses a combination of exact and loose unification depending on whether two types have to be identical, assignment-compatible, or only structurally equal. The respective type unification rules are spelled out in detail in the Appendix.\n\nFor an equation of the form , where and are types involved in an assignment (including parameter passing and return statements), the top-level type structures may unify loosely but element types must unify exactly, matching the rules for assignments.\n\nFor an equation of the form , where is a type parameter and its corresponding constraint, the unification rules are bit more complicated:\n• If has a core type and has a known type argument , and must unify loosely. If does not have a known type argument and contains exactly one type term that is not an underlying (tilde) type, unification adds the mapping to the map.\n• If does not have a core type and has a known type argument , must have all methods of , if any, and corresponding method types must unify exactly.\n\nWhen solving type equations from type constraints, solving one equation may infer additional type arguments, which in turn may enable solving other equations that depend on those type arguments. Type inference repeats type unification as long as new type arguments are inferred.\n\nComparisons are discussed elsewhere. For other binary operators, the operand types must be identical unless the operation involves shifts or untyped constants. For operations involving constants only, see the section on constant expressions.\n\nExcept for shift operations, if one operand is an untyped constant and the other operand is not, the constant is implicitly converted to the type of the other operand.\n\nThe right operand in a shift expression must have integer type [Go 1.13] or be an untyped constant representable by a value of type . If the left operand of a non-constant shift expression is an untyped constant, it is first implicitly converted to the type it would assume if the shift expression were replaced by its left operand alone.\n\nUnary operators have the highest precedence. As the and operators form statements, not expressions, they fall outside the operator hierarchy. As a consequence, statement is the same as .\n\nThere are five precedence levels for binary operators. Multiplication operators bind strongest, followed by addition operators, comparison operators, (logical AND), and finally (logical OR):\n\nBinary operators of the same precedence associate from left to right. For instance, is the same as .\n\nArithmetic operators apply to numeric values and yield a result of the same type as the first operand. The four standard arithmetic operators ( , , , ) apply to integer, floating-point, and complex types; also applies to strings. The bitwise logical and shift operators apply to integers only.\n\nIf the operand type is a type parameter, the operator must apply to each type in that type set. The operands are represented as values of the type argument that the type parameter is instantiated with, and the operation is computed with the precision of that type argument. For example, given the function:\n\nthe product and the addition are computed with or precision, respectively, depending on the type argument for .\n\nFor two integer values and , the integer quotient and remainder satisfy the following relationships:\n\nwith truncated towards zero (\"truncated division\").\n\nThe one exception to this rule is that if the dividend is the most negative value for the int type of , the quotient is equal to (and ) due to two's-complement integer overflow:\n\nIf the divisor is a constant, it must not be zero. If the divisor is zero at run time, a run-time panic occurs. If the dividend is non-negative and the divisor is a constant power of 2, the division may be replaced by a right shift, and computing the remainder may be replaced by a bitwise AND operation:\n\nThe shift operators shift the left operand by the shift count specified by the right operand, which must be non-negative. If the shift count is negative at run time, a run-time panic occurs. The shift operators implement arithmetic shifts if the left operand is a signed integer and logical shifts if it is an unsigned integer. There is no upper limit on the shift count. Shifts behave as if the left operand is shifted times by 1 for a shift count of . As a result, is the same as and is the same as but truncated towards negative infinity.\n\nFor integer operands, the unary operators , , and are defined as follows:\n\nFor unsigned integer values, the operations , , , and are computed modulo 2n, where n is the bit width of the unsigned integer's type. Loosely speaking, these unsigned integer operations discard high bits upon overflow, and programs may rely on \"wrap around\".\n\nFor signed integers, the operations , , , , and may legally overflow and the resulting value exists and is deterministically defined by the signed integer representation, the operation, and its operands. Overflow does not cause a run-time panic. A compiler may not optimize code under the assumption that overflow does not occur. For instance, it may not assume that is always true.\n\nFor floating-point and complex numbers, is the same as , while is the negation of . The result of a floating-point or complex division by zero is not specified beyond the IEEE 754 standard; whether a run-time panic occurs is implementation-specific.\n\nAn implementation may combine multiple floating-point operations into a single fused operation, possibly across statements, and produce a result that differs from the value obtained by executing and rounding the instructions individually. An explicit floating-point type conversion rounds to the precision of the target type, preventing fusion that would discard that rounding.\n\nFor instance, some architectures provide a \"fused multiply and add\" (FMA) instruction that computes without rounding the intermediate result . These examples show when a Go implementation can use that instruction:\n\nStrings can be concatenated using the operator or the assignment operator:\n\nString addition creates a new string by concatenating the operands.\n\nComparison operators compare two operands and yield an untyped boolean value.\n\nIn any comparison, the first operand must be assignable to the type of the second operand, or vice versa.\n\nThe equality operators and apply to operands of comparable types. The ordering operators , , , and apply to operands of ordered types. These terms and the result of the comparisons are defined as follows:\n• Boolean types are comparable. Two boolean values are equal if they are either both or both .\n• Integer types are comparable and ordered. Two integer values are compared in the usual way.\n• Floating-point types are comparable and ordered. Two floating-point values are compared as defined by the IEEE 754 standard.\n• Complex types are comparable. Two complex values and are equal if both and .\n• String types are comparable and ordered. Two string values are compared lexically byte-wise.\n• Pointer types are comparable. Two pointer values are equal if they point to the same variable or if both have value . Pointers to distinct zero-size variables may or may not be equal.\n• Channel types are comparable. Two channel values are equal if they were created by the same call to or if both have value .\n• Interface types that are not type parameters are comparable. Two interface values are equal if they have identical dynamic types and equal dynamic values or if both have value .\n• A value of non-interface type and a value of interface type can be compared if type is comparable and implements . They are equal if 's dynamic type is identical to and 's dynamic value is equal to .\n• Struct types are comparable if all their field types are comparable. Two struct values are equal if their corresponding non-blank field values are equal. The fields are compared in source order, and comparison stops as soon as two field values differ (or all fields have been compared).\n• Array types are comparable if their array element types are comparable. Two array values are equal if their corresponding element values are equal. The elements are compared in ascending index order, and comparison stops as soon as two element values differ (or all elements have been compared).\n• Type parameters are comparable if they are strictly comparable (see below).\n\nA comparison of two interface values with identical dynamic types causes a run-time panic if that type is not comparable. This behavior applies not only to direct interface value comparisons but also when comparing arrays of interface values or structs with interface-valued fields.\n\nSlice, map, and function types are not comparable. However, as a special case, a slice, map, or function value may be compared to the predeclared identifier . Comparison of pointer, channel, and interface values to is also allowed and follows from the general rules above.\n\nA type is strictly comparable if it is comparable and not an interface type nor composed of interface types. Specifically:\n• Struct types are strictly comparable if all their field types are strictly comparable.\n• Array types are strictly comparable if their array element types are strictly comparable.\n• Type parameters are strictly comparable if all types in their type set are strictly comparable.\n\nLogical operators apply to boolean values and yield a result of the same type as the operands. The left operand is evaluated, and then the right if the condition requires it.\n\nFor an operand of type , the address operation generates a pointer of type to . The operand must be addressable, that is, either a variable, pointer indirection, or slice indexing operation; or a field selector of an addressable struct operand; or an array indexing operation of an addressable array. As an exception to the addressability requirement, may also be a (possibly parenthesized) composite literal. If the evaluation of would cause a run-time panic, then the evaluation of does too.\n\nFor an operand of pointer type , the pointer indirection denotes the variable of type pointed to by . If is , an attempt to evaluate will cause a run-time panic.\n\nFor an operand whose core type is a channel, the value of the receive operation is the value received from the channel . The channel direction must permit receive operations, and the type of the receive operation is the element type of the channel. The expression blocks until a value is available. Receiving from a channel blocks forever. A receive operation on a closed channel can always proceed immediately, yielding the element type's zero value after any previously sent values have been received.\n\nA receive expression used in an assignment statement or initialization of the special form\n\nyields an additional untyped boolean result reporting whether the communication succeeded. The value of is if the value received was delivered by a successful send operation to the channel, or if it is a zero value generated because the channel is closed and empty.\n\nA conversion changes the type of an expression to the type specified by the conversion. A conversion may appear literally in the source, or it may be implied by the context in which an expression appears.\n\nAn explicit conversion is an expression of the form where is a type and is an expression that can be converted to type .\n\nIf the type starts with the operator or , or if the type starts with the keyword and has no result list, it must be parenthesized when necessary to avoid ambiguity:\n\nA constant value can be converted to type if is representable by a value of . As a special case, an integer constant can be explicitly converted to a string type using the same rule as for non-constant .\n\nConverting a constant to a type that is not a type parameter yields a typed constant.\n\nConverting a constant to a type parameter yields a non-constant value of that type, with the value represented as a value of the type argument that the type parameter is instantiated with. For example, given the function:\n\nthe conversion results in a non-constant value of type and the value is represented as a or a depending on the type argument for . Accordingly, if is instantiated with a type, the numeric value of the expression will be computed with the same precision as the corresponding non-constant addition.\n\nA non-constant value can be converted to type in any of these cases:\n• ignoring struct tags (see below), 's type and are not type parameters but have identical underlying types.\n• ignoring struct tags (see below), 's type and are pointer types that are not named types, and their pointer base types are not type parameters but have identical underlying types.\n• 's type and are both integer or floating point types.\n• 's type and are both complex types.\n• is an integer or a slice of bytes or runes and is a string type.\n• is a string and is a slice of bytes or runes.\n• is a slice, is an array [Go 1.20] or a pointer to an array [Go 1.17], and the slice and array types have identical element types.\n\nAdditionally, if or 's type are type parameters, can also be converted to type if one of the following conditions applies:\n• Both and are type parameters and a value of each type in 's type set can be converted to each type in 's type set.\n• Only is a type parameter and a value of each type in 's type set can be converted to .\n• Only is a type parameter and can be converted to each type in 's type set.\n\nStruct tags are ignored when comparing struct types for identity for the purpose of conversion:\n\nSpecific rules apply to (non-constant) conversions between numeric types or to and from a string type. These conversions may change the representation of and incur a run-time cost. All other conversions only change the type but not the representation of .\n\nThere is no linguistic mechanism to convert between pointers and integers. The package implements this functionality under restricted circumstances.\n\nFor the conversion of non-constant numeric values, the following rules apply:\n• When converting between integer types, if the value is a signed integer, it is sign extended to implicit infinite precision; otherwise it is zero extended. It is then truncated to fit in the result type's size. For example, if , then . The conversion always yields a valid value; there is no indication of overflow.\n• When converting a floating-point number to an integer, the fraction is discarded (truncation towards zero).\n• When converting an integer or floating-point number to a floating-point type, or a complex number to another complex type, the result value is rounded to the precision specified by the destination type. For instance, the value of a variable of type may be stored using additional precision beyond that of an IEEE 754 32-bit number, but float32(x) represents the result of rounding 's value to 32-bit precision. Similarly, may use more than 32 bits of precision, but does not.\n\nIn all non-constant conversions involving floating-point or complex values, if the result type cannot represent the value the conversion succeeds but the result value is implementation-dependent.\n\nConversions to and from a string type\n• Converting a slice of bytes to a string type yields a string whose successive bytes are the elements of the slice.\n• Converting a slice of runes to a string type yields a string that is the concatenation of the individual rune values converted to strings.\n• Converting a value of a string type to a slice of bytes type yields a non-nil slice whose successive elements are the bytes of the string. The capacity of the resulting slice is implementation-specific and may be larger than the slice length.\n• Converting a value of a string type to a slice of runes type yields a slice containing the individual Unicode code points of the string. The capacity of the resulting slice is implementation-specific and may be larger than the slice length.\n• Finally, for historical reasons, an integer value may be converted to a string type. This form of conversion yields a string containing the (possibly multi-byte) UTF-8 representation of the Unicode code point with the given integer value. Values outside the range of valid Unicode code points are converted to . Note: This form of conversion may eventually be removed from the language. The tool flags certain integer-to-string conversions as potential errors. Library functions such as or should be used instead.\n\nConversions from slice to array or array pointer\n\nConverting a slice to an array yields an array containing the elements of the underlying array of the slice. Similarly, converting a slice to an array pointer yields a pointer to the underlying array of the slice. In both cases, if the length of the slice is less than the length of the array, a run-time panic occurs.\n\nConstant expressions may contain only constant operands and are evaluated at compile time.\n\nUntyped boolean, numeric, and string constants may be used as operands wherever it is legal to use an operand of boolean, numeric, or string type, respectively.\n\nA constant comparison always yields an untyped boolean constant. If the left operand of a constant shift expression is an untyped constant, the result is an integer constant; otherwise it is a constant of the same type as the left operand, which must be of integer type.\n\nAny other operation on untyped constants results in an untyped constant of the same kind; that is, a boolean, integer, floating-point, complex, or string constant. If the untyped operands of a binary operation (other than a shift) are of different kinds, the result is of the operand's kind that appears later in this list: integer, rune, floating-point, complex. For example, an untyped integer constant divided by an untyped complex constant yields an untyped complex constant.\n\nApplying the built-in function to untyped integer, rune, or floating-point constants yields an untyped complex constant.\n\nConstant expressions are always evaluated exactly; intermediate values and the constants themselves may require precision significantly larger than supported by any predeclared type in the language. The following are legal declarations:\n\nThe divisor of a constant division or remainder operation must not be zero:\n\nThe values of typed constants must always be accurately representable by values of the constant type. The following constant expressions are illegal:\n\nThe mask used by the unary bitwise complement operator matches the rule for non-constants: the mask is all 1s for unsigned constants and -1 for signed and untyped constants.\n\nImplementation restriction: A compiler may use rounding while computing untyped floating-point or complex constant expressions; see the implementation restriction in the section on constants. This rounding may cause a floating-point constant expression to be invalid in an integer context, even if it would be integral when calculated using infinite precision, and vice versa.\n\nAt package level, initialization dependencies determine the evaluation order of individual initialization expressions in variable declarations. Otherwise, when evaluating the operands of an expression, assignment, or return statement, all function calls, method calls, receive operations, and binary logical operations are evaluated in lexical left-to-right order.\n\nFor example, in the (function-local) assignment\n\nthe function calls and communication happen in the order , (if evaluates to false), , , , , and . However, the order of those events compared to the evaluation and indexing of and the evaluation of and is not specified, except as required lexically. For instance, cannot be called before its arguments are evaluated.\n\nAt package level, initialization dependencies override the left-to-right rule for individual initialization expressions, but not for operands within each expression:\n\nThe function calls happen in the order , , , , , and .\n\nFloating-point operations within a single expression are evaluated according to the associativity of the operators. Explicit parentheses affect the evaluation by overriding the default associativity. In the expression the addition is performed before adding .\n\nA terminating statement interrupts the regular flow of control in a block. The following statements are terminating:\n• A block in which the statement list ends in a terminating statement.\n• An \"if\" statement in which:\n• the \"else\" branch is present, and\n• A \"for\" statement in which:\n• there are no \"break\" statements referring to the \"for\" statement, and\n• the loop condition is absent, and\n• the \"for\" statement does not use a range clause.\n• A \"switch\" statement in which:\n• there are no \"break\" statements referring to the \"switch\" statement,\n• there is a default case, and\n• the statement lists in each case, including the default, end in a terminating statement, or a possibly labeled \"fallthrough\" statement.\n• A \"select\" statement in which:\n• there are no \"break\" statements referring to the \"select\" statement, and\n• the statement lists in each case, including the default if present, end in a terminating statement.\n\nAll other statements are not terminating.\n\nA statement list ends in a terminating statement if the list is not empty and its final non-empty statement is terminating.\n\nThe empty statement does nothing.\n\nA labeled statement may be the target of a , or statement.\n\nWith the exception of specific built-in functions, function and method calls and receive operations can appear in statement context. Such statements may be parenthesized.\n\nThe following built-in functions are not permitted in statement context:\n\nA send statement sends a value on a channel. The channel expression's core type must be a channel, the channel direction must permit send operations, and the type of the value to be sent must be assignable to the channel's element type.\n\nBoth the channel and the value expression are evaluated before communication begins. Communication blocks until the send can proceed. A send on an unbuffered channel can proceed if a receiver is ready. A send on a buffered channel can proceed if there is room in the buffer. A send on a closed channel proceeds by causing a run-time panic. A send on a channel blocks forever.\n\nThe \"++\" and \"--\" statements increment or decrement their operands by the untyped constant . As with an assignment, the operand must be addressable or a map index expression.\n\nThe following assignment statements are semantically equivalent:\n\nAn assignment replaces the current value stored in a variable with a new value specified by an expression. An assignment statement may assign a single value to a single variable, or multiple values to a matching number of variables.\n\nEach left-hand side operand must be addressable, a map index expression, or (for assignments only) the blank identifier. Operands may be parenthesized.\n\nAn assignment operation op where op is a binary arithmetic operator is equivalent to op but evaluates only once. The op construct is a single token. In assignment operations, both the left- and right-hand expression lists must contain exactly one single-valued expression, and the left-hand expression must not be the blank identifier.\n\nA tuple assignment assigns the individual elements of a multi-valued operation to a list of variables. There are two forms. In the first, the right hand operand is a single multi-valued expression such as a function call, a channel or map operation, or a type assertion. The number of operands on the left hand side must match the number of values. For instance, if is a function returning two values,\n\nassigns the first value to and the second to . In the second form, the number of operands on the left must equal the number of expressions on the right, each of which must be single-valued, and the nth expression on the right is assigned to the nth operand on the left:\n\nThe blank identifier provides a way to ignore right-hand side values in an assignment:\n\nThe assignment proceeds in two phases. First, the operands of index expressions and pointer indirections (including implicit pointer indirections in selectors) on the left and the expressions on the right are all evaluated in the usual order. Second, the assignments are carried out in left-to-right order.\n\nIn assignments, each value must be assignable to the type of the operand to which it is assigned, with the following special cases:\n• Any typed value may be assigned to the blank identifier.\n• If an untyped constant is assigned to a variable of interface type or the blank identifier, the constant is first implicitly converted to its default type.\n• If an untyped boolean value is assigned to a variable of interface type or the blank identifier, it is first implicitly converted to type .\n\nWhen a value is assigned to a variable, only the data that is stored in the variable is replaced. If the value contains a reference, the assignment copies the reference but does not make a copy of the referenced data (such as the underlying array of a slice).\n\n\"If\" statements specify the conditional execution of two branches according to the value of a boolean expression. If the expression evaluates to true, the \"if\" branch is executed, otherwise, if present, the \"else\" branch is executed.\n\nThe expression may be preceded by a simple statement, which executes before the expression is evaluated.\n\n\"Switch\" statements provide multi-way execution. An expression or type is compared to the \"cases\" inside the \"switch\" to determine which branch to execute.\n\nThere are two forms: expression switches and type switches. In an expression switch, the cases contain expressions that are compared against the value of the switch expression. In a type switch, the cases contain types that are compared against the type of a specially annotated switch expression. The switch expression is evaluated exactly once in a switch statement.\n\nIn an expression switch, the switch expression is evaluated and the case expressions, which need not be constants, are evaluated left-to-right and top-to-bottom; the first one that equals the switch expression triggers execution of the statements of the associated case; the other cases are skipped. If no case matches and there is a \"default\" case, its statements are executed. There can be at most one default case and it may appear anywhere in the \"switch\" statement. A missing switch expression is equivalent to the boolean value .\n\nIf the switch expression evaluates to an untyped constant, it is first implicitly converted to its default type. The predeclared untyped value cannot be used as a switch expression. The switch expression type must be comparable.\n\nIf a case expression is untyped, it is first implicitly converted to the type of the switch expression. For each (possibly converted) case expression and the value of the switch expression, must be a valid comparison.\n\nIn other words, the switch expression is treated as if it were used to declare and initialize a temporary variable without explicit type; it is that value of against which each case expression is tested for equality.\n\nIn a case or default clause, the last non-empty statement may be a (possibly labeled) \"fallthrough\" statement to indicate that control should flow from the end of this clause to the first statement of the next clause. Otherwise control flows to the end of the \"switch\" statement. A \"fallthrough\" statement may appear as the last statement of all but the last clause of an expression switch.\n\nThe switch expression may be preceded by a simple statement, which executes before the expression is evaluated.\n\nImplementation restriction: A compiler may disallow multiple case expressions evaluating to the same constant. For instance, the current compilers disallow duplicate integer, floating point, or string constants in case expressions.\n\nA type switch compares types rather than values. It is otherwise similar to an expression switch. It is marked by a special switch expression that has the form of a type assertion using the keyword rather than an actual type:\n\nCases then match actual types against the dynamic type of the expression . As with type assertions, must be of interface type, but not a type parameter, and each non-interface type listed in a case must implement the type of . The types listed in the cases of a type switch must all be different.\n\nThe TypeSwitchGuard may include a short variable declaration. When that form is used, the variable is declared at the end of the TypeSwitchCase in the implicit block of each clause. In clauses with a case listing exactly one type, the variable has that type; otherwise, the variable has the type of the expression in the TypeSwitchGuard.\n\nInstead of a type, a case may use the predeclared identifier ; that case is selected when the expression in the TypeSwitchGuard is a interface value. There may be at most one case.\n\nGiven an expression of type , the following type switch:\n\nA type parameter or a generic type may be used as a type in a case. If upon instantiation that type turns out to duplicate another entry in the switch, the first matching case is chosen.\n\nThe type switch guard may be preceded by a simple statement, which executes before the guard is evaluated.\n\nThe \"fallthrough\" statement is not permitted in a type switch.\n\nA \"for\" statement specifies repeated execution of a block. There are three forms: The iteration may be controlled by a single condition, a \"for\" clause, or a \"range\" clause.\n\nIn its simplest form, a \"for\" statement specifies the repeated execution of a block as long as a boolean condition evaluates to true. The condition is evaluated before each iteration. If the condition is absent, it is equivalent to the boolean value .\n\nA \"for\" statement with a ForClause is also controlled by its condition, but additionally it may specify an init and a post statement, such as an assignment, an increment or decrement statement. The init statement may be a short variable declaration, but the post statement must not.\n\nIf non-empty, the init statement is executed once before evaluating the condition for the first iteration; the post statement is executed after each execution of the block (and only if the block was executed). Any element of the ForClause may be empty but the semicolons are required unless there is only a condition. If the condition is absent, it is equivalent to the boolean value .\n\nEach iteration has its own separate declared variable (or variables) [Go 1.22]. The variable used by the first iteration is declared by the init statement. The variable used by each subsequent iteration is declared implicitly before executing the post statement and initialized to the value of the previous iteration's variable at that moment.\n\nPrior to [Go 1.22], iterations share one set of variables instead of having their own separate variables. In that case, the example above prints\n\nA \"for\" statement with a \"range\" clause iterates through all entries of an array, slice, string or map, values received on a channel, integer values from zero to an upper limit [Go 1.22], or values passed to an iterator function's yield function [Go 1.23]. For each entry it assigns iteration values to corresponding iteration variables if present and then executes the block.\n\nThe expression on the right in the \"range\" clause is called the range expression, its core type must be an array, pointer to an array, slice, string, map, channel permitting receive operations, an integer, or a function with specific signature (see below). As with an assignment, if present the operands on the left must be addressable or map index expressions; they denote the iteration variables. If the range expression is a function, the maximum number of iteration variables depends on the function signature. If the range expression is a channel or integer, at most one iteration variable is permitted; otherwise there may be up to two. If the last iteration variable is the blank identifier, the range clause is equivalent to the same clause without that identifier.\n\nThe range expression is evaluated before beginning the loop, with one exception: if at most one iteration variable is present and or is constant, the range expression is not evaluated.\n\nFunction calls on the left are evaluated once per iteration. For each iteration, iteration values are produced as follows if the respective iteration variables are present:\n• For an array, pointer to array, or slice value , the index iteration values are produced in increasing order, starting at element index 0. If at most one iteration variable is present, the range loop produces iteration values from 0 up to and does not index into the array or slice itself. For a slice, the number of iterations is 0.\n• For a string value, the \"range\" clause iterates over the Unicode code points in the string starting at byte index 0. On successive iterations, the index value will be the index of the first byte of successive UTF-8-encoded code points in the string, and the second value, of type , will be the value of the corresponding code point. If the iteration encounters an invalid UTF-8 sequence, the second value will be , the Unicode replacement character, and the next iteration will advance a single byte in the string.\n• The iteration order over maps is not specified and is not guaranteed to be the same from one iteration to the next. If a map entry that has not yet been reached is removed during iteration, the corresponding iteration value will not be produced. If a map entry is created during iteration, that entry may be produced during the iteration or may be skipped. The choice may vary for each entry created and from one iteration to the next. If the map is , the number of iterations is 0.\n• For channels, the iteration values produced are the successive values sent on the channel until the channel is closed. If the channel is , the range expression blocks forever.\n• For an integer value , where is of integer type or an untyped integer constant, the iteration values 0 through are produced in increasing order. If is of integer type, the iteration values have that same type. Otherwise, the type of is determined as if it were assigned to the iteration variable. Specifically: if the iteration variable is preexisting, the type of the iteration values is the type of the iteration variable, which must be of integer type. Otherwise, if the iteration variable is declared by the \"range\" clause or is absent, the type of the iteration values is the default type for . If <= 0, the loop does not run any iterations.\n• For a function , the iteration proceeds by calling with a new, synthesized function as its argument. If is called before returns, the arguments to become the iteration values for executing the loop body once. After each successive loop iteration, returns true and may be called again to continue the loop. As long as the loop body does not terminate, the \"range\" clause will continue to generate iteration values this way for each call until returns. If the loop body terminates (such as by a statement), returns false and must not be called again.\n\nThe iteration variables may be declared by the \"range\" clause using a form of short variable declaration ( ). In this case their scope is the block of the \"for\" statement and each iteration has its own new variables [Go 1.22] (see also \"for\" statements with a ForClause). The variables have the types of their respective iteration values.\n\nIf the iteration variables are not explicitly declared by the \"range\" clause, they must be preexisting. In this case, the iteration values are assigned to the respective variables as in an assignment statement.\n\nA \"go\" statement starts the execution of a function call as an independent concurrent thread of control, or goroutine, within the same address space.\n\nThe expression must be a function or method call; it cannot be parenthesized. Calls of built-in functions are restricted as for expression statements.\n\nThe function value and parameters are evaluated as usual in the calling goroutine, but unlike with a regular call, program execution does not wait for the invoked function to complete. Instead, the function begins executing independently in a new goroutine. When the function terminates, its goroutine also terminates. If the function has any return values, they are discarded when the function completes.\n\nA \"select\" statement chooses which of a set of possible send or receive operations will proceed. It looks similar to a \"switch\" statement but with the cases all referring to communication operations.\n\nA case with a RecvStmt may assign the result of a RecvExpr to one or two variables, which may be declared using a short variable declaration. The RecvExpr must be a (possibly parenthesized) receive operation. There can be at most one default case and it may appear anywhere in the list of cases.\n\nExecution of a \"select\" statement proceeds in several steps:\n• For all the cases in the statement, the channel operands of receive operations and the channel and right-hand-side expressions of send statements are evaluated exactly once, in source order, upon entering the \"select\" statement. The result is a set of channels to receive from or send to, and the corresponding values to send. Any side effects in that evaluation will occur irrespective of which (if any) communication operation is selected to proceed. Expressions on the left-hand side of a RecvStmt with a short variable declaration or assignment are not yet evaluated.\n• If one or more of the communications can proceed, a single one that can proceed is chosen via a uniform pseudo-random selection. Otherwise, if there is a default case, that case is chosen. If there is no default case, the \"select\" statement blocks until at least one of the communications can proceed.\n• Unless the selected case is the default case, the respective communication operation is executed.\n• If the selected case is a RecvStmt with a short variable declaration or an assignment, the left-hand side expressions are evaluated and the received value (or values) are assigned.\n• The statement list of the selected case is executed.\n\nSince communication on channels can never proceed, a select with only channels and no default case blocks forever.\n\nA \"return\" statement in a function terminates the execution of , and optionally provides one or more result values. Any functions deferred by are executed before returns to its caller.\n\nIn a function without a result type, a \"return\" statement must not specify any result values.\n\nThere are three ways to return values from a function with a result type:\n• The return value or values may be explicitly listed in the \"return\" statement. Each expression must be single-valued and assignable to the corresponding element of the function's result type.\n• The expression list in the \"return\" statement may be a single call to a multi-valued function. The effect is as if each value returned from that function were assigned to a temporary variable with the type of the respective value, followed by a \"return\" statement listing these variables, at which point the rules of the previous case apply.\n• The expression list may be empty if the function's result type specifies names for its result parameters. The result parameters act as ordinary local variables and the function may assign values to them as necessary. The \"return\" statement returns the values of these variables.\n\nRegardless of how they are declared, all the result values are initialized to the zero values for their type upon entry to the function. A \"return\" statement that specifies results sets the result parameters before any deferred functions are executed.\n\nImplementation restriction: A compiler may disallow an empty expression list in a \"return\" statement if a different entity (constant, type, or variable) with the same name as a result parameter is in scope at the place of the return.\n\nA \"break\" statement terminates execution of the innermost \"for\", \"switch\", or \"select\" statement within the same function.\n\nIf there is a label, it must be that of an enclosing \"for\", \"switch\", or \"select\" statement, and that is the one whose execution terminates.\n\nA \"continue\" statement begins the next iteration of the innermost enclosing \"for\" loop by advancing control to the end of the loop block. The \"for\" loop must be within the same function.\n\nIf there is a label, it must be that of an enclosing \"for\" statement, and that is the one whose execution advances.\n\nA \"goto\" statement transfers control to the statement with the corresponding label within the same function.\n\nExecuting the \"goto\" statement must not cause any variables to come into scope that were not already in scope at the point of the goto. For instance, this example:\n\nis erroneous because the jump to label skips the creation of .\n\nA \"goto\" statement outside a block cannot jump to a label inside that block. For instance, this example:\n\nis erroneous because the label is inside the \"for\" statement's block but the is not.\n\nA \"fallthrough\" statement transfers control to the first statement of the next case clause in an expression \"switch\" statement. It may be used only as the final non-empty statement in such a clause.\n\nA \"defer\" statement invokes a function whose execution is deferred to the moment the surrounding function returns, either because the surrounding function executed a return statement, reached the end of its function body, or because the corresponding goroutine is panicking.\n\nThe expression must be a function or method call; it cannot be parenthesized. Calls of built-in functions are restricted as for expression statements.\n\nEach time a \"defer\" statement executes, the function value and parameters to the call are evaluated as usual and saved anew but the actual function is not invoked. Instead, deferred functions are invoked immediately before the surrounding function returns, in the reverse order they were deferred. That is, if the surrounding function returns through an explicit return statement, deferred functions are executed after any result parameters are set by that return statement but before the function returns to its caller. If a deferred function value evaluates to , execution panics when the function is invoked, not when the \"defer\" statement is executed.\n\nFor instance, if the deferred function is a function literal and the surrounding function has named result parameters that are in scope within the literal, the deferred function may access and modify the result parameters before they are returned. If the deferred function has any return values, they are discarded when the function completes. (See also the section on handling panics.)\n\nBuilt-in functions are predeclared. They are called like any other function but some of them accept a type instead of an expression as the first argument.\n\nThe built-in functions do not have standard Go types, so they can only appear in call expressions; they cannot be used as function values.\n\nThe built-in functions and assist in common slice operations. For both functions, the result is independent of whether the memory referenced by the arguments overlaps.\n\nThe variadic function appends zero or more values to a slice and returns the resulting slice of the same type as . The core type of must be a slice of type . The values are passed to a parameter of type and the respective parameter passing rules apply. As a special case, if the core type of is , also accepts a second argument with core type followed by . This form appends the bytes of the byte slice or string.\n\nIf the capacity of is not large enough to fit the additional values, allocates a new, sufficiently large underlying array that fits both the existing slice elements and the additional values. Otherwise, re-uses the underlying array.\n\nThe function copies slice elements from a source to a destination and returns the number of elements copied. The core types of both arguments must be slices with identical element type. The number of elements copied is the minimum of and . As a special case, if the destination's core type is , also accepts a source argument with core type . This form copies the bytes from the byte slice or string into the byte slice.\n\nThe built-in function takes an argument of map, slice, or type parameter type, and deletes or zeroes out all elements [Go 1.21].\n\nIf the type of the argument to is a type parameter, all types in its type set must be maps or slices, and performs the operation corresponding to the actual type argument.\n\nIf the map or slice is , is a no-op.\n\nFor an argument with a core type that is a channel, the built-in function records that no more values will be sent on the channel. It is an error if is a receive-only channel. Sending to or closing a closed channel causes a run-time panic. Closing the nil channel also causes a run-time panic. After calling , and after any previously sent values have been received, receive operations will return the zero value for the channel's type without blocking. The multi-valued receive operation returns a received value along with an indication of whether the channel is closed.\n\nThree functions assemble and disassemble complex numbers. The built-in function constructs a complex value from a floating-point real and imaginary part, while and extract the real and imaginary parts of a complex value.\n\nThe type of the arguments and return value correspond. For , the two arguments must be of the same floating-point type and the return type is the complex type with the corresponding floating-point constituents: for arguments, and for arguments. If one of the arguments evaluates to an untyped constant, it is first implicitly converted to the type of the other argument. If both arguments evaluate to untyped constants, they must be non-complex numbers or their imaginary parts must be zero, and the return value of the function is an untyped complex constant.\n\nFor and , the argument must be of complex type, and the return type is the corresponding floating-point type: for a argument, and for a argument. If the argument evaluates to an untyped constant, it must be a number, and the return value of the function is an untyped floating-point constant.\n\nThe and functions together form the inverse of , so for a value of a complex type , .\n\nIf the operands of these functions are all constants, the return value is a constant.\n\nArguments of type parameter type are not permitted.\n\nThe built-in function removes the element with key from a map . The value must be assignable to the key type of .\n\nIf the type of is a type parameter, all types in that type set must be maps, and they must all have identical key types.\n\nIf the map is or the element does not exist, is a no-op.\n\nThe built-in functions and take arguments of various types and return a result of type . The implementation guarantees that the result always fits into an .\n\nIf the argument type is a type parameter , the call (or respectively) must be valid for each type in 's type set. The result is the length (or capacity, respectively) of the argument whose type corresponds to the type argument with which was instantiated.\n\nThe capacity of a slice is the number of elements for which there is space allocated in the underlying array. At any time the following relationship holds:\n\nThe length of a slice, map or channel is 0. The capacity of a slice or channel is 0.\n\nThe expression is constant if is a string constant. The expressions and are constants if the type of is an array or pointer to an array and the expression does not contain channel receives or (non-constant) function calls; in this case is not evaluated. Otherwise, invocations of and are not constant and is evaluated.\n\nThe built-in function takes a type , optionally followed by a type-specific list of expressions. The core type of must be a slice, map or channel. It returns a value of type (not ). The memory is initialized as described in the section on initial values.\n\nEach of the size arguments and must be of integer type, have a type set containing only integer types, or be an untyped constant. A constant size argument must be non-negative and representable by a value of type ; if it is an untyped constant it is given type . If both and are provided and are constant, then must be no larger than . For slices and channels, if is negative or larger than at run time, a run-time panic occurs.\n\nCalling with a map type and size hint will create a map with initial space to hold map elements. The precise behavior is implementation-dependent.\n\nThe built-in functions and compute the smallest—or largest, respectively—value of a fixed number of arguments of ordered types. There must be at least one argument [Go 1.21].\n\nThe same type rules as for operators apply: for ordered arguments and , is valid if is valid, and the type of is the type of (and similarly for ). If all arguments are constant, the result is constant.\n\nFor numeric arguments, assuming all NaNs are equal, and are commutative and associative:\n\nFor floating-point arguments negative zero, NaN, and infinity the following rules apply:\n\nFor string arguments the result for is the first argument with the smallest (or for , largest) value, compared lexically byte-wise:\n\nThe built-in function takes a type , allocates storage for a variable of that type at run time, and returns a value of type pointing to it. The variable is initialized as described in the section on initial values.\n\nallocates storage for a variable of type , initializes it ( , ), and returns a value of type containing the address of the location.\n\nTwo built-in functions, and , assist in reporting and handling run-time panics and program-defined error conditions.\n\nWhile executing a function , an explicit call to or a run-time panic terminates the execution of . Any functions deferred by are then executed as usual. Next, any deferred functions run by 's caller are run, and so on up to any deferred by the top-level function in the executing goroutine. At that point, the program is terminated and the error condition is reported, including the value of the argument to . This termination sequence is called panicking.\n\nThe function allows a program to manage behavior of a panicking goroutine. Suppose a function defers a function that calls and a panic occurs in a function on the same goroutine in which is executing. When the running of deferred functions reaches , the return value of 's call to will be the value passed to the call of . If returns normally, without starting a new , the panicking sequence stops. In that case, the state of functions called between and the call to is discarded, and normal execution resumes. Any functions deferred by before are then run and 's execution terminates by returning to its caller.\n\nThe return value of is when the goroutine is not panicking or was not called directly by a deferred function. Conversely, if a goroutine is panicking and was called directly by a deferred function, the return value of is guaranteed not to be . To ensure this, calling with a interface value (or an untyped ) causes a run-time panic.\n\nThe function in the example below invokes the function argument and protects callers from run-time panics raised by .\n\nCurrent implementations provide several built-in functions useful during bootstrapping. These functions are documented for completeness but are not guaranteed to stay in the language. They do not return a result.\n\nImplementation restriction: and need not accept arbitrary argument types, but printing of boolean, numeric, and string types must be supported.\n\nGo programs are constructed by linking together packages. A package in turn is constructed from one or more source files that together declare constants, types, variables and functions belonging to the package and which are accessible in all files of the same package. Those elements may be exported and used in another package.\n\nEach source file consists of a package clause defining the package to which it belongs, followed by a possibly empty set of import declarations that declare packages whose contents it wishes to use, followed by a possibly empty set of declarations of functions, types, variables, and constants.\n\nA package clause begins each source file and defines the package to which the file belongs.\n\nThe PackageName must not be the blank identifier.\n\nA set of files sharing the same PackageName form the implementation of a package. An implementation may require that all source files for a package inhabit the same directory.\n\nAn import declaration states that the source file containing the declaration depends on functionality of the imported package (§Program initialization and execution) and enables access to exported identifiers of that package. The import names an identifier (PackageName) to be used for access and an ImportPath that specifies the package to be imported.\n\nThe PackageName is used in qualified identifiers to access exported identifiers of the package within the importing source file. It is declared in the file block. If the PackageName is omitted, it defaults to the identifier specified in the package clause of the imported package. If an explicit period ( ) appears instead of a name, all the package's exported identifiers declared in that package's package block will be declared in the importing source file's file block and must be accessed without a qualifier.\n\nThe interpretation of the ImportPath is implementation-dependent but it is typically a substring of the full file name of the compiled package and may be relative to a repository of installed packages.\n\nImplementation restriction: A compiler may restrict ImportPaths to non-empty strings using only characters belonging to Unicode's L, M, N, P, and S general categories (the Graphic characters without spaces) and may also exclude the characters and the Unicode replacement character U+FFFD.\n\nConsider a compiled a package containing the package clause , which exports function , and installed the compiled package in the file identified by . This table illustrates how is accessed in files that import the package after the various types of import declaration.\n\nAn import declaration declares a dependency relation between the importing and imported package. It is illegal for a package to import itself, directly or indirectly, or to directly import a package without referring to any of its exported identifiers. To import a package solely for its side-effects (initialization), use the blank identifier as explicit package name:\n\nHere is a complete Go package that implements a concurrent prime sieve.\n\nThe zero value\n\nWhen storage is allocated for a variable, either through a declaration or a call of , or when a new value is created, either through a composite literal or a call of , and no explicit initialization is provided, the variable or value is given a default value. Each element of such a variable or value is set to the zero value for its type: for booleans, for numeric types, for strings, and for pointers, functions, interfaces, slices, channels, and maps. This initialization is done recursively, so for instance each element of an array of structs will have its fields zeroed if no value is specified.\n\nThese two simple declarations are equivalent:\n\nThe same would also be true after\n\nWithin a package, package-level variable initialization proceeds stepwise, with each step selecting the variable earliest in declaration order which has no dependencies on uninitialized variables.\n\nMore precisely, a package-level variable is considered ready for initialization if it is not yet initialized and either has no initialization expression or its initialization expression has no dependencies on uninitialized variables. Initialization proceeds by repeatedly initializing the next package-level variable that is earliest in declaration order and ready for initialization, until there are no variables ready for initialization.\n\nIf any variables are still uninitialized when this process ends, those variables are part of one or more initialization cycles, and the program is not valid.\n\nMultiple variables on the left-hand side of a variable declaration initialized by single (multi-valued) expression on the right-hand side are initialized together: If any of the variables on the left-hand side is initialized, all those variables are initialized in the same step.\n\nFor the purpose of package initialization, blank variables are treated like any other variables in declarations.\n\nThe declaration order of variables declared in multiple files is determined by the order in which the files are presented to the compiler: Variables declared in the first file are declared before any of the variables declared in the second file, and so on. To ensure reproducible initialization behavior, build systems are encouraged to present multiple files belonging to the same package in lexical file name order to a compiler.\n\nDependency analysis does not rely on the actual values of the variables, only on lexical references to them in the source, analyzed transitively. For instance, if a variable 's initialization expression refers to a function whose body refers to variable then depends on . Specifically:\n• A reference to a variable or function is an identifier denoting that variable or function.\n• A reference to a method is a method value or method expression of the form , where the (static) type of is not an interface type, and the method is in the method set of . It is immaterial whether the resulting function value is invoked.\n• A variable, function, or method depends on a variable if 's initialization expression or body (for functions and methods) contains a reference to or to a function or method that depends on .\n\nFor example, given the declarations\n\nthe initialization order is , , , . Note that the order of subexpressions in initialization expressions is irrelevant: and result in the same initialization order in this example.\n\nDependency analysis is performed per package; only references referring to variables, functions, and (non-interface) methods declared in the current package are considered. If other, hidden, data dependencies exists between variables, the initialization order between those variables is unspecified.\n\nFor instance, given the declarations\n\nthe variable will be initialized after but whether is initialized before , between and , or after , and thus also the moment at which is called (before or after is initialized) is not specified.\n\nVariables may also be initialized using functions named declared in the package block, with no arguments and no result parameters.\n\nMultiple such functions may be defined per package, even within a single source file. In the package block, the identifier can be used only to declare functions, yet the identifier itself is not declared. Thus functions cannot be referred to from anywhere in a program.\n\nThe entire package is initialized by assigning initial values to all its package-level variables followed by calling all functions in the order they appear in the source, possibly in multiple files, as presented to the compiler.\n\nThe packages of a complete program are initialized stepwise, one package at a time. If a package has imports, the imported packages are initialized before initializing the package itself. If multiple packages import a package, the imported package will be initialized only once. The importing of packages, by construction, guarantees that there can be no cyclic initialization dependencies. More precisely:\n\nGiven the list of all packages, sorted by import path, in each step the first uninitialized package in the list for which all imported packages (if any) are already initialized is initialized. This step is repeated until all packages are initialized.\n\nPackage initialization—variable initialization and the invocation of functions—happens in a single goroutine, sequentially, one package at a time. An function may launch other goroutines, which can run concurrently with the initialization code. However, initialization always sequences the functions: it will not invoke the next one until the previous one has returned.\n\nA complete program is created by linking a single, unimported package called the main package with all the packages it imports, transitively. The main package must have package name and declare a function that takes no arguments and returns no value.\n\nProgram execution begins by initializing the program and then invoking the function in package . When that function invocation returns, the program exits. It does not wait for other (non- ) goroutines to complete.\n\nThe predeclared type is defined as\n\nIt is the conventional interface for representing an error condition, with the nil value representing no error. For instance, a function to read data from a file might be defined:\n\nExecution errors such as attempting to index an array out of bounds trigger a run-time panic equivalent to a call of the built-in function with a value of the implementation-defined interface type . That type satisfies the predeclared interface type . The exact error values that represent distinct run-time error conditions are unspecified.\n\nThe built-in package , known to the compiler and accessible through the import path , provides facilities for low-level programming including operations that violate the type system. A package using must be vetted manually for type safety and may not be portable. The package provides the following interface:\n\nA is a pointer type but a value may not be dereferenced. Any pointer or value of core type can be converted to a type of core type and vice versa. The effect of converting between and is implementation-defined.\n\nThe functions and take an expression of any type and return the alignment or size, respectively, of a hypothetical variable as if were declared via .\n\nThe function takes a (possibly parenthesized) selector , denoting a field of the struct denoted by or , and returns the field offset in bytes relative to the struct's address. If is an embedded field, it must be reachable without pointer indirections through fields of the struct. For a struct with field :\n\nComputer architectures may require memory addresses to be aligned; that is, for addresses of a variable to be a multiple of a factor, the variable's type's alignment. The function takes an expression denoting a variable of any type and returns the alignment of the (type of the) variable in bytes. For a variable :\n\nA (variable of) type has variable size if is a type parameter, or if it is an array or struct type containing elements or fields of variable size. Otherwise the size is constant. Calls to , , and are compile-time constant expressions of type if their arguments (or the struct in the selector expression for ) are types of constant size.\n\nThe function adds to and returns the updated pointer [Go 1.17]. The argument must be of integer type or an untyped constant. A constant argument must be representable by a value of type ; if it is an untyped constant it is given type . The rules for valid uses of still apply.\n\nThe function returns a slice whose underlying array starts at and whose length and capacity are . is equivalent to\n\nexcept that, as a special case, if is and is zero, returns [Go 1.17].\n\nThe argument must be of integer type or an untyped constant. A constant argument must be non-negative and representable by a value of type ; if it is an untyped constant it is given type . At run time, if is negative, or if is and is not zero, a run-time panic occurs [Go 1.17].\n\nThe function returns a pointer to the underlying array of the argument. If the slice's capacity is not zero, that pointer is . If is , the result is . Otherwise it is a non- pointer to an unspecified memory address [Go 1.20].\n\nThe function returns a value whose underlying bytes start at and whose length is . The same requirements apply to the and argument as in the function . If is zero, the result is the empty string . Since Go strings are immutable, the bytes passed to must not be modified afterwards. [Go 1.20]\n\nThe function returns a pointer to the underlying bytes of the argument. For an empty string the return value is unspecified, and may be . Since Go strings are immutable, the bytes returned by must not be modified [Go 1.20].\n\nFor the numeric types, the following sizes are guaranteed:\n\nThe following minimal alignment properties are guaranteed:\n• For a variable of any type: is at least 1.\n• For a variable of struct type: is the largest of all the values for each field of , but at least 1.\n• For a variable of array type: is the same as the alignment of a variable of the array's element type.\n\nA struct or array type has size zero if it contains no fields (or elements, respectively) that have a size greater than zero. Two distinct zero-size variables may have the same address in memory.\n\nThe Go 1 compatibility guarantee ensures that programs written to the Go 1 specification will continue to compile and run correctly, unchanged, over the lifetime of that specification. More generally, as adjustments are made and features added to the language, the compatibility guarantee ensures that a Go program that works with a specific Go language version will continue to work with any subsequent version.\n\nFor instance, the ability to use the prefix for binary integer literals was introduced with Go 1.13, indicated by [Go 1.13] in the section on integer literals. Source code containing an integer literal such as will be rejected if the implied or required language version used by the compiler is older than Go 1.13.\n\nThe following table describes the minimum language version required for features introduced after Go 1.\n• An alias declaration may be used to declare an alias name for a type.\n• Integer literals may use the prefixes , , , and for binary, and octal literals, respectively.\n• Hexadecimal floating-point literals may be written using the prefixes and .\n• The imaginary suffix may be used with any (binary, decimal, hexadecimal) integer or floating-point literal, not just decimal literals.\n• The digits of any number literal may be separated (grouped) using underscores .\n• The shift count in a shift operation may be a signed integer type.\n• Emdedding a method more than once through different embedded interfaces is not an error.\n• A slice may be converted to an array pointer if the slice and array element types match, and the array is not longer than the slice.\n• The built-in package includes the new functions and .\n\nThe 1.18 release adds polymorphic functions and types (\"generics\") to the language. Specifically:\n• The set of operators and punctuation includes the new token .\n• Interface types may embed arbitrary types (not just type names of interfaces) as well as union and type elements.\n• The set of predeclared types includes the new types and .\n• A slice may be converted to an array if the slice and array element types match and the array is not longer than the slice.\n• The built-in package includes the new functions , , and .\n• Comparable types (such as ordinary interfaces) may satisfy constraints, even if the type arguments are not strictly comparable.\n• The set of predeclared functions includes the new functions , , and .\n• Type inference uses the types of interface methods for inference. It also infers type arguments for generic functions assigned to variables or passed as arguments to other (possibly generic) functions.\n• In a \"for\" statement, each iteration has its own set of iteration variables rather than sharing the same variables in each iteration.\n• A \"for\" statement with \"range\" clause may iterate over integer values from zero to an upper limit.\n• A \"for\" statement with \"range\" clause accepts an iterator function as range expression.\n\nThe type unification rules describe if and how two types unify. The precise details are relevant for Go implementations, affect the specifics of error messages (such as whether a compiler reports a type inference or other error), and may explain why type inference fails in unusual code situations. But by and large these rules can be ignored when writing Go code: type inference is designed to mostly \"work as expected\", and the unification rules are fine-tuned accordingly.\n\nType unification is controlled by a matching mode, which may be exact or loose. As unification recursively descends a composite type structure, the matching mode used for elements of the type, the element matching mode, remains the same as the matching mode except when two types are unified for assignability ( ): in this case, the matching mode is loose at the top level but then changes to exact for element types, reflecting the fact that types don't have to be identical to be assignable.\n\nTwo types that are not bound type parameters unify exactly if any of following conditions is true:\n• Both types have identical structure and their element types unify exactly.\n• Exactly one type is an unbound type parameter with a core type, and that core type unifies with the other type per the unification rules for (loose unification at the top level and exact unification for element types).\n\nIf both types are bound type parameters, they unify per the given matching modes if:\n• At most one of the type parameters has a known type argument. In this case, the type parameters are joined: they both stand for the same type argument. If neither type parameter has a known type argument yet, a future type argument inferred for one the type parameters is simultaneously inferred for both of them.\n• Both type parameters have a known type argument and the type arguments unify per the given matching modes.\n\nA single bound type parameter and another type unify per the given matching modes if:\n• doesn't have a known type argument. In this case, is inferred as the type argument for .\n• does have a known type argument , and unify per the given matching modes, and one of the following conditions is true:\n• Both and are interface types: In this case, if both and are also defined types, they must be identical. Otherwise, if neither of them is a defined type, they must have the same number of methods (unification of and already established that the methods match).\n• Neither nor are interface types: In this case, if is a defined type, replaces as the inferred type argument for .\n\nFinally, two types that are not bound type parameters unify loosely (and per the element matching mode) if:\n• One type is a defined type, the other type is a type literal, but not an interface, and their underlying types unify per the element matching mode.\n• Both types are interfaces (but not type parameters) with identical type terms, both or neither embed the predeclared type comparable, corresponding method types unify exactly, and the method set of one of the interfaces is a subset of the method set of the other interface.\n• Only one type is an interface (but not a type parameter), corresponding methods of the two types unify per the element matching mode, and the method set of the interface is a subset of the method set of the other type.\n• Both types have the same structure and their element types unify per the element matching mode."
    },
    {
        "link": "https://go.dev/doc",
        "document": "The Go programming language is an open source project to make programmers more productive.\n\nGo is expressive, concise, clean, and efficient. Its concurrency mechanisms make it easy to write programs that get the most out of multicore and networked machines, while its novel type system enables flexible and modular program construction. Go compiles quickly to machine code yet has the convenience of garbage collection and the power of run-time reflection. It's a fast, statically typed, compiled language that feels like a dynamically typed, interpreted language.\n\nYou can collect related packages into modules, then publish the modules for other developers to use. This topic gives an overview of developing and publishing modules. When you develop modules for use by other developers, you can follow a workflow that helps ensure a reliable, consistent experience for developers using the module. This topic describes the high-level steps in that workflow. When you're developing modules to publish for others to use, you can help ensure that your modules are easier for other developers to use by following the repository conventions described in this topic. What is the right way to organize the files and directories in a typical Go project? This topic discusses some common layouts depending on the kind of module you have. A major version update can be very disruptive to your module's users because it includes breaking changes and represents a new module. Learn more in this topic. When you want to make a module available for other developers, you publish it so that it's visible to Go tools. Once you've published the module, developers importing its packages will be able to resolve a dependency on the module by running commands such as . A module's developer uses each part of a module's version number to signal the version’s stability and backward compatibility. For each new release, a module's release version number specifically reflects the nature of the module's changes since the preceding release.\n\nThree things that make Go fast, fun, and productive: interfaces, reflection, and concurrency. Builds a toy web crawler to demonstrate these. One of Go's key design goals is code adaptability; that it should be easy to take a simple design and build upon it in a clean and natural way. In this talk Andrew Gerrand describes a simple \"chat roulette\" server that matches pairs of incoming TCP connections, and then use Go's concurrency mechanisms, interfaces, and standard library to extend it with a web interface and other features. While the function of the program changes dramatically, Go's flexibility preserves the original design as it grows. Concurrency is the key to designing high performance network services. Go's concurrency primitives (goroutines and channels) provide a simple and efficient means of expressing concurrent execution. In this talk we see how tricky concurrency problems can be solved gracefully with simple Go code. This talk expands on the Go Concurrency Patterns talk to dive deeper into Go's concurrency primitives. See the Go Talks site and wiki page for more Go talks.\n\nThe Go Wiki, maintained by the Go community, includes articles about the Go language, tools, and other resources. See the Learn page at the Wiki for more Go learning resources."
    },
    {
        "link": "https://tip.golang.org/doc/go1.18",
        "document": "The latest Go release, version 1.18, is a significant release, including changes to the language, implementation of the toolchain, runtime, and libraries. Go 1.18 arrives seven months after Go 1.17. As always, the release maintains the Go 1 promise of compatibility. We expect almost all Go programs to continue to compile and run as before.\n\nChanges to the language\n\nGo 1.18 includes an implementation of generic features as described by the Type Parameters Proposal. This includes major - but fully backward-compatible - changes to the language.\n\nThese new language changes required a large amount of new code that has not had significant testing in production settings. That will only happen as more people write and use generic code. We believe that this feature is well implemented and high quality. However, unlike most aspects of Go, we can’t back up that belief with real world experience. Therefore, while we encourage the use of generics where it makes sense, please use appropriate caution when deploying generic code in production.\n\nWhile we believe that the new language features are well designed and clearly specified, it is possible that we have made mistakes. We want to stress that the Go 1 compatibility guarantee says “If it becomes necessary to address an inconsistency or incompleteness in the specification, resolving the issue could affect the meaning or legality of existing programs. We reserve the right to address such issues, including updating the implementations.” It also says “If a compiler or library has a bug that violates the specification, a program that depends on the buggy behavior may break if the bug is fixed. We reserve the right to fix such bugs.” In other words, it is possible that there will be code using generics that will work with the 1.18 release but break in later releases. We do not plan or expect to make any such change. However, breaking 1.18 programs in future releases may become necessary for reasons that we cannot today foresee. We will minimize any such breakage as much as possible, but we can’t guarantee that the breakage will be zero.\n\nThe following is a list of the most visible changes. For a more comprehensive overview, see the proposal. For details see the language spec.\n• The syntax for function and type declarations now accepts type parameters.\n• Parameterized functions and types can be instantiated by following them with a list of type arguments in square brackets.\n• The new token has been added to the set of operators and punctuation.\n• The syntax for Interface types now permits the embedding of arbitrary types (not just type names of interfaces) as well as union and type elements. Such interfaces may only be used as type constraints. An interface now defines a set of types as well as a set of methods.\n• The new predeclared identifier is an alias for the empty interface. It may be used instead of .\n• The new predeclared identifier is an interface that denotes the set of all types which can be compared using or . It may only be used as (or embedded in) a type constraint.\n\nThere are three experimental packages using generics that may be useful. These packages are in x/exp repository; their API is not covered by the Go 1 guarantee and may change as we gain more experience with generics.\n\nConstraints that are useful for generic code, such as .\n\nA collection of generic functions that operate on slices of any element type.\n\nA collection of generic functions that operate on maps of any key or element type.\n\nThe current generics implementation has the following known limitations:\n• The Go compiler cannot handle type declarations inside generic functions or methods. We hope to provide support for this feature in a future release.\n• The Go compiler does not accept arguments of type parameter type with the predeclared functions , , and . We hope to remove this restriction in a future release.\n• The Go compiler only supports calling a method on a value of type parameter type if is explicitly declared by ’s constraint interface. Similarly, method values and method expressions also are only supported if is explicitly declared by , even though might be in the method set of by virtue of the fact that all types in implement . We hope to remove this restriction in a future release.\n• The Go compiler does not support accessing a struct field where is of type parameter type even if all types in the type parameter’s type set have a field . We may remove this restriction in a future release.\n• Embedding a type parameter, or a pointer to a type parameter, as an unnamed field in a struct type is not permitted. Similarly, embedding a type parameter in an interface type is not permitted. Whether these will ever be permitted is unclear at present.\n• A union element with more than one term may not contain an interface type with a non-empty method set. Whether this will ever be permitted is unclear at present.\n\nGenerics also represent a large change for the Go ecosystem. While we have updated several core tools with generics support, there is much more to do. It will take time for remaining tools, documentation, and libraries to catch up with these language changes.\n\nThe Go 1.18 compiler now correctly reports declared but not used errors for variables that are set inside a function literal but are never used. Before Go 1.18, the compiler did not report an error in such cases. This fixes long-outstanding compiler issue #8560. As a result of this change, (possibly incorrect) programs may not compile anymore. The necessary fix is straightforward: fix the program if it was in fact incorrect, or use the offending variable, for instance by assigning it to the blank identifier . Since always pointed out this error, the number of affected programs is likely very small.\n\nThe Go 1.18 compiler now reports an overflow when passing a rune constant expression such as as an argument to the predeclared functions and , consistent with the behavior of user-defined functions. Before Go 1.18, the compiler did not report an error in such cases but silently accepted such constant arguments if they fit into an . As a result of this change, (possibly incorrect) programs may not compile anymore. The necessary fix is straightforward: fix the program if it was in fact incorrect, or explicitly convert the offending argument to the correct type. Since always pointed out this error, the number of affected programs is likely very small.\n\nGo 1.18 introduces the new environment variable, which selects at compile time a minimum target version of the AMD64 architecture. Allowed values are , , , or . Each higher level requires, and takes advantage of, additional processor features. A detailed description can be found here.\n\nThe 64-bit RISC-V architecture on Linux (the port) now supports the and build modes.\n\nGo 1.18 requires Linux kernel version 2.6.32 or later.\n\nThe and ports now support non-cooperative preemption, bringing that capability to all four Windows ports, which should hopefully address subtle bugs encountered when calling into Win32 functions that block for extended periods of time.\n\nOn iOS (the port) and iOS simulator running on AMD64-based macOS (the port), Go 1.18 now requires iOS 12 or later; support for previous versions has been discontinued.\n\nGo 1.18 is the last release that is supported on FreeBSD 11.x, which has already reached end-of-life. Go 1.19 will require FreeBSD 12.2+ or FreeBSD 13.0+. FreeBSD 13.0+ will require a kernel with the COMPAT_FREEBSD12 option set (this is the default).\n\nGo 1.18 includes an implementation of fuzzing as described by the fuzzing proposal.\n\nSee the fuzzing landing page to get started.\n\nPlease be aware that fuzzing can consume a lot of memory and may impact your machine’s performance while it runs. Also be aware that the fuzzing engine writes values that expand test coverage to a fuzz cache directory within while it runs. There is currently no limit to the number of files or total bytes that may be written to the fuzz cache, so it may occupy a large amount of storage (possibly several GBs).\n\nno longer builds or installs packages in module-aware mode. is now dedicated to adjusting dependencies in . Effectively, the flag is always enabled. To install the latest version of an executable outside the context of the current module, use . Any version query may be used instead of . This form of was added in Go 1.16, so projects supporting older versions may need to provide install instructions for both and . now reports an error when used outside a module, since there is no file to update. In GOPATH mode (with ), still builds and installs packages, as before.\n\nThe , , , and subcommands no longer automatically update the and files. (Those files can be updated explicitly using , , or .)\n\nThe command now embeds version control information in binaries. It includes the currently checked-out revision, commit time, and a flag indicating whether edited or untracked files are present. Version control information is embedded if the command is invoked in a directory within a Git, Mercurial, Fossil, or Bazaar repository, and the package and its containing main module are in the same repository. This information may be omitted using the flag .\n\nAdditionally, the command embeds information about the build, including build and tool tags (set with ), compiler, assembler, and linker flags (like ), whether cgo was enabled, and if it was, the values of the cgo environment variables (like ). Both VCS and build information may be read together with module information using or (for the currently running binary) or the new package.\n\nThe underlying data format of the embedded build information can change with new go releases, so an older version of may not handle the build information produced with a newer version of . To read the version information from a binary built with 1.18, use the command and the package from 1.18+.\n\nIf the main module’s file specifies or higher, without arguments now downloads source code for only the modules explicitly required in the main module’s file. (In a or higher module, that set already includes all dependencies needed to build the packages and tests in the main module.) To also download source code for transitive dependencies, use .\n\nThe subcommand now supports a flag to set the output directory. (Other commands still read from the directory at the module root when loading packages with , so the main use for this flag is for third-party tools that need to collect package source code.)\n\nThe command now retains additional checksums in the file for modules whose source code is needed to verify that each imported package is provided by only one module in the build list. Because this condition is rare and failure to apply it results in a build error, this change is not conditioned on the version in the main module’s file.\n\nThe command now supports a “Workspace” mode. If a file is found in the working directory or a parent directory, or one is specified using the environment variable, it will put the command into workspace mode. In workspace mode, the file will be used to determine the set of main modules used as the roots for module resolution, instead of using the normally-found file to specify the single main module. For more information see the documentation.\n\nThe command and related commands now support an flag that enables interoperation with C (or C++) code compiled with the address sanitizer (C compiler option ).\n\nThe command now supports additional command line options for the new fuzzing support described above:\n• supports , , and options. For documentation on these see .\n\nGo 1.17 introduced lines as a more readable way to write build constraints, instead of lines. As of Go 1.17, adds lines to match existing lines and keeps them in sync, while diagnoses when they are out of sync.\n\nSince the release of Go 1.18 marks the end of support for Go 1.16, all supported versions of Go now understand lines. In Go 1.18, now removes the now-obsolete lines in modules declaring or later in their files.\n\nFor more information, see go.dev/design/draft-gobuild.\n\nnow reads and formats input files concurrently, with a memory limit proportional to . On a machine with multiple CPUs, should now be significantly faster.\n\nThe tool is updated to support generic code. In most cases, it reports an error in generic code whenever it would report an error in the equivalent non-generic code after substituting for type parameters with a type from their type set. For example, reports a format error in\n\nbecause it would report a format error in the non-generic equivalent of :\n\nThe checkers , , , , and have all had moderate precision improvements to handle additional code patterns. This may lead to newly reported errors in existing packages. For example, the checker now tracks formatting strings created by concatenating string constants. So will report an error in:\n\nThe garbage collector now includes non-heap sources of garbage collector work (e.g., stack scanning) when determining how frequently to run. As a result, garbage collector overhead is more predictable when these sources are significant. For most applications these changes will be negligible; however, some Go applications may now use less memory and spend more time on garbage collection, or vice versa, than before. The intended workaround is to tweak where necessary.\n\nThe runtime now returns memory to the operating system more efficiently and has been tuned to work more aggressively as a result.\n\nGo 1.17 generally improved the formatting of arguments in stack traces, but could print inaccurate values for arguments passed in registers. This is improved in Go 1.18 by printing a question mark ( ) after each value that may be inaccurate.\n\nThe built-in function now uses a slightly different formula when deciding how much to grow a slice when it must allocate a new underlying array. The new formula is less prone to sudden transitions in allocation behavior.\n\nGo 1.17 implemented a new way of passing function arguments and results using registers instead of the stack on 64-bit x86 architecture on selected operating systems. Go 1.18 expands the supported platforms to include 64-bit ARM ( ), big- and little-endian 64-bit PowerPC ( , ), as well as 64-bit x86 architecture ( ) on all operating systems. On 64-bit ARM and 64-bit PowerPC systems, benchmarking shows typical performance improvements of 10% or more.\n\nAs mentioned in the Go 1.17 release notes, this change does not affect the functionality of any safe Go code and is designed to have no impact on most assembly code. See the Go 1.17 release notes for more details.\n\nThe compiler now can inline functions that contain range loops or labeled for loops.\n\nThe new compiler option supports the new command option.\n\nBecause the compiler’s type checker was replaced in its entirety to support generics, some error messages now may use different wording than before. In some cases, pre-Go 1.18 error messages provided more detail or were phrased in a more helpful way. We intend to address these cases in Go 1.19.\n\nBecause of changes in the compiler related to supporting generics, the Go 1.18 compile speed can be roughly 15% slower than the Go 1.17 compile speed. The execution time of the compiled code is not affected. We intend to improve the speed of the compiler in future releases.\n\nThe linker emits far fewer relocations. As a result, most codebases will link faster, require less memory to link, and generate smaller binaries. Tools that process Go binaries should use Go 1.18’s package to transparently handle both old and new binaries.\n\nThe new linker option supports the new command option.\n\nWhen building a Go release from source and is not set, previous versions of Go looked for a Go 1.4 or later bootstrap toolchain in the directory ( on Windows). Go now looks first for or before falling back to . We intend for Go 1.19 to require Go 1.17 or later for bootstrap, and this change should make the transition smoother. For more details, see go.dev/issue/44505.\n\nThe new package provides access to module versions, version control information, and build flags embedded in executable files built by the command. The same information is also available via for the currently running binary and via on the command line.\n\nThe new package defines a new IP address type, . Compared to the existing type, the type takes less memory, is immutable, and is comparable so it supports and can be used as a map key.\n\nIn addition to , the package defines , representing an IP and port, and , representing a network CIDR prefix.\n\nThe package also defines several functions to create and examine these new types: , , , , , , , , , , , , , .\n\nThe package includes new methods that parallel existing methods, but return instead of the heavier-weight or types: , , , , . The new methods support allocation-free I/O.\n\nThe package also now includes functions and methods to convert between the existing / types and : , , , .\n\nIf is not set, it now defaults to TLS 1.2 for client connections. Any safely up-to-date server is expected to support TLS 1.2, and browsers have required it since 2020. TLS 1.0 and 1.1 are still supported by setting to . The server-side default is unchanged at TLS 1.0.\n\nThe default can be temporarily reverted to TLS 1.0 by setting the environment variable. This option will be removed in Go 1.19.\n\nwill now reject certificates signed with the SHA-1 hash function. This doesn’t apply to self-signed root certificates. Practical attacks against SHA-1 have been demonstrated since 2017 and publicly trusted Certificate Authorities have not issued SHA-1 certificates since 2015.\n\nThis can be temporarily reverted by setting the environment variable. This option will be removed in a future release.\n\nMinor changes to the library\n\nAs always, there are various minor changes and updates to the library, made with the Go 1 promise of compatibility in mind.\n\nThe new method returns an empty buffer with a possibly non-empty capacity for use with append-like APIs. After appending, the buffer can be provided to a succeeding call and possibly avoid any copying.\n\nThe and methods now use the default buffer size when called on objects with a buffer.\n\nThe new function slices a around a separator. It can replace and simplify many common uses of , , , and .\n\n, , and are now allocation free and, especially for small ASCII cutsets, up to 10 times faster.\n\nThe function is now deprecated. It doesn’t handle Unicode punctuation and language-specific capitalization rules, and is superseded by the golang.org/x/text/cases package.\n\nThe , , and curve implementations are now all backed by code generated by the addchain and fiat-crypto projects, the latter of which is based on a formally-verified model of the arithmetic operations. They now use safer complete formulas and internal APIs. P-224 and P-384 are now approximately four times faster. All specific curve implementations are now constant-time.\n\nOperating on invalid curve points (those for which the method returns false, and which are never returned by or a method operating on a valid point) has always been undefined behavior, can lead to key recovery attacks, and is now unsupported by the new backend. If an invalid point is supplied to a , , or method, that method will now return a random point. The behavior might change to an explicit panic in a future release.\n\nThe new method allows access to the underlying .\n\nnow uses platform APIs to verify certificate validity on macOS and iOS when it is called with a nil or when using the root pool returned from .\n\nis now available on Windows.\n\nOn Windows, macOS, and iOS, when a returned by has additional certificates added to it, will do two verifications: one using the platform verifier APIs and the system roots, and one using the Go verifier and the additional roots. Chains returned by the platform verifier APIs will be prioritized.\n\nis deprecated. On Windows, macOS, and iOS the returned by will return a pool which does not include system roots in the slice returned by , as a static list can’t appropriately represent the platform policies and might not be available at all from the platform APIs.\n\nSupport for signing certificates using signature algorithms that depend on the MD5 hash ( ) may be removed in Go 1.19.\n\nThe and structs both now have a field, which holds the value of the attribute if present.\n\nThe constant has been added.\n\nThe File.Symbols method now returns the new exported error value ErrNoSymbols if the file has no symbol section.\n\nA directive may now start with to include files whose names start with dot or underscore.\n\nPer the proposal Additions to go/ast and go/token to support parameterized functions and types the following additions are made to the package:\n• the and nodes have a new field to hold type parameters, if any.\n• The new expression node represents index expressions with multiple indices, used for function and type instantiations with more than one explicit type argument.\n\nThe new method returns a human-readable name for the receiver kind.\n\nThe new constant represents the token per the proposal Additions to go/ast and go/token to support parameterized functions and types .\n\nThe new field sets the accepted Go language version.\n\nPer the proposal Additions to go/types to support type parameters the following additions are made to the package:\n• The new type , factory function , and associated methods are added to represent a type parameter.\n• The new type holds a list of type parameters.\n• The new type holds a list of types.\n• The new factory function allocates a with (receiver or function) type parameters. To access those type parameters, the type has two new methods and .\n• types have four new methods: to get the original parameterized types of instantiated types, and to get the type arguments or type parameters of an instantiated or parameterized type, and to set the type parameters (for instance, when importing a named type where allocation of the named type and setting of type parameters cannot be done simultaneously due to possible cycles).\n• The type has four new methods: and to query properties of the type set defined by the interface, and and to set and test whether the interface is an implicit interface around a type constraint literal.\n• The new types and , factory functions and , and associated methods are added to represent type sets in interfaces.\n• The new map records function and type instantiations through the new type.\n• The new type and associated methods are added to represent an error related to a type argument.\n• The new type and factory function are added to facilitate sharing of identical type instances across type-checked packages, via the new field.\n\nThe predicates , , , , , and now also work with arguments that are or contain generalized interfaces, i.e. interfaces that may only be used as type constraints in Go code. Note that the behavior of , , , and is undefined with arguments that are uninstantiated generic types, and is undefined if the first argument is a generalized interface.\n\nWithin a pipeline the new command will end the loop early and the new command will immediately start the next loop iteration.\n\nThe function no longer always evaluates all arguments; it stops evaluating arguments after the first argument that evaluates to false. Similarly, the function now stops evaluating arguments after the first argument that evaluates to true. This makes a difference if any of the arguments is a function call.\n\nThe and fallback implementations (used when the arguments are not the most common image types) are now faster when those arguments implement the optional and interfaces that were added in Go 1.17.\n\nOn WebAssembly targets, the , , and method fields in will now be correctly used, if specified, for making HTTP requests.\n\nThe new method reports whether the cookie is valid.\n\nThe new function creates a that wraps its and with a .\n\nWhen looking up a domain name containing non-ASCII characters, the Unicode-to-ASCII conversion is now done in accordance with Nontransitional Processing as defined in the Unicode IDNA Compatibility Processing standard (UTS #46). The interpretation of four distinct runes are changed: ß, ς, zero-width joiner U+200D, and zero-width non-joiner U+200C. Nontransitional Processing is consistent with most applications and web browsers.\n\nnow uses a Go native implementation when cgo is not available.\n\nThe new and methods set a Value using a map iterator as the source. They are equivalent to and , but do fewer allocations.\n\nThe new method returns the Value’s value as an . This allows callers to migrate from and to eliminate the need to perform uintptr to unsafe.Pointer conversions at the callsite (as unsafe.Pointer rules require).\n\nThe new method changes its receiver to iterate over a different map. The use of allows allocation-free iteration over many maps.\n\nA number of methods ( , , , ) have been added to to test if a conversion is safe.\n\nhas been added to avoid the panic that occurs in when stepping through a nil pointer to an embedded struct.\n\nand have been renamed to and , respectively, for consistency with the rest of the reflect package. The old names will continue to work, but will be deprecated in a future Go release.\n\nnow treats each invalid byte of a UTF-8 string as .\n\nThe struct has two new fields, containing additional information about how the binary was built:\n• holds the version of Go used to build the binary.\n• is a slice of structs holding key/value pairs describing the build.\n\nThe CPU profiler now uses per-thread timers on Linux. This increases the maximum CPU usage that a profile can observe, and reduces some forms of bias.\n\nThe new function slices a around a separator. It can replace and simplify many common uses of , , , and .\n\nThe new function copies the input without the returned cloned referencing the input string’s memory.\n\n, , and are now allocation free and, especially for small ASCII cutsets, up to 10 times faster.\n\nThe function is now deprecated. It doesn’t handle Unicode punctuation and language-specific capitalization rules, and is superseded by the golang.org/x/text/cases package.\n\nThe new methods , , and , will acquire the lock if it is not currently held.\n\nThe new function has been introduced for Windows, allowing for calls with arbitrary number of arguments. As a result, , , , , , and are deprecated in favor of .\n\nis now supported in FreeBSD.\n\nThe interface has been removed.\n\nThe precedence of in the argument for and has been increased. used to be treated as and is now treated as .\n\nIf the option does not select any tests, the option is ignored. This could change the behavior of existing tests in the unlikely case that a test changes the set of subtests that are run each time the test function itself is run.\n\nThe new type is used by the new fuzzing support described above. Tests also now support the command line options , , and .\n\nWithin a pipeline the new command will end the loop early and the new command will immediately start the next loop iteration.\n\nThe function no longer always evaluates all arguments; it stops evaluating arguments after the first argument that evaluates to false. Similarly, the function now stops evaluating arguments after the first argument that evaluates to true. This makes a difference if any of the arguments is a function call.\n\nThe package supports the new text/template and html/template command via the new constant and the new type , and similarly supports the new command via the new constant and the new type .\n\nThe new function appends the UTF-8 encoding of a to a ."
    },
    {
        "link": "https://stackoverflow.com/questions/42726986/generic-functions-in-go",
        "document": "I'm in the process of learning and the documentation and interactive lessons say that an empty can hold any type, as it requires no additionally implemented methods.\n\nSo for an example:\n\nSo I guess my question is if this is way of implementing generic functions or if there is another, more suitable, way of doing them."
    },
    {
        "link": "https://github.com/karanpratapsingh/learn-go",
        "document": "Hey, welcome to the course, and thanks for learning Go. I hope this course provides a great learning experience.\n\nThis course is also available on my website and as an ebook on leanpub. Please leave a ⭐ as motivation if this was helpful!\n• \n• What is Go?\n\nGo (also known as Golang) is a programming language developed at Google in 2007 and open-sourced in 2009.\n\nIt focuses on simplicity, reliability, and efficiency. It was designed to combine the efficacy, speed, and safety of a statically typed and compiled language with the ease of programming of a dynamic language to make programming more fun again.\n\nIn a way, they wanted to combine the best parts of Python and C++ so that they can build reliable systems that can take advantage of multi-core processors.\n\nBefore we start this course, let us talk about why we should learn Go.\n\nGo is quite easy to learn and has a supportive and active community.\n\nAnd being a multipurpose language you can use it for things like backend development, cloud computing, and more recently, data science.\n\nWhich makes it highly suitable for distributed systems. Projects such as Kubernetes and Docker are written in Go.\n\nGo has just 25 keywords which makes it easy to read, write and maintain. The language itself is concise.\n\nBut don't be fooled by the simplicity, Go has several powerful features that we will later learn in the course.\n\nGo is growing fast and is being adopted by companies of any size. and with that, comes new high-paying job opportunities.\n\nI hope this made you excited about Go. Let's start this course.\n\nIn this tutorial, we will install Go and setup our code editor.\n\nWe can install Go from the downloads section.\n\nThese instructions are from the official website.\n• Open the package file you downloaded and follow the prompts to install Go. The package installs the Go distribution to . The package should put the directory in your environment variable. You may need to restart any open Terminal sessions for the change to take effect.\n• Verify that you've installed Go by opening a command prompt and typing the following command:\n• Confirm that the command prints the installed version of Go.\n• Remove any previous Go installation by deleting the folder (if it exists), then extract the archive you just downloaded into , creating a fresh Go tree in :\n\nNote: You may need to run the command as root or through sudo.\n\nDo not untar the archive into an existing tree. This is known to produce broken Go installations.\n• Add to the PATH environment variable. You can do this by adding the following line to your or (for a system-wide installation):\n\nNote: Changes made to a profile file may not apply until the next time you log into your computer. To apply the changes immediately, just run the shell commands directly or execute them from the profile using a command such as source .\n• Verify that you've installed Go by opening a command prompt and typing the following command:\n• Confirm that the command prints the installed version of Go.\n• Open the MSI file you downloaded and follow the prompts to install Go.\n\nBy default, the installer will install Go to Program Files or Program Files (x86). You can change the location as needed. After installing, you will need to close and reopen any open command prompts so that changes to the environment made by the installer are reflected at the command prompt.\n• Verify that you've installed Go.\n• In the menu's search box, type cmd, then press the Enter key.\n• In the Command Prompt window that appears, type the following command:\n• Confirm that the command prints the installed version of Go.\n\nIn this course, I will be using VS Code and you can download it from here.\n\nFeel free to use any other code editor you prefer.\n\nMake sure to also install the Go extension which makes it easier to work with Go in VS Code.\n\nThis is it for the installation and setup of Go, let's start the course and write our first hello world!\n\nLet's write our first hello world program, we can start by initializing a module. For that, we can use the command.\n\nBut wait...what's a ? Don't worry we will discuss that soon! But for now, assume that the module is basically a collection of Go packages.\n\nMoving ahead, let's now create a file and write a program that simply prints hello world.\n\nIf you're wondering, is part of the Go standard library which is a set of core packages provided by the language.\n\nNow, let's quickly break down what we did here, or rather the structure of a Go program.\n\nFirst, we defined a package such as .\n\nThen, we have some imports.\n\nLast but not least, is our function which acts as an entry point for our application, just like in other languages like C, Java, or C#.\n\nRemember, the goal here is to keep a mental note, and later in the course, we'll learn about , , and other things in detail!\n\nFinally, to run our code, we can simply use command.\n\nCongratulations, you just wrote your first Go program!\n\nIn this tutorial, we will learn about variables. We will also learn about the different data types that Go provides us.\n\nThis is also known as declaration without initialization:\n\nType is omitted but will be inferred:\n\nShorthand declaration, here we omit keyword and type is always implicit. This is how we will see variables being declared most of the time. We also use the for declaration plus assignment.\n\nWe can also declare constants with the keyword. Which as the name suggests, are fixed values that cannot be reassigned.\n\nIt is also important to note that, only constants can be assigned to other constants.\n\nPerfect! Now let's look at some basic data types available in Go. Starting with string.\n\nIn Go, a string is a sequence of bytes. They are declared either using double quotes or backticks which can span multiple lines.\n\nNext is which is used to store boolean values. It can have two possible values - or .\n\nWe can use the following operators on boolean types\n\nGo has several built-in integer types of varying sizes for storing signed and unsigned integers\n\nThe size of the generic and types are platform-dependent. This means it is 32-bits wide on a 32-bit system and 64-bits wide on a 64-bit system.\n\nSimilar to signed integers, we have unsigned integers.\n\nIf you noticed, there's also an unsigned integer pointer type, which is an integer representation of a memory address. It is not recommended to use this, so we don't have to worry about it.\n\nSo which one should we use?\n\nIt is recommended that whenever we need an integer value, we should just use unless we have a specific reason to use a sized or unsigned integer type.\n\nGolang has two additional integer types called and that are aliases for and data types respectively.\n\nNext, we have floating point types which are used to store numbers with a decimal component.\n\nGo has two floating point types and . Both type follows the IEEE-754 standard.\n\nThe default type for floating point values is float64.\n\nGo provides several operators for performing operations on numeric types.\n\nThere are 2 complex types in Go, where both real and imaginary parts are and where real and imaginary parts are .\n\nWe can define complex numbers either using the built-in complex function or as literals.\n\nNow let's discuss zero values. So in Go, any variable declared without an explicit initial value is given its zero value. For example, let's declare some variables and see:\n\nSo, as we can see and are assigned as 0, as false, and as an empty string. This is quite different from how other languages do it. For example, most languages initialize unassigned variables as null or undefined.\n\nThis is great, but what are those percent symbols in our function? As you've already guessed, they are used for formatting and we will learn about them later.\n\nMoving on, now that we have seen how data types work, let's see how to do type conversion.\n\nAnd as we can see, it prints the type as and .\n\nNote that this is different from parsing.\n\nAlias types were introduced in Go 1.9. They allow developers to provide an alternate name for an existing type and use it interchangeably with the underlying type.\n\nLastly, we have defined types that unlike alias types do not use an equals sign.\n\nSo, defined types do more than just give a name to a type.\n\nIt first defines a new named type with an underlying type. However, this defined type is different from any other type, including its underline type.\n\nHence, it cannot be used interchangeably with the underlying type like alias types.\n\nIt's a bit confusing at first, hopefully, this example will make things clear.\n\nAs we can see, we cannot use the defined type interchangeably with the underlying type, unlike alias types.\n\nIn this tutorial, we will learn about string formatting or sometimes also known as templating.\n\npackage contains lots of functions. So to save time, we will discuss the most frequently used functions. Let's start with inside our main function.\n\nAs we can see, does not format anything, it simply takes a string and prints it.\n\nNext, we have which is the same as but it adds a new line at the end and also inserts space between the arguments.\n\nThat's much better!\n\nNext, we have also known as \"Print Formatter\", which allows us to format numbers, strings, booleans, and much more.\n\nLet's look at an example.\n\nAs we can see that was substituted with our variable.\n\nBut the question is what is and what does it mean?\n\nSo, these are called annotation verbs and they tell the function how to format the arguments. We can control things like width, types, and precision with these and there are lots of them. Here's a cheatsheet.\n\nNow, let's quickly look at some more examples. Here we will try to calculate a percentage and print it to the console.\n\nLet's say we want just which is 2 points precision, we can do that as well by using .\n\nAlso, to add an actual percent sign, we will need to escape it.\n\nThis brings us to , , and . These are basically the same as the print functions, the only difference being they return the string instead of printing it.\n\nLet's take a look at an example.\n\nSo, as we can see formats our integer as hex or binary and returns it as a string.\n\nLastly, we have multiline string literals, which can be used like this.\n\nGreat! But this is just the tip of the iceberg...so make sure to check out the go doc for package.\n\nFor those who are coming from C/C++ background, this should feel natural, but if you're coming from, let's say Python or JavaScript, this might be a little strange at first. But it is very powerful and you'll see this functionality used quite extensively.\n\nThis works pretty much the same as you expect but the expression doesn't need to be surrounded by parentheses .\n\nWe can also compact our if statements.\n\nNote: This pattern is quite common.\n\nNext, we have statement, which is often a shorter way to write conditional logic.\n\nIn Go, the switch case only runs the first case whose value is equal to the condition expression and not all the cases that follow. Hence, unlike other languages, statement is automatically added at the end of each case.\n\nThis means that it evaluates cases from top to bottom, stopping when a case succeeds. Let's take a look at an example:\n\nSwitch also supports shorthand declaration like this.\n\nWe can also use the keyword to transfer control to the next case even though the current case might have matched.\n\nAnd if we run this, we'll see that after the first case matches the switch statement continues to the next case because of the keyword.\n\nWe can also use it without any condition, which is the same as .\n\nNow, let's turn our attention toward loops.\n\nSo in Go, we only have one type of loop which is the loop.\n\nBut it's incredibly versatile. Same as if statement, for loop, doesn't need any parenthesis unlike other languages.\n\nThe basic loop has three components separated by semicolons:\n• init statement: which is executed before the first iteration.\n• condition expression: which is evaluated before every iteration.\n• post statement: which is executed at the end of every iteration.\n\nAs expected, Go also supports both and statements for loop control. Let's try a quick example:\n\nSo, the statement is used when we want to skip the remaining portion of the loop, and statement is used when we want to break out of the loop.\n\nAlso, Init and post statements are optional, hence we can make our loop behave like a while loop as well.\n\nNote: we can also remove the additional semi-colons to make it a little cleaner.\n\nLastly, If we omit the loop condition, it loops forever, so an infinite loop can be compactly expressed. This is also known as the forever loop.\n\nIn this tutorial, we will discuss how we work with functions in Go. So, let's start with a simple function declaration.\n\nAnd we can call or execute it as follows.\n\nLet's pass some parameters to it.\n\nAs we can see it prints our message. We can also do a shorthand declaration if the consecutive parameters have the same type. For example:\n\nNow let's also return a value.\n\nWhy return one value at a time, when we can do more? Go also supports multiple returns!\n\nAnother cool feature is named returns, where return values can be named and treated as their own variables.\n\nNotice how we added a statement without any arguments, this is also known as naked return.\n\nI will say that, although this feature is interesting, please use it with care as this might reduce readability for larger functions.\n\nNext, let's talk about functions as values, in Go functions are first class and we can use them as values. So, let's clean up our function and try it out!\n\nWe can also simplify this by making an anonymous function.\n\nNotice how we execute it using the parenthesis at the end.\n\nWhy stop there? let's also return a function and hence create something called a closure. A simple definition can be that a closure is a function value that references variables from outside its body.\n\nClosures are lexically scoped, which means functions can access the values in scope when defining the function.\n\nAs we can see, we get a result of 15 as variable is bound to the function. This is a very powerful concept and definitely, a must know.\n\nNow let's look at variadic functions, which are functions that can take zero or multiple arguments using the ellipses operator.\n\nAn example here would be a function that can add a bunch of values.\n\nPretty cool huh? Also, don't worry about the keyword, we will discuss it later in the course.\n\nFun fact: is a variadic function, that's how we were able to pass multiple values to it.\n\nIn Go, is a special lifecycle function that is executed before the function.\n\nSimilar to , the function does not take any arguments nor returns any value. Let's see how it works with an example.\n\nAs expected, the function was executed before the function.\n\nUnlike , there can be more than one function in single or multiple files.\n\nFor multiple in a single file, their processing is done in the order of their declaration, while functions declared in multiple files are processed according to the lexicographic filename order.\n\nAnd if we run this, we'll see the functions were executed in the order they were declared.\n\nThe function is optional and is particularly used for any global setup which might be essential for our program, such as establishing a database connection, fetching configuration files, setting up environment variables, etc.\n\nLastly, let's discuss the keyword, which lets us postpones the execution of a function until the surrounding function returns.\n\nCan we use multiple defer functions? Absolutely, this brings us to what is known as defer stack. Let's take a look at an example:\n\nAs we can see, defer statements are stacked and executed in a last in first out manner.\n\nSo, Defer is incredibly useful and is commonly used for doing cleanup or error handling.\n\nFunctions can also be used with generics but we will discuss them later in the course.\n\nIn this tutorial, we will learn about modules.\n\nSimply defined, A module is a collection of Go packages stored in a file tree with a file at its root, provided the directory is outside .\n\nGo modules were introduced in Go 1.11, which brings native support for versions and modules. Earlier, we needed the flag to turn on the modules functionality when it was experimental. But now after Go 1.13 modules mode is the default for all development.\n\nBut wait, what is ?\n\nWell, is a variable that defines the root of your workspace and it contains the following folders:\n• src: contains Go source code organized in a hierarchy.\n\nLike earlier, let's create a new module using command which creates a new module and initializes the file that describes it.\n\nThe important thing to note here is that a Go module can correspond to a Github repository as well if you plan to publish this module. For example:\n\nNow, let's explore which is the file that defines the module's module path and also the import path used for the root directory, and its dependency requirements.\n\nAnd if we want to add a new dependency, we will use command:\n\nAs we can see a file was also created. This file contains the expected hashes of the content of the new modules.\n\nWe can list all the dependencies using command as follows:\n\nIf the dependency is not used, we can simply remove it using command:\n\nFinishing up our discussion on modules, let's also discuss vendoring.\n\nVendoring is the act of making your own copy of the 3rd party packages your project is using. Those copies are traditionally placed inside each project and then saved in the project repository.\n\nThis can be done through command.\n\nSo, let's reinstall the removed module using .\n\nAfter the command is executed, a directory will be created.\n\nIn this tutorial, we will talk about packages.\n\nA package is nothing but a directory containing one or more Go source files, or other Go packages.\n\nThis means every Go source file must belong to a package and package declaration is done at top of every source file as follows.\n\nSo far, we've done everything inside of . By convention, executable programs (by that I mean the ones with the package) are called Commands, others are simply called Packages.\n\nThe package should also contain a function which is a special function that acts as the entry point of an executable program.\n\nLet's take a look at an example by creating our own package and adding some source files to it such as .\n\nBefore we proceed any further, we should talk about imports and exports. Just like other languages, go also has a concept of imports and exports but it's very elegant.\n\nBasically, any value (like a variable or function) can be exported and visible from other packages if they have been defined with an upper case identifier.\n\nLet's try an example in our package.\n\nAs we can see lower case identifiers will not be exported and will be private to the package it's defined in. In our case the package.\n\nThat's great but how do we import or access it? Well, same as we've been doing so far unknowingly. Let's go to our file and import our package.\n\nHere we can refer to it using the we had initialized in our file earlier.\n\nNotice how the package name is the last name of the import path.\n\nWe can import multiple packages as well like this.\n\nWe can also alias our imports to avoid collisions like this.\n\nIn Go, we are not only limited to working with local packages, we can also install external packages using command as we saw earlier.\n\nAlso, make sure to check out the go doc of packages you install, which is usually located in the project's readme file. go doc parses the source code and generates documentation in HTML format. Reference to It is usually located in readme files.\n\nLastly, I will add that, Go doesn't have a particular \"folder structure\" convention, always try to organize your packages in a simple and intuitive way.\n\nIn this tutorial, we will learn about multi-module workspaces that were introduced in Go 1.18.\n\nWorkspaces allow us to work with multiple modules simultaneously without having to edit files for each module. Each module within a workspace is treated as a root module when resolving dependencies.\n\nTo understand this better, let's start by creating a module.\n\nFor demonstration purposes, I will add a simple and install an example package.\n\nAnd if we run this, we should see our output in reverse.\n\nThis is great, but what if we want to modify the module that our code depends on?\n\nUntil now, we had to do it using the directive in the file, but now let's see how we can use workspaces here.\n\nSo, let's create our workspace in the directory.\n\nWe will also add our module to the workspace.\n\nThis should update the file with a reference to our module.\n\nNow, let's download and modify the package and update the function implementation.\n\nPerfect, now if we run our module we will notice that the function has been modified.\n\nThis is a very underrated feature from Go 1.18 but it is quite useful in certain circumstances.\n\nDuring our module discussion, we discussed some go commands related to go modules, let's now discuss some other important commands.\n\nStarting with , which formats the source code and it's enforced by that language so that we can focus on how our code should work rather than how our code should look.\n\nThis might seem a little weird at first especially if you're coming from a javascript or python background like me but frankly, it's quite nice not to worry about linting rules.\n\nNext, we have which reports likely mistakes in our packages.\n\nSo, if I go ahead and make a mistake in the syntax, and then run .\n\nIt should notify me of the errors.\n\nNext, we have which simply prints all the go environment information, we'll learn about some of these build-time variables later.\n\nLastly, we have which shows documentation for a package or symbol, here's an example of the package.\n\nLet's use command to see what other commands are available.\n\nAs we can see, we have:\n\nfinds Go programs that use old APIs and rewrites them to use newer ones.\n\nis usually used for code generation.\n\nis used for cleaning files that are generated by compilers.\n\nSome other very important commands are and but we will learn about them in detail later in the course.\n\nBuilding static binaries is one of the best features of Go which enables us to ship our code efficiently.\n\nWe can do this very easily using the command.\n\nThis should produce a binary with the name of our module. For example, here we have .\n\nWe can also specify the output.\n\nNow to run this, we simply need to execute it.\n\nYes, it's as simple as that!\n\nNow, let's talk about some important build time variables, starting with:\n\nThese environment variables help us build go programs for different operating systems and underlying processor architectures.\n\nWe can list all the supported architecture using command.\n\nHere's an example for building a windows executable from macOS!\n\nThis variable allows us to configure CGO, which is a way in Go to call C code.\n\nThis helps us to produce a statically linked binary that works without any external dependencies.\n\nThis is quite helpful for, let's say when we want to run our go binaries in a docker container with minimum external dependencies.\n\nHere's an example of how to use it:\n\nIn this tutorial, we will discuss pointers. So what are Pointers?\n\nSimply defined, a Pointer is a variable that is used to store the memory address of another variable.\n\nIt can be used like this:\n\nWhere is the type such as , , , and so on.\n\nLet's try a simple example and see it in action.\n\nHmm, this prints , but what is ?\n\nSo nil is a predeclared identifier in Go that represents zero value for pointers, interfaces, channels, maps, and slices.\n\nThis is just like what we learned in the variables and datatypes section, where we saw that uninitialized has a zero value of 0, a has false, and so on.\n\nOkay, now let's assign a value to the pointer.\n\nWe use the ampersand operator to refer to a variable's memory address.\n\nThis must be the value of the memory address of the variable .\n\nWe can also use the asterisk operator to retrieve the value stored in the variable that the pointer points to. This is also called dereferencing.\n\nFor example, we can access the value of the variable through the pointer using that asterisk operator.\n\nWe can not only access it but change it as well through the pointer.\n\nI think this is pretty neat!\n\nPointers can also be used as arguments for a function when we need to pass some data by reference.\n\nThere's also another way to initialize a pointer. We can use the function which takes a type as an argument, allocates enough memory to accommodate a value of that type, and returns a pointer to it.\n\nHere's an interesting idea...can we create a pointer to a pointer? The answer is yes! Yes, we can.\n\nNotice how the value of matches the address of .\n\nAlso, it is important to know that pointers in Go do not support pointer arithmetic like in C or C++.\n\nHowever, we can compare two pointers of the same type for equality using a operator.\n\nThis brings us to the million-dollar question, why do we need pointers?\n\nWell, there's no definite answer for that, and pointers are just another useful feature that helps us mutate our data efficiently without copying a large amount of data.\n\nLastly, I will add that if you are coming from a language with no notion of pointers, don't panic and try to form a mental model of how pointers work.\n\nIn this tutorial, we will learn about structs.\n\nSo, a is a user-defined type that contains a collection of named fields. Basically, it is used to group related data together to form a single unit.\n\nIf you're coming from an objected-oriented background, think of structs as lightweight classes which that support composition but not inheritance.\n\nWe can define a like this:\n\nWe use the keyword to introduce a new type, followed by the name and then the keyword to indicate that we're defining a struct.\n\nNow, let's give it some fields:\n\nAnd, if the fields have the same type, we can collapse them as well.\n\nNow that we have our struct, we can declare it the same as other datatypes.\n\nAs we can see, all the struct fields are initialized with their zero values. So the and are set to empty string and is set to 0.\n\nWe can also initialize it as \"struct literal\".\n\nFor readability, we can separate by new line but this will also require a trailing comma.\n\nWe can also initialize only a subset of fields.\n\nAs we can see, the age field of person 3 has defaulted to the zero value.\n\nGo structs also supports initialization without field names.\n\nBut here's the catch, we will need to provide all the values during the initialization or it will fail.\n\nWe can also declare an anonymous struct.\n\nLet's clean up our example a bit and see how we can access individual fields.\n\nWe can also create a pointer to structs as well.\n\nBoth statements are equal as in Go we don't need to explicitly dereference the pointer. We can also use the built-in function.\n\nAs a side note, two structs are equal if all their corresponding fields are equal as well.\n\nNow let's learn what is exported and unexported fields in a struct. Same as the rules for variables and functions, if a struct field is declared with a lower case identifier, it will not be exported and only be visible to the package it is defined in.\n\nSo, the field won't be exported. Also, the same goes for the struct, if we rename it as , it won't be exported as well.\n\nAs we discussed earlier, Go doesn't necessarily support inheritance, but we can do something similar with embedding.\n\nSo, our new struct will have all the properties of the original struct. And it should behave the same as our normal struct.\n\nHowever, this is usually not recommended and in most cases, composition is preferred. So rather than embedding, we will just define it as a normal field.\n\nHence, we can rewrite our example with composition as well.\n\nAgain, there is no right or wrong here, but nonetheless, embedding comes in handy sometimes.\n\nA struct tag is just a tag that allows us to attach metadata information to the field which can be used for custom behavior using the package.\n\nLet's learn how we can define struct tags.\n\nYou will often find tags in encoding packages, such as XML, JSON, YAML, ORMs, and Configuration management.\n\nHere's a tags example for the JSON encoder.\n\nStructs are value types. When we assign one variable to another, a new copy of the is created and assigned.\n\nSimilarly, when we pass a to another function, the function gets its own copy of the .\n\nLet's talk about methods, sometimes also known as function receivers.\n\nTechnically, Go is not an object-oriented programming language. It doesn't have classes, objects, and inheritance.\n\nHowever, Go has types. And, you can define methods on types.\n\nA method is nothing but a function with a special receiver argument. Let's see how we can declare methods.\n\nThe receiver argument has a name and a type. It appears between the keyword and the method name.\n\nNow, let us define a method like which will tell us if a car was manufactured within the last 5 years.\n\nAs you can see, we can access the instance of using the receiver variable . I like to think of it as keyword from the object-oriented world.\n\nNow we should be able to call this method after we initialize our struct, just like we do with classes in other languages.\n\nAll the examples that we saw previously had a value receiver.\n\nWith a value receiver, the method operates on a copy of the value passed to it. Therefore, any modifications done to the receiver inside the methods are not visible to the caller.\n\nFor example, let's make another method called which will update the name of the .\n\nSeems like the name wasn't updated, so now let's switch our receiver to pointer type and try again.\n\nAs expected, methods with pointer receivers can modify the value to which the receiver points. Such modifications are visible to the caller of the method as well.\n\nLet's also see some properties of the methods!\n• Go is smart enough to interpret our function call correctly, and hence, pointer receiver method calls are just syntactic sugar provided by Go for convenience.\n• We can omit the variable part of the receiver as well if we're not using it.\n• Methods are not limited to structs but can also be used with non-struct types as well.\n\nSo the question is, why use methods instead of functions?\n\nAs always, there's no particular answer for this, and in no way one is better than the other. Instead, they should be used appropriately when the situation arrives.\n\nOne thing I can think of right now is that methods can help us avoid naming conflicts.\n\nSince a method is tied to a particular type, we can have the same method names for multiple receivers.\n\nBut in the end, it might just come down to preference, such as \"method calls are much easier to read and understand than function calls\" or the other way around.\n\nIn this tutorial, we will learn about arrays and slices in Go.\n\nAn array is a fixed-size collection of elements of the same type. The elements of the array are stored sequentially and can be accessed using their .\n\nWe can declare an array as follows:\n\nHere, is the length and can be any type like integer, string, or user-defined structs.\n\nNow, let's declare an array of integers with length 4 and print it.\n\nBy default, all the array elements are initialized with the zero value of the corresponding array type.\n\nWe can also initialize an array using an array literal.\n\nWe can even do a shorthand declaration.\n\nAnd similar to other languages, we can access the elements using the as they're stored sequentially.\n\nSo, there are multiple ways to iterate over arrays.\n\nThe first one is using the for loop with the function which gives us the length of the array.\n\nAnother way is to use the keyword with the loop.\n\nAs we can see, our example works the same as before.\n\nBut the range keyword is quite versatile and can be used in multiple ways.\n\nAll the arrays that we created so far are one-dimensional. We can also create multi-dimensional arrays in Go.\n\nLet's take a look at an example:\n\nWe can also let the compiler infer the length of the array by using ellipses instead of the length.\n\nNow let's talk about some properties of arrays.\n\nThe array's length is part of its type. So, the array and are completely distinct types, and we cannot assign one to the other.\n\nThis also means that we cannot resize an array, because resizing an array would mean changing its type.\n\nArrays in Go are value types unlike other languages like C, C++, and Java where arrays are reference types.\n\nThis means that when we assign an array to a new variable or pass an array to a function, the entire array is copied.\n\nSo, if we make any changes to this copied array, the original array won't be affected and will remain unchanged.\n\nI know what you're thinking, arrays are useful but a bit inflexible due to the limitation caused by their fixed size.\n\nThis brings us to Slice, so what is a slice?\n\nA Slice is a segment of an array. Slices build on arrays and provide more power, flexibility, and convenience.\n• The length of the segment of the array that the slice contains.\n• And, the capacity, which is the maximum size up to which the segment can grow.\n\nJust like function, we can determine the capacity of a slice using the built-in function. Here's an example:\n\nDon't worry, we are going to discuss everything shown here in detail.\n\nLet's see how we can declare a slice.\n\nAs we can see, we don't need to specify any length. Let's declare a slice of integers and see how it works.\n\nSo, unlike arrays, the zero value of a slice is .\n\nThere are multiple ways to initialize our slice. One way is to use the built-in function.\n\nSimilar to arrays, we can use the slice literal to initialize our slice.\n\nAnother way is to create a slice from an array. Since a slice is a segment of an array, we can create a slice from index to as follows.\n\nMissing low index implies 0 and missing high index implies the length of the underlying array ( ).\n\nThe thing to note here is we can create a slice from other slices too and not just arrays.\n\nWe can iterate over a slice in the same way you iterate over an array, by using the for loop with either function or keyword.\n\nSo now, let's talk about built-in slice functions provided in Go.\n\nThe function copies elements from one slice to another. It takes 2 slices, a destination, and a source. It also returns the number of elements copied.\n\nLet's see how we can use it.\n\nAs expected, our 4 elements from the source slice were copied to the destination slice.\n\nNow, let's look at how we can append data to our slice using the built-in function which appends new elements at the end of a given slice.\n\nIt takes a slice and a variable number of arguments. It then returns a new slice containing all the elements.\n\nLet's try it in an example by appending elements to our slice.\n\nAs we can see, the new elements were appended and a new slice was returned.\n\nBut if the given slice doesn't have sufficient capacity for the new elements then a new underlying array is allocated with a bigger capacity.\n\nAll the elements from the underlying array of the existing slice are copied to this new array, and then the new elements are appended.\n\nThis means modifying the elements of a slice will modify the corresponding elements in the referenced array.\n\nSlices can be used with variadic types as well.\n\nSo, Go provides a built-in map type, and we'll learn how to use it.\n\nBut, the question is what are maps? And why do we need them?\n\nWell, A map is an unordered collection of key-value pairs. It maps keys to values. The keys are unique within a map while the values may not be.\n\nIt is used for fast lookups, retrieval, and deletion of data based on keys. It is one of the most used data structures.\n\nA map is declared using the following syntax:\n\nWhere is the key type and is the value type.\n\nFor example, here's how we can declare a map of keys to values.\n\nAs we can see, the zero value of a map is .\n\nA map has no keys. Moreover, any attempt to add keys to a map will result in a runtime error.\n\nThere are multiple ways to initialize a map.\n\nWe can use the built-in function, which allocates memory for referenced data types and initializes their underlying data structures.\n\nAnother way is using a map literal.\n\nNote that the trailing comma is required.\n\nAs always, we can use our custom types as well.\n\nWe can even remove the value type and Go will figure it out!\n\nNow, let's see how we can add a value to our map.\n\nWe can also retrieve our values from the map using the key.\n\nWhat if we use a key that is not present in the map?\n\nYes, you guessed it! we will get the zero value of the map's value type.\n\nWhen you retrieve the value assigned to a given key, it returns an additional boolean value as well. The boolean variable will be if the key exists, and otherwise.\n\nLet's try this in an example:\n\nWe can also update the value for a key by simply re-assigning a key.\n\nOr, we can delete the key using the built-in function.\n\nHere's how the syntax looks:\n\nThe first argument is the map, and the second is the key we want to delete.\n\nThe function doesn't return any value. Also, it doesn't do anything if the key doesn't exist in the map.\n\nSimilar to arrays or slices, we can iterate over maps with the keyword.\n\nNote that a map is an unordered collection, and therefore the iteration order of a map is not guaranteed to be the same every time we iterate over it.\n\nMaps are reference types, which means when we assign a map to a new variable, they both refer to the same underlying data structure.\n\nTherefore, changes done by one variable will be visible to the other.\n\nIn this section, let's talk about the interfaces.\n\nSo, an interface in Go is an abstract type that is defined using a set of method signatures. The interface defines the behavior for similar types of objects.\n\nHere, behavior is a key term that we will discuss shortly.\n\nLet's take a look at an example to understand this better.\n\nOne of the best real-world examples of interfaces is the power socket. Imagine that we need to connect different devices to the power socket.\n\nLet's try to implement this. Here are the device types we will be using.\n\nNow, let's define a method on a type, let's say . Here we will simply print the properties of the type.\n\nGreat, now we will define the method on the type which accepts our type as an argument.\n\nLet's try to \"connect\" or \"plug in\" the type to our type in the function.\n\nAnd if we run this we'll see the following.\n\nThis is interesting, but let's say now we want to connect our type.\n\nAs we can see, this will throw an error.\n\nWhat should we do now? Define another method? Such as ?\n\nSure, but then every time we add a new device type we will need to add a new method to the socket type as well and that's not ideal.\n\nThis is where the comes in. Essentially, we want to define a contract that, in the future, must be implemented.\n\nWe can simply define an interface such as and use it in our function to allow any device that satisfies the criteria, which is that the type must have a method matching the signature that the interface requires.\n\nAnd anyways, the socket doesn't need to know anything about our device and can simply call the method.\n\nNow let's try to implement our interface. Here's how it will look.\n\nThe convention is to use \"-er\" as a suffix in the name. And as we discussed earlier, an interface should only describe the expected behavior. Which in our case is the method.\n\nNow, we need to update our method to accept a device that implements the interface as an argument.\n\nAnd to satisfy the interface, we can simply add methods to all the device types.\n\nNow, we can connect all our devices to the socket with the help of our interface!\n\nAnd it works just as we expected.\n\nBut why is this considered such a powerful concept?\n\nWell, an interface can help us decouple our types. For example, because we have the interface, we don't need to update our implementation. We can just define a new device type with a method.\n\nUnlike other languages, Go Interfaces are implemented implicitly, so we don't need something like an keyword. This means that a type satisfies an interface automatically when it has \"all the methods\" of the interface.\n\nNext, let's talk about the empty interface. An empty interface can take on a value of any type.\n\nHere's how we declare it.\n\nBut why do we need it?\n\nEmpty interfaces can be used to handle values of unknown types.\n• Variables of an unknown type, like in the function.\n\nTo use a value of type empty , we can use type assertion or a type switch to determine the type of the value.\n\nA type assertion provides access to an interface value's underlying concrete value.\n\nThis statement asserts that the interface value holds a concrete type and assigns the underlying type value to the variable.\n\nWe can also test whether an interface value holds a specific type.\n• The first one is the underlying value.\n• The second is a boolean value that reports whether the assertion succeeded.\n\nThis can help us test whether an interface value holds a specific type or not.\n\nIn a way, this is similar to how we read values from a map.\n\nAnd If this is not the case then, will be false and the value will be the zero value of the type, and no panic will occur.\n\nBut if the interface does not hold the type, the statement will trigger a panic.\n\nHere, a statement can be used to determine the type of a variable of type empty .\n\nAnd if we run this, we can verify that we have a type.\n\nThe zero value of an interface is .\n\nWe can embed interfaces like structs. For example:\n\nUnder the hood, an interface value can be thought of as a tuple consisting of a value and a concrete type.\n\nWith that, we covered interfaces in Go.\n\nIt's a really powerful feature, but remember, \"Bigger the interface, the weaker the abstraction\" - Rob Pike.\n\nIn this tutorial, let's talk about error handling.\n\nNotice how I said errors and not exceptions as there is no exception handling in Go.\n\nInstead, we can just return a built-in type which is an interface type.\n\nWe will circle back to this shortly. First, let's try to understand the basics.\n\nSo, let's declare a simple function which, as the name suggests, will divide integer by .\n\nGreat. Now, we want to return an error, let's say, to prevent the division by zero. This brings us to error construction.\n\nThere are multiple ways to do this, but we will look at the two most common ones.\n\nThe first is by using the function provided by the package.\n\nNotice, how we return an with the result. And if there is no error we simply return as it is the zero value of an error because after all, it's an interface.\n\nBut how do we handle it? So, for that, let's call the function in our function.\n\nAs you can see, we simply check if the error is and build our logic accordingly. This is considered quite idiomatic in Go and you will see this being used a lot.\n\nAnother way to construct our errors is by using the function.\n\nThis function is similar to and it lets us format our error. But instead of returning a string, it returns an error.\n\nIt is often used to add some context or detail to our errors.\n\nAnd it should work similarly.\n\nAnother important technique in Go is defining expected Errors so they can be checked explicitly in other parts of the code. These are sometimes referred to as sentinel errors.\n\nIn Go, it is considered conventional to prefix the variable with . For example, .\n\nSo, this becomes useful when we need to execute a different branch of code if a certain kind of error is encountered.\n\nFor example, now we can check explicitly which error occurred using the function.\n\nThis strategy covers most of the error handling use cases. But sometimes we need additional functionalities such as dynamic values inside of our errors.\n\nEarlier, we saw that is just an interface. So basically, anything can be an as long as it implements the method which returns an error message as a string.\n\nSo, let's define our custom struct which will contain an error code and a message.\n\nHere, we will use instead of function to convert the error to the correct type.\n\nBut what's the difference between and ?\n\nThe difference is that this function checks whether the error has a specific type, unlike the function, which examines if it is a particular error object.\n\nWe can also use type assertions but it's not preferred.\n\nLastly, I will say that error handling in Go is quite different compared to the traditional idiom in other languages. But it is very powerful as it encourages the developer to actually handle the error in an explicit way, which improves readability as well.\n\nSo earlier, we learned that the idiomatic way of handling abnormal conditions in a Go program is using errors. While errors are sufficient for most cases, there are some situations where the program cannot continue.\n\nIn those cases, we can use the built-in function.\n\nThe panic is a built-in function that stops the normal execution of the current . When a function calls , the normal execution of the function stops immediately and the control is returned to the caller. This is repeated until the program exits with the panic message and stack trace.\n\nNote: We will discuss later in the course.\n\nSo, let's see how we can use the function.\n\nAnd if we run this, we can see in action.\n\nAs expected, our program printed the panic message, followed by the stack trace, and then it was terminated.\n\nSo, the question is, what to do when an unexpected panic happens?\n\nWell, it is possible to regain control of a panicking program using the built-in function, along with the keyword.\n\nLet's try an example by creating a function. And then, we can call it using .\n\nAs we can see, our panic was recovered and now our program can continue execution.\n\nLastly, I will mention that and can be considered similar to the idiom in other languages. But one important factor is that we should avoid panic and recover and use errors when possible.\n\nIf so, then this brings us to the question, when should we use ?\n\nThere are two valid use cases for :\n\nWhich can be a situation where the program cannot simply continue its execution.\n\nFor example, reading a configuration file which is important to start the program, as there is nothing else to do if the file read itself fails.\n\nThis is the most common situation. For example, dereferencing a pointer when the value is will cause a panic.\n\nIn this tutorial, we will talk about testing in Go. So, let's start using a simple example.\n\nWe have created a package that contains an function Which as the name suggests, adds two integers.\n\nIt's being used in our package like this.\n\nAnd, if we run this, we should see the result.\n\nNow, we want to test our function. So, in Go, we declare test files with suffix in the file name. So for our , we will create a test as . Our project structure should look like this.\n\nWe will start by using a package, and importing the package from the standard library. That's right! Testing is built into Go, unlike many other languages.\n\nBut wait...why do we need to use as our package, can't we just use the same package?\n\nWell yes, we can write our test in the same package if we wanted, but I personally think doing this in a separate package helps us write tests in a more decoupled way.\n\nNow, we can create our function. It will take an argument of type which will provide us with helpful methods.\n\nBefore we add any testing logic, let's try to run it. But this time, we cannot use command, instead, we will use the command.\n\nHere, we will have our package name which is , but we can also use the relative path to test all packages.\n\nAnd if Go doesn't find any test in a package, it will let us know.\n\nPerfect, let's write some test code. To do this, we will check our result with an expected value and if they do not match, we can use the method to fail the test.\n\nGreat! Our test seems to have passed.\n\nLet's also see what happens if we fail the test, for that, we can simply change our expected result.\n\nIf you see this, don't worry. For optimization, our tests are cached. We can use the command to clear our cache and then re-run the test.\n\nSo, this is what a test failure will look like.\n\nThis brings us to table-driven tests. But what exactly are they?\n\nSo earlier, we had function arguments and expected variables which we compared to determine if our tests passed or fail. But what if we defined all that in a slice and iterate over that? This will make our tests a little bit more flexible and help us run multiple cases easily.\n\nDon't worry, we will learn this by example. So we will start by defining our struct.\n\nNotice, how we declared with a lower case. That's right we don't want to export it as it's not useful outside our testing logic. Let's run our test.\n\nSeems like our tests broke, let's fix them by updating our test cases.\n\nFinally, let's talk about code coverage. When writing tests, it is often important to know how much of your actual code the tests cover. This is generally referred to as code coverage.\n\nTo calculate and export the coverage for our test, we can simply use the argument with the command.\n\nSeems like we have great coverage. Let's also check the report using the command which gives us a detailed report.\n\nAs we can see, this is a much more readable format. And best of all, it is built right into standard tooling.\n\nLastly, let's look at fuzz testing which was introduced in Go version 1.18.\n\nFuzzing is a type of automated testing that continuously manipulates inputs to a program to find bugs.\n\nGo fuzzing uses coverage guidance to intelligently walk through the code being fuzzed to find and report failures to the user.\n\nSince it can reach edge cases that humans often miss, fuzz testing can be particularly valuable for finding bugs and security exploits.\n\nLet's try an example:\n\nIf we run this, we'll see that it'll automatically create test cases. Because our function is quite simple, tests will pass.\n\nBut if we update our function with a random edge case such that the program will panic if is greater than .\n\nAnd if we re-run the test, this edge case will be caught by fuzz testing.\n\nI think this is a really cool feature of Go 1.18. You can learn more about fuzz testing from the official Go blog.\n\nIn this section, we will learn about Generics which is a much awaited feature that was released with Go version 1.18.\n\nGenerics means parameterized types. Put simply, generics allow programmers to write code where the type can be specified later because the type isn't immediately relevant.\n\nLet's take a look at an example to understand this better.\n\nFor our example, we have simple sum functions for different types such as , , and . Since method overriding is not allowed in Go we usually have to create new functions.\n\nAs we can see, apart from the types, these functions are pretty similar.\n\nLet's see how we can define a generic function.\n\nHere, is our type parameter and will be the interface that allows any type implementing the interface.\n\nI know, I know, this is confusing. So, let's start building our generic function.\n\nHere, we will use as our type parameter with an empty as our constraint.\n\nAlso, starting with Go 1.18 we can use , which is pretty much equivalent to the empty interface.\n\nWith type parameters, comes the need to pass type arguments, which can make our code verbose.\n\nLuckily, Go 1.18 comes with type inference which helps us to write code that calls generic functions without explicit types.\n\nLet's run this and see if it works.\n\nNow, let's update the function to add our variables.\n\nBut now if we run this, we will get an error that operator is not defined in the constraint.\n\nWhile constraint of type generally works it does not support operators.\n\nSo let's define our own custom constraint using an interface. Our interface should define a type set containing , , and .\n\nHere's how our interface looks.\n\nAnd this should work as expected.\n\nWe can also use the package which defines a set of useful constraints to be used with type parameters.\n\nFor that, we will need to install the package.\n\nHere we are using the constraint.\n\nis a new token added to Go and the expression means the set of all types whose underlying type is .\n\nAnd it still works as expected.\n\nGenerics is an amazing feature because it permits writing abstract functions that can drastically reduce code duplication in certain cases.\n\nSo, when to use generics? We can take the following use cases as an example:\n• Functions that operate on arrays, slices, maps, and channels.\n\nLastly, I will add that while generics are a great addition to the language, they should be used sparingly.\n\nAnd, it is advised to start simple and only write generic code once we have written very similar code at least 2 or 3 times.\n\nIn this lesson, we will learn about concurrency which is one of the most powerful features of Go.\n\nSo, let's start by asking What is \"concurrency\"?\n\nConcurrency, by definition, is the ability to break down a computer program or algorithm into individual parts, which can be executed independently.\n\nThe final outcome of a concurrent program is the same as that of a program that has been executed sequentially.\n\nUsing concurrency, we can achieve the same results in lesser time, thus increasing the overall performance and efficiency of our programs.\n\nA lot of people confuse concurrency with parallelism because they both somewhat imply executing code simultaneously, but they are two completely different concepts.\n\nConcurrency is the task of running and managing multiple computations at the same time, while parallelism is the task of running multiple computations simultaneously.\n\nA simple quote from Rob Pike pretty much sums it up.\n\n\"Concurrency is about dealing with lots of things at once. Parallelism is about doing lots of things at once\"\n\nBut concurrency in Go is more than just syntax. In order to harness the power of Go, we need to first understand how Go approaches concurrent execution of code. Go relies on a concurrency model called CSP (Communicating Sequential Processes).\n\nCommunicating Sequential Processes (CSP) is a model put forth by Tony Hoare in 1978 which describes interactions between concurrent processes. It made a breakthrough in Computer Science, especially in the field of concurrency.\n\nLanguages like Go and Erlang have been highly inspired by the concept of communicating sequential processes (CSP).\n\nConcurrency is hard, but CSP allows us to give a better structure to our concurrent code and provides a model for thinking about concurrency in a way that makes it a little easier. Here, processes are independent and they communicate by sharing channels between them.\n\nWe'll learn how Golang implements it using goroutines and channels later in the course.\n\nNow, let's get familiar with some basic concurrency concepts.\n\nA data race occurs when processes have to access the same resource concurrently.\n\nFor example, one process reads while another simultaneously writes to the exact same resource.\n\nA race condition occurs when the timing or order of events affects the correctness of a piece of code.\n\nA deadlock occurs when all processes are blocked while waiting for each other and the program cannot proceed further.\n\nThere are four conditions, known as the Coffman conditions, all of them must be satisfied for a deadlock to occur.\n\nA concurrent process holds at least one resource at any one time making it non-sharable.\n\nIn the diagram below, there is a single instance of Resource 1 and it is held by Process 1 only.\n\nA concurrent process holds a resource and is waiting for an additional resource.\n\nIn the diagram given below, Process 2 holds Resource 2 and Resource 3 and is requesting the Resource 1 which is held by Process 1.\n\nA resource held by a concurrent process cannot be taken away by the system. It can only be freed by the process holding it.\n\nIn the diagram below, Process 2 cannot preempt Resource 1 from Process 1. It will only be released when Process 1 relinquishes it voluntarily after its execution is complete.\n\nA process is waiting for the resource held by the second process, which is waiting for the resource held by the third process, and so on, till the last process is waiting for a resource held by the first process. Hence, forming a circular chain.\n\nIn the diagram below, Process 1 is allocated Resource2 and it is requesting Resource 1. Similarly, Process 2 is allocated Resource 1 and it is requesting Resource 2. This forms a circular wait loop.\n\nLivelocks are processes that are actively performing concurrent operations, but these operations do nothing to move the state of the program forward.\n\nStarvation happens when a process is deprived of necessary resources and is unable to complete its function.\n\nStarvation can happen because of deadlocks or inefficient scheduling algorithms for processes. In order to solve starvation, we need to employ better resource-allotment algorithms that make sure that every process gets its fair share of resources.\n\nIn this lesson, we will learn about Goroutines.\n\nBut before we start our discussion, I wanted to share an important Go proverb.\n\nA goroutine is a lightweight thread of execution that is managed by the Go runtime and essentially let us write asynchronous code in a synchronous manner.\n\nIt is important to know that they are not actual OS threads and the main function itself runs as a goroutine.\n\nA single thread may run thousands of goroutines in them by using the Go runtime scheduler which uses cooperative scheduling. This implies that if the current goroutine is blocked or has been completed, the scheduler will move the other goroutines to another OS thread. Hence, we achieve efficiency in scheduling where no routine is blocked forever.\n\nWe can turn any function into a goroutine by simply using the keyword.\n\nBefore we write any code, it is important to briefly discuss the fork-join model.\n\nGo uses the idea of the fork-join model of concurrency behind goroutines. The fork-join model essentially implies that a child process splits from its parent process to run concurrently with the parent process. After completing its execution, the child process merges back into the parent process. The point where it joins back is called the join point.\n\nNow, let's write some code and create our own goroutine.\n\nHere the function call is prefixed with the keyword. This will allow it to run as a separate goroutine. And that's it, we just created our first goroutine. It's that simple!\n\nInteresting, it seems like our program did not run completely as it's missing some output. This is because our main goroutine exited and did not wait for the goroutine that we created.\n\nWhat if we make our program wait using the function?\n\nThere we go, we can see our complete output now.\n\nOkay, so this works but it's not ideal. So how do we improve this?\n\nWell, the most tricky part about using goroutines is knowing when they will stop. It is important to know that goroutines run in the same address space, so access to shared memory must be synchronized.\n\nIn this lesson, we will learn about Channels.\n\nWell, simply defined a channel is a communications pipe between goroutines. Things go in one end and come out another in the same order until the channel is closed.\n\nAs we learned earlier, channels in Go are based on Communicating Sequential Processes (CSP).\n\nNow that we understand what channels are, let's see how we can declare them.\n\nHere, we prefix our type which is the data type of the value we want to send and receive with the keyword which stands for a channel.\n\nLet's try printing the value of our channel of type .\n\nAs we can see, the zero value of a channel is and if we try to send data over the channel our program will panic.\n\nSo, similar to slices we can initialize our channel using the built-in function.\n\nAnd if we run this, we can see our channel was initialized.\n\nNow that we have a basic understanding of channels, let us implement our earlier example using channels to learn how we can use them to communicate between our goroutines.\n\nNotice how we can send data using the and receive data using the syntax.\n\nPerfect, our program ran as we expected.\n\nWe also have buffered channels that accept a limited number of values without a corresponding receiver for those values.\n\nThis buffer length or capacity can be specified using the second argument to the function.\n\nBecause this channel is buffered, we can send these values into the channel without a corresponding concurrent receive. This means sends to a buffered channel block only when the buffer is full and receives block when the buffer is empty.\n\nBy default, a channel is unbuffered and has a capacity of 0, hence, we omit the second argument of the function.\n\nNext, we have directional channels.\n\nWhen using channels as function parameters, we can specify if a channel is meant to only send or receive values. This increases the type-safety of our program as by default a channel can both send and receive values.\n\nIn our example, we can update our function's second argument such that it can only send a value.\n\nHere, can only be used for sending values and will panic if we try to receive values.\n\nAlso, just like any other resource, once we're done with our channel, we need to close it. This can be achieved using the built-in function.\n\nHere, we can just pass our channel to the function.\n\nOptionally, receivers can test whether a channel has been closed by assigning a second parameter to the receive expression.\n\nif is then there are no more values to receive and the channel is closed.\n\nIn a way, this is similar to how we check if a key exists or not in a map.\n• A receive from a closed channel returns the zero value immediately.\n\nWe can also use and to iterate over values received from a channel.\n\nIn this tutorial, we will learn about the statement in Go.\n\nThe statement blocks the code and waits for multiple channel operations simultaneously.\n\nA blocks until one of its cases can run, then it executes that case. It chooses one at random if multiple are ready.\n\nSimilar to , also has a default case that runs if no other case is ready. This will help us send or receive without blocking.\n\nIt's also important to know that an empty blocks forever.\n\nAs we learned earlier, goroutines run in the same address space, so access to shared memory must be synchronized. The package provides useful primitives.\n\nA WaitGroup waits for a collection of goroutines to finish. The main goroutine calls to set the number of goroutines to wait for. Then each of the goroutines runs and calls when finished. At the same time, can be used to block until all goroutines have finished.\n\nWe can use the using the following methods:\n• takes in an integer value which is essentially the number of goroutines that the has to wait for. This must be called before we execute a goroutine.\n• is called within the goroutine to signal that the goroutine has successfully executed.\n• blocks the program until all the goroutines specified by have invoked from within.\n\nLet's take a look at an example.\n\nIf we run this, we can see our program runs as expected.\n\nWe can also pass the to the function directly.\n\nBut is important to know that a must not be copied after first use. And if it's explicitly passed into functions, it should be done by a pointer. This is because it can affect our counter which will disrupt the logic of our program.\n\nLet's also increase the number of goroutines by calling the method to wait for 4 goroutines.\n\nAnd as expected, all our goroutines were executed.\n\nA Mutex is a mutual exclusion lock that prevents other processes from entering a critical section of data while a process occupies it to prevent race conditions from happening.\n\nSo, a critical section can be a piece of code that must not be run by multiple threads at once because the code contains shared resources.\n\nWe can use using the following methods:\n• tries to lock and reports whether it succeeded.\n\nLet's take a look at an example, we will create a struct and add an method which will update the internal value.\n\nLet's run this and see what happens.\n\nThat doesn't look accurate, seems like our value is always zero but we somehow got the correct answer.\n\nWell, this is because, in our example, multiple goroutines are updating the variable. And as you must have guessed, this is not ideal.\n\nThis is the perfect use case for Mutex. So, let's start by using and wrap our critical section in between and methods.\n\nLooks like we solved our issue and the output looks correct as well.\n\nNote: Similar to WaitGroup a Mutex must not be copied after first use.\n\nAn RWMutex is a reader/writer mutual exclusion lock. The lock can be held by an arbitrary number of readers or a single writer.\n\nIn other words, readers don't have to wait for each other. They only have to wait for writers holding the lock.\n\nis thus preferable for data that is mostly read, and the resource that is saved compared to a is time.\n\nSimilar to , we can use using the following methods:\n\nNotice how RWMutex has additional and methods compared to Mutex.\n\nLet's add a method which will read the counter value. We will also change to .\n\nNow, we can simply use the and methods so that readers don't have to wait for each other.\n\nNote: Both and implements the interface.\n\nThe condition variable can be used to coordinate those goroutines that want to share resources. When the state of shared resources changes, it can be used to notify goroutines blocked by a mutex.\n\nEach Cond has an associated lock (often a or ), which must be held when changing the condition and when calling the Wait method.\n\nOne scenario can be when one process is receiving data, and other processes must wait for this process to receive data before they can read the correct data.\n\nIf we simply use a channel or mutex, only one process can wait and read the data. There is no way to notify other processes to read the data. Thus, we can to coordinate shared resources.\n\ncomes with the following methods:\n• wakes all goroutines waiting on the condition.\n• wakes one goroutine waiting on the condition if there is any.\n\nHere is an example that demonstrates the interaction of different goroutines using the .\n\nAs we can see, the readers were suspended using the method until the writer used the method to wake up the process.\n\nOnce ensures that only one execution will be carried out even among several goroutines.\n\nUnlike other primitives, only has a single method:\n• calls the function only once. If is called multiple times, only the first call will invoke the function .\n\nThis seems pretty straightforward, let's take an example:\n\nAs we can see, even when we ran 100 goroutines, the count only got incremented once.\n\nPool is s a scalable pool of temporary objects and is also concurrency safe. Any stored value in the pool can be deleted at any time without receiving notification. In addition, under high load, the object pool can be dynamically expanded, and when it is not used or the concurrency is not high, the object pool will shrink.\n\nThe key idea is the reuse of objects to avoid repeated creation and destruction, which will affect the performance.\n\nPool's purpose is to cache allocated but unused items for later reuse, relieving pressure on the garbage collector. That is, it makes it easy to build efficient, thread-safe free lists. However, it is not suitable for all free lists.\n\nThe appropriate use of a Pool is to manage a group of temporary items silently shared among and potentially reused by concurrent independent clients of a package. Pool provides a way to spread the cost of allocation overhead across many clients.\n\nIt is important to note that Pool also has its performance cost. It is much slower to use than simple initialization. Also, a Pool must not be copied after first use.\n\ngives us the following methods:\n• selects an arbitrary item from the Pool, removes it from the Pool, and returns it to the caller.\n• adds the item to the pool.\n\nNow, let's look at an example.\n\nFirst, we will create a new , where we can optionally specify a function to generate a value when we call, , otherwise it will return a value.\n\nAnd if we run this, we'll see an interesting output:\n\nNotice how we did type assertion when we call .\n\nIt can be seen that the is strictly a temporary object pool, which is suitable for storing some temporary objects that will be shared among goroutines.\n\nMap is like the standard but is safe for concurrent use by multiple goroutines without additional locking or coordination. Loads, stores, and deletes are spread over constant time.\n\nThe Map type is specialized. Most code should use a plain Go map instead, with separate locking or coordination, for better type safety and to make it easier to maintain other invariants along with the map content.\n\nThe Map type is optimized for two common use cases:\n• When the entry for a given key is only ever written once but read many times, as in caches that only grow.\n• When multiple goroutines read, write, and overwrite entries for disjoint sets of keys. In these two cases, the use of a may significantly reduce lock contention compared to a Go map paired with a separate or .\n\nThe zero Map is empty and ready for use. A Map must not be copied after first use.\n\ngives us the following methods:\n• deletes the value for a key.\n• returns the value stored in the map for a key, or nil if no value is present.\n• deletes the value for a key, returning the previous value if any. The loaded result reports whether the key was present.\n• returns the existing value for the key if present. Otherwise, it stores and returns the given value. The loaded result is true if the value was loaded, and false if stored.\n• sets the value for a key.\n• calls sequentially for each key and value present in the map. If returns false, the range stops the iteration.\n\nNote: Range does not necessarily correspond to any consistent snapshot of the Map's contents.\n\nLet's look at an example. Here, we will launch a bunch of goroutines that will add and retrieve values from our map concurrently.\n\nAs expected, our store and retrieve operation will be safe for concurrent use.\n\nPackage atomic provides low-level atomic memory primitives for integers and pointers that are useful for implementing synchronization algorithms.\n\npackage provides several functions that do the following 5 operations for , , and types:\n\nWe won't be able to cover all of the functions here. So, let's take a look at the most commonly used function like to get an idea.\n\nHere, guarantees that the result of will be 1000 as the instruction execution of atomic operations cannot be interrupted.\n\nIn this tutorial, we will discuss some advanced concurrency patterns in Go. Often, these patterns are used in combination in the real world.\n\nThen generator Pattern is used to generate a sequence of values which is used to produce some output.\n\nIn our example, we have a function that simply returns a channel from which we can read the values.\n\nThis works on the fact that sends and receives block until both the sender and receiver are ready. This property allowed us to wait until the next value is requested.\n\nIf we run this, we'll notice that we can consume values that were produced on demand.\n\nThis is a similar behavior as in JavaScript and Python.\n\nThe fan-in pattern combines multiple inputs into one single output channel. Basically, we multiplex our inputs.\n\nIn our example, we create the inputs and using the function. Then we use our variadic function to combine values from these inputs to a single output channel from which we can consume values.\n\nNote: order of input will not be guaranteed.\n\nFan-out patterns allow us to essentially split our single input channel into multiple output channels. This is a useful pattern to distribute work items into multiple uniform actors.\n\nIn our example, we break the input channel into 4 different output channels. For a dynamic number of outputs, we can merge outputs into a shared \"aggregate\" channel and use .\n\nNote: fan-out pattern is different from pub/sub.\n\nAs we can see, our work has been split between multiple goroutines.\n\nThe pipeline pattern is a series of stages connected by channels, where each stage is a group of goroutines running the same function.\n\nIn each stage, the goroutines:\n• Perform some function on that data, usually producing new values.\n\nEach stage has any number of inbound and outbound channels, except the first and last stages, which have only outbound or inbound channels, respectively. The first stage is sometimes called the source or producer; the last stage is the sink or consumer.\n\nBy using a pipeline, we separate the concerns of each stage, which provides numerous benefits such as:\n• Modify stages independent of one another.\n• Mix and match how stages are combined independently of modifying the stage.\n\nIn our example, we have defined three stages, , , and .\n\nSeem like our input was processed correctly by the pipeline in a concurrent manner.\n\nThe worker pool is a really powerful pattern that lets us distributes the work across multiple workers (goroutines) concurrently.\n\nIn our example, we have a channel to which we will send our jobs and a channel where our workers will send the results once they've finished doing the work.\n\nAfter that, we can launch our workers concurrently and simply receive the results from the channel.\n\nIdeally, should be set to which gives us the number of logical CPUs usable by the current process.\n\nAs expected, our jobs were distributed among our workers.\n\nQueuing pattern allows us to process number of items at a time.\n\nIn our example, we use a buffered channel to simulate a queue behavior. We simply send an empty struct to our channel and wait for it to be released by the previous process so that we can continue.\n\nThis is because sends to a buffered channel block only when the buffer is full and receives block when the buffer is empty.\n\nHere, we have total work of 10 items and we have a limit of 2. This means we can process 2 items at a time.\n\nNotice how our channel is of type as an empty struct occupies zero bytes of storage.\n\nIf we run this, we will notice that it briefly pauses when every 2nd item (which is our limit) is processed as our queue waits to be dequeued.\n\nSome additional patterns that might be useful to know:\n\nIn concurrent programs, it's often necessary to preempt operations because of timeouts, cancellations, or failure of another portion of the system.\n\nThe package makes it easy to pass request-scoped values, cancellation signals, and deadlines across API boundaries to all the goroutines involved in handling a request.\n\nLet's discuss some core types of the package.\n\nThe is an type that is defined as follows:\n\nThe type has the following methods:\n• returns a channel that is closed when the context is canceled or times out. Done may return if the context can never be canceled.\n• returns the time when the context will be canceled or timed out. Deadline returns as when no deadline is set.\n• returns an error that explains why the Done channel was closed. If Done is not closed yet, it returns .\n• returns the value associated with the key or if none.\n\nA tells an operation to abandon its work and it does not wait for the work to stop. If it is called by multiple goroutines simultaneously, after the first call, subsequent calls to a does nothing.\n\nLet's discuss functions that are exposed by the package:\n\nBackground returns a non-nil, empty . It is never canceled, has no values, and has no deadline.\n\nIt is typically used by the main function, initialization, and tests, and as the top-level Context for incoming requests.\n\nSimilar to the function function also returns a non-nil, empty .\n\nHowever, it should only be used when we are not sure what context to use or if the function has not been updated to receive a context. This means we plan to add context to the function in the future.\n\nThis function takes in a context and returns a derived context where the value is associated with and flows through the context tree with the context.\n\nThis means that once you get a context with value, any context that derives from this gets this value.\n\nIt is not recommended to pass in critical parameters using context values, instead, functions should accept those values in the signature making it explicit.\n\nLet's take a simple example to see how we can add a key-value pair to the context.\n\nAnd if we run this, we'll see the being passed via our context.\n\nThis function creates a new context from the parent context and derived context and the cancel function. The parent can be a or a context that was passed into the function.\n\nCanceling this context releases resources associated with it, so the code should call cancel as soon as the operations running in this context is completed.\n\nPassing around the function is not recommended as it may lead to unexpected behavior.\n\nThis function returns a derived context from its parent that gets canceled when the deadline exceeds or the cancel function is called.\n\nFor example, we can create a context that will automatically get canceled at a certain time in the future and pass that around in child functions. When that context gets canceled because of the deadline running out, all the functions that got the context gets notified to stop work and return.\n\nThis function is just a wrapper around the function with the added timeout.\n\nLet's look at an example to solidify our understanding of the context.\n\nIn the example below, we have a simple HTTP server that handles a request.\n\nLet's open two terminals. In terminal one we'll run our example.\n\nIn the second terminal, we will simply make a request to our server. And if we wait for 5 seconds, we get a response back.\n\nNow, let's see what happens if we cancel the request before it completes.\n\nNote: we can use to cancel the request midway.\n\nAnd as we can see, we're able to detect the cancellation of the request because of the request context.\n\nI'm sure you can already see how this can be immensely useful.\n\nFor example, we can use this to cancel any resource-intensive work if it's no longer needed or has exceeded the deadline or a timeout.\n\nNow that you know the fundamentals of Go, here are some additional things for you to try:\n• Build a REST API with Go - For Beginners\n\nI hope this course was a great learning experience. I would love to hear feedback from you.\n\nWishing you all the best for further learning!\n\nHere are the resources that were referenced while creating this course."
    },
    {
        "link": "https://github.com/aid0000/piscine-go-1/blob/master/printrune.go",
        "document": "To see all available qualifiers, see our documentation .\n\nSaved searches Use saved searches to filter your results more quickly\n\nWe read every piece of feedback, and take your input very seriously.\n\nYou signed in with another tab or window. Reload to refresh your session.\n\nYou signed out in another tab or window. Reload to refresh your session.\n\nYou switched accounts on another tab or window. Reload to refresh your session."
    },
    {
        "link": "https://stackoverflow.com/questions/71600985/ranging-over-a-slice",
        "document": "my problem is that Im only allowed to use the command PrintRune, i must range over a string and print one by one the characters of any string\n\nhere's my code, this only prints the first character of the string, how can i make the slice continue until the end of the given string please ?"
    },
    {
        "link": "https://medium.com/@teamcode20233/printing-in-go-with-the-print-and-printf-functions-e948d6b4f3e4",
        "document": "Printing is the most basic way of displaying information on a computer screen. In Go, printing is done through the fmt package, which is part of the standard library. The fmt package provides two main functions for printing: Print() and Printf().\n\nThe Print() function simply prints the text on the screen, while Printf() allows us to format the text before printing. The format string in Printf() can contain placeholders, which will be replaced with the values provided as arguments. These placeholders start with a percent sign (%), and the letter after the percent sign indicates the type of value to be replaced.\n\nThe Print() and Printf() functions also accept multiple arguments, which are printed separated by spaces.\n\nIn this article, we will explain the importance of printing in programming and how Go provides two built-in functions, Print and Printf, for this purpose. We will also go on to explain the differences between the two functions and how they can be used to output strings, numbers, and variables.\n\nThe Print function in Go is a built-in function that allows you to print to the standard output (usually the console). The Print function takes zero or more arguments of any type and concatenates them into a string using spaces as separators, and then writes the resulting string to the standard output.\n\nIf you want to use a different separator, you can use the Println function instead, which uses a newline character as the separator. The Print function is useful for quickly printing a value or a set of values to the console for debugging purposes. Here is an example of the Print function in action:\n\nIn this example, we use the Print function to print the string “Hello World” to the console. The function concatenates the three string arguments into a single string separated by a space character and then writes the resulting string to the console.\n\nThe Print function in Go is used to print text to the standard output stream (usually the console). It can be called with a series of arguments, each separated by a comma. The function takes care of converting the arguments to their string representation and concatenating them together before printing them out. The basic syntax of the Print function is as follows:\n\nThe a argument is a variadic parameter, which means that it can take any number of arguments. The function returns the number of bytes written to the output stream and any error that occurred during the process. The arguments can be of any type that has a string representation, including strings, integers, floats, and boolean values.\n\nPrinting an integer value in Go is quite simple. The Print and Printf functions from the fmt package can be used to print integer values. The Print function prints the integer in its decimal representation, while the Printf function allows for more control over the output format. Here is an example that demonstrates how to print an integer using both functions:\n\nIn this example, we first define an integer variable num with a value of 42. We then use the Print function to print the value of num on its own line. Next, we use the Printf function to print the value of num in a sentence, which includes the literal string “The number is “ and the integer value of num using the %d format specifier. The resulting output is “The number is 42.”.\n\nYou can also print multiple variables using the Printf() function. This function allows you to format your output in a specific way. You can insert values into the output string by using format verbs. The %v verb represents the value of the variable being printed. You can use the %v verb more than once to print multiple variables. Here is an example of how to print multiple variables using Printf():\n\nOutput: My name is John and I am 25 years old.\n\nIn the example above, we declare two variables age and name. We then use Printf() to print them as part of a sentence. The %v verb is used to represent the value of the variables name and age. The variables are passed to Printf() as arguments in the order that they should appear in the output string.\n\nIn Go, the Print and Println functions are used to print output to the console. The main difference between them is that Println adds a newline character at the end of the output, while Print does not. This means that if you use Println to print multiple values, each value will be printed on a new line.\n\nOn the other hand, if you use Print, all the values will be printed on the same line, separated by a space character. Additionally, Println also accepts multiple arguments, separated by a comma, while Print only accepts a single argument.\n\nThe Print and Println functions in Go have a subtle difference in how they handle the output.\n• The Print function formats the output without adding a new line character (\n\n) at the end.\n• If multiple arguments are provided, they are concatenated without any spacing between them.\n• The Println function adds a new line character (\n\n) at the end of the output.\n• If multiple arguments are provided, they are separated by a space and a new line character is appended at the end.\n\nIt’s important to note that both Print and Println functions automatically convert different data types to their string representations when printing.\n\nThe Printf function in Go is used to format and print text on the console or terminal. It takes a format string as its first argument, which specifies the layout of the output string, and any additional arguments are used to fill in the placeholders in the format string.\n\nThe format string can contain various placeholders, such as %s for strings, %d for integers, %f for floating-point numbers, and many more. The function replaces these placeholders with the corresponding values of the additional arguments, according to their order. The Printf function also supports various modifiers and flags to control the output’s alignment, precision, width, and other properties.\n\nThe Printf function is a formatted output function that is used to print values in a specific format. The syntax of the Printf function is quite simple. It starts with the letter f that stands for formatted. It is followed by the letter printf, which is the name of the function.\n\nThe format string is enclosed in double quotes “” and it contains the text to be printed along with any placeholders or format specifiers. The placeholders are marked with the percent symbol %, and they are replaced with the values of variables that are passed to the function. The format specifiers are used to specify the type of data that is being printed and how it should be formatted.\n\nIn Go, we can use the Printf() function to print formatted strings. The function takes a format string as its first argument, followed by any number of arguments that will replace the format specifiers in the format string.\n\nThe format string is composed of two types of elements: literal text and format specifiers. Literal text is printed as is, while format specifiers are placeholders for values that will be printed in a specific format. For example, the %s format specifier is used to print strings, while the %d format specifier is used to print integers. Let’s see an example:\n\nThis will output My name is John and I’m 30 years old. to the console.\n\nGo provides a powerful formatting syntax that allows us to print integers in various formats. We can use the %d verb to print an integer in decimal format. For example, if we have an integer variable num and we want to print it, we can use the Printf() function as follows:\n\nThis will print The value of num is 42 to the console. We can also use the %x verb to print an integer in hexadecimal format, or the %o verb to print an integer in octal format. Additionally, we can use the %b verb to print an integer in binary format. We can also specify the width and precision of the output using the formatting syntax. For example, we can print an integer with a minimum width of 5 digits as follows:\n\nThis will print The value of num is 00042 to the console. We can also print integers in different bases using the strconv package.\n\nPrinting floating-point numbers is a common task in programming. In Go, we can use the Printf function to print floating-point numbers with specific formatting options. The Printf function uses the %f verb to print floating-point numbers. For example, if we have a variable num that stores a floating-point number, we can print it with two decimal places using the following code:\n\nIn addition to the decimal places, we can also specify other formatting options such as the width of the field and whether to use scientific notation. The Printf function provides a powerful way to format and print floating-point numbers in Go.\n\nIn Go, we can print multiple variables in a single line using the Printf() function. This function allows us to format the output string using special formatting verbs. For example, we can use %s to format a string, %d to format an integer, %f to format a float, and so on.\n\nTo print multiple variables, we just need to pass them as additional arguments to the Printf() function, separated by commas. We can use the same formatting verbs for each variable and specify the order in which they appear in the output string by using numbered placeholders. For example:\n\nIn the format string, we used %s to format the string variable name, %d to format the integer variable age, and %f with a precision of 2 to format the float variable height. We also used numbered placeholders (%1$s, %2$d, %3$.2f) to specify the order in which the variables appear in the output string.\n\nThe Printf function in Go is indeed used for printing formatted output to the standard output stream. It allows you to control the format of the output by using formatting verbs in the format string. Formatting verbs are placeholders that specify the type and format of the data that will be printed.\n\nHere are some commonly used formatting verbs:\n\nBy using these formatting verbs along with the corresponding arguments, you can control the output format and ensure that the data is displayed as desired. Understanding the usage of formatting verbs is important for achieving the desired output format when using the Printf function in Go.\n\nIn Go, you can print the type of a variable using the %T formatting verb in the Printf function from the fmt package. Here’s an example:\n\nIn the example, the %T formatting verb is used to print the type of the variables num, str, and flag. The output shows the respective types: int, string, and bool.\n\nTo print the contents of a struct in Go, you can use the %v formatting verb in the Printf function from the fmt package. Here’s an example:\n\nIn the example, the %v formatting verb is used to print the contents of the person struct. It prints all the fields of the struct, separated by spaces, enclosed within curly braces. The output shows the values of the Name, Age, and Country fields of the person struct.\n\nLearn Go Programming with Go Online Compiler\n\nAre you having trouble dealing with errors and debugging when coding? Don’t worry, because conquering them is way easier than scaling Mount Everest!\n\nIntroducing Lightly IDE, your ultimate coding companion that transforms the learning curve into a thrilling adventure. With Lightly IDE, you don’t have to be a coding genius to program smoothly. Discover the wonders of Lightly IDE at lightly-dev.com today!\n\nLightly IDE is truly remarkable, especially with its seamless integration of artificial intelligence (AI). This means that even if you’re not a tech whiz, you can effortlessly navigate and utilize all its features. It’s like having a magical power at your fingertips, but instead of wands, you’re wielding lines of code.\n\nIf you’re curious about programming or eager to enhance your skills, Lightly IDE provides the perfect entry point. With its Go online compiler, it’s like stepping into a playground designed for aspiring programming prodigies. This platform has the incredible ability to transform a complete beginner into a coding expert in no time at all.\n\nRead more: Printing in Go with the Print and Printf Functions"
    },
    {
        "link": "https://github.com/01-edu/rc",
        "document": "This program analyzes a go source file and displays in standard output the imports, functions, slice types and loops used without authorization.\n• \n• All functions declared inside the source file are allowed\n• Slices of all types are allowed\n• allows casting to every built-in type.\n• prohibits the use of loops in the program or function.\n• allows all builtin functions and casting to builtin types\n• disallows the use of all slices types\n• : disallows the slices of type1 and type2\n• : disallows the use of relative imports\n• : disallows character and string literals that match the pattern which represent a Regular Expression\n• Flags can be passed at any point (in the beginning, middle or end) of the argument list\n• \n• Allowed imports and functions from a package\n• for full imports (all functions from that package are allowed)\n• . for partial imports (only the function is allowed)\n• . the function is only allowed to be used number of times\n• Ex: (all functions from are allowed), (only is allowed), (fmt.Println can only be used 2 times or less)\n• Allowed built-in functions\n• Use the name of the built-in function\n• It is possible to limit the number of calls of a functions like with the imports using the '#' character\n• To allow the import of the whole package, and the built-in functions for the file Note: The imports must be written exactly the way they are written inside the source code, example:\n• Allow all type of casting\n• this will allow all type of casting in the file sourcefile.go\n• Disallow the use of the slices of type and\n• To allow just one type of casting\n• this will allow the casting to , but not , ..., , , ...\n\nLet us look to an example snipped of code, let us imagine this code in a file called :\n\nNow let us run the and understand the message\n\nThe important part is printed after the tag:\n• The import of of the package is not allowed\n• In go the dot (.) is also known as the access operator for that reason the use of fmt.Println is shown as an illegal-access\n• Finally the main function is shown as illegal-definition because the function is using disallowed functions that does not mean that the function can not be defined it just mean that the definition of the function must be changed to not use disallowed functions.\n• Notice that the third column of the output with the tag \"LOCATION:\" show the location in the following way filepath:line:column This mean that you have to substitute the illegal function for ones that are allowed or write your own function with allowed functions"
    },
    {
        "link": "https://dev.to/yokwejuste/how-to-print-in-golang-fhh",
        "document": "It has always been a challenge for me when working with GoLang and trying to print out something, usually during debugging and or various other tasks while building.\n\nLet's have a quick look at what we should use and when should we use it with regards to printing in GoLang.\n\nPS: Try to read through, we will make it fast as much as possible.\n\nPersonally I usually use about 7 of the print methods in-built in GoLang, which include: , , , , , and . In Go ( ), the package provides several printing functions for different use cases.\n• No Formatting Specifiers: Just concatenates values as strings.\n• No Line Break: No newline at the end, so subsequent output appears on the same line.\n• Purpose: Prints values directly to the console, with a newline at the end.\n• No Formatting Specifiers: Concatenates values with spaces between them.\n• Purpose: Prints values directly to the console with formatting specifiers.\n• No Auto Line Break: Doesn't automatically add a newline; you need to specify .\n• No Printing: Doesn't print to the console, just returns the string.\n• No Printing: Doesn't print to the console, just returns the string.\n• No Printing: Doesn't print to the console, just returns the formatted string.\n• No Line Break: No newline unless explicitly added.\n• Purpose: Writes formatted output to a specified writer (like files, buffers, etc.).\n• For Advanced Usage: Typically used with files or custom outputs.\n\nTake a look at my YouTube and GitHub"
    }
]