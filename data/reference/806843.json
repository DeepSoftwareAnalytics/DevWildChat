[
    {
        "link": "https://docs.python.org/3/library/random.html",
        "document": "This module implements pseudo-random number generators for various distributions.\n\nFor integers, there is uniform selection from a range. For sequences, there is uniform selection of a random element, a function to generate a random permutation of a list in-place, and a function for random sampling without replacement.\n\nOn the real line, there are functions to compute uniform, normal (Gaussian), lognormal, negative exponential, gamma, and beta distributions. For generating distributions of angles, the von Mises distribution is available.\n\nAlmost all module functions depend on the basic function , which generates a random float uniformly in the half-open range . Python uses the Mersenne Twister as the core generator. It produces 53-bit precision floats and has a period of 2**19937-1. The underlying implementation in C is both fast and threadsafe. The Mersenne Twister is one of the most extensively tested random number generators in existence. However, being completely deterministic, it is not suitable for all purposes, and is completely unsuitable for cryptographic purposes.\n\nThe functions supplied by this module are actually bound methods of a hidden instance of the class. You can instantiate your own instances of to get generators that don’t share state.\n\nClass can also be subclassed if you want to use a different basic generator of your own devising: see the documentation on that class for more details.\n\nThe module also provides the class which uses the system function to generate random numbers from sources provided by the operating system.\n\nReturn a random element from the non-empty sequence seq. If seq is empty, raises . Return a k sized list of elements chosen from the population with replacement. If the population is empty, raises . If a weights sequence is specified, selections are made according to the relative weights. Alternatively, if a cum_weights sequence is given, the selections are made according to the cumulative weights (perhaps computed using ). For example, the relative weights are equivalent to the cumulative weights . Internally, the relative weights are converted to cumulative weights before making selections, so supplying the cumulative weights saves work. If neither weights nor cum_weights are specified, selections are made with equal probability. If a weights sequence is supplied, it must be the same length as the population sequence. It is a to specify both weights and cum_weights. The weights or cum_weights can use any numeric type that interoperates with the values returned by (that includes integers, floats, and fractions but excludes decimals). Weights are assumed to be non-negative and finite. A is raised if all weights are zero. For a given seed, the function with equal weighting typically produces a different sequence than repeated calls to . The algorithm used by uses floating-point arithmetic for internal consistency and speed. The algorithm used by defaults to integer arithmetic with repeated selections to avoid small biases from round-off error. Changed in version 3.9: Raises a if all weights are zero. To shuffle an immutable sequence and return a new shuffled list, use instead. Note that even for small , the total number of permutations of x can quickly grow larger than the period of most random number generators. This implies that most permutations of a long sequence can never be generated. For example, a sequence of length 2080 is the largest that can fit within the period of the Mersenne Twister random number generator. Return a k length list of unique elements chosen from the population sequence. Used for random sampling without replacement. Returns a new list containing elements from the population while leaving the original population unchanged. The resulting list is in selection order so that all sub-slices will also be valid random samples. This allows raffle winners (the sample) to be partitioned into grand prize and second place winners (the subslices). Members of the population need not be hashable or unique. If the population contains repeats, then each occurrence is a possible selection in the sample. Repeated elements can be specified one at a time or with the optional keyword-only counts parameter. For example, is equivalent to . To choose a sample from a range of integers, use a object as an argument. This is especially fast and space efficient for sampling from a large population: . If the sample size is larger than the population size, a is raised. Changed in version 3.11: The population must be a sequence. Automatic conversion of sets to lists is no longer supported.\n\nThe following functions generate specific real-valued distributions. Function parameters are named after the corresponding variables in the distribution’s equation, as used in common mathematical practice; most of these equations can be found in any statistics text. Return the next random floating-point number in the range Return a random floating-point number N such that for and for . The end-point value may or may not be included in the range depending on floating-point rounding in the expression . Return a random floating-point number N such that and with the specified mode between those bounds. The low and high bounds default to zero and one. The mode argument defaults to the midpoint between the bounds, giving a symmetric distribution. Beta distribution. Conditions on the parameters are and . Returned values range between 0 and 1. Exponential distribution. lambd is 1.0 divided by the desired mean. It should be nonzero. (The parameter would be called “lambda”, but that is a reserved word in Python.) Returned values range from 0 to positive infinity if lambd is positive, and from negative infinity to 0 if lambd is negative. Changed in version 3.12: Added the default value for . Gamma distribution. (Not the gamma function!) The shape and scale parameters, alpha and beta, must have positive values. (Calling conventions vary and some sources define ‘beta’ as the inverse of the scale). Normal distribution, also called the Gaussian distribution. mu is the mean, and sigma is the standard deviation. This is slightly faster than the function defined below. Multithreading note: When two threads call this function simultaneously, it is possible that they will receive the same return value. This can be avoided in three ways. 1) Have each thread use a different instance of the random number generator. 2) Put locks around all calls. 3) Use the slower, but thread-safe function instead. Changed in version 3.11: mu and sigma now have default arguments. Log normal distribution. If you take the natural logarithm of this distribution, you’ll get a normal distribution with mean mu and standard deviation sigma. mu can have any value, and sigma must be greater than zero. Normal distribution. mu is the mean, and sigma is the standard deviation. Changed in version 3.11: mu and sigma now have default arguments. mu is the mean angle, expressed in radians between 0 and 2*pi, and kappa is the concentration parameter, which must be greater than or equal to zero. If kappa is equal to zero, this distribution reduces to a uniform random angle over the range 0 to 2*pi. Weibull distribution. alpha is the scale parameter and beta is the shape parameter.\n\n# Even integer from 0 to 100 inclusive ['four', 'two', 'ace', 'three'] # of 52 playing cards, and determine the proportion of cards # Estimate the probability of getting 5 or more heads from 7 spins # of a biased coin that settles on heads 60% of the time. # Probability of the median of 5 samples being in middle two quartiles Example of statistical bootstrapping using resampling with replacement to estimate a confidence interval for the mean of a sample: Example of a resampling permutation test to determine the statistical significance or p-value of an observed difference between the effects of a drug versus a placebo: # Example from \"Statistics is Easy\" by Dennis Shasha and Manda Wilson 'at least as extreme as the observed difference of leads us to reject the null' 'hypothesis that there is no difference between the drug and the placebo.' Simulation of arrival times and service deliveries for a multiserver queue: # time when each server becomes available Statistics for Hackers a video tutorial by Jake Vanderplas on statistical analysis using just a few fundamental concepts including simulation, sampling, shuffling, and cross-validation. Economics Simulation a simulation of a marketplace by Peter Norvig that shows effective use of many of the tools and distributions provided by this module (gauss, uniform, sample, betavariate, choice, triangular, and randrange). A Concrete Introduction to Probability (using Python) a tutorial by Peter Norvig covering the basics of probability theory, how to write simulations, and how to perform data analysis using Python.\n\nThese recipes show how to efficiently make random selections from the combinatoric iterators in the module: \"Choose r elements with replacement. Order the result to match the iterable.\" # Result will be in set(itertools.combinations_with_replacement(iterable, r)). The default returns multiples of 2⁻⁵³ in the range 0.0 ≤ x < 1.0. All such numbers are evenly spaced and are exactly representable as Python floats. However, many other representable floats in that interval are not possible selections. For example, isn’t an integer multiple of 2⁻⁵³. The following recipe takes a different approach. All floats in the interval are possible selections. The mantissa comes from a uniform distribution of integers in the range 2⁵² ≤ mantissa < 2⁵³. The exponent comes from a geometric distribution where exponents smaller than -53 occur half as often as the next larger exponent. All real valued distributions in the class will use the new method: The recipe is conceptually equivalent to an algorithm that chooses from all the multiples of 2⁻¹⁰⁷⁴ in the range 0.0 ≤ x < 1.0. All such numbers are evenly spaced, but most have to be rounded down to the nearest representable Python float. (The value 2⁻¹⁰⁷⁴ is the smallest positive unnormalized float and is equal to .) Generating Pseudo-random Floating-Point Values a paper by Allen B. Downey describing ways to generate more fine-grained floats than normally generated by ."
    },
    {
        "link": "https://w3schools.com/python/module_random.asp",
        "document": "Python has a built-in module that you can use to make random numbers.\n\nThe module has a set of methods:"
    },
    {
        "link": "https://geeksforgeeks.org/python-random-module",
        "document": "Python Random module generates random numbers in Python. These are pseudo-random numbers means they are not truly random.\n\nThis module can be used to perform random actions such as generating random numbers, printing random a value for a list or string, etc. It is an in-built function in Python.\n\nList of all the functions Python Random Module\n\nThere are different random functions in the Random Module of Python. Look at the table below to learn more about these functions:\n\nLet’s discuss some common operations performed by Random module in Python.\n\nExample 1: Printing a random value from a list in Python.\n\nThis code uses the module to select a random element from the list using the function. It prints a random element from the list, demonstrating how to pick a random item from a sequence in Python.\n\nExample 2: Creating random numbers with Python seed() in Python.\n\nAs stated above random module creates pseudo-random numbers. Random numbers depend on the seeding value. For example, if the seeding value is 5 then the output of the below program will always be the same. Therefore, it must not be used for encryption.\n\nThe code sets the random number generator’s seed to 5 using , ensuring reproducibility. It then prints two random floating-point numbers between 0 and 1 using . The seed makes these numbers the same every time you run the code with a seed of 5, providing consistency in the generated random values.\n\nrandom.randint() method is used to generate random integers between the given range.\n\nThis code uses the ‘ module to generate random integers within specific ranges. It first generates a random integer between 5 and 15 (inclusive) and then between -10 and -2 (inclusive). The generated integers are printed with appropriate formatting.\n\nA random.random() method is used to generate random floats between 0.0 to 1.\n\nIn this code, we are using the function from the ‘ module in Python. It prints a random floating-point number between 0 and 1 when you call .\n\nRandom sampling from a list in Python (random.choice, and sample)\n\nExample 1: Python random.choice() function is used to return a random item from a list, tuple, or string.\n\nThe code uses the function from the module to randomly select elements from different data types. It demonstrates selecting a random element from a list, a string, and a tuple. The chosen elements will vary each time you run the code, making it useful for random selection from various data structures.\n\nExample 2: Python random.sample() function is used to return a random item from a list, tuple, or string.\n\nThis code utilizes the function from the ‘ module to obtain random samples from various data types. It selects three random elements without replacement from a list, a tuple, and a string, demonstrating its versatility in generating distinct random samples. With each execution, the selected elements will differ, providing random subsets from the input data structures.\n\nA random.shuffle() method is used to shuffle a sequence (list). Shuffling means changing the position of the elements of the sequence. Here, the shuffling operation is inplace.\n\nThis code uses the function from the ‘ module to shuffle the elements of a list named ‘ . It first prints the original order of the list, then shuffles it twice. The second shuffle creates a new random order, and the list’s content is displayed after each shuffle. This demonstrates how the elements are rearranged randomly in the list with each shuffle operation.\n\nIn this article we discussed about Python Random module, and also saw some examples of functions in random module in Python. Random module in Python is very important and contains very useful functions.\n\nHope this helps you in using Python Random module functions.\n\nWhat is a random module in Python?\n\nWhat is random vs Randint in Python?\n\nHow many functions are there in the random module?\n\nWhat is the syntax of the random function?\n\nWhat is the difference between the math module and the random module?"
    },
    {
        "link": "https://docs.python.org/2/library/random.html",
        "document": "This module implements pseudo-random number generators for various distributions.\n\nFor integers, uniform selection from a range. For sequences, uniform selection of a random element, a function to generate a random permutation of a list in-place, and a function for random sampling without replacement.\n\nOn the real line, there are functions to compute uniform, normal (Gaussian), lognormal, negative exponential, gamma, and beta distributions. For generating distributions of angles, the von Mises distribution is available.\n\nAlmost all module functions depend on the basic function , which generates a random float uniformly in the semi-open range [0.0, 1.0). Python uses the Mersenne Twister as the core generator. It produces 53-bit precision floats and has a period of 2**19937-1. The underlying implementation in C is both fast and threadsafe. The Mersenne Twister is one of the most extensively tested random number generators in existence. However, being completely deterministic, it is not suitable for all purposes, and is completely unsuitable for cryptographic purposes.\n\nThe functions supplied by this module are actually bound methods of a hidden instance of the class. You can instantiate your own instances of to get generators that don’t share state. This is especially useful for multi-threaded programs, creating a different instance of for each thread, and using the method to make it likely that the generated sequences seen by each thread don’t overlap.\n\nClass can also be subclassed if you want to use a different basic generator of your own devising: in that case, override the , , , and methods. Optionally, a new generator can supply a method — this allows to produce selections over an arbitrarily large range.\n\nAs an example of subclassing, the module provides the class that implements an alternative generator in pure Python. The class provides a backward compatible way to reproduce results from earlier versions of Python, which used the Wichmann-Hill algorithm as the core generator. Note that this Wichmann-Hill generator can no longer be recommended: its period is too short by contemporary standards, and the sequence generated is known to fail some stringent randomness tests. See the references below for a recent variant that repairs these flaws.\n\nThe module also provides the class which uses the system function to generate random numbers from sources provided by the operating system.\n\nReturn a k length list of unique elements chosen from the population sequence. Used for random sampling without replacement. Returns a new list containing elements from the population while leaving the original population unchanged. The resulting list is in selection order so that all sub-slices will also be valid random samples. This allows raffle winners (the sample) to be partitioned into grand prize and second place winners (the subslices). Members of the population need not be hashable or unique. If the population contains repeats, then each occurrence is a possible selection in the sample. To choose a sample from a range of integers, use an object as an argument. This is especially fast and space efficient for sampling from a large population: .\n\nThe following functions generate specific real-valued distributions. Function parameters are named after the corresponding variables in the distribution’s equation, as used in common mathematical practice; most of these equations can be found in any statistics text."
    },
    {
        "link": "https://zencoder.ai/blog/python-random-number-generator",
        "document": "Have you ever wondered how computers generate random numbers? Randomness plays a crucial role in various applications, from simulating real-world phenomena to securing sensitive data. In Python, there are several libraries designed to generate random numbers, each tailored to specific needs.\n\nIn this tutorial, we'll explore:\n• The different Python libraries available for random number generation.\n• How to use these libraries effectively.\n• Best practices to ensure efficiency and security.\n\nWhether you're a junior developer just starting out or a middle-level engineer looking to deepen your understanding, this guide is for you.\n\nRandom number generation is a fundamental aspect of programming. It enables developers to introduce variability and unpredictability into their applications. This is essential for tasks like:\n\nPython provides robust libraries to handle random number generation, each suited to different scenarios. Understanding these libraries and knowing when to use them is key to writing efficient and secure code.\n• numpy.random: Part of the NumPy library, optimized for handling large datasets and scientific computations.\n\nThe random module is included in Python's standard library and is ideal for general-purpose random number generation. It provides functions to generate random integers, floats, and even select random elements from sequences.\n\nWhen to use it:\n• Situations where cryptographic security is not a concern\n\nThe secrets module is specifically designed for generating cryptographically strong random numbers. Introduced in Python 3.6, it ensures that the numbers are unpredictable and suitable for security-sensitive applications.\n\nWhen to use it:\n\nPart of the NumPy library, numpy.random is optimized for generating large arrays of random numbers efficiently. It's particularly useful in scientific computing and data analysis.\n\nWhen to use it:\n\nNote: To use numpy.random, you need to have NumPy installed (pip install numpy).\n\nLet's start by exploring the random module for general-purpose random number generation.\n\nRemember that, for repetitive tasks or to ensure adherence to best practices, tools like zencoder can help automate code generation, saving time and reducing errors.\n\nFirst, you need to import the random module:\n\nTo generate random integers within a specific range, use random.randint(a, b), which returns a random integer N such that a <= N <= b.\n\nExplanation: This code simulates rolling a six-sided die. Each time you run the code, dice_roll will be assigned a random integer between 1 and 6.\n\nTo generate random floating-point numbers, use random.random(), which returns a float in the range [0.0, 1.0).\n\nUse random.uniform(a, b) to generate a random float N such that a <= N <= b.\n\nTo select random elements from a list or any sequence:\n• random.sample(seq, k): Returns a list of k unique elements chosen from the sequence seq.\n\nTo generate multiple random numbers within a range, you can use list comprehensions:\n\nExplanation: The underscore _ is a throwaway variable, indicating that the variable is not used in the loop body.\n\nSeeding is important when you want reproducible results, such as in testing.\n\nExplanation: Using the same seed will produce the same sequence of random numbers every time you run the code.\n\nWhen dealing with security-sensitive applications, the secrets module is the way to go.\n\nUsing zencoder, you can automate the generation of secure code snippets, ensuring that your applications adhere to the highest security standards like the following examples.\n• secrets.token_hex(nbytes): Returns a random text string, in hexadecimal. nbytes is the number of bytes.\n\nWhy Use secrets Over random for Security?\n\nThe random module is not suitable for security purposes because its pseudo-random number generator is deterministic, meaning the sequence of numbers can be predicted if the seed is known. The secrets module, on the other hand, uses the most secure source of randomness provided by the operating system.\n\nFor applications that require generating large amounts of random numbers efficiently, numpy.random is the ideal choice.\n\nAlso, when dealing with complex data analysis tasks, zencoder can help generate efficient code snippets, ensuring that your code is both performant and easy to maintain like the following examples.\n\nIf you haven't installed NumPy yet, you can do so using:\n\nNumPy provides functions to generate random numbers from various distributions:\n\nYou can use them as follows:\n\nRandom number generators have a wide range of applications across various fields.\n\nRandom numbers are essential in simulations to model real-world phenomena.\n\nExplanation: This simulation randomly generates points inside a square and counts how many fall inside the quarter circle inscribed within it. The ratio estimates Pi.\n\nRandom numbers are critical for generating secure passwords, tokens, and keys.\n\nExplanation: This function generates a secure password of the specified length using a mix of letters, digits, and punctuation.\n\nBest Practices for Random Number Generation in Python\n\nTo ensure your random number generation is effective and secure, consider the following best practices.\n\nChoosing the Right Library for the Task\n\nSelect the library that best suits your application's requirements:\n• Use random for general purposes where security is not a concern.\n• Use numpy.random for large-scale data processing and scientific computations.\n\nWhen you need consistent results (e.g., in testing or simulations), seed your random number generators:\n\nCaution: Do not seed the random number generator in security-sensitive applications, as it can make the outputs predictable.\n\nVectorization with NumPy: Use NumPy's vectorized operations to handle large datasets efficiently.\n• Avoid Loops When Possible: Use built-in functions and comprehensions instead of manual loops for better performance.\n• Do Not Use random for Security: Avoid using the random module for generating passwords or security tokens because even if you don't know the seed, with enough outputs observed, an attacker can potentially predict future values.\n• Use secrets for Cryptography: Always use the secrets module for cryptographic purposes to ensure unpredictability because the random numbers generated by secrets are unpredictable, even if previous outputs are known, as it utilizes the most secure source of randomness provided by the operating system.\n\nRandom number generation is a vital tool in a developer's toolkit, enabling the creation of dynamic, secure, and efficient applications. By understanding the strengths of Python's random, secrets, and numpy.random libraries, you can choose the right tool for your specific needs.\n• For General Purposes: Use the random module for simplicity and ease of use.\n• For Security: Use the secrets module to ensure cryptographic security.\n• For Large-Scale Applications: Use NumPy's random module for performance and efficiency.\n\nRemember to follow best practices, such as seeding for reproducibility when appropriate and ensuring that you're using the correct library for security-sensitive tasks.\n\nBy leveraging these libraries and tools like zencoder, you can write code that is not only functional but also efficient, secure, and maintainable."
    },
    {
        "link": "https://realpython.com/simpy-simulating-with-python",
        "document": "The real world is full of systems, like airports and highways, that frequently experience congestion and delay. When these systems are not optimized, their inefficiency can lead to countless unhappy customers and hours of wasted time. In this tutorial, you’ll learn how to use Python’s framework to create virtual simulations that will help you solve problems like these.\n\nIn this tutorial, you’ll learn how to:\n• Design and run a real-world simulation in Python with\n\nIn this tutorial, you’ll create a simulation for a local movie theater. Your goal is to provide the manager with a script to help find the optimal number of employees to have on staff. You can download the source code for this script by clicking on the link below:\n\nA simulation is a representation of a real-world system. One can use mathematical or computational models of this system to study how it works, or what happens when parts of it are changed. Simulations are used in airports, restaurants, mechanics, government agencies, and many other systems where poor resource allocation can lead to congestion, customer dissatisfaction, and critical transportation delays. A system can be any environment where things happen. Examples of real-world systems include car washes, banks, manufacturing plants, airports, post offices, call centers, and more. These systems have agents that undergo processes within them. For instance:\n• A car wash will have cars go through the washing process.\n• An airport will have passengers go through the security check process.\n• A call center will have customers go through the process of speaking with a telemarketer. This relationship is summed up in the table below: Understanding the processes that agents go through within a system is an important component of logistical planning, especially for large-scale organizations. For example, an airport can see passenger wait times at a security checkpoint skyrocket if there aren’t enough workers that day. Similarly, time-sensitive mail can be delayed by days (or even weeks) if it isn’t routed properly. These instances of congestion can have real-life consequences on time and money, so it’s important to be able to model these processes beforehand. This gives you an idea of where the system might run into problems and how resources should be allocated ahead of time to solve those problems in the most efficient way possible.\n\nIn Python, you can use the framework for event simulation. First, take a quick look at how a simulated process would run in Python. Below is a code snippet from a simulation of a security checkpoint system. The following three lines of code set up the environment, pass all necessary functions, and run the simulation: The first line of code above establishes the environment. You’ll do this by assigning to the desired variable. Here, it’s simply named . This tells to create an environment object named that will manage the simulation time and move the simulation through each subsequent time step. Once you have your environment established, you’ll pass in all of the variables that will act as your parameters. These are the things you can vary to see how the system will react to changes. For this security checkpoint system, you’re using the following parameters:\n• : the environment object to schedule and process events\n• the length of time it takes to check a passenger’s ID\n• : the rate at which passengers arrive at the queue Then, it’s time to run the simulation! You can do this by calling and specifying how long you want the simulation to run for. The simulation runs in minutes, so this sample code will run the simulation for 10 real-time minutes. Note: Don’t worry! You won’t have to wait 10 actual minutes for the simulation to finish. Because simulation gives you a virtual look at a real-time process, those 10 minutes will pass in mere seconds on the computer. To recap, here are the three steps to running a simulation in Python: But there’s a lot more going on underneath the hood! You’ll need to understand how to choose those parameters, and you’ll have to define all the functions that will be called when the simulation is run.\n\nHow to Get Started With There are a few to-dos you should check off your list before creating simulations in Python. The first thing you need to do is make sure you have a solid understanding of Python basics. In particular, you’ll need to have a good grasp of classes and generators. Note: If you need to freshen up on these topics, then check out Intro to Object-Oriented Programming (OOP) in Python and Introduction to Python Generators. These are crucial pieces of the simulation process, so you’ll need to understand them before moving forward. The next thing you’ll want to do is install the required package. The main framework you’ll be using is . This is the core package that will create, manage, and run your simulation. You can install it with : You’ll also need a few built-in Python modules. You’ll use the module to calculate average wait times and the module to generate random numbers. These come as part of the Python standard library, so you don’t need to install anything new. Finally, you’ll need to choose how you want to run your simulation. In general, you can choose one of two options:\n• Run it interactively: Use a Jupyter Notebook, where each code block will contain its own class or function definition. The output will be displayed at the bottom of the notebook.\n• Run it in the shell: Save your simulation as a file and tell Python to run it in your terminal. The output will be printed directly to the console. Choose whichever method you’re most comfortable with! The outcome should be the same. Throughout this tutorial, you’ll see references to a standalone file named . As you move through this tutorial, the code blocks will reference to help you keep track of how all the pieces fit together. For your reference, you can access the full code for at the link below: Download Code: Click here to download the code you’ll use to learn about SimPy in this tutorial. Feel free to save the file and follow along in your favorite editor!\n\nHow to Simulate With the Package The first step to running a simulation in is to choose a process to model. Simulation is all about creating a virtual environment to reflect a real-world system. In that same spirit, you’ll “simulate” a situation for your simulation! Imagine you’ve been hired to help the manager for a small, local movie theater. The theater has been receiving poor reviews due to their long wait times. The manager, who is just as concerned about cost as he is about customer satisfaction, can only afford to keep so many employees on staff. The manager is particularly worried about what chaos can unfold once those blockbusters start coming out: lines wrapping around the theater, employees stretched to their limit, angry moviegoers missing the opening scenes… This is definitely a situation to avoid! After checking the reviews, the manager was able to determine that a given moviegoer to their theater is willing to spend at most 10 minutes from the time they arrive until the time they put their butt in a seat. In other words, the average wait time for a night at the theater needs to be 10 minutes or less. The manager has asked for your help to figure out a solution to getting customer wait times under this 10 minute requirement. Before you write out a single line of code, it’s important that you first figure out how your process would run in real life. This is to ensure that, when you pass it along to the machine, the process is an accurate reflection of what customers will really experience. Here’s how you might think through the steps a moviegoer might take to write out your algorithm:\n• Arrive at the theater, get in line, and wait to purchase a ticket.\n• Wait in line to have the ticket checked.\n• Get the ticket checked by an usher.\n• Choose whether or not to get in line for the concession stand:\n• If they get in line, then they purchase food.\n• If they don’t get in line, then they skip to the last step. This is a step-by-step iteration for a moviegoer who purchases their ticket at the theater box office. You can already see which parts of this process can be controlled. You can affect how long a customer is waiting by having more cashiers available at the box office. There are also parts of the process that can’t be controlled, like the very first step. You can’t control how many customers will arrive, or how quickly they’ll do so. You can make a guess, but you can’t simply choose a number, because that would be a poor reflection of reality. For this parameter, the best thing you can do is use available data to determine an appropriate arrival time. Note: Using historical data ensures that the solution you find will accurately reflect what you can expect to see in real life. With these things in mind, it’s time to build your simulation! Before you start building your simulation, you need to make sure that your development environment is properly configured. The very first thing you’ll want to do is import the necessary packages. You can do this by declaring statements at the top of your file: These are the main libraries you’ll use to build a script for the theater manager. Remember, the goal is to find the optimal number of employees that gives an average wait time of less than 10 minutes. To do this, you’ll need to collect the length of time that it takes for each moviegoer to make it to their seats. The next step is to declare a list to hold these times: This list will contain the total amount of time each moviegoer spends moving through the theater, from arrival to sitting in their seat. You declare this list at the very top of the file so that you can use it inside any function you define later on. The first part of the simulation you’ll want to build is the blueprint for the system. This is going to be the overall environment inside which things happen, and people or objects move from one place to another. Remember, an environment can be one of many different systems, like a bank, a car wash, or a security checkpoint. In this case, the environment is a movie theater, so that will be the name of your class: Now it’s time to think through the parts of a movie theater. Of course, there’s the theater itself, which is what you’ve called your environment. Later, you’ll explicitly declare the theater as an actual using one of the functions. For now, call it for short and add it to the class definition: Alright, what else might there be in a theater? You can figure this out by thinking through the simulation algorithm you planned out earlier. When a moviegoer arrives, they’ll need to get in line at the box office, where a cashier will be waiting to help them out. Now you’ve discovered two things about the theater environment:\n• Moviegoers can purchase tickets from them. Cashiers are a resource that the theater makes available to its customers, and they help moviegoers through the process of purchasing a ticket. Right now, you don’t know how many cashiers are available in the simulated theater. In fact, that’s the very problem you’re trying to solve. How do wait times change, depending on the number of cashiers working on a given night? You can go ahead and call this unknown variable . The exact value this variable will take can be sorted out later. For now, just know that it’s an indispensable part of the theater environment. Add it to the class definition: Here, you add the new parameter to your definition. Then, you create a resource and use to declare how many can be in this environment at any given time. Note: In , resources are the parts of the environment ( ) that are limited in number. Using one of them takes time, and only so many ( ) are available to be used at once. There’s one more step that you’ll need to take. A cashier isn’t going to purchase a ticket for themselves, right? They’re going to help the moviegoer! Again, you know that this process of purchasing a ticket is going to take a certain amount of time. But just how much time? Say you’ve asked the manager for historical data on the theater, like employee performance reviews or ticket purchase receipts. Based on this data, you’ve learned that it takes, on average, between 1 and 2 minutes to issue a ticket at the box office. How do you get to mimic this behavior? It only takes one line of code: tells to trigger an event after a certain amount of time has passed. In this case, the event is that a ticket was purchased. The time this takes could be one minute, two minutes, or three minutes. You want each moviegoer to spend a different amount of time at the cashier. To do this, you use to choose a random number between the given low and high values. Then, for each moviegoer, the simulation will wait for the chosen amount of time. Let’s wrap this up in a tidy function and add it to the class definition: The one initiating the event in is the , so they must be passed as a required argument. Note: You’ll see how the moviegoer actually purchases the ticket in the next section! That’s it! You’ve selected a time-bound resource, defined its related process, and codified this in your class definition. For this tutorial, there are two more resources you’ll need to declare: After checking the data the manager sent over, you determine that servers take anywhere between 1 and 5 minutes to complete an order. In addition, ushers are remarkably fast at checking tickets, with an average speed of 3 seconds! You’ll need to add these resources to your class and define the corresponding functions and . Can you figure out what the code should look like? When you’ve got an idea, you can expand the code block below to check your understanding: Take a close look at the new resources and functions. Notice how they follow the same format as described above. uses to generate a random number between 1 and 5 minutes, representing the time it would take a moviegoer to place an order and receive their food. The time delay for is a bit different because the ushers only take 3 seconds. Since works in minutes, this value needs to be passed as a fraction of a minute, or . Alright, you’ve set up the environment by defining a class. You have resources and processes. Now you need a to use them. When a arrives at the theater, they’ll request a resource, wait for its process to complete, and then leave. You’ll create a function, called , to keep track of this: There are three arguments passed to this function:\n• : The will be controlled by the environment, so you’ll pass this as the first argument.\n• : This variable tracks each person as they move through the system.\n• : This parameter gives you access to the processes you defined in the overall class definition. You also declare a variable to hold the time at which each arrives at the theater. You can get this time using the call to . You’ll want each of the processes from your to have corresponding requests in . For example, the first process in the class is , which uses a resource. The will need to make a request to the resource to help them through the process. Here’s a table to summarize this: The cashier is a shared resource, which means that many moviegoers will use the same cashier. However, a cashier can only help one moviegoer at a time, so you’ll need to include some waiting behavior in your code. Here’s how that works:\n• : waits for a to become available if all are currently in use. To learn more about the keyword, check out How to Use Generators and yield in Python.\n• : uses an available to complete the given process. In this case, that’s to purchase a ticket with a call to . After a resource is used, it must be freed up for the next agent to use. You could do this explicitly with , but in the code above, you use a statement instead. This shortcut tells the simulation to automatically release the resource once the process is complete. In other words, once the ticket is bought, the will leave, and the cashier will automatically be ready to take the next customer. When a cashier is freed up, the will spend some time buying their ticket. tells the simulation to go to the instance and run the process on this . The will repeat this request, use, release cycle to have their ticket checked: Here, the structure for the code is the same. Then, there’s the optional step of buying food from the concession stand. You can’t know whether a moviegoer will want to purchase snacks and drinks. One way to deal with this uncertainty is to introduce a bit of randomness to the function. Each either will or will not want to buy food, which you can store as the Boolean values or . Then, use the module to have the simulation randomly decide whether or not this particular is going to proceed to the concession stand: This conditional statement will return one of two outcomes:\n• : The will request a server and order food.\n• : The will instead go to find their seats without purchasing any snacks. Now, remember the goal of this simulation is to determine the number of cashiers, ushers, and servers that should be on staff to keep wait times under 10 minutes. To do this, you’ll need to know how long it took any given to make it to their seats. You use at the beginning of the function to track the , and again at the end when each is finished with all processes and heading into the theater: You use to get the time at which the has finished all processes and made it to their seats. You subtract the moviegoer’s from this departure time and append the resulting time difference to your waiting list, . Note: You could store the departure time in a separate variable like , but this would make your code very repetitive, which violates the D.R.Y. principle. This is ready to watch some previews! Now you’ll need to define a function to run the simulation. will be responsible for creating an instance of a theater and generating moviegoers until the simulation stops. The first thing this function should do is create an instance of a theater: Since this is the main process, you’ll need to pass all of the unknowns you’ve declared so far: These are all variables that the simulation needs to create and control the environment, so it’s absolutely vital to pass them all. Then, you define a variable and tell the simulation to set up the theater with a certain number of cashiers, servers, and ushers. You also might want to start your simulation with a few moviegoers waiting at the theater. There will probably be a few people ready to go as soon as the doors open! The manager says to expect around 3 moviegoers in line ready to buy tickets as soon as the box office opens. You can tell the simulation to go ahead and move through this initial group like so: You use to populate the theater with 3 moviegoers. Then, you use to tell the simulation to prepare to move them through the theater. The rest of the moviegoers will make it to the theater in their own time. So, the function should keep sending new customers into the theater as long as the simulation is running. You don’t know how long it will take new moviegoers to make it to the theater, so you decide to look at past data. Using timestamped receipts from the box office, you learn that moviegoers tend to arrive at the theater, on average, every 12 seconds. Now all you have to do is tell the function to wait this long before generating a new person: Note that you use the decimal number to represent 12 seconds. To get this number, you simply divide 12 seconds by 60 seconds, which is the number of seconds in a minute. After waiting, the function should increment by 1 and generate the next person. The generator function is the same one you used to initialize the first 3 moviegoers: That’s it! When you call this function, the simulation will generate 3 moviegoers to start and begin moving them through the theater with . After that, new moviegoers will arrive at the theater with an interval of 12 seconds and move through the theater in their own time. At this point, you should have a list that contains the total amount of time it took each moviegoer to make it to their seat. Now you’ll want to define a function to help calculate the average time a spends from the time they arrive to the time they finish checking their ticket. does just this: This function takes your list as an argument and uses to calculate the average wait time. Since you’re creating a script that will be used by the movie theater manager, you’ll want to make sure that the output can be read easily by the user. You can add a function called to do this: The last part of the function uses to return the results in minutes and seconds, so the manager can easily understand the program’s output. As you’ve built these functions, you’ve run into a few variables that have not been clearly defined: These variables are the parameters that you can change to see how the simulation changes. If a blockbuster movie has customers lining up around the block, how many cashiers should be working? What if people are flying through the box office but getting stuck at concessions? What value of will help ease the flow? Note: That’s the beauty of simulation. It allows you to try these things out so that you can determine the best possible decision in real life. Whoever is using your simulation needs to be able to change the values of these parameters to try out different scenarios. To this end, you’ll create a helper function to get these values from the user: \"Could not parse input. The simulation will use default values:\" This function simply calls Python’s function to retrieve data from the user. Because user input runs the risk of being messy, you can include an clause to catch anything invalid. If the user inputs bad data, then the simulation will run with default values. The last function you’ll want to create is . This will ensure your script runs in the proper order when you execute it on the command line. You can read more about in Defining Main Functions in Python. Here’s what your should look like:\n• Set up your environment by declaring a random seed. This ensures your output will look like what you see in this tutorial.\n• Query the user of your program for some input.\n• Create the environment and save it as the variable , which will move the simulation through each time step.\n• Tell to run the process , which creates the theater environment and generates moviegoers to move through it.\n• Determine how long you want the simulation to run. As a default value, the simulation is set to run for 90 minutes.\n• Store the output of in two variables, and .\n• Use to show the results to the user. With this, the setup is complete!"
    },
    {
        "link": "https://medium.com/@bragadeeshs/simulating-success-mastering-simulation-analysis-with-python-8d6958c7eca0",
        "document": "Simulation analysis stands as a powerful tool in the modern technological toolkit, widely used across diverse fields such as engineering, finance, healthcare, and more. At its core, simulation analysis involves the use of computer models to replicate and study the behavior of complex real-world systems and processes. This technique allows researchers, engineers, and decision-makers to explore, predict, and optimize outcomes in a virtual environment before implementing them in reality.\n• Definition: Simulation analysis is the process of creating a computer-based model of a real or proposed system to study its behavior under different scenarios. This model can be as simple as a spreadsheet program simulating financial projections or as complex as a 3D model of weather patterns.\n• Purpose: The primary purpose of simulation analysis is to analyze how a system behaves and to predict its future behavior under various conditions. This is particularly valuable in scenarios where real-world experimentation is impractical, dangerous, costly, or impossible.\n• Engineering: In engineering, simulation is used for design and testing. For instance…"
    },
    {
        "link": "https://medium.com/@vitostamatti1995/introduction-to-discrete-event-simulation-with-python-3b0cce67f92e",
        "document": "Discrete Event Simulation (DES) is a powerful modeling technique that enables the emulation of real-world systems by simulating individual events as they occur over time. In data science, DES serves as a critical tool for modeling dynamic systems and processes, aiding in understanding their behavior, optimizing performance, and making informed decisions.\n\nThe relevance of DES in data science is profound. It finds applications in diverse domains, including but not limited to operations research, supply chain management, healthcare systems, transportation, and finance. DES allows data scientists to simulate complex scenarios, analyze system behaviors under various conditions, and derive insights that aid in strategic planning and decision-making.\n\nThis post aims to provide an introduction to Discrete Event Simulation from the perspective of a data scientist. Specifically, it focuses on leveraging Python’s Simpy library to implement DES models. The primary goal is to illustrate how Simpy can be a valuable asset in a data scientist’s toolkit for simulating and analyzing dynamic systems, offering a hands-on approach to understand the concept of DES and its practical applications.\n\nThroughout this post, we will explore the fundamental concepts behind DES, dive into the functionalities of Simpy, and showcase examples demonstrating how this combination can be instrumental in modeling and analyzing real-world systems. By the end, you should gain insights into the potential of DES using Simpy and its relevance in the realm of data science.\n\nLet’s embark on this journey into the world of Discrete Event Simulation with Python’s Simpy library, where data science meets the simulation of dynamic systems for insightful analysis and decision-making.\n\nDiscrete Event Simulation (DES) operates on the premise of modeling dynamic systems by tracking individual events as they occur at distinct points in time. It’s a powerful technique employed to simulate and analyze systems where changes occur instantaneously, focusing on key events that drive system behavior.\n\nAt its core, DES revolves around entities, events, the simulation clock, and queues.\n• Entities represent the objects or elements within the system under observation.\n• Events, triggered by entities, denote occurrences that affect the system’s state or condition.\n• The simulation clock marks discrete instances when these events transpire, driving the progression of time within the simulated environment.\n• Queues play a pivotal role in managing and processing entities, representing waiting lines or buffers where entities await processing or service.\n\nIf we go one abstraction layer up, common DES components can be classified into sources, servers (with or withtout queues) and sinks.\n• Sources are responsible of producing entities and inserting them into the simulating system. Times between arrival and amount of entities per arrival are common parameters of sources.\n• Servers are in charge of delaying entities in the system for a given time period defined usually as a processing time.\n• Sinks are used to remove entities from the simlating system and are useful to collect information about times spend by entities and performance of the overall system.\n\nDES finds wide-ranging applications in modeling real-world systems across diverse domains. For instance, in manufacturing, DES facilitates the optimization of production lines by simulating the movement of materials or resources through different stages of the manufacturing process. In logistics and transportation, DES helps in modeling traffic flow, allowing analysts to simulate congestion scenarios or evaluate route optimization strategies.\n\nMoreover, DES proves invaluable in healthcare systems for analyzing patient flow through hospitals or clinics, optimizing resource allocation, and evaluating the impact of different operational strategies. Financial institutions leverage DES to model transaction processing, simulate market behavior, or evaluate risk management strategies.\n\nUnderstanding the core concepts of DES forms the foundation for constructing models that emulate the behavior of real-world systems. The versatility of DES in simulating various scenarios and its applicability across industries underscores its significance in data science for modeling complex dynamic systems and deriving insights that aid in decision-making and system optimization.\n• Workflow Modeling: DES enables modeling complex workflows within systems, aiding in understanding process dynamics. For instance, in software development, DES can simulate the flow of tasks in an Agile environment, allowing for optimization of development processes.\n• Process Optimization: DES can be used to optimize manufacturing processes, supply chain operations, or service systems. By simulating different scenarios, DES helps identify bottlenecks and inefficiencies, thereby enabling data-driven process improvements.\n• Resource Allocation Analysis: DES aids in analyzing resource allocation strategies. For instance, in healthcare, it can model patient flow in hospitals to optimize staff allocation or bed utilization.\n• System Performance Evaluation: Consider a data center where DES can model server operations, traffic loads, and network congestion. Utilizing DES allows for sophisticated analysis, aiding in predicting system performance under varying workloads.\n• Predictive Modeling: DES serves as a predictive modeling tool. For instance, in predictive maintenance, DES can simulate equipment failure scenarios, enabling proactive maintenance scheduling based on predicted failures.\n• Cost-Effective Experimentation: DES allows for cost-effective experimentation. I can be used to simulate different strategies or scenarios without real-world implementation, reducing risks and costs associated with trial and error.\n\nWhile DES offers powerful capabilities, it’s important to mention the challenges and limitations when employing this approach.\n• Complexity in Model Construction: Building DES models can be intricate, especially when modeling complex systems with numerous interacting entities and events. Handling intricate interactions and dependencies while ensuring model accuracy might pose challenges.\n• Computational Resource Intensity: Simulating large-scale systems using DES might require substantial computational resources. Processing time and memory usage may increase significantly, impacting the feasibility of simulating extensive scenarios.\n• Continuous vs. Discrete Systems: DES is suitable for modeling systems with discrete events. However, for systems where events occur continuously or in a continuous manner (e.g., physical systems with continuous processes), other simulation techniques like continuous simulation or differential equations might be more appropriate.\n\nUnderstanding the challenges and limitations of employing DES with Simpy is crucial. Mitigating challenges through model abstraction, optimization techniques, and recognizing scenarios where DES might not be the optimal solution ensures more informed decision-making in selecting appropriate simulation methodologies.\n\nIn this set of examples, we’ll explore the Simpy library and its main objects. It’s not the most intuitive library, but not because of the design or quality of it, but due to the non-trivial problem that it aims to solve. Discrete Event Simulation with Python is not an easy task, and I’m far from being an expert in this matter, so I apologize in advance if I make a wrong use of the Simpy library or the concepts behind it.\n\nEasiest way to setup simpy is to install it using `pip` with the following command.\n\nThis first example is just to ilustrate how to start a simulation and what Simpy needs in order to make its magic.\n\nFirst of all, we need to import and install simpy. Then, to make an event ocurr we need to use python generators. The explanation of generators is far beyond the scope of this post but I strongly recommend to take a look at the official python documentation.\n\nThe way I like to think about generators in this specific scenario is that they will freeze the excecution until a condition is passed. In our case, this conditions is the env.timeout() event, which internally makes the simulation time to advance. After this timeout is finished, the excecution continues from where it was interrupted.\n\nAn alternative to python functions, is to use python classes (which I personally prefer). This allows us to build much more “interpretable” models where the simulation objects represents real objects.\n\nIn this example, we’ll make a process to run uninterruptedly and to let simpy enviroment finish the simulation when a maximum time is reached. This kind of simulation it’s mostly use to emulate real time dependent process and to evaluate it’s progress over time.\n\nIn this example, we simulate a machine that processes products in a queue or production plan. The processing time of each product is define by a random variable and sampled from a triangular distribution with a given minimum, mode and maximum parameters.\n\nThe policy used to select the next product can be of three different types:\n• FIFO (first in, first out)\n• LIFO (last in, first out)\n\nThe code necesary to run the previous example could be as follow:\n\nAnd the outputs for each queue policy can be seen in the next block.\n\nYou might be thinking that, with what has been presented so far, it is not enough to apply this tool and analyze highly complex issues as those encountered in real-life scenarios. As I mentioned at the beginning, this post does not aim to demonstrate the use of DES in a real application context, but rather to introduce and ignite interest in the world of simulation, which, in my humble opinion, is an undervalued technique hiding immense potential\n\nI’ll leave you some examples of systems that I could cover in future posts or maybe you could try to implement.\n\nIn conclusion, this post has provided valuable insights into Discrete Event Simulation (DES) and its applications in data science, particularly in utilizing Python’s Simpy library for modeling dynamic systems.\n• Understanding the Essence: We explored the fundamental concepts behind DES, including entities, events, simulation clocks, and queues. These concepts form the backbone of constructing models that replicate real-world system behaviors.\n• Applications: We highlighted practical applications of DES in data science, such as modeling workflows, optimizing processes, and analyzing resource allocation. DES with Simpy emerges as a potent tool for predictive modeling and strategic decision-making.\n• Challenges and Considerations: Acknowledging the challenges and limitations of employing DES is vital. From model complexity to computational resource intensity, data scientists can anticipate hurdles and strategize mitigation approaches effectively.\n\nThe Importance of DES in Data Science\n\nUnderstanding DES is pivotal for data scientists, enabling them to model and simulate complex systems, derive insights, and make informed decisions. Simpy, as a powerful tool, empowers data scientists to implement DES models effectively, allowing for experimentation and prediction in various domains of data science.\n\nAs we conclude, I encourage further exploration and experimentation with DES and Simpy. Delving deeper into DES methodologies and harnessing the functionalities of Simpy can open doors to innovative solutions, optimization strategies, and predictive modeling in diverse industries.\n\nIncorporating DES with Simpy into your data science toolkit not only facilitates better understanding but also empowers you to tackle complex real-world problems with confidence and precision."
    },
    {
        "link": "https://arxiv.org/pdf/2403.15669",
        "document": ""
    },
    {
        "link": "https://reddit.com/r/Python/comments/1gz3bgp/i_wrote_a_guide_to_simulation_in_python_with_simpy",
        "document": "I wrote a guide on discrete-event simulation with SimPy, designed to help you learn how to build simulations using Python. Kind of like the official documentation but on steroids.\n\nI have used SimPy personally in my own career for over a decade, it was central in helping me build a pretty successful engineering career. Discrete-event simulation is useful for modelling real world industrial systems such as factories, mines, railways, etc.\n\nMy latest venture is teaching others all about this.\n\nIf you do get the guide, I’d really appreciate any feedback you have. Feel free to drop your thoughts here in the thread or DM me directly!\n\nHere’s the link to get the guide: https://simulation.teachem.digital/free-simulation-in-python-guide\n\nFor full transparency, why do I ask for your email?\n\nWell I’m working on a full course following on from my previous Udemy course on Python. This new course will be all about real-world modelling and simulation with SimPy, and I’d love to send you keep you in the loop via email. If you found the guide helpful you would might be interested in the course. That said, you’re completely free to hit “unsubscribe” after the guide arrives if you prefer."
    }
]