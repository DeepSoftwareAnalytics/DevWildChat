[
    {
        "link": "https://geeksforgeeks.org/python-list-slicing",
        "document": "Python list slicing is fundamental concept that let us easily access specific elements in a list. In this article, we’ll learn the syntax and how to use both positive and negative indexing for slicing with examples.\n\nExample: Get the items from a list starting at position 1 and ending at position 4 (exclusive).\n• start (optional): Index to begin the slice (inclusive). Defaults to 0 if omitted.\n• end (optional): Index to end the slice (exclusive). Defaults to the length of list if omitted.\n• step (optional): Step size, specifying the interval between elements. Defaults to 1 if omitted\n\nLet’s see how to use list slicing in Python with the examples below.\n\nGet all the items from a list\n\nTo retrieve all items from a list, we can use slicing without specifying any parameters.\n\nExplanation: Using [:] & [::] without specifying any start, end, or step returns all elements of the list.\n\nTo get all the items from a specific position to the end of the list, we can specify the start index and leave the end blank.\n\nAnd to get all the items before a specific index, we can specify the end index while leaving start blank.\n\nGet all items between two positions\n\nTo extract elements between two specific positions, specify both the start and end indices\n\nGet items at specified intervals\n\nTo extract elements at specific intervals, use the step parameter.\n\nIn Python, list slicing allows out-of-bound indexing without raising errors. If we specify indices beyond the list length then it will simply return the available items.\n\nExample: The slice a[7:15] starts at index 7 and attempts to reach index 15, but since the list ends at index 8, so it will return only the available elements (i.e. [8,9]).\n\nNegative indexing is useful for accessing elements from the end of the list. The last element has an index of -1, the second last element -2, and so on.\n\nThis example shows how to use negative numbers to access elements from the list starting from the end. Negative indexing makes it easy to get items without needing to know the exact length of the list.\n\nIn this example, we’ll reverse the entire list using a slicing trick. By using a negative step value, we can move through the list in reverse order.\n\nExplanation: The negative step (-1) indicates that Python should traverse the list in reverse order, starting from the end. The slice a[::-1] starts from the end of the list and moves to the beginning which result in reversing list. It’s a quick and easy way to get the list in reverse without changing the original list."
    },
    {
        "link": "https://railsware.com/blog/indexing-and-slicing-for-lists-tuples-strings-sequential-types",
        "document": "List is arguably the most useful and ubiquitous type in Python. One of the reasons it’s so handy is Python slice notation. In short, slicing is a flexible tool to build new lists out of an existing list.\n\nPython supports slice notation for any sequential data type like lists, strings, tuples, bytes, bytearrays, and ranges. Also, any new data structure can add its support as well. This is greatly used (and abused) in NumPy and Pandas libraries, which are so popular in Machine Learning and Data Science. It’s a good example of “learn once, use everywhere”.\n\nIn this article, we will focus on indexing and slicing operations over Python’s lists. Most of the examples we will discuss can be used for any sequential data type. Only mutable assignment and deletion operations are not applicable to immutable sequence types like tuples, strings, bytes, and ranges.\n\nBefore discussing slice notation, we need to have a good grasp of indexing for sequential types.\n\nIn Python, list is akin to arrays in other scripting languages(Ruby, JavaScript, PHP). It allows you to store an enumerated set of items in one place and access an item by its position – index.\n\nHere we defined a list of colors. Each item in the list has a value(color name) and an index(its position in the list). Python uses zero-based indexing. That means, the first element(value ‘red’) has an index 0, the second(value ‘green’) has index 1, and so on.\n\nTo access an element by its index we need to use square brackets:\n\nUsing indexing we can easily get any element by its position. This is handy if we use position from the head of a list. But what if we want to take the last element of a list? Or the penultimate element? In this case, we want to enumerate elements from the tail of a list.\n\nTo address this requirement there is negative indexing. So, instead of using indexes from zero and above, we can use indexes from -1 and below.\n\nIn negative indexing system -1 corresponds to the last element of the list(value ‘black’), -2 to the penultimate (value ‘white’), and so on.\n\nBefore we used indexing only for accessing the content of a list cell. But it’s also possible to change cell content using an assignment operation:\n\nWe can freely use positive or negative indexing for assignment.\n\nWe can also easily delete any element from the list by using indexing and statement:\n\nRead-only indexing operations work perfectly well for all sequential types. But assignment and deletion operations are not applicable to immutable sequential types.\n\nAs it was shown, indexing allows you to access/change/delete only a single cell of a list. What if we want to get a sublist of the list. Or we want to update a bunch of cells at once? Or we want to go on a frenzy and extend a list with an arbitrary number of new cells in any position?\n\nThose and lots of other cool tricks can be done with slice notation. Let’s look at this subject – feel free to follow along on your own editor or with an online Python compiler.\n\nWhat if we want to take a sublist from the list? This is a snap when using slice:\n\nSo, here is our first example of a slice: 2:7. The full slice syntax is: start:stop:step. refers to the index of the element which is used as a start of our slice. refers to the index of the element we should stop just before to finish our slice. allows you to take each nth-element within a start:stop range.\n\nIn our example equals , so our slice starts from value . is , so the last element of the slice is with index . In the end, slice creates a new list(we named it ) with selected elements.\n\nWe did not use in our slice, so we didn’t skip any element and obtained all values within the range.\n\nWith slices we can extract an arbitrary part of a list, e.g.:\n\nHere we start from the first element(index ) and take a list till the element with index .\n\nSlice notation allows you to skip any element of the full syntax. If we skip the number then it starts from index:\n\nSo, nums[:5] is equivalent to nums[0:5]. This combination is a handy shortcut to take n first elements of a list.\n\nNegative indexes allow us to easily take n-last elements of a list:\n\nHere, the parameter is skipped. That means you take from the position, till the end of the list. We start from the third element from the end (value with index ) and take everything to the end.\n\nWe can freely mix negative and positive indexes in and positions:\n\nTaking all but n last elements of a list\n\nWe take all but the last two elements of original list.\n\nWhat if we want to have only every 2-nd element of ? This is where the parameter comes into play:\n\nHere we omit / parameters and use only . By providing we can skip some elements:\n\nAnd if we don’t want to include some elements at the end, we can also add the parameter:\n\nWe can use a negative to obtain a reversed list:\n\nNegative changes a way, slice notation works. It makes the slice be built from the tail of the list. So, it goes from the last element to the first element. That’s why we get a reversed list with a negative step.\n\nDue to this peculiarity, and should be provided from right to left as well. E.g., if you want to have a reversed list which starts from :\n\nSo, we start from the element (value ) and go from right to left collecting all the elements in a reversed list.\n\nWe can use value to stop taking before some element. E.g., let’s not include and values:\n\nWe use for index, which is the element with value . So, we go from 80 till 30, not including value .\n\nIt’s a bit baffling that with a negative , index is located before . Negative turns everything upside down.\n\nOf course, we can use an arbitrary negative :\n\nOne important thing to notice – is that list slice creates a shallow copy of the initial list. That means, we can safely modify the new list and it will not affect the initial list:\n\nDespite our mutating the element under index , it does not affect the list, because list – is a partial copy of list.\n\nThere is the shortest form of slice notation – just colons nums[:].\n\nIt creates a shallow copy of the whole list and is a good shorthand when you need a copy of the original list.\n\nBut what if we want to use the same slice over and over again. Is there a way to create a slice object instead of using just the syntactic form?\n\nThis can be done using function:\n\nfunction accepts arguments in the same order as in slice notation, and if you need to skip some element, just use :\n\nPython supports slice assignment operation, which allows us to make a bunch of neat operations over an existing list. Unlike previous slice operations, these mutate the original object in place. That’s why they are not applicable to immutable sequential types.\n\nSlice assignment allows you to update a part of a list with new values:\n\nHere we do not change the number of elements in the list. Only some list values are updated.\n\nReplace and Resize part of the list\n\nWe can replace part of a list with a bigger chunk instead:\n\nIn this case we extend the original list.\n\nIt’s also possible to replace a bigger chunk with a smaller number of items:\n\nAdding allows to replace each n-th element with a new value:\n\nUsing slice assignment with sets a limitation on the list we provide for assignment. The provided list should exactly match the number of elements to replace. If the length does not match, Python throws the exception:\n\nWe can also use negative :\n\nBy providing and values we can narrow the replacement area:\n\nWe can also use statement to remove a slice out of a list:\n\nHere we’ve removed a bunch of elements in the middle of list.\n\nWe can also provide parameter to slice and remove each n-th element:\n\nWith the full syntax, we can set boundaries for the elements to be removed:\n\nSo, we start deletion from 20(index 1) and remove each 2-nd element till the value 80(index 7).\n\nAnd because slice deletion mutates the underlying object, it’s not applicable to immutable sequential types.\n\nWe discussed two key list operations: indexing and slicing. Both concepts are crucial to efficient Python use.\n\nThis article prepared background for tackling indexing and slicing in and and objects. There are a lot of similarities between these structures, but there are also a lot of subtle differences and gotchas which will be discussed in upcoming articles dedicated to the machine learning techniques the Railsware team makes use of."
    },
    {
        "link": "https://freecodecamp.org/news/slicing-and-indexing-in-python",
        "document": "Slicing and indexing are two fundamental concepts in Python. They help you access specific elements in a sequence, such as a list, tuple or string.\n\nBy using these techniques, you can extract substrings from strings, filter lists, and extract columns from 2D lists, among other things.\n\nUnderstanding how to use slicing and indexing is essential for working with data in Python, so let's explore these concepts in detail and provide real-life examples to help you understand how they work.\n\nIndexing is the process of accessing an element in a sequence using its position in the sequence (its index).\n\nIn Python, indexing starts from 0, which means the first element in a sequence is at position 0, the second element is at position 1, and so on.\n\nTo access an element in a sequence, you can use square brackets with the index of the element you want to access.\n\nLet's consider the following example:\n\nIn the above code, we have created a list called and then used indexing to access the first and second elements in the list using their respective indices.\n\nSlicing is the process of accessing a sub-sequence of a sequence by specifying a starting and ending index. In Python, you perform slicing using the colon operator. The syntax for slicing is as follows:\n\nwhere is the index of the first element in the sub-sequence and is the index of the last element in the sub-sequence (excluding the element at the ). To slice a sequence, you can use square brackets with the start and end indices separated by a colon.\n\nIn the above code, we have used slicing to access a sub-sequence of containing the second and third elements.\n\nYou can also omit either the or the in a slice to get all the elements from the beginning or end of the sequence. For example:\n\nIn the first line of the above code, we have used slicing to get all the elements from the beginning of up to (but not including) the element at index 2. In the second line, we have used slicing to get all the elements from index 2 to the end of .\n\nExamples of Slicing and Indexing in Python\n\nLet's take a look at some real-life examples of how you can use slicing and indexing in Python.\n\nExample 1: How to Extract Substrings from a String\n\nSuppose we have a string representing a sentence, and we want to extract the first word from the sentence. We can do this using indexing as follows:\n\nIn the above code, we have used indexing to extract the first three characters from the string, which correspond to the first word. The syntax means that we are selecting all characters from the beginning of the string up to (but not including) the character at index 3.\n\nWe could also extract the second and third words from the sentence using slicing as follows:\n\nIn these examples, we have used slicing to extract a range of characters from the string. The slice means that we are selecting characters starting from index 4 (inclusive) up to index 9 (exclusive), which correspond to the second word \"quick\". Similarly, the slice means we are selecting characters starting from index 10 up to index 15 (exclusive), which correspond to the third word \"brown\".\n\nExample 2: How to Filter a List\n\nSuppose we have a list of numbers and we want to extract all the odd numbers from the list. We can do this using slicing as follows:\n\nIn the above code, we have used slicing to extract all the odd numbers from the list. The slice means that we are selecting every other element starting from the first element, which correspond to the odd numbers in the list. Since we only want the odd numbers, we start with the first element (index 0) and then select every other element after that.\n\nWe could also extract all the even numbers from the list using slicing as follows:\n\nIn this example, we have used slicing to extract every other element starting from the second element (index 1), which correspond to the even numbers in the list.\n\nExample 3: How to Extract Columns from a 2D List\n\nSuppose we have a 2D list representing a table of data, and we want to extract a particular column from the table. We can do this using list comprehension and indexing as follows:\n\nIn the above code, we have used list comprehension to extract the second element (index 1) from each row in the list, and then combined these elements into a new list called . The syntax means that we are selecting the second element from each row, which corresponds to the second column in the table.\n\nWe could also extract other columns from the table by changing the index used in the list comprehension, for example:\n\nIn these examples, we have used indexing to select the first and third elements from each row, which correspond to the first and third columns in the table.\n\nExample 4: How to Modify Parts of a List\n\nSuppose we have a list of numbers and we want to modify the values of some of the elements in the list. We can do this using slicing as follows:\n\nIn the above code, we have used slicing to select a range of elements from the list (indices 1 to 3), and then replaced these elements with a new list . The result is that the elements at indices 1 to 3 in the list have been replaced with the new values.\n\nWe could also insert new elements into the list using slicing as follows:\n\nIn this example, we have used slicing to insert a new list at index 4 in the list. The slice means that we are inserting the new list at index 4 (that is, before the element at index 4), but not deleting any existing elements.\n\nIn this article, we have discussed the concepts of slicing and indexing in Python and provided several examples of how they can be used to manipulate lists and strings.\n\nSlicing and indexing are powerful tools that can greatly simplify certain tasks in Python programming, such as selecting subsets of data, modifying lists, and extracting substrings. By understanding these concepts and using them effectively in your code, you can become a more efficient and effective Python programmer."
    },
    {
        "link": "https://stackoverflow.com/questions/51988142/elegant-slicing-in-python-list-based-on-index",
        "document": "An alternative that pushes the work to the C layer on CPython (the reference interpreter):\n\nThat returns of the values; if is necessary, just wrap in the constructor:\n\nNote that this only works properly if you need at least two indices; is variable return type based on how it's initialized, returning the value directly when it's passed a single key to pull, and a of values when passed more than one key.\n\nIt's also not particularly efficient for one-off uses. A more common use case would be if you had an iterable of sequences (typically s, but any sequence works), and don't care about them. For example, with an input of:\n\nif you only wanted the values from index 1 and 3, you could write a loop like:\n\nwhere you unpack all the values but send the ones you don't care about to to indicate the lack of interest, or you can use and to strip them down to what you care about before the unpack:\n\nThe based approach doesn't care if you have more than four items in a given element of , while manual unpacking would always require exactly four; which is better is largely based on your use case."
    },
    {
        "link": "https://pythonmorsels.com/slicing",
        "document": "Getting the first N elements from a list\n\nLet's say we have a variable that points to a list:\n\nWe can get an item from this list by indexing it:\n\nIf we put a colon and another number inside the square brackets, we'll slice this list instead of indexing it:\n\nSlicing a list gives us back a new list. We're getting a list of the first three items within our original list.\n\nNote that the original list is unchanged:\n\nSlicing takes a portion of the elements from our original list and makes a new list out of them:\n\nThe start index is inclusive but the stop index is exclusive\n\nWhat do you think we might get if we were to slice our list from to instead of from to ?\n\nHere are some guesses:\n• Two items starting from the second item\n• Three items starting from the second item\n• The same three items as before\n\nWhen we slice with and , we only get 2 items this time:\n\nWith Python's slicing syntax, the first item is the start index, and the second item is the stop index. The start index is inclusive, but the stop index is exclusive, meaning Python stops just before the stop index.\n\nSo we got the items at index and index because we stopped just before index .\n\nThe start and stop values are both optional when slicing.\n\nIf we don't supply a start index, we'll start at the beginning of the list (index ):\n\nSo that gave us the first 3 items.\n\nIf we don't supply a stop index, we'll stop at the end of the list:\n\nSo this slice gave us everything from the second item onward.\n\nWhy the stop index isn't included in slices\n\nYou may be wondering, why is the start index included, but the stop index is excluded?\n\nThe exclusivity of the stop index actually has a nice side effect: if you slice up to index 3 and then start slicing again from 3 onward, those two slices won't overlap.\n\nSo if we concatenate those slices back together, we'd get back something equivalent to our original list:\n\nHere's an example of making a new list that moves the first item to the end:\n\nWe're slicing from the second item (index ) onward and then we're slicing up to, but not including, the second item. This made a new list with the first item ( ) moved to the end of the list.\n\nNote that negative indexes work the same way with slicing as with indexing.\n\nIndex would give us the third to last item in a list:\n\nSlicing from onward would give us the last 3 items in the list:\n\nSlicing up to index (but not including it) would give us everything except for the last three items in the list:\n\nIndexing and slicing are a little bit different in the way they treat indexes.\n\nIf we index past the end of a list, we'll see a traceback:\n\nIndexing out-of-bounds will raise an exception. But slicing past the end of a list doesn't raise an exception:\n\nAn out-of-bounds slice just stops at the end of the list. The same applies to the beginning of the list:\n\nThis might look like a bug, but it can actually be a helpful feature. For example, if we wanted to get the first 3 items from a list, we could slice it:\n\nAnd if there are fewer than 3 items in the list we're working with, we'll still get items! We'll just get every item that's in the list:\n\nSlices have a start index and a stop index, but they also have an optional step value.\n\nThe start index defaults to , the stop index defaults to the end of the list, and the optional step value, defaults to :\n\nIf we change the step value to 2, we'll skip every other item:\n\nIf we change the step value to 3, it'll show us every third item:\n\nThe most common step value to see in a slice is . A step value of reverses the list:\n\nWhenever a negative step value is given, the default meaning of start and stop change. With a negative step value, the start value will default to the last item in the list and the stop value will default to just before the beginning of the list.\n\nReversing a list is the most common use for the step value when slicing, though I typically prefer to use Python's built-in function instead:\n\nIt's important to note that slicing doesn't just work on lists. If we can index an object, we can probably slice it.\n\nFor example, we could use slicing to get the last 3 characters in a string:\n\nYou can slice pretty much any sequence in Python. A sequence is an object that can be indexed (from to ). Lists, tuples, and strings are all examples of sequences in Python.\n\nThe most common uses for slicing in Python\n\nThe most common uses of slicing in Python are...\n\nGetting the first few items in a sequence\n\nGetting the last few items in a sequence:\n\nOr getting all items except for the first item, or all items except for the last item:\n\nThose are not the only uses of slicing, but they are the most common.\n\nUse slicing to get \"slices\" of sequences in Python\n\nYou can use slicing in Python to get portions of a list or any other sequence. Slicing is particularly great for getting the first few items, the last few items, everything but the first item, everything but the last item, or even reversing all the items in a sequence."
    },
    {
        "link": "https://docs.python.org/3.6/library/stdtypes.html",
        "document": "The following sections describe the standard types that are built into the interpreter.\n\nThe principal built-in types are numerics, sequences, mappings, classes, instances and exceptions.\n\nSome collection classes are mutable. The methods that add, subtract, or rearrange their members in place, and don’t return a specific item, never return the collection instance itself but .\n\nSome operations are supported by several object types; in particular, practically all objects can be compared, tested for truth value, and converted to a string (with the function or the slightly different function). The latter function is implicitly used when an object is written by the function.\n\nThere are three distinct numeric types: integers, floating point numbers, and complex numbers. In addition, Booleans are a subtype of integers. Integers have unlimited precision. Floating point numbers are usually implemented using in C; information about the precision and internal representation of floating point numbers for the machine on which your program is running is available in . Complex numbers have a real and imaginary part, which are each a floating point number. To extract these parts from a complex number z, use and . (The standard library includes additional numeric types, that hold rationals, and that hold floating-point numbers with user-definable precision.) Numbers are created by numeric literals or as the result of built-in functions and operators. Unadorned integer literals (including hex, octal and binary numbers) yield integers. Numeric literals containing a decimal point or an exponent sign yield floating point numbers. Appending or to a numeric literal yields an imaginary number (a complex number with a zero real part) which you can add to an integer or float to get a complex number with real and imaginary parts. Python fully supports mixed arithmetic: when a binary arithmetic operator has operands of different numeric types, the operand with the “narrower” type is widened to that of the other, where integer is narrower than floating point, which is narrower than complex. Comparisons between numbers of mixed type use the same rule. The constructors , , and can be used to produce numbers of a specific type. All numeric types (except complex) support the following operations, sorted by ascending priority (all numeric operations have a higher priority than comparison operations): absolute value or magnitude of x a complex number with real part re, imaginary part im. im defaults to zero. conjugate of the complex number c\n• None Also referred to as integer division. The resultant value is a whole integer, though the result’s type is not necessarily int. The result is always rounded towards minus infinity: is , is , is , and is .\n• None Not for complex numbers. Instead convert to floats using if appropriate.\n• None Conversion from floating point to integer may round or truncate as in C; see functions and for well-defined conversions.\n• None float also accepts the strings “nan” and “inf” with an optional prefix “+” or “-” for Not a Number (NaN) and positive or negative infinity.\n• None Python defines and to be , as is common for programming languages.\n• None The numeric literals accepted include the digits to or any Unicode equivalent (code points with the property). See http://www.unicode.org/Public/9.0.0/ucd/extracted/DerivedNumericType.txt for a complete list of code points with the property. All types ( and ) also include the following operations: x rounded to n digits, rounding half to even. If n is omitted, it defaults to 0. For additional numeric operations see the and modules. Bitwise operations only make sense for integers. The result of bitwise operations is calculated as though carried out in two’s complement with an infinite number of sign bits. The priorities of the binary bitwise operations are all lower than the numeric operations and higher than the comparisons; the unary operation has the same priority as the other unary numeric operations ( and ). This table lists the bitwise operations sorted in ascending priority: bitwise exclusive or of x and y\n• None Negative shift counts are illegal and cause a to be raised.\n• None A left shift by n bits is equivalent to multiplication by without overflow check.\n• None A right shift by n bits is equivalent to division by without overflow check.\n• None Performing these calculations with at least one extra sign extension bit in a finite two’s complement representation (a working bit-width of or more) is sufficient to get the same result as if there were an infinite number of sign bits. The int type implements the abstract base class. In addition, it provides a few more methods: Return the number of bits necessary to represent an integer in binary, excluding the sign and leading zeros: More precisely, if is nonzero, then is the unique positive integer such that . Equivalently, when is small enough to have a correctly rounded logarithm, then . If is zero, then returns . Return an array of bytes representing an integer. The integer is represented using length bytes. An is raised if the integer is not representable with the given number of bytes. The byteorder argument determines the byte order used to represent the integer. If byteorder is , the most significant byte is at the beginning of the byte array. If byteorder is , the most significant byte is at the end of the byte array. To request the native byte order of the host system, use as the byte order value. The signed argument determines whether two’s complement is used to represent the integer. If signed is and a negative integer is given, an is raised. The default value for signed is . Return the integer represented by the given array of bytes. The argument bytes must either be a bytes-like object or an iterable producing bytes. The byteorder argument determines the byte order used to represent the integer. If byteorder is , the most significant byte is at the beginning of the byte array. If byteorder is , the most significant byte is at the end of the byte array. To request the native byte order of the host system, use as the byte order value. The signed argument indicates whether two’s complement is used to represent the integer. The float type implements the abstract base class. float also has the following additional methods. Return a pair of integers whose ratio is exactly equal to the original float and with a positive denominator. Raises on infinities and a on NaNs. Return if the float instance is finite with integral value, and otherwise: Two methods support conversion to and from hexadecimal strings. Since Python’s floats are stored internally as binary numbers, converting a float to or from a decimal string usually involves a small rounding error. In contrast, hexadecimal strings allow exact representation and specification of floating-point numbers. This can be useful when debugging, and in numerical work. Return a representation of a floating-point number as a hexadecimal string. For finite floating-point numbers, this representation will always include a leading and a trailing and exponent. Class method to return the float represented by a hexadecimal string s. The string s may have leading and trailing whitespace. Note that is an instance method, while is a class method. where the optional may by either or , and are strings of hexadecimal digits, and is a decimal integer with an optional leading sign. Case is not significant, and there must be at least one hexadecimal digit in either the integer or the fraction. This syntax is similar to the syntax specified in section 6.4.4.2 of the C99 standard, and also to the syntax used in Java 1.5 onwards. In particular, the output of is usable as a hexadecimal floating-point literal in C or Java code, and hexadecimal strings produced by C’s format character or Java’s are accepted by . Note that the exponent is written in decimal rather than hexadecimal, and that it gives the power of 2 by which to multiply the coefficient. For example, the hexadecimal string represents the floating-point number , or : Applying the reverse conversion to gives a different hexadecimal string representing the same number: For numbers and , possibly of different types, it’s a requirement that whenever (see the method documentation for more details). For ease of implementation and efficiency across a variety of numeric types (including , , and ) Python’s hash for numeric types is based on a single mathematical function that’s defined for any rational number, and hence applies to all instances of and , and all finite instances of and . Essentially, this function is given by reduction modulo for a fixed prime . The value of is made available to Python as the attribute of . CPython implementation detail: Currently, the prime used is on machines with 32-bit C longs and on machines with 64-bit C longs. Here are the rules in detail:\n• None If is a nonnegative rational number and is not divisible by , define as , where gives the inverse of modulo .\n• None If is a nonnegative rational number and is divisible by (but is not) then has no inverse modulo and the rule above doesn’t apply; in this case define to be the constant value .\n• None If is a negative rational number define as . If the resulting hash is , replace it with .\n• None The particular values , and are used as hash values for positive infinity, negative infinity, or nans (respectively). (All hashable nans have the same hash value.)\n• None For a number , the hash values of the real and imaginary parts are combined by computing , reduced modulo so that it lies in . Again, if the result is , it’s replaced with . To clarify the above rules, here’s some example Python code, equivalent to the built-in hash, for computing the hash of a rational number, , or : Assumes m and n are integers, with n positive. # Remove common factors of P. (Unnecessary if m and n already coprime.) # Fermat's Little Theorem: pow(n, P-1, P) is 1, so # pow(n, P-2, P) gives the inverse of n modulo P.\n\nThere are three basic sequence types: lists, tuples, and range objects. Additional sequence types tailored for processing of binary data and text strings are described in dedicated sections. The operations in the following table are supported by most sequence types, both mutable and immutable. The ABC is provided to make it easier to correctly implement these operations on custom sequence types. This table lists the sequence operations sorted in ascending priority. In the table, s and t are sequences of the same type, n, i, j and k are integers and x is an arbitrary object that meets any type and value restrictions imposed by s. The and operations have the same priorities as the comparison operations. The (concatenation) and (repetition) operations have the same priority as the corresponding numeric operations. if an item of s is equal to x, else if an item of s is equal to x, else the concatenation of s and t equivalent to adding s to itself n times slice of s from i to j with step k index of the first occurrence of x in s (at or after index i and before index j) total number of occurrences of x in s Sequences of the same type also support comparisons. In particular, tuples and lists are compared lexicographically by comparing corresponding elements. This means that to compare equal, every element must compare equal and the two sequences must be of the same type and have the same length. (For full details see Comparisons in the language reference.)\n• None While the and operations are used only for simple containment testing in the general case, some specialised sequences (such as , and ) also use them for subsequence testing:\n• None Values of n less than are treated as (which yields an empty sequence of the same type as s). Note that items in the sequence s are not copied; they are referenced multiple times. This often haunts new Python programmers; consider: What has happened is that is a one-element list containing an empty list, so all three elements of are references to this single empty list. Modifying any of the elements of modifies this single list. You can create a list of different lists this way: Further explanation is available in the FAQ entry How do I create a multidimensional list?.\n• None If i or j is negative, the index is relative to the end of sequence s: or is substituted. But note that is still .\n• None The slice of s from i to j is defined as the sequence of items with index k such that . If i or j is greater than , use . If i is omitted or , use . If j is omitted or , use . If i is greater than or equal to j, the slice is empty.\n• None The slice of s from i to j with step k is defined as the sequence of items with index such that . In other words, the indices are , , , and so on, stopping when j is reached (but never including j). When k is positive, i and j are reduced to if they are greater. When k is negative, i and j are reduced to if they are greater. If i or j are omitted or , they become “end” values (which end depends on the sign of k). Note, k cannot be zero. If k is , it is treated like .\n• None Concatenating immutable sequences always results in a new object. This means that building up a sequence by repeated concatenation will have a quadratic runtime cost in the total sequence length. To get a linear runtime cost, you must switch to one of the alternatives below:\n• None if concatenating objects, you can build a list and use at the end or else write to an instance and retrieve its value when complete\n• None if concatenating objects, you can similarly use or , or you can do in-place concatenation with a object. objects are mutable and have an efficient overallocation mechanism\n• None for other types, investigate the relevant class documentation\n• None Some sequence types (such as ) only support item sequences that follow specific patterns, and hence don’t support sequence concatenation or repetition.\n• None raises when x is not found in s. Not all implementations support passing the additional arguments i and j. These arguments allow efficient searching of subsections of the sequence. Passing the extra arguments is roughly equivalent to using , only without copying any data and with the returned index being relative to the start of the sequence rather than the start of the slice. The only operation that immutable sequence types generally implement that is not also implemented by mutable sequence types is support for the built-in. This support allows immutable sequences, such as instances, to be used as keys and stored in and instances. Attempting to hash an immutable sequence that contains unhashable values will result in . The operations in the following table are defined on mutable sequence types. The ABC is provided to make it easier to correctly implement these operations on custom sequence types. In the table s is an instance of a mutable sequence type, t is any iterable object and x is an arbitrary object that meets any type and value restrictions imposed by s (for example, only accepts integers that meet the value restriction ). item i of s is replaced by x slice of s from i to j is replaced by the contents of the iterable t the elements of are replaced by those of t removes the elements of from the list appends x to the end of the sequence (same as ) removes all items from s (same as ) creates a shallow copy of s (same as ) extends s with the contents of t (for the most part the same as ) inserts x into s at the index given by i (same as ) retrieves the item at i and also removes it from s remove the first item from s where reverses the items of s in place\n• None t must have the same length as the slice it is replacing.\n• None The optional argument i defaults to , so that by default the last item is removed and returned.\n• None raises when x is not found in s.\n• None The method modifies the sequence in place for economy of space when reversing a large sequence. To remind users that it operates by side effect, it does not return the reversed sequence.\n• None and are included for consistency with the interfaces of mutable containers that don’t support slicing operations (such as and ) New in version 3.3: and methods.\n• None The value n is an integer, or an object implementing . Zero and negative values of n clear the sequence. Items in the sequence are not copied; they are referenced multiple times, as explained for under Common Sequence Operations. Lists are mutable sequences, typically used to store collections of homogeneous items (where the precise degree of similarity will vary by application). Lists may be constructed in several ways:\n• None Using a pair of square brackets to denote the empty list:\n• None Using the type constructor: or The constructor builds a list whose items are the same and in the same order as iterable’s items. iterable may be either a sequence, a container that supports iteration, or an iterator object. If iterable is already a list, a copy is made and returned, similar to . For example, returns and returns . If no argument is given, the constructor creates a new empty list, . Many other operations also produce lists, including the built-in. Lists implement all of the common and mutable sequence operations. Lists also provide the following additional method: This method sorts the list in place, using only comparisons between items. Exceptions are not suppressed - if any comparison operations fail, the entire sort operation will fail (and the list will likely be left in a partially modified state). accepts two arguments that can only be passed by keyword (keyword-only arguments): key specifies a function of one argument that is used to extract a comparison key from each list element (for example, ). The key corresponding to each item in the list is calculated once and then used for the entire sorting process. The default value of means that list items are sorted directly without calculating a separate key value. The utility is available to convert a 2.x style cmp function to a key function. reverse is a boolean value. If set to , then the list elements are sorted as if each comparison were reversed. This method modifies the sequence in place for economy of space when sorting a large sequence. To remind users that it operates by side effect, it does not return the sorted sequence (use to explicitly request a new sorted list instance). The method is guaranteed to be stable. A sort is stable if it guarantees not to change the relative order of elements that compare equal — this is helpful for sorting in multiple passes (for example, sort by department, then by salary grade). CPython implementation detail: While a list is being sorted, the effect of attempting to mutate, or even inspect, the list is undefined. The C implementation of Python makes the list appear empty for the duration, and raises if it can detect that the list has been mutated during a sort. Tuples are immutable sequences, typically used to store collections of heterogeneous data (such as the 2-tuples produced by the built-in). Tuples are also used for cases where an immutable sequence of homogeneous data is needed (such as allowing storage in a or instance). Tuples may be constructed in a number of ways:\n• None Using a pair of parentheses to denote the empty tuple:\n• None Using a trailing comma for a singleton tuple: or\n• None Using the built-in: or The constructor builds a tuple whose items are the same and in the same order as iterable’s items. iterable may be either a sequence, a container that supports iteration, or an iterator object. If iterable is already a tuple, it is returned unchanged. For example, returns and returns . If no argument is given, the constructor creates a new empty tuple, . Note that it is actually the comma which makes a tuple, not the parentheses. The parentheses are optional, except in the empty tuple case, or when they are needed to avoid syntactic ambiguity. For example, is a function call with three arguments, while is a function call with a 3-tuple as the sole argument. Tuples implement all of the common sequence operations. For heterogeneous collections of data where access by name is clearer than access by index, may be a more appropriate choice than a simple tuple object. The type represents an immutable sequence of numbers and is commonly used for looping a specific number of times in loops. The arguments to the range constructor must be integers (either built-in or any object that implements the special method). If the step argument is omitted, it defaults to . If the start argument is omitted, it defaults to . If step is zero, is raised. For a positive step, the contents of a range are determined by the formula where and . For a negative step, the contents of the range are still determined by the formula , but the constraints are and . A range object will be empty if does not meet the value constraint. Ranges do support negative indices, but these are interpreted as indexing from the end of the sequence determined by the positive indices. Ranges containing absolute values larger than are permitted but some features (such as ) may raise . Ranges implement all of the common sequence operations except concatenation and repetition (due to the fact that range objects can only represent sequences that follow a strict pattern and repetition and concatenation will usually violate that pattern). The value of the start parameter (or if the parameter was not supplied) The value of the stop parameter The value of the step parameter (or if the parameter was not supplied) The advantage of the type over a regular or is that a object will always take the same (small) amount of memory, no matter the size of the range it represents (as it only stores the , and values, calculating individual items and subranges as needed). Range objects implement the ABC, and provide features such as containment tests, element index lookup, slicing and support for negative indices (see Sequence Types — list, tuple, range): Testing range objects for equality with and compares them as sequences. That is, two range objects are considered equal if they represent the same sequence of values. (Note that two range objects that compare equal might have different , and attributes, for example or .) Changed in version 3.2: Implement the Sequence ABC. Support slicing and negative indices. Test objects for membership in constant time instead of iterating through all items. Changed in version 3.3: Define ‘==’ and ‘!=’ to compare range objects based on the sequence of values they define (instead of comparing based on object identity). New in version 3.3: The , and attributes.\n• None The linspace recipe shows how to implement a lazy version of range suitable for floating point applications.\n\nThe core built-in types for manipulating binary data are and . They are supported by which uses the buffer protocol to access the memory of other binary objects without needing to make a copy. The module supports efficient storage of basic data types like 32-bit integers and IEEE754 double-precision floating values. Bytes objects are immutable sequences of single bytes. Since many major binary protocols are based on the ASCII text encoding, bytes objects offer several methods that are only valid when working with ASCII compatible data and are closely related to string objects in a variety of other ways. Firstly, the syntax for bytes literals is largely the same as that for string literals, except that a prefix is added: Only ASCII characters are permitted in bytes literals (regardless of the declared source code encoding). Any binary values over 127 must be entered into bytes literals using the appropriate escape sequence. As with string literals, bytes literals may also use a prefix to disable processing of escape sequences. See String and Bytes literals for more about the various forms of bytes literal, including supported escape sequences. While bytes literals and representations are based on ASCII text, bytes objects actually behave like immutable sequences of integers, with each value in the sequence restricted such that (attempts to violate this restriction will trigger ). This is done deliberately to emphasise that while many binary formats include ASCII based elements and can be usefully manipulated with some text-oriented algorithms, this is not generally the case for arbitrary binary data (blindly applying text processing algorithms to binary data formats that are not ASCII compatible will usually lead to data corruption). In addition to the literal forms, bytes objects can be created in a number of other ways:\n• None From an iterable of integers: Also see the bytes built-in. Since 2 hexadecimal digits correspond precisely to a single byte, hexadecimal numbers are a commonly used format for describing binary data. Accordingly, the bytes type has an additional class method to read data in that format: This class method returns a bytes object, decoding the given string object. The string must contain two hexadecimal digits per byte, with ASCII whitespace being ignored. A reverse conversion function exists to transform a bytes object into its hexadecimal representation. Return a string object containing two hexadecimal digits for each byte in the instance. Since bytes objects are sequences of integers (akin to a tuple), for a bytes object b, will be an integer, while will be a bytes object of length 1. (This contrasts with text strings, where both indexing and slicing will produce a string of length 1) The representation of bytes objects uses the literal format ( ) since it is often more useful than e.g. . You can always convert a bytes object into a list of integers using . For Python 2.x users: In the Python 2.x series, a variety of implicit conversions between 8-bit strings (the closest thing 2.x offers to a built-in binary data type) and Unicode strings were permitted. This was a backwards compatibility workaround to account for the fact that Python originally only supported 8-bit text, and Unicode text was a later addition. In Python 3.x, those implicit conversions are gone - conversions between 8-bit binary data and Unicode text must be explicit, and bytes and string objects will always compare unequal. There is no dedicated literal syntax for bytearray objects, instead they are always created by calling the constructor:\n• None From an iterable of integers: As bytearray objects are mutable, they support the mutable sequence operations in addition to the common bytes and bytearray operations described in Bytes and Bytearray Operations. Also see the bytearray built-in. Since 2 hexadecimal digits correspond precisely to a single byte, hexadecimal numbers are a commonly used format for describing binary data. Accordingly, the bytearray type has an additional class method to read data in that format: This class method returns bytearray object, decoding the given string object. The string must contain two hexadecimal digits per byte, with ASCII whitespace being ignored. A reverse conversion function exists to transform a bytearray object into its hexadecimal representation. Return a string object containing two hexadecimal digits for each byte in the instance. Since bytearray objects are sequences of integers (akin to a list), for a bytearray object b, will be an integer, while will be a bytearray object of length 1. (This contrasts with text strings, where both indexing and slicing will produce a string of length 1) The representation of bytearray objects uses the bytes literal format ( ) since it is often more useful than e.g. . You can always convert a bytearray object into a list of integers using . Both bytes and bytearray objects support the common sequence operations. They interoperate not just with operands of the same type, but with any bytes-like object. Due to this flexibility, they can be freely mixed in operations without causing errors. However, the return type of the result may depend on the order of operands. The methods on bytes and bytearray objects don’t accept strings as their arguments, just as the methods on strings don’t accept bytes as their arguments. For example, you have to write: Some bytes and bytearray operations assume the use of ASCII compatible binary formats, and hence should be avoided when working with arbitrary binary data. These restrictions are covered below. Using these ASCII based operations to manipulate binary data that is not stored in an ASCII based format may lead to data corruption. The following methods on bytes and bytearray objects can be used with arbitrary binary data. Return the number of non-overlapping occurrences of subsequence sub in the range [start, end]. Optional arguments start and end are interpreted as in slice notation. The subsequence to search for may be any bytes-like object or an integer in the range 0 to 255. Changed in version 3.3: Also accept an integer in the range 0 to 255 as the subsequence. Return a string decoded from the given bytes. Default encoding is . errors may be given to set a different error handling scheme. The default for errors is , meaning that encoding errors raise a . Other possible values are , and any other name registered via , see section Error Handlers. For a list of possible encodings, see section Standard Encodings. Passing the encoding argument to allows decoding any bytes-like object directly, without needing to make a temporary bytes or bytearray object. Return if the binary data ends with the specified suffix, otherwise return . suffix can also be a tuple of suffixes to look for. With optional start, test beginning at that position. With optional end, stop comparing at that position. The suffix(es) to search for may be any bytes-like object. Return the lowest index in the data where the subsequence sub is found, such that sub is contained in the slice . Optional arguments start and end are interpreted as in slice notation. Return if sub is not found. The subsequence to search for may be any bytes-like object or an integer in the range 0 to 255. The method should be used only if you need to know the position of sub. To check if sub is a substring or not, use the operator: Changed in version 3.3: Also accept an integer in the range 0 to 255 as the subsequence. Like , but raise when the subsequence is not found. The subsequence to search for may be any bytes-like object or an integer in the range 0 to 255. Changed in version 3.3: Also accept an integer in the range 0 to 255 as the subsequence. Return a bytes or bytearray object which is the concatenation of the binary data sequences in iterable. A will be raised if there are any values in iterable that are not bytes-like objects, including objects. The separator between elements is the contents of the bytes or bytearray object providing this method. This static method returns a translation table usable for that will map each character in from into the character at the same position in to; from and to must both be bytes-like objects and have the same length. Split the sequence at the first occurrence of sep, and return a 3-tuple containing the part before the separator, the separator itself or its bytearray copy, and the part after the separator. If the separator is not found, return a 3-tuple containing a copy of the original sequence, followed by two empty bytes or bytearray objects. The separator to search for may be any bytes-like object. Return a copy of the sequence with all occurrences of subsequence old replaced by new. If the optional argument count is given, only the first count occurrences are replaced. The subsequence to search for and its replacement may be any bytes-like object. The bytearray version of this method does not operate in place - it always produces a new object, even if no changes were made. Return the highest index in the sequence where the subsequence sub is found, such that sub is contained within . Optional arguments start and end are interpreted as in slice notation. Return on failure. The subsequence to search for may be any bytes-like object or an integer in the range 0 to 255. Changed in version 3.3: Also accept an integer in the range 0 to 255 as the subsequence. Like but raises when the subsequence sub is not found. The subsequence to search for may be any bytes-like object or an integer in the range 0 to 255. Changed in version 3.3: Also accept an integer in the range 0 to 255 as the subsequence. Split the sequence at the last occurrence of sep, and return a 3-tuple containing the part before the separator, the separator itself or its bytearray copy, and the part after the separator. If the separator is not found, return a 3-tuple containing a copy of the original sequence, followed by two empty bytes or bytearray objects. The separator to search for may be any bytes-like object. Return if the binary data starts with the specified prefix, otherwise return . prefix can also be a tuple of prefixes to look for. With optional start, test beginning at that position. With optional end, stop comparing at that position. The prefix(es) to search for may be any bytes-like object. Return a copy of the bytes or bytearray object where all bytes occurring in the optional argument delete are removed, and the remaining bytes have been mapped through the given translation table, which must be a bytes object of length 256. You can use the method to create a translation table. Set the table argument to for translations that only delete characters: Changed in version 3.6: delete is now supported as a keyword argument. The following methods on bytes and bytearray objects have default behaviours that assume the use of ASCII compatible binary formats, but can still be used with arbitrary binary data by passing appropriate arguments. Note that all of the bytearray methods in this section do not operate in place, and instead produce new objects. Return a copy of the object centered in a sequence of length width. Padding is done using the specified fillbyte (default is an ASCII space). For objects, the original sequence is returned if width is less than or equal to . The bytearray version of this method does not operate in place - it always produces a new object, even if no changes were made. Return a copy of the object left justified in a sequence of length width. Padding is done using the specified fillbyte (default is an ASCII space). For objects, the original sequence is returned if width is less than or equal to . The bytearray version of this method does not operate in place - it always produces a new object, even if no changes were made. Return a copy of the sequence with specified leading bytes removed. The chars argument is a binary sequence specifying the set of byte values to be removed - the name refers to the fact this method is usually used with ASCII characters. If omitted or , the chars argument defaults to removing ASCII whitespace. The chars argument is not a prefix; rather, all combinations of its values are stripped: The binary sequence of byte values to remove may be any bytes-like object. The bytearray version of this method does not operate in place - it always produces a new object, even if no changes were made. Return a copy of the object right justified in a sequence of length width. Padding is done using the specified fillbyte (default is an ASCII space). For objects, the original sequence is returned if width is less than or equal to . The bytearray version of this method does not operate in place - it always produces a new object, even if no changes were made. Split the binary sequence into subsequences of the same type, using sep as the delimiter string. If maxsplit is given, at most maxsplit splits are done, the rightmost ones. If sep is not specified or , any subsequence consisting solely of ASCII whitespace is a separator. Except for splitting from the right, behaves like which is described in detail below. Return a copy of the sequence with specified trailing bytes removed. The chars argument is a binary sequence specifying the set of byte values to be removed - the name refers to the fact this method is usually used with ASCII characters. If omitted or , the chars argument defaults to removing ASCII whitespace. The chars argument is not a suffix; rather, all combinations of its values are stripped: The binary sequence of byte values to remove may be any bytes-like object. The bytearray version of this method does not operate in place - it always produces a new object, even if no changes were made. Split the binary sequence into subsequences of the same type, using sep as the delimiter string. If maxsplit is given and non-negative, at most maxsplit splits are done (thus, the list will have at most elements). If maxsplit is not specified or is , then there is no limit on the number of splits (all possible splits are made). If sep is given, consecutive delimiters are not grouped together and are deemed to delimit empty subsequences (for example, returns ). The sep argument may consist of a multibyte sequence (for example, returns ). Splitting an empty sequence with a specified separator returns or depending on the type of object being split. The sep argument may be any bytes-like object. If sep is not specified or is , a different splitting algorithm is applied: runs of consecutive ASCII whitespace are regarded as a single separator, and the result will contain no empty strings at the start or end if the sequence has leading or trailing whitespace. Consequently, splitting an empty sequence or a sequence consisting solely of ASCII whitespace without a specified separator returns . Return a copy of the sequence with specified leading and trailing bytes removed. The chars argument is a binary sequence specifying the set of byte values to be removed - the name refers to the fact this method is usually used with ASCII characters. If omitted or , the chars argument defaults to removing ASCII whitespace. The chars argument is not a prefix or suffix; rather, all combinations of its values are stripped: The binary sequence of byte values to remove may be any bytes-like object. The bytearray version of this method does not operate in place - it always produces a new object, even if no changes were made. The following methods on bytes and bytearray objects assume the use of ASCII compatible binary formats and should not be applied to arbitrary binary data. Note that all of the bytearray methods in this section do not operate in place, and instead produce new objects. Return a copy of the sequence with each byte interpreted as an ASCII character, and the first byte capitalized and the rest lowercased. Non-ASCII byte values are passed through unchanged. The bytearray version of this method does not operate in place - it always produces a new object, even if no changes were made. Return a copy of the sequence where all ASCII tab characters are replaced by one or more ASCII spaces, depending on the current column and the given tab size. Tab positions occur every tabsize bytes (default is 8, giving tab positions at columns 0, 8, 16 and so on). To expand the sequence, the current column is set to zero and the sequence is examined byte by byte. If the byte is an ASCII tab character ( ), one or more space characters are inserted in the result until the current column is equal to the next tab position. (The tab character itself is not copied.) If the current byte is an ASCII newline ( ) or carriage return ( ), it is copied and the current column is reset to zero. Any other byte value is copied unchanged and the current column is incremented by one regardless of how the byte value is represented when printed: The bytearray version of this method does not operate in place - it always produces a new object, even if no changes were made. Return true if all bytes in the sequence are alphabetical ASCII characters or ASCII decimal digits and the sequence is not empty, false otherwise. Alphabetic ASCII characters are those byte values in the sequence . ASCII decimal digits are those byte values in the sequence . Return true if all bytes in the sequence are alphabetic ASCII characters and the sequence is not empty, false otherwise. Alphabetic ASCII characters are those byte values in the sequence . Return true if all bytes in the sequence are ASCII decimal digits and the sequence is not empty, false otherwise. ASCII decimal digits are those byte values in the sequence . Return true if there is at least one lowercase ASCII character in the sequence and no uppercase ASCII characters, false otherwise. Lowercase ASCII characters are those byte values in the sequence . Uppercase ASCII characters are those byte values in the sequence . Return true if all bytes in the sequence are ASCII whitespace and the sequence is not empty, false otherwise. ASCII whitespace characters are those byte values in the sequence (space, tab, newline, carriage return, vertical tab, form feed). Return true if the sequence is ASCII titlecase and the sequence is not empty, false otherwise. See for more details on the definition of “titlecase”. Return true if there is at least one uppercase alphabetic ASCII character in the sequence and no lowercase ASCII characters, false otherwise. Lowercase ASCII characters are those byte values in the sequence . Uppercase ASCII characters are those byte values in the sequence . Return a copy of the sequence with all the uppercase ASCII characters converted to their corresponding lowercase counterpart. Lowercase ASCII characters are those byte values in the sequence . Uppercase ASCII characters are those byte values in the sequence . The bytearray version of this method does not operate in place - it always produces a new object, even if no changes were made. Return a list of the lines in the binary sequence, breaking at ASCII line boundaries. This method uses the universal newlines approach to splitting lines. Line breaks are not included in the resulting list unless keepends is given and true. Unlike when a delimiter string sep is given, this method returns an empty list for the empty string, and a terminal line break does not result in an extra line: Return a copy of the sequence with all the lowercase ASCII characters converted to their corresponding uppercase counterpart and vice-versa. Lowercase ASCII characters are those byte values in the sequence . Uppercase ASCII characters are those byte values in the sequence . Unlike , it is always the case that for the binary versions. Case conversions are symmetrical in ASCII, even though that is not generally true for arbitrary Unicode code points. The bytearray version of this method does not operate in place - it always produces a new object, even if no changes were made. Return a titlecased version of the binary sequence where words start with an uppercase ASCII character and the remaining characters are lowercase. Uncased byte values are left unmodified. Lowercase ASCII characters are those byte values in the sequence . Uppercase ASCII characters are those byte values in the sequence . All other byte values are uncased. The algorithm uses a simple language-independent definition of a word as groups of consecutive letters. The definition works in many contexts but it means that apostrophes in contractions and possessives form word boundaries, which may not be the desired result: A workaround for apostrophes can be constructed using regular expressions: The bytearray version of this method does not operate in place - it always produces a new object, even if no changes were made. Return a copy of the sequence with all the lowercase ASCII characters converted to their corresponding uppercase counterpart. Lowercase ASCII characters are those byte values in the sequence . Uppercase ASCII characters are those byte values in the sequence . The bytearray version of this method does not operate in place - it always produces a new object, even if no changes were made. Return a copy of the sequence left filled with ASCII digits to make a sequence of length width. A leading sign prefix ( / ) is handled by inserting the padding after the sign character rather than before. For objects, the original sequence is returned if width is less than or equal to . The bytearray version of this method does not operate in place - it always produces a new object, even if no changes were made. The formatting operations described here exhibit a variety of quirks that lead to a number of common errors (such as failing to display tuples and dictionaries correctly). If the value being printed may be a tuple or dictionary, wrap it in a tuple. Bytes objects ( / ) have one unique built-in operation: the operator (modulo). This is also known as the bytes formatting or interpolation operator. Given (where format is a bytes object), conversion specifications in format are replaced with zero or more elements of values. The effect is similar to using the in the C language. If format requires a single argument, values may be a single non-tuple object. Otherwise, values must be a tuple with exactly the number of items specified by the format bytes object, or a single mapping object (for example, a dictionary). A conversion specifier contains two or more characters and has the following components, which must occur in this order:\n• None The character, which marks the start of the specifier.\n• None Mapping key (optional), consisting of a parenthesised sequence of characters (for example, ).\n• None Conversion flags (optional), which affect the result of some conversion types.\n• None Minimum field width (optional). If specified as an (asterisk), the actual width is read from the next element of the tuple in values, and the object to convert comes after the minimum field width and optional precision.\n• None Precision (optional), given as a (dot) followed by the precision. If specified as (an asterisk), the actual precision is read from the next element of the tuple in values, and the value to convert comes after the precision. When the right argument is a dictionary (or other mapping type), then the formats in the bytes object must include a parenthesised mapping key into that dictionary inserted immediately after the character. The mapping key selects the value to be formatted from the mapping. For example: In this case no specifiers may occur in a format (since they require a sequential parameter list). The value conversion will use the “alternate form” (where defined below). The conversion will be zero padded for numeric values. The converted value is left adjusted (overrides the conversion if both are given). (a space) A blank should be left before a positive number (or empty string) produced by a signed conversion. A sign character ( or ) will precede the conversion (overrides a “space” flag). A length modifier ( , , or ) may be present, but is ignored as it is not necessary for Python – so e.g. is identical to . Obsolete type – it is identical to . Floating point format. Uses lowercase exponential format if exponent is less than -4 or not less than precision, decimal format otherwise. Floating point format. Uses uppercase exponential format if exponent is less than -4 or not less than precision, decimal format otherwise. Bytes (any object that follows the buffer protocol or has ). is an alias for and should only be used for Python2/3 code bases. is an alias for and should only be used for Python2/3 code bases. No argument is converted, results in a character in the result.\n• None The alternate form causes a leading octal specifier ( ) to be inserted before the first digit.\n• None The alternate form causes a leading or (depending on whether the or format was used) to be inserted before the first digit.\n• None The alternate form causes the result to always contain a decimal point, even if no digits follow it. The precision determines the number of digits after the decimal point and defaults to 6.\n• None The alternate form causes the result to always contain a decimal point, and trailing zeroes are not removed as they would otherwise be. The precision determines the number of significant digits before and after the decimal point and defaults to 6.\n• None If precision is , the output is truncated to characters.\n• None is deprecated, but will not be removed during the 3.x series.\n• None is deprecated, but will not be removed during the 3.x series. The bytearray version of this method does not operate in place - it always produces a new object, even if no changes were made. objects allow Python code to access the internal data of an object that supports the buffer protocol without copying. Create a that references obj. obj must support the buffer protocol. Built-in objects that support the buffer protocol include and . A has the notion of an element, which is the atomic memory unit handled by the originating object obj. For many simple types such as and , an element is a single byte, but other types such as may have bigger elements. is equal to the length of . If , the length is 1. If , the length is equal to the number of elements in the view. For higher dimensions, the length is equal to the length of the nested list representation of the view. The attribute will give you the number of bytes in a single element. A supports slicing and indexing to expose its data. One-dimensional slicing will result in a subview: If is one of the native format specifiers from the module, indexing with an integer or a tuple of integers is also supported and returns a single element with the correct type. One-dimensional memoryviews can be indexed with an integer or a one-integer tuple. Multi-dimensional memoryviews can be indexed with tuples of exactly ndim integers where ndim is the number of dimensions. Zero-dimensional memoryviews can be indexed with the empty tuple. Here is an example with a non-byte format: If the underlying object is writable, the memoryview supports one-dimensional slice assignment. Resizing is not allowed: File , line , in : memoryview assignment: lvalue and rvalue have different structures One-dimensional memoryviews of hashable (read-only) types with formats ‘B’, ‘b’ or ‘c’ are also hashable. The hash is defined as : Changed in version 3.3: One-dimensional memoryviews can now be sliced. One-dimensional memoryviews with formats ‘B’, ‘b’ or ‘c’ are now hashable. Changed in version 3.4: memoryview is now registered automatically with Changed in version 3.5: memoryviews can now be indexed with tuple of integers. A memoryview and a PEP 3118 exporter are equal if their shapes are equivalent and if all corresponding values are equal when the operands’ respective format codes are interpreted using syntax. For the subset of format strings currently supported by , and are equal if : If either format string is not supported by the module, then the objects will always compare as unequal (even if the format strings and buffer contents are identical): Note that, as with floating point numbers, does not imply for memoryview objects. Changed in version 3.3: Previous versions compared the raw memory disregarding the item format and the logical array structure. Return the data in the buffer as a bytestring. This is equivalent to calling the constructor on the memoryview. For non-contiguous arrays the result is equal to the flattened list representation with all elements converted to bytes. supports all format strings, including those that are not in module syntax. Return a string object containing two hexadecimal digits for each byte in the buffer. Return the data in the buffer as a list of elements. Changed in version 3.3: now supports all single character native formats in module syntax as well as multi-dimensional representations. Release the underlying buffer exposed by the memoryview object. Many objects take special actions when a view is held on them (for example, a would temporarily forbid resizing); therefore, calling release() is handy to remove these restrictions (and free any dangling resources) as soon as possible. After this method has been called, any further operation on the view raises a (except itself which can be called multiple times): The context management protocol can be used for a similar effect, using the statement: Cast a memoryview to a new format or shape. shape defaults to , which means that the result view will be one-dimensional. The return value is a new memoryview, but the buffer itself is not copied. Supported casts are 1D -> C-contiguous and C-contiguous -> 1D. The destination format is restricted to a single element native format in syntax. One of the formats must be a byte format (‘B’, ‘b’ or ‘c’). The byte length of the result must be the same as the original length. Changed in version 3.5: The source format is no longer restricted when casting to a byte view. There are also several readonly attributes available: The underlying object of the memoryview: . This is the amount of space in bytes that the array would use in a contiguous representation. It is not necessarily equal to : A bool indicating whether the memory is read only. A string containing the format (in module style) for each element in the view. A memoryview can be created from exporters with arbitrary format strings, but some methods (e.g. ) are restricted to native single element formats. Changed in version 3.3: format is now handled according to the struct module syntax. This means that . The size in bytes of each element of the memoryview: An integer indicating how many dimensions of a multi-dimensional array the memory represents. A tuple of integers the length of giving the shape of the memory as an N-dimensional array. Changed in version 3.3: An empty tuple instead of when ndim = 0. A tuple of integers the length of giving the size in bytes to access each element for each dimension of the array. Changed in version 3.3: An empty tuple instead of when ndim = 0. Used internally for PIL-style arrays. The value is informational only. A bool indicating whether the memory is C-contiguous. A bool indicating whether the memory is Fortran contiguous. A bool indicating whether the memory is contiguous.\n\nA mapping object maps hashable values to arbitrary objects. Mappings are mutable objects. There is currently only one standard mapping type, the dictionary. (For other containers see the built-in , , and classes, and the module.) A dictionary’s keys are almost arbitrary values. Values that are not hashable, that is, values containing lists, dictionaries or other mutable types (that are compared by value rather than by object identity) may not be used as keys. Numeric types used for keys obey the normal rules for numeric comparison: if two numbers compare equal (such as and ) then they can be used interchangeably to index the same dictionary entry. (Note however, that since computers store floating-point numbers as approximations it is usually unwise to use them as dictionary keys.) Dictionaries can be created by placing a comma-separated list of pairs within braces, for example: or , or by the constructor. Return a new dictionary initialized from an optional positional argument and a possibly empty set of keyword arguments. If no positional argument is given, an empty dictionary is created. If a positional argument is given and it is a mapping object, a dictionary is created with the same key-value pairs as the mapping object. Otherwise, the positional argument must be an iterable object. Each item in the iterable must itself be an iterable with exactly two objects. The first object of each item becomes a key in the new dictionary, and the second object the corresponding value. If a key occurs more than once, the last value for that key becomes the corresponding value in the new dictionary. If keyword arguments are given, the keyword arguments and their values are added to the dictionary created from the positional argument. If a key being added is already present, the value from the keyword argument replaces the value from the positional argument. To illustrate, the following examples all return a dictionary equal to {\"one\": 1, \"two\": 2, \"three\": 3} : Providing keyword arguments as in the first example only works for keys that are valid Python identifiers. Otherwise, any valid keys can be used. These are the operations that dictionaries support (and therefore, custom mapping types should support too): Return the number of items in the dictionary d. Return the item of d with key key. Raises a if key is not in the map. If a subclass of dict defines a method and key is not present, the operation calls that method with the key key as argument. The operation then returns or raises whatever is returned or raised by the call. No other operations or methods invoke . If is not defined, is raised. must be a method; it cannot be an instance variable: The example above shows part of the implementation of . A different method is used by . Remove from d. Raises a if key is not in the map. Return if d has a key key, else . Return an iterator over the keys of the dictionary. This is a shortcut for . Remove all items from the dictionary. Create a new dictionary with keys from seq and values set to value. is a class method that returns a new dictionary. value defaults to . Return the value for key if key is in the dictionary, else default. If default is not given, it defaults to , so that this method never raises a . Return a new view of the dictionary’s items ( pairs). See the documentation of view objects. Return a new view of the dictionary’s keys. See the documentation of view objects. If key is in the dictionary, remove it and return its value, else return default. If default is not given and key is not in the dictionary, a is raised. Remove and return an arbitrary pair from the dictionary. is useful to destructively iterate over a dictionary, as often used in set algorithms. If the dictionary is empty, calling raises a . If key is in the dictionary, return its value. If not, insert key with a value of default and return default. default defaults to . Update the dictionary with the key/value pairs from other, overwriting existing keys. Return . accepts either another dictionary object or an iterable of key/value pairs (as tuples or other iterables of length two). If keyword arguments are specified, the dictionary is then updated with those key/value pairs: . Return a new view of the dictionary’s values. See the documentation of view objects. Dictionaries compare equal if and only if they have the same pairs. Order comparisons (‘<’, ‘<=’, ‘>=’, ‘>’) raise . can be used to create a read-only view of a . The objects returned by , and are view objects. They provide a dynamic view on the dictionary’s entries, which means that when the dictionary changes, the view reflects these changes. Dictionary views can be iterated over to yield their respective data, and support membership tests: Return the number of entries in the dictionary. Return an iterator over the keys, values or items (represented as tuples of ) in the dictionary. Keys and values are iterated over in an arbitrary order which is non-random, varies across Python implementations, and depends on the dictionary’s history of insertions and deletions. If keys, values and items views are iterated over with no intervening modifications to the dictionary, the order of items will directly correspond. This allows the creation of pairs using : . Another way to create the same list is . Iterating views while adding or deleting entries in the dictionary may raise a or fail to iterate over all entries. Return if x is in the underlying dictionary’s keys, values or items (in the latter case, x should be a tuple). Keys views are set-like since their entries are unique and hashable. If all values are hashable, so that pairs are unique and hashable, then the items view is also set-like. (Values views are not treated as set-like since the entries are generally not unique.) For set-like views, all of the operations defined for the abstract base class are available (for example, , , or ). An example of dictionary view usage: # keys and values are iterated over in the same order # view objects are dynamic and reflect dict changes\n\nThe interpreter supports several other kinds of objects. Most of these support only one or two operations. The only special operation on a module is attribute access: , where m is a module and name accesses a name defined in m’s symbol table. Module attributes can be assigned to. (Note that the statement is not, strictly speaking, an operation on a module object; does not require a module object named foo to exist, rather it requires an (external) definition for a module named foo somewhere.) A special attribute of every module is . This is the dictionary containing the module’s symbol table. Modifying this dictionary will actually change the module’s symbol table, but direct assignment to the attribute is not possible (you can write , which defines to be , but you can’t write ). Modifying directly is not recommended. Modules built into the interpreter are written like this: . If loaded from a file, they are written as . See Objects, values and types and Class definitions for these. Function objects are created by function definitions. The only operation on a function object is to call it: . There are really two flavors of function objects: built-in functions and user-defined functions. Both support the same operation (to call the function), but the implementation is different, hence the different object types. See Function definitions for more information. Methods are functions that are called using the attribute notation. There are two flavors: built-in methods (such as on lists) and class instance methods. Built-in methods are described with the types that support them. If you access a method (a function defined in a class namespace) through an instance, you get a special object: a bound method (also called instance method) object. When called, it will add the argument to the argument list. Bound methods have two special read-only attributes: is the object on which the method operates, and is the function implementing the method. Calling is completely equivalent to calling . Like function objects, bound method objects support getting arbitrary attributes. However, since method attributes are actually stored on the underlying function object ( ), setting method attributes on bound methods is disallowed. Attempting to set an attribute on a method results in an being raised. In order to set a method attribute, you need to explicitly set it on the underlying function object: # can't set on the method File , line , in : See The standard type hierarchy for more information. Code objects are used by the implementation to represent “pseudo-compiled” executable Python code such as a function body. They differ from function objects because they don’t contain a reference to their global execution environment. Code objects are returned by the built-in function and can be extracted from function objects through their attribute. See also the module. A code object can be executed or evaluated by passing it (instead of a source string) to the or built-in functions. See The standard type hierarchy for more information. Type objects represent the various object types. An object’s type is accessed by the built-in function . There are no special operations on types. The standard module defines names for all standard built-in types. Types are written like this: . This object is returned by functions that don’t explicitly return a value. It supports no special operations. There is exactly one null object, named (a built-in name). produces the same singleton. This object is commonly used by slicing (see Slicings). It supports no special operations. There is exactly one ellipsis object, named (a built-in name). produces the singleton. It is written as or . This object is returned from comparisons and binary operations when they are asked to operate on types they don’t support. See Comparisons for more information. There is exactly one object. produces the singleton instance. It is written as . Boolean values are the two constant objects and . They are used to represent truth values (although other values can also be considered false or true). In numeric contexts (for example when used as the argument to an arithmetic operator), they behave like the integers 0 and 1, respectively. The built-in function can be used to convert any value to a Boolean, if the value can be interpreted as a truth value (see section Truth Value Testing above). They are written as and , respectively. See The standard type hierarchy for this information. It describes stack frame objects, traceback objects, and slice objects."
    },
    {
        "link": "https://docs.python.org/3/library/stdtypes.html",
        "document": "The following sections describe the standard types that are built into the interpreter.\n\nThe principal built-in types are numerics, sequences, mappings, classes, instances and exceptions.\n\nSome collection classes are mutable. The methods that add, subtract, or rearrange their members in place, and don’t return a specific item, never return the collection instance itself but .\n\nSome operations are supported by several object types; in particular, practically all objects can be compared for equality, tested for truth value, and converted to a string (with the function or the slightly different function). The latter function is implicitly used when an object is written by the function.\n\nThere are three distinct numeric types: integers, floating-point numbers, and complex numbers. In addition, Booleans are a subtype of integers. Integers have unlimited precision. Floating-point numbers are usually implemented using double in C; information about the precision and internal representation of floating-point numbers for the machine on which your program is running is available in . Complex numbers have a real and imaginary part, which are each a floating-point number. To extract these parts from a complex number z, use and . (The standard library includes the additional numeric types , for rationals, and , for floating-point numbers with user-definable precision.) Numbers are created by numeric literals or as the result of built-in functions and operators. Unadorned integer literals (including hex, octal and binary numbers) yield integers. Numeric literals containing a decimal point or an exponent sign yield floating-point numbers. Appending or to a numeric literal yields an imaginary number (a complex number with a zero real part) which you can add to an integer or float to get a complex number with real and imaginary parts. Python fully supports mixed arithmetic: when a binary arithmetic operator has operands of different numeric types, the operand with the “narrower” type is widened to that of the other, where integer is narrower than floating point, which is narrower than complex. A comparison between numbers of different types behaves as though the exact values of those numbers were being compared. The constructors , , and can be used to produce numbers of a specific type. All numeric types (except complex) support the following operations (for priorities of the operations, see Operator precedence): absolute value or magnitude of x a complex number with real part re, imaginary part im. im defaults to zero. conjugate of the complex number c\n• None Also referred to as integer division. For operands of type , the result has type . For operands of type , the result has type . In general, the result is a whole integer, though the result’s type is not necessarily . The result is always rounded towards minus infinity: is , is , is , and is .\n• None Not for complex numbers. Instead convert to floats using if appropriate.\n• None Conversion from to truncates, discarding the fractional part. See functions and for alternative conversions.\n• None float also accepts the strings “nan” and “inf” with an optional prefix “+” or “-” for Not a Number (NaN) and positive or negative infinity.\n• None Python defines and to be , as is common for programming languages.\n• None The numeric literals accepted include the digits to or any Unicode equivalent (code points with the property). See the Unicode Standard for a complete list of code points with the property. All types ( and ) also include the following operations: x rounded to n digits, rounding half to even. If n is omitted, it defaults to 0. For additional numeric operations see the and modules. Bitwise operations only make sense for integers. The result of bitwise operations is calculated as though carried out in two’s complement with an infinite number of sign bits. The priorities of the binary bitwise operations are all lower than the numeric operations and higher than the comparisons; the unary operation has the same priority as the other unary numeric operations ( and ). This table lists the bitwise operations sorted in ascending priority: bitwise exclusive or of x and y\n• None Negative shift counts are illegal and cause a to be raised.\n• None A left shift by n bits is equivalent to multiplication by .\n• None A right shift by n bits is equivalent to floor division by .\n• None Performing these calculations with at least one extra sign extension bit in a finite two’s complement representation (a working bit-width of or more) is sufficient to get the same result as if there were an infinite number of sign bits. The int type implements the abstract base class. In addition, it provides a few more methods: Return the number of bits necessary to represent an integer in binary, excluding the sign and leading zeros: More precisely, if is nonzero, then is the unique positive integer such that . Equivalently, when is small enough to have a correctly rounded logarithm, then . If is zero, then returns . Return the number of ones in the binary representation of the absolute value of the integer. This is also known as the population count. Example: Return an array of bytes representing an integer. The integer is represented using length bytes, and defaults to 1. An is raised if the integer is not representable with the given number of bytes. The byteorder argument determines the byte order used to represent the integer, and defaults to . If byteorder is , the most significant byte is at the beginning of the byte array. If byteorder is , the most significant byte is at the end of the byte array. The signed argument determines whether two’s complement is used to represent the integer. If signed is and a negative integer is given, an is raised. The default value for signed is . The default values can be used to conveniently turn an integer into a single byte object: However, when using the default arguments, don’t try to convert a value greater than 255 or you’ll get an . \"byteorder must be either 'little' or 'big'\" Changed in version 3.11: Added default argument values for and . Return the integer represented by the given array of bytes. The argument bytes must either be a bytes-like object or an iterable producing bytes. The byteorder argument determines the byte order used to represent the integer, and defaults to . If byteorder is , the most significant byte is at the beginning of the byte array. If byteorder is , the most significant byte is at the end of the byte array. To request the native byte order of the host system, use as the byte order value. The signed argument indicates whether two’s complement is used to represent the integer. \"byteorder must be either 'little' or 'big'\" Changed in version 3.11: Added default argument value for . Return a pair of integers whose ratio is equal to the original integer and has a positive denominator. The integer ratio of integers (whole numbers) is always the integer as the numerator and as the denominator. The float type implements the abstract base class. float also has the following additional methods. Return a pair of integers whose ratio is exactly equal to the original float. The ratio is in lowest terms and has a positive denominator. Raises on infinities and a on NaNs. Return if the float instance is finite with integral value, and otherwise: Two methods support conversion to and from hexadecimal strings. Since Python’s floats are stored internally as binary numbers, converting a float to or from a decimal string usually involves a small rounding error. In contrast, hexadecimal strings allow exact representation and specification of floating-point numbers. This can be useful when debugging, and in numerical work. Return a representation of a floating-point number as a hexadecimal string. For finite floating-point numbers, this representation will always include a leading and a trailing and exponent. Class method to return the float represented by a hexadecimal string s. The string s may have leading and trailing whitespace. Note that is an instance method, while is a class method. where the optional may by either or , and are strings of hexadecimal digits, and is a decimal integer with an optional leading sign. Case is not significant, and there must be at least one hexadecimal digit in either the integer or the fraction. This syntax is similar to the syntax specified in section 6.4.4.2 of the C99 standard, and also to the syntax used in Java 1.5 onwards. In particular, the output of is usable as a hexadecimal floating-point literal in C or Java code, and hexadecimal strings produced by C’s format character or Java’s are accepted by . Note that the exponent is written in decimal rather than hexadecimal, and that it gives the power of 2 by which to multiply the coefficient. For example, the hexadecimal string represents the floating-point number , or : Applying the reverse conversion to gives a different hexadecimal string representing the same number: For numbers and , possibly of different types, it’s a requirement that whenever (see the method documentation for more details). For ease of implementation and efficiency across a variety of numeric types (including , , and ) Python’s hash for numeric types is based on a single mathematical function that’s defined for any rational number, and hence applies to all instances of and , and all finite instances of and . Essentially, this function is given by reduction modulo for a fixed prime . The value of is made available to Python as the attribute of . CPython implementation detail: Currently, the prime used is on machines with 32-bit C longs and on machines with 64-bit C longs. Here are the rules in detail:\n• None If is a nonnegative rational number and is not divisible by , define as , where gives the inverse of modulo .\n• None If is a nonnegative rational number and is divisible by (but is not) then has no inverse modulo and the rule above doesn’t apply; in this case define to be the constant value .\n• None If is a negative rational number define as . If the resulting hash is , replace it with .\n• None The particular values and are used as hash values for positive infinity or negative infinity (respectively).\n• None For a number , the hash values of the real and imaginary parts are combined by computing , reduced modulo so that it lies in . Again, if the result is , it’s replaced with . To clarify the above rules, here’s some example Python code, equivalent to the built-in hash, for computing the hash of a rational number, , or : Assumes m and n are integers, with n positive. # Remove common factors of P. (Unnecessary if m and n already coprime.) # Fermat's Little Theorem: pow(n, P-1, P) is 1, so # pow(n, P-2, P) gives the inverse of n modulo P.\n\nThere are three basic sequence types: lists, tuples, and range objects. Additional sequence types tailored for processing of binary data and text strings are described in dedicated sections. The operations in the following table are supported by most sequence types, both mutable and immutable. The ABC is provided to make it easier to correctly implement these operations on custom sequence types. This table lists the sequence operations sorted in ascending priority. In the table, s and t are sequences of the same type, n, i, j and k are integers and x is an arbitrary object that meets any type and value restrictions imposed by s. The and operations have the same priorities as the comparison operations. The (concatenation) and (repetition) operations have the same priority as the corresponding numeric operations. if an item of s is equal to x, else if an item of s is equal to x, else the concatenation of s and t equivalent to adding s to itself n times slice of s from i to j with step k index of the first occurrence of x in s (at or after index i and before index j) total number of occurrences of x in s Sequences of the same type also support comparisons. In particular, tuples and lists are compared lexicographically by comparing corresponding elements. This means that to compare equal, every element must compare equal and the two sequences must be of the same type and have the same length. (For full details see Comparisons in the language reference.) Forward and reversed iterators over mutable sequences access values using an index. That index will continue to march forward (or backward) even if the underlying sequence is mutated. The iterator terminates only when an or a is encountered (or when the index drops below zero).\n• None While the and operations are used only for simple containment testing in the general case, some specialised sequences (such as , and ) also use them for subsequence testing:\n• None Values of n less than are treated as (which yields an empty sequence of the same type as s). Note that items in the sequence s are not copied; they are referenced multiple times. This often haunts new Python programmers; consider: What has happened is that is a one-element list containing an empty list, so all three elements of are references to this single empty list. Modifying any of the elements of modifies this single list. You can create a list of different lists this way: Further explanation is available in the FAQ entry How do I create a multidimensional list?.\n• None If i or j is negative, the index is relative to the end of sequence s: or is substituted. But note that is still .\n• None The slice of s from i to j is defined as the sequence of items with index k such that . If i or j is greater than , use . If i is omitted or , use . If j is omitted or , use . If i is greater than or equal to j, the slice is empty.\n• None The slice of s from i to j with step k is defined as the sequence of items with index such that . In other words, the indices are , , , and so on, stopping when j is reached (but never including j). When k is positive, i and j are reduced to if they are greater. When k is negative, i and j are reduced to if they are greater. If i or j are omitted or , they become “end” values (which end depends on the sign of k). Note, k cannot be zero. If k is , it is treated like .\n• None Concatenating immutable sequences always results in a new object. This means that building up a sequence by repeated concatenation will have a quadratic runtime cost in the total sequence length. To get a linear runtime cost, you must switch to one of the alternatives below:\n• None if concatenating objects, you can build a list and use at the end or else write to an instance and retrieve its value when complete\n• None if concatenating objects, you can similarly use or , or you can do in-place concatenation with a object. objects are mutable and have an efficient overallocation mechanism\n• None for other types, investigate the relevant class documentation\n• None Some sequence types (such as ) only support item sequences that follow specific patterns, and hence don’t support sequence concatenation or repetition.\n• None raises when x is not found in s. Not all implementations support passing the additional arguments i and j. These arguments allow efficient searching of subsections of the sequence. Passing the extra arguments is roughly equivalent to using , only without copying any data and with the returned index being relative to the start of the sequence rather than the start of the slice. The only operation that immutable sequence types generally implement that is not also implemented by mutable sequence types is support for the built-in. This support allows immutable sequences, such as instances, to be used as keys and stored in and instances. Attempting to hash an immutable sequence that contains unhashable values will result in . The operations in the following table are defined on mutable sequence types. The ABC is provided to make it easier to correctly implement these operations on custom sequence types. In the table s is an instance of a mutable sequence type, t is any iterable object and x is an arbitrary object that meets any type and value restrictions imposed by s (for example, only accepts integers that meet the value restriction ). item i of s is replaced by x slice of s from i to j is replaced by the contents of the iterable t the elements of are replaced by those of t removes the elements of from the list appends x to the end of the sequence (same as ) removes all items from s (same as ) creates a shallow copy of s (same as ) extends s with the contents of t (for the most part the same as ) inserts x into s at the index given by i (same as ) retrieves the item at i and also removes it from s removes the first item from s where is equal to x reverses the items of s in place\n• None If k is not equal to , t must have the same length as the slice it is replacing.\n• None The optional argument i defaults to , so that by default the last item is removed and returned.\n• None raises when x is not found in s.\n• None The method modifies the sequence in place for economy of space when reversing a large sequence. To remind users that it operates by side effect, it does not return the reversed sequence.\n• None and are included for consistency with the interfaces of mutable containers that don’t support slicing operations (such as and ). is not part of the ABC, but most concrete mutable sequence classes provide it.\n• None The value n is an integer, or an object implementing . Zero and negative values of n clear the sequence. Items in the sequence are not copied; they are referenced multiple times, as explained for under Common Sequence Operations. Lists are mutable sequences, typically used to store collections of homogeneous items (where the precise degree of similarity will vary by application). Lists may be constructed in several ways:\n• None Using a pair of square brackets to denote the empty list:\n• None Using the type constructor: or The constructor builds a list whose items are the same and in the same order as iterable’s items. iterable may be either a sequence, a container that supports iteration, or an iterator object. If iterable is already a list, a copy is made and returned, similar to . For example, returns and returns . If no argument is given, the constructor creates a new empty list, . Many other operations also produce lists, including the built-in. Lists implement all of the common and mutable sequence operations. Lists also provide the following additional method: This method sorts the list in place, using only comparisons between items. Exceptions are not suppressed - if any comparison operations fail, the entire sort operation will fail (and the list will likely be left in a partially modified state). accepts two arguments that can only be passed by keyword (keyword-only arguments): key specifies a function of one argument that is used to extract a comparison key from each list element (for example, ). The key corresponding to each item in the list is calculated once and then used for the entire sorting process. The default value of means that list items are sorted directly without calculating a separate key value. The utility is available to convert a 2.x style cmp function to a key function. reverse is a boolean value. If set to , then the list elements are sorted as if each comparison were reversed. This method modifies the sequence in place for economy of space when sorting a large sequence. To remind users that it operates by side effect, it does not return the sorted sequence (use to explicitly request a new sorted list instance). The method is guaranteed to be stable. A sort is stable if it guarantees not to change the relative order of elements that compare equal — this is helpful for sorting in multiple passes (for example, sort by department, then by salary grade). For sorting examples and a brief sorting tutorial, see Sorting Techniques. CPython implementation detail: While a list is being sorted, the effect of attempting to mutate, or even inspect, the list is undefined. The C implementation of Python makes the list appear empty for the duration, and raises if it can detect that the list has been mutated during a sort. Tuples are immutable sequences, typically used to store collections of heterogeneous data (such as the 2-tuples produced by the built-in). Tuples are also used for cases where an immutable sequence of homogeneous data is needed (such as allowing storage in a or instance). Tuples may be constructed in a number of ways:\n• None Using a pair of parentheses to denote the empty tuple:\n• None Using a trailing comma for a singleton tuple: or\n• None Using the built-in: or The constructor builds a tuple whose items are the same and in the same order as iterable’s items. iterable may be either a sequence, a container that supports iteration, or an iterator object. If iterable is already a tuple, it is returned unchanged. For example, returns and returns . If no argument is given, the constructor creates a new empty tuple, . Note that it is actually the comma which makes a tuple, not the parentheses. The parentheses are optional, except in the empty tuple case, or when they are needed to avoid syntactic ambiguity. For example, is a function call with three arguments, while is a function call with a 3-tuple as the sole argument. Tuples implement all of the common sequence operations. For heterogeneous collections of data where access by name is clearer than access by index, may be a more appropriate choice than a simple tuple object. The type represents an immutable sequence of numbers and is commonly used for looping a specific number of times in loops. The arguments to the range constructor must be integers (either built-in or any object that implements the special method). If the step argument is omitted, it defaults to . If the start argument is omitted, it defaults to . If step is zero, is raised. For a positive step, the contents of a range are determined by the formula where and . For a negative step, the contents of the range are still determined by the formula , but the constraints are and . A range object will be empty if does not meet the value constraint. Ranges do support negative indices, but these are interpreted as indexing from the end of the sequence determined by the positive indices. Ranges containing absolute values larger than are permitted but some features (such as ) may raise . Ranges implement all of the common sequence operations except concatenation and repetition (due to the fact that range objects can only represent sequences that follow a strict pattern and repetition and concatenation will usually violate that pattern). The value of the start parameter (or if the parameter was not supplied) The value of the stop parameter The value of the step parameter (or if the parameter was not supplied) The advantage of the type over a regular or is that a object will always take the same (small) amount of memory, no matter the size of the range it represents (as it only stores the , and values, calculating individual items and subranges as needed). Range objects implement the ABC, and provide features such as containment tests, element index lookup, slicing and support for negative indices (see Sequence Types — list, tuple, range): Testing range objects for equality with and compares them as sequences. That is, two range objects are considered equal if they represent the same sequence of values. (Note that two range objects that compare equal might have different , and attributes, for example or .) Changed in version 3.2: Implement the Sequence ABC. Support slicing and negative indices. Test objects for membership in constant time instead of iterating through all items. Changed in version 3.3: Define ‘==’ and ‘!=’ to compare range objects based on the sequence of values they define (instead of comparing based on object identity).\n• None The linspace recipe shows how to implement a lazy version of range suitable for floating-point applications."
    },
    {
        "link": "https://geeksforgeeks.org/python-program-split-join-string",
        "document": "In Python, we can use the function split() to split a string and join() to join a string. These functions allow us to easily break a string into smaller parts and then reassemble those parts into a new string. This article will explore ways to split and join a string.\n\nSplit the string into a list of strings\n\nSplitting a string can be quite useful sometimes, especially when we need only certain parts of strings. We can do this by using below mentioned methods.\n\nsplit() method splits a string into a list of substrings based on a specified delimiter (by default, it splits by whitespace).\n\nThe splitlines() method splits the string at line breaks and returns a list of lines. This is useful while using multiple strings.\n\nJoin the list of strings into a string\n\nAfter splitting a string into smaller parts, we might want to join those parts back together. This is commonly done with a delimiter between the parts.\n\nThe most common and efficient way to join a list of strings with a delimiter is using the join() method. This method is available for strings and allows we to specify the delimiter we want to use between elements.\n\nUsing for loop [Less Efficient]\n\nAlthough less efficient, we can manually join the strings in a list using a for loop. This method allows we to apply more complex transformations during the joining process."
    },
    {
        "link": "https://docs.python.org/3/tutorial/inputoutput.html",
        "document": "There are several ways to present the output of a program; data can be printed in a human-readable form, or written to a file for future use. This chapter will discuss some of the possibilities.\n\nSo far we’ve encountered two ways of writing values: expression statements and the function. (A third way is using the method of file objects; the standard output file can be referenced as . See the Library Reference for more information on this.) Often you’ll want more control over the formatting of your output than simply printing space-separated values. There are several ways to format output.\n• None To use formatted string literals, begin a string with or before the opening quotation mark or triple quotation mark. Inside this string, you can write a Python expression between and characters that can refer to variables or literal values.\n• None The method of strings requires more manual effort. You’ll still use and to mark where a variable will be substituted and can provide detailed formatting directives, but you’ll also need to provide the information to be formatted. In the following code block there are two examples of how to format variables: Notice how the are padded with spaces and a negative sign only for negative numbers. The example also prints multiplied by 100, with 2 decimal places and followed by a percent sign (see Format Specification Mini-Language for details).\n• None Finally, you can do all the string handling yourself by using string slicing and concatenation operations to create any layout you can imagine. The string type has some methods that perform useful operations for padding strings to a given column width. When you don’t need fancy output but just want a quick display of some variables for debugging purposes, you can convert any value to a string with the or functions. The function is meant to return representations of values which are fairly human-readable, while is meant to generate representations which can be read by the interpreter (or will force a if there is no equivalent syntax). For objects which don’t have a particular representation for human consumption, will return the same value as . Many values, such as numbers or structures like lists and dictionaries, have the same representation using either function. Strings, in particular, have two distinct representations. The value of x is 32.5, and y is 40000... # The repr() of a string adds string quotes and backslashes: # The argument to repr() may be any Python object: The module contains a class that offers yet another way to substitute values into strings, using placeholders like and replacing them with values from a dictionary, but offers much less control of the formatting. Formatted string literals (also called f-strings for short) let you include the value of Python expressions inside a string by prefixing the string with or and writing expressions as . An optional format specifier can follow the expression. This allows greater control over how the value is formatted. The following example rounds pi to three places after the decimal: 'The value of pi is approximately The value of pi is approximately 3.142. Passing an integer after the will cause that field to be a minimum number of characters wide. This is useful for making columns line up. Other modifiers can be used to convert the value before it is formatted. applies , applies , and applies : 'My hovercraft is full of My hovercraft is full of eels. 'My hovercraft is full of My hovercraft is full of 'eels'. The specifier can be used to expand an expression to the text of the expression, an equal sign, then the representation of the evaluated expression: See self-documenting expressions for more information on the specifier. For a reference on these format specifications, see the reference guide for the Format Specification Mini-Language. Basic usage of the method looks like this: We are the knights who say \"Ni!\" The brackets and characters within them (called format fields) are replaced with the objects passed into the method. A number in the brackets can be used to refer to the position of the object passed into the method. If keyword arguments are used in the method, their values are referred to by using the name of the argument. Positional and keyword arguments can be arbitrarily combined: The story of Bill, Manfred, and Georg. If you have a really long format string that you don’t want to split up, it would be nice if you could reference the variables to be formatted by name instead of by position. This can be done by simply passing the dict and using square brackets to access the keys. This could also be done by passing the dictionary as keyword arguments with the notation. This is particularly useful in combination with the built-in function , which returns a dictionary containing all local variables: __name__: __main__; __doc__: None; __package__: None; __loader__: ... As an example, the following lines produce a tidily aligned set of columns giving integers and their squares and cubes: For a complete overview of string formatting with , see Format String Syntax. Here’s the same table of squares and cubes, formatted manually: # Note use of 'end' on previous line The method of string objects right-justifies a string in a field of a given width by padding it with spaces on the left. There are similar methods and . These methods do not write anything, they just return a new string. If the input string is too long, they don’t truncate it, but return it unchanged; this will mess up your column lay-out but that’s usually better than the alternative, which would be lying about a value. (If you really want truncation you can always add a slice operation, as in .) There is another method, , which pads a numeric string on the left with zeros. It understands about plus and minus signs: The % operator (modulo) can also be used for string formatting. Given (where format is a string), conversion specifications in format are replaced with zero or more elements of values. This operation is commonly known as string interpolation. For example: 'The value of pi is approximately The value of pi is approximately 3.142. More information can be found in the printf-style String Formatting section.\n\nreturns a file object, and is most commonly used with two positional arguments and one keyword argument: The first argument is a string containing the filename. The second argument is another string containing a few characters describing the way in which the file will be used. mode can be when the file will only be read, for only writing (an existing file with the same name will be erased), and opens the file for appending; any data written to the file is automatically added to the end. opens the file for both reading and writing. The mode argument is optional; will be assumed if it’s omitted. Normally, files are opened in text mode, that means, you read and write strings from and to the file, which are encoded in a specific encoding. If encoding is not specified, the default is platform dependent (see ). Because UTF-8 is the modern de-facto standard, is recommended unless you know that you need to use a different encoding. Appending a to the mode opens the file in binary mode. Binary mode data is read and written as objects. You can not specify encoding when opening file in binary mode. In text mode, the default when reading is to convert platform-specific line endings ( on Unix, on Windows) to just . When writing in text mode, the default is to convert occurrences of back to platform-specific line endings. This behind-the-scenes modification to file data is fine for text files, but will corrupt binary data like that in or files. Be very careful to use binary mode when reading and writing such files. It is good practice to use the keyword when dealing with file objects. The advantage is that the file is properly closed after its suite finishes, even if an exception is raised at some point. Using is also much shorter than writing equivalent - blocks: # We can check that the file has been automatically closed. If you’re not using the keyword, then you should call to close the file and immediately free up any system resources used by it. Calling without using the keyword or calling might result in the arguments of not being completely written to the disk, even if the program exits successfully. After a file object is closed, either by a statement or by calling , attempts to use the file object will automatically fail. The rest of the examples in this section will assume that a file object called has already been created. To read a file’s contents, call , which reads some quantity of data and returns it as a string (in text mode) or bytes object (in binary mode). size is an optional numeric argument. When size is omitted or negative, the entire contents of the file will be read and returned; it’s your problem if the file is twice as large as your machine’s memory. Otherwise, at most size characters (in text mode) or size bytes (in binary mode) are read and returned. If the end of the file has been reached, will return an empty string ( ). 'This is the entire file.\n\n' reads a single line from the file; a newline character ( ) is left at the end of the string, and is only omitted on the last line of the file if the file doesn’t end in a newline. This makes the return value unambiguous; if returns an empty string, the end of the file has been reached, while a blank line is represented by , a string containing only a single newline. 'This is the first line of the file.\n\n' 'Second line of the file\n\n' For reading lines from a file, you can loop over the file object. This is memory efficient, fast, and leads to simple code: This is the first line of the file. If you want to read all the lines of a file in a list you can also use or . writes the contents of string to the file, returning the number of characters written. Other types of objects need to be converted – either to a string (in text mode) or a bytes object (in binary mode) – before writing them: returns an integer giving the file object’s current position in the file represented as number of bytes from the beginning of the file when in binary mode and an opaque number when in text mode. To change the file object’s position, use . The position is computed from adding offset to a reference point; the reference point is selected by the whence argument. A whence value of 0 measures from the beginning of the file, 1 uses the current file position, and 2 uses the end of the file as the reference point. whence can be omitted and defaults to 0, using the beginning of the file as the reference point. # Go to the 6th byte in the file # Go to the 3rd byte before the end In text files (those opened without a in the mode string), only seeks relative to the beginning of the file are allowed (the exception being seeking to the very file end with ) and the only valid offset values are those returned from the , or zero. Any other offset value produces undefined behaviour. File objects have some additional methods, such as and which are less frequently used; consult the Library Reference for a complete guide to file objects. Strings can easily be written to and read from a file. Numbers take a bit more effort, since the method only returns strings, which will have to be passed to a function like , which takes a string like and returns its numeric value 123. When you want to save more complex data types like nested lists and dictionaries, parsing and serializing by hand becomes complicated. Rather than having users constantly writing and debugging code to save complicated data types to files, Python allows you to use the popular data interchange format called JSON (JavaScript Object Notation). The standard module called can take Python data hierarchies, and convert them to string representations; this process is called serializing. Reconstructing the data from the string representation is called deserializing. Between serializing and deserializing, the string representing the object may have been stored in a file or data, or sent over a network connection to some distant machine. The JSON format is commonly used by modern applications to allow for data exchange. Many programmers are already familiar with it, which makes it a good choice for interoperability. If you have an object , you can view its JSON string representation with a simple line of code: Another variant of the function, called , simply serializes the object to a text file. So if is a text file object opened for writing, we can do this: To decode the object again, if is a binary file or text file object which has been opened for reading: JSON files must be encoded in UTF-8. Use when opening JSON file as a text file for both of reading and writing. This simple serialization technique can handle lists and dictionaries, but serializing arbitrary class instances in JSON requires a bit of extra effort. The reference for the module contains an explanation of this. Contrary to JSON, pickle is a protocol which allows the serialization of arbitrarily complex Python objects. As such, it is specific to Python and cannot be used to communicate with applications written in other languages. It is also insecure by default: deserializing pickle data coming from an untrusted source can execute arbitrary code, if the data was crafted by a skilled attacker."
    },
    {
        "link": "https://freecodecamp.org/news/python-string-split-and-join-methods-explained-with-examples",
        "document": "When working with strings in Python, you may have to split a string into substrings. Or you might need to join together smaller chunks to form a string. Python's and string methods help you do these tasks easily.\n\nIn this tutorial, you'll learn about the and string methods with plenty of example code.\n\nAs strings in Python are immutable, you can call methods on them without modifying the original strings. Let's get started.\n\nWhen you need to split a string into substrings, you can use the method.\n\nThe method acts on a string and returns a list of substrings. The syntax is:\n\nIn the above syntax:\n• is the separator that you'd like to split on. It should be specified as a string.\n• is an optional argument. By default, this method splits strings on whitespaces.\n• is an optional argument indicating the number of times you'd like to split .\n• has a default value of , which splits the string on all occurrences of .\n\nAnd setting will leave you with two chunks – one with the section of before the first comma, and another with the section of after the first comma.\n\nWhen you split a string once, you'll get 2 chunks. When you split a string twice, you'll get 3 chunks. When you split a string times, you'll get chunks.\n\n▶ Let's take a few examples to see the method in action.\n\nNow, call the method on , without the arguments and .\n\nYou can see that has been split on all whitespaces and the list of substrings is returned, as shown above.\n\n▶ Let's now consider the following example. Here, has names of fruits, separated by commas.\n\nLet's now split on commas – set or only specify in the method call.\n\nAs expected, the method returns a list of fruits, where each fruit in is now a list item.\n\n▶ Let's now use the optional argument as well by setting it equal to 2.\n\nLet's try to parse the returned list.\n\nRecall that is , and we decided to split on commas ( ).\n• The first comma is after , and after the first split you'll have 2 items, and .\n• The second comma is after . And you'll have 3 items, , , and after the second split.\n• At this point, you've reached the count of 2, and no further splits can be made.\n• This is why the portion of the string after the second comma is lumped together as a single item in the returned list.\n\nI hope you understand how the method and the arguments and work.\n\nNow that you know how to split a string into substrings, it's time to learn how to use the method to form a string from substrings.\n\nThe syntax of Python's method is:\n• is any Python iterable containing the substrings, say, a list or a tuple, and\n• is the separator that you'd like to join the substrings on.\n\n▶ And it's time for examples.\n\nIn the previous section on the method, you split into a list on the occurrences of commas. Let's call the list .\n\nNow, you'll form a string using the method to put together items in the returned list. The items in are all names of fruits.\n\n📑 Note that the separator to join on should be specified as a string. You'll run into syntax errors if you don't do so, as shown below.\n\n▶ To join the items in using a comma as the separator, use not . This is shown in the code snippet below.\n\nThe above line of code joins items in using a comma followed by a space as the separator.\n\nYou can specify any separator of your choice. This time, you'll use 3 underscores ( ) to join items in .\n\nThe items in have now been joined into a single string, and have all been separated from each other by a .\n\nAnd you now know how you can form a Python string by putting together substrings using the method.\n\nIn this tutorial, you've learned the following:\n• splits on the occurrence of , number of times,\n• joins substrings in using as the separator."
    }
]