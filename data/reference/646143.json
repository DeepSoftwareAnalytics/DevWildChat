[
    {
        "link": "https://baeldung.com/java-math-sin-degrees",
        "document": "In this short tutorial, we’ll look at how to calculate sine values using Java’s Math.sin() function and how to convert angle values between degrees and radians.\n\nBy default, the Java Math library expects values to its trigonometric functions to be in radians.\n\nAs a reminder, radians are just another way to express the measure of an angle, and the conversion is:\n\nJava makes this easy with toRadians and toDegrees:\n\nWhenever we are using any of Java’s trigonometric functions, we should first think about what is the unit of our input.\n\nWe can see this principle in action by taking a look at the Math.sin method, one of the many that Java provides:\n\nIt’s equivalent to the mathematical sine function and it expects its input to be in radians. So, let’s say that we have an angle we know to be in degrees:\n\nWe first need to convert it to radians:\n\nAnd then we can calculate the sine value:\n\nBut, if we know it to already be in radians, then we don’t need to do the conversion:\n\nSince thirtyDegreesInRadians was already in radians, we didn’t need to first convert it to get the same result.\n\nIn this quick article, we’ve reviewed radians and degrees and then saw an example of how to work with them using Math.sin."
    },
    {
        "link": "https://stackoverflow.com/questions/17764525/converting-result-of-math-sinx-into-a-result-for-degrees-in-java",
        "document": "I would like to convert the , where in radians to a result which will give me as in degrees not radians.\n\nI have used the normal method and java built in method of conversion between degrees and radians, but any argument I pass to the method is being treated as radians, thereby causing my conversion to be a futile effort.\n\nI want the output of a sin Input to be given as if the input is treated in degrees not radians like the method does."
    },
    {
        "link": "https://geeksforgeeks.org/trigonometric-functions-in-java-with-examples",
        "document": "The class Math contains methods for performing basic numeric operations such as the elementary exponential, logarithm, square root, and trigonometric functions.\n• Java.lang.Math.sin() Method : is an inbuilt method which returns the sine of the value passed as an argument. The value passed in this function should be in radians. If the argument is NaN or an infinity, then the result is NaN. If the argument is zero, then the result is a zero with the same sign as the argument. Parameters : \n\n The method takes one mandatory argument in radians. Returns :\n\n It returns a double value. The returned value is the sine of the specified double value passed. Example 1 : Program demonstrating the use of sin()\n• Java.lang.Math.cos() : is an inbuilt method which returns the cosine of the value passed as an argument. The value passed in this function should be in radians. If the argument is NaN or an infinity, then the result is NaN. Parameters : \n\n The method takes one mandatory argument in radians. Returns :\n\n It returns a double value. The returned value is the cosine of the specified double value passed. Example 2 : Program demonstrating the use of cos()\n• Java.lang.Math.tan() : is an inbuilt method which returns the tangent of the value passed as an argument. The value passed in this function should be in radians. If the argument is NaN or an infinity, then the result is NaN. If the argument is zero, then the result is a zero with the same sign as the argument.\n\n Syntax : Parameters : \n\n The method takes one mandatory argument in radians. Returns :\n\n It returns a double value. The returned value is the tangent of the specified double value passed. Example 3 : Program demonstrating the use of tan()"
    },
    {
        "link": "https://docs.vultr.com/java/standard-library/java/lang/Math/toRadians",
        "document": "The Java method is a simple yet essential tool for converting an angle measured in degrees to an equivalent in radians. This conversion is vital in various fields such as computer graphics, physics simulations, and geometric calculations where radians are the preferred unit of angular measurement due to their natural properties in mathematical expressions.\n\nIn this article, you will learn how to use the Java method to convert degrees to radians. Explore practical examples to understand how and where to apply this method effectively in your Java applications.\n• None Start by defining a variable that holds an angle in degrees.\n• None Use the method to convert this degree into radians.\n• This code converts degrees into radians. The output will show the equivalent radians for degrees, which is radians because degrees equals (approximately ) radians.\n• None Prepare a list of various degree values that commonly appear in different applications, such as , , , , and degrees.\n• None Convert each degree value to radians using a loop.\n• None Print the conversions to observe the results. This snippet iteratively converts each degree value in the array and prints out the degree-radian pairs. It provides a clear visual of how degrees translate to radians in practical scenarios.\n• None Create a function named which takes degrees as an argument and returns the radians.\n• None Call the function with a degree value and display the result. By defining a dedicated function, integrating degree-to-radian conversion becomes scalable and reusable within larger codebases, making the code clean and maintainable.\n\nThe Java function efficiently converts angles from degrees to radians, a conversion crucial for applications requiring precise angular calculations. Familiarize yourself with using this method to ensure accurate results in graphics programming, simulations, and other mathematical computations. With practice, utilize these conversions to enhance the functionality and precision of your Java programs."
    },
    {
        "link": "https://stackoverflow.com/questions/44413065/java-math-sin-math-cos-math-tan-giving-answer-in-radian",
        "document": "I was trying to use the Math library in Java where Math.sin(90) gives me result 0.8939966636005579 I search on StackOverflow about this and came to know that the value is) in radian so I used below code to convert it to a degree.\n\nThe value of sin(90) in degree is 1 but the above code returns 51.222235723088794 what should I do to get an accurate result?\n\nResult should be like for sin(90) :: 1"
    },
    {
        "link": "https://stackoverflow.com/questions/5601308/perspective-3d-projection-in-java",
        "document": "I'm working on creating a simple 3D rendering engine in Java. I've messed about and found a few different ways of doing perspective projection, but the only one I got partly working had weird stretching effects the further away from the centre of the screen the object was moved, making it look very unrealistic. Basically, I want a method (however simple or complicated it needs to be) that takes a 3D point to be projected and the 3D point and rotation (possibly?) of the 'camera' as arguments, and returns the position on the screen that that point should drawn at. I don't care how long/short/simple/complicated this method is. I just want it to generate the same kind of perspective you see in a modern 3D first person shooters or any other game, and I know I may have to use matrix multiplication for this. I don't really want to use OpenGL or any other libraries because I'd quite like to do this as a learning exercise and roll my own, if it's possible.\n\nAny help would be appreciated quite a lot :) Thanks, again - James\n\nUpdate: To show what I mean by the 'stretching effects' here are some screen shots of a demo I've put together. Here a cube (40x40x10) centered at the coords (-20,-20,-5) is drawn with the only projection method I've got working at all (code below). The three screens show the camera at (0, 0, 50) in the first screenshot then moved in the X dimension to show the effect in the other two."
    },
    {
        "link": "https://stackoverflow.com/questions/5799609/3d-sphere-opengl",
        "document": "The easiest thing to do is to use the glu functions. I work mostly in C, but in Java it's probably something like:\n\nThis will create a sphere of radius 2, with 10 longitude subdivisions and 15 latitude subdivisions. It will handle creating texture coordinates and proper normals as well.\n\nIf you really want to understand how to do the subdivisions and create the spherical approximation yourself, you might look at this code."
    },
    {
        "link": "https://reddit.com/r/learnprogramming/comments/29zndd/java_opengl_4d_3d_perspective_projection",
        "document": "Hey. I've been working on this project for about 3 days now and finally I'm getting good looking results.\n\nAnyways, there is very little information about 4D to 3D perspective projection on the internet so I've been basicly using only Wikipedia articles and this site as a reference material.\n\nI'm basicly doing the projection in the 4D object's own rendering method, taking the 4D vectors, calculating 3D vectors out of their data and rendering the 3D vectors on the screen with OpenGL's glVertex3f. Now, first of all I'd like to know if there is some way to integrate this into OpenGL's own projection calculations? That would simplify things up a lot IMO. And secondly, I'd just like to have someone more knowledgeable than me review my code, especially my projection / rotation matrix code. Also, it would be awesome if someone knows a programmable way of generating a proper 8 cube Tesseract. I can't just wrap my head around it well enough to be able to input vertex data manually for 8 different cubes so I just have 2 cubes, the second being a bit away in the 4th direction and then lines connecting them together so it looks like a tesseract in wireframe.\n\nControls can be found in Engine.java, Matrices can be found in Transform4D.java, Tesseract.java is the shape that I'm displaying on the screen in the executable jar."
    },
    {
        "link": "https://songho.ca/opengl/gl_projectionmatrix.html",
        "document": "Updates: The MathML version is available here.\n\nA computer monitor is a 2D surface. A 3D scene rendered by OpenGL must be projected onto the computer screen as a 2D image. GL_PROJECTION matrix is used for this projection transformation. First, it transforms all vertex data from the eye coordinates to the clip coordinates. Then, these clip coordinates are also transformed to the normalized device coordinates (NDC) by dividing with w component of the clip coordinates.\n\nTherefore, we have to keep in mind that both clipping (frustum culling) and NDC transformations are integrated into GL_PROJECTION matrix. The following sections describe how to build the projection matrix from 6 parameters; left, right, bottom, top, near and far boundary values.\n\nNote that the frustum culling (clipping) is performed in the clip coordinates, just before dividing by w . The clip coordinates, x , y and z are tested by comparing with w . If any clip coordinate is less than -w , or greater than w , then the vertex will be discarded. \n\n\n\nThen, OpenGL will reconstruct the edges of the polygon where clipping occurs.\n\nIn perspective projection, a 3D point in a truncated pyramid frustum (eye coordinates) is mapped to a cube (NDC); the range of x-coordinate from [l, r] to [-1, 1], the y-coordinate from [b, t] to [-1, 1] and the z-coordinate from [-n, -f] to [-1, 1].\n\nNote that the eye coordinates are defined in the right-handed coordinate system, but NDC uses the left-handed coordinate system. That is, the camera at the origin is looking along -Z axis in eye space, but it is looking along +Z axis in NDC. Since glFrustum() accepts only positive values of near and far distances, we need to negate them during the construction of GL_PROJECTION matrix.\n\nIn OpenGL, a 3D point in eye space is projected onto the near plane (projection plane). The following diagrams show how a point (x , y , z ) in eye space is projected to (x , y , z ) on the near plane.\n\nFrom the top view of the frustum, the x-coordinate of eye space, x is mapped to x , which is calculated by using the ratio of similar triangles; \n\n\n\nFrom the side view of the frustum, y is also calculated in a similar way; \n\n\n\nNote that both x and y depend on z ; they are inversely propotional to -z . In other words, they are both divided by -z . It is a very first clue to construct GL_PROJECTION matrix. After the eye coordinates are transformed by multiplying GL_PROJECTION matrix, the clip coordinates are still a homogeneous coordinates. It finally becomes the normalized device coordinates (NDC) by divided by the w-component of the clip coordinates. (See more details on OpenGL Transformation.) \n\n ,\n\nTherefore, we can set the w-component of the clip coordinates as -z . And, the 4th of GL_PROJECTION matrix becomes (0, 0, -1, 0). \n\n\n\nNext, we map x and y to x and y of NDC with linear relationship; [l, r] ⇒ [-1, 1] and [b, t] ⇒ [-1, 1].\n\nThen, we substitute x and y into the above equations.\n\nNote that we make both terms of each equation divisible by -z for perspective division (x /w , y /w ). And we set w to -z earlier, and the terms inside parentheses become x and y of the clip coordiantes.\n\nFrom these equations, we can find the 1st and 2nd rows of GL_PROJECTION matrix. \n\n\n\nNow, we only have the 3rd row of GL_PROJECTION matrix to solve. Finding z is a little different from others because z in eye space is always projected to -n on the near plane. But we need unique z value for the clipping and depth test. Plus, we should be able to unproject (inverse transform) it. Since we know z does not depend on x or y value, we borrow w-component to find the relationship between z and z . Therefore, we can specify the 3rd row of GL_PROJECTION matrix like this. \n\n\n\nIn eye space, w equals to 1. Therefore, the equation becomes; \n\n\n\nTo find the coefficients, A and B, we use the (z , z ) relation; (-n, -1) and (-f, 1), and put them into the above equation. \n\n\n\nTo solve the equations for A and B, rewrite eq.(1) for B; \n\n\n\nSubstitute eq.(1') to B in eq.(2), then solve for A; \n\n\n\nWe found A and B. Therefore, the relation between z and z becomes; \n\n\n\nFinally, we found all entries of GL_PROJECTION matrix. The complete projection matrix is;\n\nThis projection matrix is for a general frustum. If the viewing volume is symmetric, which is and , then it can be simplified as; \n\n\n\nBefore we move on, please take a look at the relation between z and z , eq.(3) once again. You notice it is a rational function and is non-linear relationship between z and z . It means there is very high precision at the near plane, but very little precision at the far plane. If the range [-n, -f] is getting larger, it causes a depth precision problem (z-fighting); a small change of z around the far plane does not affect on z value. The distance between n and f should be short as possible to minimize the depth buffer precision problem.\n\nThe perspective projection matrix can be simplified by setting the far plane to ∞ in the third row of the perspective matrix. \n\n\n\nTherefore, both general and symmetric perspective projection matices with infinite far plane become;\n\nNote that the infinite projection matrix still suffers from the depth precision error .\n\nIt is hard to determine 4 parameters (left, right, top, and bottom) properly with a given near and far planes for the perspective projection on a specific window dimension. You can easily derive these 4 parameters from the vertical/horizontal field of view angle and the aspect ratio, width/height. However these conversion are limited for a symmetric perspective projection matrix.\n\nConstructing GL_PROJECTION matrix for orthographic projection is much simpler than perspective mode.\n\nAll x , y and z components in eye space are linearly mapped to NDC. We just need to scale a rectangular volume to a cube, then move it to the origin. Let's find out the elements of GL_PROJECTION using linear relationship.\n\nSince w-component is not necessary for orthographic projection, the 4th row of GL_PROJECTION matrix remains as (0, 0, 0, 1). Therefore, the complete GL_PROJECTION matrix for orthographic projection is;\n\nIt can be further simplified if the viewing volume is symmetrical, and ."
    },
    {
        "link": "https://scratchapixel.com/lessons/3d-basic-rendering/perspective-and-orthographic-projection-matrix/opengl-perspective-projection-matrix.html",
        "document": ""
    }
]