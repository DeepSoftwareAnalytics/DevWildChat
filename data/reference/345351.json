[
    {
        "link": "https://pythonguis.com/tutorials/creating-your-first-pyqt-window",
        "document": "In this tutorial we'll learn how to use PyQt to create desktop applications with Python. First we'll create a series of simple windows on your desktop to ensure that PyQt is working and introduce some of the basic concepts. Then we'll take a brief look at the event loop and how it relates to GUI programming in Python. Finally we'll look at Qt's which offers some useful common interface elements such as toolbars and menus. These will be explored in more detail in the subsequent tutorials.\n\nLet's create our first application! To start create a new Python file — you can call it whatever you like (e.g. ) and save it somewhere accessible. We'll write our simple app in this file.\n\nWe'll be editing within this file as we go along, and you may want to come back to earlier versions of your code, so remember to keep regular backups.\n\nThe source code for the application is shown below. Type it in verbatim, and be careful not to make mistakes. If you do mess up, Python will let you know what's wrong.\n\nFirst, launch your application. You can run it from the command line like any other Python script, for example --\n\nRun it! You will now see your window. Qt automatically creates a window with the normal window decorations and you can drag it around and resize it like any window.\n\nWhat you'll see will depend on what platform you're running this example on. The image below shows the window as displayed on Windows, macOS and Linux (Ubuntu).\n\nOur window, as seen on Windows, macOS and Linux.\n\nLet's step through the code line by line, so we understand exactly what is happening.\n\nFirst, we import the PyQt classes that we need for the application. Here we're importing , the application handler and , a basic empty GUI widget, both from the module.\n\nThe main modules for Qt are , and .\n\nYou could do but this kind of global import is generally frowned upon in Python, so we'll avoid it here.\n\nNext we create an instance of , passing in , which is Python containing the command line arguments passed to the application.\n\nIf you know you won't be using command line arguments to control Qt you can pass in an empty list instead, e.g.\n\nNext we create an instance of a using the variable name .\n\nIn Qt all top level widgets are windows -- that is, they don't have a parent and are not nested within another widget or layout. This means you can technically create a window using any widget you like.\n\nWidgets without a parent are invisible by default. So, after creating the object, we must always call to make it visible. You can remove the and run the app, but you'll have no way to quit it!\n\nWhat is a window? - Holds the user-interface of your application - Every application needs at least one (...but can have more) - Application will (by default) exit when last window is closed\n\nFinally, we call to start up the event loop.\n\nIn PyQt5 you can also use . This was a legacy feature avoid a clash with the reserved word in Python 2.\n\nBefore getting the window on the screen, there are a few key concepts to introduce about how applications are organized in the Qt world. If you're already familiar with event loops you can safely skip to the next section.\n\nThe core of every Qt Applications is the class. Every application needs one — and only one — object to function. This object holds the event loop of your application — the core loop which governs all user interaction with the GUI.\n\nEach interaction with your application — whether a press of a key, click of a mouse, or mouse movement — generates an event which is placed on the event queue. In the event loop, the queue is checked on each iteration and if a waiting event is found, the event and control is passed to the specific event handler for the event. The event handler deals with the event, then passes control back to the event loop to wait for more events. There is only one running event loop per application.\n\nThe class - holds the Qt event loop - One instance required - Your application sits waiting in the event loop until an action is taken - There is only one event loop running at any time\n\nAs we discovered in the last part, in Qt any widgets can be windows. For example, if you replace with . In the example below, you would get a window with a single push-able button in it.\n\nThis is neat, but not really very useful -- it's rare that you need a UI that consists of only a single control! But, as we'll discover later, the ability to nest widgets within other widgets using layouts means you can construct complex UIs inside an empty .\n\nBut, Qt already has a solution for you -- the . This is a pre-made widget which provides a lot of standard window features you'll make use of in your apps, including toolbars, menus, a statusbar, dockable widgets and more. We'll look at these advanced features later, but for now, we'll add a simple empty to our application.\n\nRun it! You will now see your main window. It looks exactly the same as before!\n\nSo our isn't very interesting at the moment. We can fix that by adding some content. If you want to create a custom window, the best approach is to subclass and then include the setup for the window in the block. This allows the window behavior to be self contained. We can add our own subclass of — call it to keep things simple.\n\nFor this demo we're using a . The core Qt widgets are always imported from the namespace, as are the and classes. When using we use to place a widget (here a ) in the -- by default it takes the whole of the window. We'll look at how to add multiple widgets to windows in the layouts tutorial.\n\nWhen you subclass a Qt class you must always call the super function to allow Qt to set up the object.\n\nIn our block we first use to change the title of our main window. Then we add our first widget — a — to the middle of the window. This is one of the basic widgets available in Qt. When creating the button you can pass in the text that you want the button to display.\n\nFinally, we call on the window. This is a specific function that allows you to set the widget that goes in the middle of the window.\n\nRun it! You will now see your window again, but this time with the widget in the middle. Pressing the button will do nothing, we'll sort that next.\n\nOur with a single on Windows, macOS and Linux.\n\nWe'll cover more widgets in detail shortly but if you're impatient and would like to jump ahead you can take a look at the QWidget documentation. Try adding the different widgets to your window!\n\nThe window is currently freely resizable -- if you grab any corner with your mouse you can drag and resize it to any size you want. While it's good to let your users resize your applications, sometimes you may want to place restrictions on minimum or maximum sizes, or lock a window to a fixed size.\n\nIn Qt sizes are defined using a object. This accepts width and height parameters in that order. For example, the following will create a fixed size window of 400x300 pixels.\n\nRun it! You will see a fixed size window -- try and resize it, it won't work.\n\nOur fixed-size window, notice that the maximize control is disabled on Windows & Linux. On macOS you can maximize the app to fill the screen, but the central widget will not resize.\n\nAs well as you can also call and to set the minimum and maximum sizes respectively. Experiment with this yourself!\n\nYou can use these size methods on any widget.\n\nIn this section we've covered the class, the class, the event loop and experimented with adding a simple widget to a window. In the next section we'll take a look at the mechanisms Qt provides for widgets and windows to communicate with one another and your own code."
    },
    {
        "link": "https://build-system.fman.io/pyqt5-tutorial",
        "document": "This PyQt5 tutorial shows how to use Python 3 and Qt to create a GUI on Windows, Mac or Linux. It even covers creating an installer for your app.\n\nPyQt is a library that lets you use the Qt GUI framework from Python. Qt itself is written in C++. By using it from Python, you can build applications much more quickly while not sacrificing much of the speed of C++.\n\nPyQt5 refers to the most recent version 5 of Qt. You may still find the occasional mention of (Py)Qt4 on the web, but it is old and no longer supported.\n\nAn interesting new competitor to PyQt is Qt for Python. Its API is virtually identical. Unlike PyQt, it is licensed under the LGPL and can thus be used for free in commercial projects. It's backed by the Qt company, and thus likely the future. We use PyQt here because it is more mature. Since the APIs are so similar, you can easily switch your apps to Qt for Python later.\n\nThe best way to manage dependencies in Python is via a virtual environment. A virtual environment is simply a local directory that contains the libraries for a specific project. This is unlike a system-wide installation of those libraries, which would affect all of your other projects as well.\n\nTo create a virtual environment in the current directory, execute the following command:\n\nThis creates the folder. To activate the virtual environment on Windows, run:\n\nOn Mac and Linux, use:\n\nYou can see that the virtual environment is active by the prefix in your shell:\n\nTo now install PyQt, issue the following command:\n\nTime to write our very first GUI app! With the virtual environment still active, start Python. We will execute the following commands:\n\nFirst, we tell Python to load PyQt via the import statement:\n\nNext, we create a with the command:\n\nThis is a requirement of Qt: Every GUI app must have exactly one instance of . Many parts of Qt don't work until you have executed the above line. You will therefore need it in virtually every (Py)Qt app you write.\n\nThe brackets in the above line represent the command line arguments passed to the application. Because our app doesn't use any parameters, we leave the brackets empty.\n\nNow, to actually see something, we create a simple label:\n\nThen, we tell Qt to show the label on the screen:\n\nDepending on your operating system, this already opens a tiny little window:\n\nThe last step is to hand control over to Qt and ask it to \"run the application until the user closes it\". This is done via the command:\n\nIf all this worked as expected then well done! You've just built your first GUI app with Python and Qt.\n\nEverything you see in a (Py)Qt app is a widget: Buttons, labels, windows, dialogs, progress bars etc. Like HTML elements, widgets are often nested. For example, a window can contain a button, which in turn contains a label.\n\nThe following screenshot shows the most common Qt widgets:\n\nYou can download the code for the app shown in the screenshot here, if you are interested.\n\nLike the example above, your GUI will most likely consist of multiple widgets. In this case, you need to tell Qt how to position them. For instance, you can use QVBoxLayout to stack widgets vertically:\n\nThe code for this screenshot is:\n\nAs before, we instantiate a . Then, we create a . We use the most basic type for it because it merely acts as a container and we don't want it to have any special behavior. Next, we create the and add two s to it. Finally, we tell the window to use this layout (and thus its contents). As in our first application, we end with calls to and .\n\nThere are of course many other kinds of layouts (eg. QHBoxLayout to lay out items in a row). See Qt's documentation for an overview.\n\nOne of Qt's strengths is its support for custom styles. There are many mechanisms that let you customize the look and feel of your application. This section outlines a few.\n\nThe coarsest way to change the appearance of your application is to set the global Style. Recall the widgets screenshot above:\n\nThis uses a style called . If you use the style instead, then it looks as follows:\n\nThe available styles depend on your platform but are usually , , (Windows only) and (Mac only).\n\nIf you like a style, but want to change its colors (eg. to a dark theme), then you can use QPalette and . For example:\n\nThis changes the text color in buttons to red:\n\nFor a dark theme of the Fusion style, see here.\n\nIn addition to the above, you can change the appearance of your application via style sheets. This is Qt's analogue of CSS. We can use this for example to add some spacing:\n\nFor more information about style sheets, please see Qt's documentation.\n\nQt uses a mechanism called signals to let you react to events such as the user clicking a button. The following example illustrates this. It contains a button that, when clicked, shows a message box:\n\nThe interesting line is highlighted above: is a signal, lets us install a so-called slot on it. This is simply a function that gets called when the signal occurs. In the above example, our slot shows a message box.\n\nThe term slot is important when using Qt from C++, because slots must be declared in a special way in C++. In Python however, any function can be a slot – we saw this above. For this reason, the distinction between slots and \"normal\" functions has little relevance for us.\n\nSignals are ubiquitous in Qt. And of course, you can also define your own. This however is beyond the scope of this tutorial.\n\nYou now have the basic knowledge for creating a GUI that responds to user input. Say you've written an app. It runs on your computer. How do you give it to other people, so they can run it as well?\n\nYou could ask the users of your app to install Python and PyQt like we did above, then give them your source code. But that is very tedious (and usually impractical). What we want instead is a standalone version of your app. That is, a binary executable that other people can run on their systems without having to install anything.\n\nIn the Python world, the process of turning source code into a self-contained executable is called freezing. Although there are many libraries that address this issue – such as PyInstaller, py2exe, cx_Freeze, bbfreze, py2app, ... – freezing PyQt apps has traditionally been a surprisingly hard problem.\n\nWe will use a new library called fbs that lets you create standalone executables for PyQt apps. To install it, enter the command:\n\nThen, execute the following:\n\nThis prompts you for a few values:\n\nWhen you type in the suggested command, an empty window should open:\n\nThis is a PyQt5 app just like the ones we have seen before. Its source code is in in your current directory. But here's the cool part: We can use fbs to turn it into a standalone executable!\n\nThis places a self-contained binary in the folder of your current directory. You can send it to your friends (with the same OS as yours) and they will be able to run your app!\n\n(Please note that the free version of fbs only supports Python 3.5 or 3.6. If you have a different version, please install one of these supported Python versions or buy fbs Pro).\n\nfbs also lets you create an installer for your app via the command :\n\nFor more information on how you can use fbs for your existing application, please see this article. Or fbs's tutorial.\n\nIf you have made it this far, then big congratulations. Hopefully, you now have a good idea of how PyQt (and its various parts) can be used to write a desktop application with Python. We also saw how fbs lets you create standalone executables and installers.\n\nDue to the popularity of this article, I wrote a PyQt6 book.\n\nThe book explains in more detail how you can create your own apps. Even Phil Thompson, the creator of PyQt, read the book and said it's \"very good\". So check it out!"
    },
    {
        "link": "https://doc.qt.io/qtforpython-5/PySide2/QtWidgets/QPushButton.html",
        "document": "The push button, or command button, is perhaps the most commonly used widget in any graphical user interface. Push (click) a button to command the computer to perform some action, or to answer a question. Typical buttons are OK, Apply, Cancel, Close, Yes, No and Help.\n\nA command button is rectangular and typically displays a text label describing its action. A shortcut key can be specified by preceding the preferred character with an ampersand in the text. For example:\n\nIn this example the shortcut is Alt+D . See the documentation for details (to display an actual ampersand, use ‘&&’).\n\nPush buttons display a textual label, and optionally a small icon. These can be set using the constructors and changed later using and . If the button is disabled, the appearance of the text and icon will be manipulated with respect to the GUI style to make the button look “disabled”.\n\nA push button emits the signal when it is activated by the mouse, the Spacebar or by a keyboard shortcut. Connect to this signal to perform the button’s action. Push buttons also provide less commonly used signals, for example and .\n\nCommand buttons in dialogs are by default auto-default buttons, i.e., they become the default push button automatically when they receive the keyboard input focus. A default button is a push button that is activated when the user presses the Enter or Return key in a dialog. You can change this with . Note that auto-default buttons reserve a little extra space which is necessary to draw a default-button indicator. If you do not want this space around your buttons, call (false).\n\nBeing so central, the button widget has grown to accommodate a great many variations in the past decade. The Microsoft style guide now shows about ten different states of Windows push buttons and the text implies that there are dozens more when all the combinations of features are taken into consideration.\n\nThe most important modes or states are:\n• None Available or not (grayed out, disabled).\n• None On or off (only for toggling push buttons).\n• None Default or normal. The default button in a dialog can generally be “clicked” using the Enter or Return key.\n• None Pressed down or not.\n\nAs a general rule, use a push button when the application or dialog window performs an action when the user clicks on it (such as Apply, Cancel, Close and Help) and when the widget is supposed to have a wide, rectangular shape with a text label. Small, typically square buttons that change the state of the window rather than performing an action (such as the buttons in the top-right corner of the ) are not command buttons, but tool buttons. Qt provides a special class ( ) for these buttons.\n\nIf you need toggle behavior (see ) or a button that auto-repeats the activation signal when being pushed down like the arrows in a scroll bar (see ), a command button is probably not what you want. When in doubt, use a tool button.\n\nA variation of a command button is a menu button. These provide not just one command, but several, since when they are clicked they pop up a menu of options. Use the method to associate a popup menu with a push button.\n\nOther classes of buttons are option buttons (see ) and check boxes (see ).\n\nIn Qt, the base class provides most of the modes and other API, and provides GUI logic. See for more information about the API."
    },
    {
        "link": "https://pythonguis.com/pyqt5-tutorial",
        "document": "PyQt is a Python library for creating GUI applications using the Qt toolkit. Created by Riverbank Computing, PyQt is free software (GPL licensed) and has been in development since 1999. PyQt5 was released in 2016 and last updated in October 2021.\n\nThis complete PyQt5 tutorial takes you from first concepts to building fully-functional GUI applications in Python. It requires some basic Python knowledge, but no previous familiarity with GUI concepts. Everything will be introduced step by by step, using hands-on examples.\n\nPyQt5 is the Qt5-based edition of the Python GUI library PyQt from Riverbank Computing.\n\nThere are two major versions currently in use: PyQt5 based on Qt5 and PyQt6 based on Qt6. Both versions are almost completely compatible aside from imports. PyQt6 also makes some changes to how namespaces and flags work, but these are easily manageable.\n\nLooking for something else? I also have a PyQt6 tutorial, PySide2 tutorial and PySide6 tutorial.\n\nThis track consists of 36 tutorials. Keep checking back as I'm adding new tutorials regularly — last updated ."
    },
    {
        "link": "https://realpython.com/qt-designer-python",
        "document": "To create a GUI for your windows and dialogs in PyQt, you can take two main paths: you can use Qt Designer, or you can hand code the GUI in plain Python code. The first path can dramatically improve your productivity, whereas the second path puts you in full control of your application’s code.\n\nGUI applications often consist of a main window and several dialogs. If you’re looking to create these graphical components in an efficient and user-friendly way, then Qt Designer is the tool for you. In this tutorial, you’ll learn how to use Qt Designer to create your GUIs productively.\n• What Qt Designer is and how to install it on your system\n• When to use Qt Designer vs hand coding for building your GUIs\n• How to build and lay out the GUI of an application’s main window using Qt Designer\n• How to create and lay out the GUI of your dialogs with Qt Designer\n• How to use Qt Designer’s files in your GUI applications\n\nFor a better understanding of the topics in this tutorial, you can check out the following resources:\n\nYou’ll put all this knowledge together by using the GUIs that you’ll build with Qt Designer in a sample text editor application. You can get the code and all the required resources to build this application by clicking the link below:\n\nQt Designer is a Qt tool that provides you with a what-you-see-is-what-you-get (WYSIWYG) user interface to create GUIs for your PyQt applications productively and efficiently. With this tool, you create GUIs by dragging and dropping objects on an empty form. After that, you can arrange them into a coherent GUI using different layout managers. Qt Designer also allows you to preview your GUIs using different styles and resolutions, connect signals and slots, create menus and toolbars, and more. Qt Designer is platform and programming language independent. It doesn’t produce code in any particular programming language, but it creates files. These files are files with detailed descriptions of how to generate Qt-based GUIs. You can translate the content of files into Python code with , which is a command-line tool that comes with PyQt. Then you can use this Python code in your GUI applications. You can also read files directly and load their content to generate the associated GUI. There are several ways to get and install Qt Designer depending on your current platform. If you use Windows or Linux, then you can run the following commands from your terminal or command line: Here, you create a Python virtual environment, activate it, and install and . installs PyQt and a copy of the required Qt libraries, while installs a set of Qt tools that includes Qt Designer. The installation will place the Qt Designer executable in a different directory according to your platform: On Linux systems, such as Debian and Ubuntu, you can also install Qt Designer by using the system package manager with the following command: This command downloads and installs Qt Designer and other Qt tools on your system. In other words, you’ll have a system-wide installation and you’ll be able to run Qt Designer by clicking its icon in a file manager or system menu. On macOS, if you’ve installed Qt from Homebrew using the command, then you should have Qt Designer already installed on your system. Finally, you can download the Qt installer for your current platform from the official download site and then follow the on-screen instructions. In this case, to complete the installation process, you need to register a Qt account. If you’ve already installed Qt Designer using one of the options discussed so far, then go ahead and launch the application. You should get the following two windows on your screen: The window in the foreground is Qt Designer’s New Form dialog. The window in the background is Qt Designer’s main window. In the next two sections, you’ll learn the basics of how to use these components of the Qt Designer interface. When you run Qt Designer, you’re presented with the application’s main window and the New Form dialog. In this dialog, you can select from five available GUI templates. These templates include options to create dialogs, main windows, and custom widgets: OK and Cancel buttons laid out horizontally on the bottom-right corner OK and Cancel buttons laid out vertically on the top-right corner A menu bar at the top and a status bar at the bottom By default, when you run Qt Designer, the New Form dialog appears in the foreground. If it doesn’t, then you can click New on Qt Designer’s toolbar. You can also click File → New in the main menu or press + on your keyboard. In the New Form dialog, you can select the form template that you want to start with and then click Create to generate a new form: To create a new and empty form using a Qt Designer template, you just need to select the desired template from the New Form dialog and then click Create or press + on your keyboard. Note that the first two dialog templates have their own default buttons. These are standard buttons included in a . This class automatically handles the position or order of buttons across different platforms. For example, if you use a Cancel button and an OK button, then the standard on Linux and macOS is to display those buttons in this same order. But on Windows, the order of buttons will be swapped, with OK appearing first, followed by Cancel. handles this issue for you automatically. Qt Designer’s main window provides a menu bar with options for saving and managing forms, editing forms and changing the edit mode, laying out and previewing forms, and also for tuning the application’s settings and accessing its help documentation: The main window also provides a toolbar that displays commonly used options. You’ll use most of these options when you’re editing and laying out your forms. These options are also available in the main menu, especially in the File, Edit, and Form menus: Qt Designer’s main window also includes a few dock windows that provide a rich set of features and tools: The Widget Box provides a selection of layout managers, spacers, standard widgets, and other objects that you can use to create a GUI for your dialogs and windows: The Widget Box provides a filter option at the top of the window. You can type the name of a given object or widget and get quick access to it. The objects are grouped into categories that reflect their specific use. You can show or hide all the available objects in a category by clicking the handle next to the category label. When you’re creating your forms, you can take objects from the Widget Box with your mouse pointer and then drag and drop them onto the form to build its GUI. The Widget Box also provides a Scratchpad section at the bottom of the window. In this section, you can group frequently used objects in a separate category. You can fill the Scratchpad category with any widget currently placed on a form by dragging and dropping them back onto the Widget Box. You can remove widgets from the Scratchpad category by right-clicking them and selecting Remove in the context menu. The Object Inspector provides a tree view of all the objects on the current form. The Object Inspector also has a filter box at the top to allow you to find objects in the tree. You can use the Object Inspector to set the name and other properties of the form and its widgets. You can also right-click any widget to access a context menu with additional options: With the Object Inspector, you can manage the widgets on your form. You can rename them, update some of their properties, remove them from the form, and so on. The tree view in the Object Inspector reflects the parent-child relationship of the widgets and objects on the current form. The Property Editor is another dock window that appears in Qt Designer’s main window. This window holds a two-column table with the active object’s properties and their values. You can use the Property Editor to edit the value of an object’s properties, as the name implies: The Property Editor provides a user-friendly way to access and edit the values of the active object’s properties, such as its name, size, font, icon, and so on. The properties listed on the editor will change depending on which object you select on your form. The properties are listed from top to bottom according to class hierarchy. For example, if you select a on the form, then the Property Editor shows the properties of , followed by the properties of , and finally the properties of itself. Note that the rows on the editor show different colors to visually differentiate the underlying class. Finally, you have three dock windows that commonly appear as tabs in the bottom-right corner:\n• Resource Browser provides a quick way of adding resources, such as icons, translation files, images, and other binary files to your applications.\n• Action Editor provides a way to create actions and add them to your forms.\n• Signal/Slot Editor provides a way to connect signals and slots in your forms. Here are some of the options that these tools provide: That’s it! These three dock windows round out the set of tools and options that Qt Designer provides for you to create and customize the GUIs for your dialogs and windows. Using Qt Designer vs Hand Coding Your GUIs With PyQt, you have at least two options for creating the GUI of a window or dialog: You can use Qt Designer, or you can hand code the GUI in plain Python code. Both options have their pros and cons. Sometimes it’s hard to decide when to use one or the other. Qt Designer provides a user-friendly graphical interface that allows you to quickly create GUIs. This can boost your productivity as a developer and shorten your development cycles. Hand coding your GUIs, on the other hand, can give you much more control over them. With this approach, adding new components and features doesn’t require any extra tools beyond your code editor or IDE, which can be quite convenient in some development environments. Whether you use Qt Designer or hand code your GUIs is a personal decision. Here are some general considerations on both approaches: High if you’re familiar with PyQt, but low otherwise Beyond these concerns, if you’re just starting with PyQt, then Qt Designer can help you discover available widgets, layout managers, base classes, properties and their typical values, and so on. One last difference between using Qt Designer and hand coding a GUI is that you need to run an extra step when using Qt Designer: translating files into Python code.\n\nWith PyQt, you can build main window–style and dialog-style applications. Main window–style applications often consist of a main window with a menu bar, one or more toolbars, a central widget, and a status bar. They can also include several dialogs, but those are independent of the main window. Qt Designer enables you to quickly build the GUI of your main windows using the predefined Main Window template. Once you’ve created a form based on that template, you’ll have tools to perform the following actions: Qt Designer’s Main Window template also provides a default central widget and a status bar at the bottom of the window: Qt Designer saves its forms in files. These are files that contain all the information you’ll need to later recreate the GUI in your applications. To save your forms, go to File → Save, enter in the Save Form As dialog, select a directory to save the file in, and click Save. You can also get access to the Save Form As dialog by pressing + on your keyboard. Don’t close your Qt Designer session—stay there to continue adding menus and toolbars to the main window you just created. Qt Designer’s Main Window template provides an empty menu bar at the top of the form. You can add menus to that menu bar using the Menu Editor. Menus are pull-down lists of options that provide quick access to the application’s options. Go back to Qt Designer and your newly created main window. At the top of the form, you’ll see a menu bar with the placeholder text Type Here. If you double-click or press on this placeholder text, then you can type the name of your first menu. To confirm the menu name, just press . Say you want to create your own text editor. Typically, this kind of application has a File menu with at least some of the following options:\n• New for creating a new document Here’s how you can use Qt Designer to create this menu: Qt Designer’s Menu Editor allows you to add menus to the menu bar in a user-friendly way. When you enter the name of a menu or menu option, you can use an ampersand symbol ( ) before a given letter to provide a keyboard accelerator. For example, if you add an ampersand before the F in the File menu, then you can access this menu by pressing + . Likewise, if you add an ampersand before the N in New, then once you’ve launched the File menu, you can access the New option by pressing . With the Menu Editor, you can also add separators to your menus. This is a good way to visually separate menu options and group them logically. To add a separator, double-click the Add Separator option at the end of the active menu in the Menu Editor. You can remove an existing separator by right-clicking it and then selecting Remove Separator in the context menu. This menu also allows you to add new separators. If you need to move a separator to another place in a given menu, then you can drag the separator to the desired position and drop it there. A red line will indicate the position where the separator will be placed. You can also add a submenu to a given menu option. To do this, click the icon on the right side of the menu option to which you want to attach the submenu, just like you did with the Open Recent option in the above example. To run a preview of your form, go to Form → Preview, or hit the key combination + on your keyboard. When you create a menu like the File menu in your sample text editor, a new object is automatically added to your menu bar. When you add a menu option to a given menu, you create an action. Qt Designer provides an Action Editor for creating, customizing, and managing actions. The tool provides a few handy options that you can use to fine-tune your actions: With the Action Editor, you can fine-tune, update, or set the following options:\n• The text of the action, which will be shown on menu options and toolbar buttons\n• The object name, which you’ll use in your code to reference the action object\n• The icons that will be shown on your menu options and toolbar buttons\n• The checkable property of the action\n• The keyboard shortcuts, which will provide the user with a quick way to access the action The final ellipsis ( ) in the text of your menu options is a widely used convention for naming options that don’t perform an immediate action but launch a pop-up dialog for performing further actions. In the case of the icons, you need to pack those icons with your application as independent files, or you can create a resources file, also known as a file. For this example, you can download the required icons and other resources by clicking the link below: Get the Source Code: Click here to get the source code you’ll use to learn about creating Python GUI applications with Qt Designer in this tutorial. Once you’ve downloaded the icons, create a directory beside your file and copy the icons there. Then get back to the Action Editor and add icons to your actions like this: Note that your menu options now display an icon on the left margin. This provides extra visual information to your users and helps them find the desired option. Now go ahead and add an Edit menu with the following options:\n• Find and Replace for finding and replacing text Next, add a Help menu with an About option for launching a dialog with general information about your text editor. Finally, go to the Property Editor and set the title of your window to . After these additions, your main window should look something like this: With these additions, your sample text editor’s main menu is starting to look like the menu of a real text editor! You can add as many toolbars as you need to your main window’s GUI using Qt Designer. To do that, right-click on the form and select Add Tool Bar from the context menu. This adds an empty toolbar at the top of the window. Alternatively, you can predefine the toolbar area where you want to place a given toolbar by selecting Add Tool Bar to Other Area: Once you have your toolbars in place, you can populate them with buttons. To do this, you use actions rather than specific toolbar buttons from the Widget Box. To add actions to your toolbars, you can use the Action Editor: Actions can be shared between menu options and toolbar buttons, so in this case, you reuse the actions that you created when you populated your menus in the preceding section. To populate the toolbar, click on an action on the Action Editor, then drag and drop it onto the toolbar. Note that by right-clicking on the toolbar, you can add separators to visually separate the tool buttons. Qt Designer uses for building its Main Window template. This class provides a default layout that allows you to create a menu bar, one or more toolbars, one or more dock widgets, a status bar, and a central widget. By default, Qt Designer uses a object as the central widget on the Main Window template. Using a bare-bones object as the central widget on a main window’s GUI is a good choice because, on top of that widget, you can place either a single widget or multiple widgets in a coherent layout. For example, in your sample text editor, you might want to use a single widget that provides your users with a work area to type, copy, paste, and edit their text. For this purpose, you can use a object and then add a vertical (or horizontal) layout as the central widget’s layout: In this example, you first drag a onto the form. Then you click on the form to select your central widget. Finally, you apply a vertical layout to your central widget by clicking Lay Out Vertically on Qt Designer’s toolbar. Since the spacing around the doesn’t look right, you use the Object Inspector to change the margins of the layout from pixels to pixel. With Qt Designer, you can use different layout managers to arrange your widgets quickly. Arguably, the most accessible way of laying out your GUIs with Qt Designer is using the layout-related section on the main toolbar: From left to right, you’ll find the following options to create different types of layouts: Horizontally in one row and several columns Vertically in one column and several rows Tabularly in a grid with several rows and columns The last two options in the toolbar are related to layouts but don’t create them:\n• Break Layout allows you to break an existing layout. Once widgets are arranged in a layout, you can’t move or resize them individually because their geometry is controlled by the layout. To modify individual widgets, you might need to break the layout and redo it later. To access this option, you can press + on your keyboard.\n• Adjust Size adjusts the size of the layout to accommodate contained widgets and to ensure that each has enough space to be visible. To access this option, you can press + on your keyboard. You can also access all these layout-related options through Qt Designer’s main menu bar, under the Form menu: In the Form menu, you have access to all the layout-related options, with a complete reference of the keyboard shortcuts to access them. You can also access these options through the form’s context menu, under the Lay Out option. When you’re creating your main windows, you might face situations in which you need to use multiple widgets in a given layout as your central widget. Since Qt Designer’s Main Window template ships with a object as its central widget, you can take advantage of this to create your own custom arrangement of widgets and then set it as the top-level layout of that central widget. With Qt Designer, you can lay out your widgets using layout managers, as you already saw in the above section. If you need a compound layout of widgets for your main window’s GUI, then you can build it by running the following steps:\n• Drag and drop the widgets onto your form and try to place them near their desired position.\n• Select the widgets that should be managed together by a given layout.\n• Apply the appropriate layout using Qt Designer’s toolbar or main menu, or with the form’s context menu. Although you can drag layouts onto a form and then drag widgets onto the layouts, the best practice is to drag all the widgets and spacers first and then repeatedly select related widgets and spacers to apply layouts to them. For example, suppose you’re building a calculator application. You need a object on the top of your form to display the operations and their results. Under the line edit, you need a few objects for the numbers and operations. That gives you a window like this: This looks something like a calculator, but the GUI is messy and cluttered. To arrange this into a more polished calculator GUI, you can use a grid layout for the buttons and a vertical box layout as the calculator’s top-level layout: Your calculator still needs some extra polishing, but it looks a lot better now. To get a more finished version, you can use the Property Editor to tweak the values of some properties on your buttons, such as their maximum and minimum size. You can also set a fixed size for your calculator’s main window, and so on. Go ahead and give it a try! Qt Designer’s Main Window template provides a status bar by default. A status bar is a horizontal panel that’s usually placed at the bottom of the main window in a GUI application. Its primary purpose is to display information about the current status of the application. You can divide a status bar into several sections and show different information on each section. The information on the status bar can be temporary or permanent, and most of the time it comes as text messages. The purpose of the information displayed on the status bar is to keep your users updated about what the application is currently doing and what its general status is at a given time. You can also use the status bar to display help tips, which are short help messages that describe what a given button or menu option does. This kind of message appears on the status bar when the user hovers the mouse pointer over a toolbar button or menu option.\n\nDialogs are small-sized windows that you commonly use to provide auxiliary functionalities, such as a Preferences dialog, or to communicate with your users by showing error messages or general information about a given operation. You can also use dialogs to ask the user for some required information or to confirm an operation that’s about to take place. PyQt offers a rich set of built-in dialog that you can use in your applications directly. You just need to import them from . Here’s a summary: Selecting and setting a font of a given text Specifying the settings of a printer Getting a single value from the user Displaying messages such as errors, general information, warnings, and questions All these built-in dialogs are ready for you to use in your code directly. Most of them provide class methods to build specific types of dialogs depending on your needs. Along with these dialogs, PyQt provides the class. You can use this class to create your own dialogs in code, but you can also use Qt Designer to create your dialogs quickly. In the next few sections, you’ll learn how to create, lay out, and customize your dialogs using Qt Designer and its dialog templates. To create a custom dialog with Qt Designer, select the appropriate template for the dialog from the New Form dialog. Drag and drop the required widgets onto the form, lay out them correctly, and save the form in a file for later use in your application. Go back to your sample text editor and suppose you want to add a Find and Replace dialog like this: To create this dialog, start with the Dialog without Buttons template and add the required widgets to the form: Here, you first create an empty dialog using the Dialog without Buttons template and set the window title to Find and Replace in the Object Inspector. Then you drag and drop two objects onto the form using the Widget Box. These labels ask the users for the words they need to find and replace. Those words will be entered in the corresponding objects near the labels. Next, you drag and drop three objects onto the form. These buttons will allow your users to find and replace words in their current document. Finally, you add two objects to provide Match Case and Match Whole Word options. Once you have all the widgets on the form, make sure to place them in a position that’s similar to what you want to achieve in your final dialog. Now it’s time to lay out the widgets. As you saw before, to arrange the widgets in a form, you can use several layout managers. To lay out your Find and Replace dialog, use a grid layout for the labels, line edits, and checkboxes. For the buttons, use a vertical layout. Finally, use a horizontal layout as your dialog’s top-level layout manager: Here, you select the labels, line edits, and checkboxes with your mouse pointer and apply a grid layout to them. After that, you add a vertical spacer between the Replace and Cancel buttons to keep them visually separated. The final step is to set the dialog’s top-level layout. In this case, you use a horizontal layout manager. That’s it! You’ve built the GUI of your Find and Replace dialog with Qt Designer. Save it with the filename . There are a bunch of other properties and features that you can tweak in your dialogs using Qt Designer. For example, you can set the tab order of your input widget to improve the experience of users navigating your dialogs with their keyboard. You can also provide keyboard accelerators, connect signals and slots, and so on. So far, you’ve used Qt Designer in the Edit Widgets mode, which is its default mode. In this mode, you can add widgets to your forms, edit widget’s properties, lay out the widgets on the form, and so on. However, Qt Designer has up to four different modes to allow you to work on different features of your forms: Setting up the tab order of widgets You can also access these modes by clicking their corresponding buttons in the mode-related section of Qt Designer’s toolbar, which looks like this: To be able to edit the built-in signals and slots of your widgets and forms, you first need to switch to the Edit Signals/Slots mode. Note: In Qt, the term buddies refers to a special relationship between a label and a widget in which the label provides a keyboard accelerator or shortcut that allows you to access the buddy widget using your keyboard. User actions on widgets and forms, such as a click or a keypress, are known as events in PyQt. When an event occurs, the widget at hand emits a signal. This mechanism allows you to run actions in response to events. These actions are known as slots, which are methods or functions. To execute a slot in response to an event, you need to select one of the signals emitted by the widget in response to an event and connect it to the desired slot. Most widgets, including dialogs and windows, implement built-in signals that are emitted when a given event occurs on the widget. Widgets also provide built-in slots that allow you to perform certain standardized actions. To establish a signal-and-slot connection between two widgets using Qt Designer, you need to select the signal-provider widget with your mouse and then drag and drop it over the slot-provider widget. This launches Qt Designer’s Configure Connection dialog. Now go back to the Find and Replace dialog and switch to Qt Designer’s Edit Signals/Slots mode. Then drag and drop the Cancel button onto the form: The Configure Connection dialog has two panels. On the left panel, you can select a signal from the signal-provider widget, and on the right panel, you can select a slot from the slot-provider widget. To create the connection, press OK: The connection appears as an arrow from the signal-provider widget to the slot-provider widget, indicating that the connection is established. You’ll also see the name of the signal and the slot that you just connected. In this case, you connected the signal of the Cancel button with the slot of the dialog. Now when you click Cancel, your action will be ignored, and the dialog will close. To modify a connection, double-click the arrow or one of the labels. This displays the Configure Connection dialog, in which you can change the signal or the slot involved in the connection according to your needs. To delete a connection, select the arrow that represents the connection or one of the labels that identify the signal and slot, then press . To improve the usability of your dialogs, you can set a coherent tab order for your input widgets. The tab order is the order in which the widgets on your form come into focus when you press or + on your keyboard. If you’re using Qt Designer to create your forms, then the default tab order of your widgets is based on the order in which you place each widget on the form. Sometimes this order isn’t right, and when you hit or + , the focus jumps to an unexpected widget. Take a look at the tab order behavior in your Find and Replace dialog: The focus starts on the Find line edit, then it goes through the Replace line edit, then through the checkboxes, and finally through the buttons. What if you want the focus to jump from the Find line edit to the Replace line edit and then to the Find button? In this case, you can change the tab order of the input widgets on the dialog. Switch to Edit Tab Order mode in Qt Designer. You’ll see something like this: In Edit Tab Order mode, each input widget in the form shows a number that identifies its position in the tab-order chain. You can change that order by clicking on the numbers in the desired order: You change the tab order of the input widgets by clicking the numbers in the desired order. Note that when you select a number, it changes to red, indicating that this is the currently edited position in the tab-order chain. Numbers you haven’t set are shown in blue, and the numbers you have set are shown in green. If you make a mistake, then you can restart the ordering by choosing Restart from the form’s context menu. A keyboard accelerator is a key combination that you can press on your keyboard to quickly move the focus onto a given widget on a dialog or window. Normally, keyboard accelerators consist of the key and a letter that identifies the widget or option that you want to access. This can help you improve the usability of your applications. To define a keyboard accelerator on a widget that includes a label, such as a button or a checkbox, you just need to place an ampersand symbol ( ) before the letter in the label text that you want to use in the accelerator. For example, place an ampersand before the C on the Cancel button of your Find and Replace dialog, run a preview, and press + like in the following example: By placing an ampersand before the letter C in the text of the Cancel button, you create a keyboard accelerator. If you press + on your keyboard, then the Cancel button is selected and the dialog closes. To define a keyboard accelerator on a widget that doesn’t include a label, such as a line edit, you need to make that widget a buddy of a label object. There are four steps that you need to take if you want to create a buddy connection:\n• Select a letter in the text of the label to identify the buddy connection and provide the keyboard accelerator.\n• Place an ampersand ( ) before the selected letter in the text of the label.\n• Drag and drop the label onto the buddy widget. Here’s how you can create a buddy relationship between the Find label and its related line edit: To create a buddy relationship between a label and a widget, select the label with your mouse and drag it onto the input widget that you want to set as its buddy. The label and the input widget will become buddies. From this point on, you can press plus the selected letter in the label text to move the focus to the related widget. It’s important to note that you shouldn’t have two widgets with the same keyboard accelerator in a given form. This means that you need to select a unique letter for each keyboard accelerator. Go ahead and use Qt Designer to set keyboard accelerators for the widgets on your Find and Replace dialog. The final result should look like the dialog you saw at the beginning of the section Creating a Dialog GUI.\n\nIntegrating Windows and Dialogs in an Application Up to this point, you’ve learned how to create a GUI for your main windows and dialogs with Qt Designer. In this section, you’ll learn how to integrate those GUIs into your Python code and build a real application. There are two main approaches to do that in PyQt:\n• Translating the content of your files into Python code using\n• Loading the content of the files dynamically using The first approach uses , which is a tool included in the PyQt installation that allows you to translate the content of a file into Python code. This approach is widely used because of its efficiency. However, it has one drawback: every time you modify the GUI with Qt Designer, you need to generate the code again. The second approach takes advantage of to dynamically load the content of a file into your application. This approach is suitable when you’re working with small GUIs that don’t involve substantial loading time. Setting Up Windows and Dialogs for Use Now it’s time to set up your windows and dialogs for use in a real application (in this case, a sample text editor). If you’ve been following this tutorial, then you should have at least two files:\n• with the GUI of a sample text editor application\n• with the GUI of a Find and Replace dialog Go ahead and create a new directory called . Inside this directory, create another directory called and copy your files into it. Also, copy the directory that contains the icons for your menu options and toolbar buttons to the directory. So far, the structure of your application should look like this: Since the main-window GUI is relatively complex, you can use to translate the content of into Python code. You can download all the required code and resources to build your sample text editor by clicking the link below: Get the Source Code: Click here to get the source code you’ll use to learn about creating Python GUI applications with Qt Designer in this tutorial. Now open a terminal and navigate to the directory. Once you’re there, run the following command: This command generates a Python module called from the file and places it in your directory. This module contains the Python code for your main window’s GUI. Here’s a small sample of the code: # WARNING: Any manual changes made to this file will be lost when pyuic5 is # run again. Do not edit this file unless you know what you are doing. has all the code for generating the GUI of the sample editor’s main window. Note that contains the code to create all the required widgets and lay them out on the GUI. contains code for internationalization and localization, but this topic is beyond the scope of this tutorial. Note: If doesn’t work for you, then you need to check out your current PyQt installation. If you installed PyQt in a Python virtual environment, then you might need to activate the environment. You can also move to your virtual environment directory and run from there. Typically, you’ll find the application under the directory. If you have a system-wide installation of PyQt, then you should be able to run directly from your command line without needing to activate a virtual environment. Now your working directory should look like this: Since your Find and Replace dialog is quite small, you can load its GUI directly from your file using . This function takes a string with the path to a file as an argument and returns a subclass that implements the GUI. This way of loading files dynamically is rarely used in practice. You can use it with small dialogs that don’t require too much effort to load. With this approach, you don’t need to generate the Python code for the dialog’s GUI every time you modify the file with Qt Designer, which can be a productivity and maintainability win in some cases. Now that you’ve chosen a strategy for building each of your GUIs, it’s time to put everything together in a real application. Putting Everything Together in an Application With all the pieces in place for your sample text editor, you can create the application and write the required code to use the main window and the Find and Replace dialog. Fire up your favorite code editor or IDE in your directory and create a new file called . Add the following code to it: Here’s what this code does:\n• Line 3 imports the required PyQt classes to build the application and the GUI.\n• Line 6 imports from the module. This function provides a way of loading the content of a file dynamically.\n• Line 8 imports , which contains the GUI for your main window.\n• Line 10 defines , which will provide your application’s main window. In this case, the class uses multiple inheritance. It inherits the main window functionality from and the GUI functionality from .\n• Line 13 calls , which creates the whole GUI for your main window.\n• Line 16 defines , which connects the required signals and slots.\n• Line 21 defines . This method creates an instance of your Find and Replace dialog and execute it.\n• Line 25 defines , which creates and launches a small dialog to provide information about the application. In this case, you use a built-in dialog based on .\n• Line 35 defines , which provides the Find and Replace dialog.\n• Line 38 calls to load the dialog’s GUI from the files . Finally, on lines 41 to 44, you create the application, create and show the main window, and run the application’s main loop by calling on the application object. It’s important to note that Qt Designer can name your actions a bit differently from what you saw in the above code. For example, you might find the name instead of to refer to the Exit action. So, for this example to work properly, you need to make sure you’re using the right names. If you want to use your own names instead of the names that Qt Designer generates, then you can go to the Property Editor and change the property to the name that seems right for you. Note: You can also create using composition instead of multiple inheritance. For example, you can define and its initializer like this: In this case, you create , which is an instance of . From this point on, you need to use to access the widgets and objects on your main window’s GUI. If you run this application, then you’ll get the following window on your screen: That’s it! You’ve created a sample text editor with minimal functionality using Qt Designer. Note that to code this application, you wrote only forty-four lines of Python code, which is substantially less than what you’d need to write to hand code the GUI of an equivalent application from scratch."
    },
    {
        "link": "https://realpython.com/python-requests",
        "document": "The Requests library is the de facto standard for making HTTP requests in Python. It abstracts the complexities of making requests behind a beautiful, simple API so that you can focus on interacting with services and consuming data in your application.\n\nThroughout this tutorial, you’ll see some of the most useful features that Requests has to offer as well as ways to customize and optimize those features for different situations that you may come across. You’ll also learn how to use Requests in an efficient way as well as how to prevent requests to external services from slowing down your application.\n\nIn this tutorial, you’ll learn how to:\n• Make requests using the most common HTTP methods\n• Customize your requests’ headers and data using the query string and message body\n• Inspect data from your requests and responses\n• Configure your requests to help prevent your application from backing up or slowing down\n\nFor the best experience working through this tutorial, you should have basic general knowledge of HTTP. That said, you still may be able to follow along fine without it.\n\nIn the upcoming sections, you’ll see how you can install and use in your application. If you want to play with the code examples that you’ll see in this tutorial, as well as some additional ones, then you can download the code examples and work with them locally:\n\nEven though the Requests library is a common staple for many Python developers, it’s not included in Python’s standard library. There are good reasons for that decision, primarily that the library can continue to evolve more freely as a self-standing project. Note: Requests doesn’t support asynchronous HTTP requests directly. If you need async support in your program, you should try out AIOHTTP or HTTPX. The latter library is broadly compatible with Requests’ syntax. Because Requests is a third-party library, you need to install it before you can use it in your code. As a good practice, you should install external packages into a virtual environment, but you may choose to install into your global environment if you’re planning to use it across multiple projects. Whether you’re working in a virtual environment or not, you’ll need to install : Once has finished installing , you can use it in your application. Importing looks like this: Now that you’re all set up, it’s time to begin your journey through Requests. Your first goal will be learning how to make a request.\n\nA is a powerful object for inspecting the results of the request. Make that same request again, but this time store the return value in a variable so that you can get a closer look at its attributes and behaviors: In this example, you’ve captured the return value of , which is an instance of , and stored it in a variable called . You can now use to see a lot of information about the results of your request. The first bit of information that you can gather from is the status code. A status code informs you of the status of the request. For example, a status means that your request was successful, whereas a status means that the resource you were looking for wasn’t found. There are many other possible status codes as well to give you specific insights into what happened with your request. By accessing , you can see the status code that the server returned: returned , which means that your request was successful and the server responded with the data that you were requesting. Sometimes, you might want to use this information to make decisions in your code: With this logic, if the server returns a status code, then your program will print . If the result is a , then your program will print . Requests goes one step further in simplifying this process for you. If you use a instance in a conditional expression, then it’ll evaluate to if the status code was smaller than , and otherwise. Therefore, you can simplify the last example by rewriting the statement: In the code snippet above, you implicitly check whether the of is between and . If it’s not, then you raise an exception that includes the non-success status code in an f-string. Note: This truth value test is possible because is an overloaded method on . This means that the adapted default behavior of takes the status code into account when determining the truth value of the object. Keep in mind that this method is not verifying that the status code is equal to . The reason for this is that other status codes within the to range, such as and , are also considered successful in the sense that they provide some workable response. For example, the status code tells you that the response was successful, but there’s no content to return in the message body. So, make sure you use this convenient shorthand only if you want to know if the request was generally successful. Then, if necessary, you’ll need to handle the response appropriately based on the status code. Let’s say you don’t want to check the response’s status code in an statement. Instead, you want to use Request’s built-in capacities to raise an exception if the request was unsuccessful. You can do this using : If you invoke , then Requests will raise an for status codes between and . If the status code indicates a successful request, then the program will proceed without raising that exception. Now, you know a lot about how to deal with the status code of the response that you got back from the server. However, when you make a request, you rarely only care about the status code of the response. Usually, you want to see more. Next, you’ll see how to view the actual data that the server sent back in the body of the response. The response of a request often has some valuable information, known as a payload, in the message body. Using the attributes and methods of , you can view the payload in a variety of different formats. To see the response’s content in , you use : While gives you access to the raw bytes of the response payload, you’ll often want to convert them into a string using a character encoding such as UTF-8. will do that for you when you access : Because the decoding of to a requires an encoding scheme, Requests will try to guess the encoding based on the response’s headers if you don’t specify one. You can provide an explicit encoding by setting before accessing : If you take a look at the response, then you’ll see that it’s actually serialized JSON content. To get a dictionary, you could take the that you retrieved from and deserialize it using . However, a simpler way to accomplish this task is to use : The of the return value of is a dictionary, so you can access values in the object by key: You can do a lot with status codes and message bodies. But, if you need more information, like metadata about the response itself, then you’ll need to look at the response’s headers. The response headers can give you useful information, such as the content type of the response payload and a time limit on how long to cache the response. To view these headers, access : returns a dictionary-like object, allowing you to access header values by key. For example, to see the content type of the response payload, you can access : There’s something special about this dictionary-like headers object, though. The HTTP specification defines headers as case-insensitive, which means that you’re able to access these headers without worrying about their capitalization: Whether you use the key or , you’ll get the same value. Now that you’ve seen the most useful attributes and methods of in action, you already have a good overview of Requests’ basic usage. You can get content from the Internet and work with the response that you receive. But there’s more to the Internet than plain and straightforward URLs. In the next section, you’ll take a step back and see how your responses change when you customize your requests to account for query string parameters.\n\nAccording to the HTTP specification, , , and the less common requests pass their data through the message body rather than through parameters in the query string. Using Requests, you’ll pass the payload to the corresponding function’s parameter. takes a dictionary, a list of tuples, bytes, or a file-like object. You’ll want to adapt the data that send in the body of your request to the specific needs of the service that you’re interacting with. For example, if your request’s content type is , then you can send the form data as a dictionary: You can also send that same data as a list of tuples: If, however, you need to send JSON data, then you can use the parameter. When you pass JSON data via , Requests will serialize your data and add the correct header for you. Like you learned earlier, the httpbin service accepts test requests and responds with data about the requests. For instance, you can use it to inspect a basic request: You can see from the response that the server received your request data and headers as you sent them. Requests also provides this information to you in the form of a that you’ll inspect in more detail in the next section.\n\nAuthentication helps a service understand who you are. Typically, you provide your credentials to a server by passing data through the header or a custom header defined by the service. All the functions of Requests that you’ve seen to this point provide a parameter called , which allows you to pass your credentials: The request succeeds if the credentials that you pass in the tuple to are valid. When you pass your credentials in a tuple to the parameter, Requests applies the credentials using HTTP’s Basic access authentication scheme under the hood. You may wonder where the string that Requests set as the value for your header comes from. In short, it’s a Base64-encoded string of the username and password with the prefix :\n• First, Requests combines the username and password that you provided, putting a colon in between them. So for the username and password , this becomes .\n• Then, Requests encodes this string in Base64 using . The encoding converts the string to .\n• Finally, Requests adds in front of this Base64 string. This is how the final value for the header becomes in the example shown above. HTTP Basic authentication isn’t very secure, because you can decode the username and password from the Base64 string. That’s why it’s important to always send these requests over HTTPS, which provides an additional layer of security by encrypting the entire HTTP request. You could make the same request by passing explicit Basic authentication credentials using : Though you don’t need to be explicit for Basic authentication, you may want to authenticate using another method. Requests provides other methods of authentication out of the box, such as and . A real-world example of an API that requires authentication is GitHub’s authenticated user API. This endpoint provides information about the authenticated user’s profile. If you try to make a request without credentials, then you’ll see that the status code is : If you don’t provide authentication credentials when accessing a service that requires them, then you’ll get an HTTP error code as a response. To make a request to GitHub’s authenticated user API, you first need to generate a personal access token with the read:user scope. Then you can pass this token as the second element in a tuple to : Like you learned previously, this approach passes the credentials to , which expects a username and a password and sends the credentials as a Base64-encoded string with the prefix : This works, but it’s not the right way to authenticate with a Bearer token—and using an empty string input for the superfluous username is awkward. With Requests, you can supply your own authentication mechanism to fix that. To try this out, create a subclass of and implement : \"\"\"Attach an API token to the Authorization header.\"\"\" Here, your custom mechanism receives a token, then includes that token in the header of your request, also setting the recommended prefix to the string. You can now use this custom token authentication to make your call to GitHub’s authenticated user API: Your custom created a well-formatted string for the header. You can now use this more intuitive way of interacting with a token-based authentication scheme such as the one that parts of GitHub’s API require. Note: While you could construct the authentication string outside of a custom authentication class and pass it directly with , this appoach is discouraged because it can lead to unexpected behavior. When you attempt to set your authentication credentials directly using , then Requests may internally overwrite your input. This can happen, for example, if you have a file that provides authentication credentials. Requests will attempt to get the credentials from the file if you don’t provide an authentication method using . Bad authentication mechanisms can lead to security vulnerabilities. Unless a service requires a custom authentication mechanism for some reason, you’ll always want to use a tried-and-true auth scheme like the built-in Basic authentication or OAuth, for example through Requests-OAuthlib. While you’re thinking about security, consider dealing with SSL certificates using Requests.\n\nAnytime the data that you’re trying to send or receive is sensitive, security is important. The way that you communicate with secure sites over HTTP is by establishing an encrypted connection using SSL, which means that verifying the target server’s SSL certificate is critical. The good news is that Requests does this for you by default. However, there are some cases where you might want to change this behavior. If you want to disable SSL certificate verification, then you pass to the parameter of the request function: InsecureRequestWarning: Unverified HTTPS request is being made to host Requests even warns you when you’re making an insecure request to help you keep your data safe! Note: Requests uses a package called to provide certificate authorities. This lets Requests know which authorities it can trust. Therefore, you should update frequently to keep your connections as secure as possible. Now that you know how to make all sorts of HTTP requests using Requests, authenticated or not, you may wonder about how you can make sure that your program works as quickly as possible. In the next section, you’ll learn about a few ways that you can improve performance with the help of Requests.\n\nWhen using Requests, especially in a production application environment, it’s important to consider performance implications. Features like timeout control, sessions, and retry limits can help you keep your application running smoothly. When you make an inline request to an external service, your system will need to wait for the response before moving on. If your application waits too long for that response, requests to your service could back up, your user experience could suffer, or your background jobs could hang. By default, Requests will wait indefinitely on the response, so you should almost always specify a timeout duration to prevent these issues from happening. To set the request’s timeout, use the parameter. can be an integer or float representing the number of seconds to wait on a response before timing out: In the first request, the request will time out after 1 second. In the second request, the request will time out after 3.05 seconds. You can also pass a tuple to with the following two elements:\n• Connect timeout: The time it allows for the client to establish a connection to the server\n• Read timeout: The time it’ll wait on a response once your client has established a connection Both of these elements should be numbers, and can be of type or : If the request establishes a connection within 3.05 seconds and receives data within 5 seconds of the connection being established, then the response will be returned as it was before. If the request times out, then the function will raise a exception: \"The request did not time out\" Your program can catch the exception and respond accordingly. Until now, you’ve been dealing with high-level APIs such as and . These functions are abstractions of what’s going on when you make your requests. They hide implementation details, such as how connections are managed, so that you don’t have to worry about them. Underneath those abstractions is a class called . If you need to fine-tune your control over how requests are being made or improve the performance of your requests, you may need to use a instance directly. Sessions are used to persist parameters across requests. For example, if you want to use the same authentication across multiple requests, then you can use a session: In this code example, you use a context manager to ensure that the session releases the resources when it doesn’t need them anymore. In line 7, you log in using your custom . You only need to log in once per session, and then you can make multiple authenticated requests. Requests will persist the credentials while the session exists. You then make two requests to the authenticated user API in lines 9 and 10 using instead of . The primary performance optimization of sessions comes in the form of persistent connections. When your app makes a connection to a server using a , it keeps that connection around in a connection pool. When your app wants to connect to the same server again, it’ll reuse a connection from the pool rather than establishing a new one. When a request fails, you may want your application to retry the same request. However, Requests won’t do this for you by default. To apply this functionality, you need to implement a custom transport adapter. Transport adapters let you define a set of configurations for each service that you’re interacting with. For example, say you want all requests to to retry two times before finally raising a . You’d build a transport adapter, set its parameter, and mount it to an existing : In this example, you’ve set up your session so that it’ll retry a maximum of two times when your request to GitHub’s API doesn’t work as expected. When you mount the —in this case, —to , then will adhere to its configuration for each request to . Note: While the implementation shown above works, you won’t see any effect of the retry behavior unless there’s something wrong with your network connection or GitHub’s servers. If you want to play around with code that builds on top of this example, and you’d like to inspect when the retries happen, then you’re in luck. You can download the materials of this tutorial and take a look at : Get Your Code: Click here to download the free sample code that shows you how to use Python’s Requests library. The code in this file improves on the example shown above by using the underlying to further customize the retry functionality. It also adds logging to display debugging output, which gives you a chance to monitor when Python attempted the retries. Requests comes packaged with intuitive implementations for timeouts, transport adapters, and sessions that can help you keep your code efficient and your application resilient."
    },
    {
        "link": "https://requests.readthedocs.io/en/master/user/quickstart",
        "document": "Eager to get started? This page gives a good introduction in how to get started with Requests.\n\nFirst, make sure that:\n\nLet’s get started with some simple examples.\n\nMaking a request with Requests is very simple. Now, let’s try to get a webpage. For this example, let’s get GitHub’s public timeline: Now, we have a object called . We can get all the information we need from this object. Requests’ simple API means that all forms of HTTP request are as obvious. For example, this is how you make an HTTP POST request: Nice, right? What about the other HTTP request types: PUT, DELETE, HEAD and OPTIONS? These are all just as simple: That’s all well and good, but it’s also only the start of what Requests can do.\n\nYou often want to send some sort of data in the URL’s query string. If you were constructing the URL by hand, this data would be given as key/value pairs in the URL after a question mark, e.g. . Requests allows you to provide these arguments as a dictionary of strings, using the keyword argument. As an example, if you wanted to pass and to , you would use the following code: You can see that the URL has been correctly encoded by printing the URL: Note that any dictionary key whose value is will not be added to the URL’s query string. You can also pass a list of items as a value:\n\nWe can read the content of the server’s response. Consider the GitHub timeline again: Requests will automatically decode content from the server. Most unicode charsets are seamlessly decoded. When you make a request, Requests makes educated guesses about the encoding of the response based on the HTTP headers. The text encoding guessed by Requests is used when you access . You can find out what encoding Requests is using, and change it, using the property: If you change the encoding, Requests will use the new value of whenever you call . You might want to do this in any situation where you can apply special logic to work out what the encoding of the content will be. For example, HTML and XML have the ability to specify their encoding in their body. In situations like this, you should use to find the encoding, and then set . This will let you use with the correct encoding. Requests will also use custom encodings in the event that you need them. If you have created your own encoding and registered it with the module, you can simply use the codec name as the value of and Requests will handle the decoding for you.\n\nThere’s also a builtin JSON decoder, in case you’re dealing with JSON data: In case the JSON decoding fails, raises an exception. For example, if the response gets a 204 (No Content), or if the response contains invalid JSON, attempting raises . This wrapper exception provides interoperability for multiple exceptions that may be thrown by different python versions and json serialization libraries. It should be noted that the success of the call to does not indicate the success of the response. Some servers may return a JSON object in a failed response (e.g. error details with HTTP 500). Such JSON will be decoded and returned. To check that a request is successful, use or check is what you expect.\n\nIn the rare case that you’d like to get the raw socket response from the server, you can access . If you want to do this, make sure you set in your initial request. Once you do, you can do this: In general, however, you should use a pattern like this to save what is being streamed to a file: Using will handle a lot of what you would otherwise have to handle when using directly. When streaming a download, the above is the preferred and recommended way to retrieve the content. Note that can be freely adjusted to a number that may better fit your use cases. An important note about using versus . will automatically decode the and transfer-encodings. is a raw stream of bytes – it does not transform the response content. If you really need access to the bytes as they were returned, use .\n\nIf you’d like to add HTTP headers to a request, simply pass in a to the parameter. For example, we didn’t specify our user-agent in the previous example: Note: Custom headers are given less precedence than more specific sources of information. For instance:\n• None Authorization headers set with will be overridden if credentials are specified in , which in turn will be overridden by the parameter. Requests will search for the netrc file at , , or at the path specified by the environment variable.\n• None Authorization headers will be removed if you get redirected off-host.\n• None Proxy-Authorization headers will be overridden by proxy credentials provided in the URL.\n• None Content-Length headers will be overridden when we can determine the length of the content. Furthermore, Requests does not change its behavior at all based on which custom headers are specified. The headers are simply passed on into the final request. Note: All header values must be a , bytestring, or unicode. While permitted, it’s advised to avoid passing unicode header values.\n\nTypically, you want to send some form-encoded data — much like an HTML form. To do this, simply pass a dictionary to the argument. Your dictionary of data will automatically be form-encoded when the request is made: The argument can also have multiple values for each key. This can be done by making either a list of tuples or a dictionary with lists as values. This is particularly useful when the form has multiple elements that use the same key: There are times that you may want to send data that is not form-encoded. If you pass in a instead of a , that data will be posted directly. For example, the GitHub API v3 accepts JSON-Encoded POST/PATCH data: Please note that the above code will NOT add the header (so in particular it will NOT set it to ). If you need that header set and you don’t want to encode the yourself, you can also pass it directly using the parameter (added in version 2.4.2) and it will be encoded automatically: Note, the parameter is ignored if either or is passed.\n\nYou can set the filename, content_type and headers explicitly: If you want, you can send strings to be received as files: In the event you are posting a very large file as a request, you may want to stream the request. By default, does not support this, but there is a separate package which does - . You should read the toolbelt’s documentation for more details about how to use it. For sending multiple files in one request refer to the advanced section. It is strongly recommended that you open files in binary mode. This is because Requests may attempt to provide the header for you, and if it does this value will be set to the number of bytes in the file. Errors may occur if you open the file in text mode.\n\nWe can view the server’s response headers using a Python dictionary: The dictionary is special, though: it’s made just for HTTP headers. According to RFC 7230, HTTP Header names are case-insensitive. So, we can access the headers using any capitalization we want: It is also special in that the server could have sent the same header multiple times with different values, but requests combines them so they can be represented in the dictionary within a single mapping, as per RFC 7230: A recipient MAY combine multiple header fields with the same field name into one “field-name: field-value” pair, without changing the semantics of the message, by appending each subsequent field value to the combined field value in order, separated by a comma.\n\nYou can tell Requests to stop waiting for a response after a given number of seconds with the parameter. Nearly all production code should use this parameter in nearly all requests. Failure to do so can cause your program to hang indefinitely: is not a time limit on the entire response download; rather, an exception is raised if the server has not issued a response for seconds (more precisely, if no bytes have been received on the underlying socket for seconds). If no timeout is specified explicitly, requests do not time out.\n\nIn the event of a network problem (e.g. DNS failure, refused connection, etc), Requests will raise a exception. will raise an if the HTTP request returned an unsuccessful status code. If a request times out, a exception is raised. If a request exceeds the configured number of maximum redirections, a exception is raised. All exceptions that Requests explicitly raises inherit from . Ready for more? Check out the advanced section."
    },
    {
        "link": "https://requests.readthedocs.io",
        "document": "Requests is an elegant and simple HTTP library for Python, built for human beings.\n\nRequests allows you to send HTTP/1.1 requests extremely easily. There’s no need to manually add query strings to your URLs, or to form-encode your POST data. Keep-alive and HTTP connection pooling are 100% automatic, thanks to urllib3."
    },
    {
        "link": "https://apidog.com/blog/python-requests-response",
        "document": "Handling API requests and responses in Python can be a game-changer for your projects. Whether you're building a web application, a mobile app, or even a simple script, understanding how to interact with APIs is crucial. In this comprehensive guide, we'll dive deep into the world of Python requests and responses, giving you the tools you need to become an API master. And hey, don't forget to download Apidog for free - it will make your API development and testing a breeze!\n\nFirst things first, let's talk about what an API is. API stands for Application Programming Interface. It's a set of rules that allows different software entities to communicate with each other. Think of it as a waiter taking your order (your request) and bringing back your food (the response). APIs are everywhere – from weather apps to social media platforms.\n\nAPIs allow developers to access the functionality of other software programs. This can range from simple tasks, like fetching data from a web server, to more complex operations, like interacting with a machine learning model hosted on a cloud service.\n\nUsing APIs can save you a lot of time and effort. Instead of reinventing the wheel, you can leverage existing services and data. Plus, it allows your applications to be more versatile and integrated.\n\nBefore we dive in, here are some key terms you should know:\n• Endpoint: The URL where the API can be accessed.\n• Request: The message sent to the API to perform an action.\n• Response: The message the API sends back with the result of the request.\n• Status Code: A code that indicates the result of the request (e.g., 200 for success, 404 for not found).\n\nPython's library is a powerful tool for making HTTP requests. It's simple, yet very flexible, allowing you to interact with APIs effortlessly. Let's get started with installing the library.\n\nNow that we have the library installed, let's move on to making our first API request.\n\nTo make an API request, you'll need an API endpoint. For this example, we'll use the JSONPlaceholder API, a free fake online REST API for testing and prototyping.\n\nHere's a simple example of how to make a GET request:\n\nIn this example, we're sending a GET request to the endpoint. The function sends the request, and the response is stored in the variable. We then print the status code and the JSON response.\n\nThe response object contains all the information returned by the server. Here are some useful properties of the response object:\n• : The HTTP status code returned by the server.\n• : A method that parses the response body as JSON.\n\nSometimes, you'll need to send data to the API. This is where POST requests come in. Here's an example:\n\nIn this example, we're sending a POST request to the endpoint with some JSON data. The function sends the request, and the response is handled similarly to the GET request.\n\nNow that we've made some requests, let's talk about handling the responses. It's important to check the status code to ensure the request was successful.\n\nHere's a simple example of how to check the status code:\n\nIn this example, we're checking if the status code is , which indicates success. If the request was successful, we print the JSON response. Otherwise, we print an error message with the status code.\n\nMost APIs return data in JSON format. The method makes it easy to parse the JSON data. Here's an example:\n\nIn this example, we're parsing the JSON response and printing the and fields.\n\nError handling is crucial when working with APIs. You need to be prepared for various scenarios, such as network issues, invalid endpoints, and server errors.\n\nNetwork errors can occur when the server is unreachable or the connection is lost. The library provides built-in support for handling these errors using exceptions.\n\nIn this example, we're using a try-except block to catch different types of errors. The method raises an HTTPError if the status code is not 200.\n\nServer errors (status codes 500-599) indicate a problem on the server side. Here's an example of how to handle server errors:\n\nIn this example, we're checking if the status code is in the 500 range, which indicates a server error. We're also handling 404 (Not Found) and 400 (Bad Request) errors.\n\nNow that we've covered the basics, let's explore some advanced tips and tricks to make your life easier when working with APIs in Python.\n\nQuery parameters allow you to pass data to the API as part of the URL. Here's an example:\n\nIn this example, we're passing a parameter to the endpoint. The parameter of the function takes a dictionary of query parameters.\n\nHeaders are used to send additional information with the request. Here's an example:\n\nIn this example, we're setting the header to . The parameter of the function takes a dictionary of headers.\n\nMany APIs require authentication. The library supports various authentication methods, including Basic Auth and OAuth. Here's an example of how to use Basic Auth:\n\nIn this example, we're using Basic Auth to authenticate with the API. The parameter of the function takes an instance of .\n\nHow to Test Your Python POST Request\n\nApidog is a powerful tool for testing APIs. It allows you to create and save API requests, organize them into collections, and share them with your team.\n\nHere is how you can use Apidog to test your POST request:\n\n3. Enter the URL of the resource you want to update. Add any additional headers or parameters you want to include then click the “Send” button to send the request.\n\n4. Verify that the response is what you expected.\n\nIn this guide, we've covered the essentials of handling API requests and responses in Python. We've looked at making GET and POST requests, handling responses, and dealing with errors. We've also explored some advanced tips and tricks to make your life easier. Remember, APIs are a powerful tool that can open up a world of possibilities for your projects. So go ahead, experiment, and start building amazing things!\n\nAnd don't forget to download Apidog for free to streamline your API development and testing. Happy coding!"
    },
    {
        "link": "https://datacamp.com/tutorial/making-http-requests-in-python",
        "document": "Master the basics of data analysis with Python in just four hours. This online course will introduce the Python interface and explore popular packages."
    }
]