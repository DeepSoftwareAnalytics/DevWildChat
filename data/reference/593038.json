[
    {
        "link": "https://gnu.org/software/sed/manual/sed.html",
        "document": "is a stream editor. A stream editor is used to perform basic text transformations on an input stream (a file or input from a pipeline). While in some ways similar to an editor which permits scripted edits (such as ), works by making only one pass over the input(s), and is consequently more efficient. But it is ’s ability to filter text in a pipeline which particularly distinguishes it from other types of editors.\n\nThis chapter covers how to run . Details of scripts and individual commands are discussed in the next chapter.\n\nNormally is invoked like this:\n\nFor example, to replace all occurrences of ‘ ’ to ‘ ’ in the file :\n\nIf you do not specify , or if is , filters the contents of the standard input. The following commands are equivalent:\n\nwrites output to standard output. Use to edit files in-place instead of printing to standard output. See also the and commands for writing output to other files. The following command modifies and does not produce any output:\n\nBy default prints all processed input (except input that has been modified/deleted by commands such as ). Use to suppress output, and the command to print specific lines. The following command prints only line 45 of the input file:\n\ntreats multiple input files as one long stream. The following example prints the first line of the first file ( ) and the last line of the last file ( ). Use to reverse this behavior.\n\nWithout or options, uses the first non-option parameter as the , and the following non-option parameters as input files. If or options are used to specify a , all non-option parameters are taken as input files. Options and can be combined, and can appear multiple times (in which case the final effective will be concatenation of all the individual s).\n\nThe following examples are equivalent:\n\nThe full format for invoking is:\n\nmay be invoked with the following command-line options:\n\nIf no , , , or options are given on the command-line, then the first non-option argument on the command line is taken to be the to be executed.\n\nIf any command-line parameters remain after processing the above, these parameters are interpreted as the names of input files to be processed. A file name of ‘ ’ refers to the standard input stream. The standard input will be processed if no file names are specified.\n\nAn exit status of zero indicates success, and a nonzero value indicates failure. GNU returns the following exit status error values:\n\nAdditionally, the commands and can be used to terminate with a custom exit code value (this is a GNU extension):\n\nA program consists of one or more commands, passed in by one or more of the , , , and options, or the first non-option argument if zero of these options are used. This document will refer to “the” script; this is understood to mean the in-order concatenation of all of the s and s passed in. See Overview.\n\nis a single-letter command. is an optional line address. If is specified, the command will be executed only on the matched lines. can be a single line number, a regular expression, or a range of lines (see sed addresses). Additional are used for some commands.\n\nThe following example deletes lines 30 to 35 in the input. is an address range. is the delete command:\n\nThe following example prints all input until a line starting with the word ‘ ’ is found. If such line is found, will terminate with exit status 42. If such line was not found (and no other error occurred), will exit with status 0. is a regular-expression address. is the quit command. is the command option.\n\nCommands within a or can be separated by semicolons ( ) or newlines (ASCII 10). Multiple scripts can be specified with or options.\n\nThe following examples are all equivalent. They perform two operations: deleting any lines matching the regular expression , and replacing all occurrences of the string ‘ ’ with ‘ ’:\n\nCommands , , , due to their syntax, cannot be followed by semicolons working as command separators and thus should be terminated with newlines or be placed at the end of a or . Commands can also be preceded with optional non-significant whitespace characters. See Multiple commands syntax.\n\nThe following commands are supported in GNU . Some are standard POSIX commands, while other are GNU extensions. Details and examples for each command are in the following sections. (Mnemonics) are shown in parentheses.\n\nThe command (as in substitute) is probably the most important in and has a lot of different options. The syntax of the command is ‘ ’.\n\nIts basic concept is simple: the command attempts to match the pattern space against the supplied regular expression ; if the match is successful, then that portion of the pattern space which was matched is replaced with .\n\nFor details about syntax see Regular Expression Addresses.\n\nThe can contain ( being a number from 1 to 9, inclusive) references, which refer to the portion of the match which is contained between the th and its matching . Also, the can contain unescaped characters which reference the whole matched portion of the pattern space.\n\nThe characters may be uniformly replaced by any other single character within any given command. The character (or whatever other character is used in its stead) can appear in the or only if it is preceded by a character.\n\nFinally, as a GNU extension, you can include a special sequence made of a backslash and one of the letters , , , , or . The meaning is as follows:\n\nWhen the flag is being used, case conversion does not propagate from one occurrence of the regular expression to another. For example, when the following command is executed with ‘ ’ in pattern space:\n\nthe output is ‘ ’. When replacing the first ‘ ’, the ‘ ’ sequence only affects the empty replacement of ‘ ’. It does not affect the character that is added to pattern space when replacing with .\n\nOn the other hand, and do affect the remainder of the replacement text if they are followed by an empty substitution. With ‘ ’ in pattern space, the following command:\n\nwill replace ‘ ’ with ‘ ’ (uppercase) and ‘ ’ with ‘ ’. If this behavior is undesirable, you can prevent it by adding a ‘ ’ sequence—after ‘ ’ in this case.\n\nTo include a literal , , or newline in the final replacement, be sure to precede the desired , , or newline in the with a .\n\nThe command can be followed by zero or more of the following :\n\nIf you use at all, you will quite likely want to know these commands.\n\nThough perhaps less frequently used than those in the previous section, some very small yet useful scripts can be built with these commands.\n\nIn most cases, use of these commands indicates that you are probably better off programming in something like or Perl. But occasionally one is committed to sticking with , and these commands can enable one to write quite convoluted scripts.\n\nThese commands are specific to GNU , so you must use them with care and only when you are sure that hindering portability is not evil. They allow you to check for GNU extensions or to do tasks that are required quite often, yet are unsupported by standard s.\n\nThere are several methods to specify multiple commands in a program.\n\nUsing newlines is most natural when running a sed script from a file (using the option).\n\nOn the command line, all commands may be separated by newlines. Alternatively, you may specify each command as an argument to an option:\n\nA semicolon (‘ ’) may be used to separate most simple commands:\n\nThe , , , , , commands can be separated with a semicolon (this is a non-portable GNU extension).\n\nLabels used in , , , commands are read until a semicolon. Leading and trailing whitespace is ignored. In the examples below the label is ‘ ’. The first example works with GNU . The second is a portable equivalent. For more information about branching and labels see Branching and flow control.\n\nThe following commands cannot be separated by a semicolon and require a newline:\n\nAddresses determine on which line(s) the command will be executed. The following command replaces the word ‘ ’ with ‘ ’ only on line 144:\n\nIf no addresses are given, the command is performed on all lines. The following command replaces the word ‘ ’ with ‘ ’ on all lines in the input file:\n\nAddresses can contain regular expressions to match lines based on content instead of line numbers. The following command replaces the word ‘ ’ with ‘ ’ only in lines containing the word ‘ ’:\n\nAn address range is specified with two addresses separated by a comma ( ). Addresses can be numeric, regular expressions, or a mix of both. The following command replaces the word ‘ ’ with ‘ ’ only in lines 4 to 17 (inclusive):\n\nAppending the character to the end of an address specification (before the command letter) negates the sense of the match. That is, if the character follows an address or an address range, then only lines which do not match the addresses will be selected. The following command replaces the word ‘ ’ with ‘ ’ only in lines not containing the word ‘ ’:\n\nThe following command replaces the word ‘ ’ with ‘ ’ only in lines 1 to 3 and 18 till the last line of the input file (i.e. excluding lines 4 to 17):\n\nAddresses in a script can be in any of the following forms:\n\nGNU supports the following regular expression addresses. The default regular expression is Basic Regular Expression (BRE). If or options are used, The regular expression should be in Extended Regular Expression (ERE) syntax. See BRE vs ERE.\n\nRegex addresses operate on the content of the current pattern space. If the pattern space is changed (for example with command) the regular expression matching will operate on the changed text.\n\nIn the following example, automatic printing is disabled with . The command changes lines containing ‘ ’ to ‘ ’. The command matches lines with digits and prints them. Because the second line is changed before the regex, it will not match and will not be printed:\n\nAn address range can be specified by specifying two addresses separated by a comma ( ). An address range matches lines starting from where the first address matches, and continues until the second address matches (inclusively):\n\nIf the second address is a , then checking for the ending match will start with the line following the line which matched the first address: a range will always span at least two lines (except of course if the input stream ends).\n\nIf the second address is a less than (or equal to) the line matching the first address, then only the one line is matched:\n\nGNU also supports some special two-address forms; all these are GNU extensions:\n\nTo know how to use , people should understand regular expressions (regexp for short). A regular expression is a pattern that is matched against a subject string from left to right. Most characters are ordinary: they stand for themselves in a pattern, and match the corresponding characters. Regular expressions in are specified between two slashes.\n\nThe following command prints lines containing the word ‘ ’:\n\nThe above example is equivalent to this command:\n\nThe power of regular expressions comes from the ability to include alternatives and repetitions in the pattern. These are encoded in the pattern by the use of special characters, which do not stand for themselves but instead are interpreted in some special way.\n\nThe character (caret) in a regular expression matches the beginning of the line. The character (dot) matches any single character. The following command matches and prints lines which start with the letter ‘ ’, followed by any single character, followed by the letter ‘ ’:\n\nThe following sections explain the meaning and usage of special characters in regular expressions.\n\nBasic and extended regular expressions are two variations on the syntax of the specified pattern. Basic Regular Expression (BRE) syntax is the default in (and similarly in ). Use the POSIX-specified option ( , ) to enable Extended Regular Expression (ERE) syntax.\n\nIn GNU , the only difference between basic and extended regular expressions is in the behavior of a few special characters: ‘ ’, ‘ ’, parentheses, braces (‘ ’), and ‘ ’.\n\nWith basic (BRE) syntax, these characters do not have special meaning unless prefixed with a backslash (‘ ’); While with extended (ERE) syntax it is reversed: these characters are special unless they are prefixed with backslash (‘ ’).\n\nHere is a brief description of regular expression syntax as used in .\n\nNote that the regular expression matcher is greedy, i.e., matches are attempted from left to right and, if two or more matches are possible starting at the same character, it selects the longest.\n\nThe only difference between basic and extended regular expressions is in the behavior of a few characters: ‘ ’, ‘ ’, parentheses, braces (‘ ’), and ‘ ’. While basic regular expressions require these to be escaped if you want them to behave as special characters, when using extended regular expressions you must escape them if you want them to match a literal character. ‘ ’ is special here because ‘ ’ is a GNU extension – standard basic regular expressions do not provide its functionality.\n\nA bracket expression is a list of characters enclosed by ‘ ’ and ‘ ’. It matches any single character in that list; if the first character of the list is the caret ‘ ’, then it matches any character not in the list. For example, the following command replaces the words ‘ ’ or ‘ ’ with ‘ ’:\n\nBracket expressions can be used in both basic and extended regular expressions (that is, with or without the / options).\n\nWithin a bracket expression, a range expression consists of two characters separated by a hyphen. It matches any single character that sorts between the two characters, inclusive. In the default C locale, the sorting sequence is the native character order; for example, ‘ ’ is equivalent to ‘ ’.\n\nFinally, certain named classes of characters are predefined within bracket expressions, as follows.\n\nThese named classes must be used inside brackets themselves. Correct usage:\n\nIncorrect usage is rejected by newer versions. Older versions accepted it but treated it as a single bracket expression (which is equivalent to ‘ ’, that is, only the characters ):\n\nNote that the brackets in these class names are part of the symbolic names, and must be included in addition to the brackets delimiting the bracket expression.\n\nThe characters , , , , and are normally not special within . For example, matches either ‘ ’ or ‘ ’, because the is not special here. However, strings like , , and are special within and represent collating symbols, equivalence classes, and character classes, respectively, and is therefore special within when it is followed by , , or . Also, when not in mode, special escapes like and are recognized within . See Escapes.\n\nThe following sequences have special meaning inside regular expressions (used in addresses and the command).\n\nThese can be used in both basic and extended regular expressions (that is, with or without the / options).\n\nback-references are regular expression commands which refer to a previous part of the matched regular expression. Back-references are specified with backslash and a single digit (e.g. ‘ ’). The part of the regular expression they refer to is called a subexpression, and is designated with parentheses.\n\nBack-references and subexpressions are used in two cases: in the regular expression search pattern, and in the part of the command (see Regular Expression Addresses and The \"s\" Command).\n\nIn a regular expression pattern, back-references are used to match the same content as a previously matched subexpression. In the following example, the subexpression is ‘ ’ - any single character (being surrounded by parentheses makes it a subexpression). The back-reference ‘ ’ asks to match the same content (same character) as the sub-expression.\n\nThe command below matches words starting with any character, followed by the letter ‘ ’, followed by the same character as the first.\n\nMultiple subexpressions are automatically numbered from left-to-right. This command searches for 6-letter palindromes (the first three letters are 3 subexpressions, followed by 3 back-references in reverse order):\n\nIn the command, back-references can be used in the part to refer back to subexpressions in the part.\n\nThe following example uses two subexpressions in the regular expression to match two space-separated words. The back-references in the part prints the words in a different order:\n\nWhen used with alternation, if the group does not participate in the match then the back-reference makes the whole match fail. For example, ‘ ’ will not match ‘ ’. When multiple regular expressions are given with or from a file (‘ ’), back-references are local to each expression.\n\nUntil this chapter, we have only encountered escapes of the form ‘ ’, which tell not to interpret the circumflex as a special character, but rather to take it literally. For example, ‘ ’ matches a single asterisk rather than zero or more backslashes.\n\nThis chapter introduces another kind of escape6—that is, escapes that are applied to a character or sequence of characters that ordinarily are taken literally, and that replaces with a special character. This provides a way of encoding non-printable characters in patterns in a visible manner. There is no restriction on the appearance of non-printing characters in a script but when a script is being prepared in the shell or by text editing, it is usually easier to use one of the following escape sequences than the binary character it represents:\n\nThe list of these escapes is:\n\n‘ ’ (backspace) was omitted because of the conflict with the existing “word boundary” meaning.\n\nGNU processes escape sequences before passing the text onto the regular-expression matching of the command and Address matching. Thus the follwing two commands are equivalent (‘ ’ is the hexadecimal ASCII value of the character ‘ ’):\n\nAs are the following (‘ ’,‘ ’ are the hexadecimal ASCII values of ‘ ’,‘ ’, respectively):\n\nHowever it is recommended to avoid such special characters due to unexpected edge-cases. For example, the following are not equivalent:\n\nThe following example uses the Greek letter Capital Sigma (Σ, Unicode code point ). In a locale, correctly processes the Sigma as one character despite it being 2 octets (bytes):\n\nTo force to process octets separately, use the locale (also known as the locale):\n\n’s regular expressions do not match invalid multibyte sequences in a multibyte locale.\n\nIn the following examples, the ascii value is an incomplete multibyte character (shown here as �). The regular expression ‘ ’ does not match it:\n\nSimilarly, the ’catch-all’ regular expression ‘ ’ does not match the entire line:\n\nGNU offers the special command to clear the current pattern space regardless of invalid multibyte characters (i.e. it works like but also removes invalid multibyte characters):\n\nAlternatively, force the locale to process each octet separately (every octet is a valid character in the locale):\n\n’s inability to process invalid multibyte characters can be used to detect such invalid sequences in a file. In the following examples, the is an invalid multibyte sequence, while is a valid multibyte sequence (of the Greek Sigma character).\n\nThe following program removes all valid characters using . Any content left in the pattern space (the invalid characters) are added to the hold space using the command. On the last line ( ), the hold space is retrieved ( ), newlines are removed ( ), and any remaining octets are printed unambiguously ( ). Thus, any invalid multibyte sequences are printed as octal values:\n\nWith a few more commands, can print the exact line number corresponding to each invalid characters (line 3). These characters can then be removed by forcing the locale and using octal escape sequences:\n\nIn other locales, the sorting sequence is not specified, and ‘ ’ might be equivalent to ‘ ’ or to ‘ ’, or it might fail to match any character, or the set of characters that it matches might even be erratic. To obtain the traditional interpretation of bracket expressions, you can use the ‘ ’ locale by setting the environment variable to the value ‘ ’.\n\nTheir interpretation depends on the locale; for example, ‘ ’ means the character class of numbers and letters in the current locale.\n\nmaintains two data buffers: the active pattern space, and the auxiliary hold space. Both are initially empty.\n\noperates by performing the following cycle on each line of input: first, reads one line from the input stream, removes any trailing newline, and places it in the pattern space. Then commands are executed; each command can have an address associated to it: addresses are a kind of condition code, and a command is only executed if the condition is verified before the command is to be executed.\n\nWhen the end of the script is reached, unless the option is in use, the contents of pattern space are printed out to the output stream, adding back the trailing newline if it was removed.8 Then the next cycle starts for the next input line.\n\nUnless special commands (like ‘ ’) are used, the pattern space is deleted between two cycles. The hold space, on the other hand, keeps its data between cycles (see commands ‘ ’, ‘ ’, ‘ ’, ‘ ’, ‘ ’ to move data between both buffers).\n\nMultiple lines can be processed as one buffer using the , , , , . They are similar to their lowercase counterparts ( , , , , ), except that these commands append or subtract data while respecting embedded newlines - allowing adding and removing lines from the pattern and hold spaces.\n\nThey operate as follows:\n\nThe following example illustrates the operation of and commands:\n• starts by reading the first line into the pattern space (i.e. ‘ ’).\n• At the beginning of every cycle, the command appends a newline and the next line to the pattern space (i.e. ‘ ’, ‘ ’, ‘ ’ in the first cycle).\n• The command prints the content of the pattern space unambiguously.\n• The command then removes the content of pattern space up to the first newline (leaving ‘ ’ at the end of the first cycle).\n• At the next cycle the command appends a newline and the next input line to the pattern space (e.g. ‘ ’, ‘ ’, ‘ ’).\n\nA common technique to process blocks of text such as paragraphs (instead of line-by-line) is using the following construct:\n• The first expression, operates on all non-empty lines, and adds the current line (in the pattern space) to the hold space. On all lines except the last, the pattern space is deleted and the cycle is restarted.\n• The other expressions and are executed only on empty lines (i.e. paragraph separators). The command fetches the accumulated lines from the hold space back to the pattern space. The command then operates on all the text in the paragraph (including the embedded newlines).\n\nThe following example demonstrates this technique:\n\nFor more annotated examples, see Text search across multiple lines and Line length adjustment.\n\nThe branching commands , , and enable changing the flow of programs.\n\nBy default, reads an input line into the pattern buffer, then continues to processes all commands in order. Commands without addresses affect all lines. Commands with addresses affect only matching lines. See Execution Cycle and Addresses overview.\n\ndoes not support a typical construct. Instead, some commands can be used as conditionals or to change the default flow control:\n\nThe following two programs are equivalent. The first (contrived) example uses the command to skip the command on lines containing ‘ ’. The second example uses an address with negation (‘ ’) to perform substitution only on desired lines. The command is still executed on all lines:\n\nThe , and commands can be followed by a label (typically a single letter). Labels are defined with a colon followed by one or more letters (e.g. ‘ ’). If the label is omitted the branch commands restart the cycle. Note the difference between branching to a label and restarting the cycle: when a cycle is restarted, first prints the current content of the pattern space, then reads the next input line into the pattern space; Jumping to a label (even if it is at the beginning of the program) does not print the pattern space and does not read the next input line.\n\nThe following program is a no-op. The command (the only command in the program) does not have a label, and thus simply restarts the cycle. On each cycle, the pattern space is printed and the next input line is read:\n\nThe following example is an infinite-loop - it doesn’t terminate and doesn’t print anything. The command jumps to the ‘ ’ label, and a new cycle is never started:\n\nBranching is often complemented with the or commands: both commands read the next input line into the pattern space without waiting for the cycle to restart. Before reading the next input line, prints the current pattern space then empties it, while appends a newline and the next input line to the pattern space.\n\nConsider the following two examples:\n• Both examples do not inf-loop, despite never starting a new cycle.\n• In the first example, the commands first prints the content of the pattern space, empties the pattern space then reads the next input line.\n• In the second example, the commands appends the next input line to the pattern space (with a newline). Lines are accumulated in the pattern space until there are no more input lines to read, then the command terminates the program. When the program terminates, the end-of-cycle actions are performed, and the entire pattern space is printed.\n• The second example requires GNU , because it uses the non-POSIX-standard behavior of . See the “ command on the last line” paragraph in Reporting Bugs.\n• To further examine the difference between the two examples, try the following commands:\n\nAs a real-world example of using branching, consider the case of quoted-printable files, typically used to encode email messages. In these files long lines are split and marked with a soft line break consisting of a single ‘ ’ character at the end of the line:\n\nThe following program uses an address match ‘ ’ as a conditional: If the current pattern space ends with a ‘ ’, it reads the next input line using , replaces all ‘ ’ characters which are followed by a newline, and unconditionally branches ( ) to the beginning of the program without restarting a new cycle. If the pattern space does not ends with ‘ ’, the default action is performed: the pattern space is printed and a new cycle is started:\n\nHere’s an alternative program with a slightly different approach: On all lines except the last, appends the line to the pattern space. A substitution command then removes soft line breaks (‘ ’ at the end of a line, i.e. followed by a newline) by replacing them with an empty string. if the substitution was successful (meaning the pattern space contained a line which should be joined), The conditional branch command jumps to the beginning of the program without completing or restarting the cycle. If the substitution failed (meaning there were no soft line breaks), The command will not branch. Then, will print the pattern space content until the first newline, and will delete the pattern space content until the first new line. (To learn more about , and commands see Multiline techniques).\n\nFor more line-joining examples see Joining lines.\n\nHere are some scripts to guide you in the art of mastering .\n\nThis section uses , and commands to process multiple lines, and the and commands for branching. See Multiline techniques and Branching and flow control.\n\nJoin specific lines (e.g. if lines 2 and 3 need to be joined):\n\nThis script centers all lines of a file on a 80 columns width. To change that width, the number in must be replaced, and the number of added spaces also must be changed.\n\nNote how the buffer commands are used to separate parts in the regular expressions to be matched—this is a common technique.\n\nThis script is one of a few that demonstrate how to do arithmetic in . This is indeed possible,9 but must be done manually.\n\nTo increment one number you just add 1 to last digit, replacing it by the following digit. There is one exception: when the digit is a nine the previous digits must be also incremented until you don’t have a nine.\n\nThis solution by Bruno Haible is very clever and smart because it uses a single buffer; if you don’t have this limitation, the algorithm used in Numbering lines, is faster. It works by replacing trailing nines with an underscore, then using multiple commands to increment the last digit, and then again substituting underscores with zeros.\n\nThis is a pretty strange use of . We transform text, and transform it to be shell commands, then just feed them to shell. Don’t worry, even worse hacks are done when using ; I have seen a script converting the output of into a program!\n\nThe main body of this is the script, which remaps the name from lower to upper (or vice-versa) and even checks out if the remapped name is the same as the original name. Note how the script is parameterized using shell variables and proper quoting.\n\nThis script strips the definition of the shell functions from the output of the Bourne-shell command.\n\nThis script can be used to reverse the position of characters in lines. The technique moves two characters at a time, hence it is faster than more intuitive implementations.\n\nNote the command before the definition of the label. This is often needed to reset the flag that is tested by the command.\n\nImaginative readers will find uses for this script. An example is reversing the output of .10\n\nThis section uses and commands to search for consecutive words spanning multiple lines. See Multiline techniques.\n\nThese examples deal with finding doubled occurrences of words in a document.\n\nFinding doubled words in a single line is easy using GNU and similarly with GNU :\n• The regular expression ‘ ’ searches for word-boundary (‘ ’), followed by one-or-more word-characters (‘ ’), followed by whitespace (‘ ’). See regexp extensions.\n• Adding parentheses around the ‘ ’ expression creates a subexpression. The regular expression pattern ‘ ’ defines a subexpression (in the parentheses) followed by a back-reference, separated by whitespace. A successful match means the was repeated twice in succession. See Back-references and Subexpressions.\n• The word-boundery expression (‘ ’) at both ends ensures partial words are not matched (e.g. ‘ ’ is not a desired match).\n• The option enables extended regular expression syntax, alleviating the need to add backslashes before the parenthesis. See ERE syntax.\n\nWhen the doubled word span two lines the above regular expression will not find them as and operate line-by-line.\n\nBy using and commands, can apply regular expressions on multiple lines (that is, multiple lines are stored in the pattern space, and the regular expression works on it):\n• The command appends the next line to the pattern space (thus ensuring it contains two consecutive lines in every cycle).\n• The regular expression uses ‘ ’ for word separator which matches both spaces and newlines.\n• The regular expression matches, the entire pattern space is printed with . No lines are printed by default due to the option.\n• The removes the first line from the pattern space (up until the first newline), readying it for the next cycle.\n\nSee the GNU manual for an alternative solution using and at https://gnu.org/s/coreutils/manual/html_node/Squeezing-and-deleting.html.\n\nThis section uses and commands to search for consecutive words spanning multiple lines, and the command for branching. See Multiline techniques and Branching and flow control.\n\nThis (somewhat contrived) example deal with formatting and wrapping lines of text of the following input file:\n\nThe following sed program wraps lines at 40 characters:\n\nThis one begins a series of totally useless (yet interesting) scripts emulating various Unix commands. This, in particular, is a workalike.\n\nNote that on implementations other than GNU this script might easily overflow internal buffers.\n\nThis script replaces ‘ ’; in fact it formats its output exactly like GNU does.\n\nOf course this is completely useless and for two reasons: first, because somebody else did it in C, second, because the following Bourne-shell script could be used for the same purpose and would be much faster:\n\nIt uses to print the line number, then groups lines two by two using . Of course, this script does not teach as much as the one presented below.\n\nThe algorithm used for incrementing uses both buffers, so the line is printed as soon as possible and then discarded. The number is split so that changing digits go in a buffer and unchanged ones go in the other; the changed digits are modified in a single step (using a command). The line number for the next line is then composed and stored in the hold space, to be used in the next iteration.\n\nEmulating ‘ ’ is almost the same as ‘ ’—we only have to select which lines are to be numbered and which are not.\n\nThe part that is common to this script and the previous one is not commented to show how important it is to comment scripts properly...\n\nThis script shows another way to do arithmetic with . In this case we have to add possibly large numbers, so implementing this by successive increments would not be feasible (and possibly even more complicated to contrive than this script).\n\nThe approach is to map numbers to letters, kind of an abacus implemented with . ‘ ’s are units, ‘ ’s are tens and so on: we simply add the number of characters on the current line as units, and then propagate the carry to tens, hundreds, and so on.\n\nAs usual, running totals are kept in hold space.\n\nOn the last line, we convert the abacus form back to decimal. For the sake of variety, this is done with a loop rather than with some 80 commands11: first we convert units, removing ‘ ’s from the number; then we rotate letters so that tens become ‘ ’s, and so on until no more letters remain.\n\nThis script is almost the same as the previous one, once each of the words on the line is converted to a single ‘ ’ (in the previous script each letter was changed to an ‘ ’).\n\nIt is interesting that real programs have optimized loops for ‘ ’, so they are much slower at counting words rather than characters. This script’s bottleneck, instead, is arithmetic, and hence the word-counting one is faster (it has to manage smaller numbers).\n\nAgain, the common parts are not commented to show the importance of commenting scripts.\n\nNo strange things are done now, because gives us ‘ ’ functionality for free!!! Look:\n\nThis script is probably the simplest useful script. It displays the first 10 lines of input; the number of displayed lines is right before the command.\n\nPrinting the last lines rather than the first is more complex but indeed possible. is encoded in the second line, before the bang character.\n\nThis script is similar to the script in that it keeps the final output in the hold space and prints it at the end:\n\nMainly, the scripts keeps a window of 10 lines and slides it by adding a line and deleting the oldest (the substitution command on the second line works like a command but does not restart the loop).\n\nThe “sliding window” technique is a very powerful way to write efficient and complex scripts, because commands like would require a lot of work if implemented manually.\n\nTo introduce the technique, which is fully demonstrated in the rest of this chapter and is based on the , and commands, here is an implementation of using a simple “sliding window.”\n\nThis looks complicated but in fact the working is the same as the last script: after we have kicked in the appropriate number of lines, however, we stop using the hold space to keep inter-line state, and instead use and to slide pattern space by one line:\n\nNote how the first, second and fourth line are inactive after the first ten lines of input. After that, all the script does is: exiting on the last line of input, appending the next input line to pattern space, and removing the first line.\n\nThis is an example of the art of using the , and commands, probably the most difficult to master.\n\nAs you can see, we maintain a 2-line window using and . This technique is often used in advanced scripts.\n\nThis script prints only duplicated lines, like ‘ ’.\n\nThis script prints only unique lines, like ‘ ’.\n\nAs a final example, here are three scripts, of increasing complexity and speed, that implement the same function as ‘ ’, that is squeezing blank lines.\n\nThe first leaves a blank line at the beginning and end if there are some already.\n\nThis one is a bit more complex and removes all empty lines at the beginning. It does leave a single blank line at end if one was there.\n\nThis removes leading and trailing blank lines. It is also the fastest. Note that loops are completely done with and , without relying on to restart the script automatically at the end of a line.\n\nFor those who want to write portable scripts, be aware that some implementations have been known to limit line lengths (for the pattern and hold spaces) to be no more than 4000 bytes. The POSIX standard specifies that conforming implementations shall support at least 8192 byte line lengths. GNU has no built-in limit on line length; as long as it can more (virtual) memory, you can feed or construct lines as long as you like.\n\nHowever, recursion is used to handle subpatterns and indefinite repetition. This means that the available stack space may limit the size of the buffer that can be processed by certain patterns.\n\n9 Other Resources for Learning About\n\nFor up to date information about GNU please visit https://www.gnu.org/software/sed/.\n\nSend general questions and suggestions to sed-devel@gnu.org. Visit the mailing list archives for past discussions at https://lists.gnu.org/archive/html/sed-devel/.\n\nThe following resources provide information about (both GNU and other variations). Note these not maintained by GNU developers.\n• The mailing list maintained by Sven Guckes: http://groups.yahoo.com/group/sed-users/ (note this is not the GNU mailing list).\n\nEmail bug reports to bug-sed@gnu.org. Also, please include the output of ‘ ’ in the body of your report if at all possible.\n\nPlease do not send a bug report like this:\n\nIf GNU doesn’t configure your favorite package, take a few extra minutes to identify the specific problem and make a stand-alone test case. Unlike other programs such as C compilers, making such test cases for is quite simple.\n\nA stand-alone test case includes all the data necessary to perform the test, and the specific invocation of that causes the problem. The smaller a stand-alone test case is, the better. A test case should not involve something as far removed from as “try to configure frobme-1.3.4”. Yes, that is in principle enough information to look for the bug, but that is not a very practical prospect.\n\nHere are a few commonly reported bugs that are not bugs.\n• PREAMBLE The purpose of this License is to make a manual, textbook, or other functional and useful document free in the sense of freedom: to assure everyone the effective freedom to copy and redistribute it, with or without modifying it, either commercially or noncommercially. Secondarily, this License preserves for the author and publisher a way to get credit for their work, while not being considered responsible for modifications made by others. This License is a kind of “copyleft”, which means that derivative works of the document must themselves be free in the same sense. It complements the GNU General Public License, which is a copyleft license designed for free software. We have designed this License in order to use it for manuals for free software, because free software needs free documentation: a free program should come with manuals providing the same freedoms that the software does. But this License is not limited to software manuals; it can be used for any textual work, regardless of subject matter or whether it is published as a printed book. We recommend this License principally for works whose purpose is instruction or reference.\n• APPLICABILITY AND DEFINITIONS This License applies to any manual or other work, in any medium, that contains a notice placed by the copyright holder saying it can be distributed under the terms of this License. Such a notice grants a world-wide, royalty-free license, unlimited in duration, to use that work under the conditions stated herein. The “Document”, below, refers to any such manual or work. Any member of the public is a licensee, and is addressed as “you”. You accept the license if you copy, modify or distribute the work in a way requiring permission under copyright law. A “Modified Version” of the Document means any work containing the Document or a portion of it, either copied verbatim, or with modifications and/or translated into another language. A “Secondary Section” is a named appendix or a front-matter section of the Document that deals exclusively with the relationship of the publishers or authors of the Document to the Document’s overall subject (or to related matters) and contains nothing that could fall directly within that overall subject. (Thus, if the Document is in part a textbook of mathematics, a Secondary Section may not explain any mathematics.) The relationship could be a matter of historical connection with the subject or with related matters, or of legal, commercial, philosophical, ethical or political position regarding them. The “Invariant Sections” are certain Secondary Sections whose titles are designated, as being those of Invariant Sections, in the notice that says that the Document is released under this License. If a section does not fit the above definition of Secondary then it is not allowed to be designated as Invariant. The Document may contain zero Invariant Sections. If the Document does not identify any Invariant Sections then there are none. The “Cover Texts” are certain short passages of text that are listed, as Front-Cover Texts or Back-Cover Texts, in the notice that says that the Document is released under this License. A Front-Cover Text may be at most 5 words, and a Back-Cover Text may be at most 25 words. A “Transparent” copy of the Document means a machine-readable copy, represented in a format whose specification is available to the general public, that is suitable for revising the document straightforwardly with generic text editors or (for images composed of pixels) generic paint programs or (for drawings) some widely available drawing editor, and that is suitable for input to text formatters or for automatic translation to a variety of formats suitable for input to text formatters. A copy made in an otherwise Transparent file format whose markup, or absence of markup, has been arranged to thwart or discourage subsequent modification by readers is not Transparent. An image format is not Transparent if used for any substantial amount of text. A copy that is not “Transparent” is called “Opaque”. Examples of suitable formats for Transparent copies include plain ASCII without markup, Texinfo input format, LaTeX input format, SGML or XML using a publicly available DTD, and standard-conforming simple HTML, PostScript or PDF designed for human modification. Examples of transparent image formats include PNG, XCF and JPG. Opaque formats include proprietary formats that can be read and edited only by proprietary word processors, SGML or XML for which the DTD and/or processing tools are not generally available, and the machine-generated HTML, PostScript or PDF produced by some word processors for output purposes only. The “Title Page” means, for a printed book, the title page itself, plus such following pages as are needed to hold, legibly, the material this License requires to appear in the title page. For works in formats which do not have any title page as such, “Title Page” means the text near the most prominent appearance of the work’s title, preceding the beginning of the body of the text. The “publisher” means any person or entity that distributes copies of the Document to the public. A section “Entitled XYZ” means a named subunit of the Document whose title either is precisely XYZ or contains XYZ in parentheses following text that translates XYZ in another language. (Here XYZ stands for a specific section name mentioned below, such as “Acknowledgements”, “Dedications”, “Endorsements”, or “History”.) To “Preserve the Title” of such a section when you modify the Document means that it remains a section “Entitled XYZ” according to this definition. The Document may include Warranty Disclaimers next to the notice which states that this License applies to the Document. These Warranty Disclaimers are considered to be included by reference in this License, but only as regards disclaiming warranties: any other implication that these Warranty Disclaimers may have is void and has no effect on the meaning of this License.\n• VERBATIM COPYING You may copy and distribute the Document in any medium, either commercially or noncommercially, provided that this License, the copyright notices, and the license notice saying this License applies to the Document are reproduced in all copies, and that you add no other conditions whatsoever to those of this License. You may not use technical measures to obstruct or control the reading or further copying of the copies you make or distribute. However, you may accept compensation in exchange for copies. If you distribute a large enough number of copies you must also follow the conditions in section 3. You may also lend copies, under the same conditions stated above, and you may publicly display copies.\n• COPYING IN QUANTITY If you publish printed copies (or copies in media that commonly have printed covers) of the Document, numbering more than 100, and the Document’s license notice requires Cover Texts, you must enclose the copies in covers that carry, clearly and legibly, all these Cover Texts: Front-Cover Texts on the front cover, and Back-Cover Texts on the back cover. Both covers must also clearly and legibly identify you as the publisher of these copies. The front cover must present the full title with all words of the title equally prominent and visible. You may add other material on the covers in addition. Copying with changes limited to the covers, as long as they preserve the title of the Document and satisfy these conditions, can be treated as verbatim copying in other respects. If the required texts for either cover are too voluminous to fit legibly, you should put the first ones listed (as many as fit reasonably) on the actual cover, and continue the rest onto adjacent pages. If you publish or distribute Opaque copies of the Document numbering more than 100, you must either include a machine-readable Transparent copy along with each Opaque copy, or state in or with each Opaque copy a computer-network location from which the general network-using public has access to download using public-standard network protocols a complete Transparent copy of the Document, free of added material. If you use the latter option, you must take reasonably prudent steps, when you begin distribution of Opaque copies in quantity, to ensure that this Transparent copy will remain thus accessible at the stated location until at least one year after the last time you distribute an Opaque copy (directly or through your agents or retailers) of that edition to the public. It is requested, but not required, that you contact the authors of the Document well before redistributing any large number of copies, to give them a chance to provide you with an updated version of the Document.\n• MODIFICATIONS You may copy and distribute a Modified Version of the Document under the conditions of sections 2 and 3 above, provided that you release the Modified Version under precisely this License, with the Modified Version filling the role of the Document, thus licensing distribution and modification of the Modified Version to whoever possesses a copy of it. In addition, you must do these things in the Modified Version:\n• Use in the Title Page (and on the covers, if any) a title distinct from that of the Document, and from those of previous versions (which should, if there were any, be listed in the History section of the Document). You may use the same title as a previous version if the original publisher of that version gives permission.\n• List on the Title Page, as authors, one or more persons or entities responsible for authorship of the modifications in the Modified Version, together with at least five of the principal authors of the Document (all of its principal authors, if it has fewer than five), unless they release you from this requirement.\n• State on the Title page the name of the publisher of the Modified Version, as the publisher.\n• Preserve all the copyright notices of the Document.\n• Add an appropriate copyright notice for your modifications adjacent to the other copyright notices.\n• Include, immediately after the copyright notices, a license notice giving the public permission to use the Modified Version under the terms of this License, in the form shown in the Addendum below.\n• Preserve in that license notice the full lists of Invariant Sections and required Cover Texts given in the Document’s license notice.\n• Include an unaltered copy of this License.\n• Preserve the section Entitled “History”, Preserve its Title, and add to it an item stating at least the title, year, new authors, and publisher of the Modified Version as given on the Title Page. If there is no section Entitled “History” in the Document, create one stating the title, year, authors, and publisher of the Document as given on its Title Page, then add an item describing the Modified Version as stated in the previous sentence.\n• Preserve the network location, if any, given in the Document for public access to a Transparent copy of the Document, and likewise the network locations given in the Document for previous versions it was based on. These may be placed in the “History” section. You may omit a network location for a work that was published at least four years before the Document itself, or if the original publisher of the version it refers to gives permission.\n• For any section Entitled “Acknowledgements” or “Dedications”, Preserve the Title of the section, and preserve in the section all the substance and tone of each of the contributor acknowledgements and/or dedications given therein.\n• Preserve all the Invariant Sections of the Document, unaltered in their text and in their titles. Section numbers or the equivalent are not considered part of the section titles.\n• Delete any section Entitled “Endorsements”. Such a section may not be included in the Modified Version.\n• Do not retitle any existing section to be Entitled “Endorsements” or to conflict in title with any Invariant Section. If the Modified Version includes new front-matter sections or appendices that qualify as Secondary Sections and contain no material copied from the Document, you may at your option designate some or all of these sections as invariant. To do this, add their titles to the list of Invariant Sections in the Modified Version’s license notice. These titles must be distinct from any other section titles. You may add a section Entitled “Endorsements”, provided it contains nothing but endorsements of your Modified Version by various parties—for example, statements of peer review or that the text has been approved by an organization as the authoritative definition of a standard. You may add a passage of up to five words as a Front-Cover Text, and a passage of up to 25 words as a Back-Cover Text, to the end of the list of Cover Texts in the Modified Version. Only one passage of Front-Cover Text and one of Back-Cover Text may be added by (or through arrangements made by) any one entity. If the Document already includes a cover text for the same cover, previously added by you or by arrangement made by the same entity you are acting on behalf of, you may not add another; but you may replace the old one, on explicit permission from the previous publisher that added the old one. The author(s) and publisher(s) of the Document do not by this License give permission to use their names for publicity for or to assert or imply endorsement of any Modified Version.\n• COMBINING DOCUMENTS You may combine the Document with other documents released under this License, under the terms defined in section 4 above for modified versions, provided that you include in the combination all of the Invariant Sections of all of the original documents, unmodified, and list them all as Invariant Sections of your combined work in its license notice, and that you preserve all their Warranty Disclaimers. The combined work need only contain one copy of this License, and multiple identical Invariant Sections may be replaced with a single copy. If there are multiple Invariant Sections with the same name but different contents, make the title of each such section unique by adding at the end of it, in parentheses, the name of the original author or publisher of that section if known, or else a unique number. Make the same adjustment to the section titles in the list of Invariant Sections in the license notice of the combined work. In the combination, you must combine any sections Entitled “History” in the various original documents, forming one section Entitled “History”; likewise combine any sections Entitled “Acknowledgements”, and any sections Entitled “Dedications”. You must delete all sections Entitled “Endorsements.”\n• COLLECTIONS OF DOCUMENTS You may make a collection consisting of the Document and other documents released under this License, and replace the individual copies of this License in the various documents with a single copy that is included in the collection, provided that you follow the rules of this License for verbatim copying of each of the documents in all other respects. You may extract a single document from such a collection, and distribute it individually under this License, provided you insert a copy of this License into the extracted document, and follow this License in all other respects regarding verbatim copying of that document.\n• AGGREGATION WITH INDEPENDENT WORKS A compilation of the Document or its derivatives with other separate and independent documents or works, in or on a volume of a storage or distribution medium, is called an “aggregate” if the copyright resulting from the compilation is not used to limit the legal rights of the compilation’s users beyond what the individual works permit. When the Document is included in an aggregate, this License does not apply to the other works in the aggregate which are not themselves derivative works of the Document. If the Cover Text requirement of section 3 is applicable to these copies of the Document, then if the Document is less than one half of the entire aggregate, the Document’s Cover Texts may be placed on covers that bracket the Document within the aggregate, or the electronic equivalent of covers if the Document is in electronic form. Otherwise they must appear on printed covers that bracket the whole aggregate.\n• TRANSLATION Translation is considered a kind of modification, so you may distribute translations of the Document under the terms of section 4. Replacing Invariant Sections with translations requires special permission from their copyright holders, but you may include translations of some or all Invariant Sections in addition to the original versions of these Invariant Sections. You may include a translation of this License, and all the license notices in the Document, and any Warranty Disclaimers, provided that you also include the original English version of this License and the original versions of those notices and disclaimers. In case of a disagreement between the translation and the original version of this License or a notice or disclaimer, the original version will prevail. If a section in the Document is Entitled “Acknowledgements”, “Dedications”, or “History”, the requirement (section 4) to Preserve its Title (section 1) will typically require changing the actual title.\n• TERMINATION You may not copy, modify, sublicense, or distribute the Document except as expressly provided under this License. Any attempt otherwise to copy, modify, sublicense, or distribute it is void, and will automatically terminate your rights under this License. However, if you cease all violation of this License, then your license from a particular copyright holder is reinstated (a) provisionally, unless and until the copyright holder explicitly and finally terminates your license, and (b) permanently, if the copyright holder fails to notify you of the violation by some reasonable means prior to 60 days after the cessation. Moreover, your license from a particular copyright holder is reinstated permanently if the copyright holder notifies you of the violation by some reasonable means, this is the first time you have received notice of violation of this License (for any work) from that copyright holder, and you cure the violation prior to 30 days after your receipt of the notice. Termination of your rights under this section does not terminate the licenses of parties who have received copies or rights from you under this License. If your rights have been terminated and not permanently reinstated, receipt of a copy of some or all of the same material does not give you any rights to use it.\n• FUTURE REVISIONS OF THIS LICENSE The Free Software Foundation may publish new, revised versions of the GNU Free Documentation License from time to time. Such new versions will be similar in spirit to the present version, but may differ in detail to address new problems or concerns. See https://www.gnu.org/copyleft/. Each version of the License is given a distinguishing version number. If the Document specifies that a particular numbered version of this License “or any later version” applies to it, you have the option of following the terms and conditions either of that specified version or of any later version that has been published (not as a draft) by the Free Software Foundation. If the Document does not specify a version number of this License, you may choose any version ever published (not as a draft) by the Free Software Foundation. If the Document specifies that a proxy can decide which future versions of this License can be used, that proxy’s public statement of acceptance of a version permanently authorizes you to choose that version for the Document.\n• RELICENSING “Massive Multiauthor Collaboration Site” (or “MMC Site”) means any World Wide Web server that publishes copyrightable works and also provides prominent facilities for anybody to edit those works. A public wiki that anybody can edit is an example of such a server. A “Massive Multiauthor Collaboration” (or “MMC”) contained in the site means any set of copyrightable works thus published on the MMC site. “CC-BY-SA” means the Creative Commons Attribution-Share Alike 3.0 license published by Creative Commons Corporation, a not-for-profit corporation with a principal place of business in San Francisco, California, as well as future copyleft versions of that license published by that same organization. “Incorporate” means to publish or republish a Document, in whole or in part, as part of another Document. An MMC is “eligible for relicensing” if it is licensed under this License, and if all works that were first published under this License somewhere other than this MMC, and subsequently incorporated in whole or in part into the MMC, (1) had no cover texts or invariant sections, and (2) were thus incorporated prior to November 1, 2008. The operator of an MMC Site may republish an MMC contained in the site under CC-BY-SA on the same site at any time before August 1, 2009, provided the MMC is eligible for relicensing.\n\nADDENDUM: How to use this License for your documents\n\nTo use this License in a document you have written, include a copy of the License in the document and put the following copyright and license notices just after the title page:\n\nIf you have Invariant Sections, Front-Cover Texts and Back-Cover Texts, replace the “with…Texts.” line with this:\n\nIf you have Invariant Sections without Cover Texts, or some other combination of the three, merge those two alternatives to suit the situation.\n\nIf your document contains nontrivial examples of program code, we recommend releasing these examples in parallel under your choice of free software license, such as the GNU General Public License, to permit their use in free software.\n\nThis is a general index of all issues discussed in this manual, with the exception of the commands and command-line options.\n\nThis is an alphabetical list of all commands and command-line options."
    },
    {
        "link": "https://gnu.org/software/sed/manual/html_node/The-_0022s_0022-Command.html",
        "document": "The command (as in substitute) is probably the most important in and has a lot of different options. The syntax of the command is ‘ ’.\n\nIts basic concept is simple: the command attempts to match the pattern space against the supplied regular expression ; if the match is successful, then that portion of the pattern space which was matched is replaced with .\n\nFor details about syntax see Regular Expression Addresses.\n\nThe can contain ( being a number from 1 to 9, inclusive) references, which refer to the portion of the match which is contained between the th and its matching . Also, the can contain unescaped characters which reference the whole matched portion of the pattern space.\n\nThe characters may be uniformly replaced by any other single character within any given command. The character (or whatever other character is used in its stead) can appear in the or only if it is preceded by a character.\n\nFinally, as a GNU extension, you can include a special sequence made of a backslash and one of the letters , , , , or . The meaning is as follows:\n\nWhen the flag is being used, case conversion does not propagate from one occurrence of the regular expression to another. For example, when the following command is executed with ‘ ’ in pattern space:\n\nthe output is ‘ ’. When replacing the first ‘ ’, the ‘ ’ sequence only affects the empty replacement of ‘ ’. It does not affect the character that is added to pattern space when replacing with .\n\nOn the other hand, and do affect the remainder of the replacement text if they are followed by an empty substitution. With ‘ ’ in pattern space, the following command:\n\nwill replace ‘ ’ with ‘ ’ (uppercase) and ‘ ’ with ‘ ’. If this behavior is undesirable, you can prevent it by adding a ‘ ’ sequence—after ‘ ’ in this case.\n\nTo include a literal , , or newline in the final replacement, be sure to precede the desired , , or newline in the with a .\n\nThe command can be followed by zero or more of the following :\n\nApply the replacement to all matches to the , not just the first. Only replace the th match of the . interaction in command Note: the POSIX standard does not specify what should happen when you mix the and modifiers, and currently there is no widely agreed upon meaning across implementations. For GNU , the interaction is defined to be: ignore matches before the th, and then match and replace all matches from the th on. If the substitution was made, then print the new pattern space. Note: when both the and options are specified, the relative ordering of the two produces very different results. In general, (evaluate then print) is what you want, but operating the other way round can be useful for debugging. For this reason, the current version of GNU interprets specially the presence of options both before and after , printing the pattern space before and after evaluation, while in general flags for the command show their effect just once. This behavior, although documented, might change in future versions. If the substitution was made, then write out the result to the named file. As a GNU extension, two special values of are supported: , which writes the result to the standard error, and , which writes to the standard output.3 This command allows one to pipe input from a shell command into pattern space. If a substitution was made, the command that is found in pattern space is executed and pattern space is replaced with its output. A trailing newline is suppressed; results are undefined if the command to be executed contains a NUL character. This is a GNU extension. The modifier to regular-expression matching is a GNU extension which makes match in a case-insensitive manner. The modifier to regular-expression matching is a GNU extension which directs GNU to match the regular expression in mode. The modifier causes and to match respectively (in addition to the normal behavior) the empty string after a newline, and the empty string before a newline. There are special character sequences ( and ) which always match the beginning or the end of the buffer. In addition, the period character does not match a new-line character in multi-line mode."
    },
    {
        "link": "https://unix.stackexchange.com/questions/459555/understanding-sed-command-with-extended-regexp",
        "document": "Stack Exchange network consists of 183 Q&A communities including Stack Overflow, the largest, most trusted online community for developers to learn, share their knowledge, and build their careers."
    },
    {
        "link": "https://linux.die.net/man/1/sed",
        "document": ""
    },
    {
        "link": "https://unix.stackexchange.com/questions/78625/using-sed-to-find-and-replace-complex-string-preferrably-with-regex",
        "document": "Stack Exchange network consists of 183 Q&A communities including Stack Overflow, the largest, most trusted online community for developers to learn, share their knowledge, and build their careers."
    },
    {
        "link": "https://linuxjournal.com/content/mastering-text-manipulation-sed-command",
        "document": "The Linux command line interface provides a wealth of tools for text processing, and one of the most powerful among them is the sed command. Sed, an abbreviation for Stream EDitor, is a versatile tool that allows for complex manipulation of text files and streams​​.\n\nSed is a non-interactive text editor that operates on piped input or text files. By providing it with instructions, you can make it modify and process text in files or streams. The most common use cases of sed include operations like selecting text, substituting text, modifying an original file, adding lines to text, or deleting lines from the text. It can be used from the command line in Bash and other command-line shells​.\n\nThe syntax of the sed command comprises three main parts:\n• Options: These control the output of the command.\n• Script: This contains a list of commands to run.\n• Input file: This is the file you're using the sed command on.\n\nIn the absence of a filename, the script operates on the standard input data. You can also run the sed command without any options. The basic syntax looks like this:\n\nSed isn't the only text processing tool in the Linux ecosystem. Another powerful utility is awk. While both of them work with text, they have some key differences:\n• Sed excels at parsing and transforming text in a compact and simple language, making it simple and limited but easy to use.\n• Awk, on the other hand, is a tool for text processing and writing potent programs in the form of statements. It's complex, versatile, and more powerful than sed, but also more complicated to use​​.\n\nLet's dive deeper into the workings of sed with some practical examples. For all these examples, assume that we have a file called . Note that sed does not alter the original file by default. All changes will appear in the output, but the original file will remain unmodified.\n\nOne of the most common operations in sed is text substitution. This is done using the command. For example, to replace the first instance of a pattern with another pattern , use:\n\nHere, only the first instance of in each line is substituted with . If you want to replace the third instance of a pattern, you can use:\n\nIn a global substitution, all instances of a pattern are replaced. This is achieved by appending to the substitute command. To replace all instances of with , use:\n\nYou can also start the global replacement from the nth instance of the pattern by using . For example, to replace all instances of with , starting from the third instance, use:\n\nIn conclusion, the command in Linux is a powerful stream editor that can perform a multitude of operations on text files and streams. It doesn't offer an interactive interface but rather operates on piped input or text files according to the instructions we provide. The command's syntax is relatively simple and consists of three parts: options, the script containing the Linux commands to run, and the file name."
    },
    {
        "link": "https://digitalocean.com/community/tutorials/the-basics-of-using-the-sed-stream-editor-to-manipulate-text-in-linux",
        "document": "The command, short for stream editor, performs editing operations on text coming from standard input or a file. edits line-by-line and in a non-interactive way.\n\nThis means that you make all of the editing decisions as you are calling the command, and executes the directions automatically. This may seem confusing or unintuitive, but it is a very powerful and fast way to transform text, especially as part of a script or automated workflow.\n\nThis tutorial will cover some basic operations and introduce you to the syntax required to operate this editor. You will almost certainly never replace your regular text editor with , but it will probably become a welcomed addition to your text editing toolbox.\n\noperates on a stream of text that it reads from either a text file or from standard input (STDIN). This means that you can send the output of another command directly into sed for editing, or you can work on a file that you’ve already created.\n\nYou should also be aware that outputs everything to standard out (STDOUT) by default. That means that, unless redirected, will print its output to the screen instead of saving it in a file.\n\nIn this tutorial, you’ll use a copy of the BSD Software License to experiment with . On Ubuntu, execute the following commands to copy the BSD license file to your home directory so you can work with it:\n\nIf you don’t have a local copy of the BSD license, create one yourself with this command:\n\nLet’s use to view the contents of the BSD license file. sends its results to the screen by default, which means you can use it as a file reader by passing it no editing commands. Try executing the following command:\n\nYou’ll see the BSD license displayed to the screen:\n\nThe single quotes contain the editing commands you pass to . In this case, you passed it nothing, so printed each line it received to standard output.\n\ncan use standard input rather than a file. Pipe the output of the command into to produce the same result:\n\nYou’ll see the output of the file:\n\nAs you can see, you can operate on files or streams of text, like the ones produced when piping output with the pipe character, just as easily.\n\nIn the previous example, you saw that input passed into without any operations would print the results directly to standard output.\n\nLet’s explore ’s explicit command, which you specify by using the character within single quotes.\n\nYou’ll see each line of the file printed twice:\n\nautomatically prints each line by default, and then you’ve told it to print lines explicitly with the “p” command, so you get each line printed twice.\n\nIf you examine the output closely, you’ll see that it has the first line twice, followed by the second line twice, etc, which tells you that operates on data line by line. It reads a line, operates on it, and outputs the resulting text before repeating the process on the next line.\n\nYou can clean up the results by passing the option to , which suppresses the automatic printing:\n\nWe now are back to printing each line once.\n\nThe examples so far can hardly be considered editing (unless you wanted to print each line twice…). Next you’ll explore how can modify the output by targeting specific sections of the text data.\n\nAddresses let you target specific parts of a text stream. You can specify a specific line or even a range of lines.\n\nLet’s have print the first line of the file. Execute the following command:\n\nThe first line prints to the screen:\n\nBy placing the number before the print command, you told the line number to operate on. You can just as easily print five lines (don’t forget the “-n”):\n\nYou’ve just given an address range to . If you give an address, it will only perform the commands that follow on those lines. In this example, you’ve told sed to print line 1 through line 5. You could have specified this in a different way by giving the first address and then using an offset to tell sed how many additional lines to travel, like this:\n\nThis will result in the same output, because you told to start at line 1 and then operate on the next 4 lines as well.\n\nIf you want to print every other line, specify the interval after the character. The following command prints every other line in the file, starting with line 1:\n\nYou can use to delete text from the output as well.\n\nYou can perform text deletion where you previously were specifying text printing by changing the command to the command.\n\nIn this case, you no longer need the command because will print everything that is not deleted. This will help you see what’s going on.\n\nModify the last command from the previous section to make it delete every other line starting with the first:\n\nThe result is that you see every line you were not given last time:\n\nIt is important to note here that our source file is not being affected. It is still intact. The edits are output to our screen.\n\nIf we want to save our edits, we can redirect standard output to a file like so:\n\nNow open the file with :\n\nYou see the same output that you saw onscreen previously:\n\nThe command does not edit the source file by default, but you can change this behavior by passing the option, which means “perform edits in-place.” This will alter the source file.\n\nLet’s try it by editing the file you just created, in-place. Let’s further reduce the file by deleting every other line again:\n\nIf you use to display the file with , you’ll see that the file has been edited.\n\nThe option can be dangerous. Thankfully, gives you the ability to create a backup file prior to editing.\n\nTo create a backup file prior to editing, add the backup extension directly after the “-i” option:\n\nThis creates a backup file with the extension, and then edits the original file in-place.\n\nNext you’ll look at how to use to perform search and replace operations.\n\nPerhaps the most well-known use for is substituting text. can search for text patterns using regular expressions, and then replace the found text with something else.\n\nYou can learn more about regular expressions by following the Using Grep Regular Expressions to Search for Text Patterns in Linux.\n\nIn its most basic form, you can change one word to another word using the following syntax:\n\nThe is the substitute command. The three slashes ( ) are used to separate the different text fields. You can use other characters to delimit the fields if it would be more helpful.\n\nFor instance, if you were trying to change a website name, using another delimiter would be helpful since URLs contain slashes.\n\nExecute the following command to print a URL with and modify it with , using the underscore ( ) character as the delimiter:\n\nThis replaces with . The output shows the modifed URL:\n\nDo not forget the final delimiter, or will complain. If you ran this command:\n\nLet’s create a new file to practice some substitutions. Execute the following command to create a new text file called :\n\nNow let’s substitute the expression with . Use the following command:\n\nThe output looks like this:\n\nYou can see a few notable things here. First, is that replaced patterns, not words. The within is changed to .\n\nThe other thing to notice is that on line 2, the second was not changed to .\n\nThis is because by default, the command operates on the first match in a line and then moves to the next line. To make replace every instance of instead of just the first on each line, you must pass an optional flag to the substitute command.\n\nProvide the flag to the substitute command by placing it after the substitution set:\n\nNow the substitute command changes every instance.\n\nIf you only wanted to change the second instance of “on” that sed finds on each line, then you would use the number instead of the :\n\nThis time the other lines are unchanged, as they don’t have a second occurrence:\n\nIf you only want to see which lines were substituted, use the option again to suppress automatic printing.\n\nYou can then pass the option to the substitute command to print lines where substitution took place.\n\nThe line that changed prints to the screen:\n\nAs you can see, you can combine the flags at the end of the command.\n\nIf you want the search process to ignore case, you can pass it the “i” flag.\n\nIf you want to find more complex patterns with regular expressions, you have a number of different methods of referencing the matched pattern in the replacement text.\n\nFor instance, to match from the beginning of the line to , use the following command:\n\nYou can see that the wildcard expression matches from the beginning of the line to the last instance of .\n\nSince you don’t know the exact phrase that will match in the search string, you can use the character to represent the matched text in the replacement string.\n\nA more flexible way of referencing matched text is to use escaped parentheses to group sections of matched text.\n\nEvery group of search text marked with parentheses can be referenced by an escaped reference number. For instance, the first parentheses group can be referenced with , the second with and so on.\n\nIn this example, we’ll switch the first two words of each line:\n\nAs you can see, the results are not perfect. For instance, the second line skips the first word because it has a character not listed in our character set. Similarly, it treated as two words in the fifth line.\n\nLet’s improve the regular expression to be more accurate:\n\nThis is much better than last time. This groups punctuation with the associated word.\n\nNotice how we repeat the expression inside the parentheses (once without the character, and then once with it). This is because the character matches the character set that comes before it zero or more times. This means that the match with the wildcard would be considered a “match” even if the pattern is not found.\n\nTo ensure that finds the text at least once, you must match it once without the wildcard before employing the wildcard.\n\nIn this tutorial you explored the command. You printed specific lines from the file, searched for text, deleted lines, overwrote the original file, and used regular expressions to replace text. You should be able to see already how you can quickly transform a text document using properly constructed sed commands.\n\nIn the next article in this series, you will explore some more advanced features."
    },
    {
        "link": "https://linode.com/docs/guides/manipulate-text-from-the-command-line-with-sed",
        "document": "This credit will be applied to any valid services used during your first days.\n\nThe traditional Unix utility makes it possible to manipulate strings and streams of text from the command line without using a text editing application. is useful in a number of different contexts, including finding and replacing strings of text in a large number of files, manipulating text for Stack Scripts and other kinds of scripts, as well as a component in basic shell scripting.\n\nThis document provides a gentle overview of usage, accompanied by a number of practical applications of . If you find this guide helpful, please consider our guide to basic administration practices or the rest of the Tools & Reference section.\n\nIn this guide, refers to recent versions of “GNU sed” which are included by default in all images provided by Linode, and as part of the common “base” selection of packages provided in nearly all distributions of Linux-based operating systems.\n\ncommands take a particular form. Consider the following example:\n\nThis command begins with the invocation ( ) followed by the option. allows sed to perform the modification “in place” on the file specified. The option forces to use an extended regular syntax. The next argument enclosed in single quotes (e.g. ) specifies the “substitution” or search and replace function. The final term of a command specifies the file object that the substitution function will be applied to.\n\ncan also be used to modify streams of text rather than files, so often a command might take the form of:\n\nIn this case, the contents of the stream of data which is created by running the command on the is filtered through the operation. The result is written to the . Generally, the left-hand side of the pipe would contain some other form of input, but you do not need to files into as the above command is equivalent to the following:\n\nUnless otherwise directed, will output the transformed text to standard output.\n\nThe basic form provides the core of functionality in common use. The indicates that the script will perform a substitution. The next character introduces a character to separate the “find” and “replace” strings and to terminate the substitution script. By convention the separation characters are characters, but in cases where you are searching for data that contains characters, it is possible to use another separating character. Thus, the following two strings are functionally identical:\n\nSed uses regular expressions in the “search” part of the substitution syntax. Most characters in regular expressions match with input data literally; however, there are some sequences that carry special significance. If you want to match these characters literally you can use the escape character to transform the next character into a literal match. Consider the following characters with special significance in substitution scripts:\n• The symbol causes the character immediately proceeding this character to successfully match to zero or more instances of that character in the data set.\n• The symbol causes the character immediately proceeding this character to successfully match to one or more instances of that character in the data set.\n• Square brackets ( ) enclose a set of characters that match against any member of the set of specified characters. When prefaced with a caret, as in , it matches none of the characters specified in the set.\n• Parenthetical characters (left or right ) both allow you to write more complex expressions and also create “captures” that allow you to use sequences from the matched text in the replacement string. Captured sequences are available in the order that they were captured with where corresponds to the number of the capture.\n• The character matches the beginning of a line.\n• The character matches the end of a line.\n• The character, as previously stated, escapes the following character for literal matching if it caries additional meaning.\n• The character provides an “OR” operator, so the sequence would match a line that began with the characters or .\n\nWhile these characters provide the foundation of writing matching patterns, there are other significant characters and powerful matching abstractions. Documenting the full capabilities of the regular expression syntax is beyond the scope of this guide; however you can learn more about commands using the command.\n\nFinding and Replacing Strings within files Using Sed\n\nIn some cases, the “in place” substitution with the argument provides the desired behavior. However, if you want to test a sed operation, or provide a “safety net”, consider the following command:\n\nIn this case, the existing file is copied to and the replacements are made automatically to . If you want to reverse the changes, issue a command similar to .\n\nThe option appended to the substitution statement sets a “global” mode that forces to replace multiple instances of the match on the same line.\n\nIt’s possible to use to modify streams of text in shell scripts. Consider the following bash function:\n\nWhen this function is called, the following operations are performed: for every item (the file names in the current directory,) the move command ( ) is issued with the existing file name and the old file name filtered through a function. The function matches for the string of characters at the end of the file name, and replaces that with . If the sed script fails to match, the original file name will be output and the move will fail.\n\nConsider the following expression:\n\nIn this command, the 56th line of the ssh “known hosts” file will be deleted. Commands in this form are useful for deleting a host key for a host that has changed from the file, as is the case after redeploying a system or moving an IP or domain to a new host.\n\nYou may wish to consult the following resources for additional information on this topic. While these are provided in the hope that they will be useful, please note that we cannot vouch for the accuracy or timeliness of externally hosted materials."
    },
    {
        "link": "https://unix.stackexchange.com/questions/78625/using-sed-to-find-and-replace-complex-string-preferrably-with-regex",
        "document": "Stack Exchange network consists of 183 Q&A communities including Stack Overflow, the largest, most trusted online community for developers to learn, share their knowledge, and build their careers."
    },
    {
        "link": "https://medium.com/@kuldeepkumawat195/mastering-advanced-linux-sed-commands-n-b-n-and-s-a8699216273a",
        "document": "In this comprehensive guide, we delve into the advanced (stream editor) commands— , , , and —which are integral for text manipulation in Linux. These commands provide powerful ways to transform text in a stream or file, allowing for intricate editing tasks to be automated with ease. We explore each command with practical examples, ensuring you can apply them effectively in your workflows.\n\nThe command in is essential for controlling the flow of text processing. It performs the following operations sequentially:\n• Print the Pattern Buffer (Conditional): If automatic printing is enabled, the current contents of the pattern buffer (the space where stores a line of input) are printed.\n• Process Input: The next line of input is read into the pattern buffer, replacing its previous contents.\n• Terminate if No More Input: If there are no more lines to read, quits, and no further commands are executed.\n\nExample: Basic Usage of the Command"
    }
]