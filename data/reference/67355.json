[
    {
        "link": "https://en.cppreference.com/w/cpp/container/queue",
        "document": "The class template is a container adaptor that gives the functionality of a queue - specifically, a FIFO (first-in, first-out) data structure.\n\nThe class template acts as a wrapper to the underlying container - only a specific set of functions is provided. The queue pushes the elements on the back of the underlying container and pops them from the front.\n\nAll member functions of are constexpr: it is possible to create and use objects in the evaluation of a constant expression. However, objects generally cannot be constexpr, because any dynamically allocated storage must be released in the same evaluation of constant expression.\n\nThe type of the stored elements. The program is ill-formed if is not the same type as . The type of the underlying container to use to store the elements. The container must satisfy the requirements of . Additionally, it must provide the following functions with the usual semantics: The standard containers std::deque and std::list satisfy these requirements.\n\nThe following behavior-changing defect reports were applied retroactively to previously published C++ standards.\n• . The resolution of this DR\n\nadded support of and . The changes involving \n\nare for maintaining consistency. Such as containers similar to with additional support of. The resolution of this DRadded support of forand. The changes involvingare for maintaining consistency."
    },
    {
        "link": "https://geeksforgeeks.org/queue-cpp-stl",
        "document": "In C++, queue container follows the FIFO (First In First Out) order of insertion and deletion. According to it, the elements that are inserted first should be removed first. This is possible by inserting elements at one end (called back) and deleting them from the other end (called front) of the data structure.\n\nExplanation: In this program, we created a queue of integers and pushed three elements {3, 4, 5} into it.\n\nQueue is defined as the std::queue class template inside <queue> header file.\n• T: Type of elements in the queue.\n• q: Name assigned to the queue.\n\nIn C++, queue can be declared and initialized in multiple ways as shown in the below example:\n\nExplanation: In the above program,\n• queue<int> q1 creates an empty queue of integers. Elements are later added into it.\n• queue<int> q2(q1) q2 with same elements as q1\n\nHere are the basic operations that can be performed on a queue:\n\nNew elements can only be inserted at back of the queue using push() function. The process of inserting elements in a queue is also called enqueue.\n\nOnly the front and back elements of the queue can be accessed by using front() and back() functions respectively. We can’t access any middle element of queue.\n\nElements can only be deleted from the front of the queue using the function. This operation is also called dequeue.\n\nSince only the front and back element can be accessed in a queue, we cannot directly traverse it. On the other hand, we can create a copy of the queue, access the front element, and then delete it. By continuing this process until the copied queue is empty, we can effectively traverse all the elements of the queue.\n\nThe below table lists the time complexity of the basic operations on a queue:\n\nThe following are some more operations on queue that will help you become more familiarize with this container:\n\nQueue container provides the built-in implementation of the Queue data structure in C++. It is a container adaptor that is built over another container like deque or list. The queue follows the FIFO (First In, First Out) principle to insert and delete elements. This behaviour is achieved using underlying data structures that allow constant time insert and delete operations at both ends.\n\nExample, we cannot use vector as it does not allow constant time for deletion at both ends. But on the other hand, deque allows the constant time insertion at the back and deletion at the front. All the other operations of deque are restricted.\n\nFollowing is the list of all member functions of std::queue class in C++:"
    },
    {
        "link": "https://en.cppreference.com/w/cpp/container/stack",
        "document": "The class is a container adaptor that gives the programmer the functionality of a stack - specifically, a LIFO (last-in, first-out) data structure.\n\nThe class template acts as a wrapper to the underlying container - only a specific set of functions is provided. The stack pushes and pops the element from the back of the underlying container, known as the top of the stack.\n\nAll member functions of are constexpr: it is possible to create and use objects in the evaluation of a constant expression. However, objects generally cannot be constexpr, because any dynamically allocated storage must be released in the same evaluation of constant expression.\n\nThe type of the stored elements. The program is ill-formed if is not the same type as . The type of the underlying container to use to store the elements. The container must satisfy the requirements of . Additionally, it must provide the following functions with the usual semantics: The standard containers std::vector (including ), std::deque and std::list satisfy these requirements. By default, if no container class is specified for a particular stack class instantiation, the standard container std::deque is used.\n\nThe following behavior-changing defect reports were applied retroactively to previously published C++ standards."
    },
    {
        "link": "https://stackoverflow.com/questions/51266104/c-default-implementation-of-stack-and-queue",
        "document": "is right out, it doesn't change size.\n\noptimises for iterator non-invalidation, allows insertion at known positions, and lacks random access. It has O(N) space overhead, with a large constant, and it has bad cache locality.\n\nis an even more crippled with smaller space overhead\n\noptimises for appending or prepending, at the expense of not being contiguous. It has O(N) space overhead, with a smaller constant, and it has mediocre cache locality.\n\noptimises for access speed, at the expense of insertion / removal anywhere but the end. It has O(1) space overhead, and the great cache locality.\n\nSo what does this mean for stack and queue?\n\nonly requires operations at one end. , and all provide the necessary operations\n\nrequires operations at both ends. and are the only candidates.\n\nThe choice of as the default is then one of consistency, as is generally better for , but inapplicable for .\n\nNote that , whilst named similar to , is actually more akin to in requiring only modification at one end. It also benefits more from the raw access speed of , maintaining the heap invariant."
    },
    {
        "link": "https://dev.to/michaelarn0ld/c-data-structures-stacks-queues-sets-and-maps-28ap",
        "document": "I've been programming seriously now for about a year; in that time I've brushed up on my python skills, completed a few YouTube courses on HTML/CSS, studied JavaScript, and built a few React apps. So far, everything has been awesome. I love to code and this journey has allowed me to seamlessly integrate the technical and creative sides of my brain. Recently, however, I have been faced with this lingering question: are my programs optimized for performance?\n\nCuriosity has led me to dive deeper into some of the computer science fundamentals, something that I feel was missing from the previous stage of my learning. Sure I was learning to write code; heck, I even got out of \"tutorial hell\" and was quickly building projects on my own. However, I lacked the theory necessary to be confident that I was writing the best code.\n\nEnter my introduction to data structures. For the past few months now, I have been following the old Stanford CS106B lectures available through YouTube. The course does an excellent job at transforming you from someone who knows how to code into someone who knows how to use computers to solve problems.\n\nSo why would you want to learn about data structures? Well, just as there are many tools that serve unique purposes in the construction of a house, there are various data structures that are useful in solving different kinds of problems in computer science. Here, I will briefly discuss the theory and applications of stacks, queues, sets, and maps implemented in C++.\n\nLike the name implies, a stack is simply a stack of things; In this structure, items can only be added or removed from the top. The order of a stack is known as \"LIFO\", or the last item that goes in is the first item that comes out.\n\nImagine you are grading papers, every time you finish one you place the paper into a neat pile on your desk. When you get up and look at those papers, the first one you will see is the last you finished grading. Similarly, if you grade another new paper and place it in the pile, it is now at the top of the pile. Stacks are just like this.\n\nIn a stack, the three fundamental operations are top, push, and pop. Calling \"top\" on a stack allows you to examine the top item but does not remove it. When you \"push\" an item to a stack, you place it at the top. When you \"pop\" from a stack, you remove the top item.\n\nStacks are useful in an abundance of applications. One of the most popular is the undo feature that is used in word processors. Every time a change is made to a document, that change gets added to a stack. When you press CMD+Z (or CTRL+Z for my windows friends), the most recent action gets \"popped\" from the stack. Another area where stacks find use is in the balancing of braces and parentheses in a program. The compiler checks for matching braces by implementing the stack data structure.\n\nA queue is another data structure that is a lot like the line at a grocery store or movie theater. At the movie theater, people are served in the order in which they get in line; the first person that gets in line is the first person who gets their ticket. The order of a queue is then known as \"FIFO\", or the first item that goes in is the first item that comes out.\n\nThe fundamental operations of a queue are pretty similar to those of a stack; You can push to a queue, you can pop from a queue, and you can check both the frontmost and rearmost elements of a queue. The difference, however, is in the order in which elements are enqueued (pushed) and dequeued (popped); enqueuing an element places it at the back and dequeuing removes the element at the front.\n\nLike stacks, queues are useful in a variety of problems. For instance, a queue might be used to schedule the order in which items get processed by a printer. Another type of problem that a queue excels in is the implementation of a breadth-first-search algorithm.\n\nA set is a data structure that represents a unique collection of values. Sets cannot contain duplicates and are not indexed like vectors. Consequentially, adding and removing items from a set is efficient because, unlike vectors, there is no reindexing of other elements during these kinds of operations.\n\nSets have three primary operations: insert, erase, and count. \"Insert\" adds an element to the set so long as it is unique, \"erase\" removes an element from the set, and \"count\" checks if an element is present in the set. Of course, there are plenty of other things you can do with a set, and if you are interested you can check those out on the C++ STL reference page.\n\nSets, similar to other data structures mentioned, have specific cases where their use is ideal. One example that implements a set is a shopping list. We can add items to the shopping list and we can remove them, but we don't really care about the order of items on our list. The point is that we put all items on our list into our cart exactly one time. Another great scenario for a set that comes to mind is determining the number of unique words in a book. In this case, the book would be parsed and all words would be inserted into the set. Since sets ignore duplicates, attempting to add the same word more than once does nothing. At the end of the parsing, we simply count the number of items in our set, representing unique words from the book.\n\nIf you are familiar with python, a map in C++ is a lot like a python . More formally, a map is a data structure that stores key-value pairs. Intuitively, a map is a lot like a dictionary, with words representing unique keys and the respective definitions representing their values. The concept of indexing is still present in a map, though the \"index\" (key) does not necessarily need to be an .\n\nMaps support a variety of operations but the main ones are insertion of a key-value pair, removal of a key, and retrieval of a key. When you remove a key from the map, it also removes the value that was associated with it.\n\nConsider the previous scenario that implemented a set to find all unique words in a book. Imagine that instead of simply wanting to get the count of all unique words in the document, you wanted to know the number of times that each word occurred. You could implement a map to do this:\n\nBesides this simple example, maps are used extensively in a variety of problems. You can imagine a map-type structure being used to keep track of a user and their friend list on a social media platform. Similarly, a map would be a perfect data structure to store the information in a phonebook. Maps are incredibly useful for storing associative data.\n\nOf course, this is not an exhaustive list of all the different kinds of data structures; if you want to learn more, the lectures I am following provide much more detail than I can share here. I have never had the pleasure of taking one of his courses, but Marty Strepp does an excellent job of presenting the material.\n\nIf you are interested in reading about how I got involved in programming, I wrote a medium article which you can find here. Similarly, if you want to stay up to date with my progress in this field, please visit my GitHub: https://github.com/michaelarn0ld"
    },
    {
        "link": "https://geeksforgeeks.org/breadth-first-search-or-bfs-for-a-graph",
        "document": "Breadth First Search or BFS for a Graph\n\nGiven a undirected graph represented by an adjacency list , where each represents the list of vertices connected to vertex . Perform a Breadth First Traversal (BFS) starting from vertex , visiting vertices from left to right according to the adjacency list, and return a list containing the BFS traversal of the graph.\n\nInput: adj = [[2,3,1], [0], [0,4], [0], [2]]\n\n Output: [0, 2, 3, 1, 4]\n\nExplanation: Starting from 0, the BFS traversal will follow these steps: \n\nVisit 0 → Output: 0 \n\nVisit 2 (first neighbor of 0) → Output: 0, 2 \n\nVisit 3 (next neighbor of 0) → Output: 0, 2, 3 \n\nVisit 1 (next neighbor of 0) → Output: 0, 2, 3, \n\nVisit 4 (neighbor of 2) → Final Output: 0, 2, 3, 1, 4 Input: adj = [[1, 2], [0, 2], [0, 1, 3, 4], [2], [2]]\n\n Output: [0, 1, 2, 3, 4]\n\nExplanation: Starting from 0, the BFS traversal proceeds as follows: \n\nVisit 0 → Output: 0 \n\nVisit 1 (the first neighbor of 0) → Output: 0, 1 \n\nVisit 2 (the next neighbor of 0) → Output: 0, 1, 2 \n\nVisit 3 (the first neighbor of 2 that hasn’t been visited yet) → Output: 0, 1, 2, 3 \n\nVisit 4 (the next neighbor of 2) → Final Output: 0, 1, 2, 3, 4 Input: adj = [[1], [0, 2, 3], [1], [1, 4], [3]]\n\nOutput: [0, 1, 2, 3, 4]\n\nExplanation: Starting the BFS from vertex 0:\n\nVisit vertex 0 → Output: [0]\n\nVisit vertex 1 (first neighbor of 0) → Output: [0, 1]\n\nVisit vertex 2 (first unvisited neighbor of 1) → Output: [0, 1, 2]\n\nVisit vertex 3 (next neighbor of 1) → Output: [0, 1, 2, 3]\n\nVisit vertex 4 (neighbor of 3) → Final Output: [0, 1, 2, 3, 4]\n\nWhat is Breadth First Search?\n\nFollow the below given approach:\n• Initialization: Enqueue the given source vertex into a queue and mark it as visited.\n• Exploration: While the queue is not empty:\n• None Dequeue a node from the queue and visit it (e.g., print its value).\n• None For each unvisited neighbor of the dequeued node:\n• None Enqueue the neighbor into the queue.\n• Termination: Repeat step 2 until the queue is empty.\n\nThis algorithm ensures that all nodes in the graph are visited in a breadth-first manner, starting from the starting node.\n\n// create an array to store the traversal // Initially mark all the vertices as not visited // Mark source node as visited and enqueue it // Dequeue a vertex from queue and store it // Get all adjacent vertices of the dequeued // vertex curr If an adjacent has not been // visited, mark it visited and enqueue it // Function to find BFS of Graph from given source s // create an array to store the traversal // Initially mark all the vertices as not visited // Mark source node as visited and enqueue it // Dequeue a vertex from queue and store it // Get all adjacent vertices of the dequeued // vertex curr If an adjacent has not been // visited, mark it visited and enqueue it # Function to find BFS of Graph from given source s # create an array to store the traversal # Initially mark all the vertices as not visited # Mark source node as visited and enqueue it # Dequeue a vertex from queue and store it # Get all adjacent vertices of the dequeued # vertex curr If an adjacent has not been # visited, mark it visited and enqueue it // Function to find BFS of Graph from given source s // create an array to store the traversal // Initially mark all the vertices as not visited // Mark source node as visited and enqueue it // Dequeue a vertex from queue and store it // Get all adjacent vertices of the dequeued // vertex curr If an adjacent has not been // visited, mark it visited and enqueue it // Function to find BFS of Graph from given source s // create an array to store the traversal // Initially mark all the vertices as not visited // Mark source node as visited and enqueue it // Dequeue a vertex from queue and store it // Get all adjacent vertices of the dequeued // vertex curr If an adjacent has not been // visited, mark it visited and enqueue it\n\nThe above implementation takes a source as an input and prints only those vertices that are reachable from the source and would not print all vertices in case of disconnected graph. Let us see the algorithm that prints all vertices without any source and the graph maybe disconnected. The algorithm is simple, instead of calling BFS for a single vertex, we call the above implemented BFS for all not yet visited vertices one by one.\n\n// Mark source node as visited and enqueue it // Get all adjacent vertices of the dequeued // vertex curr If an adjacent has not been // visited, mark it visited and enqueue it // Perform BFS for the entire graph which maybe // create an array to store the traversal // Initially mark all the vertices as not visited // Mark source node as visited and enqueue it // Get all adjacent vertices of the dequeued // vertex curr If an adjacent has not been // visited, mark it visited and enqueue it // Perform BFS for the entire graph which maybe // create an array to store the traversal // Initially mark all the vertices as not visited # Mark source node as visited and enqueue it # Get all adjacent vertices of the dequeued # vertex curr If an adjacent has not been # visited, mark it visited and enqueue it # Perform BFS for the entire graph which maybe # create an array to store the traversal # Initially mark all the vertices as not visited // Mark source node as visited and enqueue it // Get all adjacent vertices of the dequeued // vertex curr If an adjacent has not been // visited, mark it visited and enqueue it // Perform BFS for the entire graph which maybe // create an array to store the traversal // Initially mark all the vertices as not visited // Mark source node as visited and enqueue it // Get all adjacent vertices of the dequeued // vertex curr If an adjacent has not been // visited, mark it visited and enqueue it // Perform BFS for the entire graph which maybe // create an array to store the traversal // Initially mark all the vertices as not visited\n\nTime Complexity: O(V + E), BFS explores all the vertices and edges in the graph. In the worst case, it visits every vertex and edge once. Therefore, the time complexity of BFS is O(V + E), where V and E are the number of vertices and edges in the given graph. Auxiliary Space: O(V), BFS uses a queue to keep track of the vertices that need to be visited. In the worst case, the queue can contain all the vertices in the graph. Therefore, the space complexity of BFS is O(V).\n\nBFS has various applications in graph theory and computer science, including:\n• Shortest Path Finding: BFS can be used to find the shortest path between two nodes in an unweighted graph. By keeping track of the parent of each node during the traversal, the shortest path can be reconstructed.\n• Cycle Detection: BFS can be used to detect cycles in a graph. If a node is visited twice during the traversal, it indicates the presence of a cycle.\n• Connected Components: BFS can be used to identify connected components in a graph. Each connected component is a set of nodes that can be reached from each other.\n• Topological Sorting: BFS can be used to perform topological sorting on a directed acyclic graph (DAG). Topological sorting arranges the nodes in a linear order such that for any edge (u, v), u appears before v in the order.\n• Level Order Traversal of Binary Trees: BFS can be used to perform a level order traversal of a binary tree. This traversal visits all nodes at the same level before moving to the next level.\n• Network Routing: BFS can be used to find the shortest path between two nodes in a network, making it useful for routing data packets in network protocols.\n• None Find the level of a given node in an Undirected Graph\n• None Minimize maximum adjacent difference in a path from top-left to bottom-right\n• None Minimum jump to the same value or adjacent to reach the end of an Array\n• None Maximum coin in minimum time by skipping K obstacles along the path in Matrix\n• None Check if all nodes of the Undirected Graph can be visited from the given Node\n• None Minimum time to visit all nodes of a given Graph at least once\n• None Minimize moves to the next greater element to reach the end of the Array\n• None Minimum time required to infect all the nodes of the Binary tree\n• None Check if destination of given Matrix is reachable with required values of cells\n\nFAQs on Breadth First Search (BFS) for a Graph\n\nQuestion 1: What is BFS and how does it work?\n\nQuestion 2: What are the applications of BFS?\n\nQuestion 3: What is the time complexity of BFS?\n\nQuestion 4: What is the space complexity of BFS?\n\nQuestion 5: What are the advantages of using BFS?\n• None Time and Space Complexity of Breadth First Search (BFS)"
    },
    {
        "link": "https://geeksforgeeks.org/depth-first-search-or-dfs-for-a-graph",
        "document": "Depth First Search or DFS for a Graph\n\nIn Depth First Search (or DFS) for a graph, we traverse all adjacent vertices one by one. When we traverse an adjacent vertex, we completely finish the traversal of all vertices reachable through that adjacent vertex. This is similar to a tree, where we first completely traverse the left subtree and then move to the right subtree. The key difference is that, unlike trees, graphs may contain cycles (a node may be visited more than once). To avoid processing a node multiple times, we use a boolean visited array.\n\nNote : There can be multiple DFS traversals of a graph according to the order in which we pick adjacent vertices. Here we pick vertices as per the insertion order. Output: 1 0 2 3 4\n\nExplanation: The source vertex s is 1. We visit it first, then we visit an adjacent. \n\nStart at 1: Mark as visited. Output: 1\n\nMove to 0: Mark as visited. Output: 0 (backtrack to 1)\n\nMove to 2: Mark as visited. Output: 2 (backtrack to 0)\n\nMove to 3: Mark as visited. Output: 3 (backtrack to 2)\n\nMove to 4: Mark as visited. Output: 4 (backtrack to 2) Not that there can be more than one DFS Traversals of a Graph. For example, after 1, we may pick adjacent 2 instead of 0 and get a different DFS. Here we pick in the insertion order. Start at 0: Mark as visited. Output: 0\n\nMove to 2: Mark as visited. Output: 2\n\nMove to 4: Mark as visited. Output: 4 (backtrack to 2, then backtrack to 0)\n\nMove to 3: Mark as visited. Output: 3 (backtrack to 0)\n\nMove to 1: Mark as visited. Output: 1\n\nDFS from a Given Source of Undirected Graph:\n\nThe algorithm starts from a given source and explores all reachable vertices from the given source. It is similar to Preorder Tree Traversal where we visit the root, then recur for its children. In a graph, there might be loops. So we use an extra visited array to make sure that we do not process a vertex again.\n\nLet us understand the working of Depth First Search with the help of the following illustration: for the source as 0.\n\nBelow is the implementation of the above approach:\n\n// that are not visited yet // To add an edge in an undirected graph // Traverse all adjacent vertices that are not visited yet // Function to add an edge to the adjacency list // Define the edges of the graph // Recursively visit all adjacent vertices that are // Function to add an edge to the adjacency list // Number of vertices in the graph // Create an adjacency list for the graph // Define the edges of the graph # that are not visited yet # Create an adjacency list for the graph # Define the edges of the graph // that are not visited yet // Create an adjacency list for the graph // Define the edges of the graph // Recursively visit all adjacent vertices that are not // Number of vertices in the graph // Create an adjacency list for the graph // Define the edges of the graph\n\nTime complexity: O(V + E), where V is the number of vertices and E is the number of edges in the graph.\n\nAuxiliary Space: O(V + E), since an extra visited array of size V is required, And stack size for recursive calls to DFSRec function.\n\nPlease refer Complexity Analysis of Depth First Search: for details.\n\nThe above implementation takes a source as an input and prints only those vertices that are reachable from the source and would not print all vertices in case of disconnected graph. Let us now talk about the algorithm that prints all vertices without any source and the graph maybe disconnected.\n\nThe idea is simple, instead of calling DFS for a single vertex, we call the above implemented DFS for all all non-visited vertices one by one.\n\n// Recursively visit all adjacent vertices that are not visited yet // Main DFS function to perform DFS for the entire graph // Loop through all vertices to handle disconnected graph // If vertex i has not been visited, // Create an adjacency list for the graph // Define the edges of the graph // Function to add an edge to the adjacency list // Add edge from t to s (for undirected graph) // Traverse all adjacent vertices that are not visited yet // Main DFS function to perform DFS for the entire graph // Loop through all vertices to handle disconnected graph // If vertex i has not been visited, // Define the edges of the graph // Function to add an edge to the adjacency list // Recursively visit all adjacent vertices that are // Main DFS function to perform DFS for the entire graph // Loop through all vertices to handle disconnected // Create an adjacency list for the graph // Define the edges of the graph # that are not visited yet # Loop through all vertices to handle disconnected # Define the edges of the graph // Function to add an edge to the adjacency list // that are not visited yet // Main DFS function to perform DFS for the entire graph // Loop through all vertices to handle // If vertex i has not been visited, // Create an adjacency list for the graph // Define the edges of the graph using tuples // Recursively visit all adjacent vertices that are not // Main DFS function to perform DFS for the entire graph // Loop through all vertices to handle disconnected // Create an adjacency list for the graph // Define the edges of the graph\n\nTime complexity: O(V + E). Note that the time complexity is same here because we visit every vertex at most once and every edge is traversed at most once (in directed) and twice in undirected.\n\nAuxiliary Space: O(V + E), since an extra visited array of size V is required, And stack size for recursive calls to DFSRec function.\n• None Depth First Search or DFS on Directed Graph\n• None Breadth First Search or BFS for a Graph"
    },
    {
        "link": "https://medium.com/@hanxuyang0826/mastering-dfs-and-bfs-in-c-techniques-implementations-and-leetcode-examples-57dbe66a140c",
        "document": "In this blog post, we will explore two fundamental graph traversal algorithms: Depth-First Search (DFS) and Breadth-First Search (BFS). These algorithms are essential tools for solving many programming problems that involve traversing or searching through data structures such as trees and graphs. Both DFS and BFS have distinct ways of exploring nodes and edges, making them suitable for different types of problems, from finding the shortest path in a maze to counting connected components in a network.\n\nWe will cover the core concepts behind DFS and BFS, how they work, and the scenarios where one is preferred over the other. Additionally, we will implement these algorithms in C# and dive into real-world applications, particularly in geometry and pathfinding. We will also look at common problems on platforms like LeetCode, where DFS and BFS can be used to effectively solve challenges such as traversing matrices, finding islands in grids, and solving puzzles. Understanding how and when to use these algorithms will help improve both your problem-solving skills and code efficiency."
    },
    {
        "link": "https://digitalocean.com/community/tutorials/breadth-first-search-depth-first-search-bfs-dfs",
        "document": "Breadth-First Search and Depth-First Search are two techniques of traversing graphs and trees. In this tutorial, we will focus mainly on BFS and DFS traversals in trees.\n\nWhat is Depth First Search (DFS)?\n\nThe algorithm begins at the root node and then it explores each branch before backtracking. It is implemented using stacks. Often while writing the code, we use recursion stacks to backtrack. By using recursion we are able to take advantage of the fact that left and right subtrees are also trees and share the same properties.\n\nFor Binary trees, there are three types of DFS traversals.\n\nThis algorithm also begins at the root node and then visits all nodes level by level. That means after the root, it traverses all the direct children of the root. After all direct children of the root are traversed, it moves to their children and so on. To implement BFS we use a queue.\n\nFor Binary trees, we have Level Order Traversal which follows BFS.\n\nImplementation of BFS and DFS in Java\n\nLet the tree under consideration be:\n\nThe structure of TreeNode class is as follows :\n\nIn pre-order traversal of a binary tree, we first traverse the root, then the left subtree and then finally the right subtree. We do this recursively to benefit from the fact that left and right subtrees are also trees.\n\nThe algorithm for pre-order traversal is as follows:\n• Call preorder() on the right subtree.\n\nThe Pre-Order traversal of the tree above is:\n\nThe java code is as follows:\n\nIn-order traversal of a binary tree first traverses the left subtree then the root and finally the right subtree.\n\nThe algorithm for in-order traversal is as follows:\n\nThe in-order traversal of the tree above is:\n\nThe java code is as follows :\n\nPost-order traversal of a binary tree first traverses the left subtree then the right subtree and then finally the root.\n\nThe algorithm for post-order traversal is as follows:\n\nThe post-order traversal of the tree above is:\n\nThe java code is as follows :\n\nLevel order traversal uses a queue to keep track of nodes to visit. After visiting a node, its children are put in the queue. To get a new node to traverse, we take out elements from the queue.\n\nThe algorithm is as follows:\n• Run a Loop till queue is not empty\n• Enqueue temp’s children in the order left then right.\n• Dequeue a node from the queue and assign it’s value to temp.\n\nLevel order traversal of the tree above is :\n\nThe java code is as follows :\n\nComplete Code Implementation of BFS and DFS in Java\n\nThe complete Java code is given below :\n\nThis tutorial was about BFS and DFS traversals in binary trees. To get DFS implementation in C++ refer to this tutorial. For C++ implementation of level order traversal refer to this tutorial."
    },
    {
        "link": "https://celerdata.com/glossary/breadth-first-search-bfs",
        "document": "Breadth-First Search (BFS) is one of the simplest and most widely used algorithms for searching a graph. It systematically explores all nodes in the graph to find a solution, starting from a given starting point (or root node) and moving outward layer by layer. The algorithm does not make assumptions about the possible location of the solution but explores all nodes equally, ensuring that it checks every possibility until it finds the target node or exhausts all options.\n• Graph: A structure consisting of nodes (also called vertices) and edges connecting them. In BFS, the graph can be directed or undirected.\n• Node (Vertex): The individual elements or points in a graph where edges meet. BFS begins at a specific node and explores outward from it.\n• Edge: A connection between two nodes. In BFS, edges define how nodes are connected and dictate the traversal path.\n• Queue: A First-In-First-Out (FIFO) data structure used in BFS to track nodes that need to be explored. Nodes are added to the queue when discovered and removed when explored.\n• Visited Set: A collection of nodes that have already been explored to avoid revisiting the same node multiple times.\n• Root/Starting Node: The node where the BFS algorithm begins. From this node, the search proceeds to explore the graph.\n• Level/Layer: Refers to the distance from the starting node. BFS explores all nodes at the same level before moving on to nodes further away.\n\nBFS operates by exploring a graph level by level, starting from a given node and expanding outward based on distance. The detailed steps are:\n• Mark the start node as visited and place it in a queue.\n• Remove a node from the queue, visit it, and perform necessary actions.\n• Add all unvisited neighboring nodes of the current node to the queue and mark them as visited.\n• Repeat steps 2 and 3 until the queue is empty, indicating that all reachable nodes have been processed.\n\nThis process continues level by level, visiting each node's neighbors, until all nodes have been explored or the target is found. BFS is often used as the foundation for more advanced algorithms, such as Dijkstra's algorithm for finding the shortest path and Prim's algorithm for constructing minimum spanning trees.\n\nConsider the following graph structure:\n\nIn this graph, nodes (also known as vertices) are represented by letters, and edges are the connections between these nodes.\n\nBFS Traversal on the Example Graph\n\nBFS explores the graph level by level, starting from a chosen root node (vertex A in this case). Here's how the traversal proceeds:\n• \n• Mark as visited to avoid revisiting it.\n• \n• Step 1: Dequeue from the queue (current node) and visit it. Then enqueue its neighbors and , and mark them as visited.\n• Step 2: Dequeue and visit it. Then enqueue its neighbors and , marking them as visited.\n• Step 3: Dequeue and visit it. Then enqueue its neighbor , and mark as visited.\n• Step 4: Dequeue and visit it. Since has no neighbors, move to the next node.\n• Step 5: Dequeue and visit it. Similarly, has no neighbors.\n• Step 6: Dequeue and visit it. has no neighbors.\n\nThe nodes are visited in the following order:\n• Explanation: The time complexity of BFS is O(V + E), where:\n• V represents the number of vertices (nodes) in the graph.\n• E represents the number of edges (connections between nodes). BFS explores every vertex and examines each edge once, resulting in this linear time complexity. This makes it efficient for traversing graphs, whether large or small.\n• \n• Best Case: BFS quickly finds the target node close to the start.\n• Worst Case: BFS needs to explore the entire graph before reaching the target node.\n• Explanation: The space complexity of BFS is O(V), where is the number of vertices. This is because BFS uses:\n• A queue to store vertices that are waiting to be explored.\n• A visited set to track which nodes have already been visited. In the worst case, the size of the queue could be as large as the number of vertices at the largest level of the graph, leading to O(V) space usage.\n• Memory Usage: The memory needed for BFS depends on the graph size. In addition to the queue, BFS needs space for the visited set or array, which has a size of O(V).\n• Shortest Path in Unweighted Graphs:\n\nBFS guarantees the shortest path in an unweighted graph by exploring nodes in increasing order of distance from the start. This is particularly useful in network routing, such as finding the most efficient path in road networks (e.g., Google Maps uses BFS for unweighted roads).\n• Web Crawlers:\n\nWeb crawlers use BFS to systematically explore web pages. Starting from a seed URL, the crawler visits all links on that page, then proceeds to follow links from those pages, layer by layer. This method ensures a comprehensive search across a defined depth.\n• Bipartite Graph Checking:\n\nBFS helps check if a graph is bipartite by attempting to color nodes with two colors. If BFS detects any adjacent nodes having the same color, the graph is not bipartite. This is used in scheduling problems and matching algorithms.\n• Finding Connected Components:\n\nIn an undirected graph, BFS can identify connected components by exploring all vertices reachable from a starting vertex. Once a component is fully explored, BFS moves to the next unvisited node to find the next component. This is important for clustering and social network analysis.\n\nThe following Python code demonstrates the implementation of the Breadth-First Search (BFS) algorithm:\n• A queue is used to track the vertices to be explored next.\n• The set ensures that vertices are not revisited.\n• As the queue processes each vertex, its unvisited neighbors are enqueued, and the process repeats.\n\nThe following Java code demonstrates the implementation of the Breadth-First Search (BFS) algorithm:\n\nThe Java code defines a method that takes a graph and a starting vertex as inputs. The method uses a to track visited vertices and a as a queue.\n• Initialization: The code adds the starting vertex to the visited set and enqueues it.\n• Exploration: While the queue is not empty, the code dequeues a vertex, prints it, and enqueues its unvisited neighbors.\n• Termination: The process continues until the queue becomes empty.\n\nThe method creates an example graph using a and initiates the BFS traversal from vertex .\n\nThe following C++ code demonstrates the implementation of the Breadth-First Search (BFS) algorithm:\n\nThe C++ code defines a function that takes a graph and a starting vertex as inputs. The function uses an to track visited vertices and a to manage the order of exploration.\n• Initialization: The code inserts the starting vertex into the visited set and enqueues it.\n• Exploration: While the queue is not empty, the code dequeues a vertex, prints it, and enqueues its unvisited neighbors.\n• Termination: The process continues until the queue becomes empty.\n\nThe function creates an example graph using an and initiates the BFS traversal from vertex .\n• Traversal Strategy:\n• DFS explores as far down a branch as possible using a stack (or recursion) before backtracking.\n• Use Cases:\n• BFS is ideal for finding the shortest path in unweighted graphs.\n• DFS is more suited for tasks like topological sorting and solving mazes.\n• \n• Dijkstra’s Algorithm is designed for weighted graphs, finding the shortest path based on cumulative edge weights.\n• \n• BFS is useful in social networks and bipartite graph checking.\n• Dijkstra's Algorithm is used in GPS systems and network routing where edge weights represent distances or costs.\n\nBFS is a systematic and efficient graph traversal algorithm, providing a foundation for solving various problems, such as finding the shortest path, analyzing network structures, and more. Its simplicity and guaranteed exploration of all reachable nodes make it a powerful tool in computer science."
    }
]