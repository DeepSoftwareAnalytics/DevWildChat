[
    {
        "link": "https://techonthenet.com/postgresql/union_all.php",
        "document": "The PostgreSQL UNION ALL operator is used to combine the result sets of 2 or more SELECT statements. It returns all rows from the query and it does not remove duplicate rows between the various SELECT statements. Each SELECT statement within the PostgreSQL UNION ALL operator must have the same number of fields in the result sets with similar data types.\n\nThe syntax for the UNION ALL operator in PostgreSQL is: SELECT expression1, expression2, ... expression_n FROM tables [WHERE conditions] UNION ALL SELECT expression1, expression2, ... expression_n FROM tables [WHERE conditions]; The columns or calculations that you wish to retrieve. The tables that you wish to retrieve records from. There must be at least one table listed in the FROM clause. Optional. The conditions that must be met for the records to be selected.\n\nThe following is an example of the PostgreSQL UNION ALL operator that returns one field from multiple SELECT statements (and both fields have the same data type): SELECT category_id FROM products UNION ALL SELECT category_id FROM categories; This PostgreSQL UNION ALL operator would return a category_id multiple times in your result set if the category_id appeared in both the products and categories table. The PostgreSQL UNION ALL operator does not remove duplicates. If you wish to remove duplicates, try using the PostgreSQL UNION operator.\n\nExample - Using ORDER BY The PostgreSQL UNION ALL operator can use the ORDER BY clause to order the results of the operator. SELECT product_id, product_name FROM products WHERE product_name LIKE 'S%' UNION SELECT category_id, category_name FROM categories WHERE category_id < 99 ORDER BY 2; In this PostgreSQL UNION ALL operator, since the column names are different between the two SELECT statements, it is more advantageous to reference the columns in the ORDER BY clause by their position in the result set. In this example, we've sorted the results by product_name / category_name in ascending order, as denoted by the . The product_name / category_name fields are in position #2 in the result set."
    },
    {
        "link": "https://w3schools.com/postgresql/postgresql_union.php",
        "document": "The operator is used to combine the result-set of two or more queries.\n\nThe queries in the union must follow these rules:\n• They must have the same number of columns\n• The columns must have the same data types\n• The columns must be in the same order\n\nCombine and using the operator: Run Example »\n\nWith the operator, if some rows in the two queries returns the exact same result, only one row will be listed, because selects only distinct values.\n\nLet's make some changes to the queries, so that we have duplicate values in the result:"
    },
    {
        "link": "https://postgresql.org/docs/current/queries-union.html",
        "document": "The results of two queries can be combined using the set operations union, intersection, and difference. The syntax is\n\nwhere and are queries that can use any of the features discussed up to this point.\n\neffectively appends the result of to the result of (although there is no guarantee that this is the order in which the rows are actually returned). Furthermore, it eliminates duplicate rows from its result, in the same way as , unless is used.\n\nreturns all rows that are both in the result of and in the result of . Duplicate rows are eliminated unless is used.\n\nreturns all rows that are in the result of but not in the result of . (This is sometimes called the difference between two queries.) Again, duplicates are eliminated unless is used.\n\nIn order to calculate the union, intersection, or difference of two queries, the two queries must be “union compatible”, which means that they return the same number of columns and the corresponding columns have compatible data types, as described in Section 10.5.\n\nSet operations can be combined, for example\n\nwhich is equivalent to\n\nAs shown here, you can use parentheses to control the order of evaluation. Without parentheses, and associate left-to-right, but binds more tightly than those two operators. Thus\n\nYou can also surround an individual with parentheses. This is important if the needs to use any of the clauses discussed in following sections, such as . Without parentheses, you'll get a syntax error, or else the clause will be understood as applying to the output of the set operation rather than one of its inputs. For example,\n\nis accepted, but it means"
    },
    {
        "link": "https://neon.tech/postgresql/postgresql-tutorial/postgresql-union",
        "document": "Summary: in this tutorial, you will learn how to use the PostgreSQL operator to combine result sets of multiple queries into a single result set.\n\nThe operator allows you to combine the result sets of two or more statements into a single result set.\n\nHere’s the basic syntax of the operator:\n\nIn this syntax, the queries must conform to the following rules:\n• The number and the order of the columns in the select list of both queries must be the same.\n• The data types of the columns in select lists of the queries must be compatible.\n\nThe operator removes all duplicate rows from the combined data set. To retain the duplicate rows, you use the instead.\n\nHere’s the syntax of the operator:\n\nThe following Venn diagram illustrates how the works:\n\nThe and operators may order the rows in the final result set in an unspecified order. For example, it may place rows from the second result set before/after the row from the first result set.\n\nTo sort rows in the final result set, you specify the clause after the second query:\n\nNote that if you use the clause in the first query, PostgreSQL will issue an error.\n\nThe following statements create two tables and , and insert data into these tables:\n\nThe following statement retrieves data from the table:\n\nThe following statement retrieves data from the table:\n\nLet’s take some examples of using the PostgreSQL operator.\n\nThe following statement uses the operator to combine data from the queries that retrieve data from the and :\n\nThe result set includes six rows because the operator removes two duplicate rows.\n\nThe following statement uses the operator to combine result sets from queries that retrieve data from and tables:\n\nThe output indicates that the operator retains the duplicate rows.\n\n3) PostgreSQL UNION ALL with ORDER BY clause example\n\nTo sort the result returned by the operator, you place the clause after the second query:\n• Use the to combine result sets of two queries and return distinct rows.\n• Use the to combine the result sets of two queries but retain the duplicate rows."
    },
    {
        "link": "https://commandprompt.com/education/postgresql-union-all-operator-with-examples",
        "document": "PostgreSQL offers UNION and UNION ALL operators that combine/merge the result sets of at least two SELECT queries. Both these operators are responsible for combining the result set of different queries into one table. However, the behavior of both these operators is different, i.e., UNION combines only distinct records, while UNION ALL combines all records, including duplicates.\n\nThis guide will demonstrate how to combine different result sets using the UNION ALL operator in Postgres. For this purpose, the below-mentioned concepts will be discussed in this write-up:\n• How to Use the UNION ALL Operator in Postgres?\n\nFirstly we will create a couple of sample tables named “book_details” and “top_selling_books” using the CREATE TABLE statement:\n\nNow, we will use the INSERT INTO command to insert data into the newly created \"book_details\" table:\n\nIn the above code snippet, twelve records have been inserted into the book_details table using the INSERT query.\n\nLet’s create one more table named “top_selling_books” using the CREATE TABLE command:\n\nNow, we will execute the INSERT query to insert data into the newly created \"book_details\" table:\n\nThe above snippet indicates that nine records have been inserted into the “top_selling_books” table using the INSERT query.\n\nBefore moving towards the UNION ALL operator, firstly, we will comprehend the working of the UNION operator.\n\nTo get the services of the UNION operator, users must follow the below syntax:\n\nTo combine the result sets of table_1 and table_2, the UNION operator is used in the above syntax.\n\nExample: How the UNION Operator Works in Postgres?\n\nIn this example, we will use the UNION operator to combine the result sets of book_details and top_selling_books:\n\nFrom the output, you can observe that the result sets of the “book_details” and “top_selling_books” have been combined successfully. However, the resultant table contains only unique records.\n\nHow to Use Postgres UNION All Operator?\n\nTo include the duplicates in the resultant table, users must use the UNION ALL operator instead of the UNION operator:\n\nThe syntax mentioned above will be used to combine the result set of table_1 with the result set of table_2, including the duplicates.\n\nThe below-listed points explain the concept of UNION ALL operator in more detail:\n\n- While using the UNION ALL operator, both SELECT statements must contain the same number of expressions/columns.\n\n- Use the WHERE clause and the UNION ALL operator to combine the filtered data(based on some particular condition).\n\n- Use the ORDER BY clause with the UNION ALL operator to sort the data of the resultant table in a specific format, i.e., ASC or DESC.\n\n- The resultant table will have the same column names as the first SELECT statement.\n\nExample 1: How Does the UNION ALL Operator Work in Postgres?\n\nExecute the following query to combine the result sets of the “top_selling_books” and “book_details” tables:\n\nThe output snippet proves that the UNION ALL operator retrieves a total of twenty-one records, including duplicates.\n\nExample 2: How to Sort the Result Set of UNION ALL Operator in Descending Order?\n\nNow, using the ORDER BY clause in conjunction with the UNION ALL operator, we will sort the result set retrieved by the UNION ALL operator as follows:\n\nThe result set will be sorted based on the “b_id” column:\n\nThe output proves that the ORDER BY clause sorted the resultant table in descending order.\n\nThat’s all from this Postgres guide!\n\nIn Postgres, the UNION ALL operator combines the result sets of two or more queries into one table, including the duplicate records. While using the UNION ALL operator, both SELECT statements must contain the same number of expressions/columns. The resultant table will have the same column names as the first SELECT statement. This Postgres blog went through various examples to explain the working of the Postgres UNION ALL operator."
    },
    {
        "link": "https://stackoverflow.com/questions/49452711/can-we-union-two-tables-with-different-number-of-columns-such-that-the-query-add",
        "document": "I have tables where data has been fed across different time periods in the year. Although similar, these tables have different number of columns for each quarter. I know if I want to union two tables with different number of columns, the solution is just to add the extra number of columns as null columns.\n\nHowever, in this case, I have more than 22 tables, each having 4 versions which need to be union. For example TableA_Q1 union TableA_Q2 union TableA_Q3 union TableA_Q4, and then repeat the same process for TableB_Q1 union TableB_Q2 and so on.\n\nRight now, I am doing an intersect across 4 quarters for each of the Table and then started using excel to identify the remaining columns, but there has to be an easier way to do this. Any ideas?"
    },
    {
        "link": "https://stackoverflow.com/questions/51595565/select-union-count-and-group-multiple-tables-postgresql",
        "document": "By aggregating each table, you get a result like this:\n\nbecause doesn't detect any duplicates, because of the different count. And if there where two rows with the same count, one would be removed and the count accordingly too small by 50%.\n\nYou probably want this:\n\ninstead with the total count, no matter in which tables. So get a set of all records first (with ), then aggregate."
    },
    {
        "link": "https://citusdata.com/blog/2016/10/12/count-performance",
        "document": "Customer-facing real-time analytics dashboards need to deliver sub-second query responses to 1000s of concurrent users, while simultaneously ingesting fresh data and enabling users to query the fresh data in real time, too.\n\nBy scaling out Postgres across multiple nodes, Citus gives your analytics dashboards the compute, memory, and performance they need to process billions of events in real time."
    },
    {
        "link": "https://postgresql.org/docs/current/sql-select.html",
        "document": "You must have SELECT privilege on each column used in a SELECT command. The use of FOR NO KEY UPDATE , FOR UPDATE , FOR SHARE or FOR KEY SHARE requires UPDATE privilege as well (for at least one column of each table so selected).\n\nIf FOR UPDATE , FOR NO KEY UPDATE , FOR SHARE or FOR KEY SHARE is specified, the SELECT statement locks the selected rows against concurrent updates. (See The Locking Clause below.)\n\nIf the LIMIT (or FETCH FIRST ) or OFFSET clause is specified, the SELECT statement only returns a subset of the result rows. (See LIMIT Clause below.)\n\nIf the ORDER BY clause is specified, the returned rows are sorted in the specified order. If ORDER BY is not given, the rows are returned in whatever order the system finds fastest to produce. (See ORDER BY Clause below.)\n\nUsing the operators UNION , INTERSECT , and EXCEPT , the output of more than one SELECT statement can be combined to form a single result set. The UNION operator returns all rows that are in one or both of the result sets. The INTERSECT operator returns all rows that are strictly in both result sets. The EXCEPT operator returns the rows that are in the first result set but not in the second. In all three cases, duplicate rows are eliminated unless ALL is specified. The noise word DISTINCT can be added to explicitly specify eliminating duplicate rows. Notice that DISTINCT is the default behavior here, even though ALL is the default for SELECT itself. (See UNION Clause , INTERSECT Clause , and EXCEPT Clause below.)\n\nSELECT DISTINCT eliminates duplicate rows from the result. SELECT DISTINCT ON eliminates rows that match on all the specified expressions. SELECT ALL (the default) will return all candidate rows, including duplicates. (See DISTINCT Clause below.)\n\nThe actual output rows are computed using the SELECT output expressions for each selected row or row group. (See SELECT List below.)\n\nIf the GROUP BY clause is specified, or if there are aggregate function calls, the output is combined into groups of rows that match on one or more values, and the results of aggregate functions are computed. If the HAVING clause is present, it eliminates groups that do not satisfy the given condition. (See GROUP BY Clause and HAVING Clause below.) Although query output columns are nominally computed in the next step, they can also be referenced (by name or ordinal number) in the GROUP BY clause.\n\nIf the WHERE clause is specified, all rows that do not satisfy the condition are eliminated from the output. (See WHERE Clause below.)\n\nAll elements in the FROM list are computed. (Each element in the FROM list is a real or virtual table.) If more than one element is specified in the FROM list, they are cross-joined together. (See FROM Clause below.)\n\nAll queries in the WITH list are computed. These effectively serve as temporary tables that can be referenced in the FROM list. A WITH query that is referenced more than once in FROM is computed only once, unless specified otherwise with NOT MATERIALIZED . (See WITH Clause below.)\n\nSELECT retrieves rows from zero or more tables. The general processing of SELECT is as follows:\n\nThe clause allows you to specify one or more subqueries that can be referenced by name in the primary query. The subqueries effectively act as temporary tables or views for the duration of the primary query. Each subquery can be a , , , , , , or statement. When writing a data-modifying statement ( , , , or ) in , it is usual to include a clause. It is the output of , not the underlying table that the statement modifies, that forms the temporary table that is read by the primary query. If is omitted, the statement is still executed, but it produces no output so it cannot be referenced as a table by the primary query. A name (without schema qualification) must be specified for each query. Optionally, a list of column names can be specified; if this is omitted, the column names are inferred from the subquery. If is specified, it allows a subquery to reference itself by name. Such a subquery must have the form where the recursive self-reference must appear on the right-hand side of the . Only one recursive self-reference is permitted per query. Recursive data-modifying statements are not supported, but you can use the results of a recursive query in a data-modifying statement. See Section 7.8 for an example. Another effect of is that queries need not be ordered: a query can reference another one that is later in the list. (However, circular references, or mutual recursion, are not implemented.) Without , queries can only reference sibling queries that are earlier in the list. When there are multiple queries in the clause, should be written only once, immediately after . It applies to all queries in the clause, though it has no effect on queries that do not use recursion or forward references. The optional clause computes a search sequence column that can be used for ordering the results of a recursive query in either breadth-first or depth-first order. The supplied column name list specifies the row key that is to be used for keeping track of visited rows. A column named will be added to the result column list of the query. This column can be ordered by in the outer query to achieve the respective ordering. See Section 7.8.2.1 for examples. The optional clause is used to detect cycles in recursive queries. The supplied column name list specifies the row key that is to be used for keeping track of visited rows. A column named will be added to the result column list of the query. This column will be set to when a cycle has been detected, else to . Furthermore, processing of the recursive union will stop when a cycle has been detected. and must be constants and they must be coercible to a common data type, and the data type must have an inequality operator. (The SQL standard requires that they be Boolean constants or character strings, but PostgreSQL does not require that.) By default, and (of type ) are used. Furthermore, a column named will be added to the result column list of the query. This column is used internally for tracking visited rows. See Section 7.8.2.2 for examples. Both the and the clause are only valid for recursive queries. The must be a (or ) of two (or equivalent) commands (no nested s). If both clauses are used, the column added by the clause appears before the columns added by the clause. The primary query and the queries are all (notionally) executed at the same time. This implies that the effects of a data-modifying statement in cannot be seen from other parts of the query, other than by reading its output. If two such data-modifying statements attempt to modify the same row, the results are unspecified. A key property of queries is that they are normally evaluated only once per execution of the primary query, even if the primary query refers to them more than once. In particular, data-modifying statements are guaranteed to be executed once and only once, regardless of whether the primary query reads all or any of their output. However, a query can be marked to remove this guarantee. In that case, the query can be folded into the primary query much as though it were a simple sub- in the primary query's clause. This results in duplicate computations if the primary query refers to that query more than once; but if each such use requires only a few rows of the query's total output, can provide a net savings by allowing the queries to be optimized jointly. is ignored if it is attached to a query that is recursive or is not side-effect-free (i.e., is not a plain containing no volatile functions). By default, a side-effect-free query is folded into the primary query if it is used exactly once in the primary query's clause. This allows joint optimization of the two query levels in situations where that should be semantically invisible. However, such folding can be prevented by marking the query as . That might be useful, for example, if the query is being used as an optimization fence to prevent the planner from choosing a bad plan. PostgreSQL versions before v12 never did such folding, so queries written for older versions might rely on to act as an optimization fence.\n\nThe clause specifies one or more source tables for the . If multiple sources are specified, the result is the Cartesian product (cross join) of all the sources. But usually qualification conditions are added (via ) to restrict the returned rows to a small subset of the Cartesian product. The clause can contain the following elements: The name (optionally schema-qualified) of an existing table or view. If is specified before the table name, only that table is scanned. If is not specified, the table and all its descendant tables (if any) are scanned. Optionally, can be specified after the table name to explicitly indicate that descendant tables are included. A substitute name for the item containing the alias. An alias is used for brevity or to eliminate ambiguity for self-joins (where the same table is scanned multiple times). When an alias is provided, it completely hides the actual name of the table or function; for example given , the remainder of the must refer to this item as not . If an alias is written, a column alias list can also be written to provide substitute names for one or more columns of the table. A clause after a indicates that the specified should be used to retrieve a subset of the rows in that table. This sampling precedes the application of any other filters such as clauses. The standard PostgreSQL distribution includes two sampling methods, and , and other sampling methods can be installed in the database via extensions. The and sampling methods each accept a single which is the fraction of the table to sample, expressed as a percentage between 0 and 100. This argument can be any -valued expression. (Other sampling methods might accept more or different arguments.) These two methods each return a randomly-chosen sample of the table that will contain approximately the specified percentage of the table's rows. The method scans the whole table and selects or ignores individual rows independently with the specified probability. The method does block-level sampling with each block having the specified chance of being selected; all rows in each selected block are returned. The method is significantly faster than the method when small sampling percentages are specified, but it may return a less-random sample of the table as a result of clustering effects. The optional clause specifies a number or expression to use for generating random numbers within the sampling method. The seed value can be any non-null floating-point value. Two queries that specify the same seed and values will select the same sample of the table, if the table has not been changed meanwhile. But different seed values will usually produce different samples. If is not given then a new random sample is selected for each query, based upon a system-generated seed. Note that some add-on sampling methods do not accept , and will always produce new samples on each use. A sub- can appear in the clause. This acts as though its output were created as a temporary table for the duration of this single command. Note that the sub- must be surrounded by parentheses, and an alias can be provided in the same way as for a table. A command can also be used here. A query is referenced by writing its name, just as though the query's name were a table name. (In fact, the query hides any real table of the same name for the purposes of the primary query. If necessary, you can refer to a real table of the same name by schema-qualifying the table's name.) An alias can be provided in the same way as for a table. Function calls can appear in the clause. (This is especially useful for functions that return result sets, but any function can be used.) This acts as though the function's output were created as a temporary table for the duration of this single command. If the function's result type is composite (including the case of a function with multiple parameters), each attribute becomes a separate column in the implicit table. When the optional clause is added to the function call, an additional column of type will be appended to the function's result column(s). This column numbers the rows of the function's result set, starting from 1. By default, this column is named . An alias can be provided in the same way as for a table. If an alias is written, a column alias list can also be written to provide substitute names for one or more attributes of the function's composite return type, including the ordinality column if present. Multiple function calls can be combined into a single -clause item by surrounding them with . The output of such an item is the concatenation of the first row from each function, then the second row from each function, etc. If some of the functions produce fewer rows than others, null values are substituted for the missing data, so that the total number of rows returned is always the same as for the function that produced the most rows. If the function has been defined as returning the data type, then an alias or the key word must be present, followed by a column definition list in the form . The column definition list must match the actual number and types of columns returned by the function. When using the syntax, if one of the functions requires a column definition list, it's preferred to put the column definition list after the function call inside . A column definition list can be placed after the construct only if there's just a single function and no clause. To use together with a column definition list, you must use the syntax and put the column definition list inside . For the and join types, a join condition must be specified, namely exactly one of , , or . See below for the meaning. A clause combines two items, which for convenience we will refer to as “tables”, though in reality they can be any type of item. Use parentheses if necessary to determine the order of nesting. In the absence of parentheses, s nest left-to-right. In any case binds more tightly than the commas separating -list items. All the options are just a notational convenience, since they do nothing you couldn't do with plain and . returns all rows in the qualified Cartesian product (i.e., all combined rows that pass its join condition), plus one copy of each row in the left-hand table for which there was no right-hand row that passed the join condition. This left-hand row is extended to the full width of the joined table by inserting null values for the right-hand columns. Note that only the clause's own condition is considered while deciding which rows have matches. Outer conditions are applied afterwards. Conversely, returns all the joined rows, plus one row for each unmatched right-hand row (extended with nulls on the left). This is just a notational convenience, since you could convert it to a by switching the left and right tables. returns all the joined rows, plus one row for each unmatched left-hand row (extended with nulls on the right), plus one row for each unmatched right-hand row (extended with nulls on the left). is an expression resulting in a value of type (similar to a clause) that specifies which rows in a join are considered to match. A clause of the form is shorthand for . Also, implies that only one of each pair of equivalent columns will be included in the join output, not both. If a name is specified, it provides a table alias for the join columns. Only the join columns listed in the clause are addressable by this name. Unlike a regular , this does not hide the names of the joined tables from the rest of the query. Also unlike a regular , you cannot write a column alias list — the output names of the join columns are the same as they appear in the list. is shorthand for a list that mentions all columns in the two tables that have matching names. If there are no common column names, is equivalent to . is equivalent to , that is, no rows are removed by qualification. They produce a simple Cartesian product, the same result as you get from listing the two tables at the top level of , but restricted by the join condition (if any). The key word can precede a sub- item. This allows the sub- to refer to columns of items that appear before it in the list. (Without , each sub- is evaluated independently and so cannot cross-reference any other item.) can also precede a function-call item, but in this case it is a noise word, because the function expression can refer to earlier items in any case. A item can appear at top level in the list, or within a tree. In the latter case it can also refer to any items that are on the left-hand side of a that it is on the right-hand side of. When a item contains cross-references, evaluation proceeds as follows: for each row of the item providing the cross-referenced column(s), or set of rows of multiple items providing the columns, the item is evaluated using that row or row set's values of the columns. The resulting row(s) are joined as usual with the rows they were computed from. This is repeated for each row or set of rows from the column source table(s). The column source table(s) must be or joined to the item, else there would not be a well-defined set of rows from which to compute each set of rows for the item. Thus, although a construct such as is syntactically valid, it is not actually allowed for to reference .\n\nThe optional clause has the general form will condense into a single row all selected rows that share the same values for the grouped expressions. An used inside a can be an input column name, or the name or ordinal number of an output column ( list item), or an arbitrary expression formed from input-column values. In case of ambiguity, a name will be interpreted as an input-column name rather than an output column name. If any of , or are present as grouping elements, then the clause as a whole defines some number of independent . The effect of this is equivalent to constructing a between subqueries with the individual grouping sets as their clauses. The optional clause removes duplicate sets before processing; it does not transform the into a . For further details on the handling of grouping sets see Section 7.2.4. Aggregate functions, if any are used, are computed across all rows making up each group, producing a separate value for each group. (If there are aggregate functions but no clause, the query is treated as having a single group comprising all the selected rows.) The set of rows fed to each aggregate function can be further filtered by attaching a clause to the aggregate function call; see Section 4.2.7 for more information. When a clause is present, only those rows matching it are included in the input to that aggregate function. When is present, or any aggregate functions are present, it is not valid for the list expressions to refer to ungrouped columns except within aggregate functions or when the ungrouped column is functionally dependent on the grouped columns, since there would otherwise be more than one possible value to return for an ungrouped column. A functional dependency exists if the grouped columns (or a subset thereof) are the primary key of the table containing the ungrouped column. Keep in mind that all aggregate functions are evaluated before evaluating any “scalar” expressions in the clause or list. This means that, for example, a expression cannot be used to skip evaluation of an aggregate function; see Section 4.2.14. Currently, , , and cannot be specified with .\n\nThe optional clause has the general form where is a name that can be referenced from clauses or subsequent window definitions, and is [ ] [ PARTITION BY [, ...] ] [ ORDER BY [ ASC | DESC | USING ] [ NULLS { FIRST | LAST } ] [, ...] ] [ ] If an is specified it must refer to an earlier entry in the list; the new window copies its partitioning clause from that entry, as well as its ordering clause if any. In this case the new window cannot specify its own clause, and it can specify only if the copied window does not have one. The new window always uses its own frame clause; the copied window must not specify a frame clause. The elements of the list are interpreted in much the same fashion as elements of a clause, except that they are always simple expressions and never the name or number of an output column. Another difference is that these expressions can contain aggregate function calls, which are not allowed in a regular clause. They are allowed here because windowing occurs after grouping and aggregation. Similarly, the elements of the list are interpreted in much the same fashion as elements of a statement-level clause, except that the expressions are always taken as simple expressions and never the name or number of an output column. The optional defines the window frame for window functions that depend on the frame (not all do). The window frame is a set of related rows for each row of the query (called the current row). The can be one of where and can be one of and can be one of If is omitted it defaults to . Restrictions are that cannot be , cannot be , and the choice cannot appear earlier in the above list of and options than the choice does — for example is not allowed. The default framing option is , which is the same as ; it sets the frame to be all rows from the partition start up through the current row's last peer (a row that the window's clause considers equivalent to the current row; all rows are peers if there is no ). In general, means that the frame starts with the first row of the partition, and similarly means that the frame ends with the last row of the partition, regardless of , or mode. In mode, means that the frame starts or ends with the current row; but in or mode it means that the frame starts or ends with the current row's first or last peer in the ordering. The and options vary in meaning depending on the frame mode. In mode, the is an integer indicating that the frame starts or ends that many rows before or after the current row. In mode, the is an integer indicating that the frame starts or ends that many peer groups before or after the current row's peer group, where a peer group is a group of rows that are equivalent according to the window's clause. In mode, use of an option requires that there be exactly one column in the window definition. Then the frame contains those rows whose ordering column value is no more than less than (for ) or more than (for ) the current row's ordering column value. In these cases the data type of the expression depends on the data type of the ordering column. For numeric ordering columns it is typically of the same type as the ordering column, but for datetime ordering columns it is an . In all these cases, the value of the must be non-null and non-negative. Also, while the does not have to be a simple constant, it cannot contain variables, aggregate functions, or window functions. The option allows rows around the current row to be excluded from the frame, even if they would be included according to the frame start and frame end options. excludes the current row from the frame. excludes the current row and its ordering peers from the frame. excludes any peers of the current row from the frame, but not the current row itself. simply specifies explicitly the default behavior of not excluding the current row or its peers. Beware that the mode can produce unpredictable results if the ordering does not order the rows uniquely. The and modes are designed to ensure that rows that are peers in the ordering are treated alike: all rows of a given peer group will be in the frame or excluded from it. The purpose of a clause is to specify the behavior of window functions appearing in the query's list or clause. These functions can reference the clause entries by name in their clauses. A clause entry does not have to be referenced anywhere, however; if it is not used in the query it is simply ignored. It is possible to use window functions without any clause at all, since a window function call can specify its window definition directly in its clause. However, the clause saves typing when the same window definition is needed for more than one window function. Currently, , , and cannot be specified with . Window functions are described in detail in Section 3.5, Section 4.2.8, and Section 7.2.5.\n\nThe list (between the key words and ) specifies expressions that form the output rows of the statement. The expressions can (and usually do) refer to columns computed in the clause. Just as in a table, every output column of a has a name. In a simple this name is just used to label the column for display, but when the is a sub-query of a larger query, the name is seen by the larger query as the column name of the virtual table produced by the sub-query. To specify the name to use for an output column, write after the column's expression. (You can omit , but only if the desired output name does not match any PostgreSQL keyword (see Appendix C). For protection against possible future keyword additions, it is recommended that you always either write or double-quote the output name.) If you do not specify a column name, a name is chosen automatically by PostgreSQL. If the column's expression is a simple column reference then the chosen name is the same as that column's name. In more complex cases a function or type name may be used, or the system may fall back on a generated name such as . An output column's name can be used to refer to the column's value in and clauses, but not in the or clauses; there you must write out the expression instead. Instead of an expression, can be written in the output list as a shorthand for all the columns of the selected rows. Also, you can write as a shorthand for the columns coming from just that table. In these cases it is not possible to specify new names with ; the output column names will be the same as the table columns' names. According to the SQL standard, the expressions in the output list should be computed before applying , , or . This is obviously necessary when using , since otherwise it's not clear what values are being made distinct. However, in many cases it is convenient if output expressions are computed after and ; particularly if the output list contains any volatile or expensive functions. With that behavior, the order of function evaluations is more intuitive and there will not be evaluations corresponding to rows that never appear in the output. PostgreSQL will effectively evaluate output expressions after sorting and limiting, so long as those expressions are not referenced in , or . (As a counterexample, clearly must evaluate before sorting.) Output expressions that contain set-returning functions are effectively evaluated after sorting and before limiting, so that will act to cut off the output from a set-returning function. PostgreSQL versions before 9.6 did not provide any guarantees about the timing of evaluation of output expressions versus sorting and limiting; it depended on the form of the chosen query plan.\n\nThe optional clause has this general form: ORDER BY [ ASC | DESC | USING ] [ NULLS { FIRST | LAST } ] [, ...] The clause causes the result rows to be sorted according to the specified expression(s). If two rows are equal according to the leftmost expression, they are compared according to the next expression and so on. If they are equal according to all specified expressions, they are returned in an implementation-dependent order. Each can be the name or ordinal number of an output column ( list item), or it can be an arbitrary expression formed from input-column values. The ordinal number refers to the ordinal (left-to-right) position of the output column. This feature makes it possible to define an ordering on the basis of a column that does not have a unique name. This is never absolutely necessary because it is always possible to assign a name to an output column using the clause. It is also possible to use arbitrary expressions in the clause, including columns that do not appear in the output list. Thus the following statement is valid: SELECT name FROM distributors ORDER BY code; A limitation of this feature is that an clause applying to the result of a , , or clause can only specify an output column name or number, not an expression. If an expression is a simple name that matches both an output column name and an input column name, will interpret it as the output column name. This is the opposite of the choice that will make in the same situation. This inconsistency is made to be compatible with the SQL standard. Optionally one can add the key word (ascending) or (descending) after any expression in the clause. If not specified, is assumed by default. Alternatively, a specific ordering operator name can be specified in the clause. An ordering operator must be a less-than or greater-than member of some B-tree operator family. is usually equivalent to and is usually equivalent to . (But the creator of a user-defined data type can define exactly what the default sort ordering is, and it might correspond to operators with other names.) If is specified, null values sort after all non-null values; if is specified, null values sort before all non-null values. If neither is specified, the default behavior is when is specified or implied, and when is specified (thus, the default is to act as though nulls are larger than non-nulls). When is specified, the default nulls ordering depends on whether the operator is a less-than or greater-than operator. Note that ordering options apply only to the expression they follow; for example does not mean the same thing as . Character-string data is sorted according to the collation that applies to the column being sorted. That can be overridden at need by including a clause in the , for example . For more information see Section 4.2.10 and Section 23.2.\n\nThe clause consists of two independent sub-clauses: The parameter specifies the maximum number of rows to return, while specifies the number of rows to skip before starting to return rows. When both are specified, rows are skipped before starting to count the rows to be returned. If the expression evaluates to NULL, it is treated as , i.e., no limit. If evaluates to NULL, it is treated the same as . SQL:2008 introduced a different syntax to achieve the same result, which PostgreSQL also supports. It is: OFFSET { ROW | ROWS } FETCH { FIRST | NEXT } [ ] { ROW | ROWS } { ONLY | WITH TIES } In this syntax, the or value is required by the standard to be a literal constant, a parameter, or a variable name; as a PostgreSQL extension, other expressions are allowed, but will generally need to be enclosed in parentheses to avoid ambiguity. If is omitted in a clause, it defaults to 1. The option is used to return any additional rows that tie for the last place in the result set according to the clause; is mandatory in this case, and is not allowed. and as well as and are noise words that don't influence the effects of these clauses. According to the standard, the clause must come before the clause if both are present; but PostgreSQL is laxer and allows either order. When using , it is a good idea to use an clause that constrains the result rows into a unique order. Otherwise you will get an unpredictable subset of the query's rows — you might be asking for the tenth through twentieth rows, but tenth through twentieth in what ordering? You don't know what ordering unless you specify . The query planner takes into account when generating a query plan, so you are very likely to get different plans (yielding different row orders) depending on what you use for and . Thus, using different / values to select different subsets of a query result will give inconsistent results unless you enforce a predictable result ordering with . This is not a bug; it is an inherent consequence of the fact that SQL does not promise to deliver the results of a query in any particular order unless is used to constrain the order. It is even possible for repeated executions of the same query to return different subsets of the rows of a table, if there is not an to enforce selection of a deterministic subset. Again, this is not a bug; determinism of the results is simply not guaranteed in such a case."
    },
    {
        "link": "https://dba.stackexchange.com/questions/175119/union-all-date-on-the-same-row",
        "document": "Stack Exchange network consists of 183 Q&A communities including Stack Overflow, the largest, most trusted online community for developers to learn, share their knowledge, and build their careers."
    }
]