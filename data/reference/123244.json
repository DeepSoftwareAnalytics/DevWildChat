[
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/api/system.xml.xmldocument?view=net-9.0",
        "document": "Some information relates to prerelease product that may be substantially modified before it’s released. Microsoft makes no warranties, express or implied, with respect to the information provided here.\n\nRepresents an XML document. You can use this class to load, validate, edit, add, and position XML in a document.\n\nFor more information about this API, see Supplemental API remarks for XmlDocument.\n\nGets an XmlAttributeCollection containing the attributes of this node. (Inherited from XmlNode) Gets the base URI of the current node. Gets all the child nodes of the node. (Inherited from XmlNode) Gets the root XmlElement for the document. Gets the node containing the DOCTYPE declaration. Gets the first child of the node. (Inherited from XmlNode) Gets a value indicating whether this node has any child nodes. (Inherited from XmlNode) Gets the XmlImplementation object for the current document. Throws an InvalidOperationException in all cases. Gets or sets the concatenated values of the node and all its child nodes. (Inherited from XmlNode) Gets or sets the markup representing the children of the current node. Gets a value indicating whether the current node is read-only. Gets the first child element with the specified LocalName and NamespaceURI. (Inherited from XmlNode) Gets the first child element with the specified Name. (Inherited from XmlNode) Gets the last child of the node. (Inherited from XmlNode) Gets the local name of the node. Gets the qualified name of the node. Gets the namespace URI of this node. (Inherited from XmlNode) Gets the XmlNameTable associated with this implementation. Gets the node immediately following this node. (Inherited from XmlNode) Gets the type of the current node. Gets the markup containing this node and all its child nodes. (Inherited from XmlNode) Gets the XmlDocument to which the current node belongs. Gets the parent node of this node (for nodes that can have parents). Gets the parent of this node (for nodes that can have parents). (Inherited from XmlNode) Gets or sets the namespace prefix of this node. (Inherited from XmlNode) Gets or sets a value indicating whether to preserve white space in element content. Gets the node immediately preceding this node. (Inherited from XmlNode) Gets the text node that immediately precedes this node. (Inherited from XmlNode) Returns the Post-Schema-Validation-Infoset (PSVI) of the node. Gets or sets the XmlSchemaSet object associated with this XmlDocument. Gets or sets the value of the node. (Inherited from XmlNode) Sets the XmlResolver to use for resolving external resources.\n\nOccurs when the Value of a node belonging to this document has been changed. Occurs when the Value of a node belonging to this document is about to be changed. Occurs when a node belonging to this document has been inserted into another node. Occurs when a node belonging to this document is about to be inserted into another node. Occurs when a node belonging to this document has been removed from its parent. Occurs when a node belonging to this document is about to be removed from the document.\n\nCasts the elements of an IEnumerable to the specified type. Filters the elements of an IEnumerable based on a specified type. Converts an IEnumerable to an IQueryable. Creates an XPath navigator object for navigating the specified document positioned on the specified node. Creates a new XPath navigator object for navigating the specified document. Creates an XPath navigator for navigating the specified node. Selects a list of nodes matching the specified XPath expression. Any prefixes found in the XPath expression are resolved using the supplied namespace manager. Selects a list of nodes matching the specified XPath expression. Selects the first node that matches the XPath expression. Any prefixes found in the XPath expression are resolved using the supplied namespace manager. Selects the first node that matches the XPath expression. Creates an IXPathNavigable instance used for producing navigators."
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/xmldoc",
        "document": "C# source files can include structured comments that produce API documentation for the types defined in those files. The C# compiler produces an XML file that contains structured data representing the comments and the API signatures. Other tools can process that XML output to create human-readable documentation in the form of web pages or PDF files, for example.\n\nThis process provides many advantages for you to add API documentation in your code:\n• The C# compiler combines the structure of the C# code with the text of the comments into a single XML document.\n• The C# compiler verifies that the comments match the API signatures for relevant tags.\n• Tools that process the XML documentation files can define XML elements and attributes specific to those tools.\n\nTools like Visual Studio provide IntelliSense for many common XML elements used in documentation comments.\n• Tags validated by the C# compiler and Visual Studio\n\nYou create documentation for your code by writing special comment fields indicated by triple slashes. The comment fields include XML elements that describe the code block that follows the comments. For example:\n\nYou set either the GenerateDocumentationFile or DocumentationFile option, and the compiler finds all comment fields with XML tags in the source code and creates an XML documentation file from those comments. When this option is enabled, the compiler generates the CS1591 warning for any publicly visible member declared in your project without XML documentation comments.\n\nThe use of XML doc comments requires delimiters that indicate where a documentation comment begins and ends. You use the following delimiters with the XML documentation tags:\n• Single-line delimiter: The documentation examples and C# project templates use this form. If white space follows the delimiter, it isn't included in the XML output. Visual Studio automatically inserts the and tags and positions your cursor within these tags after you type the delimiter in the code editor. You can turn this feature on or off in the Options dialog box.\n• Multiline delimiters: The delimiters have the following formatting rules:\n• None On the line that contains the delimiter, if the rest of the line is white space, the line isn't processed for comments. If the first character after the delimiter is white space, that white-space character is ignored and the rest of the line is processed. Otherwise, the entire text of the line after the delimiter is processed as part of the comment.\n• None On the line that contains the delimiter, if there's only white space up to the delimiter, that line is ignored. Otherwise, the text on the line up to the delimiter is processed as part of the comment.\n• None For the lines after the one that begins with the delimiter, the compiler looks for a common pattern at the beginning of each line. The pattern can consist of optional white space and/or an asterisk ( ), followed by more optional white space. If the compiler finds a common pattern at the beginning of each line that doesn't begin with the delimiter or end with the delimiter, it ignores that pattern for each line.\n• None The only part of the following comment processed is the line that begins with . The three tag formats produce the same comments.\n• None The compiler identifies a common pattern of \" * \" at the beginning of the second and third lines. The pattern isn't included in the output.\n• None The compiler finds no common pattern in the following comment because the second character on the third line isn't an asterisk. All text on the second and third lines is processed as part of the comment.\n• None The compiler finds no pattern in the following comment for two reasons. First, the number of spaces before the asterisk isn't consistent. Second, the fifth line begins with a tab, which doesn't match spaces. All text from lines two through five is processed as part of the comment.\n\nTo refer to XML elements (for example, your function processes specific XML elements that you want to describe in an XML documentation comment), you can use the standard quoting mechanism ( and ). To refer to generic identifiers in code reference ( ) elements, you can use either the escape characters (for example, ) or braces ( ). As a special case, the compiler parses the braces as angle brackets to make the documentation comment less cumbersome to the author when referring to generic identifiers.\n\nThe following tools create output from XML comments:\n• DocFX: DocFX is an API documentation generator for .NET, which currently supports C#, Visual Basic, and F#. It also allows you to customize the generated reference documentation. DocFX builds a static HTML website from your source code and Markdown files. Also, DocFX provides you with the flexibility to customize the layout and style of your website through templates. You can also create custom templates.\n• Sandcastle: The Sandcastle tools create help files for managed class libraries containing both conceptual and API reference pages. The Sandcastle tools are command-line based and have no GUI front-end, project management features, or automated build process. The Sandcastle Help File Builder provides standalone GUI and command-line-based tools to build a help file in an automated fashion. A Visual Studio integration package is also available for it so that help projects can be created and managed entirely from within Visual Studio.\n• Doxygen: Doxygen generates an online documentation browser (in HTML) or an offline reference manual (in LaTeX) from a set of documented source files. There's also support for generating output in RTF (MS Word), PostScript, hyperlinked PDF, compressed HTML, DocBook, and Unix manual pages. You can configure Doxygen to extract the code structure from undocumented source files.\n\nEach type or member is stored in an element in the output XML file. Each of those elements has a unique ID string that identifies the type or member. The ID string must account for operators, parameters, return values, generic type parameters, , , and parameters. To encode all those potential elements, the compiler follows clearly defined rules for generating the ID strings. Programs that process the XML file use the ID string to identify the corresponding .NET metadata or reflection item that the documentation applies to.\n\nThe compiler observes the following rules when it generates the ID strings:\n• None No white space is in the string.\n• None The first part of the string identifies the kind of member using a single character followed by a colon. The following member types are used: You can't add documentation comments to a namespace, but you can make references to them, where supported. Includes special methods, such as constructors and operators. The rest of the string provides information about the error. The C# compiler generates error information for links that can't be resolved.\n• None The second part of the string is the fully qualified name of the item, starting at the root of the namespace. The name of the item, its enclosing type(s), and namespace are separated by periods. If the name of the item itself has periods, they're replaced with the hash-sign ('#'). The grammar assumes that no item has a hash-sign directly in its name. For example, the fully qualified name of the String constructor is \"System.String.#ctor\".\n• None For properties and methods, the parameter list enclosed in parentheses follows. If there are no parameters, no parentheses are present. The parameters are separated by commas. The encoding of each parameter follows directly how it's encoded in a .NET signature (See Microsoft.VisualStudio.CorDebugInterop.CorElementType for definitions of the all caps elements in the following list):\n• Base types. Regular types ( or ) are represented as the fully qualified name of the type.\n• Intrinsic types (for example, , , , , and ) are represented as the fully qualified name of the corresponding full type. For example, or .\n• is represented as a '*' following the modified type.\n• is represented as a '@' following the modified type.\n• is represented as a '!' and the fully qualified name of the modifier class, following the modified type.\n• is represented as \"[]\" following the element type of the array.\n• is represented as [lower bound: ,lower bound: ] where the number of commas is the rank - 1, and the lower bounds and size of each dimension, if known, are represented in decimal. The lower bound and size are omitted if they aren't specified. If the lower bound and size for a particular dimension is omitted, the ':' is omitted as well. For example, a two-dimensional array with 1 as the lower bounds and unspecified sizes is [1:,1:].\n• None For conversion operators only ( and ), the return value of the method is encoded as a followed by the return type. For example: is the tag for the cast operator declared in the class.\n• None For generic types, the name of the type is followed by a backtick and then a number that indicates the number of generic type parameters. For example: is the tag for a type that is defined as . For methods that take generic types as parameters, the generic type parameters are specified as numbers prefaced with backticks (for example `0,`1). Each number represents a zero-based array notation for the type's generic parameters.\n• is represented as a '^' following the modified type. The C# compiler never generates this encoding.\n• is represented as a '|' and the fully qualified name of the modifier class, following the modified type. The C# compiler never generates this encoding.\n• is represented as \"[?]\" following the element type of the array. The C# compiler never generates this encoding.\n• is represented as \"=FUNC: (signature)\", where is the return type, and signature is the arguments of the method. If there are no arguments, the parentheses are omitted. The C# compiler never generates this encoding.\n• The following signature components aren't represented because they aren't used to differentiate overloaded methods:\n\nThe following examples show how the ID strings for a class and its members are generated:\n\nFor more information, see the C# Language Specification annex on documentation comments."
    },
    {
        "link": "https://stackoverflow.com/questions/642293/how-do-i-read-and-parse-an-xml-file-in-c",
        "document": "There are different ways, depending on where you want to get. XmlDocument is lighter than XDocument, but if you wish to verify minimalistically that a string contains XML, then regular expression is possibly the fastest and lightest choice you can make. For example, I have implemented Smoke Tests with SpecFlow for my API and I wish to test if one of the results in any valid XML - then I would use a regular expression. But if I need to extract values from this XML, then I would parse it with XDocument to do it faster and with less code. Or I would use XmlDocument if I have to work with a big XML (and sometimes I work with XML's that are around 1M lines, even more); then I could even read it line by line. Why? Try opening more than 800MB in private bytes in Visual Studio; even on production you should not have objects bigger than 2GB. You can with a twerk, but you should not. If you would have to parse a document, which contains A LOT of lines, then this documents would probably be CSV.\n\nI have written this comment, because I see a lof of examples with XDocument. XDocument is not good for big documents, or when you only want to verify if there the content is XML valid. If you wish to check if the XML itself makes sense, then you need Schema.\n\nI also downvoted the suggested answer, because I believe it needs the above information inside itself. Imagine I need to verify if 200M of XML, 10 times an hour, is valid XML. XDocument will waste a lof of resources.\n\nprasanna venkatesh also states you could try filling the string to a dataset, it will indicate valid XML as well."
    },
    {
        "link": "https://oreilly.com/library/view/c-in-a/0596001819/ch04s10.html",
        "document": "C# offers three different styles of source-code documentation: single-line comments, multiline comments, and documentation comments.\n\nSingle- and multiline comments use the C++ syntax: and : int x = 3; // this is a comment MyMethod(); /* this is a comment that spans two lines */ The disadvantage of this style of commenting is that there is no predetermined standard for documenting types. Consequently, it cannot be easily parsed to automate the production of documentation. C# improves on this by allowing you to embed documentation comments in the source, and by providing an automated mechanism for extracting and validating documentation at compile time.\n\nDocumentation comments are similar to C# single-line comments, but start with (that’s three slashes), and can be applied to any user-defined type or member. As well as containing descriptive text, these comments can also include embedded XML tags. These tags allow one to mark up the descriptive text to better define the semantics of the type or member, and also to incorporate cross-references. These comments can then be extracted at compile time into a separate output file containing the documentation. The compiler validates the comments for internal consistency, expands cross-references into fully qualified type IDs, and outputs a well-formed XML file. Further processing is left up to you, although a common next step is to run the XML through XSLT, generating HTML documentation. Here is an example of documentation comments for a very simple type: // Filename: DocTest.cs using System; class MyClass { /// <summary> /// The Foo method is called from /// <see cref=\"Main\">Main</see> /// </summary> /// <mytag>Secret stuff</mytag> /// <param name=\"s\">Description for s</param> static void Foo(string s) { Console.WriteLine(s); } static void Main() { Foo(\"42\"); } }\n\nWhen run through the compiler using the command-line option, the following XML file is generated: <?xml version=\"1.0\"?> <doc> <assembly> <name>DocTest</name> </assembly> <members> <member name=\"M:MyClass.Foo(System.String)\"> <summary> The Foo method is called from <see cref=\"M:MyClass.Main\">Main</see> </summary> <mytag>Secret stuff</mytag> <param name=\"s\">Description for s</param> </member> </members> </doc> The , , and tags are generated automatically and form the skeleton for the XML file. The and tags indicate the assembly this type lives in. Every member that was preceded by a documentation comment is included in the XML file via a tag with a attribute that identifies the member. Note that the attribute in the tag has also been expanded to refer to a fully qualified type and member. The predefined XML documentation tags that were embedded in the documentation comments are also included in the XML file, and have been validated to ensure that all parameters are documented, that the names are accurate, and that any cross-references to other types or members can be resolved. Finally, any additional user-defined tags are transferred verbatim.\n\nThe predefined set of XML tags that can be used to mark up the descriptive text are listed here: This tag describes a type or member. Typically, contains the description of a member at a fairly high level. This tag provides additional information regarding a particular member. Information about side effects within the method, or particular behavior that may not otherwise be intuitive (such as the idea that this method may throw an if a parameter is greater than 5) is listed here. This tag describes a parameter on a method. The attribute is mandatory, and must refer to a parameter on the method. If this tag is applied to any parameter on a method, all of the parameters on that method must be documented. Enclose in double quotation marks ( ). This tag describes the return values for a method. This tag documents the exceptions a method may throw. If present, the optional attribute should refer to the type of the exception. The type name must be enclosed in double quotation marks ( ). This tag documents the permissions requirement for a type or member. If present, the optional attribute should refer to the type that represents the permission set required by the member, although the compiler does not validate this. The type name must be enclosed in double quotation marks ( ). This tag provides a description and sample source code explaining the use of a type or member. Typically, the tag provides the description and contains the and tags, although they can also be used independently. This tag indicates an inline code snippet. Typically, this tag is used inside an block (described previously). This tag is used to indicate multiline code snippets. Again, this is typically used inside of an block (described previously). This tag identifies cross-references in the documentation to other types or members. Typically, the tag is used inline within a description, (as opposed to the tag, which is broken out into a separate “See Also” section). This tag is useful because it allows tools to generate cross-references, indexes, and hyperlinked views of the documentation. Member names must be enclosed by double quotation marks ( ). This tag identifies cross-references in the documentation to other types or members. Typically, tags are broken out into a separate “See Also” section. This tag is useful because it allows tools to generate cross-references, indexes, and hyperlinked views of the documentation. Member names must be enclosed by double quotation marks ( ). This tag identifies the use of a parameter name within descriptive text, such as . The name must be enclosed by double quotation marks ( ). This tag provides hints to documentation generators about how to format the documentation — in this case, as a list of items. This tag sets off the text as a paragraph to documentation generators. This tag specifies an external file that contains documentation and an XPath path to a specific element in that file. For example, a path of retrieves whatever is inside of . The and must be enclosed by single quotation marks ( ), but you must use double quotation marks ( ) for the attribute within the expression.\n\nThere is little that is special about the predefined XML tags recognized by the C# compiler, and you are free to define your own. The only special processing done by the compiler is on the tag (in which it verifies the parameter name and that all the parameters on the method are documented) and the attribute (in which it verifies that the attribute refers to a real type or member, and expands it to a fully qualified type or member ID). The attribute can also be used in your own tags, and is verified and expanded just as it is in the predefined , , , and tags.\n\nOnce an XML file is generated from documentation comments, it typically requires another step before becoming generally useful to programmers, since most of us aren’t quite able to parse and use an XML file “in the raw.” The most common approach is to run the XML output through an XSLT stylesheet to generate some more human-friendly format, such as HTML. (Variations on this idea include generating PDF, RTF, or even Microsoft Word documents.) While Microsoft may publish a standardized XSLT file for this, companies may want to create their own to establish their own “look” for documentation of components they sell. Alternatively, several open source projects have already begun to explore this area, and produce neatly formatted documentation files; one example is http://ndoc.sourceforge.net. The ability to put user-defined tags into the XML documentation sections represents a powerful extensibility point — for example, a company may put implementation details about the method or class inside of tags and define two XSLT files: one excluding the implementation tags, and the other including it. The non- -aware files can be distributed publicly, while the -aware files are used internally by developers. An automated test tool might run tests against those methods or classes described by a tag. Types meant to be stored in the database might use XML documentation tags to indicate the SQL required to create the tables, and a custom tool could be written to extract the necessary SQL from the XML documentation files in order to run it. Non-public information about the code can be embedded within the code itself or in the documentation comments and processed by an external tool via this mechanism, which makes it quite powerful.\n\nType names and type or member cross-references are translated into IDs that uniquely define the type or member. These names are composed of a prefix that defines what the ID represents and a signature of the type or member. Table 4-4 lists the set of type or member prefixes. The rules describing how the signatures are generated are well documented, although fairly complex. Here is an example of a type and the IDs that are generated: // Namespaces do not have independent signatures namespace NS { /// T:NS.MyClass class MyClass { /// F:NS.MyClass.aField string aField; /// P:NS.MyClass.aProperty short aProperty {get {...} set {...}} /// T:NS.MyClass.NestedType class NestedType {...}; /// M:NS.MyClass.X() void X() {...} /// M:NS.MyClass.Y(System.Int32,System.Double@,System.Decimal@) void Y(int p1, ref double p2, out decimal p3) {...} /// M:NS.MyClass.Z(System.Char[],System.Single[0:,0:]) void Z(char[] p1, float[,] p2) {...} /// M:NS.MyClass.op_Addition(NS.MyClass,NS.MyClass) public static MyClass operator+(MyClass c1, MyClass c2) {...} /// M:NS.MyClass.op_Implicit(NS.MyClass)~System.Int32 public static implicit operator int(MyClass c) {...} /// M:NS.MyClass.#ctor MyClass() {...} /// M:NS.MyClass.Finalize ~MyClass() {...} /// M:NS.MyClass.#cctor static MyClass() {...} } }"
    },
    {
        "link": "https://stackoverflow.com/questions/55828/how-does-one-parse-xml-files",
        "document": "It's very simple. I know these are standard methods, but you can create your own library to deal with that much better.\n\nHere are some examples:\n\nAlso, there are some other methods to work with. For example, here. And I think there is no one best method to do this; you always need to choose it by yourself, what is most suitable for you."
    },
    {
        "link": "https://stackoverflow.com/questions/55828/how-does-one-parse-xml-files",
        "document": "It's very simple. I know these are standard methods, but you can create your own library to deal with that much better.\n\nHere are some examples:\n\nAlso, there are some other methods to work with. For example, here. And I think there is no one best method to do this; you always need to choose it by yourself, what is most suitable for you."
    },
    {
        "link": "https://stackoverflow.com/questions/220867/how-to-deal-with-xml-in-c-sharp",
        "document": "nyxtom's answer is very good. I'd add a couple of things to it:\n\nIf you need read-only access to an XML document, is a much lighter-weight object than .\n\nThe downside of using is that you can't use the familiar and methods of . Instead, you have to use the tools that the provides: use to create an , and use the to create s to iterate over the lists of nodes you find via XPath. This generally requires a few more lines of code than the methods.\n\nBut: the and classes implement , so any code you write to use those methods on an will also work on an . If you get used to writing against , your methods can work against either object. (This is why using and in method signatures is flagged by FxCop.)\n\nLamentably, and (and and ) don't implement .\n\nAnother thing not present in nyxtom's answer is . You generally use to avoid the overhead of parsing the XML stream into an object model before you begin processing it. Instead, you use an to process the input stream one XML node at a time. This is essentially .NET's answer to SAX. It lets you write very fast code for processing very large XML documents.\n\nalso provides the simplest way of processing XML document fragments, e.g. the stream of XML elements with no encluding element that SQL Server's FOR XML RAW option returns.\n\nThe code you write using is generally very tightly coupled to the format of the XML it's reading. Using XPath allows your code to be much, much more loosely coupled to the XML, which is why it's generally the right answer. But when you need to use , you really need it."
    },
    {
        "link": "https://bytehide.com/blog/linq-xml-csharp",
        "document": "In this article, we will dive deep into the world of XML processing using C# LINQ to XML. We will explore how to parse, create, and manipulate XML documents effectively with LINQ, making your XML handling tasks a breeze. The topics covered in this article include parsing XML documents, querying XML data, modifying XML elements and attributes, and creating XML documents from scratch. So, let’s get started!\n\nIn this section, we will learn how to parse XML documents using LINQ to XML, and explore various techniques to read and extract information from XML data. The following topics will be covered in this section:\n\nThere are several ways to load XML data into a LINQ to XML object. You can load XML from a file, a string, or an object. Here are some examples of how to load XML data using different sources:\n\nOnce you have loaded the XML data, you can begin to access its elements and attributes using LINQ queries. Here’s an example of how to access elements and attributes in an XML document:\n\nLINQ to XML provides various methods to navigate and traverse XML trees, such as , , , and . Here are some examples of navigating XML trees using these methods:\n\nIn this section, we will explore how to query XML data using LINQ queries, making it easy to filter, sort, and project XML data. We will cover the following topics:\n\nYou can use LINQ queries to filter XML elements and attributes based on specific conditions. Here’s an example of filtering XML data using a LINQ query:\n\nLINQ queries can also be used to sort XML elements and attributes based on specific criteria. Here’s an example of sorting XML data using a LINQ query:\n\nLINQ queries can project XML data into objects, making it easier to work with the data in your C# code. Here’s an example of projecting XML data into objects using a LINQ query:\n\nIn this section, we will learn how to modify XML elements and attributes using LINQ to XML. We will cover the following topics:\n\nYou can add new elements and attributes to an XML document using the method. Here’s an example of adding elements and attributes to an XML document:\n\nYou can update the values of elements and attributes in an XML document using simple assignment statements. Here’s an example of updating elements and attributes in an XML document:\n\nYou can remove elements and attributes from an XML document using the method. Here’s an example of removing elements and attributes from an XML document:\n\nIn this section, we will learn how to create XML documents from scratch using LINQ to XML. You can create an XML document by creating , , and objects and adding them together. Here’s an example of creating an XML document from scratch:\n\nIn summary, we have explored various techniques to parse, create, and manipulate XML documents using C# LINQ to XML. By understanding and applying these concepts, you can easily handle complex XML tasks in your C# applications. Don’t forget to experiment with these techniques to gain a deeper understanding of LINQ to XML capabilities and improve your XML processing skills. Happy coding!"
    },
    {
        "link": "https://learn.microsoft.com/en-us/answers/questions/1281201/parsing-xml-in-c-net-core",
        "document": "From your code, it seems that you have already get the xml string, then to get the attribute value, since the and attribute are in the root element. You could use the XmlElement.GetAttribute Method to get the attribute value. Code like this:\n\nBesides, you can also use LINQ to XML to find the element and get the attribute value (refer to How to find descendant elements (LINQ to XML)), code like this:\n\nThe result as below:\n\nIf the answer is the right solution, please click \"Accept Answer\" and kindly upvote it. If you have extra questions about this answer, please click \"Comment\".\n\nNote: Please follow the steps in our documentation to enable e-mail notifications if you want to receive the related email notification for this thread."
    },
    {
        "link": "https://quora.com/Whats-a-good-way-to-parse-XML-in-C",
        "document": "Something went wrong. Wait a moment and try again."
    }
]