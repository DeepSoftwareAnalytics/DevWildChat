[
    {
        "link": "https://developer.android.com/develop/ui/views/text-and-emoji/emoji-compat",
        "document": "Stay organized with collections Save and categorize content based on your preferences.\n\nCaution: As of late 2021, the library is deprecated in favor of , which provides integration into . To support modern emoji and simplify backward-compatibility with lower versions of Android, it's recommended that you migrate to the library. For details on how to implement, see Support modern emoji.\n\nThe support library aims to keep Android devices up to date with the latest emoji. It prevents your app from showing missing emoji characters in the form of ☐, which indicates that your device does not have a font to display the text. By using the support library, your app users do not need to wait for Android OS updates to get the latest emoji.\n\nRefer to the following related resources:\n\nThe support library provides classes to implement backward-compatible emoji support on devices running Android 4.4 (API level 19) and higher. You can configure with either bundled or downloadable fonts. For more information about configuration, refer to the following sections:\n\nidentifies emoji for a given , replaces them with , if required, and finally renders the emoji glyphs. Figure 2 demonstrates the process.\n\nThe downloadable fonts configuration uses the Downloadable Fonts support library feature to download an emoji font. It also updates the necessary emoji metadata that the support library needs to keep up with the latest versions of the Unicode specification.\n\nTo use the support library, you must modify your app project's classpath dependencies within your development environment.\n\nTo add a support library to your application project:\n• Open the file of your application.\n• Add the support library to the section.\n\nYou need to initialize to load the metadata and the typeface. Since initialization can take some time, the initialization process runs on a background thread.\n\nTo initialize with the downloadable font configuration, perform the following steps:\n• Create an instance of the class and provide the font provider authority, the font provider package, the font query, and a list of sets of hashes for the certificate. For more information about , refer to the Using Downloadable Fonts programmatically section in the Downloadable Fonts documentation.\n• Create an instance of and provide instances of and .\n• Initialize by calling the method and pass the instance of .\n• Use widgets in layout XMLs. If you are using , refer to the Using EmojiCompat widgets with AppCompat section.\n\nFor more information about how to configure with the downloadable font configuration, go to Emoji Compatibility sample app Java | Kotlin.\n\nYou can use the instance to modify behavior. You can use the following methods from the base class to set the configuration:\n• : Determines whether should replace all emoji it finds with . By default, tries its best to understand if the system can render an emoji and does not replace those emoji. When set to , replaces all emoji it finds with .\n• : Indicates whether has replaced an emoji with an . When set to , draws a background for the . This method is mainly used for debugging purposes.\n• : Sets the color to indicate an . The default value is .\n• : Informs app about the state of the initialization.\n\nand classes provide and methods to register an initialization callback. To use these methods, create an instance of the class. Call these methods and pass the instance of the class. When the initialization of the support library is successful, the class calls the method. If the library fails to initialize, the class calls the method. To check the initialization state at any point, call the method. It returns one of the following values: , , or . If you are using , you can use widgets that extend from .\n• Add the support library to the dependencies section. The support library is also available in a bundled font version. This package includes the font with the embedded metadata. The package also includes a that uses the to load the metadata and fonts. Note: The size of the font is in multiple megabytes. To use the support library with bundled font configuration, you must modify your app project's classpath dependencies within your development environment. To add a support library to your application project:\n• Open the file of your application.\n• Add the support library to the section. To use bundled fonts to configure , perform the following steps:\n• Use to create an instance of and provide an instance of .\n• Call the method to initialize and pass the instance of . uses to render correct images. Therefore, it has to convert any given into instances with . The class provides a method to convert into instances with . Using this method, you can process and cache the processed instances instead of the raw string, which improves the performance of your application. Using the support library, keyboards can render the emoji supported by the application they are interacting with. IMEs can use the method to check if is capable of rendering an emoji. This method takes a of an emoji and returns if can detect and render the emoji. The keyboard can also check the version of the support library that the app supports to determine which emoji to render in the palette. To check the version, if available, the keyboard needs to check whether the following keys exist in the bundle: If the key exists in the bundle, the value represents the version of the emoji metadata that the app uses. If this key does not exist, the app is not using . If the key exists and is set to , this indicates that the app has called the method. For more information about configuration, refer to the Configuration options section. After receiving the keys in the bundle, the keyboard can use the method, where is the value for , to check whether the app can render a specific emoji. You can always use the method to preprocess the in your app and add it to any widget that can render instances; for example, . In addition, provides the following widget helper classes to let you enrich your custom widgets with emoji support with minimum effort.\n• How do I initiate the font download? The emoji fonts are downloaded on first request, if they do not exist on the device. The download scheduling is transparent to the app.\n• How much time does it take to initialize? After the font is downloaded, it takes approximately 150 milliseconds to initialize .\n• How much memory does the EmojiCompat support library use? Currently, the data structure to find the emoji is loaded in the app’s memory and uses around 200KB.\n• Can I use EmojiCompat for a custom TextView? Yes. EmojiCompat provides helper classes for custom widgets. It is also possible to preprocess a given string and convert it to . For more information about widget helper classes, refer to the Using EmojiCompat with custom widgets section.\n• What happens if I add widgets in layout XMLs on devices that run on Android 4.4 (API level 19) or lower? You can include the support library or its widgets in your applications that support devices running Android 4.4 (API level 19) or lower. However, if a device runs on an Android version prior to API level 19, and its widgets are in a \"no operation\" state. This means that behaves exactly like a regular . instance; it immediately gets into a state when you call the method. For additional information on using the library, watch EmojiCompat. Content and code samples on this page are subject to the licenses described in the Content License. Java and OpenJDK are trademarks or registered trademarks of Oracle and/or its affiliates. [[[\"Easy to understand\",\"easyToUnderstand\",\"thumb-up\"],[\"Solved my problem\",\"solvedMyProblem\",\"thumb-up\"],[\"Other\",\"otherUp\",\"thumb-up\"]],[[\"Missing the information I need\",\"missingTheInformationINeed\",\"thumb-down\"],[\"Too complicated / too many steps\",\"tooComplicatedTooManySteps\",\"thumb-down\"],[\"Out of date\",\"outOfDate\",\"thumb-down\"],[\"Samples / code issue\",\"samplesCodeIssue\",\"thumb-down\"],[\"Other\",\"otherDown\",\"thumb-down\"]],[\"Last updated 2025-03-13 UTC.\"],[],[]]"
    },
    {
        "link": "https://opensource.com/article/17/4/cross-platform-emoji",
        "document": ""
    },
    {
        "link": "https://stackoverflow.com/questions/25074112/how-to-encode-and-decode-emoji-in-android",
        "document": "We can use commons-lang(commons-lang-2.5.jar) library for encoding and decoding of the unicode characters. Download jar file here or use gradle: .\n\nFor Encoding use - This can be used in android when call method, where it will encode the unicode characters properly before sending to web server.\n\nFor Decoding use - This can be used in android to , where it will decode the unicode characters properly after receiving the response from web server.\n\nFYI Use the encoding and decoding for web service side as well. Unicode encoded string should be decoded from web service and response from web service should be encoded before sending to clients. Server tables should contain utf8mb4 instead of utf8, because unicode character needs 4bytes per character. Therefore unicode will not be represented in 3bytes."
    },
    {
        "link": "https://codenewbie.org/blogs/what-emojis-tell-us-about-encoding",
        "document": ""
    },
    {
        "link": "https://nolanlawson.com/2022/04/08/the-struggle-of-using-native-emoji-on-the-web",
        "document": "Emoji are a standard overseen by the Unicode Consortium. The web is a standard governed by bodies such as the W3C, WHATWG, and TC39. Both emoji and the web are ubiquitous.\n\nSo you might be forgiven for thinking that, in 2022, it’s possible to plop an emoji on a web page and have it “just work”:\n\nIf you see a lotus flower above, then congratulations! You’re on a browser or operating system that supports Emoji 14.0, released in September 2021. If not, you might see something that looks like the scoreboard on an old 80’s arcade game:\n\nLet’s try another one. What does this emoji look like to you?\n\nIf you see a face with spiral eyes, then wonderful! Your browser can render Emoji 13.1, released in September 2020. If not, you might see a puzzling combination of face with crossed-out eyes and a shooting (“dizzy”) star:\n\nIt’s a fun bit of cartoon iconography to know that this combination means “dizzy face,” but for most folks, it doesn’t really evoke the same meaning. It’s not much better than the robot barf.\n\nIf you’re like me, you’re a minimalist when it comes to web development. If I don’t have to rebuild something from scratch, then I’ll avoid doing so. I try to “use the platform” as much as possible and lean on existing web standards and browser capabilities.\n\nWhen it comes to emoji, there are a lot of potential upsides to using the platform. You don’t need to bring your own heavy emoji font, or use a spritesheet, or do any manual DOM processing to replace text with s. But sadly, if you try to avoid these heavy-handed techniques and just, you know, use emoji on the web, you’ll quickly run into the kinds of problems I describe above.\n\nThe first major problem is that, although emoji are released by the Unicode Consortium at a yearly cadence, OSes don’t always update in a timely manner to add the latest-and-greatest characters. And the browser, in most cases, is beholden to the OS to render whatever emoji fonts are provided by the underlying system (e.g. Apple Color Emoji on iOS, Microsoft Segoe Color Emoji on Windows, etc.).\n\nIn the case of major releases (such as Emoji 14.0), a missing character means the “robot barf” shown above. In the case of minor releases (such as Emoji 13.1), it can mean that the emoji renders as a bizarre “double” emoji – some of my favorites include “man with floating wig of red hair” (👨🦰) for “man with red hair” (👨‍🦰) and “bear with snowflake” (🐻❄️) for “polar bear” (🐻‍❄️).\n\nIf I’m trying to convince you that native emoji are worth investing in for your website, I’ve probably lost half my audience at this point. Most chat and social media app developers would prefer to have a consistent experience across all browsers and devices – not a broken experience for some users. And even if the latest emoji were perfectly supported across devices, these developers may still prefer a uniform look-and-feel, which is why vendors like Twitter, Facebook, and WhatsApp actually design their own emoji fonts.\n\nLet’s say, though, that you’re comfortable with emoji looking different on different platforms. After all – maybe Apple users would prefer to see Apple emoji, and Windows users would prefer to see Windows emoji. And in any case, you’d rather not reinvent what the OS already provides. What do you have to do in this case?\n\nWell, first you need a way to detect broken emoji. This is actually much harder than it sounds, and basically boils down to rendering the emoji to a , testing that it has an actual color, and also testing that it doesn’t render as two separate characters. (is-emoji-supported is a decent JavaScript library that does this.)\n\nThis solution has a few downsides. First off, you now need to run JavaScript before rendering any text – with all the problems therein for , performance, etc. Second, it doesn’t actually solve the problem – it just tells you that there is a problem. And it might not even work – I’ve seen this technique fail in cross-origin iframes in Firefox, presumably because the triggered the browser’s fingerprinting detection.\n\nBut again, let’s just say that you’re comfortable with all this. You detect broken emoji and perhaps replace them with text saying “emoji not supported.” Or maybe you want a more graceful degradation, so you include half a megabyte of JSON data describing every emoji ever created, so that you can actually show some text to describe the emoji. (Of course, that file is only going to get bigger, and you’ll need to update it every year.)\n\nI know what you’re thinking: “I just wanted to show an emoji on my web page. Why do I have to know everything about emoji?” But just wait: it gets worse.\n\nOkay, so now you’re successfully detecting whether an emoji is supported, so you can hide or replace those newfangled emoji that are causing problems. But would it occur to you that the oldest emoji might be problematic too?\n\nThis is the classic smiling face emoji. But depending on your browser, instead of the more familiar full-color version, you might see a simple black-and-white smiley. In case you don’t see it, here is a comparison, and here’s how it looks in Chrome on Windows:\n\nYou’ll also see this same problem for some other older emoji, such as red heart (❤️) and heart suit (♥️), which both render as black hearts rather than red ones.\n\nSo how can we render these venerable emoji in glorious Technicolor? Well, after a lot of trial-and-error, I’ve landed on this CSS:\n\nBasically, what we have to do is point the at a known list of built-in emoji fonts on various operating systems. This is similar to the “system font” trick.\n\nIf you’re wondering what “Twemoji Mozilla” is, well, it turns out that Firefox is a bit odd in that it actually bundles its own version of Twitter’s Twemoji font on Windows and Linux. This will be important later, but let’s set it aside for now.\n\nUpdate: The property can also solve this problem, once browser support improves.\n\nWhat is an emoji, anyway?\n\nAt this point, you may be getting pretty tired of this blog post. “Nolan,” you might say, “why don’t you just tell me what to do? Just give me a snippet I can slap onto my website to fix all these dang emoji problems!” Well I wish it were as simple as just chucking a CSS onto your and calling it a day. But if you try that naïve approach, you’ll start to see some bizarre characters:\n\nAs it turns out, characters like the asterisk (*), octothorpe (#), trademark (™), and even the numbers 0-9 are technically emoji. And depending on your browser and OS, the system emoji font will either not render them at all, or it might render them as the somewhat-cartoony versions you see above.\n\nMaybe to some folks it’s acceptable for these characters to be rendered as emoji, but I would wager that the average person doesn’t consider these numbers and symbols to be “emoji.” And it would look odd to treat them like that.\n\nSo all right, some “emoji” are not really emoji. This means we need to ensure that some characters (like the smiley face) render using the system emoji font, whereas other kinda-sorta emoji characters (like * and #) don’t. Potentially you could use a JavaScript tool like emoji-regex or a CSS tool like emoji-unicode-range to manage this, but in my experience, neither one handles all the various edge cases (nor have I found an off-the-shelf solution that does). And either way, it’s starting to feel pretty far from “use the platform.”\n\nI could stop right here, and hopefully I’ve made the point that using native emoji on the web is a painful experience. But I can’t help mentioning one more problem: flag emoji on Windows.\n\nAs it turns out, Microsoft’s emoji font does not have country flags on either Windows 10 or Windows 11. So instead of the US flag emoji, you’ll just see the characters “US” (and the equivalent country codes for other flags). Microsoft might have a good geopolitical reason to do this (although they’d have to explain why no other emoji vendor follows suit), but in any case, it makes it hard to talk about sports matches or national independence days.\n\nInterestingly, this problem is actually solvable in Firefox, since they ship their own “Mozilla Twemoji” font (which, furthermore, tends to stay more up-to-date than the built-in Microsoft font). But the most popular browser engine on Windows, Chromium, does not ship their own emoji font and doesn’t plan to. There’s actually a neat tool called country-flag-emoji-polyfill that can detect the broken flag support and patch in a minimal Twemoji font to fix it, but again, it’s a shame that web developers have to jump through so many hoops to get this working.\n\nI could go on. I really could. I could talk about the sad state of browser support for color fonts, or how to avoid mismatched emoji fonts in Firefox, or subtle issues with measuring emoji width on Windows, or how you need to install a separate package for emoji to work at all in Chrome on Linux.\n\nBut in the end, my message is a simple one: I, as a web developer, would like to use emoji on my web sites. And for a variety of reasons, I cannot.\n\nAt a time when web browsers have gained a staggering array of new capabilities – including Bluetooth, USB, and access to the filesystem – it’s still a struggle to render a smiley face. It feels a bit odd to argue in 2022 that “the web should have emoji support,” and yet here I stand, cap in hand, making my case.\n\nYou might wonder why browsers have been so slow to fix this problem. I suspect part of it is that there are ready workarounds, such as twemoji, which parses the DOM to look for emoji sequences and replaces them with s. The fact that this technique isn’t great for performance (downloading extra images, processing the DOM and mutating it, needing to run JavaScript at all) might seem unimportant when you consider the benefits (a unified look-and-feel across devices, up-to-date emoji support).\n\nPart of me also wonders if this is one of those cases where the needs of larger entities have eclipsed the needs of smaller “mom-and-pop” web shops. A well-funded tech company building a social media app with a massive user base has the resources to handle these emoji problems – heck, they might even design their own emoji font! Whereas your average small-time blogger, agency, or studio would probably prefer for emoji to “just work” without a lot of heavy lifting. But for whatever reason, their voices are not being heard.\n\nWhat do I wish browsers would do? I don’t have much of a grand solution in mind, but I would settle for browsers following the Firefox model and bundling their own emoji font. If the OS can’t keep its emoji up-to-date, or if it doesn’t want to support certain characters (like country flags), then the browser should fill that gap. It’s not a huge technical hurdle to bundle a font, and it would help spare web developers a lot of the headaches I listed above.\n\nAnother nice feature would be some sensible way to render what are colloquially known as “emoji” as emoji. So for instance, the “smiley face” should be rendered as emoji, but the numbers 0-9 and symbols like * and # should not. If backwards compatibility is a concern, then maybe we need a new CSS property along the lines of – something like would be nice.\n\nIn any case, even if this blog post has only served to dissuade you from ever trying to use native emoji on the web, I hope that I’ve at least done a decent job of summarizing the current problems and making the case for browsers to help solve it. Maybe someday, when browsers everywhere can render a smiley face, I can write something other than to show my approval.\n\nUpdate: At some point, WordPress started automatically converting emoji in this blog post to s. I’ve replaced some of the examples with CodePens to make it clearer what’s going on. Of course, the fact that WordPress feels compelled to use s instead of native emoji kind of proves my point.\n\nUpdate: Ollie Williams has written a great recent blog post with some more tips on rendering emoji."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/Media/Guides/Formats/Image_types",
        "document": "The image file formats that are most commonly used on the web are listed below. Good choice for lossless animation sequences (GIF is less performant). AVIF and WebP have better performance but less broad browser support.\n\n Support: Chrome, Edge, Firefox, Opera, Safari. Good choice for both images and animated images due to high performance and royalty free image format. It offers much better compression than PNG or JPEG with support for higher color depths, animated frames, transparency, etc. Note that when using AVIF, you should include fallbacks to formats with better browser support (i.e. using the element).\n\n Support: Chrome, Edge, Firefox, Opera, Safari. Good choice for basic images and animations. Prefer PNG for lossless and indexed still images, and consider WebP, AVIF or APNG for animation sequences.\n\n Support: Chrome, Edge, Firefox, IE, Opera, Safari. Good choice for lossy compression of still images (currently the most popular). Prefer PNG when more precise reproduction of the image is required, or WebP/AVIF if both better reproduction and higher compression are required.\n\n Support: Chrome, Edge, Firefox, IE, Opera, Safari. PNG is preferred over JPEG for more precise reproduction of source images, or when transparency is needed. WebP/AVIF provide even better compression and reproduction, but browser support is more limited.\n\n Support: Chrome, Edge, Firefox, IE, Opera, Safari. Vector image format; ideal for user interface elements, icons, diagrams, etc., that must be drawn accurately at different sizes.\n\n Support: Chrome, Edge, Firefox, IE, Opera, Safari. Excellent choice for both images and animated images. WebP offers much better compression than PNG or JPEG with support for higher color depths, animated frames, transparency etc. AVIF offers slightly better compression, but is not quite as well-supported in browsers and does not support progressive rendering.\n\n Support: Chrome, Edge, Firefox, Opera, Safari Note: The older formats like PNG, JPEG, GIF have poor performance compared to newer formats like WebP and AVIF, but enjoy broader \"historical\" browser support. The newer image formats are seeing increasing popularity as browsers without support become increasingly irrelevant (i.e. have virtually zero market share). The following list includes image formats that appear on the web, but which should be avoided for web content (generally this is because either they do not have wide browser support, or because there are better alternatives). Note: The abbreviation for each image format links to a longer description of the format, its capabilities, and detailed browser compatibility information (including which versions introduced support and specific special features that may have been introduced later). Note: Safari 11.1 added the ability to use a video format, as an animated gif replacement. No other browser supports this. See the Chromium bug, and Firefox bug for more information.\n\nAV1 Image File Format (AVIF) is a powerful, open source, royalty-free file format that encodes AV1 bitstreams in the High Efficiency Image File Format (HEIF) container. Note: AVIF has potential to become the \"next big thing\" for sharing images in web content. It offers state-of-the-art features and performance, without the encumbrance of complicated licensing and patent royalties that have hampered comparable alternatives. AV1 is a coding format that was originally designed for video transmission over the Internet. The format benefits from the significant advances in video encoding in recent years, and may potentially benefit from the associated support for hardware rendering. However it also has disadvantages for some cases, as video and image encoding have some different requirements.\n• Excellent lossy compression compared to JPG and PNG for visually similar compression levels (e.g. lossy AVIF images are around 50% smaller than JPEG images).\n• Generally, AVIF has better compression than WebP — median 50% vs. 30% compression for the same JPG set (source: AVIF WebP Comparison (CTRL Blog)).\n• Animation/multi-image storage (similar to animated GIFs, but with much better compression)\n• High Dynamic Range (HDR): support for storing images that can represent bigger contrasts between the lightest and darkest parts of the image.\n• Wide Color Gamut: Support for images that can contain a larger range of colors. AVIF does not support progressive rendering, so files must be fully downloaded before they can be displayed. This often has little impact on real-world user experience because AVIF files are much smaller than the equivalent JPEG or PNG files, and hence can be downloaded and displayed much faster. For larger file size the impact can become significant, and you should consider using a format that supports progressive rendering. AVIF is supported in Chrome, Edge, Opera, Safari and Firefox. As support is not yet comprehensive (and has little historical depth) you should provide a fallback in WebP, JPEG or PNG format using the element (or some other approach). Chrome 85, Edge 121, Opera 71, Firefox 93, and Safari 16.1.\n• Firefox 93 supports still images, with colorspace support for both full and limited range colors, image transforms for mirroring and rotation. The preference image.avif.compliance_strictness can be used to adjust the compliance strictness with the specification. Color mode support information is provided in the AV1 Bitstream & Decoding Process Specification, section 6.4.2 : Color config semantics. Royalty free. Licensing information is available at License Page.\n\nThe BMP (Bitmap image) file type is most prevalent on Windows computers, and is generally used only for special cases in web apps and content. Warning: You should typically avoid using BMP files for website content. The most common form of BMP file represents the data as an uncompressed raster image, resulting in large file sizes compared to png or jpg image types. More efficient BMP formats exist but are not widely used, and rarely supported in web browsers. BMP theoretically supports a variety of internal data representations. The simplest, and most commonly used, form of BMP file is an uncompressed raster image, with each pixel occupying 3 bytes representing its red, green, and blue components, and each row padded with bytes to a multiple of 4 bytes wide. While other data representations are defined in the specification, they are not widely used and often completely unimplemented. These features include: support for different bit depths, indexed color, alpha channels, and different pixel orders (by default, BMP is written from bottom-left corner toward the right and top, rather than from the top-left corner toward the right and bottom). Theoretically, several compression algorithms are supported, and the image data can also be stored in JPEG or PNG format within the BMP file. No specification; however, Microsoft provides general documentation of the format at docs.microsoft.com/en-us/windows/desktop/gdi/bitmap-storage All versions of Chrome, Edge, Firefox, Opera, and Safari Either 32,767×32,767 or 2,147,483,647×2,147,483,647 pixels, depending on the format version Each bit represents a single pixel, which can be either black or white. Each pixel is represented by three values representing the red, green, and blue color components; each is D bits. Each pixel is represented by a value which is one 2, 4, or 8 bits, serving as an index into the color table. Each pixel is represented by four values representing the red, green, blue, and alpha color components; each is D bits. Several compression methods are supported, including lossy or lossless algorithms Covered by the Microsoft Open Specification Promise; while Microsoft holds patents against BMP, they have published a promise not to assert its patent rights as long as specific conditions are met. This is not the same as a license, however. BMP is included under the Windows Metafile Format ( ).\n\nIn 1987, the CompuServe online service provider introduced the GIF (Graphics Interchange Format) image file format to provide a compressed graphics format that all members of their service would be able to use. GIF uses the Lempel-Ziv-Welch (LZW) algorithm to losslessly compress 8-bit indexed color graphics. GIF was one of the first two graphics formats supported by HTML, along with XBM. Each pixel in a GIF is represented by a single 8-bit value serving as an index into a palette of 24-bit colors (8 bits each of red, green, and blue). The length of a color table is always a power of 2 (that is, each palette has 2, 4, 8, 16, 32, 64, or 256 entries). To simulate more than 255 or 256 colors, dithering is generally used. It is technically possible to tile multiple image blocks, each with its own color palette, to create truecolor images, but in practice this is rarely done. Pixels are opaque, unless a specific color index is designated as transparent, in which case pixels colored that value are entirely transparent. GIF supports simple animation, in which following an initial full-size frame, a series of images reflecting the parts of the image that change with each frame are provided. GIF has been extremely popular for decades, due to its simplicity and compatibility. Its animation support caused a resurgence in its popularity in the social media era, when animated GIFs began to be widely used for short \"videos\", memes, and other simple animation sequences. Another popular feature of GIF is support for interlacing, where rows of pixels are stored out of order so that partially-received files can be displayed in lower quality. This is particularly useful when network connections are slow. GIF is a good choice for simple images and animations, although converting full color images to GIF can result in unsatisfactory dithering. Typically, modern content should use PNG for lossless and indexed still images, and should consider using APNG for lossless animation sequences. All versions of Chrome, Edge, Firefox, Opera, and Safari Each color in a GIF palette is defined as 8 bits each of red, green, and blue (24 total bits per pixel). While the GIF format itself is open, the LZW compression algorithm was covered by patents until the early 2000s. As of July 7, 2004, all relevant patents have expired and the GIF format may be used freely\n\nThe ICO (Microsoft Windows icon) file format was designed by Microsoft for desktop icons of Windows systems. However, early versions of Internet Explorer introduced the ability for a website to provide an ICO file named in a website's root directory to specify a favicon — an icon to be displayed in the Favorites menu, and other places where an iconic representation of the site would be useful. An ICO file can contain multiple icons, and begins with a directory listing details about each. Following the directory comes the data for the icons. Each icon's data can be either a BMP image without the file header, or a complete PNG image (including the file header). If you use ICO files, you should use the BMP format, as support for PNG inside ICO files wasn't added until Windows Vista and may not be well supported. Warning: ICO files should not be used in web content. Additionally, their use for favicons has subsided in favor of using a PNG file and the element, as described in Providing icons for different usage contexts. All versions of Chrome, Edge, Firefox, Opera, and Safari Each bit represents a single pixel, which can be either black or white. Each pixel is represented by three values representing the red, green, and blue color components; each is D bits. Each pixel is represented by a value which is one 2, 4, or 8 bits, serving as an index into the color table. Each pixel is represented by four values representing the red, green, blue, and alpha color components; each is D bits. Each pixel consists of a single D-bit value indicating the brightness of the greyscale pixel. Each pixel is represented by three D-bit values indicating the level of the red, green, and blue color components. Each pixel is a D-bit value indicating an index into a color palette which is contained within a chunk in the APNG file; the colors in the palette all use an 8-bit depth. Each pixel is represented by two D-bit values: the intensity of the greyscale pixel and an alpha sample, indicating how opaque the pixel is. Each pixel is comprised of four D-pixel color components: red, green, blue, and the alpha sample indicating how opaque the pixel is. BMP-format icons nearly always use lossless compression, but lossy methods are available. PNG icons are always compressed losslessly.\n\nTIFF is a raster graphics file format which was created to store scanned photos, although it can be any kind of image. It is a somewhat \"heavy\" format, in that TIFF files have a tendency to be larger than images in other formats. This is because of the metadata often included, as well as the fact that most TIFF images are either uncompressed or use compression algorithms that still leave fairly large files after compression. TIFF supports a variety of compression methods, but the most commonly used are the CCITT Group 4 (and, for older fax systems, Group 3) compression systems used for by fax software, as well as LZW and lossy JPEG compression. Every value in a TIFF file is specified using its tag (indicating what kind of information it is, such as the width of the image) and its type (indicating the format the data is stored in), followed by the length of the array of values to assign to that tag (all properties are stored in arrays, even for single values). This allows different data types to be used for the same properties. For example, the width of an image, , is stored using tag , and is a one-entry array. By specifying type 3 ( ), the value of is stored as a 16-bit value: Specifying type 4 ( ) stores the width as a 32-bit value: A single TIFF file can contain multiple images; this may be used to represent multi-page documents, for example (such as a multi-page scanned document, or a received fax). However, software reading TIFF files is only required to support the first image. TIFF supports a variety of color spaces, not just RGB. These include CMYK, YCbCr, and others, making TIFF a good choice for storing images intended for print, film, or television media. Other than Safari, browsers do not natively support TIFF images in web content except by using special libraries or browser add-ons. As such, TIFF files are not broadly used for displaying web content, but it's common to provide downloadable TIFF files when distributing photos and other artwork intended for precision editing or printing. A bilevel TIFF stores 8 bits in each byte, one bit per pixel. The field specifies which of 0 and 1 are black and which is white. Each pixel consists of a single D-bit value indicating the brightness of the greyscale pixel. All true color RGB images are stored using 8-bits each of red, green, and blue. Each pixel is an index into a record, which defines the colors used in the image. The color map lists all of the red values, then all of the green values, then all of the blue values (rather than ). Alpha information is added by specifying that there are more than 3 samples per pixel in the field, and indicating the type of alpha (1 for an associated, pre-multiplied alpha component, and 2 for unassociated alpha - a separate matte); however, alpha channels are rarely used in TIFF files and may be unsupported by the user's software. Alpha information is added by specifying that there are more than 3 samples per pixel in the field, and indicating the type of alpha (1 for an associated, pre-multiplied alpha component, and 2 for unassociated alpha - a separate matte); however, alpha channels are rarely used in TIFF files and may be unsupported by the user's software. Most TIFF files are uncompressed, but lossless PackBits and LZW compression are supported, as is lossy JPEG compression. No license required (aside from any associated with libraries you might use); all known patents have expired."
    },
    {
        "link": "https://pixx.io/en/blog/gif-alternative",
        "document": "Are you already working with metadata? If not, it's high time you did. However, you should not only know how to add it to your media but also how to remove metadata again."
    },
    {
        "link": "https://quora.com/What-image-format-is-an-emoji-Can-I-create-one",
        "document": "Something went wrong. Wait a moment and try again."
    },
    {
        "link": "https://reddit.com/r/modhelp/comments/bolmgq/can_gifs_or_apng_be_used_as_emoji",
        "document": "r/modhelp Have questions about moderating your subreddit? We might be able to help!\n\ncan GIFs or aPNG be used as emoji?\n\nArchived post. New comments cannot be posted and votes cannot be cast."
    },
    {
        "link": "https://en.wikipedia.org/wiki/GIF",
        "document": "The Graphics Interchange Format (GIF; GHIF or JIF, see § Pronunciation) is a bitmap image format that was developed by a team at the online services provider CompuServe led by American computer scientist Steve Wilhite and released on June 15, 1987.[1]\n\nThe format can contain up to 8 bits per pixel, allowing a single image to reference its own palette of up to 256 different colors chosen from the 24-bit RGB color space. It can also represent multiple images in a file, which can be used for animations, and allows a separate palette of up to 256 colors for each frame. These palette limitations make GIF less suitable for reproducing color photographs and other images with color gradients but well-suited for simpler images such as graphics or logos with solid areas of color.\n\nGIF images are compressed using the Lempel–Ziv–Welch (LZW) lossless data compression technique to reduce the file size without degrading the visual quality.\n\nWhile once in widespread usage on the World Wide Web because of its wide implementation and portability between applications and operating systems, usage of the format has declined for space and quality reasons, often being replaced with video formats such as the MP4 file format. These replacements, in turn, are sometimes termed \"GIFs\" despite having no relation to the original file format.[3]\n\nCompuServe introduced GIF on 15 June 1987 to provide a color image format for their file downloading areas. This replaced their earlier run-length encoding format, which was black and white only. GIF became popular because it used Lempel–Ziv–Welch data compression. Since this was more efficient than the run-length encoding used by PCX and MacPaint, fairly large images could be downloaded reasonably quickly even with slow modems.\n\nThe original version of GIF was called 87a.[1] This version already supported multiple images in a stream.\n\nIn 1989, CompuServe released an enhanced version, called 89a,[2] This version added:\n• allowing text labels as text (not embedding them in the graphical data). As there is little control over display fonts, however, this feature is rarely used.\n\nThe two versions can be distinguished by looking at the first six bytes of the file (the \"magic number\" or signature), which, when interpreted as ASCII, read \"GIF87a\" or \"GIF89a\", respectively.\n\nCompuServe encouraged the adoption of GIF by providing downloadable conversion utilities for many computers. By December 1987, for example, an Apple IIGS user could view pictures created on an Atari ST or Commodore 64.[4] GIF was one of the first two image formats commonly used on Web sites, the other being the black-and-white XBM.[5]\n\nIn September 1995 Netscape Navigator 2.0 added the ability for animated GIFs to loop.\n\nWhile GIF was developed by CompuServe, it used the Lempel–Ziv–Welch (LZW) lossless data compression algorithm patented by Unisys in 1985. Controversy over the licensing agreement between Unisys and CompuServe in 1994 spurred the development of the Portable Network Graphics (PNG) standard. In 2004, all patents relating to the proprietary compression used for GIF expired.\n\nThe feature of storing multiple images in one file, accompanied by control data, is used extensively on the Web to produce simple animations.\n\nThe optional interlacing feature, which stores image scan lines out of order in such a fashion that even a partially downloaded image was somewhat recognizable, also helped GIF's popularity,[6] as a user could abort the download if it was not what was required.\n\nIn May 2015 Facebook added support for GIF.[7][8] In January 2018 Instagram also added GIF stickers to the story mode.[9]\n\nIn 2016 the Internet Archive released a searchable library of GIFs from their Geocities archive.[10][11]\n\nAs a noun, the word GIF is found in the newer editions of many dictionaries. In 2012, the American wing of the Oxford University Press recognized GIF as a verb as well, meaning \"to create a GIF file\", as in \"GIFing was the perfect medium for sharing scenes from the Summer Olympics\". The press's lexicographers voted it their word of the year, saying that GIFs have evolved into \"a tool with serious applications including research and journalism\".[12][13]\n\nThe pronunciation of the first letter of GIF has been disputed since the 1990s. The most common pronunciations in English are (with a soft g as in gin) and (with a hard g as in gift), differing in the phoneme represented by the letter G. The creators of the format pronounced the acronym GIF as , with a soft g, with Wilhite stating that he intended for the pronunciation to deliberately echo the American peanut butter brand Jif, and CompuServe employees would often quip \"choosy developers choose GIF\", a spoof of Jif's television commercials.[14] However, the word is widely pronounced as , with a hard g,[15] and polls have generally shown that this hard g pronunciation is more prevalent.[16][17]\n\nDictionary.com[18] cites both pronunciations, indicating as the primary pronunciation, while Cambridge Dictionary of American English[19] offers only the hard-g pronunciation. Merriam-Webster's Collegiate Dictionary[20] and Oxford Dictionaries cite both pronunciations, but place the hard g first: .[21][22][23][24] The New Oxford American Dictionary gave only in its second edition[25] but updated it to in the third edition.[26]\n\nThe disagreement over the pronunciation has led to heated Internet debate. On the occasion of receiving a lifetime achievement award at the 2013 Webby Awards ceremony, Wilhite publicly rejected the hard-g pronunciation;[15][27][28] his speech led to more than 17,000 posts on Twitter and dozens of news articles.[29] The White House[15] and the TV program Jeopardy! also entered the debate in 2013.[28] In February 2020, The J.M. Smucker Company, the owners of the Jif brand, partnered with the animated image database and search engine Giphy to release a limited-edition \"Jif vs. GIF\" (hashtagged as #JIFvsGIF) jar of peanut butter that had a label humorously declaring the soft-g pronunciation to refer exclusively to the peanut butter, and GIF to be exclusively pronounced with the hard-g pronunciation.[30]\n\nGIFs are suitable for sharp-edged line art with a limited number of colors, such as logos. This takes advantage of the format's lossless compression, which favors flat areas of uniform color with well defined edges.[31] They can also be used to store low-color sprite data for games.[32] GIFs can be used for small animations and low-resolution video clips, or as reactions in online messaging used to convey emotion and feelings instead of using words. They are popular on social media platforms such as Tumblr,[33] Facebook and Twitter.[34]\n\nConceptually, a GIF file describes a fixed-sized graphical area (the \"logical screen\") populated with zero or more \"images\". Many GIF files have a single image that fills the entire logical screen. Others divide the logical screen into separate sub-images. The images may also function as animation frames in an animated GIF file, but again these need not fill the entire logical screen.\n\nGIF files start with a fixed-length header (\"GIF87a\" or \"GIF89a\") giving the version, followed by a fixed-length Logical Screen Descriptor giving the pixel dimensions and other characteristics of the logical screen. The screen descriptor may also specify the presence and size of a Global Color Table (GCT), which follows next if present.\n\nThereafter, the file is divided into segments of the following types, each introduced by a 1-byte sentinel:\n• An image (introduced by 0x2C, an ASCII comma )\n• An extension block (introduced by 0x21, an ASCII exclamation point )\n• The trailer (a single byte of value 0x3B, an ASCII semicolon ), which should be the last byte of the file.\n\nAn image starts with a fixed-length Image Descriptor, which may specify the presence and size of a Local Color Table (which follows next if present). The image data follows: one byte giving the bit width of the unencoded symbols (which must be at least 2 bits wide, even for bi-color images), followed by a series of sub-blocks containing the LZW-encoded data.\n\nExtension blocks (blocks that \"extend\" the 87a definition via a mechanism already defined in the 87a spec) consist of the sentinel, an additional byte specifying the type of extension, and a series of sub-blocks with the extension data. Extension blocks that modify an image (like the Graphic Control Extension that specifies the optional animation delay time and optional transparent background color) must immediately precede the segment with the image they refer to.\n\nEach sub-block begins with a byte giving the number of subsequent data bytes in the sub-block (1 to 255). The series of sub-blocks is terminated by an empty sub-block (a 0 byte).\n\nThis structure allows the file to be parsed even if not all parts are understood. A GIF marked 87a may contain extension blocks; the intent is that a decoder can read and display the file without the features covered in extensions it does not understand.\n\nThe full detail of the file format is covered in the GIF specification.[2]\n\nGIF is palette-based: the colors used in an image (a frame) in the file have their RGB values defined in a palette table that can hold up to 256 entries, and the data for the image refer to the colors by their indices (0–255) in the palette table. The color definitions in the palette can be drawn from a color space of millions of shades (224 shades, 8 bits for each primary), but the maximum number of colors a frame can use is 256. This limitation was reasonable when GIF was developed because hardware that could display more than 256 colors simultaneously was rare. Simple graphics, line drawings, cartoons, and grey-scale photographs typically need fewer than 256 colors.\n\nEach frame can designate one index as a \"transparent background color\": any pixel assigned this index takes on the color of the pixel in the same position from the background, which may have been determined by a previous frame of animation.\n\nMany techniques, collectively called dithering, have been developed to approximate a wider range of colors with a small color palette by using pixels of two or more colors to approximate in-between colors. These techniques sacrifice spatial resolution to approximate deeper color resolution. While not part of the GIF specification, dithering can be used in images subsequently encoded as GIF images. This is often not an ideal solution for GIF images, both because the loss of spatial resolution typically makes an image look fuzzy on the screen, and because the dithering patterns often interfere with the compressibility of the image data, working against GIF's main purpose.\n\nIn the early days of graphical web browsers[when?], graphics cards with 8-bit buffers (allowing only 256 colors) were common and it was fairly common to make GIF images using the websafe palette.[according to whom?] This ensured predictable display, but severely limited the choice of colors. When 24-bit color became the norm, palettes could instead be populated with the optimum colors for individual images.\n\nA small color table may suffice for small images, and keeping the color table small allows the file to be downloaded faster. Both the 87a and 89a specifications allow color tables of 2n colors for any n from 1 through 8. Most graphics applications will read and display GIF images with any of these table sizes; but some do not support all sizes when creating images. Tables of 2, 16, and 256 colors are widely supported.\n\nAlthough GIF is almost never used for true color images, it is possible to do so.[35][36] A GIF image can include multiple image blocks, each of which can have its own 256-color palette, and the blocks can be tiled to create a complete image. Alternatively, the GIF89a specification introduced the idea of a \"transparent\" color where each image block can include its own palette of 255 visible colors plus one transparent color. A complete image can be created by layering image blocks with the visible portion of each layer showing through the transparent portions of the layers above.\n\nTo render a full-color image as a GIF, the original image must be broken down into smaller regions having no more than 255 or 256 different colors. Each of these regions is then stored as a separate image block with its own local palette and when the image blocks are displayed together (either by tiling or by layering partially transparent image blocks), the complete, full-color image appears. For example, breaking an image into tiles of 16 by 16 pixels (256 pixels in total) ensures that no tile has more than the local palette limit of 256 colors, although larger tiles may be used and similar colors merged resulting in some loss of color information.[35]\n\nSince each image block can have its own local color table, a GIF file having many image blocks can be very large, limiting the usefulness of full-color GIFs.[36] Additionally, not all GIF rendering programs handle tiled or layered images correctly. Many rendering programs interpret tiles or layers as animation frames and display them in sequence as an animation[35] with most web browsers automatically displaying the frames with a delay time of 0.1 seconds or more.[37][38][better source needed]\n\nThe hex numbers in the following tables are in little-endian byte order, as the format specification prescribes.\n\nThe image pixel data, scanned horizontally from top left, are converted by LZW encoding to codes that are then mapped into bytes for storing in the file. The pixel codes typically don't match the 8-bit size of the bytes, so the codes are packed into bytes by a \"little-Endian\" scheme: the least significant bit of the first code is stored in the least significant bit of the first byte, higher order bits of the code into higher order bits of the byte, spilling over into the low order bits of the next byte as necessary. Each subsequent code is stored starting at the least significant bit not already used.\n\nThis byte stream is stored in the file as a series of \"sub-blocks\". Each sub-block has a maximum length 255 bytes and is prefixed with a byte indicating the number of data bytes in the sub-block. The series of sub-blocks is terminated by an empty sub-block (a single 0 byte, indicating a sub-block with 0 data bytes).\n\nFor the sample image above the reversible mapping between 9-bit codes and bytes is shown below.\n\nA slight compression is evident: pixel colors defined initially by 15 bytes are exactly represented by 12 code bytes including control codes. The encoding process that produces the 9-bit codes is shown below. A local string accumulates pixel color numbers from the palette, with no output action as long as the local string can be found in a code table. There is special treatment of the first two pixels that arrive before the table grows from its initial size by additions of strings. After each output code, the local string is initialized to the latest pixel color (that could not be included in the output code).\n\nFor clarity the table is shown above as being built of strings of increasing length. That scheme can function but the table consumes an unpredictable amount of memory. Memory can be saved in practice by noting that each new string to be stored consists of a previously stored string augmented by one character. It is economical to store at each address only two words: an existing address and one character.\n\nThe LZW algorithm requires a search of the table for each pixel. A linear search through up to 4096 addresses would make the coding slow. In practice the codes can be stored in order of numerical value; this allows each search to be done by a SAR (Successive Approximation Register, as used in some ADCs), with only 12 magnitude comparisons. For this efficiency an extra table is needed to convert between codes and actual memory addresses; the extra table upkeeping is needed only when a new code is stored which happens at much less than pixel rate.\n\nDecoding begins by mapping the stored bytes back to 9-bit codes. These are decoded to recover the pixel colors as shown below. A table identical to the one used in the encoder is built by adding strings by this rule:\n\nShorter code lengths can be used for palettes smaller than the 256 colors in the example. If the palette is only 64 colors (so color indexes are 6 bits wide), the symbols can range from 0 to 63, and the symbol width can be taken to be 6 bits, with codes starting at 7 bits. In fact, the symbol width need not match the palette size: as long as the values decoded are always less than the number of colors in the palette, the symbols can be any width from 2 to 8, and the palette size any power of 2 from 2 to 256. For example, if only the first four colors (values 0 to 3) of the palette are used, the symbols can be taken to be 2 bits wide with codes starting at 3 bits.\n\nConversely, the symbol width could be set at 8, even if only values 0 and 1 are used; these data would only require a two-color table. Although there would be no point in encoding the file that way, something similar typically happens for bi-color images: the minimum symbol width is 2, even if only values 0 and 1 are used.\n\nThe code table initially contains codes that are one bit longer than the symbol size in order to accommodate the two special codes clr and end and codes for strings that are added during the process. When the table is full the code length increases to give space for more strings, up to a maximum code 4095 = FFF(hex). As the decoder builds its table it tracks these increases in code length and it is able to unpack incoming bytes accordingly.\n\nThe GIF encoding process can be modified to create a file without LZW compression that is still viewable as a GIF image. This technique was introduced originally as a way to avoid patent infringement. Uncompressed GIF can also be a useful intermediate format for a graphics programmer because individual pixels are accessible for reading or painting. An uncompressed GIF file can be converted to an ordinary GIF file simply by passing it through an image editor.\n\nThe modified encoding method ignores building the LZW table and emits only the root palette codes and the codes for CLEAR and STOP. This yields a simpler encoding (a 1-to-1 correspondence between code values and palette codes) but sacrifices all of the compression: each pixel in the image generates an output code indicating its color index. When processing an uncompressed GIF, a standard GIF decoder will not be prevented from writing strings to its dictionary table, but the code width must never increase since that triggers a different packing of bits to bytes.\n\nIf the symbol width is n, the codes of width n+1 fall naturally into two blocks: the lower block of 2n codes for coding single symbols, and the upper block of 2n codes that will be used by the decoder for sequences of length greater than one. Of that upper block, the first two codes are already taken: 2n for CLEAR and 2n + 1 for STOP. The decoder must also be prevented from using the last code in the upper block, 2n+1 − 1, because when the decoder fills that slot, it will increase the code width. Thus in the upper block there are 2n − 3 codes available to the decoder that won't trigger an increase in code width. Because the decoder is always one step behind in maintaining the table, it does not generate a table entry upon receiving the first code from the encoder, but will generate one for each succeeding code. Thus the encoder can generate 2n − 2 codes without triggering an increase in code width. Therefore, the encoder must emit extra CLEAR codes at intervals of 2n − 2 codes or less to make the decoder reset the coding dictionary. The GIF standard allows such extra CLEAR codes to be inserted in the image data at any time. The composite data stream is partitioned into sub-blocks that each carry from 1 to 255 bytes.\n\nFor the sample 3×5 image above, the following 9-bit codes represent \"clear\" (100) followed by image pixels in scan order and \"stop\" (101).\n\nAfter the above codes are mapped to bytes, the uncompressed file differs from the compressed file thus:\n\nThe trivial example of a large image of solid color demonstrates the variable-length LZW compression used in GIF files.\n\nThe code values shown are packed into bytes which are then packed into blocks of up to 255 bytes. A block of image data begins with a byte that declares the number of bytes to follow. The last block of data for an image is marked by a zero block-length byte.\n\nThe GIF Specification allows each image within the logical screen of a GIF file to specify that it is interlaced; i.e., that the order of the raster lines in its data block is not sequential. This allows a partial display of the image that can be recognized before the full image is painted.\n\nAn interlaced image is divided from top to bottom into strips 8 pixels high, and the rows of the image are presented in the following order:\n• Pass 1: Line 0 (the top-most line) from each strip.\n• Pass 3: Lines 2 and 6 from each strip.\n• Pass 4: Lines 1, 3, 5, and 7 from each strip.\n\nThe pixels within each line are not interlaced, but presented consecutively from left to right. As with non-interlaced images, there is no break between the data for one line and the data for the next. The indicator that an image is interlaced is a bit set in the corresponding Image Descriptor block.\n\nAlthough GIF was not designed as an animation medium, its ability to store multiple images in one file naturally suggested using the format to store the frames of an animation sequence. To facilitate displaying animations, the GIF89a spec added the Graphic Control Extension (GCE), which allows the images (frames) in the file to be painted with time delays, forming a video clip. Each frame in an animation GIF is introduced by its own GCE specifying the time delay to wait after the frame is drawn. Global information at the start of the file applies by default to all frames. The data is stream-oriented, so the file offset of the start of each GCE depends on the length of preceding data. Within each frame the LZW-coded image data is arranged in sub-blocks of up to 255 bytes; the size of each sub-block is declared by the byte that precedes it.\n\nBy default, an animation displays the sequence of frames only once, stopping when the last frame is displayed. To enable an animation to loop, Netscape in the 1990s used the Application Extension block (intended to allow vendors to add application-specific information to the GIF file) to implement the Netscape Application Block (NAB).[39] This block, placed immediately before the sequence of animation frames, specifies the number of times the sequence of frames should be played (1 to 65535 times) or that it should repeat continuously (zero indicates loop forever). Support for these repeating animations first appeared in Netscape Navigator version 2.0, and then spread to other browsers.[40] Most browsers now recognize and support NAB, though it is not strictly part of the GIF89a specification.\n\nThe following example shows the structure of the animation file Rotating earth (large).gif shown (as a thumbnail) in the article's infobox.\n\nThe animation delay for each frame is specified in the GCE in hundredths of a second. Some economy of data is possible where a frame need only rewrite a portion of the pixels of the display, because the Image Descriptor can define a smaller rectangle to be rescanned instead of the whole image. Browsers or other displays that do not support animated GIFs typically show only the first frame.\n\nThe size and color quality of animated GIF files can vary significantly depending on the application used to create them. Strategies for minimizing file size include using a common global color table for all frames (rather than a complete local color table for each frame) and minimizing the number of pixels covered in successive frames (so that only the pixels that change from one frame to the next are included in the latter frame). More advanced techniques involve modifying color sequences to better match the existing LZW dictionary, a form of lossy compression. Simply packing a series of independent frame images into a composite animation tends to yield large file sizes. Tools are available to minimize the file size given an existing GIF.\n\nMetadata can be stored in GIF files as a comment block, a plain text block, or an application-specific application extension block. Several graphics editors use unofficial application extension blocks to include the data used to generate the image, so that it can be recovered for further editing.\n\nAll of these methods technically require the metadata to be broken into sub-blocks so that applications can navigate the metadata block without knowing its internal structure.\n\nThe Extensible Metadata Platform (XMP) metadata standard introduced an unofficial but now widespread \"XMP Data\" application extension block for including XMP data in GIF files.[41] Since the XMP data is encoded using UTF-8 without NUL characters, there are no 0 bytes in the data. Rather than break the data into formal sub-blocks, the extension block terminates with a \"magic trailer\" that routes any application treating the data as sub-blocks to a final 0 byte that terminates the sub-block chain.\n\nIn 1977 and 1978, Jacob Ziv and Abraham Lempel published a pair of papers on a new class of lossless data-compression algorithms, now collectively referred to as LZ77 and LZ78. In 1983, Terry Welch developed a fast variant of LZ78 which was named Lempel–Ziv–Welch (LZW).[42][43]\n\nWelch filed a patent application for the LZW method in June 1983. The resulting patent, US4558302,[44] granted in December 1985, was assigned to Sperry Corporation who subsequently merged with Burroughs Corporation in 1986 and formed Unisys.[42] Further patents were obtained in the United Kingdom, France, Germany, Italy, Japan and Canada.\n\nIn addition to the above patents, Welch's 1983 patent also includes citations to several other patents that influenced it, including:\n\nIn June 1984, an article by Welch was published in the IEEE magazine which publicly described the LZW technique for the first time.[49] LZW became a popular data compression technique and, when the patent was granted, Unisys entered into licensing agreements with over a hundred companies.[42][50]\n\nThe popularity of LZW led CompuServe to choose it as the compression technique for their version of GIF, developed in 1987. At the time, CompuServe was not aware of the patent.[42] Unisys became aware that the version of GIF used the LZW compression technique and entered into licensing negotiations with CompuServe in January 1993. The subsequent agreement was announced on 24 December 1994.[43] Unisys stated that they expected all major commercial on-line information services companies employing the LZW patent to license the technology from Unisys at a reasonable rate, but that they would not require licensing, or fees to be paid, for non-commercial, non-profit GIF-based applications, including those for use on the on-line services.[50]\n\nFollowing this announcement, there was widespread condemnation of CompuServe and Unisys, and many software developers threatened to stop using GIF. The PNG format (see below) was developed in 1995 as an intended replacement.[42][43][49] However, obtaining support from the makers of Web browsers and other software for the PNG format proved difficult and it was not possible to replace GIF, although PNG has gradually increased in popularity.[42] Therefore, GIF variations without LZW compression were developed. For instance the libungif library, based on Eric S. Raymond's giflib, allows creation of GIFs that followed the data format but avoided the compression features, thus avoiding use of the Unisys LZW patent.[51] A 2001 Dr. Dobb's article described a way to achieve LZW-compatible encoding without infringing on its patents.[52]\n\nIn August 1999, Unisys changed the details of their licensing practice, announcing the option for owners of certain non-commercial and private websites to obtain licenses on payment of a one-time license fee of $5000 or $7500.[53] Such licenses were not required for website owners or other GIF users who had used licensed software to generate GIFs. Nevertheless, Unisys was subjected to thousands of online attacks and abusive emails from users believing that they were going to be charged $5000 or sued for using GIFs on their websites.[54] Despite giving free licenses to hundreds of non-profit organizations, schools and governments, Unisys was completely unable to generate any good publicity and continued to be condemned by individuals and organizations such as the League for Programming Freedom who started the \"Burn All GIFs\" campaign in 1999.[55][56]\n\nThe United States LZW patent expired on 20 June 2003.[57] The counterpart patents in the United Kingdom, France, Germany and Italy expired on 18 June 2004, the Japanese patents expired on 20 June 2004, and the Canadian patent expired on 7 July 2004.[57] Consequently, while Unisys has further patents and patent applications relating to improvements to the LZW technique,[57] LZW itself (and consequently GIF) have been free to use since July 2004.[58]\n\nPortable Network Graphics (PNG) was designed as a replacement for GIF in order to avoid infringement of Unisys' patent on the LZW compression technique.[42] PNG offers better compression and more features than GIF,[59] animation being the only significant exception. PNG is more suitable than GIF in instances where true-color imaging and alpha transparency are required.\n\nAlthough support for PNG format came slowly, new web browsers support PNG. Older versions of Internet Explorer do not support all features of PNG. Versions 6 and earlier do not support alpha channel transparency without using Microsoft-specific HTML extensions.[60] Gamma correction of PNG images was not supported before version 8, and the display of these images in earlier versions may have the wrong tint.[61]\n\nFor identical 8-bit (or lower) image data, PNG files are typically smaller than the equivalent GIFs, due to the more efficient compression techniques used in PNG encoding.[62] Complete support for GIF is complicated chiefly by the complex canvas structure it allows, though this is what enables the compact animation features.\n\nVideos resolve many issues that GIFs present through common usage on the web. They include drastically smaller file sizes, the ability to surpass the 8-bit color restriction, and better frame-handling and compression through inter-frame coding. Virtually universal support for the GIF format in web browsers and a lack of official support for video in the HTML standard caused GIF to rise to prominence for the purpose of displaying short video-like files on the web.\n• MNG (\"Multiple-image Network Graphics\") was originally developed as a PNG-based solution for animations. MNG reached version 1.0 in 2001, but few applications support it.\n• APNG (\"Animated Portable Network Graphics\") was proposed by Mozilla in 2006. APNG is an extension to the PNG format as alternative to the MNG format. APNG is supported by most browsers as of 2019. 63 APNG provides the ability to animate PNG files, while retaining backwards compatibility in decoders that cannot understand the animation chunk (unlike MNG). Older decoders will simply render the first frame of the animation.\n• Embedded Adobe Flash objects and MPEG files were used on some websites to display simple video, but required the use of an additional browser plugin.\n• WebM and WebP are in development and are supported by some web browsers. 70\n• Other options for web animation include serving individual frames using AJAX, or animating SVG (\"Scalable vector graphics\") images using JavaScript or SMIL (\"Synchronized Multimedia Integration Language\"). 71\n• With the introduction of widespread support of the HTML video ( ) tag in most web browsers, some websites use a looped version of the video tag generated by JavaScript functions. This gives the appearance of a GIF, but with the size and speed advantages of compressed video.\n• HEIF (\"High Efficiency Image File Format\") is an image file format, finalized in 2015, which uses a discrete cosine transform (DCT) lossy compression algorithm based on the HEVC video format, and related to the JPEG image format. In contrast to JPEG, HEIF supports animation. 73\n• VP9 only supports alpha compositing with 4:2:0 chroma subsampling, 75 which may be unsuitable for GIFs that combine transparency with rasterised vector graphics with fine color details.\n• AV1 video codec or AVIF can also be used either as a video or a sequenced image.\n\nIn April 2014, 4chan added support for silent WebM videos that are under 3 MB in size and 2 min in length,[76][77] and in October 2014, Imgur started converting any GIF files uploaded to the site to H.264 video and giving the link to the HTML player the appearance of an actual file with a extension.[78][79]\n\nIn January 2016, Telegram started re-encoding all GIFs to MPEG-4 videos that \"require up to 95% less disk space for the same image quality.\"[80]\n• GIF art, a form of digital art associated with GIF\n• GNU plotutils (supports pseudo-GIF, which uses run-length encoding rather than LZW)"
    }
]