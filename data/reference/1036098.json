[
    {
        "link": "https://opensource.com/article/19/11/simulate-gravity-python",
        "document": ""
    },
    {
        "link": "https://stackoverflow.com/questions/59656983/collision-detection-physics-for-simple-game",
        "document": "You have to reflect the movement vectors ( , ) and ( , ) when the objects hit. For a given incident vector and surface normal , the reflection direction calculated as .\n\nThe normal vector is the Unit vector from one center point to the other, when the objects hit, Detect the hit and normalize the vector between the center points (divide the vector by ):\n\nUse to calculate the reflection. Use to compute the length of the reflected vectors and exchange there length by :\n\nSince it is not possible to detect the \"hit\" exactly, when the distance between the players is it is necessary to correct the position of the players and to find the point when the distance is exactly :"
    },
    {
        "link": "https://gamedevacademy.org/pygame-collisions-tutorial-complete-guide",
        "document": "Have you ever played a game where your character moves around the screen, avoiding enemies, collecting items, or simply not bumping into walls? If you have, you have directly interacted with a common game development concept known as “collision detection”. This concept is at the core of virtually every video game, and as an aspiring game developer, understanding this principle is key to creating immersive, interactive experiences.\n\nSimply put, collision detection in Pygame refers to the computational mechanism that checks for the intersection of two or more game objects. It is a technique widely used in video game development to ascertain when objects come into contact.\n\nLearning about collisions in Pygame has multiple benefits:\n• Interactivity: It provides the key element of interactivity in your games, allowing characters to interact with their environment.\n• Variety: It broadens the range of games and mechanics you can implement, from simple bouncing paddles to complex player character interactions.\n• Problem-solving skills: Tackling the challenges of implementing collision enhances your problem-solving skills as a developer.\n\nWith collision detection, you can improve the overall game experience by delivering a more realistic response to the user’s actions. Now let’s delve into some practical examples.\n\nLearning to handle collisions begins with understanding basic collisions. Let’s consider two objects represented by Pygame Rect objects:\n\nTo check if these two objects collide, you could use the ‘colliderect’ function:\n\nThis is a simple but powerful example of how to handle collisions in Pygame.\n\nAs you may implement multiple objects in your game, you will need more complex collision detections. Consider a scenario where you need to check whether an object collides with any object in a group.\n\nThis illustrates the idea of multiple collisions, where you have to detect collisions between an object and a group of objects.\n\nOn the Road to Mastery with Zenva\n\nLet’s take your learning experience a notch higher with our Python Mini-Degree at Zenva. We strive to provide content that helps learners at every point of their coding journey. Our mini-degree has several modules that dive deep into Pygame and other advanced Python concepts. It’s an excellent resource for mastering Python game development skills and more – visit the Python Mini-Degree here.\n\nWe have touched on the concept of Pygame collisions and the importance it holds in game development. While collisions in Pygame may seem complex at first, mastering it starts with understanding basic concepts and progressively taking on more complex implementations.\n\nMost importantly, constant learning and practice is key to mastery. Our Python Mini-Degree is a perfect avenue to continue building on this foundation. Persistence and dedication to learning will most definitely pay off. Enhance your Python skills, take the leap with Pygame, and start creating compelling video game experiences today!\n\n\n\nBefore we delve further into collision detection, it’s crucial to understand how to move game objects around, forming the basis for dynamic collision scenarios. A simple rectangle can be moved by manipulating the x and y value:\n\nThis will move the object to a new position. For smoother motion, one way is to change the object’s position based on the elapsed time:\n\nThis snippet moves the rectangle and checks if it exceeds screen boundaries, re-positioning it if necessary.\n\nWe’re ready to add collisions to the mix. Here, we’ll check collisions with the screen edge:\n\nThis program will print “Collision detected!” whenever object1 collides with the edge of the screen.\n\nAdd a dash of realism to your game through basic physics. Let’s implement a simple gravity effect:\n\nThe object falls due to gravity and stops when it hits the screen’s bottom edge.\n\nLet’s add another object to our game and check collisions between them to add more complexity:\n\nWhenever the two objects collide, “Collision detected!” will be printed.\n\nRemember, constant practice is key. Understanding and implementing Pygame collision checks can seem daunting initially, but repetition will make the process much more intuitive. Keep refining your codes and remember to refer back to examples as provided in this tutorial. Above all, maintain the fun factor; after all, we’re dealing with game development!\n\nCollisions are not just about detection, but also how game objects interact upon collision. Let’s make object2 unmovable while object1 bounces upon collision:\n\nIn this case, when object1 collides with object2, it changes direction and moves in the opposite direction.\n\nTo manage collisions among many objects, Pygame provides the `Sprite` and `Group` classes, simplifying handling of multiple objects.\n\nIn the following example, we use these classes to spawn multiple moving objects and check collisions among them:\n\nIn the above code, when a sprite collides with another sprite within the group, the console prints “Collision detected!”.\n\nPower-ups, health packs, and hazardous objects are standard features in video games. Let’s create a simple game scenario where the player can collect power-ups while avoiding deadly spikes:\n\nThe `groupcollide()` function is used to check for collisions between two groups. If a collision is detected with a power-up, it’s collected (removed from the group), and if a collision is detected with a spike, it’s also removed, indicating the player took damage.\n\nNow that you have hands-on experience with Pygame collisions, why not put your knowledge into practice? Try creating a game project where the player must collect items while avoiding obstacles. Test out different collision scenarios and experiment with different actions on collision. Remember, practice, and creativity are core to a successful learning journey. Happy coding!\n\nWhile bounding rectangle-based collisions work for most scenarios, sometimes more precision is required. If your game relies on detailed sprites, you’ll want pixel-perfect collision detection. Pygame provides the `mask` module for this.\n\nConsider two game objects with their respective masks. A mask in Pygame is a simpler logical representation of the sprite’s shape:\n\nNext, we can check for a collision between these two objects:\n\nWhile this process is more CPU intensive, it provides significantly increased accuracy for collision detections.\n\nCollisions in a game often trigger reactions, for a more immersive experience, sound effects can be added:\n\nReading collision detection status and playing sound accordingly can add depth and excitement to your game.\n\nIn addition to sound, visually appealing particle effects can also be activated upon collisions:\n\nWhen a collision is detected, particles are spawned at the collision point, enhancing the visibility of the interaction.\n\nWe’ve embarked on an insightful journey from understanding collisions, through detecting and managing them, to making games more interactive through sound effects and particle physics. As with any new concept, practice is fundamental to cementing this knowledge. Attempting new projects, enhancing existing ones or even redoing tutorial examples, will greatly bolster your competency and offer innovative ways to make games more fun and engaging.\n\nNow, you’re equipped with a key principle in game development, keep practicing, keep experimenting – the sky is the limit!\n\nEmbracing the journey of continuous learning is the hallmark of a successful developer. Understanding the implications and applications of Pygame collision detection is just the beginning. As you delve further into game development with Python, numerous fascinating concepts are waiting to be explored and mastered.\n\nWe at Zenva offer beginner to professional courses in programming, game development, and AI. Our curriculum is tailored to cater to diverse learning paths, petrolled by a wide range of over 250 supported courses. With us, there’s always an opportunity to nurture existing abilities and acquire new skills, whether you desire to learn coding, create games, explore AI or transition from a beginner to a professional.\n\nFor an encompassing understanding of Python programming, our Python Mini-Degree is your ideal partner in this journey. This program offers a selection of courses ranging from coding basics to advanced areas like game development, app development, and much more. At your own pace and tailored to your schedule, you can immerse in interactive courses, work on exciting projects, and earn valued certificates, all accessible 24/7.\n\nTo further enhance your Python learning experience, you can also explore our broader Python course selection. As we continue to strive in equipping you with profound coding skills and knowledge, remember, the next level of your programming journey is just a few clicks away!\n\nUnderstanding and implementing Pygame collision detection is a milestone on your path towards mastering Python game programming. As we have demonstrated in this tutorial, the use of Pygame collisions can significantly enhance your game’s interactivity, leading to more advanced and immersive experiences.\n\nContinue your journey towards game creation mastery with Zenva’s high-quality, far-reaching resources. Our Python Mini-Degree will provide you with a comprehensive and practical understanding of Pygame, Python, and more. Transition from a beginner to an accomplished developer and let your imagination lead your creations, one collision at a time. Happy coding!"
    },
    {
        "link": "https://makeuseof.com/pygame-collision-detection-physics",
        "document": "Pygame provides several built-in functions for detecting collisions between game objects. These are invaluable because working out exactly when and how moving objects overlap can be a complicated task.\n\nLearn how to add basic physics and collisions in your game using the pygame module.\n\nThe most basic built-in collision detection function is spritecollide. It takes in a sprite, a group of sprites, and a boolean value indicating whether or not the sprites should \"die\" (be removed) when they collide. This function returns a list of sprites that have collided. Here is an example of how to use it:\n\nAnother useful collision detection function is groupcollide, which takes in two groups of sprites and a boolean value as well. This function returns a dictionary with the collided sprites as the keys and the sprites they collided with as the values. Here's an example of how to use it:\n\nTo create a basic platformer game using Pygame, you will need to create a player sprite that the user can control and a platform sprite for the player to stand on. You can use the spritecollide function to detect when the player sprite collides with the platform sprite and prevent the player from falling through the platform.\n\nTo start, install the pygame module using pip:\n\nAfter that, create simple classes for the Player and Platform, both of which should inherit from Pygame’s Sprite class. The Player class should have an update method to handle the position of the player based on the velocity. Also, it should have a y_velocity variable to apply the gravity effect. The Platform class should have an __init__ method that takes the coordinates of the platform and creates a surface with that size.\n\nYou can create a Player class using the pygame.sprite.Sprite module. This class will initialize the player with a given x and y coordinates. Then, the update method will update the position of the player by incrementing the y_velocity value.\n\nThe Platform class also uses the pygame.sprite.Sprite module. This class will initialize the platform with given x and y coordinates, as well as a width and height.\n\nThe game loop will allow you to create a window with a size of 640x480. Then, it will run a loop that will check for any events, such as a quit command. It will also check for any collisions between the player and the platform. Finally, it will fill the screen with a white color, draw the player and platform, and then flip the display.\n\nBelow is the output:\n\nTo implement gravity and jumping behavior in your platformer game, you will need to add a y velocity to your player sprite and update its y position in each frame. To do this you can use the update method inside the Player class and add the following code snippet:\n\nNow every time you call the update method, it will update the player position according to its velocity and gravity.\n\nTo make the player sprite jump, you can bind the jumping action to a specific key or button and update the player's y velocity with a negative value. The following code snippet is an example of how to jump when a player presses the spacebar.\n\nNote that you will need to check the event.type to make sure that the event is a KEYDOWN event before checking the key value.\n\nAdding Basic Physics Such as Friction and Acceleration\n\nTo add basic physics such as friction and acceleration to your platformer game, you will need to update the x velocity of your player sprite in each frame. You can add x velocity to the player class and update it in the same way as y velocity. To implement friction, you can decrease the x velocity of the player sprite by a small amount in each frame. For example, you can add the following code snippet inside the update method of the Player class:\n\nTo implement acceleration, you can set a variable, player_movement, for the horizontal movement, and update the x velocity of the player sprite according to the player_movement value. You can do this by binding the movement to specific keys or buttons and updating the player's x velocity in the event loop, for example:\n\nBy using these techniques, you can create a simple yet fun platformer game using Pygame's built-in collision detection functions and basic physics. With a little bit of creativity and experimentation, you can use these techniques to create a variety of different games and game mechanics.\n\nYou can find the complete code in the GitHub repository.\n\nBelow is the output:\n\nMany games require some form of collision detection. You can use collisions to create a wide range of game mechanics, from simple platformers to complex physics-based simulations.\n\nImplementing basic physics such as gravity, friction, and acceleration can also greatly improve user engagement, adding realism and a sense of weight to game objects."
    },
    {
        "link": "https://github.com/AkiRusProd/python-2d-physics",
        "document": "This project is a simple 2D physics simulation implemented in Python using the Pygame library for objects visualization. It is designed to simulate basic physical phenomena such as collisions, gravity, and friction for various shapes like rectangles, circles, and convex polygons.\n• Collision Response: Includes impulse-based collision response with support for both linear and rotational kinematics.\n\nThe project is structured into several modules:\n• main.py: The entry point of the application, which sets up the Pygame window and contains the main game loop.\n• body.py: Defines the , , and classes, which represent physical objects in the simulation.\n• space.py: Contains the class, which manages all bodies and simulates physics steps.\n• collision.py: Contains functions for collision detection and response.\n\nThis project was inspired by various resources on game development and physics simulations, including:"
    },
    {
        "link": "https://stackoverflow.com/questions/58710804/how-to-detect-collision-using-pybox2d-and-use-that-information",
        "document": "I am trying to filter collisions occurring in my Box2D world by reproducing this example: https://github.com/pybox2d/pybox2d/blob/master/examples/collision_filtering.py\n\nI have four classes in my world, Car, Wheel, Building, and Pedestrian, I want to filter which instance collided with which and one of the possible outputs is (pseudo-code)\n\nI have this set of categories\n\nI also tried this: but it doesn't work (it does nothing)\n\nand I apply this in given classes (only class Pedestrian shown as example for simplicity):\n\nAnd then I draw the bodies and run the world using pygame\n\nBut I am confused about how to continue, how could I use the information from the collisionfilter to be able to for example print the sentence about the accident from above?\n\nThank you very much EDIT: I have found a link which solves exactly what I want to do, but it is written in C++ and I do not understand it http://www.iforce2d.net/b2dtut/collision-callbacks"
    },
    {
        "link": "https://box2d.org/documentation",
        "document": "Box2D is a 2D rigid body simulation library for games. Programmers can use it in their games to make objects move in realistic ways and make the game world more interactive. From the game engine's point of view, a physics engine is just a system for procedural animation.\n\nBox2D is written in portable C11. Most of the types defined in the engine begin with the b2 prefix. Hopefully this is sufficient to avoid name clashing with your application.\n\nIn this manual I'll assume you are familiar with basic physics concepts, such as mass, force, torque, and impulses. If not, please first consult Google search and Wikipedia.\n\nBox2D was created as part of a physics tutorial at the Game Developer Conference. You can get these tutorials from the publications section of box2d.org.\n\nSince Box2D is written in C, you are expected to be experienced in C programming. Box2D should not be your first C programming project! You should be comfortable with compiling, linking, and debugging.\n\nThis manual covers the majority of the Box2D API. However, not every aspect is covered. Please look at the Reference section and samples application included with Box2D to learn more.\n\nThis manual is only updated with new releases. The latest version of Box2D may be out of sync with this manual.\n\nPlease file bugs and feature requests here: Box2D Issues\n\nYou can help to ensure your issue gets fixed if you provide sufficient detail. A testbed example that reproduces the problem is ideal. You can read about the testbed later in this document.\n\nThere is also a Discord server and a subreddit for Box2D.\n\nBox2D works with several fundamental concepts and objects. I briefly define these objects here and more details are given later in this document.\n\nA chunk of matter that is so strong that the distance between any two bits of matter on the chunk is constant. They are hard like a diamond. In the following discussion I use body interchangeably with rigid body.\n\nA shape binds collision geometry to a body and adds material properties such as density, friction, and restitution. A shape puts collision geometry into the collision system (broad-phase) so that it can collide with other shapes.\n\nA constraint is a physical connection that removes degrees of freedom from bodies. A 2D body has 3 degrees of freedom (two translation coordinates and one rotation coordinate). If I take a body and pin it to the wall (like a pendulum) I have constrained the body to the wall. At this point the body can only rotate about the pin, so the constraint has removed 2 degrees of freedom.\n\nA special constraint designed to prevent penetration of rigid bodies and to simulate friction and restitution. You do not create contact constraints; they are created automatically by Box2D.\n\nThis is a constraint used to hold two or more bodies together. Box2D supports several joint types: revolute, prismatic, distance, and more. Joints may have limits, motors, and/or springs.\n\nA joint limit restricts the range of motion of a joint. For example, the human elbow only allows a certain range of angles.\n\nA joint motor drives the motion of the connected bodies according to the joint's degrees of freedom. For example, you can use a motor to drive the rotation of an elbow. Motors have a target speed and a maximum force or torque. The simulation will apply the force or torque required to achieve the desired speed.\n\nA joint spring has a stiffness and damping. In Box2D spring stiffness is expressed in terms or Hertz or cycles per second. This lets you configure how quickly a spring reacts regardless of the body masses. Joint springs also have a damping ratio to let you specify how quickly the spring will come to rest.\n\nA physics world is a collection of bodies, shapes, joints, and contacts that interact together. Box2D supports the creation of multiple worlds which are completely independent.\n\nThe physics world has a solver that is used to advance time and to resolve contact and joint constraints. The Box2D solver is a high performance sequential solver that operates in order N time, where N is the number of constraints.\n\nThe solver advances bodies in time using discrete time steps. Without intervention this can lead to tunneling.\n\nBox2D contains specialized algorithms to deal with tunneling. First, the collision algorithms can interpolate the motion of two bodies to find the first time of impact (TOI). Second, speculative collision is used to create contact constraints between bodies before they touch.\n\nWorld simulation leads to the creation of events that are available at the end of the time step:\n\nThese events allow your application to react to changes in the simulation.\n\nBox2D's primary purpose is to provide rigid body simulation. However, there are math and collision features that may be useful apart from the rigid body simulation. These are provided in the directory. Anything in the directory is considered public, while everything in the directory is consider internal.\n\nPublic features are supported and you can get help with these on the Discord server. Using internal code directly is not supported.\n\nBox2D works with floating point numbers and tolerances have to be used to make Box2D perform well. These tolerances have been tuned to work well with meters-kilogram-second (MKS) units. In particular, Box2D has been tuned to work well with moving shapes between 0.1 and 10 meters. So this means objects between soup cans and buses in size should work well. Static shapes may be up to 50 meters long without trouble. If you have a large world, you should split it up into multiple static bodies.\n\nBeing a 2D physics engine, it is tempting to use pixels as your units. Unfortunately this will lead to a poor simulation and possibly weird behavior. An object of length 200 pixels would be seen by Box2D as the size of a 45 story building.\n\nIt is best to think of Box2D bodies as moving billboards upon which you attach your artwork. The billboard may move in a unit system of meters, but you can convert that to pixel coordinates with a simple scaling factor. You can then use those pixel coordinates to place your sprites, etc. You can also account for flipped coordinate axes.\n\nAnother limitation to consider is overall world size. If your world units become larger than 12 kilometers or so, then the lost precision can affect stability.\n\nBox2D uses radians for angles. The body rotation is stored a complex number, so when you access the angle of a body, it will be between \\(-\\pi\\) and \\(\\pi\\) radians.\n\nAdvanced users may change the length unit by calling at application startup. If you keep Box2D in a shared library, you will need to call this if the shared library is reloaded.\n\nIf you change the length units to pixels you will need to decide how many pixels represent a meter. You will also need to figure out reasonable values for gravity, density, force, and torque. One of the benefits of using MKS units for physics simulation is that you can use real world values to get reasonable results.\n\nIt is also harder to get support for using Box2D if you change the unit system, because values are harder to communicate and may become non-intuitive.\n\nFast memory management plays a central role in the design of the Box2D interface. When you create a world, body, shape or joint, you will receive a handle called an id. These ids are opaque and are passed to various functions to access the underlying data.\n\nThese ids provide some safety. If you use an id after it has been freed you will usually get an assertion. All ids support 64k generations of safety. All ids also have a corresponding function you can call to check if it is valid.\n\nWhen you create a world, body, shape, or joint, you need to provide a definition structure. These definitions contain all the information needed to build the Box2D object. By using this approach I can prevent construction errors, keep the number of function parameters small, provide sensible defaults, and reduce the number of accessors.\n\nHere is an example of body creation:\n\nNotice the body definition is initialize by calling . This is needed because C does not have constructors and zero initialization is not suitable for the definitions used in Box2D.\n\nAlso notice that the body definition is a temporary object that is fully copied into the internal body data structures. Definitions should usually be created on the stack as temporaries.\n\nThis is how a body is destroyed:\n\nNotice that the body id is set to null using the constant . You should treat ids as opaque data, however you may zero initialize all Box2D ids and they will be considered null.\n\nShapes are created in a similar way. For example, here is how a box shape is created:\n\nAnd the shape may be destroyed as follows:\n\nFor convenience, Box2D will destroy all shapes on a body when the body is destroyed. Therefore, you may not need to store the shape id."
    },
    {
        "link": "https://github.com/pybox2d/cython-box2d/blob/master/docs/source/getting_started.md",
        "document": "pybox2d is a 2D rigid body simulation library for games. Programmers can use it in their games to make objects move in believable ways and make the game world more interactive. From the game's point of view a physics engine is just a system for procedural animation.\n\nBox2D, the library behind pybox2d, is written in portable C++ and bound to Python by Cython.\n\nIn this manual I'll assume you are familiar with basic physics concepts, such as mass, force, torque, and impulses. If not, please first consult the many tutorials provided by Chris Hecker and David Baraff (Google these names). You do not need to understand their tutorials in great detail, but they do a good job of laying out the basic concepts that will help you use pybox2d.\n\nWikipedia is also an excellent source of physics and mathematics knowledge. In some ways it is more useful than Google, because it has carefully crafted content.\n\nBox2D was created as part of a physics tutorial at the Game Developer Conference. You can get these tutorials from the download section of box2d.org.\n\npybox2d works with several fundamental objects. We briefly define these objects here and more details are given later in this document.\n\nA 2D geometrical object, such as a circle or polygon.\n\nA chunk of matter that is so strong that the distance between any two bits of matter on the chunk is completely constant. They are hard like a diamond. In the following discussion we use body interchangeably with rigid body.\n\nA fixture binds a shape to a body and adds material properties such as density, friction, and restitution.\n\nA constraint is a physical connection that removes degrees of freedom from bodies. In 2D a body has 3 degrees of freedom (two translation coordinates and one rotation coordinate). If we take a body and pin it to the wall (like a pendulum) we have constrained the body to the wall. At this point the body can only rotate about the pin, so the constraint has removed 2 degrees of freedom.\n\nA special constraint designed to prevent penetration of rigid bodies and to simulate friction and restitution. You do not create contact constraints; they are created automatically by Box2D.\n\nThis is a constraint used to hold two or more bodies together. pybox2d supports several joint types: revolute, prismatic, distance, and more. Some joints may have limits and motors.\n\nA joint limit restricts the range of motion of a joint. For example, the human elbow only allows a certain range of angles.\n\nA joint motor drives the motion of the connected bodies according to the joint's degrees of freedom. For example, you can use a motor to drive the rotation of an elbow.\n\nA physics world is a collection of bodies, fixtures, and constraints that interact together. pybox2d supports the creation of multiple worlds, but this is usually not necessary or desirable.\n\nBox2D is composed of three modules: Common, Collision, and Dynamics. The Common module has code for allocation, math, and settings. The Collision module defines shapes, a broad-phase, and collision functions/queries. Finally the Dynamics module provides the simulation world, bodies, fixtures, and joints. As a pybox2d user, you do not need to worry about this for the most part, unless you are delving into the C++ source.\n\npybox2d works with floating point numbers, so some tolerances have to be used to make pybox2d perform well. These tolerances have been tuned to work well with meters-kilogram-second (MKS) units. In particular, Box2D has been tuned to work well with moving objects between 0.1 and 10 meters. So this means objects between soup cans and buses in size should work well. Static objects may be up to 50 meters without too much trouble.\n\nBeing a 2D physics engine, it is tempting to use pixels as your units. Unfortunately this will lead to a poor simulation and possibly weird behavior. An object of length 200 pixels would be seen by Box2D as the size of a 45 story building. Imagine trying to simulate the movement of a high-rise building with an engine that is tuned to simulate ragdolls and barrels. It isn't pretty.\n\nIt is best to think of pybox2d bodies as moving billboards upon which you attach your artwork. The billboard may move in a unit system of meters, but you can convert that to pixel coordinates with a simple scaling factor. You can then use those pixel coordinates to place your sprites, etc.\n\npybox2d uses radians for angles. The body rotation is stored in radians and may grow unbounded. Consider normalizing the angle of your bodies if the magnitude of the angle becomes too large ( ).\n\nMemory management plays a central role in the design of the pybox2d API. So when you create a Body or a Joint, you need to call the factory functions on World. There are creation functions:\n\nAnd there are corresponding destruction functions:\n\nWhen you create a body or joint, you have the option of providing a definition or using some of pybox2d's convenient kwarg support. These definitions contain all the information needed to build the body or joint. I'll provide further examples of possible usage shortly.\n\nSince fixtures must be parented to a body, they are created and destroyed using a factory method on Body:\n\nThere is also shortcut to create a fixture directly from the shape and density.\n\nFactories do not retain references to the definitions. So you can create and reuse definitions, but you do not need to store them.\n\nThe most efficient way to create many bodies or fixtures is using create_body_from_def() or create_fixture_from_def() on BodyDef and FixtureDef. A marginally slower (but significantly more convenient) pybox2d shorthand exists allowing you to forego these definitions.\n\nThe following are equivalent:\n\nWorld has the following creation functions available. Be sure to read their docstrings (i.e., help(World.create_dynamic_body) ) for further information.\n\nBodies have similar methods for fixture creation, described in later sections.\n\nVec2 is pybox2d's 2d vector class. In most cases, it is not necessary to specifically pass a Vec2 into a function. As you can see in the EdgeShape example above, the two vertices were passed as tuples. Similarly, properly sized (i.e., 2 element) lists or sequences can also be used.\n\nIf you intend to do calculations on 2d vectors, you will want to use this class -- or substitute your own, should you so choose.\n\nThe following are all equivalent:\n\nNote that you cannot just make a tuple and expect it to behave as a Vec2. This works because the above properties/methods return Vec2. Should you want to use a vector for something else, first you would need to define one:\n\nIn pybox2d, with the help of Cython, we can now subclass Body and use them directly in our engine. For example:\n\nThe Fixture and Body classes also allow you to attach your own custom user data. This is handy when you are examining pybox2d data structures and you want to determine how they relate to the data structures in your game engine without subclassing as in the previous section.\n\nFor example, it is typical to attach an actor pointer to the rigid body on that actor. This sets up a circular reference. If you have the actor, you can get the body. If you have the body, you can get the actor.\n\nHere are some examples of cases where you would need the user data:\n• Applying damage to an actor using a collision result.\n• Playing a scripted event if the player is inside an axis-aligned box.\n• Accessing a game structure when pybox2d notifies you that a joint is going to be destroyed.\n\nKeep in mind that user data is optional and you can put anything in it. However, you should be consistent. For example, an integer in one, a dict in another, will lead to confusion when you are searching for a specific body.\n\nIn the distribution of pybox2d is a Hello World example. The program creates a large ground box and a small dynamic box. This code does not contain any graphics. All you will see is text output in the console of the box's position over time.\n\nThis is a good example of the absolute basics of pybox2d, without letting graphics and GUIs get in the way.\n\nEvery pybox2d program begins with the creation of a World object. World is the physics hub that manages memory, objects, and simulation. It is easy to create a pybox2d world.\n\nSo now we have our physics world, let's start adding some stuff to it.\n\nBodies are built using the following steps:\n• Use the world object to create a body with a position, damping, etc.\n• Create fixtures on the body with a shape, friction, density, etc.\n\nTo illustrate what goes on behind the scenes of pybox2d, let's create the body the long way. This means that we need to specifically create a body definition first. Don't get discouraged -- I'll show how much easier it can be later.\n\nThe body definition is passed to the world object to create the ground body. The world object does not keep a reference to the body definition. The ground body is created as a static body. Static bodies don't collide with other static bodies and are immovable. Box2D determines that a body is static when it has zero mass. Bodies have zero mass by default; therefore they are static by default.\n\nWe use the box property to form the ground polygon into a box shape, with the box centered on the origin of the parent body.\n\nSetting it as a box takes the half-width and half-height (extents). So in this case the ground box is 100 units wide (x-axis) and 20 units tall (y-axis). Box2D is tuned for meters, kilograms, and seconds. So you can consider the extents to be in meters. Box2D generally works best when objects are the size of typical real world objects. For example, a barrel is about 1 meter tall. Due to the limitations of floating point arithmetic, using Box2D to model the movement of glaciers or dust particles is not a good idea.\n\nWe finish the ground body by creating the shape fixture.\n\nBox2D does not keep a reference to the shape. It clones the data into a new object.\n\nNote that every fixture must have a parent body, even fixtures that are static. However, you can attach all static fixtures to a single static body. This need for static bodies is done to make the Box2D code more uniform internally, reducing the number of potential bugs.\n\nHere's a big shortcut to all of the above. The following few lines are equivalent to all of the steps of this example so far:\n\nSo now we have a ground body. We can use the same technique to create a dynamic body. The main difference, besides dimensions, is that we must establish the dynamic body's mass properties.\n\nFirst we create the body using create_dynamic_body. By default bodies are static, so we should set the BodyType at construction time to make the body dynamic. Let's do this with the new kwargs methods.\n\nNext we create and attach a polygon fixture:\n\nNotice that we set density to 1. The default density is zero. Also, the friction on the shape is set to 0.3. Both of these are from the fixture definition and not the shape definition. This is all taken care of behind the scenes using this method with pybox2d. You could very well create your own FixtureDef with those parameters and it would have the same effect. This would require at least 5x more code on your part.\n\nThat's it for initialization. We are now ready to begin simulating.\n\nSo we have initialized the ground box and a dynamic box. Now we are ready to set Newton loose to do his thing. We just have a couple more issues to consider.\n\nBox2D uses a computational algorithm called an integrator. Integrators simulate the physics equations at discrete points of time. This goes along with the traditional game loop where we essentially have a flip book of movement on the screen. So we need to pick a time step for pybox2d. Generally physics engines for games like a time step at least as fast as 60Hz or 1/60 seconds. You can get away with larger time steps, but you will have to be more careful about setting up the definitions for your world. We also don't like the time step to change much. A variable time step produces variable results, which makes it difficult to debug. So don't tie the time step to your frame rate (unless you really, really have to). Without further ado, here is the time step.\n\nIn addition to the integrator, Box2D also uses a larger bit of code called a constraint solver. The constraint solver solves all the constraints in the simulation, one at a time. A single constraint can be solved perfectly. However, when we solve one constraint, we slightly disrupt other constraints. To get a good solution, we need to iterate over all constraints a number of times.\n\nThere are two phases in the constraint solver: a velocity phase and a position phase. In the velocity phase the solver computes the impulses necessary for the bodies to move correctly. In the position phase the solver adjusts the positions of the bodies to reduce overlap and joint detachment. Each phase has its own iteration count. In addition, the position phase may exit iterations early if the errors are small.\n\nThe suggested iteration count for pybox2d is 10 for both velocity and position. You can tune this number to your liking, just keep in mind that this has a trade-off between speed and accuracy. Using fewer iterations increases performance but accuracy suffers. Likewise, using more iterations decreases performance but improves the quality of your simulation. For this simple example, we don't need much iteration. Here are our chosen iteration counts.\n\nNote that the time step and the iteration count are completely unrelated. An iteration is not a sub-step. One iteration is a single pass over all the constraints within a time step. You can have multiple passes over the constraints within a single time step. Don't worry if this is too confusing. Often, setting both iterations to 10 will give you the results you desire without having to worry about much else.\n\nWe are now ready to begin the simulation loop. In your game the simulation loop can be merged with your game loop. In each pass through your game loop you call . Just one call is usually enough, depending on your frame rate and your physics time step. After stepping, you should call to clear any forces you applied to the bodies.\n\nThe Hello World program was designed to be dead simple, so it has no graphical output. Rather than being utterly boring by producing no output, the code prints out the position and rotation of the dynamic body. Here is the simulation loop that simulates 60 time steps for a total of 1 second of simulated time.\n\nThe output shows the box falling and landing on the ground box. Your output should look like this:\n\nThis indicates that the body is slowly falling (in the y-axis, since this is how gravity is defined). Its angle is not changing during the beginning.\n\nThe Collision module contains shapes and functions that operate on them. The module also contains a dynamic tree and broad-phase to acceleration collision processing of large systems.\n\nShapes describe collision geometry and may be used independently of physics simulation. You may perform several operations with shapes.\n\npybox2d shapes implement the Shape base class. The base class defines functions to:\n• Test a point for overlap with the shape.\n• Compute the mass properties of the shape.\n\nIn addition, each shape has a type member and a radius. The radius even applies to polygons, as discussed below.\n\nCircles are solid. You cannot make a hollow circle. However, you can create chains of line segments using polygon shapes.\n\nPolygon shapes are solid convex polygons. A polygon is convex when all line segments connecting two points in the interior do not cross any edge of the polygon. Polygons are solid and never hollow. However, you can create line segments using 2 point polygons.\n\nYou must create polygons with a counter clockwise winding (CCW). We must be careful because the notion of CCW is with respect to a right-handed coordinate system with the z-axis pointing out of the plane. This might turn out to be clockwise on your screen, depending on your coordinate system conventions.\n\nYou can create a polygon shape by passing in a vertex array. The maximal size of the array is controlled by maxPolygonVertices which has a default value of 16. This is more than sufficient to describe most convex polygons.\n\nThe polygon shape has some custom initialization functions to create boxes.\n\nPolygons inherit a radius from Shape. The radius creates a skin around the polygon. The skin is used in stacking scenarios to keep polygons slightly separated. This allows continuous collision to work against the core polygon.\n\nYou can test a point for overlap with a shape. You provide a transform for the shape and a world point.\n\nSo, to use a transform to test a point:\n\nThe Collision module contains bilateral functions that take a pair of shapes and compute some results. These include:\n\nBox2D has functions to compute contact points for overlapping shapes. If we consider circle-circle or circle-polygon, we can only get one contact point and normal. In the case of polygon-polygon we can get two points. These points share the same normal vector so Box2D groups them into a manifold structure. The contact solver takes advantage of this to improve stacking stability.\n\nNormally you don't need to compute contact manifolds directly, however you will likely use the results produced in the simulation.\n\nThe Manifold structure holds a normal vector and up to two contact points. The normal and points are held in local coordinates. As a convenience for the contact solver, each point stores the normal and tangential (friction) impulses.\n\nThe WorldManifold structure can be used to generate the world coordinates of the contact normal and points. You need to provide a Manifold and the shape transforms and radii.\n\nDuring simulation shapes may move and the manifolds may change. Points may be added or removed. You can detect this using get_point_states.\n\nThe Distance function can be used to compute the distance between two shapes. The distance function needs both shapes to be converted into a DistanceProxy. There is also some caching used to warm start the distance function for repeated calls. You can see the details in b2Distance.h.\n\nIf two shapes are moving fast, they may tunnel through each other in a single time step.\n\nThe TimeOfImpact is used to determine the time when two moving shapes collide. This is called the *time of impact *(TOI). The main purpose of TimeOfImpact is for tunnel prevention. In particular, it is designed to prevent moving objects from tunneling outside of static level geometry.\n\nThis function accounts for rotation and translation of both shapes, however if the rotations are large enough, then the function may miss a collision. However the function will still report a non-overlapped time and will capture all translational collisions.\n\nThe time of impact function identities an initial separating axis and ensures the shapes do not cross on that axis. This will miss collisions that are clear at the final positions. While this approach may miss some collisions, it is very fast and adequate for tunnel prevention.\n\nIt is difficult to put a restriction on the rotation magnitude. There may be cases where collisions are missed for small rotations. Normally, these missed rotational collisions should not harm game play.\n\nThe function requires two shapes (converted to DistanceProxy) and two Sweep structures. The sweep structure defines the initial and final transforms of the shapes.\n\nYou can use fixed rotations to perform a shape cast. In this case, the time of impact function will not miss any collisions.\n\n** TODO: This might not function at all in pybox2d *\n\nThe DynamicTree class is used by Box2D to organize large numbers of shapes efficiently. The class does not know about shapes. Instead it operates on axis-aligned bounding boxes (AABBs) with user data pointers.\n\nThe dynamic tree is a hierarchical AABB tree. Each internal node in the tree can has two children. A leaf node is a single user AABB.\n\nThe tree structure allows for efficient ray casts and region queries. For example, you may have hundreds of shapes in your scene. You could perform a ray cast against the scene in a brute force manner by ray casting each shape. This would be inefficient because it does not take advantage of shapes being spread out. Instead, you can maintain a dynamic tree and perform ray casts against the tree. This traverses the ray through the tree skipping large numbers of shapes.\n\nA region query uses the tree to find all leaf AABBs that overlap a query AABB. This is faster than a brute force approach because many shapes can be skipped.\n\nNormally you will not use the dynamic tree directly. Rather you will go through the World class for ray casts and region queries. If you do plan to create your own dynamic tree, you can learn how to use it by looking at how Box2D uses it (in C++, there are no Python examples TODO).\n\nCollision processing in a physics step can be divided into narrow-phase and broad-phase. In the narrow-phase we compute contact points between pairs of shapes. Imagine we have N shapes. Using brute force, we would need to perform the narrow-phase for N*N/2 pairs.\n\nThe BroadPhase class reduces this load by using a dynamic tree for pair management. This greatly reduces the number of narrow-phase calls.\n\nNormally you do not interact with the broad-phase directly. Instead, Box2D creates and manages a broad-phase internally. Also, BroadPhase is designed with Box2D's simulation loop in mind, so it is likely not suited for other use cases. This means you, as a pybox2d user, also do not have to worry about this.\n\nThe Dynamics module is the most complex part of Box2D and is the part you likely interact with the most. The Dynamics module sits on top of the Common and Collision modules, so you should be familiar with those by now.\n\nThere are many dependencies between these classes so it is difficult to describe one class without referring to another. In the following, you may see some references to classes that have not been described yet. Therefore, you may want to quickly skim this chapter before reading it closely.\n\nThe dynamics module is covered in the following chapters.\n\nRecall that shapes don't know about bodies and may be used independently. Therefore pybox2d provides the Fixture class to attach shapes to bodies. Fixtures hold the following:\n\nThese are described in the following sections.\n\nFixtures are created by initializing a fixture definition and then passing the definition to the parent body.\n\nThis creates the fixture and attaches it to the body. You do not need to store the fixture pointer since the fixture will automatically be destroyed when the parent body is destroyed. You can create multiple fixtures on a single body.\n\nYou can destroy a fixture on the parent body. You may do this to model a breakable object. Otherwise you can just leave the fixture alone and let the body destruction take care of destroying the attached fixtures.\n\nThe fixture density is used to compute the mass properties of the parent body. The density can be zero or positive. You should generally use similar densities for all your fixtures. This will improve stacking stability.\n\nThe mass of a body is automatically adjusted when you create a fixture.\n\nFriction is used to make objects slide along each other realistically. Box2D supports static and dynamic friction, but uses the same parameter for both. Friction is simulated accurately in Box2D and the friction strength is proportional to the normal force (this is called Coulomb friction). The friction parameter is usually set between 0 and 1, but can be any non-negative value. A friction value of 0 turns off friction and a value of 1 makes the friction strong. When the friction force is computed between two shapes, Box2D must combine the friction parameters of the two parent fixtures. This is done with the geometric mean:\n\nSo if one fixture has zero friction then the contact will have zero friction.\n\nRestitution is used to make objects bounce. The restitution value is usually set to be between 0 and 1. Consider dropping a ball on a table. A value of zero means the ball won't bounce. This is called an inelastic collision. A value of one means the ball's velocity will be exactly reflected. This is called a perfectly elastic collision. Restitution is combined using the following formula.\n\nFixtures carry collision filtering information to let you prevent collisions between certain game objects.\n\nWhen a shape develops multiple contacts, restitution is simulated approximately. This is because Box2D uses an iterative solver. Box2D also uses inelastic collisions when the collision velocity is small. This is done to prevent jitter.\n\nCollision filtering is a system for preventing collision between fixtures. For example, say you make a character that rides a bicycle. You want the bicycle to collide with the terrain and the character to collide with the terrain, but you don't want the character to collide with the bicycle (because they must overlap). pybox2d supports such collision filtering using categories and groups.\n\npybox2d supports 16 collision categories. For each fixture you can specify which category it belongs to. You also specify what other categories this fixture can collide with. For example, you could specify in a multiplayer game that all players don't collide with each other and monsters don't collide with each other, but players and monsters should collide. This is done with masking bits. For example:\n\nCollision groups let you specify an integral group index. You can have all fixtures with the same group index always collide (positive index) or never collide (negative index). Group indices are usually used for things that are somehow related, like the parts of a bicycle. In the following example, fixture1 and fixture2 always collide, but fixture3 and fixture4 never collide.\n\nCollisions between fixtures of different group indices are filtered according the category and mask bits. In other words, group filtering has higher precedence than category filtering.\n\nNote that additional collision filtering occurs in Box2D. Here is a list:\n• A fixture on a static body never collides with a fixture on another static body.\n• Fixtures on the same body never collide with each other.\n• You can optionally enable/disable collision between fixtures on bodies connected by a joint.\n\nSometimes you might need to change collision filtering after a fixture has already been created. You can get and set the Filter structure on an existing fixture using the filterData property. Note that changing the filter data will not add or remove contacts until the next time step (see the World class in the C++ source code).\n\nSometimes game logic needs to know when two fixtures overlap yet there should be no collision response. This is done by using sensors. A sensor is a fixture that detects collision but does not produce a response.\n\nYou can flag any fixture as being a sensor. Sensors may be static or dynamic. Remember that you may have multiple fixtures per body and you can have any mix of sensors and solid fixtures.\n\nSensors do not generate contact points. There are two ways to get the state of a sensor, , and during the ContactListener callbacks, BeginContact and EndContact.\n\nBodies have position and velocity. You can apply forces, torques, and impulses to bodies. Bodies can be static, kinematic, or dynamic. Here are the body type definitions:\n\nA static body has does not move under simulation and behaves as if it has infinite mass. Internally, Box2D stores zero for the mass and the inverse mass. Static bodies can be moved manually by the user. A static body has zero velocity. Static bodies do not collide with other static or kinematic bodies.\n\nA kinematic body moves under simulation according to its velocity. Kinematic bodies do not respond to forces. They can be moved manually by the user, but normally a kinematic body is moved by setting its velocity. A kinematic body behaves as if it has infinite mass, however, Box2D stores zero for the mass and the inverse mass. Kinematic bodies do not collide with other static or kinematic bodies.\n\nA dynamic body is fully simulated. They can be moved manually by the user, but normally they move according to forces. A dynamic body can collide with all body types. A dynamic body always has finite, non-zero mass. If you try to set the mass of a dynamic body to zero, it will automatically acquire a mass of one kilogram.\n\nBodies are the backbone for fixtures. Bodies carry fixtures and move them around in the world. Bodies are always rigid bodies in Box2D. That means that two fixtures attached to the same rigid body never move relative to each other.\n\nFixtures have collision geometry and density. Normally, bodies acquire their mass properties from the fixtures. However, you can override the mass properties after a body is constructed. This is discussed below.\n\nYou usually keep pointers to all the bodies you create. This way you can query the body positions to update the positions of your graphical entities. You should also keep body pointers so you can destroy them when you are done with them.\n\nAs mentioned before, before a body is created you have the option of using the kwargs to simplify creation, or manually create a body definition (BodyDef). Regardless of what method you choose, a body definition has to exist to create and initialize a body.\n\nBox2D copies the data out of the body definition; it does not keep a pointer to the body definition. This means you can recycle a body definition to create multiple bodies.\n\nLet's go over some of the key members of the body definition. Please note that all of these can be passed via the kwargs of the create_*_body() functions.\n\nAs discussed at the beginning of this chapter, there are three different body types: static, kinematic, and dynamic. You should establish the body type at creation because changing the body type later is expensive.\n\nThe body definition gives you the chance to initialize the position of the body on creation. This has far better performance than creating the body at the world origin and then moving the body.\n\nA body has two main points of interest. The first point is the body's origin. Fixtures and joints are attached relative to the body's origin. The second point of interest is the center of mass. The center of mass is determined from mass distribution of the attached shapes or is explicitly set with MassData. Much of Box2D's internal computations use the center of mass position. For example Body stores the linear velocity for the center of mass.\n\nWhen you are building the body definition, you may not know where the center of mass is located. Therefore you specify the position of the body's origin. You may also specify the body's angle in radians, which is not affected by the position of the center of mass. If you later change the mass properties of the body, then the center of mass may move on the body, but the origin position does not change and the attached shapes and joints do not move.\n\nDamping is used to reduce the world velocity of bodies. Damping is different than friction because friction only occurs with contact. Damping is not a replacement for friction and the two effects should be used together.\n\nDamping parameters should be between 0 and infinity, with 0 meaning no damping, and infinity meaning full damping. Normally you will use a damping value between 0 and 0.1. I generally do not use linear damping because it makes bodies look floaty.\n\nDamping is approximated for stability and performance. At small damping values the damping effect is mostly independent of the time step. At larger damping values, the damping effect will vary with the time step. This is not an issue if you use a fixed time step (recommended).\n\nWhat does sleep mean? Well it is expensive to simulate bodies, so the less we have to simulate the better. When a body comes to rest we would like to stop simulating it.\n\nWhen Box2D determines that a body (or group of bodies) has come to rest, the body enters a sleep state which has very little CPU overhead. If a body is awake and collides with a sleeping body, then the sleeping body wakes up. Bodies will also wake up if a joint or contact attached to them is destroyed. You can also wake a body manually.\n\nThe body definition lets you specify whether a body can sleep and whether a body is created sleeping.\n\nYou may want a rigid body, such as a character, to have a fixed rotation. Such a body should not rotate, even under load. You can use the fixed rotation setting to achieve this:\n\nThe fixed rotation flag causes the rotational inertia and its inverse to be set to zero.\n\nGame simulation usually generates a sequence of images that are played at some frame rate. This is called discrete simulation. In discrete simulation, rigid bodies can move by a large amount in one time step. If a physics engine doesn't account for the large motion, you may see some objects incorrectly pass through each other. This effect is called tunneling.\n\nBy default, Box2D uses continuous collision detection (CCD) to prevent dynamic bodies from tunneling through static bodies. This is done by sweeping shapes from their old position to their new positions. The engine looks for new collisions during the sweep and computes the time of impact (TOI) for these collisions. Bodies are moved to their first TOI and then halted for the remainder of the time step.\n\nNormally CCD is not used between dynamic bodies. This is done to keep performance reasonable. In some game scenarios you need dynamic bodies to use CCD. For example, you may want to shoot a high speed bullet at a stack of dynamic bricks. Without CCD, the bullet might tunnel through the bricks.\n\nFast moving objects in Box2D can be labeled as bullets. Bullets will perform CCD with both static and dynamic bodies. You should decide what bodies should be bullets based on your game design. If you decide a body should be treated as a bullet, use the following setting.\n\nYou may wish a body to be created but not participate in collision or dynamics. This state is similar to sleeping except the body will not be woken by other bodies and the body's fixtures will not be placed in the broad-phase. This means the body will not participate in collisions, ray casts, etc.\n\nYou can create a body in an inactive state and later re-activate it.\n\nJoints may be connected to inactive bodies. These joints will not be simulated. You should be careful when you activate a body that its joints are not distorted.\n\nuserData gives you a hook to link your application objects to bodies. You should be consistent to use the same object type for all body user data.\n\nBodies are created and destroyed using a body factory provided by the world class. This lets the world create the body with an efficient allocator and add the body to the world data structure.\n\nBodies can be dynamic or static depending on the mass properties. All body types use the same creation and destruction methods.\n\nStatic bodies do not move under the influence of other bodies. You may manually move static bodies, but you should be careful so that you don't squash dynamic bodies between two or more static bodies. Friction will not work correctly if you move a static body. Static bodies never collide with static or kinematic bodies. It is faster to attach several shapes to a static body than to create several static bodies with a single shape on each one. Internally, Box2D sets the mass and inverse mass of static bodies to zero. This makes the math work out so that most algorithms don't need to treat static bodies as a special case.\n\nBox2D does not keep a reference to the body definition or any of the data it holds (except user data). So you can create temporary body definitions and reuse the same body definitions.\n\nAfter creating a body, there are many operations you can perform on the body. These include setting mass properties, accessing position and velocity, applying forces, and transforming points and vectors.\n\nEvery body has a mass (scalar), center of mass (2-vector), and rotational inertia (scalar). For static bodies, the mass and rotational inertia are set to zero. When a body has fixed rotation, its rotational inertia is zero.\n\nNormally the mass properties of a body are established automatically when fixtures are added to the body. You can also adjust the mass of a body at run-time. This is usually done when you have special game scenarios that require altering the mass.\n\nAfter setting a body's mass directly, you may wish to revert to the natural mass dictated by the fixtures. You can do this with:\n\nThe body's mass data is available through the following read-write properties:\n\nThere are many aspects to the body's state. You can access this state data efficiently through the following read-write properties:\n\nYou can access the position and rotation of a body. This is common when rendering your associated game actor. You can also set the position, although this is less common since you will normally use pybox2d to simulate movement.\n\nYou can access the center of mass position in local and world coordinates. Much of the internal simulation in Box2D uses the center of mass. However, you should normally not need to access it. Instead you will usually work with the body transform. For example, you may have a body that is square. The body origin might be a corner of the square, while the center of mass is located at the center of the square.\n\nYou can access the linear and angular velocity. The linear velocity is for the center of mass. Therefore, the linear velocity may change if the mass properties change.\n\nJoints are used to constrain bodies to the world or to each other. Typical examples in games include ragdolls, teeters, and pulleys. Joints can be combined in many different ways to create interesting motions.\n\nSome joints provide limits so you can control the range of motion. Some joint provide motors which can be used to drive the joint at a prescribed speed until a prescribed force/torque is exceeded.\n\nJoint motors can be used in many ways. You can use motors to control position by specifying a joint velocity that is proportional to the difference between the actual and desired position. You can also use motors to simulate joint friction: set the joint velocity to zero and provide a small, but significant maximum motor force/torque. Then the motor will attempt to keep the joint from moving until the load becomes too strong.\n\nEach joint type has a definition that derives from JointDef. All joints are connected between two different bodies. One body may static. Joints between static and/or kinematic bodies are allowed, but have no effect and use some processing time.\n\nYou can specify user data for any joint type and you can provide a flag to prevent the attached bodies from colliding with each other. This is actually the default behavior and you must set the collideConnected Boolean to allow collision between to connected bodies.\n\nMany joint definitions require that you provide some geometric data. Often a joint will be defined by anchor points. These are points fixed in the attached bodies. pybox2d requires these points to be specified in local coordinates. This way the joint can be specified even when the current body transforms violate the joint constraint --- a common occurrence when a game is saved and reloaded. Additionally, some joint definitions need to know the default relative angle between the bodies. This is necessary to constrain rotation correctly.\n\nInitializing the geometric data can be tedious, so many joints have initialization functions and kwargs that use the current body transforms to remove much of the work. However, these initialization functions should usually only be used for prototyping. Production code should define the geometry directly. This will make joint behavior more robust.\n\nThe rest of the joint definition data depends on the joint type. We cover these now.\n\nJoints are created and destroyed using the world factory methods. This brings up an old issue:\n\nHere's an example of the lifetime of a revolute joint:\n\nIt is always good to remove references to joints after they are destroyed. pybox2d ensures that your objects are still valid, but attempting to interact with an already-destroyed joint will raise a RuntimeError.\n\nThis precaution is not always necessary. You may organize your game engine so that joints are always destroyed before the attached bodies. In this case you don't need to implement the listener class.\n\nMany simulations create the joints and don't access them again until they are destroyed. However, there is a lot of useful data contained in joints that you can use to create a rich simulation.\n\nFirst of all, you can get the bodies, anchor points, and user data from a joint.\n\nAll joints have a reaction force and torque. This the reaction force applied to body 2 at the anchor point. You can use reaction forces to break joints or trigger other game events. These functions may do some computations, so don't call them if you don't need the result.\n\nOne of the simplest joint is a distance joint which says that the distance between two points on two bodies must be constant. When you specify a distance joint the two bodies should already be in place. Then you specify the two anchor points in world coordinates. The first anchor point is connected to body 1, and the second anchor point is connected to body 2. These points imply the length of the distance constraint.\n\nHere is an example of a distance joint definition. In this case we decide to allow the bodies to collide.\n\nThe distance joint can also be made soft, like a spring-damper connection. See the Web example in the testbed to see how this behaves.\n\nSoftness is achieved by tuning two constants in the definition: frequency and damping ratio. Think of the frequency as the frequency of a harmonic oscillator (like a guitar string). The frequency is specified in Hertz. Typically the frequency should be less than a half the frequency of the time step. So if you are using a 60Hz time step, the frequency of the distance joint should be less than 30Hz. The reason is related to the Nyquist frequency.\n\nThe damping ratio is non-dimensional and is typically between 0 and 1, but can be larger. At 1, the damping is critical (all oscillations should vanish).\n\nA revolute joint forces two bodies to share a common anchor point, often called a hinge point. The revolute joint has a single degree of freedom: the relative rotation of the two bodies. This is called the joint angle.\n\nTo specify a revolute you need to provide two bodies and a single anchor point in world space. The initialization function assumes that the bodies are already in the correct position.\n\nIn this example, two bodies are connected by a revolute joint at the first body's center of mass.\n\nThe revolute joint angle is positive when body2 rotates CCW about the angle point. Like all angles in pybox2d, the revolute angle is measured in radians. By convention the revolute joint angle is zero when the joint is created using Initialize(), regardless of the current rotation of the two bodies.\n\nIn some cases you might wish to control the joint angle. For this, the revolute joint can optionally simulate a joint limit and/or a motor.\n\nA joint limit forces the joint angle to remain between a lower and upper bound. The limit will apply as much torque as needed to make this happen. The limit range should include zero, otherwise the joint will lurch when the simulation begins.\n\nA joint motor allows you to specify the joint speed (the time derivative of the angle). The speed can be negative or positive. A motor can have infinite force, but this is usually not desirable. Recall the eternal question:\n\n\"What happens when an irresistible force meets an immovable object?\"\n\nI can tell you it's not pretty. So you can provide a maximum torque for the joint motor. The joint motor will maintain the specified speed unless the required torque exceeds the specified maximum. When the maximum torque is exceeded, the joint will slow down and can even reverse.\n\nYou can use a joint motor to simulate joint friction. Just set the joint speed to zero, and set the maximum torque to some small, but significant value. The motor will try to prevent the joint from rotating, but will yield to a significant load.\n\nHere's a revision of the revolute joint definition above; this time the joint has a limit and a motor enabled. The motor is setup to simulate joint friction.\n\nYou can access a revolute joint's angle, speed, and motor torque.\n\nYou also update the motor parameters each step.\n\nJoint motors have some interesting abilities. You can update the joint speed every time step so you can make the joint move back-and-forth like a sine-wave or according to whatever function you want.\n\nYou can also use joint motors to track a desired joint angle. For example:\n\nGenerally your gain parameter should not be too large. Otherwise your joint may become unstable.\n\nA prismatic joint allows for relative translation of two bodies along a specified axis. A prismatic joint prevents relative rotation. Therefore, a prismatic joint has a single degree of freedom.\n\nThe prismatic joint definition is similar to the revolute joint description; just substitute translation for angle and force for torque. Using this analogy provides an example prismatic joint definition with a joint limit and a friction motor:\n\nThe revolute joint has an implicit axis coming out of the screen. The prismatic joint needs an explicit axis parallel to the screen. This axis is fixed in the two bodies and follows their motion.\n\nLike the revolute joint, the prismatic joint translation is zero when the joint is created using Initialize(). So be sure zero is between your lower and upper translation limits.\n\nUsing a prismatic joint is similar to using a revolute joint. Here are the relevant properties:\n\nA pulley is used to create an idealized pulley. The pulley connects two bodies to ground and to each other. As one body goes up, the other goes down. The total length of the pulley rope is conserved according to the initial configuration.\n\nYou can supply a ratio that simulates a block and tackle. This causes one side of the pulley to extend faster than the other. At the same time the constraint force is smaller on one side than the other. You can use this to create mechanical leverage.\n\nFor example, if the ratio is 2, then length1 will vary at twice the rate of length2. Also the force in the rope attached to body1 will have half the constraint force as the rope attached to body2.\n\nPulleys can be troublesome when one side is fully extended. The rope on the other side will have zero length. At this point the constraint equations become singular (bad). Therefore the pulley joint constrains the maximum length that either side can attain. Also, you may want to control the maximum lengths for game play reasons. So the maximum lengths improve stability and give you more control.\n\nHere is an example pulley definition:\n\nIf you want to create a sophisticated mechanical contraption you might want to use gears. In principle you can create gears in pybox2d by using compound shapes to model gear teeth. This is not very efficient and might be tedious to author. You also have to be careful to line up the gears so the teeth mesh smoothly. pybox2d has a simpler method of creating gears: the gear joint.\n\nThe gear joint requires that you have two bodies connected to ground by a revolute or prismatic joint. You can use any combination of those joint types. Also, Box2D requires that the revolute and prismatic joints were created with the ground as body1.\n\nLike the pulley ratio, you can specify a gear ratio. However, in this case the gear ratio can be negative. Also keep in mind that when one joint is a revolute joint (angular) and the other joint is prismatic (translation), and then the gear ratio will have units of length or one over length.\n\nHere is an example gear joint:\n\nNote that the gear joint depends on two other joints. This creates a fragile situation. What happens if those joints are deleted?\n\nThe mouse joint is used in the testbed to manipulate bodies with the mouse. It attempts to drive a point on a body towards the current position of the cursor. There is no restriction on rotation.\n\nThe mouse joint definition has a target point, maximum force, frequency, and damping ratio. The target point initially coincides with the body's anchor point. The maximum force is used to prevent violent reactions when multiple dynamic bodies interact. You can make this as large as you like. The frequency and damping ratio are used to create a spring/damper effect similar to the distance joint.\n\nMany users have tried to adapt the mouse joint for game play. Users often want to achieve precise positioning and instantaneous response. The mouse joint doesn't work very well in that context. You may wish to consider using kinematic bodies instead.\n\nThe line joint is like the prismatic joint with the rotation restriction removed. This was requested by a user to model a vehicle wheel with a suspension.\n\nAs such, the initialization is very similar to the prismatic joint. Use introspection to find out more about it.\n\nThe weld joint attempts to constrain all relative motion between two bodies. See the Cantilever demo in the testbed to see how the weld joint behaves.\n\nIt is tempting to use the weld joint to define breakable structures. However, the Box2D solver is iterative so the joints are a bit soft. So chains of bodies connected by weld joints will flex.\n\nInstead it is better to create breakable bodies starting with a single body with multiple fixtures. When the body breaks, you can destroy a fixture and recreate it on a new body. See the Breakable example in the testbed.\n\nContacts are objects created by Box2D to manage collision between fixtures. There are different kinds of contacts, derived from Contact, for managing contact between different kinds of fixtures. For example there is a contact class for managing polygon-polygon collision and another contact class for managing circle-circle collision.\n\nHere is some terminology associated with contacts.\n\nA contact point is a point where two shapes touch. Box2D approximates contact with a small number of points.\n\nA contact normal is a unit vector that points from one shape to another. By convention, the normal points from fixtureA to fixtureB.\n\nSeparation is the opposite of penetration. Separation is negative when shapes overlap. It is possible that future versions of Box2D will create contact points with positive separation, so you may want to check the sign when contact points are reported.\n\nContact between two convex polygons may generate up to 2 contact points. Both of these points use the same normal, so they are grouped into a contact manifold, which is an approximation of a continuous region of contact.\n\nThe normal force is the force applied at a contact point to prevent the shapes from penetrating. For convenience, Box2D works with impulses. The normal impulse is just the normal force multiplied by the time step.\n\nThe tangent force is generated at a contact point to simulate friction. For convenience, this is stored as an impulse.\n\nBox2D tries to re-use the contact force results from a time step as the initial guess for the next time step. Box2D uses contact ids to match contact points across time steps. The ids contain geometric features indices that help to distinguish one contact point from another.\n\nContacts are created when two fixtures AABBs overlap. Sometimes collision filtering will prevent the creation of contacts. Contacts are destroyed with the AABBs cease to overlap.\n\nSo you might gather that there may be contacts created for fixtures that are not touching (just their AABBs). Well, this is correct. It's a \"chicken or egg\" problem. We don't know if we need a contact object until one is created to analyze the collision. We could delete the contact right away if the shapes are not touching, or we can just wait until the AABBs stop overlapping. Box2D takes the latter approach because it lets the system cache information to improve performance.\n\nAs mentioned before, the contact class is created and destroyed by Box2D. Contact objects are not created by the user. However, you are able to access the contact class and interact with it.\n\nYou can access the raw contact manifold or the world manifold: .\n\nThe latter uses the current positions of the bodies to compute world positions of the contact points. You can potentially modify the manifold, but this is generally not supported and is for advanced usage.\n\nSensors do not create manifolds, so for them use:\n\nThis function also works for non-sensors.\n\nYou can get the fixtures from a contact. From those you can get the bodies.\n\nYou can disable a contact. This only works inside the PreSolve event, discussed below.\n\nYou can get access to contacts in several ways. You can access the contacts directly on the world and body structures. You can also implement a contact listener.\n\nYou can iterate over all contacts in the world:\n\nYou can also iterate over all the contacts on a body. These are stored in a graph using a contact edge structure.\n\nYou can also access contacts using the contact listener that is described below.\n\nThis is called when two fixtures begin to overlap. This is called for sensors and non-sensors. This event can only occur inside the time step.\n\nThis is called when two fixtures cease to overlap. This is called for sensors and non-sensors. This may be called when a body is destroyed, so this event can occur outside the time step.\n\nThis is called after collision detection, but before collision resolution. This gives you a chance to disable the contact based on the current configuration. For example, you can implement a one-sided platform using this callback and setting Contact.enabled=False. The contact will be re-enabled each time through collision processing, so you will need to disable the contact every time-step. The pre-solve event may be fired multiple times per time step per contact due to continuous collision detection.\n\nThe pre-solve event is also a good place to determine the point state and the approach velocity of collisions.\n\nThe post solve event is where you can gather collision impulse results. If you don't care about the impulses, you should probably just implement the pre-solve event.\n\nIt is tempting to implement game logic that alters the physics world inside a contact callback. For example, you may have a collision that applies damage and try to destroy the associated actor and its rigid body. However, pybox2d does not allow you to alter the physics world inside a callback because you might destroy objects that Box2D is currently processing, leading to orphaned pointers (which is not a good thing).\n\nThe recommended practice for processing contact points is to buffer all contact data that you care about and process it after the time step. You should always process the contact points immediately after the time step; otherwise some other client code might alter the physics world, invalidating the contact buffer. When you process the contact buffer you can alter the physics world, but you still need to be careful that you don't orphan pointers stored in the contact point buffer. The testbed has example contact point processing that is safe from orphaned pointers.\n\nThis code from the CollisionProcessing test shows how to handle orphaned bodies when processing the contact buffer. Here is an excerpt. Be sure to read the comments in the listing. This code assumes that all contact points have been buffered in the ContactPoint array.\n\nOften in a game you don't want all objects to collide. For example, you may want to create a door that only certain characters can pass through. This is called contact filtering, because some interactions are filtered out.\n\npybox2d allows you to achieve custom contact filtering by implementing a ContactFilter class. This class requires you to implement a ShouldCollide function that receives two Shapes. Your function returns True if the shapes should collide.\n\nThe default implementation of ShouldCollide uses the FilterData defined in [[Fixtures]].\n\nAt run-time you can create an instance of your contact filter and register it with World.contact_filter. The world will hold a reference to your contact filter, so it is unnecessary to keep your own copy.\n\nThe World class contains the bodies and joints. It manages all aspects of the simulation and allows for asynchronous queries (like AABB queries and ray-casts). Much of your interactions with pybox2d will be with a World object.\n\nCreating a world is fairly simple. You can to provide a gravity vector and a Boolean indicating if bodies can sleep. The defaults of (0, -10) and allowing sleep will be used if neither are specified.\n\nThe world class contains factories for creating and destroying bodies and joints. These factories are discussed later in the sections on bodies and joints. There are some other interactions with World that I will cover now.\n\nThe world class is used to drive the simulation. You specify a time step and a velocity and position iteration count. For example:\n\nAfter the time step you can examine your bodies and joints for information. Most likely you will grab the position off the bodies so that you can update your actors and render them. You can perform the time step anywhere in your game loop, but you should be aware of the order of things. For example, you must create bodies before the time step if you want to get collision results for the new bodies in that frame.\n\nAs I discussed above in the HelloWorld tutorial, you should use a fixed time step. By using a larger time step you can improve performance in low frame rate scenarios. But generally you should use a time step no larger than 1/30 seconds. A time step of 1/60 seconds will usually deliver a high quality simulation.\n\nThe iteration count controls how many times the constraint solver sweeps over all the contacts and joints in the world. More iteration always yields a better simulation. But don't trade a small time step for a large iteration count. 60Hz and 10 iterations is far better than 30Hz and 20 iterations.\n\nAfter stepping, you should clear any forces you have applied to your bodies. This is done with the command World.clear_forces. This lets you take multiple sub-steps with the same force field.\n\nThe world is a container for bodies, contacts, and joints. You can grab the body, contact, and joint lists off the world and iterate over them. For example, this code wakes up all the bodies in the world:\n\nOr browse through the rest with:\n\nSometimes you want to determine all the shapes in a region. The World class has a fast log(N) method for this using the broad-phase data structure. You provide an AABB in world coordinates and an implementation of QueryCallback. The world calls your class with each fixture whose AABB overlaps the query AABB. Return True to continue the query, otherwise return False. For example, the following code finds all the fixtures that potentially intersect a specified AABB and wakes up all of the associated bodies.\n\nYou cannot make any assumptions about the order of the callbacks.\n\nYou can use ray casts to do line-of-site checks, fire guns, etc. You perform a ray cast by implementing a callback class and providing the start and end points. The world class calls your class with each fixture hit by the ray. Your callback is provided with the fixture, the point of intersection, the unit normal vector, and the fractional distance along the ray. You cannot make any assumptions about the order of the callbacks.\n\nYou control the continuation of the ray cast by returning a fraction. Returning a fraction of zero indicates the ray cast should be terminated. A fraction of one indicates the ray cast should continue as if no hit occurred. If you return the fraction from the argument list, the ray will be clipped to the current intersection point. So you can ray cast any shape, ray cast all shapes, or ray cast the closest shape by returning the appropriate fraction.\n\nYou may also return of fraction of -1 to filter the fixture. Then the ray cast will proceed as if the fixture does not exist.\n\nHere is an example:\n\nYou can apply forces, torques, and impulses to a body. When you apply a force or an impulse, you provide a world point where the load is applied. This often results in a torque about the center of mass.\n\nApplying a force, torque, or impulse wakes the body. Sometimes this is undesirable. For example, you may be applying a steady force and want to allow the body to sleep to improve performance. In this case you can use the following code.\n\nThe body class has some utility functions to help you transform points and vectors between local and world space. If you don't understand these concepts, please read \"Essential Mathematics for Games and Interactive Applications\" by Jim Van Verth and Lars Bishop. These functions are efficient (when inlined).\n\nYou can iterate over a body's fixtures. This is mainly useful if you need to access the fixture's user data.\n\nYou can similarly iterate over the body's joint list.\n\nThe body also provides a list of associated contacts. You can use this to get information about the current contacts. Be careful, because the contact list may not contain all the contacts that existed during the previous time step.\n\nIf you destroy a Box2D entity, it is up to you to make sure you remove all references to the destroyed object. This is easy if you only have a single reference to the entity.\n\nOften when using pybox2d you will create and destroy many bodies, shapes, and joints. Managing these entities is somewhat automated by Box2D. If you destroy a body then all associated shapes and joints are automatically destroyed. This is called implicit destruction.\n\nWhen you destroy a body, all its attached shapes, joints, and contacts are destroyed. This is called implicit destruction. Any body connected to one of those joints and/or contacts is woken. This process is usually convenient. However, you must be aware of one crucial issue:\n\nTo help you nullify your joint pointers, Box2D provides a listener class named WorldListener that you can implement and provide to your world object. Then the world object will notify you when a joint is going to be implicitly destroyed.\n\nImplicit destruction is a great convenience in many cases. It can also make your program fall apart. You may store pointers to shapes and joints somewhere in your code. These pointers become orphaned when an associated body is destroyed. The situation becomes worse when you consider that joints are often created by a part of the code unrelated to management of the associated body. For example, the testbed creates a MouseJoint for interactive manipulation of bodies on the screen.\n\nBox2D provides a callback mechanism to inform your application when implicit destruction occurs. This gives your application a chance to do some cleanup.\n\nBox2D uses several approximations to simulate rigid body physics efficiently. This brings some limitations.\n\nHere are the current limitations:\n• Stacking heavy bodies on top of much lighter bodies is not stable. Stability degrades as the mass ratio passes 10:1.\n• Polygons may not slide smoothly over chains of edge shapes or other polygon shapes that are aligned. For this reason, tile-based environments may not have smooth collision with box-like characters. This problem will be addressed in the future.\n• Chains of bodies connected by joints may stretch if a lighter body is supporting a heavier body. For example, a wrecking ball connect to a chain of light weight bodies may not be stable. Stability degrades as the mass ratio passes 10:1.\n• There is typically around 0.5cm of slop in shape versus shape collision.\n• Continuous collision is processed sequentially. In a time of impact event, the body is moved back and held there for the rest of the time step. This may make fast moving objects appear to move in a non-smooth manner.\n\nThe C++ header file b2Settings.h, which is in the pybox2d source distribution, contains:\n\nPlease note that the average user should NOT need to worry about this. It is left in here for completeness.\n\npybox2d defines several constants. These are all documented in b2Settings.h. Normally you do not need to adjust these constants, as this requires rebuilding the library from the source code in order to use. Also, this will make your library incompatible with the main pybox2d release. If you are creating your own binaries for your intended audience, this may not be an issue, but it is looked down upon for open source releases.\n\npybox2d uses floating point math for collision and simulation. Due to round-off error some numerical tolerances are defined. Some tolerances are absolute and some are relative. Absolute tolerances use MKS units.\n\nThe pybox2d version number is accessible from , and the internal Box2D version can be determined from .\n\nThese are placed in the settings file in case you need to customize them for your application.\n\nA large number of the decisions about the design of Box2D were based on the need for quick and efficient use of memory. In this section I will discuss how and why Box2D allocates memory.\n\nBox2D tends to allocate a large number of small objects (around 50-300 bytes). Using the system heap through malloc or new for small objects is inefficient and can cause fragmentation. Many of these small objects may have a short life span, such as contacts, but can persist for several time steps. So we need an allocator that can efficiently provide heap memory for these objects.\n\nBox2D's solution is to use a small object allocator (SOA) called BlockAllocator. The SOA keeps a number of growable pools of varying sizes. When a request is made for memory, the SOA returns a block of memory that best fits the requested size. When a block is freed, it is returned to the pool. Both of these operations are fast and cause little heap traffic.\n\nWhile executing a time step, Box2D needs some temporary workspace memory. For this, it uses a stack allocator called StackAllocator to avoid per-step heap allocations. You don't need to interact with the stack allocator, but it's good to know it's there.\n\nCopyright (C) 2007-2011 Erin Catto Converted and modified for pybox2d"
    },
    {
        "link": "https://code.google.com/archive/p/pybox2d/wikis/GettingStartedManual.wiki",
        "document": "The Google Code Archive requires JavaScript to be enabled in your browser."
    },
    {
        "link": "https://box2d.org/documentation/md_collision.html",
        "document": "Box2D provides geometric types and functions. These include:\n\nThe collision interface is designed to be usable outside of rigid body simulation. For example, you can use the dynamic tree for other aspects of your game besides physics.\n\nHowever, the main purpose of Box2D is to be a rigid body physics engine. So the collision interface only contains features that are also useful in the physics simulation.\n\nShape primitives describe collision geometry and may be used independently of physics simulation. At a minimum, you should understand how to create primitives that can be later attached to rigid bodies.\n• Test a point for overlap with the primitive\n• Compute the mass properties of the primitive\n\nCircles have a center and radius. Circles are solid.\n\nYou can also initialize a circle and other structures inline. This is an equivalent circle:\n\nCapsules have two center points and a radius. The center points are the centers of two semicircles that are connected by a rectangle.\n\nBox2D polygons are solid convex polygons. A polygon is convex when all line segments connecting two points in the interior do not cross any edge of the polygon. Polygons are solid and never hollow. A polygon must have 3 or more vertices.\n\nPolygons vertices are stored with a counter clockwise winding (CCW). We must be careful because the notion of CCW is with respect to a right-handed coordinate system with the z-axis pointing out of the plane. This might turn out to be clockwise on your screen, depending on your coordinate system conventions.\n\nThe polygon members are public, but you should use initialization functions to create a polygon. The initialization functions create normal vectors and perform validation.\n\nPolygons in Box2D have a maximum of 8 vertices, as controlled by b2_maxPolygonVertices. If you have more complex shapes, I recommend to use multiple polygons.\n\nThere are a few ways to create polygons. You can attempt to create them manually, but this is not recommended. Instead there are several functions provided to create them.\n\nFor example if you need a square or box you can use these functions:\n\nThe values provided to these functions are extents, which are half-widths or half-heights. This corresponds with circles and capsules using radii instead of diameters.\n\nBox2D also supports rounded polygons. These are convex polygons with a thick rounded skin.\n\nIf you want a box that is not centered on the body origin, you can use an offset box.\n\nIf you want a more general convex polygon, you can compute the hull using . Then you can create a polygon from the hull. You can make this rounded or not.\n\nIf you have an automatic process for generating convex polygons, you may feed a degenerate set of points to . You should check that the hull was created successfully before creating the polygon or you will get an assertion.\n\nDegenerate points may be coincident and/or collinear. For the hull to be viable, the enclosed area must be sufficiently positive.\n\nSegments are line segments. Segment shapes can collide with circles, capsules, and polygons but not with other line segments. The collision algorithms used by Box2D require that at least one of two colliding shapes has sufficiently positive area. Segment shapes have no area, so segment-segment collision is not possible.\n\nIn many cases a game environment is constructed by connecting several segment shapes end-to-end. This can give rise to an unexpected artifact when a polygon slides along the chain of segments. In the figure below there is a box colliding with an internal vertex. These ghost collisions are caused when the polygon collides with an internal vertex generating an internal collision normal.\n\nIf edge1 did not exist this collision would seem fine. With edge1 present, the internal collision seems like a bug. But normally when Box2D collides two shapes, it views them in isolation.\n\nprovides a mechanism for eliminating ghost collisions by storing the adjacent ghost vertices. Box2D uses these ghost vertices to prevent internal collisions.\n\nThe Box2D algorithm for dealing with ghost collisions only supports one-sided collision. The front face is to the right when looking from the first vertex towards the second vertex. This matches the counter-clockwise winding order used by polygons.\n\nChain segments use a concept called ghost vertices that Box2D can use to eliminate ghost collisions.\n\nThese ghost vertices must align with vertices of neighboring chain segments, making them tedious and error-prone to setup.\n\nChain segments are not created directly. Instead, you can create chains of line segments. See and .\n\nYou can perform a geometric queries on a single shape.\n\nYou can test a point for overlap with a shape. You provide a transform for the shape and a world point.\n\nSee also and .\n\nYou can cast a ray at a shape to get the point of first intersection and normal vector.\n\nYou can also cast a shape at another shape. This uses an abstract way of describing the moving shape. It is represented as a point cloud with a radius. This implies a convex shape even if the input data is not convex. The internal algorithm (GJK) will essentially only use the convex portion.\n\nEven more generic, you can use to linearly cast one point cloud at another point cloud. All shape cast functions use this internally.\n\nfunction can be used to compute the distance between two shapes. The distance function needs both shapes to be converted into a (which are point clouds with radii). There is also some caching used to warm start the distance function for repeated calls. This can improve performance when the shapes move by small amounts.\n\nIf two shapes are moving fast, they may tunnel through each other in a single time step.\n\nThe function is used to determine the time when two moving shapes collide. This is called the time of impact (TOI). The main purpose of is for tunnel prevention. Box2D uses this internally to prevent moving objects from tunneling through static shapes.\n\nThe identifies an initial separating axis and ensures the shapes do not cross on that axis. This process is repeated as shapes are moved closer together, until they touch or pass by each other.\n\nThe TOI function might miss collisions that are clear at the final positions. Nevertheless, it is very fast and adequate for tunnel prevention.\n\nIt is difficult to put a restriction on the rotation magnitude. There may be cases where collisions are missed for small rotations. Normally, these missed rotational collisions should not harm game play. They tend to be glancing collisions.\n\nThe function requires two shapes (converted to ) and two structures. The sweep structure defines the initial and final transforms of the shapes.\n\nYou can use fixed rotations to perform a shape cast. In this case, the time of impact function will not miss any collisions.\n\nBox2D has functions to compute contact points for overlapping shapes. If we consider circle-circle or circle-polygon, we can only get one contact point and normal. In the case of polygon-polygon we can get two points. These points share the same normal vector so Box2D groups them into a manifold structure. The contact solver takes advantage of this to improve stacking stability.\n\nNormally you don't need to compute contact manifolds directly, however you will likely use the results produced in the simulation.\n\nThe structure holds a normal vector and up to two contact points. The contact points store the normal and tangential (friction) impulses computed in the rigid body simulation.\n\nis used by Box2D to organize large numbers of shapes efficiently. The object does not know directly about shapes. Instead it operates on axis-aligned bounding boxes ( ) with user data integers.\n\nThe dynamic tree is a hierarchical AABB tree. Each internal node in the tree has two children. A leaf node is a single user AABB. The tree uses rotations to keep the tree balanced, even in the case of degenerate input.\n\nThe tree structure allows for efficient ray casts and region queries. For example, you may have hundreds of shapes in your scene. You could perform a ray cast against the scene in a brute force manner by ray casting each shape. This would be inefficient because it does not take advantage of shapes being spread out. Instead, you can maintain a dynamic tree and perform ray casts against the tree. This traverses the ray through the tree skipping large numbers of shapes.\n\nA region query uses the tree to find all leaf AABBs that overlap a query AABB. This is faster than a brute force approach because many shapes can be skipped.\n\nNormally you will not use the dynamic tree directly. Rather you will go through the functions for ray casts and region queries. If you plan to instantiate your own dynamic tree, you can learn how to use it by looking at how Box2D uses it. Also see the sample."
    }
]