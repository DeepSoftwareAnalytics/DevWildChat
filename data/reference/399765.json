[
    {
        "link": "https://learn.microsoft.com/en-us/sql/t-sql/language-elements/execute-transact-sql?view=sql-server-ver16",
        "document": "Applies to: SQL Server Azure SQL Database Azure SQL Managed Instance Azure Synapse Analytics Analytics Platform System (PDW) SQL analytics endpoint in Microsoft Fabric Warehouse in Microsoft Fabric SQL database in Microsoft Fabric\n\nExecutes a command string or character string within a Transact-SQL batch, or one of the following modules: system stored procedure, user-defined stored procedure, CLR stored procedure, scalar-valued user-defined function, or extended stored procedure. The or statement can be used to send pass-through commands to linked servers. Additionally, the context in which a string or command is executed can be explicitly set. Metadata for the result set can be defined by using the options.\n\nAn optional integer variable that stores the return status of a module. This variable must be declared in the batch, stored procedure, or function before it's used in an statement.\n\nWhen used to invoke a scalar-valued user-defined function, the @return_status variable can be of any scalar data type.\n\nThe fully qualified or nonfully qualified name of the stored procedure or scalar-valued user-defined function to call. Module names must comply with the rules for identifiers. The names of extended stored procedures are always case-sensitive, regardless of the collation of the server.\n\nA module that was created in another database can be executed if the user running the module owns the module, or has the appropriate permission to execute it in that database. A module can be executed on another server running SQL Server if the user running the module has the appropriate permission to use that server (remote access) and to execute the module in that database. If a server name is specified but no database name is specified, the SQL Server Database Engine looks for the module in the default database of the user.\n\nAn optional integer that is used to group procedures of the same name. This parameter isn't used for extended stored procedures.\n\nFor more information about procedure groups, see CREATE PROCEDURE.\n\nThe name of a locally defined variable that represents a module name.\n\nThis can be a variable that holds the name of a natively compiled, scalar user-defined function.\n\nThe parameter for module_name, as defined in the module. Parameter names must be preceded by the at sign ( ). When used with the @parameter_name = value form, parameter names and constants don't have to be supplied in the order in which they're defined in the module. However, if the @parameter_name = value form is used for any parameter, it must be used for all subsequent parameters.\n\nThe value of the parameter to pass to the module or pass-through command. If parameter names aren't specified, parameter values must be supplied in the order defined in the module.\n\nWhen executing pass-through commands against linked servers, the order of the parameter values depends on the OLE DB provider of the linked server. Most OLE DB providers bind values to parameters from left to right.\n\nIf the value of a parameter is an object name, character string, or qualified by a database name or schema name, the whole name must be enclosed in single quotation marks. If the value of a parameter is a keyword, the keyword must be enclosed in double quotation marks.\n\nIf you pass a single word that doesn't begin with , that isn't enclosed in quotation marks (for example, if you forget on a parameter name), the word is treated as an nvarchar string, in spite of the missing quotation marks.\n\nIf a default is defined in the module, a user can execute the module without specifying a parameter.\n\nThe default can also be . Generally, the module definition specifies the action that should be taken if a parameter value is .\n\nThe variable that stores a parameter or a return parameter.\n\nSpecifies that the module or command string returns a parameter. The matching parameter in the module or command string must also have been created by using the keyword . Use this keyword when you use cursor variables as parameters.\n\nIf value is defined as of a module executed against a linked server, any changes to the corresponding @parameter performed by the OLE DB provider are copied back to the variable at the end of the execution of module.\n\nIf parameters are being used and the intent is to use the return values in other statements within the calling batch or module, the value of the parameter must be passed as a variable, such as @parameter = @variable. You can't execute a module by specifying for a parameter that isn't defined as an parameter in the module. Constants can't be passed to module by using ; the return parameter requires a variable name. The data type of the variable must be declared and a value assigned before executing the procedure.\n\nWhen is used against a remote stored procedure, or to execute a pass-through command against a linked server, parameters can't be any one of the large object (LOB) data types.\n\nReturn parameters can be of any data type except the LOB data types.\n\nSupplies the default value of the parameter as defined in the module. When the module expects a value for a parameter that doesn't have a defined default and either a parameter is missing or the keyword is specified, an error occurs.\n\nThe name of a local variable. @string_variable can be any char, varchar, nchar, or nvarchar data type. These include the (max) data types.\n\nA constant string. tsql_string can be any nvarchar or varchar data type. If the is included, the string is interpreted as nvarchar data type.\n\nSpecifies the context in which the statement is executed.\n\nSpecifies the context to be impersonated is a login. The scope of impersonation is the server.\n\nSpecifies the context to be impersonated is a user in the current database. The scope of impersonation is restricted to the current database. A context switch to a database user doesn't inherit the server-level permissions of that user.\n\nA valid user or login name. The name argument must be a member of the sysadmin fixed server role or exist as a principal in sys.database_principals or sys.server_principals, respectively.\n\nThis argument can't be a built-in account, such as , , or .\n\nFor more information, see Specifying a User or Login Name later in this article.\n\nA constant string that contains the command to be passed through to the linked server. If the is included, the string is interpreted as nvarchar data type.\n\nIndicates parameters for which values are supplied in the of pass-through commands that are used in an statement.\n\nSpecifies that command_string is executed against linked_server_name and results, if any, are returned to the client. linked_server_name must refer to an existing linked server definition in the local server. Linked servers are defined by using sp_addlinkedserver.\n• Possible execute options. The options can't be specified in an statement.\n\nApplies to: SQL Server 2019 (15.x) and later versions.\n\nSpecifies that command_string is executed against data_source_name and results, if any, are returned to the client. data_source_name must refer to an existing definition in the database. Only data sources that point to SQL Server are supported. Additionally, for SQL Server Big Data Cluster data sources that point to compute pool, data pool or storage pool are supported. Data sources are defined by using CREATE EXTERNAL DATA SOURCE.\n• Possible execute options. The options can't be specified in an statement. Forces a new plan to be compiled, used, and discarded after the module is executed. If there's an existing query plan for the module, this plan remains in the cache.\n\n\n\nUse this option if the parameter you're supplying is atypical or if the data has significantly changed. This option isn't used for extended stored procedures. We recommend that you use this option sparingly because it's expensive.\n\n\n\nNote: You can't use when calling a stored procedure that uses syntax. The option is ignored when a four-part object name is specified.\n\n\n\nNote: isn't supported with natively compiled, scalar user-defined functions. If you need to recompile, use sp_recompile. This option provides no guarantee of what results, if any, are returned, and no definition is provided. The statement executes without error if any results are returned or no results are returned. is the default behavior if a result_sets_option isn't provided.\n\n\n\nFor interpreted scalar user-defined functions, and natively compiled scalar user-defined functions, this option isn't operational because the functions never return a result set.\n\n\n\nApplies to: SQL Server 2012 (11.x) and later versions, and Azure SQL Database. Guarantees that the statement doesn't return any results. If any results are returned the batch is aborted.\n\n\n\nFor interpreted scalar user-defined functions, and natively compiled scalar user-defined functions, this option isn't operational because the functions never return a result set.\n\n\n\nApplies to: SQL Server 2012 (11.x) and later versions, and Azure SQL Database. Provides a guarantee that the result comes back as specified in the . For statements that return multiple result sets, provide multiple result_sets_definition sections. Enclose each result_sets_definition in parentheses, separated by commas. For more information, see later in this article.\n\n\n\nThis option always results in an error for natively compiled, scalar user-defined functions because the functions never return a result set.\n\n\n\nApplies to: SQL Server 2012 (11.x) and later versions, and Azure SQL Database. describes the result sets returned by the executed statements. The clauses of the have the following meaning: See the following table. The name of the database containing the table, view, or table valued function. The name of the schema owning the table, view, or table valued function. Specifies that the columns returned are those specified in the table, view, or table valued function named. Table variables, temporary tables, and synonyms aren't supported in the AS object syntax. Specifies that the columns returned are those specified in the table type. Specifies that the XML results from the statement or stored procedure called by the statement are converted into the format as though they were produced by a statement. All formatting from the type directives in the original statement is removed, and the results returned are as though no type directive was specified. AS FOR XML doesn't convert non-XML tabular results from the executed statement or stored procedure into XML. The names of each column. If the number of columns differs from the result set, an error occurs and the batch is aborted. If the name of a column differs from the result set, the column name returned will be set to the name defined. The data types of each column. If the data types differ, an implicit conversion to the defined data type is performed. If the conversion fails the batch is aborted The collation of each column. If there's a collation mismatch, an implicit collation is attempted. If that fails, the batch is aborted. The nullability of each column. If the defined nullability is and the data returned contains nulls, an error occurs and the batch is aborted. If not specified, the default value conforms to the setting of the and options. The actual result set being returned during execution can differ from the result defined using the clause in one of the following ways: number of result sets, number of columns, column name, nullability, and data type. If the number of result sets differs, an error occurs and the batch is aborted.\n\nParameters can be supplied either by using value or by using @parameter_name = value. A parameter isn't part of a transaction; therefore, if a parameter is changed in a transaction that is later rolled back, the value of the parameter doesn't revert to its previous value. The value returned to the caller is always the value at the time the module returns.\n\nNesting occurs when one module calls another or executes managed code by referencing a common language runtime (CLR) module, user-defined type, or aggregate. The nesting level increments when the called module or managed code reference starts execution, and decrements when the called module or managed code reference finishes. Exceeding the maximum of 32 nesting levels causes the complete calling chain to fail. The current nesting level is stored in the system function.\n\nBecause remote stored procedures and extended stored procedures aren't within the scope of a transaction (unless issued within a statement or when used with various configuration options), commands executed through calls to them can't be rolled back. For more information, see System stored procedures and BEGIN DISTRIBUTED TRANSACTION.\n\nWhen you use cursor variables, if you execute a procedure that passes in a cursor variable with a cursor allocated to it, an error occurs.\n\nYou don't have to specify the keyword when executing modules if the statement is the first one in a batch.\n\nFor more information specific to CLR stored procedures, see CLR Stored Procedures.\n\nYou don't have to specify the keyword when you execute stored procedures when the statement is the first one in a batch.\n\nSQL Server system stored procedures start with the characters . They are physically stored in the Resource Database, but logically appear in the sys schema of every system and user-defined database. When you execute a system stored procedure, either in a batch or inside a module such as a user-defined stored procedure or function, we recommend that you qualify the stored procedure name with the sys schema name.\n\nSQL Server system extended stored procedures start with the characters , and these are contained in the dbo schema of the database. When you execute a system extended stored procedure, either in a batch or inside a module such as a user-defined stored procedure or function, we recommend that you qualify the stored procedure name with .\n\nWhen you execute a user-defined stored procedure, either in a batch or inside a module such as a user-defined stored procedure or function, we recommend that you qualify the stored procedure name with a schema name. We don't recommend that you name a user-defined stored procedure with the same name as a system stored procedure. For more information about executing stored procedures, see Execute a stored procedure.\n\nIn SQL Server, the varchar(max) and nvarchar(max) data types can be specified that allow for character strings to be up to 2 gigabytes of data.\n\nChanges in database context last only until the end of the statement. For example, after the in this following statement is run, the database context is .\n\nYou can use the clause to switch the execution context of a dynamic statement. When the context switch is specified as , the duration of the context switch is limited to the scope of the query being executed.\n\nSpecify a user or login name\n\nThe user or login name specified in must exist as a principal in or respectively, or the statement fails. Additionally, permissions must be granted on the principal. Unless the caller is the database owner or is a member of the sysadmin fixed server role, the principal must exist even when the user is accessing the database or instance of SQL Server through a Windows group membership. For example, assume the following conditions:\n• None group has access to the database.\n• None is a member of and, therefore, has implicit access to the database.\n\nAlthough has access to the database through membership in the group, the statement fails because doesn't exist as a principal in the database.\n\nSpecify a login or user that has the least privileges required to perform the operations that are defined in the statement or module. For example, don't specify a login name, which has server-level permissions, if only database-level permissions are required. Or, don't specify a database owner account unless those permissions are required.\n\nPermissions aren't required to run the statement. However, permissions are required on the securables that are referenced within the string. For example, if the string contains an statement, the caller of the statement must have permission on the target table. Permissions are checked at the time statement is encountered, even if the statement is included within a module.\n\npermissions for a module default to the owner of the module, who can transfer them to other users. When a module is run that executes a string, permissions are checked in the context of the user who executes the module, not in the context of the user who created the module. However, if the same user owns the calling module and the module being called, permission checking isn't performed for the second module.\n\nIf the module accesses other database objects, execution succeeds when you have permission on the module and one of the following conditions is true:\n• None The module is marked or , and the module owner has the corresponding permissions on the referenced object. For more information about impersonation within a module, see EXECUTE AS clause.\n• None The module is marked , and you have the corresponding permissions on the object.\n• None The module is marked , and has the corresponding permissions on the object.\n\nTo specify on a login, the caller must have permissions on the specified login name. To specify on a database user, the caller must have permissions on the specified user name. When no execution context is specified, or is specified, permissions aren't required.\n\nThe code samples in this article use the or sample database, which you can download from the Microsoft SQL Server Samples and Community Projects home page.\n\nThe stored procedure in the AdventureWorks2022 database expects one parameter ( ). The following examples execute the stored procedure with as its parameter value.\n\nThe variable can be explicitly named in the execution:\n\nIf the following is the first statement in a batch or a sqlcmd script, isn't required.\n\nThe following example executes the stored procedure in the AdventureWorks2022 database. It passes two parameters: the first parameter is a product ID ( ) and the second parameter is a datetime value.\n\nC. Use EXECUTE 'tsql_string' with a variable\n\nThe following example shows how handles dynamically built strings that contain variables. This example creates the cursor to hold a list of all user-defined tables in the database, and then uses that list to rebuild all indexes on the tables.\n\nThe following example executes the stored procedure on the remote server and stores the return status that indicates success or failure in .\n\nThe following example creates a variable that represents a stored procedure name.\n\nThe following example creates a stored procedure with default values for the first and third parameters. When the procedure is run, these defaults are inserted for the first and third parameters when no value is passed in the call or when the default is specified. Note the various ways the keyword can be used.\n\nThe stored procedure can be executed in many combinations.\n\nG. Use EXECUTE with AT linked_server_name\n\nThe following example passes a command string to a remote server. It creates a linked server that points to another instance of SQL Server and executes a DDL statement ( ) against that linked server.\n\nThe following example executes the stored procedure and forces a new query plan to be compiled, used, and discarded after the module is executed.\n\nThe following example executes the scalar user-defined function in the AdventureWorks2022 database. It uses the variable to store the value returned by the function. The function expects one input parameter, . This is defined as a tinyint data type.\n\nJ. Use EXECUTE to query an Oracle database on a linked server\n\nThe following example executes several statements at the remote Oracle server. The example begins by adding the Oracle server as a linked server and creating linked server login.\n\nK. Use EXECUTE AS USER to switch context to another user\n\nThe following example executes a Transact-SQL string that creates a table and specifies the clause to switch the execution context of the statement from the caller to . The Database Engine checks the permissions of when the statement is run. must exist as a user in the database and must have permission to create tables in the schema, or the statement fails.\n\nL. Use a parameter with EXECUTE and AT linked_server_name\n\nThe following example passes a command string to a remote server by using a question mark ( ) placeholder for a parameter. The example creates a linked server that points to another instance of SQL Server and executes a statement against that linked server. The statement uses the question mark as a place holder for the parameter ( ), which is provided after the statement.\n\nApplies to: SQL Server 2012 (11.x) and later versions, and Azure SQL Database.\n\nSome of the previous examples executed which returned seven columns. The following example demonstrates using the syntax to change the names and data types of the returning result set.\n\nN. Use EXECUTE to redefine a two result sets\n\nApplies to: SQL Server 2012 (11.x) and later versions, and Azure SQL Database.\n\nWhen executing a statement that returns more than one result set, define each expected result set. The following example in creates a procedure that returns two result sets. Then the procedure is executed using the clause, and specifying two result set definitions.\n\nO. Use EXECUTE with AT DATA_SOURCE data_source_name to query a remote SQL Server\n\nApplies to: SQL Server 2019 (15.x) and later versions.\n\nThe following example passes a command string to an external data source pointing to a SQL Server instance.\n\nP. Use EXECUTE with AT DATA_SOURCE data_source_name to query compute pool in SQL Server Big Data Cluster\n\nThe following example passes a command string to an external data source pointing to a compute pool in SQL Server Big Data Cluster. The example creates a data source against a compute pool in SQL Server Big Data Cluster and executes a statement against the data source.\n\nQ. Use EXECUTE with AT DATA_SOURCE data_source_name to query data pool in SQL Server Big Data Cluster\n\nThe following example passes a command string to an external data source pointing to compute pool in SQL Server Big Data Cluster (BDC). The example creates a data source against a data pool in BDC and executes a statement against the data source.\n\nR. Use EXECUTE with AT DATA_SOURCE data_source_name to query storage pool in SQL Server Big Data Cluster\n\nThe following example passes a command string to an external data source pointing to compute pool in SQL Server Big Data Cluster. The example creates a data source against a data pool in SQL Server Big Data Cluster and executes a statement against the data source.\n\nThe code samples in this article use the or sample database, which you can download from the Microsoft SQL Server Samples and Community Projects home page.\n\nCall a stored procedure with name determined at runtime:\n\nThe following example creates a procedure with parameters and demonstrates three ways to execute the procedure:\n\nExecute using named parameters out of order:"
    },
    {
        "link": "https://sqlshack.com/exec-sql-overview-and-examples",
        "document": "In this article, we will review on EXEC SQL statement in SQL Server and explore a few examples.\n\nThe EXEC command is used to execute a stored procedure, or a SQL string passed to it. You can also use full command EXECUTE which is the same as EXEC.\n\nFollowing is the basic syntax of EXEC command in SQL Server.\n\nTo illustrate the examples, I will create a sample stored procedure and table.\n\nTo execute a stored procedure using EXEC pass the procedure name and parameters if any. Please refer to the below T-SQL script to execute a stored procedure.\n\nWe can also assign the value returned by a stored procedure to a variable. Please refer to the following example T-SQL script.\n\nTo execute a string, construct the string and pass it to the EXEC SQL command. Please refer to the below example which executes a string.\n\nFollowing is the example of using EXEC with string constructed from a variable. You always need to enclose the string in the brackets else execute statement consider it as a stored procedure and throws an error as shown in the below image.\n\nConstructing a string from the variable and executing it using EXEC SQL command may inject unwanted code. There are some techniques to avoid SQL injection. We will review those techniques in another article.\n\nAT linked_server_name clause along with EXEC command is used to execute queries on a remote server. A linked server must be configured and RPC Out option must be enabled on the linked server to execute queries on a remote server.\n\nPlease refer to the following example of executing a query on a remote server. Replace the linked server name with your linked server name.\n\nIf we do not specify the database name, EXEC SQL statement will execute the query on the default database of the login used in the linked server.\n\nIf you want to execute query in a specific database use “USE databasename” in the query. Please refer to the below example.\n\nWe can also issue a select query against the remote server using four-part notation. We must enable the Data Access option on the linked server. Please refer to the below example.\n\nTo execute a stored procedure on a remote server, use below T-SQL script by replacing the linked server name, database name, and the stored procedure name.\n\nFollowing is the example of executing a stored procedure on the linked server using four-part notation. Here “TEST01V” is the server name, “test” is the database name, and “dbo” is the schema name.\n\nThis execution option in EXEC SQL statement creates a new plan and discards it after using it. If there is an existing plan for the procedure it remains the same in the cache. If there is no existing plan for the procedure and using with recompile option will not store the plan in cache.\n\nPlease refer to the below example for executing the procedure with recompile option. Before executing this I have cleared the plan cache using DBCC FREEPROCCACHE().\n\nAfter executing the above T-SQL script, I executed the below script to check for the cached plan.\n\nPlease refer to the below image. Executing procedure with recompile option did not store the plan in the cache.\n\nNow, we will execute procedure without recompile which will save the execution plan in cache and after that, we will execute the procedure with recompile option to see if the existing plan is changed or not.\n\nPlease refer to the below image for the result set of the above query. We can see the plan identifier and use counts are the same and the existing plan did not change. EXEC WITH RECOMPILE did not use the existing plan in the cache and created a new plan, used it and discarded it.\n\nThis option is used to modify the result set of a stored procedure or the string executed as per the definition specified in the WITH RESULT SETS clause.\n\nPlease refer to the following example of executing a stored procedure with RESULT SETS\n\nWe can modify the result set headers and the data type of the column return by executing the stored procedure. This is like using convert (), cast () and column aliases in the normal T-SQL script.\n\nIf the procedure or T-SQL string returns more than one result set we must define multiple results sets in the WITH RESULTS SETS clause as well else it will throw following error “EXECUTE statement failed because it’s WITH RESULT SETS clause specified 1 result set(s), and the statement tried to send more result sets than this.”\n\nPlease refer to the following example to use WITH RESULTS SETS clause in EXEC SQL statement for multiple results sets returned by stored procedure or string. In this example, the stored procedure returns two result sets which are the same. I have defined two results in WITH RESULTS SETS clause by changing the datatype and result set headers in both result sets.\n\nWe explored different aspects of EXEC SQL Statement with several examples in this article. In case you have any questions, please feel free to ask in the comment section below."
    },
    {
        "link": "https://learn.microsoft.com/en-us/sql/relational-databases/system-stored-procedures/sp-executesql-transact-sql?view=sql-server-ver16",
        "document": "Applies to: SQL Server Azure SQL Database Azure SQL Managed Instance Azure Synapse Analytics Analytics Platform System (PDW) SQL analytics endpoint in Microsoft Fabric Warehouse in Microsoft Fabric\n\nExecutes a Transact-SQL statement or batch that can be reused many times, or one that is built dynamically. The Transact-SQL statement or batch can contain embedded parameters.\n\nThe code samples in this article use the or sample database, which you can download from the Microsoft SQL Server Samples and Community Projects home page.\n\nA Unicode string that contains a Transact-SQL statement or batch. @stmt must be either a Unicode constant or a Unicode variable. More complex Unicode expressions, such as concatenating two strings with the operator, aren't allowed. Character constants aren't allowed. Unicode constants must be prefixed with an . For example, the Unicode constant is valid, but the character constant isn't. The size of the string is limited only by available database server memory. On 64-bit servers, the size of the string is limited to 2 GB, the maximum size of nvarchar(max).\n\n@stmt can contain parameters having the same form as a variable name. For example:\n\nEach parameter included in @stmt must have a corresponding entry in both the @params parameter definition list and the parameter values list.\n\nA string that contains the definitions of all parameters that are embedded in @stmt. The string must be either a Unicode constant or a Unicode variable. Each parameter definition consists of a parameter name and a data type. n is a placeholder that indicates more parameter definitions. Every parameter specified in @stmt must be defined in @params. If the Transact-SQL statement or batch in @stmt doesn't contain parameters, @params isn't required. The default value for this parameter is .\n\nA value for the first parameter that is defined in the parameter string. The value can be a Unicode constant or a Unicode variable. There must be a parameter value supplied for every parameter included in @stmt. The values aren't required when the Transact-SQL statement or batch in @stmt has no parameters.\n\nIndicates that the parameter is an output parameter. text, ntext, and image parameters can be used as parameters, unless the procedure is a common language runtime (CLR) procedure. An output parameter that uses the keyword can be a cursor placeholder, unless the procedure is a CLR procedure.\n\nA placeholder for the values of extra parameters. Values can only be constants or variables. Values can't be more complex expressions such as functions, or expressions built by using operators.\n\nReturns the result sets from all the SQL statements built into the SQL string.\n\nparameters must be entered in the specific order as described in the Syntax section earlier in this article. If the parameters are entered out of order, an error message occurs.\n\nhas the same behavior as regarding batches, the scope of names, and database context. The Transact-SQL statement or batch in the @stmt parameter isn't compiled until the statement is executed. The contents of @stmt are then compiled and executed as an execution plan separate from the execution plan of the batch that called . The batch can't reference variables declared in the batch that calls . Local cursors or variables in the batch aren't visible to the batch that calls . Changes in database context last only to the end of the statement.\n\ncan be used instead of stored procedures to execute a Transact-SQL statement many times when the change in parameter values to the statement is the only variation. Because the Transact-SQL statement itself remains constant and only the parameter values change, the SQL Server query optimizer is likely to reuse the execution plan it generates for the first execution. In this scenario, performance is equivalent to that of a stored procedure.\n\nsupports the setting of parameter values separately from the Transact-SQL string, as shown in the following example.\n\nOutput parameters can also be used with . The following example retrieves a job title from the table in the sample database, and returns it in the output parameter .\n\nBeing able to substitute parameters in offers the following advantages over using the statement to execute a string:\n• None Because the actual text of the Transact-SQL statement in the string doesn't change between executions, the query optimizer probably matches the Transact-SQL statement in the second execution with the execution plan generated for the first execution. Therefore, SQL Server doesn't have to compile the second statement.\n• None The Transact-SQL string is built only once.\n• None The integer parameter is specified in its native format. Casting to Unicode isn't required.\n\nWhen the OPTIMIZED_SP_EXECUTESQL database scoped configuration is enabled, the compilation behavior of batches submitted using becomes identical to the serialized compilation behavior that objects such as stored procedures and triggers currently employ.\n\nWhen batches are identical (excluding any parameter differences), the option tries to obtain a compile lock as an enforcement mechanism to guarantee that the compilation process is serialized. This lock ensures that if multiple sessions invoke simultaneously, those sessions will wait while trying to obtain an exclusive compile lock after the first session starts the compilation process. The first execution of compiles and inserts its compiled plan into the plan cache. Other sessions abort waiting on the compile lock and reuse the plan once it becomes available.\n\nWithout the option, multiple invocations of identical batches executed via compile in parallel and place their own copies of a compiled plan into the plan cache, which replace or duplicate plan cache entries in some cases.\n\nis off by default. To enable at the database level, use the following Transact-SQL statement:\n\nThe following example creates and executes a statement that contains an embedded parameter named .\n\nThe following example shows using to execute a dynamically built string. The example stored procedure is used to insert data into a set of tables that are used to partition sales data for a year. There's one table for each month of the year that has the following format:\n\nThis sample stored procedure dynamically builds and executes an statement to insert new orders into the correct table. The example uses the order date to build the name of the table that should contain the data, and then incorporates that name into an statement.\n\nUsing in this procedure is more efficient than using to execute the dynamically built string, because it allows for the use of parameter markers. Parameter markers make it more likely that the Database Engine reuses the generated query plan, which helps to avoid additional query compilations. With , each string is unique because the parameter values are different, and would be appended to the end of the dynamically generated string. When executed, the query wouldn't be parameterized in a way that encourages plan reuse, and would have to be compiled before each statement is executed, which would add a separate cached entry of the query in the plan cache.\n\nC. Use the OUTPUT parameter\n\nThe following example uses an parameter to store the result set generated by the statement in the parameter. Two statements are then executed that use the value of the parameter.\n\nThe following example creates and executes a statement that contains an embedded parameter named ."
    },
    {
        "link": "https://w3schools.com/sql/sql_ref_exec.asp",
        "document": "W3Schools offers a wide range of services and products for beginners and professionals, helping millions of people everyday to learn and master new skills."
    },
    {
        "link": "https://stackoverflow.com/questions/37326802/sql-server-exec-keyword",
        "document": "The EXEC keyword tells SQL that you want to run a stored procedure, function or character string. Syntax can be found here: https://msdn.microsoft.com/en-us/library/ms188332.aspx\n\nEXEC is essential for using transact SQL, when you want to built a SQL statement dynamically. Common practice for this is to build a sql statement in a temporary variable string, then use the EXECUTE keyword to execute it.\n\nThe above would execute the following statement: 'USE MyDB INSERT INTO #NewTable SELECT Column1 FROM Mytable'\n\nAs for GO, it is a command to end a batch of statements. This can be used for a variety of reasons, but I would start your research here: https://msdn.microsoft.com/en-us/library/ms188037.aspx"
    },
    {
        "link": "https://learn.microsoft.com/en-us/sql/t-sql/language-elements/use-transact-sql?view=sql-server-ver16",
        "document": "Changes the database context to the specified database or database snapshot.\n\ndatabase_name\n\n Is the name of the database or database snapshot to which the user context is switched. Database and database snapshot names must comply with the rules for identifiers.\n\nIn Azure SQL Database, the database parameter can only refer to the current database. If a database other than the current database is provided, the statement does not switch between databases, and error code 40508 is returned. To change databases, you must directly connect to the database. The USE statement is marked as not applicable to SQL Database at the top of this page, because even though you can have the statement in a batch, it doesn't do anything.\n\nWhen a SQL Server login connects to SQL Server, the login is automatically connected to its default database and acquires the security context of a database user. If no database user has been created for the SQL Server login, the login connects as guest. If the database user does not have CONNECT permission on the database, the USE statement will fail. If no default database has been assigned to the login, its default database will be set to master.\n\nUSE is executed at both compile and execution time and takes effect immediately. Therefore, statements that appear in a batch after the USE statement are executed in the specified database.\n\nThe following example changes the database context to the database."
    },
    {
        "link": "https://stackoverflow.com/questions/2652252/do-all-databases-use-the-use-statement-to-switch-databases",
        "document": "MySQL uses the to change the active database. Does that work on all databases?\n\nEDIT: By databases I mean DBMS. Thanks for bringing it to my attention."
    },
    {
        "link": "https://support.microsoft.com/en-us/topic/fix-use-statement-is-not-supported-to-switch-between-databases-error-message-when-you-run-a-custom-report-in-sql-server-2008-r2-management-studio-986fb381-59e9-22c8-836d-a1e607263f45",
        "document": "Microsoft distributes Microsoft SQL Server 2008 R2 fixes as one downloadable file. Because the fixes are cumulative, each new release contains all the hotfixes and all the security fixes that were included with the previous SQL Server 2008 R2 fix release. Consider the following scenario:\n• You connect to a Microsoft SQL Azure instance in Microsoft SQL Server 2008 R2 Management Studio (SSMS 2008 R2).\n• You right-click a non-master database in Object Explorer, and then run a custom report.\n• The custom report does not include the USE command to switch context to the current database. In this scenario, the custom report does not run. Additionally, you receive the following error message:\n\n\n\n USE statement is not supported to switch between databases. Use a new connection to connect to a different Database.\n\nThis issue occurs because SSMS 2008 R2 uses the default database name (typically the master database) to run the custom report. However, SSMS 2008 R2 should use the database name that is used by the Object Explorer node to run the custom report.\n\n\n\nThe fix for this issue was first released in Cumulative Update 3. For more information about how to obtain this cumulative update package for SQL Server 2008 R2, click the following article number to view the article in the Microsoft Knowledge Base: 2261464 Cumulative update package 3 for SQL Server 2008 R2Note Because the builds are cumulative, each new fix release contains all the hotfixes and all the security fixes that were included with the previous SQL Server 2008 R2 fix release. We recommend that you consider applying the most recent fix release that contains this hotfix. For more information, click the following article number to view the article in the Microsoft Knowledge Base: 981356 The SQL Server 2008 R2 builds that were released after SQL Server 2008 R2 was released\n\nFor more information about the Incremental Servicing Model for SQL Server, click the following article number to view the article in the Microsoft Knowledge Base:\n\n\n\n 935897 An Incremental Servicing Model is available from the SQL Server team to deliver hotfixes for reported problems\n\n\n\n\n\nFor more information about the naming schema for SQL Server updates, click the following article number to view the article in the Microsoft Knowledge Base:\n\n\n\n 822499New naming schema for Microsoft SQL Server software update packages\n\nFor more information about software update terminology, click the following article number to view the article in the Microsoft Knowledge Base: 824684 Description of the standard terminology that is used to describe Microsoft software updates"
    },
    {
        "link": "https://geeksforgeeks.org/sql-use-database-statement",
        "document": "SQL(Structured Query Language) is a standard Database language that is used to create, maintain and retrieve the data from relational databases like MySQL, Oracle, etc. It is flexible and user-friendly. In SQL, to interact with the database, the users have to type queries that have certain syntax, and use command is one of them. The use command is used when there are multiple databases in the SQL and the user or programmer specifically wants to use a particular database. Thus, in simple terms, the use statement selects a specific database and then performs operations on it using the inbuilt commands of SQL.\n\nThe user wants to works on the databases named “GEEKS”. So the user will write:\n\nBefore using any database using the use command, it’s necessary to first create it. In order to create a database in SQL, the following command is used. Here, we create a database named “GFG1”:\n\nNow, after the user has created a database named candy, we can use this database to perform the database operations. So, for that, the user has to type the USE command as follows:\n\nAfter performing desired operations on the database, if we do not want the database, We can drop the database using the DROP command:\n\nRemember, once a database is dropped, it’s removed permanently from the list of available databases, there is no way to retrieve the data of the table or the complete database in any possible way.\n\nAfter using the drop command, if the user types –\n\nThe SQL database will throw an error as the GFG1 database has been removed permanently from the database using the drop command."
    },
    {
        "link": "https://tutorialspoint.com/sql/sql-select-database.htm",
        "document": "To work with a database in SQL, we need to first select the database we want to work with. After selecting the database, we can perform various operations on it such as creating tables, inserting data, updating data, and deleting data.\n\nThe SQL USE DATABASE statement is used to select a database from a list of databases available in the system. Once a database is selected, we can perform various operations on it such as creating tables, inserting data, updating data, and deleting data.\n\nFollowing is the syntax of the USE DATABASE statement in SQL −\n\nHere, the DatabaseName is the name of the database that we want to select. The database name is always unique within the RDBMS.\n\nFirst of all we will create a database using the following SQL CREATE DATABASE query −\n\nNow, we can list all the available databases as follws −\n\nThe output will be displayed as −\n\nFollowing query is used to select/switch the current database to testDB −\n\nOnce we finish switching to the database testDB we can perform operations such as creating a table, and inserting data in that table as shown below −.\n\nNow, let us insert some records in the CALENDAR table using SQL INSERT statements as shown in the query below −\n\nLet's verify the operation by listing all the records from CALENDAR table using SQL SELECT statement as shown below −\n\nThe output will be displayed as −\n\nAn attempt to select a non-existent database will result in an error. In the following query we are trying to switch to the database which does not exist −\n\nOn executing the above query, the output will be displayed as"
    }
]