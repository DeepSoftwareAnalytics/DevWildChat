[
    {
        "link": "https://docs.panda3d.org",
        "document": "Welcome to the Panda3D documentation! Panda3D is an open-source, free-to-use 3D engine made for the development of realtime 3D games, visualizations, simulations, experiments — you name it! It consists of a library of subroutines that can be used with either the Python or C++ programming language, as well as a few tools to assist with development and debugging.\n\nThere are two versions of the manual: one for Python users and one for C++ users. Use the link in the sidebar to switch between the versions. You are currently viewing the manual for Python users.\n\nThe manual is divided up into sections, which are listed below. You can at any time use the sidebar on the left side to navigate between the different sections and their contained pages.\n\nIf you are struggling with understanding or using Panda3D, feel free to ask the community! There is a passionate community around Panda3D that is here to help. You can post a question on the discussion forum, visit our Discord server or visit the channel on the Libera.Chat IRC server."
    },
    {
        "link": "https://docs.panda3d.org/1.10/python/programming/scene-graph/index",
        "document": "Many simple 3D engines maintain a list of 3D models to render every frame. In these simple engines, one must allocate a 3D model (or load it from disk), and then insert it into the list of models to render. The model is not “visible” to the renderer until it is inserted into the list. Panda3D is slightly more sophisticated. Instead of maintaining a list of objects to render, it maintains a tree of objects to render. An object is not visible to the renderer until it is inserted into the tree. The tree consists of objects of class . This is actually a superclass for a number of other classes: , , , and so forth. Throughout this manual, it is common for us to refer to objects of these classes as simply nodes, and the tree that is being made up by these nodes is known as the scene graph. There may be many scene graphs in an application. In fact, any tree of nodes in existence is technically a scene graph all on its own. But for the purposes of rendering 3D models, we usually talk about the standard 3D scene graph, at the root of which is a node called . Panda3D also creates a scene graph for rendering 2D objects. This is used for putting text, images and GUI elements on top of the 3D scene. This scene graph is positioned under a root called , but this will be explained further in a later section.\n\nWhat you Need to Know about the Hierarchical Scene Graph Here are the most important things you need to know about the hierarchical arrangement of the scene graph:\n• None You control where objects go in the tree. When you insert an object into the tree, you specify where to insert it. You can move branches of the tree around. You can make the tree as deep or as shallow as you like.\n• None Positions of objects are specified relative to their parent in the tree. For example, if you have a 3D model of a hat, you might want to specify that it always stays five units above a 3D model of a certain person’s head. Insert the hat as a child of the head, and set the position of the hat to (0,0,5).\n• None When models are arranged in a tree, any rendering attributes you assign to a node will propagate to its children. For example, if you specify that a given node should be rendered with depth fog, then its children will also be rendered with depth fog, unless you explicitly override at the child level.\n• None Panda3D generates bounding boxes for each node in the tree. A good organizational hierarchy can speed frustum and occlusion culling. If the bounding box of an entire branch is outside the frustum, there is no need to examine the children. Beginners usually choose to make their tree completely flat–everything is inserted immediately beneath the root. This is actually a very good initial design. Eventually, you will find a reason to want to add a little more depth to the hierarchy. But it is wise not to get complicated until you have a clear, specific reason to do so.\n\nMost manipulations of the scene graph are performed using the class. This is a very small object containing a pointer to a node, plus some administrative information. For now, you can ignore the administrative information; it will be explained in a later section of the manual. It is the intent of the Panda3D designers that you should think of a NodePath as a handle to a node. Any function that creates a node returns a that refers to the newly-created node. A NodePath isn’t exactly a pointer to a node; it’s a “handle” to a node. Conceptually, this is almost a distinction without a difference. However, there are certain API functions that expect you to pass in a NodePath, and there are other API functions that expect you to pass in a node pointer. Because of this, although there is little conceptual difference between them, you still need to know that both exist. You can convert a NodePath into a “regular” pointer at any time by calling . However, there is no unambiguous way to convert back. That’s important: sometimes you need a NodePath, sometimes you need a node pointer. Because of this, it is recommended that you store NodePaths, not node pointers. When you pass parameters, you should probably pass NodePaths, not node pointers. The callee can always convert the NodePath to a node pointer if it needs to.\n\nThere are many methods that you can invoke on NodePaths, which are appropriate for nodes of any type. Specialized node types, like and (for instance), provide additional methods that are available only for nodes of that type, which you must invoke on the node itself. Here are some assorted examples: Always remember: when you invoke a method of , you are actually performing an operation on the node to which it points. In the example above, we call node-methods by first converting the NodePath into a node, and then immediately calling the node-method. This is the recommended style."
    },
    {
        "link": "https://docs.panda3d.org/1.11/cpp/index",
        "document": "Welcome to the Panda3D documentation! Panda3D is an open-source, free-to-use 3D engine made for the development of realtime 3D games, visualizations, simulations, experiments — you name it! It consists of a library of subroutines that can be used with either the Python or C++ programming language, as well as a few tools to assist with development and debugging.\n\nThere are two versions of the manual: one for Python users and one for C++ users. Use the link in the sidebar to switch between the versions. You are currently viewing the manual for C++ users.\n\nThe manual is divided up into sections, which are listed below. You can at any time use the sidebar on the left side to navigate between the different sections and their contained pages.\n\nIf you are struggling with understanding or using Panda3D, feel free to ask the community! There is a passionate community around Panda3D that is here to help. You can post a question on the discussion forum, visit our Discord server or visit the channel on the Libera.Chat IRC server."
    },
    {
        "link": "https://docs.panda3d.org/1.9/python/programming/scene-graph/index",
        "document": "Many simple 3D engines maintain a list of 3D models to render every frame. In these simple engines, one must allocate a 3D model (or load it from disk), and then insert it into the list of models to render. The model is not “visible” to the renderer until it is inserted into the list. Panda3D is slightly more sophisticated. Instead of maintaining a list of objects to render, it maintains a tree of objects to render. An object is not visible to the renderer until it is inserted into the tree. The tree consists of objects of class . This is actually a superclass for a number of other classes: , , , and so forth. Throughout this manual, it is common for us to refer to objects of these classes as simply , and the tree that is being made up by these nodes is known as the scene graph. There may be many scene graphs in an application. In fact, any tree of nodes in existence is technically a scene graph all on its own. But for the purposes of rendering 3D models, we usually talk about the standard 3D scene graph, at the root of which is a node called .\n\nWhat you Need to Know about the Hierarchical Scene Graph Here are the most important things you need to know about the hierarchical arrangement of the scene graph:\n• None You control where objects go in the tree. When you insert an object into the tree, you specify where to insert it. You can move branches of the tree around. You can make the tree as deep or as shallow as you like.\n• None Positions of objects are specified relative to their parent in the tree. For example, if you have a 3D model of a hat, you might want to specify that it always stays five units above a 3D model of a certain person’s head. Insert the hat as a child of the head, and set the position of the hat to (0,0,5).\n• None When models are arranged in a tree, any rendering attributes you assign to a node will propagate to its children. For example, if you specify that a given node should be rendered with depth fog, then its children will also be rendered with depth fog, unless you explicitly override at the child level.\n• None Panda3D generates bounding boxes for each node in the tree. A good organizational hierarchy can speed frustum and occlusion culling. If the bounding box of an entire branch is outside the frustum, there is no need to examine the children. Beginners usually choose to make their tree completely flat–everything is inserted immediately beneath the root. This is actually a very good initial design. Eventually, you will find a reason to want to add a little more depth to the hierarchy. But it is wise not to get complicated until you have a clear, specific reason to do so.\n\nThere is a helper class called which is a very small object containing a pointer to a node, plus some administrative information. For now, you can ignore the administrative information; it will be explained in a later section of the manual. It is the intent of the panda designers that you should think of a NodePath as a handle to a node. Any function that creates a node returns a that refers to the newly-created node. A NodePath isn’t exactly a pointer to a node; it’s a “handle” to a node. Conceptually, this is almost a distinction without a difference. However, there are certain API functions that expect you to pass in a NodePath, and there are other API functions that expect you to pass in a node pointer. Because of this, although there is little conceptual difference between them, you still need to know that both exist. You can convert a NodePath into a “regular” pointer at any time by calling . However, there is no unambiguous way to convert back. That’s important: sometimes you need a NodePath, sometimes you need a node pointer. Because of this, it is recommended that you store NodePaths, not node pointers. When you pass parameters, you should probably pass NodePaths, not node pointers. The callee can always convert the NodePath to a node pointer if it needs to."
    },
    {
        "link": "https://research.cs.wisc.edu/graphics/Courses/559-f2007/wiki/pub/tutorials/tutPanda/pandaManual.pdf",
        "document": ""
    },
    {
        "link": "https://docs.panda3d.org/1.10/python/programming/physics/bullet/vehicles",
        "document": "Bullet comes with a simple vehicle controller, which can be used for arcade style vehicle simulations. Instead of simulation of each wheel and chassis as separate rigid bodies connected by joints, it simply uses a single rigid body for the chassis. Collision detection for the wheels is approximated by ray casts, and the tire friction is a basic anisotropic friction model. This approach to vehicle modelling is called “raycast vehicle”, and it is used widely in commercial and non-commercial driving games.\n\nIn order to create a vehicle we first have to create an ordinary dynamic rigid body. This rigid body will serve as the vehicle chassis. Then we can create a new instance of . We have to pass the and the as arguments to the vehicle constructor. The following code snippet shows how this could be done.\n\nOnce we have created the chassis and the vehicle we can add wheels to the vehicle. We can create a new wheel using the factory method of the previously created vehicle. Once created we still have to configure the wheel, that is set friction parameters, offset of the wheel hub with respect to the chassis, axle direction and so on. The following sample shows how to create and configure a wheel. In this case a front wheel is created. Front wheels are steerable.\n\nFinally we need to control steering and engine/brakes. This is best done using a task, and keeping the current steering angle around somewhere in a variable. Here we use a very simple model of controlling the steering angle. If ‘turnLeft’ or ‘turnRight’ keys are pressed the steering angle will increase/decrease at a constant rate, until a maximum steering angle is achieved. No relaxation is applied. Therefor we also define constants for the maximum steering angle (here: steeringClamp) and the rate at which the steering angle increases/decreases (here: steeringIncrement). The engine force and brake model shown is very simple too. If ‘forward’ is pressed then the engine force will be the maximum engine force, otherwise engine force will be zero. Likewise for the brakes. Once the steering angle and engine/brake forces are determined they will be applied to the wheels. Each wheel - addressed by it’s index, i. e. 0 to 3 for a four-wheel car - can be individually assigned values for steering and engine/brake force. This way front/rear drives or four-wheel-drives can be simulated. The following code snippet shows pseudocode for controlling steering and engine/brakes. More realistic control models can be invented, in order to meet the control requirements of individual driving games. For example:\n• None Relaxing the steering angle to zero if the user does no hold down the left or right keys.\n• None Setting engine force based on an analogue input, or alternatively based on the duration of the forward key being pressed down. However, it is up to you do invent such controls. What Bullet requires is that you provide the steering angle and the engine and brake force."
    },
    {
        "link": "https://docs.panda3d.org/1.11/cpp/programming/physics/bullet/vehicles",
        "document": "Bullet comes with a simple vehicle controller, which can be used for arcade style vehicle simulations. Instead of simulation of each wheel and chassis as separate rigid bodies connected by joints, it simply uses a single rigid body for the chassis. Collision detection for the wheels is approximated by ray casts, and the tire friction is a basic anisotropic friction model. This approach to vehicle modelling is called “raycast vehicle”, and it is used widely in commercial and non-commercial driving games.\n\nIn order to create a vehicle we first have to create an ordinary dynamic rigid body. This rigid body will serve as the vehicle chassis. Then we can create a new instance of BulletVehicle . We have to pass the BulletWorld and the BulletRigidBodyNode as arguments to the vehicle constructor.\n\nOnce we have created the chassis and the vehicle we can add wheels to the vehicle. We can create a new wheel using the createWheel factory method of the previously created vehicle. Once created we still have to configure the wheel, that is set friction parameters, offset of the wheel hub with respect to the chassis, axle direction and so on.\n\nFinally we need to control steering and engine/brakes. This is best done using a task, and keeping the current steering angle around somewhere in a variable.\n\nHere we use a very simple model of controlling the steering angle. If ‘turnLeft’ or ‘turnRight’ keys are pressed the steering angle will increase/decrease at a constant rate, until a maximum steering angle is achieved. No relaxation is applied. Therefor we also define constants for the maximum steering angle (here: steeringClamp) and the rate at which the steering angle increases/decreases (here: steeringIncrement).\n\nThe engine force and brake model shown is very simple too. If ‘forward’ is pressed then the engine force will be the maximum engine force, otherwise engine force will be zero. Likewise for the brakes.\n\nOnce the steering angle and engine/brake forces are determined they will be applied to the wheels. Each wheel - addressed by it’s index, i. e. 0 to 3 for a four-wheel car - can be individually assigned values for steering and engine/brake force. This way front/rear drives or four-wheel-drives can be simulated.\n\nMore realistic control models can be invented, in order to meet the control requirements of individual driving games. For example:\n• None Relaxing the steering angle to zero if the user does no hold down the left or right keys.\n• None Setting engine force based on an analogue input, or alternatively based on the duration of the forward key being pressed down.\n\nHowever, it is up to you do invent such controls. What Bullet requires is that you provide the steering angle and the engine and brake force."
    },
    {
        "link": "https://pybullet.org/Bullet/phpBB3/viewtopic.php?t=994",
        "document": "Hi all,\n\n \n\n I'm experimenting with various ways to create a vehicle with Bullet. I have integrated Bullet into our game engine and the basics are working nicely (can roll balls and things down hills etc), and visualize the collision shapes properly.\n\n \n\n Haven't had much luck with the Bullet raycar so far, and I guess it might have to do with the coordinate system we use in the game engine. Is it possible to define a raycar that has the body x-axis pointing forward, y to the right and z down? \n\n \n\n I also would like to do a car with proper wheels attached. I tried using the hinge as a simple test, and this works well enough, allthough I cannot steer and there's no suspension. The wheels do appear to be attached with a rubber axle, but I recon that was to be expected. Can the hinge axis vector be modified while the simulation is running, to be able to steer? I could not find any function for this. \n\n \n\n How would you recommend going about implementing a car with \"real\" wheels in Bullet? Should I try using the 6DOF constraint? Is there a way to simulate suspension (apply the forces for sping and damper, basically) from the \"outside\" or does this have to be a part of the constraint itself? \n\n \n\n Best regards,\n\n Ola"
    },
    {
        "link": "https://docs.panda3d.org/1.9/cpp/programming/physics/bullet/vehicles",
        "document": "Bullet comes with a simple vehicle controller, which can be used for arcade style vehicle simulations. Instead of simulation of each wheel and chassis as separate rigid bodies connected by joints, it simply uses a single rigid body for the chassis. Collision detection for the wheels is approximated by ray casts, and the tire friction is a basic anisotropic friction model. This approach to vehicle modelling is called “raycast vehicle”, and it is used widely in commercial and non-commercial driving games.\n\nIn order to create a vehicle we first have to create an ordinary dynamic rigid body. This rigid body will serve as the vehicle chassis. Then we can create a new instance of BulletVehicle . We have to pass the BulletWorld and the BulletRigidBodyNode as arguments to the vehicle constructor.\n\nOnce we have created the chassis and the vehicle we can add wheels to the vehicle. We can create a new wheel using the createWheel factory method of the previously created vehicle. Once created we still have to configure the wheel, that is set friction parameters, offset of the wheel hub with respect to the chassis, axle direction and so on.\n\nFinally we need to control steering and engine/brakes. This is best done using a task, and keeping the current steering angle around somewhere in a variable.\n\nHere we use a very simple model of controlling the steering angle. If ‘turnLeft’ or ‘turnRight’ keys are pressed the sterring angle will increase/decrease at a constant rate, until a maximum steering angle is achieved. No relaxation is applied. Therefor we also define constants for the maximum steering angle (here: steeringClamp) and the rate at which the steering angle increases/decreases (here: steeringIncrement).\n\nThe engine force and brake model shown is very simple too. If ‘forward’ is pressed then the engine force will be the maximum engine force, otherwise engine force will be zero. Likewise for the brakes.\n\nOnce the steering angle and engine/brake forces are determined they will be applied to the wheels. Each wheel - addressed by it’s index, i. e. 0 to 3 for a four-wheel car - can be individually assigned values for steering and engine/brake force. This way front/rear drives or four-wheel-drives can be simulated.\n\nMore realistic control models can be invented, in order to meet the control requirements of individual driving games. For example:\n• None Relaxing the steering angle to zero if the user does no hold down the left or right keys.\n• None Setting engine force based on an analogue input, or alternatively based on the duration of the forward key being pressed down.\n\nHowever, it is up to you do invent such controls. What Bullet requires is that you provide the steering angle and the engine and brake force."
    },
    {
        "link": "https://docs.panda3d.org/1.10/python/programming/physics/index",
        "document": "While Collision Detection addresses the problem of preventing objects from intersecting each other adequately for most applications, some games and simulations may need to model more realistic dynamic interactions between objects, taking into account such things as an object’s mass, friction, elasticity and external forces.\n\nThese uses may require the use of a physics engine. This is a system that can model interactions between objects using physics equations, taking into account far more parameters than a simple collision response system can.\n\nPanda3D offers several choices to use for physics. Before you choose one, however, think carefully whether you need the additional complexity, performance and authoring cost of a physics simulation, and whether perhaps Collision Detection on its own might be adequate for your use-cases.\n• None Panda’s Built-in Physics Engine: Panda3D has a very basic physics engine built-in that may apply forces to classes. The physics engine can handle angular or linear forces, as well as viscosity.\n• None Bullet Physics Engine: This is a good choice for more advanced physics in most games.\n• None The Open Dynamics Engine: This is another option provided as part of the Panda3D binaries, but does not support as many features as Bullet.\n\nWhen you have a very simple simulation, you will most likely want to use the built-in physics, which works with Panda’s collision system. However, many applications that need physics simulations may find it inadequate, as the Bullet system is far more full-featured."
    }
]