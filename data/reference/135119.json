[
    {
        "link": "https://developer.android.com/guide/fragments/lifecycle",
        "document": "Each instance has its own lifecycle. When a user navigates and interacts with your app, your fragments transition through various states in their lifecycle as they are added, removed, and enter or exit the screen.\n\nTo manage lifecycle, implements , exposing a object that you can access through the method.\n\nEach possible state is represented in the enum.\n\nBy building on top of , you can use the techniques and classes available for Handling Lifecycles with Lifecycle-Aware Components. For example, you might display the device's location on the screen using a lifecycle-aware component. This component could automatically start listening when the fragment becomes active and stop when the fragment moves to an inactive state.\n\nAs an alternative to using a , the class includes callback methods that correspond to each of the changes in a fragment's lifecycle. These include , , , , , and .\n\nA fragment's view has a separate that is managed independently from that of the fragment's . Fragments maintain a for their view, which can be accessed using or . Having access to the view's is useful for situations where a Lifecycle-aware component should only perform work while a fragment's view exists, such as observing that is only meant to be displayed on the screen.\n\nThis topic discusses the lifecycle in detail, explaining some of the rules that determine a fragment's lifecycle state and showing the relationship between the states and the fragment lifecycle callbacks.\n\nWhen a fragment is instantiated, it begins in the state. For a fragment to transition through the rest of its lifecycle, it must be added to a . The is responsible for determining what state its fragment should be in and then moving them into that state.\n\nBeyond the fragment lifecycle, is also responsible for attaching fragments to their host activity and detaching them when the fragment is no longer in use. The class has two callback methods, and , that you can override to perform work when either of these events occur.\n\nThe callback is invoked when the fragment has been added to a and is attached to its host activity. At this point, the fragment is active, and the is managing its lifecycle state. At this point, methods such as return this fragment.\n\nis always called before any Lifecycle state changes.\n\nThe callback is invoked when the fragment has been removed from a and is detached from its host activity. The fragment is no longer active and can no longer be retrieved using .\n\nis always called after any Lifecycle state changes.\n\nNote that these callbacks are unrelated to the methods and . For more information on these methods, see Fragment transactions.\n\nWhen determining a fragment's lifecycle state, considers the following:\n• A fragment's maximum state is determined by its . A fragment cannot progress beyond the state of its .\n• As part of a , you can set a maximum lifecycle state on a fragment using .\n• A fragment's lifecycle state can never be greater than its parent. For example, a parent fragment or activity must be started before its child fragments. Likewise, child fragments must be stopped before their parent fragment or activity.\n\nFigure 1 shows each of the fragment's states and how they relate to both the fragment's lifecycle callbacks and the fragment's view .\n\nAs a fragment progresses through its lifecycle, it moves upward and downward through its states. For example, a fragment that is added to the top of the back stack moves upward from to to . Conversely, when a fragment is popped off of the back stack, it moves downward through those states, going from to to and finally .\n\nWhen moving upward through its lifecycle states, a fragment first calls the associated lifecycle callback for its new state. Once this callback is finished, the relevant is emitted to observers by the fragment's , followed by the fragment's view , if it has been instantiated.\n\nWhen your fragment reaches the state, it has been added to a and the method has already been called.\n\nThis would be the appropriate place to restore any saved state associated with the fragment itself through the fragment's . Note that the fragment's view has not been created at this time, and any state associated with the fragment's view should be restored only after the view has been created.\n\nThis transition invokes the callback. The callback also receives a argument containing any state previously saved by . Note that has a value the first time the fragment is created, but it is always non-null for subsequent recreations, even if you do not override . See Saving state with fragments for more details.\n\nThe fragment's view is created only when your provides a valid instance. In most cases, you can use the fragment constructors that take a , which automatically inflates the view at the appropriate time. You can also override to programmatically inflate or create your fragment's view.\n\nIf and only if your fragment's view is instantiated with a non-null , that is set on the fragment and can be retrieved using . The is then updated with the newly corresponding with the fragment's view. The lifecycle callback is also called at this time.\n\nThis is the appropriate place to set up the initial state of your view, to start observing instances whose callbacks update the fragment's view, and to set up adapters on any or instances in your fragment's view.\n\nAfter the fragment's view has been created, the previous view state, if any, is restored, and the view's is then moved into the state. The view lifecycle owner also emits the event to its observers. Here you should restore any additional state associated with the fragment's view.\n\nThis transition also invokes the callback.\n\nIt is strongly recommended to tie Lifecycle-aware components to the state of a fragment, as this state guarantees that the fragment's view is available, if one was created, and that it is safe to perform a on the child of the fragment. If the fragment's view is non-null, the fragment's view is moved to immediately after the fragment's is moved to .\n\nWhen the fragment becomes , the callback is invoked.\n\nWhen the fragment is visible, all and effects have finished, and the fragment is ready for user interaction. The fragment's moves to the state, and the callback is invoked.\n\nThe transition to is the appropriate signal to indicate that the user is now able to interact with your fragment. Fragments that are not should not manually set focus on their views or attempt to handle input method visibility.\n\nWhen a fragment moves downward to a lower lifecycle state, the relevant is emitted to observers by the fragment's view , if instantiated, followed by the fragment's . After a fragment's lifecycle event is emitted, the fragment calls the associated lifecycle callback.\n\nAs the user begins to leave the fragment, and while the fragment is still visible, the s for the fragment and for its view are moved back to the state and emit the event to their observers. The fragment then invokes its callback.\n\nOnce the fragment is no longer visible, the s for the fragment and for its view are moved into the state and emit the event to their observers. This state transition is triggered not only by the parent activity or fragment being stopped, but also by the saving of state by the parent activity or fragment. This behavior guarantees that the event is invoked before the fragment's state is saved. This makes the event the last point where it is safe to perform a on the child .\n\nAs shown in figure 2, the ordering of the callback and the saving of the state with differs based on API level. For all API levels prior to API 28, is invoked before . For API levels 28 and higher, the calling order is reversed.\n\nAfter all of the exit animations and transitions have completed, and the fragment's view has been detached from the window, the fragment's view is moved into the state and emits the event to its observers. The fragment then invokes its callback. At this point, the fragment's view has reached the end of its lifecycle and returns a value.\n\nAt this point, all references to the fragment's view should be removed, allowing the fragment's view to be garbage collected.\n\nIf the fragment is removed, or if the is destroyed, the fragment's is moved into the state and sends the event to its observers. The fragment then invokes its callback. At this point, the fragment has reached the end of its lifecycle.\n\nFor more information related to the fragment lifecycle, see the following additional resources."
    },
    {
        "link": "https://developer.android.com/guide/fragments",
        "document": "A represents a reusable portion of your app's UI. A fragment defines and manages its own layout, has its own lifecycle, and can handle its own input events. Fragments can't live on their own. They must be hosted by an activity or another fragment. The fragment’s view hierarchy becomes part of, or attaches to, the host’s view hierarchy.\n\nFragments introduce modularity and reusability into your activity’s UI by letting you divide the UI into discrete chunks. Activities are an ideal place to put global elements around your app's user interface, such as a navigation drawer. Conversely, fragments are better suited to define and manage the UI of a single screen or portion of a screen.\n\nConsider an app that responds to various screen sizes. On larger screens, you might want the app to display a static navigation drawer and a list in a grid layout. On smaller screens, you might want the app to display a bottom navigation bar and a list in a linear layout.\n\nManaging these variations in the activity is unwieldy. Separating the navigation elements from the content can make this process more manageable. The activity is then responsible for displaying the correct navigation UI, while the fragment displays the list with the proper layout.\n\nDividing your UI into fragments makes it easier to modify your activity's appearance at runtime. While your activity is in the lifecycle state or higher, fragments can be added, replaced, or removed. And you can keep a record of these changes in a back stack that is managed by the activity, so that the changes can be reversed.\n\nYou can use multiple instances of the same fragment class within the same activity, in multiple activities, or even as a child of another fragment. With this in mind, only provide a fragment with the logic necessary to manage its own UI. Avoid depending on or manipulating one fragment from another.\n\nFor more documentation and resources related to fragments, see the following.\n• Single Activity: Why, when, and how (Android Dev Summit '18)"
    },
    {
        "link": "https://stackoverflow.com/questions/20355127/android-lifecycle-management-of-fragments-within-viewpager-and-fragmentpageradap",
        "document": "I have been struggling to find out what the correct management of Fragments within a with a is. Before I go into details, a quick summary of the issue that I am facing is the following:\n\nI have a with a . The uses a custom, yet very simple . Each within the comprises of an . I also have an action bar button called \"Refresh\". For now, let's assume that the has only one . The activity is created, and the 's is populated (so far so good). When the Refresh button is clicked, the handling method within the iterates over the list of that are assigned to the FragmentPagerAdapter and calls on each to populate its ListView. However, when the orientation of the device changes (e.g. from portrait to landscape), the Activity is recreated and so are the fragments. Clicking the Refresh button now will iterate over non-initialised .\n\nI know that I am being quite vague, especially without sample code, but please bear with me. I have traced the problem and method calls as follows from the start of the application/activity:\n• <-- this creates an ArrayList of Fragments and assignes them to a new FragmentPagerAdapter which is in turn assigned to the ViewPager.\n• <-- nothing special here, just calling the super method.\n• <-- nothing special here either, just inflating the layout\n• <-- nothing here either.\n• << All good, orientation changes here >>\n• <-- iterates over the newly created Fragments from #13 (not these by Android!).\n\nSo the problem, as I see it, is as follows: When Android re-creates the and its after a change of screen orientation (calls #9-15 above), it creates new objects with their state restored to what the original ones were. However, these ones appear to be completely managed by the , and not by the . In contrast, when the is re-created along with the in the activity's method (see call #13) the that get assigned to the adapter never have their or methods called at all. So when the refresh() method is called (see #17) the method iterates over these that have not been initialised. Therefore, when they try to populate the , the view's instance variable is . This is to be expected as the instance variable is only assigned in the method that never gets called on these .\n\nSo my question is: how does one properly make re-use of the re-recreated (by Android) after the screen orientation has changed in order to avoid creating new ones that don't get initialised? I need to have a valid reference to them, in order to call their refresh() method that populates them on-demand. Ideally, they should also be assigned to the as well.\n\nI hope I have been clear in describing the issue, and the reason that I have not provided sample code is because the problem (as can be seen) is not from the code itself but from a rather incorrect (seemigly) re-creation of Fragments rather than re-use. But if needed, I can give you sample code, I just through this way would be clearer."
    },
    {
        "link": "https://medium.com/@anna972606/activity-vs-fragment-lifecycle-e8735108cc87",
        "document": "Before diving into their lifecycles, let’s clarify what they are:\n\nActivity: Represents a single screen in an Android app. It’s the basic building block for user interaction.\n\nFragment: A modular part of an activity that has its own lifecycle and can be added, removed, or replaced at runtime.\n\nWhen to Use Activity vs Fragment in Android\n• Manages the lifecycle of the app.\n• Should be used for independent, self-contained screens.\n• Can be added, removed, or replaced dynamically.\n• Has its own lifecycle, but tied to the Activity’s lifecycle.\n\nThere are two primary methods to attach a fragment to an activity:\n\nDeclare the fragment in your activity’s layout XML:\n• : Replaces the existing Fragment in a container view with a new one.\n• : Adds the current transaction to the back stack, allowing users to navigate back to the previous Fragment.\n\nLet’s consider a basic app with three fragments:\n• Initial Fragment: The is added to the container when the activity starts (if there's no saved state).\n• Opening Profile: When the user wants to see their profile, the function is called.\n• The replaces the current fragment in the container.\n• The transaction is added to the back stack with the tag “profile”.\n\n3. Opening Settings: Similar to opening the profile, the function handles navigating to the settings screen.\n• When the user presses the back button, the top fragment in the back stack (either or ) is popped off, and the previous fragment is restored.\n• If there are no fragments left in the back stack, the activity finishes.\n• Fragment Transactions: Use to start a transaction, perform operations (add, replace), and commit it.\n• Back Stack: Use to save a transaction in the back stack for navigation.\n• Fragment Tags: Provide unique tags for fragments to identify them later if needed.\n• Fragment Lifecycle: Be aware of fragment lifecycle methods (onCreateView, onAttach, onDetach, etc.) for proper management.\n\nHere are some scenarios with diagrams.\n\nNote that it’s guaranteed that the Activity’s is executed before the Fragment’s. However, callbacks shown side by side — such as and — are executed in parallel and can therefore be called in either order. For example, the system might execute the Activity’s method before the Fragment’s method, but then execute the Fragment’s method before the Activity’s method.\n\nFragment state is saved and restored in very similar fashion to activity state. The difference is that there’s no in fragments, but the Bundle is available in the fragment’s , and .\n\nFragments can be retained, which means that the same instance is used on configuration change. As the next scenario shows, this changes the diagram slightly.\n\nThe fragment is not destroyed nor created after the rotation because the same fragment instance is used after the activity is recreated. The state bundle is still available in .\n\nUsing retained fragments is not recommended unless they are used to store data across configuration changes (in a non-UI fragment). This is what the ViewModel class from the Architecture Components library uses internally, but with a simpler API.\n\nThe lifecycle of s is quite simple: they have only one callback: . However, there’s a difference between scoping to an activity or to a fragment:\n\nNote that the initialization happens whenever you obtain the , which is normally done in .\n\nIf you find errors or you think something important is missing, please report them in the comments. Also, let us know what other scenarios you would like us to write about."
    },
    {
        "link": "https://developer.android.com/guide/fragments/transactions",
        "document": "At runtime, a can add, remove, replace, and perform other actions with fragments in response to user interaction. Each set of fragment changes that you commit is called a transaction, and you can specify what to do inside the transaction using the APIs provided by the class. You can group multiple actions into a single transaction—for example, a transaction can add or replace multiple fragments. This grouping can be useful for when you have multiple sibling fragments displayed on the same screen, such as with split views.\n\nYou can save each transaction to a back stack managed by the , allowing the user to navigate backward through the fragment changes—similar to navigating backward through activities.\n\nYou can get an instance of from the by calling , as shown in the following example:\n\nThe final call on each must commit the transaction. The call signals to the that all operations have been added to the transaction.\n\nAllow reordering of fragment state changes\n\nEach should use :\n\nFor behavior compatibility, the reordering flag is not enabled by default. It is required, however, to allow to properly execute your , particularly when it operates on the back stack and runs animations and transitions. Enabling the flag ensures that if multiple transactions are executed together, any intermediate fragments (i.e. ones that are added and then immediately replaced) do not go through lifecycle changes or have their animations or transitions executed. Note that this flag affects both the initial execution of the transaction and reversing the transaction with .\n\nTo add a fragment to a , call on the transaction. This method receives the ID of the container for the fragment, as well as the class name of the fragment you wish to add. The added fragment is moved to the state. It is strongly recommended that the container is a that is part of the view hierarchy.\n\nTo remove a fragment from the host, call , passing in a fragment instance that was retrieved from the fragment manager through or . If the fragment's view was previously added to a container, the view is removed from the container at this point. The removed fragment is moved to the state.\n\nUse to replace an existing fragment in a container with an instance of a new fragment class that you provide. Calling is equivalent to calling with a fragment in a container and adding a new fragment to that same container.\n\nThe following code snippet shows how you can replace one fragment with another:\n\nIn this example, a new instance of replaces the fragment, if any, that is currently in the layout container identified by .\n\nBy default, the changes made in a are not added to the back stack. To save those changes, you can call on the . For more information, see Fragment manager.\n\nCalling doesn't perform the transaction immediately. Rather, the transaction is scheduled to run on the main UI thread as soon as it is able to do so. If necessary, however, you can call to run the fragment transaction on your UI thread immediately.\n\nNote that is incompatible with . Alternatively, you can execute all pending submitted by calls that have not yet run by calling . This approach is compatible with .\n\nFor the vast majority of use cases, is all you need.\n\nThe order in which you perform operations within a is significant, particularly when using . This method applies the given animations to all fragment operations that follow it.\n\ncan affect the lifecycle state of individual fragments added within the scope of the transaction. When creating a , sets a maximum state for the given fragment. For example, uses to limit the off-screen fragments to the state.\n\nUse the methods and to show and hide the view of fragments that have been added to a container. These methods set the visibility of the fragment's views without affecting the lifecycle of the fragment.\n\nWhile you don't need to use a fragment transaction to toggle the visibility of the views within a fragment, these methods are useful for cases where you want changes to the visibility state to be associated with transactions on the back stack.\n\nThe method detaches the fragment from the UI, destroying its view hierarchy. The fragment remains in the same state ( ) as when it is put on the back stack. This means that the fragment was removed from the UI but is still managed by the fragment manager.\n\nThe method reattaches a fragment from which it was previously detached. This causes its view hierarchy to be recreated, attached to the UI, and displayed.\n\nAs a is treated as a single atomic set of operations, calls to both and on the same fragment instance in the same transaction effectively cancel each other out, thus avoiding the destruction and immediate recreation of the fragment's UI. Use separate transactions, separated by if using , if you want to detach and then immediately re-attach a fragment."
    },
    {
        "link": "https://developer.android.com/training/data-storage/shared-preferences",
        "document": "If you have a relatively small collection of key-values that you'd like to save, you can use the APIs. A object points to a file containing key-value pairs and provides simple methods to read and write them. Each file is managed by the framework and can be private or shared.\n\nThis page shows you how to use the APIs to store and retrieve simple values.\n\nCaution: is a modern data storage solution that you should use instead of . It builds on Kotlin coroutines and Flow, and overcomes many of the drawbacks of . is a modern data storage solution that you should use instead of. It builds on Kotlin coroutines and Flow, and overcomes many of the drawbacks of Read the DataStore guide for more information.\n\nYou can create a new shared preference file or access an existing one by calling one of these methods:\n• : Use this if you need multiple shared preference files identified by name, which you specify with the first parameter. You can call this from any in your app.\n• : Use this from an if you need to use only one shared preference file for the activity. Because this retrieves a default shared preference file that belongs to the activity, you don't need to supply a name.\n\nFor example, the following code accesses the shared preferences file that's identified by the resource string and opens it using the private mode so the file is accessible by only your app:\n\nWhen naming your shared preference files, you should use a name that's uniquely identifiable to your app. A good way to do this is prefix the file name with your application ID. For example:\n\nAlternatively, if you need just one shared preference file for your activity, you can use the method:\n\nIf you're using the API to save app settings, you should instead use to get the default shared preference file for your entire app. For more information, see the Settings developer guide.\n\nTo write to a shared preferences file, create a by calling on your .\n\nPass the keys and values you want to write with methods such as: and . Then call or to save the changes. For example:\n\nchanges the in-memory object immediately but writes the updates to disk asynchronously. Alternatively, you can use to write the data to disk synchronously. But because is synchronous, you should avoid calling it from your main thread because it could pause your UI rendering.\n\nTo retrieve values from a shared preferences file, call methods such as and , providing the key for the value you want, and optionally a default value to return if the key isn't present. For example:"
    },
    {
        "link": "https://developer.android.com/reference/android/content/SharedPreferences",
        "document": "Interface for accessing and modifying preference data returned by . For any particular set of preferences, there is a single instance of this class that all clients share. Modifications to the preferences must go through an object to ensure the preference values remain in a consistent state and control when they are committed to storage. Objects that are returned from the various methods must be treated as immutable by the application.\n\nSharedPreferences is best suited to storing data about how the user prefers to experience the app, for example, whether the user prefers a particular UI theme or whether they prefer viewing particular content in a list vs. a grid. To this end, SharedPreferences reflects changes or by s immediately, potentially before those changes are durably persisted. Under some circumstances such as app crashes or termination these changes may be lost, even if an reported the change was successful. SharedPreferences is not recommended for storing data that is sensitive to this kind of rollback to a prior state such as user security or privacy settings. For other high-level data persistence options, see Room or DataStore.\n\nNote: Common implementations guarantee that outstanding edits to preference files are persisted to disk when host Activities become stopped. In some situations (e.g. performing many or operations just prior to navigating away from the host Activity) this can lead to blocking the main thread during lifecycle transition events and associated ANR errors. For more details see the documentation for and .\n\nNote: This class does not support use across multiple processes."
    },
    {
        "link": "https://geeksforgeeks.org/shared-preferences-in-android-with-examples",
        "document": "One of the most Interesting Data Storage options Android provides its users is Shared Preferences. Shared Preferences is the way in which one can store and retrieve small amounts of primitive data as key/value pairs to a file on the device storage such as String, int, float, Boolean that make up your preferences in an XML file inside the app on the device storage. Shared Preferences can be thought of as a dictionary or a key/value pair. For example, you might have a key being “username” and for the value, you might store the user’s username. And then you could retrieve that by its key (here username). You can have a simple shared preference API that you can use to store preferences and pull them back as and when needed. The shared Preferences class provides APIs for reading, writing, and managing this data. A sample GIF is given below to get an idea about what we are going to do in this article.\n\nShared Preferences are suitable for different situations. For example, when the user’s settings need to be saved or to store data that can be used in different activities within the app. As you know, onPause() will always be called before your activity is placed in the background or destroyed, So for the data to be saved persistently, it’s preferred to save it in onPause(), which could be restored in onCreate() of the activity. The data stored using shared preferences are kept private within the scope of the application. However, shared preferences are different from that activity’s instance state.\n\nHow are Shared Preferences different from Saved Instance State?\n\nThe first thing we need to do is to create one shared preferences file per app. So name it with the package name of your app- unique and easy to associate with the app. When you want to get the values, call the getSharedPreferences() method. Shared Preferences provide modes of storing the data (private mode and public mode). It is for backward compatibility- use only MODE_PRIVATE to be secure.\n• SharedPreferences.Editor : Interface used to write(edit) data in the SP file. Once editing has been done, one must commit() apply() the changes made to the file.\n• SharedPreferences.OnSharedPreferenceChangeListener() : Called when a shared preference is changed, added, or removed. This may be called even if a preference is set to its existing value. This callback will be run on your main thread.\n• contains(String key) : This method is used to check whether the preferences contain a preference.\n• edit() : This method is used to create a new Editor for these preferences, through which you can make modifications to the data in the preferences and atomically commit those changes back to the SharedPreferences object.\n• getAll() : This method is used to retrieve all values from the preferences.\n• getBoolean(String key, boolean defValue) : This method is used to retrieve a boolean value from the preferences.\n• getFloat(String key, float defValue) : This method is used to retrieve a float value from the preferences.\n• getInt(String key, int defValue) : This method is used to retrieve an int value from the preferences.\n• getLong(String key, long defValue) : This method is used to retrieve a long value from the preferences.\n• getString(String key, String defValue) : This method is used to retrieve a String value from the preferences.\n• getStringSet(String key, Set defValues) : This method is used to retrieve a set of String values from the preferences.\n• registerOnSharedPreferencechangeListener(SharedPreferences.OnSharedPreferencechangeListener listener) : This method is used to register a callback to be invoked when a change happens to a preference.\n• unregisterOnSharedPreferencechangeListener(SharedPreferences.OnSharedPreferencechangeListener listener) : This method is used to unregister a previous callback.\n\nIf you don’t know how to create a new project in Android Studio then you can refer to How to Create/Start a New Project in Android Studio?\n\nBelow is the small demo for Shared Preferences. In this particular demo, there are two EditTexts, which save and retain the data entered earlier in them. This type of feature can be seen in applications with forms. Using Shared Preferences, the user will not have to fill in details again and again. Invoke the following code inside the activity_main.xml file to implement the UI.\n\nThis file will be used to handle the two of the EditText to save the data entered by the user inside the SharedPreferences. Below is the code for the MainActivity file. Comments are added inside the code to understand the code in more detail."
    },
    {
        "link": "https://stackoverflow.com/questions/6146106/where-are-shared-preferences-stored",
        "document": "Shared Preferences are the key/value pairs that we can store. They are internal type of storage which means we do not have to create an external database to store it. To see it go to, 1) Go to View in the menu bar. Select Tool Windows. 2) Click on Device File Explorer. 3) Device File Explorer opens up in the right hand side. 4) Find the data folder and click on it. 5) In the data folder, you can select another data folder. 6) Try to search for your package name in this data folder. Ex: com.example.com 7) Then Click on shared_prefs and open the .xml file."
    },
    {
        "link": "https://medium.com/@dobri.kostadinov/android-data-storage-sharedpreferences-room-and-datastore-compared-b7eb9f75ded5",
        "document": "Room is part of the Android Architecture Components and acts as an abstraction layer over SQLite, the persistent storage solution in Android. Unlike direct queries to SQLite, Room ensures SQL queries are checked at compile-time, reducing runtime errors and crashes due to incorrect SQL queries. It’s designed to fit into the architecture of an Android application, providing an easier way to handle database operations with less boilerplate code.\n\nRoom also facilitates observing data changes in the database with LiveData or Flow, allowing UI components to react to data changes more efficiently and reducing the chance of app crashes due to unhandled data states.\n\nTo start using Room, you need to include its dependencies in your file. Here's an updated version that uses a newer version of Room, assuming there have been updates since your initial version:\n\nEnsure you check for the latest version of Room to take advantage of new features and bug fixes.\n\nEntities represent tables in your app’s database. Each field in the entity class stands for a column in the table. The Room uses annotations to understand the structure of your tables and the relationships between them.\n\nHere’s a more detailed entity example that includes Room’s , , and annotations:\n\nIn this example, specifies the name of the table if you want it to be different from the class name. allows Room to automatically generate unique IDs for new rows.\n\nData Access Objects (DAOs) define the database interactions. They provide methods that your app can use to query, update, insert, and delete data in the database.\n\nIn this updated DAO, the method returns a list of users, which allows the UI to be notified of changes in the user data automatically. The strategy is specified for the insert operation to handle conflicts.\n\nFinally, you initialize the Room database in your application. It’s common to do this once and provide a singleton instance for the whole app to avoid unnecessary reinitializations.\n\nThis pattern ensures that your app uses a single instance of the database, reducing overhead and ensuring consistent access to your data.\n\nAdapting to changes in your app’s data model is crucial for its longevity. Room databases use versioning to manage schema updates and migrations to preserve data integrity as your application evolves.\n\nEach Room database is associated with a version number that reflects its schema configuration. When you modify the schema (e.g., changing tables, adding columns), you must increment this version number. This increment signals Room to execute migrations that adjust the existing database to the new schema.\n\nRoom’s class allows you to define the steps to migrate from one version to another. Here's how to add a new column to an existing table in Kotlin:\n\nIncorporate this migration when constructing your database instance:\n\nFor migrations that require data transformations or multiple sequential changes, you can chain migrations together or execute multiple steps within a single migration. Ensure every migration is thoroughly tested to maintain data integrity.\n\nDuring development, you might encounter scenarios where preserving old data isn’t necessary. For these cases, Room supports destructive migrations, which reset the database when the version changes — useful for quick iterations:\n\nExercise caution with this approach, and ensure it’s never used in your production environment.\n• Maintain Version History: Document your database schema versions and changes. This can help track evolution over time and assist in debugging.\n• Test Migrations: Implement comprehensive unit tests for your migrations to ensure no data is lost or corrupted during schema updates.\n• Provide Backup Options: Consider integrating backup and restore functionality within your app, allowing users to safeguard their data before major updates.\n\nBy carefully managing your database schema changes with well-planned migrations, your app can smoothly transition through updates, ensuring a consistent and reliable user experience.\n\nDataStore is a modern data storage solution designed by Google to overcome some of the limitations of SharedPreferences, providing a more robust and flexible way to store data persistently. It’s part of Android Jetpack and comes in two flavors: for storing key-value pairs (similar to SharedPreferences) and for storing typed objects using Protocol Buffers. Here’s why DataStore can be a better choice and how you can use it:\n\n1.3.1 Why DataStore is Better\n• Asynchronous by Nature: DataStore uses Kotlin coroutines and Flow to read and write data asynchronously, which helps in avoiding blocking the main thread and thus improves app performance.-\n• Safer Data Updates: Unlike SharedPreferences which operates on an in-memory object, DataStore provides transactional APIs with ACID properties, ensuring data integrity during read and write operations.\n• Data Consistency: DataStore files are safe from being accessed by multiple processes at once, reducing the risk of data corruption. This is a significant improvement over SharedPreferences.\n• Support for Default Values: DataStore preferences support default values directly in the data layer, making it easier to work with optional settings.\n• Type Safety with Proto DataStore: Proto DataStore uses Protocol Buffers, allowing for the storage of structured data and providing compile-time checks for schema correctness, which SharedPreferences cannot offer.\n\n1.3.2 Using DataStore in Your Application\n\nTo use DataStore, add its dependencies to your file. Make sure you have the latest versions:\n\nPreferences DataStore is used for storing simple key-value pairs.\n\nProto DataStore stores typed objects. First, define your data schema in a file, then use the generated classes in your DataStore.\n\nDataStore is a powerful tool for data storage in Android applications, offering improved safety, performance, and convenience over SharedPreferences. Its support for asynchronous operations and structured data makes it an excellent choice for modern Android development. For detailed information and updates, refer to the official Android documentation."
    },
    {
        "link": "https://developer.android.com/develop/ui/views/layout/declaring-layout",
        "document": "Save and categorize content based on your preferences.\n\nA layout defines the structure for a user interface in your app, such as in an activity. All elements in the layout are built using a hierarchy of and objects. A usually draws something the user can see and interact with. A is an invisible container that defines the layout structure for and other objects, as shown in figure 1.\n\nobjects are often called widgets and can be one of many subclasses, such as or . The objects are usually called layouts and can be one of many types that provide a different layout structure, such as or .\n\nYou can declare a layout in two ways:\n• Declare UI elements in XML. Android provides a straightforward XML vocabulary that corresponds to the classes and subclasses, such as those for widgets and layouts. You can also use Android Studio's Layout Editor to build your XML layout using a drag-and-drop interface.\n• Instantiate layout elements at runtime. Your app can create and objects and manipulate their properties programmatically.\n\nDeclaring your UI in XML lets you separate the presentation of your app from the code that controls its behavior. Using XML files also makes it easier to provide different layouts for different screen sizes and orientations. This is discussed further in Support different screen sizes.\n\nThe Android framework gives you the flexibility to use either or both of these methods to build your app's UI. For example, you can declare your app's default layouts in XML, and then modify the layout at runtime.\n\nUsing Android's XML vocabulary, you can quickly design UI layouts and the screen elements they contain, in the same way that you create web pages in HTML with a series of nested elements.\n\nEach layout file must contain exactly one root element, which must be a or object. After you define the root element, you can add additional layout objects or widgets as child elements to gradually build a hierarchy that defines your layout. For example, here's an XML layout that uses a vertical to hold a and a :\n\nAfter you declare your layout in XML, save the file with the extension in your Android project's directory so it properly compiles.\n\nFor more information about the syntax for a layout XML file, see Layout resource.\n\nWhen you compile your app, each XML layout file is compiled into a resource. Load the layout resource in your app's callback implementation. Do so by calling , passing it the reference to your layout resource in the form: . For example, if your XML layout is saved as , load it for your as follows:\n\nThe Android framework calls the callback method in your when the launches. For more information about activity lifecycles, see Introduction to activities.\n\nEvery and object supports its own variety of XML attributes. Some attributes are specific to a object. For example, supports the attribute. However, these attributes are also inherited by any objects that extend this class. Some are common to all objects, because they are inherited from the root class, like the attribute. Other attributes are considered layout parameters, which are attributes that describe certain layout orientations of the object, as defined by that object's parent object.\n\nAny object can have an integer ID associated with it to uniquely identify the within the tree. When the app is compiled, this ID is referenced as an integer, but the ID is typically assigned in the layout XML file as a string in the attribute. This is an XML attribute common to all objects, and it is defined by the class. You use it very often. The syntax for an ID inside an XML tag is the following:\n\nThe at symbol (@) at the beginning of the string indicates that the XML parser parses and expands the rest of the ID string and identifies it as an ID resource. The plus symbol (+) means this is a new resource name that must be created and added to your resources in the file.\n\nThe Android framework offers many other ID resources. When referencing an Android resource ID, you don't need the plus symbol, but you must add the package namespace as follows:\n\nThe package namespace indicates that you're referencing an ID from the resources class, rather than the local resources class.\n\nTo create views and reference them from your app, you can use a common pattern as follows:\n• Define a view in the layout file and assign it a unique ID, as in the following example:\n• Create an instance of the view object and capture it from the layout, typically in the method, as shown in the following example:\n\nDefining IDs for view objects is important when creating a . In a relative layout, sibling views can define their layout relative to another sibling view, which is referenced by the unique ID.\n\nAn ID doesn't need to be unique throughout the entire tree, but it must be unique within the part of the tree you search. It might often be the entire tree, so it's best to make it unique when possible.\n\nXML layout attributes named define layout parameters for the that are appropriate for the it resides in.\n\nEvery class implements a nested class that extends . This subclass contains property types that define the size and position of each child view, as appropriate for the view group. As shown in figure 2, the parent view group defines layout parameters for each child view, including the child view group.\n\nEvery subclass has its own syntax for setting values. Each child element must define a that is appropriate for its parent, though it might also define a different for its own children.\n\nAll view groups include a width and height, using and , and each view is required to define them. Many include optional margins and borders.\n\nYou can specify width and height with exact measurements, but you might not want to do this often. More often, you use one of these constants to set the width or height:\n• : tells your view to size itself to the dimensions required by its content.\n• : tells your view to become as big as its parent view group allows.\n\nIn general, we don't recommend specifying a layout width and height using absolute units such as pixels. A better approach is using relative measurements, such as density-independent pixel units (dp), , or , because it helps your app display properly across a variety of device screen sizes. The accepted measurement types are defined in Layout resource.\n\nA view has rectangular geometry. It has a location, expressed as a pair of left and top coordinates, and two dimensions, expressed as a width and height. The unit for location and dimensions is the pixel.\n\nYou can retrieve the location of a view by invoking the methods and . The former returns the left (x) coordinate of the rectangle representing the view. The latter returns the top (y) coordinate of the rectangle representing the view. These methods return the location of the view relative to its parent. For example, when returns 20, this means the view is located 20 pixels to the right of the left edge of its direct parent.\n\nIn addition, there are convenience methods to avoid unnecessary computations: namely and . These methods return the coordinates of the right and bottom edges of the rectangle representing the view. For example, calling is similar to the following computation: .\n\nThe size of a view is expressed with a width and height. A view has two pairs of width and height values.\n\nThe first pair is known as measured width and measured height. These dimensions define how big a view wants to be within its parent. You can obtain the measured dimensions by calling and .\n\nThe second pair is known as width and height, or sometimes drawing width and drawing height. These dimensions define the actual size of the view on screen, at drawing time and after layout. These values might, but don't have to, differ from the measured width and height. You can obtain the width and height by calling and .\n\nTo measure its dimensions, a view takes into account its padding. The padding is expressed in pixels for the left, top, right and bottom parts of the view. You can use padding to offset the content of the view by a specific number of pixels. For instance, a left padding of two pushes the view's content two pixels to the right of the left edge. You can set padding using the method and query it by calling , , , and .\n\nAlthough a view can define a padding, it doesn't support margins. However, view groups do support margins. See and for more information.\n\nFor more information about dimensions, see Dimension.\n\nBesides setting margins and padding programmatically, you can also set them in your XML layouts, as shown in the following example:\n\nThe preceding example shows margin and padding being applied. The has uniform margins and padding applied all around, and the shows how you can apply them independently to different edges.\n\nEach subclass of the class provides a unique way to display the views you nest within it. The most flexible layout type, and the one that provides the best tools for keeping your layout hierarchy shallow, is .\n\nThe following are some of the common layout types built into the Android platform.\n\nWhen the content for your layout is dynamic or not pre-determined, you can use or a subclass of . is generally the better option, because it uses memory more efficiently than .\n\nCommon layouts possible with and include the following:\n\noffers more possibilities and the option to create a custom layout manager.\n\nYou can populate an such as or by binding the instance to an , which retrieves data from an external source and creates a that represents each data entry.\n\nAndroid provides several subclasses of that are useful for retrieving different kinds of data and building views for an . The two most common adapters are:\n\nIf during the course of your app's life you change the underlying data that is read by your adapter, call . This notifies the attached view that the data has been changed and it refreshes itself.\n\nYou can respond to click events on each item in an by implementing the interface. For example:\n\nSee how layouts are used in the Sunflower demo app on GitHub."
    },
    {
        "link": "https://developer.android.com/studio/write/layout-editor",
        "document": "Stay organized with collections Save and categorize content based on your preferences.\n\nThe Layout Editor enables you to quickly build -based layouts by dragging UI elements into a visual design editor instead of writing layout XML. The design editor can preview your layout on different Android devices and versions, and you can dynamically resize the layout to be sure it works properly on different screen sizes.\n\nThe Layout Editor is especially powerful when building a layout with .\n\nThis page provides an overview of the Layout Editor. To learn more about layout fundamentals, see Layouts.\n\nThe Layout Editor appears when you open an XML layout file.\n• Palette: contains various views and view groups that you can drag into your layout.\n• Component Tree: shows the hierarchy of components in your layout.\n• Toolbar: has buttons that configure your layout appearance in the editor and change layout attributes.\n• Design editor: lets you edit your layout in Design view, Blueprint view, or both.\n• Attributes: has controls for the selected view's attributes.\n• View mode: lets you view your layout in either Code , Split , or Design modes. Split mode shows the Code and Design windows at the same time.\n• Zoom and pan controls: control the preview size and position within the editor.\n\nWhen you open an XML layout file, the design editor opens by default, as shown in figure 1. To edit the layout XML in the text editor, click the Code button in the top-right corner of the window. Note that the Palette, Component Tree, and Attributes panels are not available while editing your layout in Code view.\n\nTip: To switch between design and text editors, press ( on macOS) plus and the right or left arrow key.\n\nThe buttons in the top row of the design editor let you configure the appearance of your layout in the editor.\n• Design and Blueprint: Select how you want to view your layout in the editor. You can also press to cycle through these view types.\n• Choose Design to see a rendered preview of your layout.\n• Choose Blueprint to see only outlines for each view.\n• Choose Design + Blueprint to see both views side by side.\n• Screen orientation and layout variants: Choose between landscape or portrait screen orientation or choose other screen modes that your app provides alternative layouts for, such as night mode. This menu also contains commands for creating a new layout variant, as described in a section on this page. You can also press the letter on your keyboard to change orientation.\n• None System UI Mode: If you've enabled dynamic color in your app, switch wallpapers and see how your layouts react to different users chosen wallpaper. Note that you must first change the theme to a Material dynamic color theme, then change the wallpaper.\n• None Device type and size: Select the device type (phone/tablet, Android TV, or Wear OS) and screen configuration (size and density). You can select from several pre-configured device types and your own AVD definitions, and you can create a new AVD by selecting Add Device Definition from the list, as shown in figure 3.\n• To resize the device, drag the bottom-right corner of the layout.\n• Press to cycle through the device list. Testing your layout against the Reference Devices in this menu helps your app scale well to layout states on real devices.\n• None API version: Select the version of Android to preview your layout. The list of available Android versions depends on which SDK platform versions you have installed using SDK Manager.\n• None App theme: Select which UI theme to apply to the preview. This works only for supported layout styles, so many themes in this list result in an error.\n• None Language: Select the language to show for your UI strings. This list displays only the languages available in your string resources. If you'd like to edit your translations, click Edit Translations from the menu. For more information on working with translations, see Localize the UI with Translations Editor.\n\nWhen adding a new layout for your app, first create a default layout file in your project's default directory so that it applies to all device configurations. Once you have a default layout, you can create layout variations, as described in a section on this page, for specific device configurations, such as for large screens.\n\nYou can create a new layout in one of the following ways:\n• In the Project window, click the module you want to add a layout to.\n• In the main menu, select File > New > XML > Layout XML File.\n• In the dialog that appears, provide the filename, the root layout tag, and the source set where the layout belongs.\n• Choose the Project view from within the Project window.\n• Right-click the layout directory where you'd like to add the layout.\n• In the context menu that appears, click New > Layout Resource File.\n• Choose the Android view from within the Project window.\n• In the context menu that appears, select New > Layout Resource File.\n• In the Resource Manager, select the Layout tab.\n• Click the button, and then click Layout Resource File.\n\nUse layout variants to optimize for different screens\n\nA layout variant is an alternative version of an existing layout that is optimized for a certain screen size or orientation.\n\nAndroid Studio includes common layout variants that you can use in your project. To use a suggested layout variant, do the following:\n• Click the Design icon in the top-right corner of the window.\n• The name of the layout file appears in the Action to switch and create qualifiers for layout files drop-down. Select the drop-down.\n• In the drop-down list, select a variant such as Create Landscape Qualifier or Create Tablet Qualifier.\n\nIf you'd like to create your own layout variant, do the following:\n• Click the Design icon in the top-right corner of the window.\n• The name of the layout file appears in the Action to switch and create qualifiers for layout files drop-down. Select the drop-down.\n• None In the drop-down list, select Add Resource Qualifier. (See figure 4 above.)\n• None In the Select Resource Directory dialog, define the resource qualifiers for the variant:\n• Select a qualifier from the Available qualifiers list.\n• Repeat these steps to add other qualifiers.\n• None Once you've added all of your qualifiers, click OK.\n\nWhen you have multiple variations of the same layout, you can switch between them by selecting a variant from the Action to switch and create qualifiers for layout files drop-down.\n\nFor more information about how to create layouts for different displays, see Support different display sizes.\n\nYou can convert a view to another kind of view, and you can convert a layout to another kind of layout:\n• Click the Design button in the top-right corner of the editor window.\n• In the Component Tree, right-click the view or layout, and then click Convert view.\n• In the dialog that appears, choose the new type of view or layout, and then click Apply.\n\nFor improved layout performance, convert older layouts to . uses a constraint-based layout system that lets you build most layouts without any nested view groups.\n\nTo convert an existing layout to a , do the following:\n• Click the Design icon in the top-right corner of the editor window.\n• In the Component Tree, right-click the layout, and then click Convert to ConstraintLayout.\n\nTo learn more about , see Build a Responsive UI with ConstraintLayout.\n\nTo search for a view or view group by name in the Palette, click the Search button at the top of the palette. Alternatively, you can type the name of the item whenever the Palette window has focus.\n\nIn the Palette, you can find frequently used items in the Common category. To add an item to this category, right-click a view or view group in the Palette and then click Favorite in the context menu.\n\nTo open the Android Developers reference documentation for a view or view group, select the UI element in the Palette and press + .\n\nTo view Material Guidelines documentation for a view or view group, right-click the UI element in the Palette and select Material Guidelines from the context menu. If no specific entry exists for the item, then the command opens the homepage of the Material Guidelines documentation.\n\nTo start building your layout, drag views and view groups from the Palette into the design editor. As you place a view in the layout, the editor displays information about the view's relationship with the rest of the layout.\n\nIf you are using , you can automatically create constraints using the Infer Constraints and Autoconnect features.\n\nYou can edit view attributes from the Attributes panel in the Layout Editor. This window is available only when the design editor is open, so view your layout in either Design or Split mode to use it.\n\nWhen you select a view, whether by clicking the view in the Component Tree or in the design editor, the Attributes panel shows the following, as indicated in figure 5:\n• Declared Attributes: Lists attributes specified in the layout file. To add an attribute, click the Add button at the top of the section.\n• Layout: Contains controls for the width and height of the view. If the view is in a , this section also shows constraint bias and lists the constraints that the view uses. For more information on controlling the size of views with , see Adjust the view size.\n• Common Attributes: Lists common attributes for the selected view. To see all available attributes, expand the All Attributes section at the bottom of the window.\n• None The icons to the right of each attribute value indicate whether the attribute values are resource references. These indicators are solid when the value is a resource reference and empty when the value is hardcoded to help you recognize hardcoded values at a glance. Click indicators in either state to open the Resources dialog, where you can select a resource reference for the corresponding attribute.\n• None A red highlight around an attribute value indicates an error with the value. For example, an error might indicate an invalid entry for a layout-defining attribute. An orange highlight indicates a warning for the value. For example, a warning might appear when you use a hardcoded value where a resource reference is expected.\n\nBecause many Android layouts rely on runtime data, it can be difficult to visualize the look and feel of a layout while designing your app. You can add sample preview data to a , an , or a from within the Layout Editor.\n\nTo display the Design-time View Attributes window, right-click one of these view types and choose Set Sample Data, as shown in figure 6.\n\nFor a , you can choose between different sample text categories. When using sample text, Android Studio populates the attribute of the with your chosen sample data. Note that you can choose sample text via the Design-time View Attributes window only if the attribute is empty.\n\nFor an , you can choose between different sample images. When you choose a sample image, Android Studio populates the attribute of the (or if using AndroidX).\n\nFor a , you can choose from a set of templates that contain sample images and texts. When using these templates, Android Studio adds a file to your directory, , that contains the layout for the sample data. Android Studio also adds metadata to the to properly display the sample data.\n\nThe Layout Editor notifies you of any layout issues next to the corresponding view in the Component Tree by using a red circle exclamation icon for errors or an orange triangle exclamation icon for warnings. Click the icon to see more details.\n\nTo see all known issues in a window below the editor, click Show Warnings and Errors ( or ) in the toolbar.\n\nDownload fonts and apply them to text\n\nWhen using Android 8.0 (API level 26) or the Jetpack Core library, you can select from hundreds of fonts by following these steps:\n• In the Layout Editor, click the Design icon to view your layout in the design editor.\n• In the Attributes panel, expand textAppearance, and then expand the fontFamily box.\n• Scroll to the bottom of the list and click More Fonts to open the Resources dialog.\n• In the Resources dialog, to select a font, browse the list or type into the search bar at the top. If you select a font under Downloadable, then you can either click Create downloadable font to load the font at runtime as a downloadable font or click Add font to project to package the TTF font file in your APK. The fonts listed under Android are provided by the Android system, so they don't need to be downloaded or bundled in your APK.\n\nLayout Validation is a visual tool for simultaneously previewing layouts for different devices and display configurations, helping you catch problems in your layouts earlier in the process. To access this feature, click the Layout Validation tab in the top-right corner of the IDE window:\n\nTo switch between the available configuration sets, select one of the following from the Reference Devices drop-down at the top of the Layout Validation window:\n\nReference devices are a set of devices that we recommend you test against. They include phone, foldable, tablet, and desktop interfaces. You should preview how your layout appears on this set of reference devices:\n\nTo customize a display configuration to preview, choose from a variety of settings including language, device, or screen orientation:\n\nTo help make your app more accessible for users who are color blind, validate your layout with simulations of common types of color blindness:\n\nValidate your layouts at various font sizes, and improve your app's accessibility for visually impaired users by testing your layouts with larger fonts:"
    },
    {
        "link": "https://stackoverflow.com/questions/9827819/best-practices-layouts-on-android-programmatic-vs-xml",
        "document": "The answer very much depends on your needs, flexibility, and knowledge. The first thing to understand is that every Layout, whether created via XML or programmatically can be tweaked specifically or made to conform to many screens via properties.\n\nYes, it is. Android makes those available so you can do just that. However, the benefits of managing layouts via XML include standard MVC segregation, simpler debugging, and an easier time modifying the resource, if needed. Additionally, you may maintain multiple copies of Layouts depending on device configuration easily.\n\nAbsolutely! There are some amazing programs that fully utilize XML rather than programmatic views. The key to them is how much information (that is non-standard view properties) is required from parental Views. Even in those cases there are ways to pass that information provided you know where and how to do so.\n\nI don't think so. Honestly, I've run both ways depending on need. I'd say it really comes down to your lack of knowledge of the quirks. But the job is to get the job done. Here's an example: There are some times when I don't know how big everything needs to be until its run on the device, and there are times that I make the device conform to my layout's needs. Ultimately, I use the following chart to make my determinations.\n• Do I need information from parental Layouts that is aside from view properties\n• Do I need to dynamically size more than one element independently.\n• Is the View type pre-determined or will it change as well?\n\nIf the answer to 2 out of 3 of those is \"yes\", I will use some level of programmatic layout. If not, I will go pure XML. That being said, programming is one of those professions that encourages ingenuity (provided it is safe) and nearly anything can be accomplished in any number of ways. Ultimately, I'd say do whatever makes your job making quality apps easier.\n\nGoogle makes its recommendations based on their own knowledge of software programmers and their general practices. They also created the platform, so they know which things are optimized in which ways. Its all about experience and we all have our own. If you have trouble utilizing XML, its worth taking the time to figure out the quirks simply so that it is another tool to utilize. Also, it will give you the information you need to answer this question for yourself.\n\nTo sum things up: I could say chocolate is better, but if you like vanilla, you'll disagree. Be aware of the drawbacks and benefits of each and take the time to learn how to accomplish the same tasks with both methods. It will make you a better programmer and give you a better sense of when to use which technique."
    },
    {
        "link": "https://quickstart.com/blog/app-development/user-interface-best-practices-for-android-developers",
        "document": "What is User Interface? Well to simply put it, it is everything you see when you start an app. An app is only good if the user is able to interact with it fully without facing any sort of problems. The user interface is everything that your user interacts with on the app, so clearly it is one of the most important aspects to looks into when creating an app.\n\nWhat makes a good user interface? If only it were that simple, a one liner that could explain everything, but sadly it is a bit more complicated than that. People go through a lot of app development training just to understand the basics of User Interface and how one can make it almost perfect.\n\nHere are some of the best practices for Android Developers when considering building a good user interface:\n\nSo many devices and so many screens to keep in mind. Android is an OS that is not only limited to tablets and smart phones, but is now heavily used in smart TVs too which means, more screens to keep in mind when designing your own app.\n\nAnother important thing to keep in mind is that your app supports different screen densities. To make your compatible with all types of screen densities, it is a good practice to not use absolute pixels to define size and distance. So it is better to use the “dp” or “sp” units to specify dimensions. “dp” are density independent pixels which responds to the actually physical size of a pixel according to 160dpi. “sp” is a unit that works in a similar way, but scales according to the user’s set text size. Use these units when defining text size, but not for layout design.\n\nFor different screens you should also have different adaptive UI flows. For different layouts, the UI flow may vary. As an example let’s suppose the app is in the dual pane mode. The left pane item will display an item in the right pane. In case of single pane, the content will display on its own.\n\nYour UI Should Be Responsive With A Constraint Layout\n\nConstraint Layouts are very helpful in creating layouts that are considerably large, complex, and based in a flat-view hierarchy. It’s just like a relative layout, but all the views are shown in accordance with parent layout and sibling views.\n\nWhen you learn android development, the first thing you will be taught is to make sure the user gets everything done through the minimum amount of clicks. An App bar which also may be referred to as the action bar is one of the key elements that guides the user through the main pages and aspects of your app without the user having to switch a lot between windows. With interactive elements familiar to users, it become very easy for them to navigate throughout the app.\n• A specific space that should both display the identity of your app and show the user where they are in the app.\n• A search bar which allows the user to navigate through the app at will.\n• The bar should be able to support different tabs opened in the app.\n\nWhen creating custom views, your android training will always put specific stress on one thing, good design. It integrates both an easy to use interface and a set of functionality that caters to all new and veteran app users. The custom view should be able to use you’re the devices memory and CPU efficiently so it is quick in loading and getting the job done for the user.\n\nThe main elements that should be present in the custom view are:\n• The view should be according to android app standards. This will aid users while using the app as it would be a familiar kind of interface.\n• You can stylize your attributes, but they should be compatible with Android XML layouts.\n• It should be compatible on several android platforms.\n\nUI design undoubtedly is one of the key components that make or break your app. There are thousands of apps coming out on android every day, but most don’t make the top downloaded page because they don’t have the proper interface to qualify as a good app. App development training can teach one a lot about proper UI implementation and design to help a developer perfect themselves in UI design. With proper training, you won’t just develop UI, you will innovate."
    },
    {
        "link": "https://stackoverflow.com/questions/11876705/designing-xml-layouts-for-different-screen-android",
        "document": "I am working on a small app, with 3 buttons on left corner(Vertically) and a edit box which covers rest of the screen.\n\nI want to run this app to be able to work on all screen resolutions. So I have used Relative layout, linear layout and Android:weight for buttons, which equally share the size of the buttons and works fine.\n\nMy Question is am I doing it wrong?\n\nShould we design different layouts for different screens or using same layout out but adding properties like weight and padding is fine??"
    }
]