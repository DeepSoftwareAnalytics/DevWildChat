[
    {
        "link": "https://playwright.dev/docs/api/class-browsercontext",
        "document": "If a page opens another page, e.g. with a call, the popup will belong to the parent page's browser context.\n\nPlaywright allows creating isolated non-persistent browser contexts with browser.newContext() method. Non-persistent browser contexts don't write any browsing data to disk.\n\nAdds cookies into this browser context. All pages within this context will have these cookies installed. Cookies can be obtained via browserContext.cookies().\n• Array<Object>#\n• Either url or domain / path are required. Optional.\n• For the cookie to apply to all subdomains as well, prefix domain with a dot, like this: \".example.com\". Either url or domain / path are required. Optional.\n• Either url or domain / path are required Optional.\n\nAdds a script which would be evaluated in one of the following scenarios:\n• Whenever a page is created in the browser context or is navigated.\n• Whenever a child frame is attached or navigated in any page in the browser context. In this case, the script is evaluated in the context of the newly attached frame.\n\nThe script is evaluated after the document was created but before any of its scripts were run. This is useful to amend the JavaScript environment, e.g. to seed .\n\nAn example of overriding before the page loads:\n• \n• Path to the JavaScript file. If is a relative path, then it is resolved relative to the current working directory. Optional. Script to be evaluated in all pages in the browser context.\n• Optional argument to pass to script (only supported when passing a function).\n\nAll existing background pages in the context.\n\nReturns the browser instance of the context. If it was launched as a persistent context null gets returned.\n• Object (optional)\n• Only removes cookies with the given domain.\n• Only removes cookies with the given name.\n• Only removes cookies with the given path.\n\nClears all permission overrides for the browser context.\n\nCloses the browser context. All the pages that belong to the browser context will be closed.\n• Object (optional)\n• The reason to be reported to the operations interrupted by the context closure.\n\nIf no URLs are specified, this method returns all cookies. If URLs are specified, only cookies that affect those URLs are returned.\n\nThe method adds a function called name on the object of every frame in every page in the context. When called, the function executes callback and returns a Promise which resolves to the return value of callback. If the callback returns a Promise, it will be awaited.\n\nThe first argument of the callback function contains information about the caller: .\n\nAn example of exposing page URL to all frames in all pages in the context:\n• Name of the function on the window object.\n• Callback function that will be called in the Playwright's context.\n• \n• This option will be removed in the future. Whether to pass the argument as a handle, instead of passing by value. When passing a handle, only one argument is supported. When passing by value, multiple arguments are supported.\n\nThe method adds a function called name on the object of every frame in every page in the context. When called, the function executes callback and returns a Promise which resolves to the return value of callback.\n\nIf the callback returns a Promise, it will be awaited.\n\nAn example of adding a function to all pages in the context:\n• Name of the function on the window object.\n• Callback function that will be called in the Playwright's context.\n\nGrants specified permissions to the browser context. Only grants corresponding permissions to the given origin if specified.\n• Supported permissions differ between browsers, and even between different versions of the same browser. Any permission may stop working after an update. Here are some permissions that may be supported by some browsers:\n• \n• The origin to grant permissions to, e.g. \"https://example.com\".\n• Target to create new session for. For backwards-compatibility, this parameter is named , but it can be a or type.\n\nCreates a new page in the browser context.\n\nReturns all open pages in the context.\n\nRemoves all the listeners of the given type (or all registered listeners if no type given). Allows to wait for async listeners to complete or to ignore subsequent errors from these listeners.\n• Object (optional)\n• Specifies whether to wait for already running listeners and what to do if they throw errors:\n• - do not wait for current listener calls (if any) to finish, if the listener throws, it may result in unhandled error\n• - wait for current listener calls (if any) to finish\n• - do not wait for current listener calls (if any) to finish, all errors thrown by the listeners after removal are silently caught\n\nRouting provides the capability to modify network requests that are made by any page in the browser context. Once route is enabled, every request matching the url pattern will stall unless it's continued, fulfilled or aborted.\n\nAn example of a naive handler that aborts all image requests:\n\nor the same snippet using a regex pattern instead:\n\nIt is possible to examine the request to decide the route action. For example, mocking all requests that contain some post data, and leaving all other requests as is:\n\nPage routes (set up with page.route()) take precedence over browser context routes when request matches both handlers.\n\nTo remove a route with its handler you can use browserContext.unroute().\n• A glob pattern, regex pattern or predicate receiving URL to match while routing. When a baseURL via the context options was provided and the passed URL is a path, it gets merged via the constructor.\n• \n• How often a route should be used. By default it will be used every time.\n\nIf specified the network requests that are made in the context will be served from the HAR file. Read more about Replaying from HAR.\n\nPlaywright will not serve requests intercepted by Service Worker from the HAR file. See this issue. We recommend disabling Service Workers when using request interception by setting serviceWorkers to .\n• Path to a HAR file with prerecorded network data. If is a relative path, then it is resolved relative to the current working directory.\n• \n• \n• If set to 'abort' any request not found in the HAR file will be aborted.\n• If set to 'fallback' falls through to the next route handler in the handler chain.\n• If specified, updates the given HAR with the actual network information instead of serving from file. The file is written to disk when browserContext.close() is called.\n• Optional setting to control resource content management. If is specified, resources are persisted as separate files or entries in the ZIP archive. If is specified, content is stored inline the HAR file.\n• When set to , only record information necessary for routing from HAR. This omits sizes, timing, page, cookies, security and other types of HAR information that are not used when replaying from HAR. Defaults to .\n• A glob pattern, regular expression or predicate to match the request URL. Only requests with URL matching the pattern will be served from the HAR file. If not specified, all requests are served from the HAR file.\n\nThis method allows to modify websocket connections that are made by any page in the browser context.\n\nNote that only s created after this method was called will be routed. It is recommended to call this method before creating any pages.\n\nBelow is an example of a simple handler that blocks some websocket messages. See WebSocketRoute for more details and examples.\n• Only WebSockets with the url matching this pattern will be routed. A string pattern can be relative to the baseURL context option.\n\nAll existing service workers in the context.\n\nThis setting will change the default maximum navigation time for the following methods and related shortcuts:\n\nThis setting will change the default maximum time for all the methods accepting timeout option.\n\nThe extra HTTP headers will be sent with every request initiated by any page in the context. These headers are merged with page-specific extra HTTP headers set with page.setExtraHTTPHeaders(). If page overrides a particular header, page-specific header value will be used instead of the browser context header value.\n• An object containing additional HTTP headers to be sent with every request. All header values must be strings.\n• Whether to emulate network being offline for the browser context.\n\nReturns storage state for this browser context, contains current cookies, local storage snapshot and IndexedDB snapshot.\n• Object (optional)\n• Set to to include IndexedDB in the storage state snapshot. If your application uses IndexedDB to store authentication tokens, like Firebase Authentication, enable this. IndexedDBs with typed arrays are currently not supported.\n• The file path to save the storage state to. If path is a relative path, then it is resolved relative to current working directory. If no path is provided, storage state is still returned, but won't be saved to the disk.\n\nRemoves a route created with browserContext.route(). When handler is not specified, removes all routes for the url.\n• A glob pattern, regex pattern or predicate receiving URL used to register a routing with browserContext.route().\n• Optional handler function used to register a routing with browserContext.route().\n\nRemoves all routes created with browserContext.route() and browserContext.routeFromHAR().\n• Object (optional)\n• Specifies whether to wait for already running handlers and what to do if they throw errors:\n• - do not wait for current handler calls (if any) to finish, if unrouted handler throws, it may result in unhandled error\n• - wait for current handler calls (if any) to finish\n• - do not wait for current handler calls (if any) to finish, all errors thrown by the handlers after unrouting are silently caught\n\nWaits for event to fire and passes its value into the predicate function. Returns when the predicate returns truthy value. Will throw an error if the context closes before the event is fired. Returns the event data value.\n• Event name, same one would pass into .\n• \n• Receives the event data and resolves to truthy value when the waiting should resolve.\n• Maximum time to wait for in milliseconds. Defaults to - no timeout. The default value can be changed via option in the config, or by using the browserContext.setDefaultTimeout() method. Either a predicate that receives an event or an options object. Optional.\n• \n• Receives the event data and resolves to truthy value when the waiting should resolve.\n\nPlaywright has ability to mock clock and passage of time.\n\nAPI testing helper associated with this context. Requests made with this API will use context cookies.\n\nEmitted when new background page is created in the context.\n\nEmitted when Browser context gets closed. This might happen because of one of the following:\n\nEmitted when JavaScript within the page calls one of console API methods, e.g. or .\n\nThe arguments passed into and the page are available on the ConsoleMessage event handler argument.\n\nEmitted when a JavaScript dialog appears, such as , , or . Listener must either dialog.accept() or dialog.dismiss() the dialog - otherwise the page will freeze waiting for the dialog, and actions like click will never finish.\n\nThe event is emitted when a new Page is created in the BrowserContext. The page may still be loading. The event will also fire for popup pages. See also page.on('popup') to receive events about popups relevant to a specific page.\n\nThe earliest moment that page is available is when it has navigated to the initial url. For example, when opening a popup with , this event will fire when the network request to \"http://example.com\" is done and its response has started loading in the popup. If you would like to route/listen to this network request, use browserContext.route() and browserContext.on('request') respectively instead of similar methods on the Page.\n\nEmitted when a request is issued from any pages created through this context. The request object is read-only. To only listen for requests from a particular page, use page.on('request').\n\nIn order to intercept and mutate requests, see browserContext.route() or page.route().\n\nEmitted when a request fails, for example by timing out. To only listen for failed requests from a particular page, use page.on('requestfailed').\n\nEmitted when a request finishes successfully after downloading the response body. For a successful response, the sequence of events is , and . To listen for successful requests from a particular page, use page.on('requestfinished').\n\nEmitted when response status and headers are received for a request. For a successful response, the sequence of events is , and . To listen for response events from a particular page, use page.on('response').\n\nEmitted when new service worker is created in the context.\n\nEmitted when exception is unhandled in any of the pages in this context. To listen for errors from a particular page, use page.on('pageerror') instead."
    },
    {
        "link": "https://playwright.dev/docs/api/class-browsertype",
        "document": "BrowserType provides methods to launch a specific browser instance or connect to an existing one. The following is a typical example of using Playwright to drive automation:\n\nThis method attaches Playwright to an existing browser instance created via in Node.js.\n• A Playwright browser websocket endpoint to connect to. You obtain this endpoint via .\n• \n• This option exposes network available on the connecting client to the browser being connected to. Consists of a list of rules separated by comma.\n• Additional HTTP headers to be sent with web socket connect request. Optional.\n• Slows down Playwright operations by the specified amount of milliseconds. Useful so that you can see what is going on. Defaults to 0.\n• Maximum time in milliseconds to wait for the connection to be established. Defaults to (no timeout).\n\nThis method attaches Playwright to an existing browser instance using the Chrome DevTools Protocol.\n\nThe default browser context is accessible via browser.contexts().\n• A CDP websocket endpoint or http url to connect to. For example or .\n• \n• Deprecated, use the first argument instead. Optional.\n• Additional HTTP headers to be sent with connect request. Optional.\n• Slows down Playwright operations by the specified amount of milliseconds. Useful so that you can see what is going on. Defaults to 0.\n• Maximum time in milliseconds to wait for the connection to be established. Defaults to (30 seconds). Pass to disable timeout.\n\nYou can use ignoreDefaultArgs to filter out from default arguments:\n\nChromium-only Playwright can also be used to control the Google Chrome or Microsoft Edge browsers, but it works best with the version of Chromium it is bundled with. There is no guarantee it will work with any other version. Use executablePath option with extreme caution. If Google Chrome (rather than Chromium) is preferred, a Chrome Canary or Dev Channel build is suggested. Stock browsers like Google Chrome and Microsoft Edge are suitable for tests that require proprietary media codecs for video playback. See this article for other differences between Chromium and Chrome. This article describes some differences for Linux users.\n• Object (optional)\n• Use custom browser args at your own risk, as some of them may break Playwright functionality. Additional arguments to pass to the browser instance. The list of Chromium flags can be found here.\n• Use \"chromium\" to opt in to new headless mode. Use \"chrome\", \"chrome-beta\", \"chrome-dev\", \"chrome-canary\", \"msedge\", \"msedge-beta\", \"msedge-dev\", or \"msedge-canary\" to use branded Google Chrome and Microsoft Edge.\n• Chromium-only Whether to auto-open a Developer Tools panel for each tab. If this option is , the headless option will be set .\n• If specified, accepted downloads are downloaded into this directory. Otherwise, temporary directory is created and is deleted when browser is closed. In either case, the downloads are deleted when the browser context they were created in is closed.\n• Specify environment variables that will be visible to the browser. Defaults to .\n• Path to a browser executable to run instead of the bundled one. If executablePath is a relative path, then it is resolved relative to the current working directory. Note that Playwright only works with the bundled Chromium, Firefox or WebKit, use at your own risk.\n• Firefox user preferences. Learn more about the Firefox user preferences at .\n• Close the browser process on SIGHUP. Defaults to .\n• Close the browser process on Ctrl-C. Defaults to .\n• Close the browser process on SIGTERM. Defaults to .\n• Whether to run browser in headless mode. More details for Chromium and Firefox. Defaults to unless the devtools option is .\n• If , Playwright does not pass its own configurations args and only uses the ones from args. If an array is given, then filters out the given default arguments. Dangerous option; use with care. Defaults to .\n• \n• Proxy to be used for all requests. HTTP and SOCKS proxies are supported, for example or . Short form is considered an HTTP proxy.\n• Optional comma-separated domains to bypass proxy, for example .\n• Optional username to use if HTTP proxy requires authentication.\n• Optional password to use if HTTP proxy requires authentication.\n• Slows down Playwright operations by the specified amount of milliseconds. Useful so that you can see what is going on.\n• Maximum time in milliseconds to wait for the browser instance to start. Defaults to (30 seconds). Pass to disable timeout.\n• If specified, traces are saved into this directory.\n\nLaunches browser that uses persistent storage located at userDataDir and returns the only context. Closing this context will automatically close the browser.\n• Path to a User Data Directory, which stores browser session data like cookies and local storage. More details for Chromium and Firefox. Note that Chromium's user data directory is the parent directory of the \"Profile Path\" seen at . Pass an empty string to use a temporary directory instead.\n• \n• Whether to automatically download all the attachments. Defaults to where all the downloads are accepted.\n• Use custom browser args at your own risk, as some of them may break Playwright functionality. Additional arguments to pass to the browser instance. The list of Chromium flags can be found here.\n• When using page.goto(), page.route(), page.waitForURL(), page.waitForRequest(), or page.waitForResponse() it takes the base URL in consideration by using the constructor for building the corresponding URL. Unset by default. Examples:\n• baseURL: and navigating to results in\n• baseURL: and navigating to results in\n• baseURL: (without trailing slash) and navigating to results in\n• Use \"chromium\" to opt in to new headless mode. Use \"chrome\", \"chrome-beta\", \"chrome-dev\", \"chrome-canary\", \"msedge\", \"msedge-beta\", \"msedge-dev\", or \"msedge-canary\" to use branded Google Chrome and Microsoft Edge.\n• \n• Exact origin that the certificate is valid for. Origin includes protocol, a hostname and optionally a port.\n• Path to the file with the certificate in PEM format.\n• Direct value of the certificate in PEM format.\n• Path to the file with the private key in PEM format.\n• Direct value of the private key in PEM format.\n• Path to the PFX or PKCS12 encoded private key and certificate chain.\n• Direct value of the PFX or PKCS12 encoded private key and certificate chain.\n• Passphrase for the private key (PEM or PFX). TLS Client Authentication allows the server to request a client certificate and verify it. An array of client certificates to be used. Each certificate object must have either both and , a single , or their corresponding direct value equivalents ( and , or ). Optionally, property should be provided if the certificate is encrypted. The property should be provided with an exact match to the request origin that the certificate is valid for. When using WebKit on macOS, accessing will not pick up client certificates. You can make it work by replacing with .\n• Emulates prefers-colors-scheme media feature, supported values are and . See page.emulateMedia() for more details. Passing resets emulation to system defaults. Defaults to .\n• Emulates media feature, supported values are , . See page.emulateMedia() for more details. Passing resets emulation to system defaults. Defaults to .\n• Specify device scale factor (can be thought of as dpr). Defaults to . Learn more about emulating devices with device scale factor.\n• Chromium-only Whether to auto-open a Developer Tools panel for each tab. If this option is , the headless option will be set .\n• If specified, accepted downloads are downloaded into this directory. Otherwise, temporary directory is created and is deleted when browser is closed. In either case, the downloads are deleted when the browser context they were created in is closed.\n• Specify environment variables that will be visible to the browser. Defaults to .\n• Path to a browser executable to run instead of the bundled one. If executablePath is a relative path, then it is resolved relative to the current working directory. Note that Playwright only works with the bundled Chromium, Firefox or WebKit, use at your own risk.\n• An object containing additional HTTP headers to be sent with every request. Defaults to none.\n• Firefox user preferences. Learn more about the Firefox user preferences at .\n• Emulates media feature, supported values are , . See page.emulateMedia() for more details. Passing resets emulation to system defaults. Defaults to .\n• Close the browser process on SIGHUP. Defaults to .\n• Close the browser process on Ctrl-C. Defaults to .\n• Close the browser process on SIGTERM. Defaults to .\n• Specifies if viewport supports touch events. Defaults to false. Learn more about mobile emulation.\n• Whether to run browser in headless mode. More details for Chromium and Firefox. Defaults to unless the devtools option is .\n• \n• This option only applies to the requests sent from corresponding APIRequestContext and does not affect requests sent from the browser. - header with basic authentication credentials will be sent with the each API request. - the credentials are only sent when 401 (Unauthorized) response with header is received. Defaults to . Credentials for HTTP authentication. If no origin is specified, the username and password are sent to any servers upon unauthorized responses.\n• If , Playwright does not pass its own configurations args and only uses the ones from args. If an array is given, then filters out the given default arguments. Dangerous option; use with care. Defaults to .\n• Whether to ignore HTTPS errors when sending network requests. Defaults to .\n• Whether the tag is taken into account and touch events are enabled. isMobile is a part of device, so you don't actually need to set it manually. Defaults to and is not supported in Firefox. Learn more about mobile emulation.\n• Whether or not to enable JavaScript in the context. Defaults to . Learn more about disabling JavaScript.\n• Specify user locale, for example , , etc. Locale will affect value, request header value as well as number and date formatting rules. Defaults to the system default locale. Learn more about emulation in our emulation guide.\n• Whether to emulate network being offline. Defaults to . Learn more about network emulation.\n• A list of permissions to grant to all pages in this context. See browserContext.grantPermissions() for more details. Defaults to none.\n• \n• Proxy to be used for all requests. HTTP and SOCKS proxies are supported, for example or . Short form is considered an HTTP proxy.\n• Optional comma-separated domains to bypass proxy, for example .\n• Optional username to use if HTTP proxy requires authentication.\n• Optional password to use if HTTP proxy requires authentication.\n• \n• Optional setting to control whether to omit request content from the HAR. Defaults to . Deprecated, use policy instead.\n• Optional setting to control resource content management. If is specified, content is not persisted. If is specified, resources are persisted as separate files or entries in the ZIP archive. If is specified, content is stored inline the HAR file as per HAR specification. Defaults to for output files and to for all other file extensions.\n• Path on the filesystem to write the HAR file to. If the file name ends with , is used by default.\n• When set to , only record information necessary for routing from HAR. This omits sizes, timing, page, cookies, security and other types of HAR information that are not used when replaying from HAR. Defaults to .\n• A glob or regex pattern to filter requests that are stored in the HAR. When a baseURL via the context options was provided and the passed URL is a path, it gets merged via the constructor. Defaults to none. Enables HAR recording for all pages into file. If not specified, the HAR is not recorded. Make sure to await browserContext.close() for the HAR to be saved.\n• \n• Path to the directory to put videos into.\n• Optional dimensions of the recorded videos. If not specified the size will be equal to scaled down to fit into 800x800. If is not configured explicitly the video size defaults to 800x450. Actual picture of each page will be scaled down if necessary to fit the specified size. Enables video recording for all pages into directory. If not specified videos are not recorded. Make sure to await browserContext.close() for videos to be saved.\n• Emulates media feature, supported values are , . See page.emulateMedia() for more details. Passing resets emulation to system defaults. Defaults to .\n• Emulates consistent window screen size available inside web page via . Is only used when the viewport is set.\n• Whether to allow sites to register Service workers. Defaults to .\n• : Playwright will block all registration of Service Workers.\n• Slows down Playwright operations by the specified amount of milliseconds. Useful so that you can see what is going on.\n• If set to true, enables strict selectors mode for this context. In the strict selectors mode all operations on selectors that imply single target DOM element will throw when more than one element matches the selector. This option does not affect any Locator APIs (Locators are always strict). Defaults to . See Locator to learn more about the strict mode.\n• Maximum time in milliseconds to wait for the browser instance to start. Defaults to (30 seconds). Pass to disable timeout.\n• Changes the timezone of the context. See ICU's metaZones.txt for a list of supported timezone IDs. Defaults to the system timezone.\n• If specified, traces are saved into this directory.\n• Specific user agent to use in this context.\n• Emulates consistent viewport for each page. Defaults to an 1280x720 viewport. Use to disable the consistent viewport emulation. Learn more about viewport emulation. The value opts out from the default presets, makes viewport depend on the host window size defined by the operating system. It makes the execution of the tests non-deterministic.\n\nReturns the browser app instance. You can connect to it via browserType.connect(), which requires the major/minor client/server version to match (1.2.3 → is compatible with 1.2.x).\n\nLaunches browser server that client can connect to. An example of launching a browser executable and connecting to it later:\n• Object (optional)\n• Use custom browser args at your own risk, as some of them may break Playwright functionality. Additional arguments to pass to the browser instance. The list of Chromium flags can be found here.\n• Use \"chromium\" to opt in to new headless mode. Use \"chrome\", \"chrome-beta\", \"chrome-dev\", \"chrome-canary\", \"msedge\", \"msedge-beta\", \"msedge-dev\", or \"msedge-canary\" to use branded Google Chrome and Microsoft Edge.\n• Chromium-only Whether to auto-open a Developer Tools panel for each tab. If this option is , the headless option will be set .\n• If specified, accepted downloads are downloaded into this directory. Otherwise, temporary directory is created and is deleted when browser is closed. In either case, the downloads are deleted when the browser context they were created in is closed.\n• Specify environment variables that will be visible to the browser. Defaults to .\n• Path to a browser executable to run instead of the bundled one. If executablePath is a relative path, then it is resolved relative to the current working directory. Note that Playwright only works with the bundled Chromium, Firefox or WebKit, use at your own risk.\n• Firefox user preferences. Learn more about the Firefox user preferences at .\n• Close the browser process on SIGHUP. Defaults to .\n• Close the browser process on Ctrl-C. Defaults to .\n• Close the browser process on SIGTERM. Defaults to .\n• Whether to run browser in headless mode. More details for Chromium and Firefox. Defaults to unless the devtools option is .\n• Host to use for the web socket. It is optional and if it is omitted, the server will accept connections on the unspecified IPv6 address (::) when IPv6 is available, or the unspecified IPv4 address (0.0.0.0) otherwise. Consider hardening it with picking a specific interface.\n• If , Playwright does not pass its own configurations args and only uses the ones from args. If an array is given, then filters out the given default arguments. Dangerous option; use with care. Defaults to .\n• Port to use for the web socket. Defaults to 0 that picks any available port.\n• \n• Proxy to be used for all requests. HTTP and SOCKS proxies are supported, for example or . Short form is considered an HTTP proxy.\n• Optional comma-separated domains to bypass proxy, for example .\n• Optional username to use if HTTP proxy requires authentication.\n• Optional password to use if HTTP proxy requires authentication.\n• Maximum time in milliseconds to wait for the browser instance to start. Defaults to (30 seconds). Pass to disable timeout.\n• If specified, traces are saved into this directory.\n• Path at which to serve the Browser Server. For security, this defaults to an unguessable string. Any process or web page (including those running in Playwright) with knowledge of the can take control of the OS user. For this reason, you should use an unguessable token when using this option.\n\nReturns browser name. For example: , or ."
    },
    {
        "link": "https://github.com/microsoft/playwright/issues/18046",
        "document": "\n• Extra: [any specific details about your environment]\n\nI'm trying to use Playwright against my main Chrome profile/browser with the method, but it just throws an exception...\n\nThe exception on that screenshot is thrown on line 2. Ignore that it's using LINQPad there - the same happens in a normal dotnet console app (see repro-case above).\n\nInstructions followed from the docs [here](https://playwright.dev/dotnet/docs/api/class-browsertype#browser-type-launch-persistent-context] to get that path."
    },
    {
        "link": "https://playwright.dev/docs/api/class-playwright",
        "document": "Playwright module provides a method to launch a browser instance. The following is a typical example of using Playwright to drive automation:\n\nThis object can be used to launch or connect to Chromium, returning instances of Browser.\n\nReturns a dictionary of devices to be used with browser.newContext() or browser.newPage().\n\nPlaywright methods might throw errors if they are unable to fulfill a request. For example, locator.waitFor() might fail if the selector doesn't match any nodes during the given timeframe.\n\nFor certain types of errors Playwright uses specific error classes. These classes are available via .\n\nAn example of handling a timeout error:\n\nThis object can be used to launch or connect to Firefox, returning instances of Browser.\n\nExposes API that can be used for the Web API testing.\n\nSelectors can be used to install custom selector engines. See extensibility for more information.\n\nThis object can be used to launch or connect to WebKit, returning instances of Browser."
    },
    {
        "link": "https://stackoverflow.com/questions/73111371/how-to-reuse-the-same-page-context-in-different-tests-playwright-javascript",
        "document": "I have been writing various tests using Playwright, importing them to a separate file and executing from there. My aim is to execute the tests in a specified order using a single worker.\n\nA series of different tests that launch in a specified order\n\nWhat I don't like is that Playwright launches a new browser context for each test. I found a possible solution on DZone which explains that if you don't pass the page object to each test and only declare it in the beforeAll function then the tests use the same context. Unfortunately I can't replicate that example because each of my tests is in a different file and exported as a function (example in the image below).\n\nI've been trying to solve this by declaring the page object in a beforeAll test or before the function that contains one of the tests or import it from a different file and use it as a function parameter but none of the solutions seem to work. Adding a failing example:\n\nIs there a way to declare the page object before the test function or import it from a different file using JavaScript and use it as a function parameter?"
    },
    {
        "link": "https://playwright.dev/docs/locators",
        "document": "Locators are the central piece of Playwright's auto-waiting and retry-ability. In a nutshell, locators represent a way to find element(s) on the page at any moment.\n\nThese are the recommended built-in locators.\n• page.getByRole() to locate by explicit and implicit accessibility attributes.\n• page.getByLabel() to locate a form control by associated label's text.\n• page.getByPlaceholder() to locate an input by placeholder.\n• page.getByAltText() to locate an element, usually image, by its text alternative.\n• page.getByTitle() to locate an element by its title attribute.\n• page.getByTestId() to locate an element based on its attribute (other attributes can be configured).\n\nPlaywright comes with multiple built-in locators. To make tests resilient, we recommend prioritizing user-facing attributes and explicit contracts such as page.getByRole().\n\nFor example, consider the following DOM structure.\n\nLocate the element by its role of with name \"Sign in\".\n\nEvery time a locator is used for an action, an up-to-date DOM element is located in the page. In the snippet below, the underlying DOM element will be located twice, once prior to every action. This means that if the DOM changes in between the calls due to re-render, the new element corresponding to the locator will be used.\n\nNote that all methods that create a locator, such as page.getByLabel(), are also available on the Locator and FrameLocator classes, so you can chain them and iteratively narrow down your locator.\n\nThe page.getByRole() locator reflects how users and assistive technology perceive the page, for example whether some element is a button or a checkbox. When locating by role, you should usually pass the accessible name as well, so that the locator pinpoints the exact element.\n\nFor example, consider the following DOM structure.\n\nYou can locate each element by its implicit role:\n\nRole locators include buttons, checkboxes, headings, links, lists, tables, and many more and follow W3C specifications for ARIA role, ARIA attributes and accessible name. Note that many html elements like have an implicitly defined role that is recognized by the role locator.\n\nNote that role locators do not replace accessibility audits and conformance tests, but rather give early feedback about the ARIA guidelines.\n\nMost form controls usually have dedicated labels that could be conveniently used to interact with the form. In this case, you can locate the control by its associated label using page.getByLabel().\n\nFor example, consider the following DOM structure.\n\nYou can fill the input after locating it by the label text:\n\nInputs may have a placeholder attribute to hint to the user what value should be entered. You can locate such an input using page.getByPlaceholder().\n\nFor example, consider the following DOM structure.\n\nYou can fill the input after locating it by the placeholder text:\n\nFind an element by the text it contains. You can match by a substring, exact string, or a regular expression when using page.getByText().\n\nFor example, consider the following DOM structure.\n\nYou can locate the element by the text it contains:\n\nYou can also filter by text which can be useful when trying to find a particular item in a list.\n\nAll images should have an attribute that describes the image. You can locate an image based on the text alternative using page.getByAltText().\n\nFor example, consider the following DOM structure.\n\nYou can click on the image after locating it by the text alternative:\n\nLocate an element with a matching title attribute using page.getByTitle().\n\nFor example, consider the following DOM structure.\n\nYou can check the issues count after locating it by the title text:\n\nTesting by test ids is the most resilient way of testing as even if your text or role of the attribute changes, the test will still pass. QA's and developers should define explicit test ids and query them with page.getByTestId(). However testing by test ids is not user facing. If the role or text value is important to you then consider using user facing locators such as role and text locators.\n\nFor example, consider the following DOM structure.\n\nYou can locate the element by its test id:\n\nBy default, page.getByTestId() will locate elements based on the attribute, but you can configure it in your test config or by calling selectors.setTestIdAttribute().\n\nSet the test id to use a custom data attribute for your tests.\n\nIn your html you can now use as your test id instead of the default .\n\nAnd then locate the element as you would normally do:\n\nIf you absolutely must use CSS or XPath locators, you can use page.locator() to create a locator that takes a selector describing how to find an element in the page. Playwright supports CSS and XPath selectors, and auto-detects them if you omit or prefix.\n\nXPath and CSS selectors can be tied to the DOM structure or implementation. These selectors can break when the DOM structure changes. Long CSS or XPath chains below are an example of a bad practice that leads to unstable tests:\n\nAll locators in Playwright by default work with elements in Shadow DOM. The exceptions are:\n• Locating by XPath does not pierce shadow roots.\n\nConsider the following example with a custom web component:\n\nYou can locate in the same way as if the shadow root was not present at all.\n\nTo ensure that contains the text \"Details\":\n\nConsider the following DOM structure where we want to click on the buy button of the second product card. We have a few options in order to filter the locators to get the right one.\n\nLocators can be filtered by text with the locator.filter() method. It will search for a particular string somewhere inside the element, possibly in a descendant element, case-insensitively. You can also pass a regular expression.\n\nAlternatively, filter by not having text:\n\nLocators support an option to only select elements that have or have not a descendant matching another locator. You can therefore filter by any other locator such as a locator.getByRole(), locator.getByTestId(), locator.getByText() etc.\n\nWe can also assert the product card to make sure there is only one:\n\nThe filtering locator must be relative to the original locator and is queried starting with the original locator match, not the document root. Therefore, the following will not work, because the filtering locator starts matching from the list element that is outside of the list item matched by the original locator:\n\nWe can also filter by not having a matching element inside.\n\nNote that the inner locator is matched starting from the outer one, not from the document root.\n\nYou can chain methods that create a locator, like page.getByText() or locator.getByRole(), to narrow down the search to a particular part of the page.\n\nIn this example we first create a locator called product by locating its role of . We then filter by text. We can use the product locator again to get by role of button and click it and then use an assertion to make sure there is only one product with the text \"Product 2\".\n\nYou can also chain two locators together, for example to find a \"Save\" button inside a particular dialog:\n\nMethod locator.and() narrows down an existing locator by matching an additional locator. For example, you can combine page.getByRole() and page.getByTitle() to match by both role and title.\n\nIf you'd like to target one of the two or more elements, and you don't know which one it will be, use locator.or() to create a locator that matches any one or both of the alternatives.\n\nFor example, consider a scenario where you'd like to click on a \"New email\" button, but sometimes a security settings dialog shows up instead. In this case, you can wait for either a \"New email\" button, or a dialog and act accordingly.\n\nConsider a page with two buttons, the first invisible and the second visible.\n• This will find both buttons and throw a strictness violation error:\n• This will only find a second button, because it is visible, and then click it.\n\nYou can assert locators in order to count the items in a list.\n\nFor example, consider the following DOM structure:\n\nUse the count assertion to ensure that the list has 3 items.\n\nYou can assert locators in order to find all the text in a list.\n\nFor example, consider the following DOM structure:\n\nUse expect(locator).toHaveText() to ensure that the list has the text \"apple\", \"banana\" and \"orange\".\n\nThere are many ways to get a specific item in a list.\n\nUse the page.getByText() method to locate an element in a list by its text content and then click on it.\n\nFor example, consider the following DOM structure:\n\nLocate an item by its text content and click it.\n\nUse the locator.filter() to locate a specific item in a list.\n\nFor example, consider the following DOM structure:\n\nLocate an item by the role of \"listitem\" and then filter by the text of \"orange\" and then click it.\n\nUse the page.getByTestId() method to locate an element in a list. You may need to modify the html and add a test id if you don't already have a test id.\n\nFor example, consider the following DOM structure:\n\nLocate an item by its test id of \"orange\" and then click it.\n\nIf you have a list of identical elements, and the only way to distinguish between them is the order, you can choose a specific element from a list with locator.first(), locator.last() or locator.nth().\n\nHowever, use this method with caution. Often times, the page might change, and the locator will point to a completely different element from the one you expected. Instead, try to come up with a unique locator that will pass the strictness criteria.\n\nWhen you have elements with various similarities, you can use the locator.filter() method to select the right one. You can also chain multiple filters to narrow down the selection.\n\nFor example, consider the following DOM structure:\n\nTo take a screenshot of the row with \"Mary\" and \"Say goodbye\":\n\nYou should now have a \"screenshot.png\" file in your project's root directory.\n\nThe code inside locator.evaluateAll() runs in the page, you can call any DOM apis there.\n\nLocators are strict. This means that all operations on locators that imply some target DOM element will throw an exception if more than one element matches. For example, the following call throws if there are several buttons in the DOM:\n\nOn the other hand, Playwright understands when you perform a multiple-element operation, so the following call works perfectly fine when the locator resolves to multiple elements.\n\nYou can explicitly opt-out from strictness check by telling Playwright which element to use when multiple elements match, through locator.first(), locator.last(), and locator.nth(). These methods are not recommended because when your page changes, Playwright may click on an element you did not intend. Instead, follow best practices above to create a locator that uniquely identifies the target element.\n\nFor less commonly used locators, look at the other locators guide."
    },
    {
        "link": "https://playwright.dev/docs/api/class-locator",
        "document": "Locators are the central piece of Playwright's auto-waiting and retry-ability. In a nutshell, locators represent a way to find element(s) on the page at any moment. A locator can be created with the page.locator() method.\n\nWhen the locator points to a list of elements, this returns an array of locators, pointing to their respective elements.\n\nReturns an array of values for all matching nodes.\n\nReturns an array of values for all matching nodes.\n\nCreates a locator that matches both this locator and the argument locator.\n\nThe following example finds a button with a specific title.\n\nCaptures the aria snapshot of the given element. Read more about aria snapshots and expect(locator).toMatchAriaSnapshot() for the corresponding assertion.\n• Object (optional)\n• Maximum time in milliseconds. Defaults to - no timeout. The default value can be changed via option in the config, or by using the browserContext.setDefaultTimeout() or page.setDefaultTimeout() methods.\n\nThis method captures the aria snapshot of the given element. The snapshot is a string that represents the state of the element and its children. The snapshot can be used to assert the state of the element in the test, or to compare it to state in the future.\n\nThe ARIA snapshot is represented using YAML markup language:\n• The keys of the objects are the roles and optional accessible names of the elements.\n• The values are either text content or an array of child elements.\n• Generic static text can be represented with the key.\n\nBelow is the HTML markup and the respective ARIA snapshot:\n• Object (optional)\n• Maximum time in milliseconds. Defaults to - no timeout. The default value can be changed via option in the config, or by using the browserContext.setDefaultTimeout() or page.setDefaultTimeout() methods.\n\nThis method returns the bounding box of the element matching the locator, or if the element is not visible. The bounding box is calculated relative to the main frame viewport - which is usually the same as the browser window.\n• Object (optional)\n• Maximum time in milliseconds. Defaults to - no timeout. The default value can be changed via option in the config, or by using the browserContext.setDefaultTimeout() or page.setDefaultTimeout() methods.\n• Promise<null | Object>#\n• the x coordinate of the element in pixels.\n• the y coordinate of the element in pixels.\n• the width of the element in pixels.\n• the height of the element in pixels.\n\nScrolling affects the returned bounding box, similarly to Element.getBoundingClientRect. That means and/or may be negative.\n\nElements from child frames return the bounding box relative to the main frame, unlike the Element.getBoundingClientRect.\n\nAssuming the page is static, it is safe to use bounding box coordinates to perform input. For example, the following snippet should click the center of the element.\n\nEnsure that checkbox or radio element is checked.\n• Object (optional)\n• Whether to bypass the actionability checks. Defaults to .\n• This option has no effect. This option has no effect.\n• A point to use relative to the top-left corner of element padding box. If not specified, uses some visible point of the element.\n• Maximum time in milliseconds. Defaults to - no timeout. The default value can be changed via option in the config, or by using the browserContext.setDefaultTimeout() or page.setDefaultTimeout() methods.\n• When set, this method only performs the actionability checks and skips the action. Defaults to . Useful to wait until the element is ready for the action without performing it.\n• Ensure that element is a checkbox or a radio input. If not, this method throws. If the element is already checked, this method returns immediately.\n• Wait for actionability checks on the element, unless force option is set.\n• Scroll the element into view if needed.\n• Use page.mouse to click in the center of the element.\n• Ensure that the element is now checked. If not, this method throws.\n\nIf the element is detached from the DOM at any moment during the action, this method throws.\n\nWhen all steps combined have not finished during the specified timeout, this method throws a TimeoutError. Passing zero timeout disables this.\n• Object (optional)\n• Whether to bypass the actionability checks. Defaults to .\n• This option has no effect. This option has no effect.\n• Maximum time in milliseconds. Defaults to - no timeout. The default value can be changed via option in the config, or by using the browserContext.setDefaultTimeout() or page.setDefaultTimeout() methods.\n\nThis method waits for actionability checks, focuses the element, clears it and triggers an event after clearing.\n\nIf the target element is not an , or element, this method throws an error. However, if the element is inside the element that has an associated control, the control will be cleared instead.\n• Object (optional)\n• Time to wait between and in milliseconds. Defaults to 0.\n• Whether to bypass the actionability checks. Defaults to .\n• Modifier keys to press. Ensures that only these modifiers are pressed during the operation, and then restores current modifiers back. If not specified, currently pressed modifiers are used. \"ControlOrMeta\" resolves to \"Control\" on Windows and Linux and to \"Meta\" on macOS.\n• This option will default to in the future. Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to inaccessible pages. Defaults to .\n• A point to use relative to the top-left corner of element padding box. If not specified, uses some visible point of the element.\n• Maximum time in milliseconds. Defaults to - no timeout. The default value can be changed via option in the config, or by using the browserContext.setDefaultTimeout() or page.setDefaultTimeout() methods.\n• When set, this method only performs the actionability checks and skips the action. Defaults to . Useful to wait until the element is ready for the action without performing it. Note that keyboard will be pressed regardless of to allow testing elements which are only visible when those keys are pressed.\n\nThis method clicks the element by performing the following steps:\n• Wait for actionability checks on the element, unless force option is set.\n• Scroll the element into view if needed.\n• Use page.mouse to click in the center of the element, or the specified position.\n• Wait for initiated navigations to either succeed or fail, unless noWaitAfter option is set.\n\nIf the element is detached from the DOM at any moment during the action, this method throws.\n\nWhen all steps combined have not finished during the specified timeout, this method throws a TimeoutError. Passing zero timeout disables this.\n\nReturns a FrameLocator object pointing to the same as this locator.\n\nUseful when you have a Locator object obtained somewhere, and later on would like to interact with the content inside the frame.\n\nReturns the number of elements matching the locator.\n• Object (optional)\n• Time to wait between and in milliseconds. Defaults to 0.\n• Whether to bypass the actionability checks. Defaults to .\n• Modifier keys to press. Ensures that only these modifiers are pressed during the operation, and then restores current modifiers back. If not specified, currently pressed modifiers are used. \"ControlOrMeta\" resolves to \"Control\" on Windows and Linux and to \"Meta\" on macOS.\n• This option has no effect. This option has no effect.\n• A point to use relative to the top-left corner of element padding box. If not specified, uses some visible point of the element.\n• Maximum time in milliseconds. Defaults to - no timeout. The default value can be changed via option in the config, or by using the browserContext.setDefaultTimeout() or page.setDefaultTimeout() methods.\n• When set, this method only performs the actionability checks and skips the action. Defaults to . Useful to wait until the element is ready for the action without performing it. Note that keyboard will be pressed regardless of to allow testing elements which are only visible when those keys are pressed.\n\nThis method double clicks the element by performing the following steps:\n• Wait for actionability checks on the element, unless force option is set.\n• Scroll the element into view if needed.\n• Use page.mouse to double click in the center of the element, or the specified position.\n\nIf the element is detached from the DOM at any moment during the action, this method throws.\n\nWhen all steps combined have not finished during the specified timeout, this method throws a TimeoutError. Passing zero timeout disables this.\n\nProgrammatically dispatch an event on the matching element.\n• \n• Maximum time in milliseconds. Defaults to - no timeout. The default value can be changed via option in the config, or by using the browserContext.setDefaultTimeout() or page.setDefaultTimeout() methods.\n\nThe snippet above dispatches the event on the element. Regardless of the visibility state of the element, is dispatched. This is equivalent to calling element.click().\n\nUnder the hood, it creates an instance of an event based on the given type, initializes it with eventInit properties and dispatches it on the element. Events are , and bubble by default.\n\nSince eventInit is event-specific, please refer to the events documentation for the lists of initial properties:\n\nYou can also specify JSHandle as the property value if you want live objects to be passed into the event:\n\nDrag the source element towards the target element and drop it.\n• Locator of the element to drag to.\n• \n• Whether to bypass the actionability checks. Defaults to .\n• This option has no effect. This option has no effect.\n• Clicks on the source element at this point relative to the top-left corner of the element's padding box. If not specified, some visible point of the element is used.\n• Drops on the target element at this point relative to the top-left corner of the element's padding box. If not specified, some visible point of the element is used.\n• Maximum time in milliseconds. Defaults to - no timeout. The default value can be changed via option in the config, or by using the browserContext.setDefaultTimeout() or page.setDefaultTimeout() methods.\n• When set, this method only performs the actionability checks and skips the action. Defaults to . Useful to wait until the element is ready for the action without performing it.\n\nThis method drags the locator to another target locator or target position. It will first move to the source element, perform a , then move to the target element or position and perform a .\n\nExecute JavaScript code in the page, taking the matching element as an argument.\n• Function to be evaluated in the page context.\n• \n• Maximum time in milliseconds. Defaults to - no timeout. The default value can be changed via option in the config, or by using the browserContext.setDefaultTimeout() or page.setDefaultTimeout() methods.\n\nReturns the return value of pageFunction, called with the matching element as a first argument, and arg as a second argument.\n\nIf pageFunction returns a Promise, this method will wait for the promise to resolve and return its value.\n\nIf pageFunction throws or rejects, this method throws.\n\nExecute JavaScript code in the page, taking all matching elements as an argument.\n• Function to be evaluated in the page context.\n\nReturns the return value of pageFunction, called with an array of all matching elements as a first argument, and arg as a second argument.\n\nIf pageFunction returns a Promise, this method will wait for the promise to resolve and return its value.\n\nIf pageFunction throws or rejects, this method throws.\n\nExecute JavaScript code in the page, taking the matching element as an argument, and return a JSHandle with the result.\n• Function to be evaluated in the page context.\n• \n• Maximum time in milliseconds. Defaults to - no timeout. The default value can be changed via option in the config, or by using the browserContext.setDefaultTimeout() or page.setDefaultTimeout() methods.\n\nReturns the return value of pageFunction as aJSHandle, called with the matching element as a first argument, and arg as a second argument.\n\nThe only difference between locator.evaluate() and locator.evaluateHandle() is that locator.evaluateHandle() returns JSHandle.\n\nIf pageFunction returns a Promise, this method will wait for the promise to resolve and return its value.\n\nIf pageFunction throws or rejects, this method throws.\n\nSee page.evaluateHandle() for more details.\n\nSet a value to the input field.\n• Value to set for the , or element.\n• \n• Whether to bypass the actionability checks. Defaults to .\n• This option has no effect. This option has no effect.\n• Maximum time in milliseconds. Defaults to - no timeout. The default value can be changed via option in the config, or by using the browserContext.setDefaultTimeout() or page.setDefaultTimeout() methods.\n\nThis method waits for actionability checks, focuses the element, fills it and triggers an event after filling. Note that you can pass an empty string to clear the input field.\n\nIf the target element is not an , or element, this method throws an error. However, if the element is inside the element that has an associated control, the control will be filled instead.\n\nThis method narrows existing locator according to the options, for example filters by text. It can be chained to filter multiple times.\n• Object (optional)\n• Narrows down the results of the method to those which contain elements matching this relative locator. For example, that has matches . Inner locator must be relative to the outer locator and is queried starting with the outer locator match, not the document root. For example, you can find that has in . However, looking for that has will fail, because the inner locator must be relative and should not use any elements outside the . Note that outer and inner locators must belong to the same frame. Inner locator must not contain FrameLocators.\n• Matches elements that do not contain an element that matches an inner locator. Inner locator is queried against the outer one. For example, that does not have matches . Note that outer and inner locators must belong to the same frame. Inner locator must not contain FrameLocators.\n• Matches elements that do not contain specified text somewhere inside, possibly in a child or a descendant element. When passed a string, matching is case-insensitive and searches for a substring.\n• Matches elements containing specified text somewhere inside, possibly in a child or a descendant element. When passed a string, matching is case-insensitive and searches for a substring. For example, matches .\n\nReturns locator to the first matching element.\n• Object (optional)\n• Maximum time in milliseconds. Defaults to - no timeout. The default value can be changed via option in the config, or by using the browserContext.setDefaultTimeout() or page.setDefaultTimeout() methods.\n\nWhen working with iframes, you can create a frame locator that will enter the iframe and allow locating elements in that iframe:\n• A selector to use when resolving DOM element.\n• Attribute name to get the value for.\n• \n• Maximum time in milliseconds. Defaults to - no timeout. The default value can be changed via option in the config, or by using the browserContext.setDefaultTimeout() or page.setDefaultTimeout() methods.\n\nAllows locating elements by their alt text.\n\nFor example, this method will find the image by alt text \"Playwright logo\":\n• Text to locate the element for.\n• \n• Whether to find an exact match: case-sensitive and whole-string. Default to false. Ignored when locating by a regular expression. Note that exact match still trims whitespace.\n\nAllows locating input elements by the text of the associated or element, or by the attribute.\n\nFor example, this method will find inputs by label \"Username\" and \"Password\" in the following DOM:\n• Text to locate the element for.\n• \n• Whether to find an exact match: case-sensitive and whole-string. Default to false. Ignored when locating by a regular expression. Note that exact match still trims whitespace.\n\nAllows locating input elements by the placeholder text.\n\nFor example, consider the following DOM structure.\n\nYou can fill the input after locating it by the placeholder text:\n• Text to locate the element for.\n• \n• Whether to find an exact match: case-sensitive and whole-string. Default to false. Ignored when locating by a regular expression. Note that exact match still trims whitespace.\n\nAllows locating elements by their ARIA role, ARIA attributes and accessible name.\n\nConsider the following DOM structure.\n\nYou can locate each element by it's implicit role:\n• \n• An attribute that is usually set by or native controls.\n• An attribute that is usually set by or . Unlike most other attributes, is inherited through the DOM hierarchy. Learn more about .\n• Whether name is matched exactly: case-sensitive and whole-string. Defaults to false. Ignored when name is a regular expression. Note that exact match still trims whitespace.\n• An attribute that is usually set by .\n• Option that controls whether hidden elements are matched. By default, only non-hidden elements, as defined by ARIA, are matched by role selector.\n• A number attribute that is usually present for roles , , , , with default values for elements.\n• Option to match the accessible name. By default, matching is case-insensitive and searches for a substring, use exact to control this behavior. Learn more about accessible name.\n• An attribute that is usually set by .\n• An attribute that is usually set by .\n\nRole selector does not replace accessibility audits and conformance tests, but rather gives early feedback about the ARIA guidelines.\n\nMany html elements have an implicitly defined role that is recognized by the role selector. You can find all the supported roles here. ARIA guidelines do not recommend duplicating implicit roles and attributes by setting and/or attributes to default values.\n\nConsider the following DOM structure.\n\nYou can locate the element by it's test id:\n• Id to locate the element by.\n\nBy default, the attribute is used as a test id. Use selectors.setTestIdAttribute() to configure a different test id attribute if necessary.\n\nAllows locating elements that contain given text.\n\nSee also locator.filter() that allows to match by another criteria, like an accessible role, and then filter by the text content.\n\nConsider the following DOM structure:\n\nYou can locate by text substring, exact string, or a regular expression:\n• Text to locate the element for.\n• \n• Whether to find an exact match: case-sensitive and whole-string. Default to false. Ignored when locating by a regular expression. Note that exact match still trims whitespace.\n\nMatching by text always normalizes whitespace, even with exact match. For example, it turns multiple spaces into one, turns line breaks into spaces and ignores leading and trailing whitespace.\n\nInput elements of the type and are matched by their instead of the text content. For example, locating by text matches .\n\nAllows locating elements by their title attribute.\n\nConsider the following DOM structure.\n\nYou can check the issues count after locating it by the title text:\n• Text to locate the element for.\n• \n• Whether to find an exact match: case-sensitive and whole-string. Default to false. Ignored when locating by a regular expression. Note that exact match still trims whitespace.\n\nHighlight the corresponding element(s) on the screen. Useful for debugging, don't commit the code that uses locator.highlight().\n• Object (optional)\n• Whether to bypass the actionability checks. Defaults to .\n• Modifier keys to press. Ensures that only these modifiers are pressed during the operation, and then restores current modifiers back. If not specified, currently pressed modifiers are used. \"ControlOrMeta\" resolves to \"Control\" on Windows and Linux and to \"Meta\" on macOS.\n• This option has no effect. This option has no effect.\n• A point to use relative to the top-left corner of element padding box. If not specified, uses some visible point of the element.\n• Maximum time in milliseconds. Defaults to - no timeout. The default value can be changed via option in the config, or by using the browserContext.setDefaultTimeout() or page.setDefaultTimeout() methods.\n• When set, this method only performs the actionability checks and skips the action. Defaults to . Useful to wait until the element is ready for the action without performing it. Note that keyboard will be pressed regardless of to allow testing elements which are only visible when those keys are pressed.\n\nThis method hovers over the element by performing the following steps:\n• Wait for actionability checks on the element, unless force option is set.\n• Scroll the element into view if needed.\n• Use page.mouse to hover over the center of the element, or the specified position.\n\nIf the element is detached from the DOM at any moment during the action, this method throws.\n\nWhen all steps combined have not finished during the specified timeout, this method throws a TimeoutError. Passing zero timeout disables this.\n• Object (optional)\n• Maximum time in milliseconds. Defaults to - no timeout. The default value can be changed via option in the config, or by using the browserContext.setDefaultTimeout() or page.setDefaultTimeout() methods.\n• Object (optional)\n• Maximum time in milliseconds. Defaults to - no timeout. The default value can be changed via option in the config, or by using the browserContext.setDefaultTimeout() or page.setDefaultTimeout() methods.\n\nReturns the value for the matching or or element.\n• Object (optional)\n• Maximum time in milliseconds. Defaults to - no timeout. The default value can be changed via option in the config, or by using the browserContext.setDefaultTimeout() or page.setDefaultTimeout() methods.\n\nThrows elements that are not an input, textarea or a select. However, if the element is inside the element that has an associated control, returns the value of the control.\n\nReturns whether the element is checked. Throws if the element is not a checkbox or radio input.\n• Object (optional)\n• Maximum time in milliseconds. Defaults to - no timeout. The default value can be changed via option in the config, or by using the browserContext.setDefaultTimeout() or page.setDefaultTimeout() methods.\n\nReturns whether the element is disabled, the opposite of enabled.\n• Object (optional)\n• Maximum time in milliseconds. Defaults to - no timeout. The default value can be changed via option in the config, or by using the browserContext.setDefaultTimeout() or page.setDefaultTimeout() methods.\n\nReturns whether the element is editable. If the target element is not an , , , and does not have a role allowing , this method throws an error.\n• Object (optional)\n• Maximum time in milliseconds. Defaults to - no timeout. The default value can be changed via option in the config, or by using the browserContext.setDefaultTimeout() or page.setDefaultTimeout() methods.\n\nReturns whether the element is enabled.\n• Object (optional)\n• Maximum time in milliseconds. Defaults to - no timeout. The default value can be changed via option in the config, or by using the browserContext.setDefaultTimeout() or page.setDefaultTimeout() methods.\n\nReturns whether the element is hidden, the opposite of visible.\n• Object (optional)\n• This option is ignored. locator.isHidden() does not wait for the element to become hidden and returns immediately.\n\nReturns whether the element is visible.\n• Object (optional)\n• This option is ignored. locator.isVisible() does not wait for the element to become visible and returns immediately.\n\nReturns locator to the last matching element.\n\nThe method finds an element matching the specified selector in the locator's subtree. It also accepts filter options, similar to locator.filter() method.\n• A selector or locator to use when resolving DOM element.\n• \n• Narrows down the results of the method to those which contain elements matching this relative locator. For example, that has matches . Inner locator must be relative to the outer locator and is queried starting with the outer locator match, not the document root. For example, you can find that has in . However, looking for that has will fail, because the inner locator must be relative and should not use any elements outside the . Note that outer and inner locators must belong to the same frame. Inner locator must not contain FrameLocators.\n• Matches elements that do not contain an element that matches an inner locator. Inner locator is queried against the outer one. For example, that does not have matches . Note that outer and inner locators must belong to the same frame. Inner locator must not contain FrameLocators.\n• Matches elements that do not contain specified text somewhere inside, possibly in a child or a descendant element. When passed a string, matching is case-insensitive and searches for a substring.\n• Matches elements containing specified text somewhere inside, possibly in a child or a descendant element. When passed a string, matching is case-insensitive and searches for a substring. For example, matches .\n\nReturns locator to the n-th matching element. It's zero based, selects the first element.\n\nCreates a locator matching all elements that match one or both of the two locators.\n\nNote that when both locators match something, the resulting locator will have multiple matches, potentially causing a locator strictness violation.\n\nConsider a scenario where you'd like to click on a \"New email\" button, but sometimes a security settings dialog shows up instead. In this case, you can wait for either a \"New email\" button, or a dialog and act accordingly.\n\nFocuses the matching element and presses a combination of the keys.\n• Name of the key to press or a character to generate, such as or .\n• \n• Time to wait between and in milliseconds. Defaults to 0.\n• This option will default to in the future. Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to inaccessible pages. Defaults to .\n• Maximum time in milliseconds. Defaults to - no timeout. The default value can be changed via option in the config, or by using the browserContext.setDefaultTimeout() or page.setDefaultTimeout() methods.\n\nFocuses the element, and then uses keyboard.down() and keyboard.up().\n\nkey can specify the intended keyboardEvent.key value or a single character to generate the text for. A superset of the key values can be found here. Examples of the keys are:\n\nFollowing modification shortcuts are also supported: , , , , , . resolves to on Windows and Linux and to on macOS.\n\nHolding down will type the text that corresponds to the key in the upper case.\n\nIf key is a single character, it is case-sensitive, so the values and will generate different respective texts.\n\nShortcuts such as , or are supported as well. When specified with the modifier, modifier is pressed and being held while the subsequent key is being pressed.\n\nFocuses the element, and then sends a , / , and event for each character in the text.\n\nTo press a special key, like or , use locator.press().\n\nAn example of typing into a text field and then submitting the form:\n• String of characters to sequentially press into a focused element.\n• \n• Time to wait between key presses in milliseconds. Defaults to 0.\n• This option has no effect. This option has no effect.\n• Maximum time in milliseconds. Defaults to - no timeout. The default value can be changed via option in the config, or by using the browserContext.setDefaultTimeout() or page.setDefaultTimeout() methods.\n\nTake a screenshot of the element matching the locator.\n• Object (optional)\n• When set to , stops CSS animations, CSS transitions and Web Animations. Animations get different treatment depending on their duration:\n• finite animations are fast-forwarded to completion, so they'll fire event.\n• infinite animations are canceled to initial state, and then played over after the screenshot.\n• When set to , screenshot will hide text caret. When set to , text caret behavior will not be changed. Defaults to .\n• Specify locators that should be masked when the screenshot is taken. Masked elements will be overlaid with a pink box (customized by maskColor) that completely covers its bounding box. The mask is also applied to invisible elements, see Matching only visible elements to disable that.\n• Specify the color of the overlay box for masked elements, in CSS color format. Default color is pink .\n• Hides default white background and allows capturing screenshots with transparency. Not applicable to images. Defaults to .\n• The file path to save the image to. The screenshot type will be inferred from file extension. If path is a relative path, then it is resolved relative to the current working directory. If no path is provided, the image won't be saved to the disk.\n• The quality of the image, between 0-100. Not applicable to images.\n• When set to , screenshot will have a single pixel per each css pixel on the page. For high-dpi devices, this will keep screenshots small. Using option will produce a single pixel per each device pixel, so screenshots of high-dpi devices will be twice as large or even larger.\n• Text of the stylesheet to apply while making the screenshot. This is where you can hide dynamic elements, make elements invisible or change their properties to help you creating repeatable screenshots. This stylesheet pierces the Shadow DOM and applies to the inner frames.\n• Maximum time in milliseconds. Defaults to - no timeout. The default value can be changed via option in the config, or by using the browserContext.setDefaultTimeout() or page.setDefaultTimeout() methods.\n\nThis method captures a screenshot of the page, clipped to the size and position of a particular element matching the locator. If the element is covered by other elements, it will not be actually visible on the screenshot. If the element is a scrollable container, only the currently scrolled content will be visible on the screenshot.\n\nThis method waits for the actionability checks, then scrolls element into view before taking a screenshot. If the element is detached from DOM, the method throws an error.\n\nReturns the buffer with the captured screenshot.\n\nThis method waits for actionability checks, then tries to scroll element into view, unless it is completely visible as defined by IntersectionObserver's .\n\nSee scrolling for alternative ways to scroll.\n• Object (optional)\n• Maximum time in milliseconds. Defaults to - no timeout. The default value can be changed via option in the config, or by using the browserContext.setDefaultTimeout() or page.setDefaultTimeout() methods.\n• null | string | ElementHandle | Array<string> | Object | Array<ElementHandle> | Array<Object># Options to select. If the has the attribute, all matching options are selected, otherwise only the first option matching one of the passed options is selected. String values are matching both values and labels. Option is considered matching if all specified properties match.\n• Object (optional)\n• Whether to bypass the actionability checks. Defaults to .\n• This option has no effect. This option has no effect.\n• Maximum time in milliseconds. Defaults to - no timeout. The default value can be changed via option in the config, or by using the browserContext.setDefaultTimeout() or page.setDefaultTimeout() methods.\n\nThis method waits for actionability checks, waits until all specified options are present in the element and selects these options.\n\nIf the target element is not a element, this method throws an error. However, if the element is inside the element that has an associated control, the control will be used instead.\n\nReturns the array of option values that have been successfully selected.\n\nTriggers a and event once all the provided options have been selected.\n\nThis method waits for actionability checks, then focuses the element and selects all its text content.\n\nIf the element is inside the element that has an associated control, focuses and selects text in the control instead.\n• Object (optional)\n• Whether to bypass the actionability checks. Defaults to .\n• Maximum time in milliseconds. Defaults to - no timeout. The default value can be changed via option in the config, or by using the browserContext.setDefaultTimeout() or page.setDefaultTimeout() methods.\n\nSet the state of a checkbox or a radio element.\n• Whether to check or uncheck the checkbox.\n• \n• Whether to bypass the actionability checks. Defaults to .\n• This option has no effect. This option has no effect.\n• A point to use relative to the top-left corner of element padding box. If not specified, uses some visible point of the element.\n• Maximum time in milliseconds. Defaults to - no timeout. The default value can be changed via option in the config, or by using the browserContext.setDefaultTimeout() or page.setDefaultTimeout() methods.\n• When set, this method only performs the actionability checks and skips the action. Defaults to . Useful to wait until the element is ready for the action without performing it.\n\nThis method checks or unchecks an element by performing the following steps:\n• Ensure that matched element is a checkbox or a radio input. If not, this method throws.\n• If the element already has the right checked state, this method returns immediately.\n• Wait for actionability checks on the matched element, unless force option is set. If the element is detached during the checks, the whole action is retried.\n• Scroll the element into view if needed.\n• Use page.mouse to click in the center of the element.\n• Ensure that the element is now checked or unchecked. If not, this method throws.\n\nWhen all steps combined have not finished during the specified timeout, this method throws a TimeoutError. Passing zero timeout disables this.\n\nUpload file or multiple files into . For inputs with a attribute, only a single directory path is supported.\n• Object (optional)\n• This option has no effect. This option has no effect.\n• Maximum time in milliseconds. Defaults to - no timeout. The default value can be changed via option in the config, or by using the browserContext.setDefaultTimeout() or page.setDefaultTimeout() methods.\n\nSets the value of the file input to these file paths or files. If some of the are relative paths, then they are resolved relative to the current working directory. For empty array, clears the selected files.\n\nThis method expects Locator to point to an input element. However, if the element is inside the element that has an associated control, targets the control instead.\n\nPerform a tap gesture on the element matching the locator. For examples of emulating other gestures by manually dispatching touch events, see the emulating legacy touch events page.\n• Object (optional)\n• Whether to bypass the actionability checks. Defaults to .\n• Modifier keys to press. Ensures that only these modifiers are pressed during the operation, and then restores current modifiers back. If not specified, currently pressed modifiers are used. \"ControlOrMeta\" resolves to \"Control\" on Windows and Linux and to \"Meta\" on macOS.\n• This option has no effect. This option has no effect.\n• A point to use relative to the top-left corner of element padding box. If not specified, uses some visible point of the element.\n• Maximum time in milliseconds. Defaults to - no timeout. The default value can be changed via option in the config, or by using the browserContext.setDefaultTimeout() or page.setDefaultTimeout() methods.\n• When set, this method only performs the actionability checks and skips the action. Defaults to . Useful to wait until the element is ready for the action without performing it. Note that keyboard will be pressed regardless of to allow testing elements which are only visible when those keys are pressed.\n\nThis method taps the element by performing the following steps:\n• Wait for actionability checks on the element, unless force option is set.\n• Scroll the element into view if needed.\n• Use page.touchscreen to tap the center of the element, or the specified position.\n\nIf the element is detached from the DOM at any moment during the action, this method throws.\n\nWhen all steps combined have not finished during the specified timeout, this method throws a TimeoutError. Passing zero timeout disables this.\n• Object (optional)\n• Maximum time in milliseconds. Defaults to - no timeout. The default value can be changed via option in the config, or by using the browserContext.setDefaultTimeout() or page.setDefaultTimeout() methods.\n\nEnsure that checkbox or radio element is unchecked.\n• Object (optional)\n• Whether to bypass the actionability checks. Defaults to .\n• This option has no effect. This option has no effect.\n• A point to use relative to the top-left corner of element padding box. If not specified, uses some visible point of the element.\n• Maximum time in milliseconds. Defaults to - no timeout. The default value can be changed via option in the config, or by using the browserContext.setDefaultTimeout() or page.setDefaultTimeout() methods.\n• When set, this method only performs the actionability checks and skips the action. Defaults to . Useful to wait until the element is ready for the action without performing it.\n\nThis method unchecks the element by performing the following steps:\n• Ensure that element is a checkbox or a radio input. If not, this method throws. If the element is already unchecked, this method returns immediately.\n• Wait for actionability checks on the element, unless force option is set.\n• Scroll the element into view if needed.\n• Use page.mouse to click in the center of the element.\n• Ensure that the element is now unchecked. If not, this method throws.\n\nIf the element is detached from the DOM at any moment during the action, this method throws.\n\nWhen all steps combined have not finished during the specified timeout, this method throws a TimeoutError. Passing zero timeout disables this.\n\nReturns when element specified by locator satisfies the state option.\n\nIf target element already satisfies the condition, the method returns immediately. Otherwise, waits for up to timeout milliseconds until the condition is met.\n• Object (optional)\n• Defaults to . Can be either:\n• - wait for element to be present in DOM.\n• - wait for element to not be present in DOM.\n• - wait for element to have non-empty bounding box and no . Note that element without any content or with has an empty bounding box and is not considered visible.\n• - wait for element to be either detached from DOM, or have an empty bounding box or . This is opposite to the option.\n• Maximum time in milliseconds. Defaults to - no timeout. The default value can be changed via option in the config, or by using the browserContext.setDefaultTimeout() or page.setDefaultTimeout() methods.\n\nResolves given locator to the first matching DOM element. If there are no matching elements, waits for one. If multiple elements match the locator, throws.\n• Object (optional)\n• Maximum time in milliseconds. Defaults to - no timeout. The default value can be changed via option in the config, or by using the browserContext.setDefaultTimeout() or page.setDefaultTimeout() methods.\n\nResolves given locator to all matching DOM elements. If there are no matching elements, returns an empty list.\n\nFocuses the element, and then sends a , / , and event for each character in the text.\n\nTo press a special key, like or , use locator.press().\n• \n• Time to wait between key presses in milliseconds. Defaults to 0.\n• This option has no effect. This option has no effect.\n• Maximum time in milliseconds. Defaults to - no timeout. The default value can be changed via option in the config, or by using the browserContext.setDefaultTimeout() or page.setDefaultTimeout() methods."
    },
    {
        "link": "https://playwright.dev/python/docs/locators",
        "document": "Locators are the central piece of Playwright's auto-waiting and retry-ability. In a nutshell, locators represent a way to find element(s) on the page at any moment.\n\nThese are the recommended built-in locators.\n• page.get_by_role() to locate by explicit and implicit accessibility attributes.\n• page.get_by_label() to locate a form control by associated label's text.\n• page.get_by_placeholder() to locate an input by placeholder.\n• page.get_by_alt_text() to locate an element, usually image, by its text alternative.\n• page.get_by_title() to locate an element by its title attribute.\n• page.get_by_test_id() to locate an element based on its attribute (other attributes can be configured).\n\nPlaywright comes with multiple built-in locators. To make tests resilient, we recommend prioritizing user-facing attributes and explicit contracts such as page.get_by_role().\n\nFor example, consider the following DOM structure.\n\nLocate the element by its role of with name \"Sign in\".\n\nEvery time a locator is used for an action, an up-to-date DOM element is located in the page. In the snippet below, the underlying DOM element will be located twice, once prior to every action. This means that if the DOM changes in between the calls due to re-render, the new element corresponding to the locator will be used.\n\nNote that all methods that create a locator, such as page.get_by_label(), are also available on the Locator and FrameLocator classes, so you can chain them and iteratively narrow down your locator.\n\nThe page.get_by_role() locator reflects how users and assistive technology perceive the page, for example whether some element is a button or a checkbox. When locating by role, you should usually pass the accessible name as well, so that the locator pinpoints the exact element.\n\nFor example, consider the following DOM structure.\n\nYou can locate each element by its implicit role:\n\nRole locators include buttons, checkboxes, headings, links, lists, tables, and many more and follow W3C specifications for ARIA role, ARIA attributes and accessible name. Note that many html elements like have an implicitly defined role that is recognized by the role locator.\n\nNote that role locators do not replace accessibility audits and conformance tests, but rather give early feedback about the ARIA guidelines.\n\nMost form controls usually have dedicated labels that could be conveniently used to interact with the form. In this case, you can locate the control by its associated label using page.get_by_label().\n\nFor example, consider the following DOM structure.\n\nYou can fill the input after locating it by the label text:\n\nInputs may have a placeholder attribute to hint to the user what value should be entered. You can locate such an input using page.get_by_placeholder().\n\nFor example, consider the following DOM structure.\n\nYou can fill the input after locating it by the placeholder text:\n\nFind an element by the text it contains. You can match by a substring, exact string, or a regular expression when using page.get_by_text().\n\nFor example, consider the following DOM structure.\n\nYou can locate the element by the text it contains:\n\nYou can also filter by text which can be useful when trying to find a particular item in a list.\n\nAll images should have an attribute that describes the image. You can locate an image based on the text alternative using page.get_by_alt_text().\n\nFor example, consider the following DOM structure.\n\nYou can click on the image after locating it by the text alternative:\n\nLocate an element with a matching title attribute using page.get_by_title().\n\nFor example, consider the following DOM structure.\n\nYou can check the issues count after locating it by the title text:\n\nTesting by test ids is the most resilient way of testing as even if your text or role of the attribute changes, the test will still pass. QA's and developers should define explicit test ids and query them with page.get_by_test_id(). However testing by test ids is not user facing. If the role or text value is important to you then consider using user facing locators such as role and text locators.\n\nFor example, consider the following DOM structure.\n\nYou can locate the element by its test id:\n\nBy default, page.get_by_test_id() will locate elements based on the attribute, but you can configure it in your test config or by calling selectors.set_test_id_attribute().\n\nSet the test id to use a custom data attribute for your tests.\n\nIn your html you can now use as your test id instead of the default .\n\nAnd then locate the element as you would normally do:\n\nIf you absolutely must use CSS or XPath locators, you can use page.locator() to create a locator that takes a selector describing how to find an element in the page. Playwright supports CSS and XPath selectors, and auto-detects them if you omit or prefix.\n\nXPath and CSS selectors can be tied to the DOM structure or implementation. These selectors can break when the DOM structure changes. Long CSS or XPath chains below are an example of a bad practice that leads to unstable tests:\n\nAll locators in Playwright by default work with elements in Shadow DOM. The exceptions are:\n• Locating by XPath does not pierce shadow roots.\n\nConsider the following example with a custom web component:\n\nYou can locate in the same way as if the shadow root was not present at all.\n\nTo ensure that contains the text \"Details\":\n\nConsider the following DOM structure where we want to click on the buy button of the second product card. We have a few options in order to filter the locators to get the right one.\n\nLocators can be filtered by text with the locator.filter() method. It will search for a particular string somewhere inside the element, possibly in a descendant element, case-insensitively. You can also pass a regular expression.\n\nAlternatively, filter by not having text:\n\nLocators support an option to only select elements that have or have not a descendant matching another locator. You can therefore filter by any other locator such as a locator.get_by_role(), locator.get_by_test_id(), locator.get_by_text() etc.\n\nWe can also assert the product card to make sure there is only one:\n\nThe filtering locator must be relative to the original locator and is queried starting with the original locator match, not the document root. Therefore, the following will not work, because the filtering locator starts matching from the list element that is outside of the list item matched by the original locator:\n\nWe can also filter by not having a matching element inside.\n\nNote that the inner locator is matched starting from the outer one, not from the document root.\n\nYou can chain methods that create a locator, like page.get_by_text() or locator.get_by_role(), to narrow down the search to a particular part of the page.\n\nIn this example we first create a locator called product by locating its role of . We then filter by text. We can use the product locator again to get by role of button and click it and then use an assertion to make sure there is only one product with the text \"Product 2\".\n\nYou can also chain two locators together, for example to find a \"Save\" button inside a particular dialog:\n\nMethod locator.and_() narrows down an existing locator by matching an additional locator. For example, you can combine page.get_by_role() and page.get_by_title() to match by both role and title.\n\nIf you'd like to target one of the two or more elements, and you don't know which one it will be, use locator.or_() to create a locator that matches any one or both of the alternatives.\n\nFor example, consider a scenario where you'd like to click on a \"New email\" button, but sometimes a security settings dialog shows up instead. In this case, you can wait for either a \"New email\" button, or a dialog and act accordingly.\n\nConsider a page with two buttons, the first invisible and the second visible.\n• This will find both buttons and throw a strictness violation error:\n• This will only find a second button, because it is visible, and then click it.\n\nYou can assert locators in order to count the items in a list.\n\nFor example, consider the following DOM structure:\n\nUse the count assertion to ensure that the list has 3 items.\n\nYou can assert locators in order to find all the text in a list.\n\nFor example, consider the following DOM structure:\n\nUse expect(locator).to_have_text() to ensure that the list has the text \"apple\", \"banana\" and \"orange\".\n\nThere are many ways to get a specific item in a list.\n\nUse the page.get_by_text() method to locate an element in a list by its text content and then click on it.\n\nFor example, consider the following DOM structure:\n\nLocate an item by its text content and click it.\n\nUse the locator.filter() to locate a specific item in a list.\n\nFor example, consider the following DOM structure:\n\nLocate an item by the role of \"listitem\" and then filter by the text of \"orange\" and then click it.\n\nUse the page.get_by_test_id() method to locate an element in a list. You may need to modify the html and add a test id if you don't already have a test id.\n\nFor example, consider the following DOM structure:\n\nLocate an item by its test id of \"orange\" and then click it.\n\nIf you have a list of identical elements, and the only way to distinguish between them is the order, you can choose a specific element from a list with locator.first, locator.last or locator.nth().\n\nHowever, use this method with caution. Often times, the page might change, and the locator will point to a completely different element from the one you expected. Instead, try to come up with a unique locator that will pass the strictness criteria.\n\nWhen you have elements with various similarities, you can use the locator.filter() method to select the right one. You can also chain multiple filters to narrow down the selection.\n\nFor example, consider the following DOM structure:\n\nTo take a screenshot of the row with \"Mary\" and \"Say goodbye\":\n\nYou should now have a \"screenshot.png\" file in your project's root directory.\n\nThe code inside locator.evaluate_all() runs in the page, you can call any DOM apis there.\n\nLocators are strict. This means that all operations on locators that imply some target DOM element will throw an exception if more than one element matches. For example, the following call throws if there are several buttons in the DOM:\n\nOn the other hand, Playwright understands when you perform a multiple-element operation, so the following call works perfectly fine when the locator resolves to multiple elements.\n\nYou can explicitly opt-out from strictness check by telling Playwright which element to use when multiple elements match, through locator.first, locator.last, and locator.nth(). These methods are not recommended because when your page changes, Playwright may click on an element you did not intend. Instead, follow best practices above to create a locator that uniquely identifies the target element.\n\nFor less commonly used locators, look at the other locators guide."
    },
    {
        "link": "https://bugbug.io/blog/testing-frameworks/playwright-locators",
        "document": "Playwright Locators are designed to locate HTML elements on a web page with precision and flexibility, offering a robust solution to the challenges of dynamic web applications.\n\nThey are the central piece in the puzzle of web automation, enabling testers to specify locators using various strategies, such as CSS selectors, XPath expressions, text content, and custom attributes like test IDs.\n\nThese locators are adept at handling multiple elements, matching elements by text, and even locating elements that contain or do not contain specified text somewhere inside, showcasing their versatility.\n• Comprehensive Locator Strategies – Playwright offers multiple locator strategies, including Playwright locator by ID, Playwright locator by class, Playwright get element by ID, Playwright get by text, and Playwright get by ARIA label, making it easy to target web elements precisely.\n• CSS and XPath Selectors – Playwright supports CSS selectors like Playwright class selector, Playwright ID selector, data-test attribute, and XPath selectors, including advanced queries like XPath nth child.\n• Optimized Testing with Auto-Wait – Playwright ensures stable tests by automatically waiting for elements to be actionable, reducing flakiness and improving test reliability.\n• Chaining and Parent Selection – Playwright allows selector chaining and Playwright get parent element, enabling precise element targeting within complex DOM structures.\n\nOne of the standout features of Playwright Locators is their auto-waiting and retry-ability, ensuring that actions on elements proceed only when conditions are right, thus mitigating the risks of flaky tests. They always normalize whitespace in text matches, enhancing the accuracy and reliability of tests that involve text verification.\n\nMoreover, Playwright allows for the use of regular expressions and filters by text, providing a fine-grained control over element selection that is unmatched by traditional testing tools.\n\nThis approach, where a locator must be relative, allows for the construction of complex queries that can navigate the nested structures of modern web applications with ease.\n\nFurthermore, the built-in locators and the capability to create custom locators using the Playwright Inspector tool underline the flexibility and power that Playwright brings to the table.\n\nPlaywright supports a variety of selector engines, allowing for flexible and powerful element selection strategies. The main types include:\n\nCSS selectors in Playwright are a cornerstone for selecting elements in the browser efficiently and effectively. They leverage standard CSS syntax to target elements based on their tag name, class, ID, attributes, and relationships within the DOM.\n• Type Selectors: Target elements by their tag name, e.g., , .\n• Class Selectors: Use a period followed by the class name, e.g., .\n• ID Selectors: Use a hash followed by the ID value, e.g., .\n• Attribute Selectors: Use square brackets to specify an element with a certain attribute, e.g., .\n• Pseudo-classes and Pseudo-elements: Use pseudo-classes ( , ) and pseudo-elements ( , ) for state-based and structural targeting.\n• Combinators: Use combinators like , , to define relationships between elements, e.g., selects elements with class that are direct children of a .\n\nTo use a CSS selector in Playwright, you pass the CSS string directly into the or methods. For example:\n\n// Selecting an element by tag name const heading = page.locator('h1');\n\n// Selecting an element by ID const navbar = page.locator('#navbar'); // Selecting elements by attribute const input = page.locator('input[type=\"text\"]');\n\nCSS selectors can be combined to create more specific queries. For example, to select a button within a specific section:\n\nThis selects elements with the class within the element with the ID .\n\nPlaywright supports CSS pseudo-classes and pseudo-elements, allowing for even more precise element selection:\n\n// Selecting the first child of an element const firstItem = page.locator('ul > li:first-child');\n\nIn Playwright, matching by text is a fundamental technique that enables precise targeting of elements based on their visible text content. This approach is especially useful for interacting with elements like buttons, links, and labels where the text content is a significant identifier.\n• Syntax: for exact matches, or for regular expression matches.\n• Particularly useful for selecting links, buttons, or other elements where the visible text is a clear identifier.\n\nIn Playwright, ID selectors are a straightforward and efficient way to target elements based on their unique attribute. Given that attributes are intended to be unique within an HTML document, using ID selectors can lead to very precise element selection, making them a reliable choice for identifying specific elements on a page.\n\nTo use an ID selector in Playwright, you can simply prefix the ID value with a hash ( ) symbol, similar to CSS. However, Playwright also provides a dedicated selector engine that can be used explicitly. Here are both ways to target an element by its ID:\n\nBoth lines above will target an element with the attribute of .\n\nXPath selectors in Playwright provide a powerful and flexible way to select elements based on their structure and content within the HTML document. XPath, or XML Path Language, allows you to navigate the DOM tree using paths, offering features that go beyond the capabilities of CSS selectors.\n\nThis includes selecting elements based on their text content, attributes, hierarchy, and more complex criteria.\n• Use XPath expressions to select elements based on their hierarchical position in the DOM or specific attributes.\n• Provides a powerful way to navigate complex DOM structures or select elements based on sibling or ancestor relationships.\n\nIn Playwright, data attribute selectors provide a robust way to target elements based on custom data attributes. These attributes, often prefixed with , are used for providing additional information about HTML elements without interfering with their styling or behavior.\n\nTo use data attribute selectors in Playwright, you directly utilize the attribute in your locator string. Here are some examples demonstrating how to select elements by their data attributes:\n\n// Targeting an element with a specific data attribute and value const element = page.locator('[data-test-id=\"unique-element\"]');\n\n// Using a data attribute to find a button within a specific component const button = page.locator('.component-class [data-action=\"save\"]');\n\nIn these examples, and are custom attributes used to uniquely identify elements within the page.\n• Target elements by custom data attributes, which are often used specifically for testing purposes.\n• Syntax: or selects elements with a attribute equal to .\n• Helps maintain stable tests by separating testing identifiers from CSS classes and IDs used for styling.\n\nPlaywright's role selectors provide a powerful and semantic way to target elements based on their Accessible Rich Internet Applications (ARIA) role, enhancing the accessibility testing capabilities within your automated testing suite.\n\nRole selectors make it easier to ensure that web applications are accessible and functional for users with disabilities, by allowing tests to interact with elements in a way that mirrors how assistive technologies interpret and interact with web content.\n\nTo use a role selector in Playwright, you specify the followed by the role name you are targeting. The syntax looks like this:\n\nThis example targets all elements with an ARIA role of .\n• Target elements based on their framework-specific component names. This requires using Playwright's framework-specific selectors plugin.\n• Syntax: or to select elements corresponding to a specific React or Vue component.\n• Enables testing that is more closely tied to the application's architectural components.\n\nBest Practices for Using Playwright Selectors\n• Use locator that mimic user interactions, such as text content or labels, over technical attributes like classes or IDs that may change more frequently.\n• Use attributes that are meaningful to the application's users, such as attributes for accessibility, which tend to be more stable.\n• Implement custom data attributes (e.g., , ) in your application specifically for testing purposes. These attributes provide a stable way to select elements without relying on CSS classes or IDs that might change due to styling updates.\n• Avoid using selectors that are highly dependent on the page structure or that use indexed positions, as these can easily break with UI changes.\n• CSS selectors should be concise and not overly specific to avoid breakage from minor changes in the DOM structure.\n• CSS selectors are powerful for selecting elements based on their class, ID, or other attributes. They are a good balance between simplicity and specificity.\n• Text selectors are invaluable for interacting with elements in a way that mirrors user behavior, such as clicking buttons or links labeled with specific text.\n• Playwright automatically waits for elements to be actionable before interacting with them. Ensure your selectors take advantage of this feature to reduce flakiness and the need for explicit waits.\n• When necessary, combine selectors to refine element targeting. For example, use a combination of CSS and text selectors to identify an element within a specific section of a page.\n• Use regular expressions with text selectors when you need to match elements based on patterns rather than fixed strings. This is particularly useful for dynamic content that follows a predictable format.\n• Utilize role selectors to ensure that your application is accessible. Selecting elements by their ARIA role can help validate that important elements are present and correctly labeled for screen readers.\n• While specificity is important, overly complex selectors can be hard to read and maintain. Aim for a balance between specificity and readability.\n• As your application evolves, so too should your selectors. Regularly review and update selectors to ensure they remain effective and reflect any changes in the application's UI.\n\nTo create a locator in Playwright, you use the method, passing in a string that specifies the selection criteria. Playwright supports a wide range of selector engines, including CSS, text, XPath, and others, allowing you to craft locators that can match elements in almost any scenario:\n• CSS Selectors: For selecting elements based on their CSS properties.\n• Text Selectors: For selecting elements based on their text content.\n• ID Selectors: For selecting elements by their ID.\n\nOnce you have defined a locator, you can perform various actions on the targeted element(s), such as:\n\nPlaywright locators can also handle multiple elements. For instance, to count elements matching a selector:\n\nChaining locators in Playwright refers to the process of creating a locator that is based on the context of another locator. This is particularly useful when you need to perform actions on elements that are within a specific part of the page or are related to other elements in some way.\n\nYou can chain locators using the method on an existing locator object, allowing you to refine your selection based on a relative context. This approach enables you to create precise and resilient selectors that can navigate complex page structures.\n\nIn this example, is a locator that specifically targets elements that are descendants of elements. This allows for precise targeting of elements within a specific context.\n\nIn summary, Playwright's locators and selector engines offer a powerful and flexible way to interact with web elements, supporting a wide range of scenarios from simple element selection to complex, dynamic interactions. Chaining locators further enhance this by allowing for context-specific element selection, making it easier to write stable and reliable tests.\n\nLocators are the central piece of Playwright’s automation framework, allowing you to locate and interact with elements on the page efficiently. By understanding and leveraging various locator strategies, testers can ensure stable, reliable, and maintainable automated tests. Here’s how you can take full advantage of Playwright’s locators:\n• Understand the Difference Between Locators and Selectors – A selector describes how to find elements on a web page, while an element locator is used to interact with those elements dynamically. This distinction is crucial for ensuring that the element corresponding to the locator remains valid even as the DOM updates over time.\n• Utilize Playwright’s Built-in Locators – Playwright comes with multiple locators that provide an easy way to locate elements on a web page. Locators such as , , , and are commonly used to find elements by their role, attributes, or the text they contain. Understanding when and how each locator is used will improve your test accuracy.\n• Filter and Chain Locators for Precision – Locators can be filtered to refine element matching. Whether you need to target elements containing specified text or exclude elements that do not contain certain attributes, filtering ensures precision. Additionally, chaining locators can help scope selections to a single locator and ensure that the outer locator match aligns with the intended element.\n• Handle Dynamic Content with Auto-Waiting – Elements on the web page often change state due to asynchronous loading. Playwright resolves a given locator dynamically, ensuring that actions like clicking, filling fields, or asserting values only execute when the element is interactable.\n• Leverage and Classes – When working with complex pages, including those with nested iframes, Playwright provides powerful tools like the and classes. These ensure that your automation tests can accurately locate and interact with elements inside frames or deeply nested structures.\n• Locate Elements Using Accessibility Attributes – A robust way to locate elements in web pages is by using accessibility-based locators such as , which identifies elements by their semantic roles. This approach not only improves test stability but also ensures better accessibility compliance.\n• Avoid Overly Complex Selectors – While selectors such as CSS and XPath in Playwright can be used to find elements, relying on long, complex selectors can reduce test maintainability. Instead, opt for structured locators that match key attributes and user-facing identifiers.\n\nBy applying these best practices, you can efficiently locate and interact with elements, ensuring smoother, more reliable test execution. Whether dealing with dynamic elements, elements by the text they contain, or elements based on their attributes, mastering Playwright’s locator strategies will significantly enhance your test automation efforts. Start refining your locator usage today and elevate your Playwright automation game!\n\nWhat are Locators in Playwright?\n\nLocators in Playwright represent a way to interact with elements on a web page. Unlike a direct reference to an element (like an ElementHandle), a Locator is an abstraction that allows Playwright to efficiently re-query the element in the DOM whenever an action is performed. This means that even if the page changes or the element is dynamically loaded or reloaded, Playwright can still interact with the element using the locator.\n\nCan I Use XPath with Playwright?\n\nYes, you can use XPath with Playwright. Playwright supports a wide range of selector engines for identifying elements, and XPath is one of them. XPath selectors allow you to navigate through elements and attributes in an XML document. In the context of Playwright, XPath can be used to locate web elements based on their XML path in the HTML document.\n\nWhat are the Playwright Selector Options?\n\nPlaywright supports multiple selector engines, enabling various strategies for selecting elements. Some of the selector options include:\n• CSS: Standard CSS selectors to select elements based on their class, ID, attributes, etc.\n• XPath: An expression language that allows for the navigation of XML documents to select nodes or node-sets.\n• Text: Allows selection of elements based on their text content.\n• ID: Shortcut for selecting elements based on their ID attribute.\n• Data-testid: A common pattern for selecting elements using a specific attribute often used for testing.\n\nThese selectors can be combined and used together to create powerful and precise locators for any element on a page.\n\nWhat is the Difference Between Locator and Element Handle in Playwright?\n\nThe primary difference between a Locator and an ElementHandle in Playwright lies in how they reference and interact with elements on a web page:\n• Locator: Represents a query that can be used to find an element or elements every time an action is performed. It is stateless and re-evaluates the query on the DOM whenever it is accessed. This makes locators particularly useful for dealing with dynamic content that might change or be loaded asynchronously.\n• ElementHandle: Represents a reference to an actual DOM element. ElementHandles are stateful, meaning they hold a direct reference to a particular element. If the element they reference is removed from the DOM, the handle becomes useless. ElementHandles are useful when you need to perform multiple operations on the same element and are sure that the element won't be recreated or removed."
    },
    {
        "link": "https://playwright.dev/dotnet/docs/locators",
        "document": "Locators are the central piece of Playwright's auto-waiting and retry-ability. In a nutshell, locators represent a way to find element(s) on the page at any moment.\n\nThese are the recommended built-in locators.\n• Page.GetByRole() to locate by explicit and implicit accessibility attributes.\n• Page.GetByLabel() to locate a form control by associated label's text.\n• Page.GetByPlaceholder() to locate an input by placeholder.\n• Page.GetByAltText() to locate an element, usually image, by its text alternative.\n• Page.GetByTitle() to locate an element by its title attribute.\n• Page.GetByTestId() to locate an element based on its attribute (other attributes can be configured).\n\nPlaywright comes with multiple built-in locators. To make tests resilient, we recommend prioritizing user-facing attributes and explicit contracts such as Page.GetByRole().\n\nFor example, consider the following DOM structure.\n\nLocate the element by its role of with name \"Sign in\".\n\nEvery time a locator is used for an action, an up-to-date DOM element is located in the page. In the snippet below, the underlying DOM element will be located twice, once prior to every action. This means that if the DOM changes in between the calls due to re-render, the new element corresponding to the locator will be used.\n\nNote that all methods that create a locator, such as Page.GetByLabel(), are also available on the Locator and FrameLocator classes, so you can chain them and iteratively narrow down your locator.\n\nThe Page.GetByRole() locator reflects how users and assistive technology perceive the page, for example whether some element is a button or a checkbox. When locating by role, you should usually pass the accessible name as well, so that the locator pinpoints the exact element.\n\nFor example, consider the following DOM structure.\n\nYou can locate each element by its implicit role:\n\nRole locators include buttons, checkboxes, headings, links, lists, tables, and many more and follow W3C specifications for ARIA role, ARIA attributes and accessible name. Note that many html elements like have an implicitly defined role that is recognized by the role locator.\n\nNote that role locators do not replace accessibility audits and conformance tests, but rather give early feedback about the ARIA guidelines.\n\nMost form controls usually have dedicated labels that could be conveniently used to interact with the form. In this case, you can locate the control by its associated label using Page.GetByLabel().\n\nFor example, consider the following DOM structure.\n\nYou can fill the input after locating it by the label text:\n\nInputs may have a placeholder attribute to hint to the user what value should be entered. You can locate such an input using Page.GetByPlaceholder().\n\nFor example, consider the following DOM structure.\n\nYou can fill the input after locating it by the placeholder text:\n\nFind an element by the text it contains. You can match by a substring, exact string, or a regular expression when using Page.GetByText().\n\nFor example, consider the following DOM structure.\n\nYou can locate the element by the text it contains:\n\nYou can also filter by text which can be useful when trying to find a particular item in a list.\n\nAll images should have an attribute that describes the image. You can locate an image based on the text alternative using Page.GetByAltText().\n\nFor example, consider the following DOM structure.\n\nYou can click on the image after locating it by the text alternative:\n\nLocate an element with a matching title attribute using Page.GetByTitle().\n\nFor example, consider the following DOM structure.\n\nYou can check the issues count after locating it by the title text:\n\nTesting by test ids is the most resilient way of testing as even if your text or role of the attribute changes, the test will still pass. QA's and developers should define explicit test ids and query them with Page.GetByTestId(). However testing by test ids is not user facing. If the role or text value is important to you then consider using user facing locators such as role and text locators.\n\nFor example, consider the following DOM structure.\n\nYou can locate the element by its test id:\n\nBy default, Page.GetByTestId() will locate elements based on the attribute, but you can configure it in your test config or by calling Selectors.SetTestIdAttribute().\n\nSet the test id to use a custom data attribute for your tests.\n\nIn your html you can now use as your test id instead of the default .\n\nAnd then locate the element as you would normally do:\n\nIf you absolutely must use CSS or XPath locators, you can use Page.Locator() to create a locator that takes a selector describing how to find an element in the page. Playwright supports CSS and XPath selectors, and auto-detects them if you omit or prefix.\n\nXPath and CSS selectors can be tied to the DOM structure or implementation. These selectors can break when the DOM structure changes. Long CSS or XPath chains below are an example of a bad practice that leads to unstable tests:\n\nAll locators in Playwright by default work with elements in Shadow DOM. The exceptions are:\n• Locating by XPath does not pierce shadow roots.\n\nConsider the following example with a custom web component:\n\nYou can locate in the same way as if the shadow root was not present at all.\n\nTo ensure that contains the text \"Details\":\n\nConsider the following DOM structure where we want to click on the buy button of the second product card. We have a few options in order to filter the locators to get the right one.\n\nLocators can be filtered by text with the Locator.Filter() method. It will search for a particular string somewhere inside the element, possibly in a descendant element, case-insensitively. You can also pass a regular expression.\n\nAlternatively, filter by not having text:\n\nLocators support an option to only select elements that have or have not a descendant matching another locator. You can therefore filter by any other locator such as a Locator.GetByRole(), Locator.GetByTestId(), Locator.GetByText() etc.\n\nWe can also assert the product card to make sure there is only one:\n\nThe filtering locator must be relative to the original locator and is queried starting with the original locator match, not the document root. Therefore, the following will not work, because the filtering locator starts matching from the list element that is outside of the list item matched by the original locator:\n\nWe can also filter by not having a matching element inside.\n\nNote that the inner locator is matched starting from the outer one, not from the document root.\n\nYou can chain methods that create a locator, like Page.GetByText() or Locator.GetByRole(), to narrow down the search to a particular part of the page.\n\nIn this example we first create a locator called product by locating its role of . We then filter by text. We can use the product locator again to get by role of button and click it and then use an assertion to make sure there is only one product with the text \"Product 2\".\n\nYou can also chain two locators together, for example to find a \"Save\" button inside a particular dialog:\n\nMethod Locator.And() narrows down an existing locator by matching an additional locator. For example, you can combine Page.GetByRole() and Page.GetByTitle() to match by both role and title.\n\nIf you'd like to target one of the two or more elements, and you don't know which one it will be, use Locator.Or() to create a locator that matches any one or both of the alternatives.\n\nFor example, consider a scenario where you'd like to click on a \"New email\" button, but sometimes a security settings dialog shows up instead. In this case, you can wait for either a \"New email\" button, or a dialog and act accordingly.\n\nConsider a page with two buttons, the first invisible and the second visible.\n• This will find both buttons and throw a strictness violation error:\n• This will only find a second button, because it is visible, and then click it.\n\nYou can assert locators in order to count the items in a list.\n\nFor example, consider the following DOM structure:\n\nUse the count assertion to ensure that the list has 3 items.\n\nYou can assert locators in order to find all the text in a list.\n\nFor example, consider the following DOM structure:\n\nUse Expect(Locator).ToHaveTextAsync() to ensure that the list has the text \"apple\", \"banana\" and \"orange\".\n\nThere are many ways to get a specific item in a list.\n\nUse the Page.GetByText() method to locate an element in a list by its text content and then click on it.\n\nFor example, consider the following DOM structure:\n\nLocate an item by its text content and click it.\n\nUse the Locator.Filter() to locate a specific item in a list.\n\nFor example, consider the following DOM structure:\n\nLocate an item by the role of \"listitem\" and then filter by the text of \"orange\" and then click it.\n\nUse the Page.GetByTestId() method to locate an element in a list. You may need to modify the html and add a test id if you don't already have a test id.\n\nFor example, consider the following DOM structure:\n\nLocate an item by its test id of \"orange\" and then click it.\n\nIf you have a list of identical elements, and the only way to distinguish between them is the order, you can choose a specific element from a list with Locator.First, Locator.Last or Locator.Nth().\n\nHowever, use this method with caution. Often times, the page might change, and the locator will point to a completely different element from the one you expected. Instead, try to come up with a unique locator that will pass the strictness criteria.\n\nWhen you have elements with various similarities, you can use the Locator.Filter() method to select the right one. You can also chain multiple filters to narrow down the selection.\n\nFor example, consider the following DOM structure:\n\nTo take a screenshot of the row with \"Mary\" and \"Say goodbye\":\n\nYou should now have a \"screenshot.png\" file in your project's root directory.\n\nThe code inside Locator.EvaluateAllAsync() runs in the page, you can call any DOM apis there.\n\nLocators are strict. This means that all operations on locators that imply some target DOM element will throw an exception if more than one element matches. For example, the following call throws if there are several buttons in the DOM:\n\nOn the other hand, Playwright understands when you perform a multiple-element operation, so the following call works perfectly fine when the locator resolves to multiple elements.\n\nYou can explicitly opt-out from strictness check by telling Playwright which element to use when multiple elements match, through Locator.First, Locator.Last, and Locator.Nth(). These methods are not recommended because when your page changes, Playwright may click on an element you did not intend. Instead, follow best practices above to create a locator that uniquely identifies the target element.\n\nFor less commonly used locators, look at the other locators guide."
    }
]