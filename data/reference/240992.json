[
    {
        "link": "https://mpja.com/download/stc89c52rcdata.pdf",
        "document": ""
    },
    {
        "link": "https://stcmicro.com/STC/STC89C52RC.html",
        "document": ""
    },
    {
        "link": "http://mcudreams.blogspot.com/2012/12/programming-stc-89c52-microcontroller.html",
        "document": "A tool to transfer the machine code to the MCU\n\n A programmer consist of a software part and/or a hardware part. The above development boards supports programming using serial port and comes with a USB to serial adapter cable(more on this later)\n\nThe accompanying CD comes with a programing software(STC ISP V4.80)\n\nIf you are buying a universal programmer make sure it supports the MCU in the development board and also has a good user manual in the language you understand. BTW most of the MCU nowadays support ISP so you can buy a USB ISP tool and wire it to the ISP pins on the MCU or to the ISP port on the development board.\n\n \n\n At this point if you have got the stuff 1 &2 from 'Things you need' you are ready for setup and then to write your first program. Below are the steps you should follow At this point if you have got the stuff 1 &2 from 'Things you need' you are ready for setup and then to write your first program. Below are the steps you should follow\n\n\n\n This is needed to download your program into the MCU \n\n \n\n Install the driver (HL-340) from the CD or google for HL-340 driver \n\n \n\n \n\n \n\n Click on INSTALL\n\n \n\n \n\n After installing the driver connect the USB to Serial cable to your PC using the USB port.\n\n \n\n \n\n \n\n Windows will prompt you to install driver for the new hardware, chose windows to automatically install the driver. \n\n \n\n \n\n \n\n After successful configuration, verify that the driver has been installed properly using the device manager. You should be seeing a new COM port(e.g COM4) assigned. The port assignment is based on the USB port you connect the cable to.\n\n \n\n \n\n If you unplug the cable, the device manager will refresh as below\n\n \n\n \n\n Click on INSTALLAfter installing the driver connect the USB to Serial cable to your PC using the USB port.Windows will prompt you to install driver for the new hardware, chose windows to automatically install the driver.After successful configuration, verify that the driver has been installed properly using the device manager. You should be seeing a new COM port(e.g COM4) assigned. The port assignment is based on the USB port you connect the cable to.If you unplug the cable, the device manager will refresh as below \n\n \n\n \n\n Closeup of the USB to RS-232 chip inside the cable How to open device manager in XP ? Simple, type devmgmt.msc in the Run dialog box(Win key + r)Closeup of the USB to RS-232 chip inside the cable\n\nBased on your version of Keil (uv2, uv3 or uv4), copy the corresponding CDB to kiel install and update the tools.ini file as below\n\nFor e.g. if you have\n\n\n\n Unfortunately i am unable to find the English version of the tool which supports STC89C52RC (i guess its better to buy a development board with the latest MCU i.e the 90, 10, 11, 12 or 15 series).\n\n \n\n I downloaded a later version (4.83) from stcmcu.com and installed it \n\n \n\n \n\n \n\n \n\n Now connect the development board to your PC and switch on the power \n\n \n\n \n\n You should see the factory loaded program running. :) The board is working !!!\n\n Don't worry if nothing happens, power off and recheck the connections. If still nothing happens, maybe there is no pre-installed program, just carry on.\n\n \n\n Now to program the MCU you need to connect the serial cable. Power off the board and connect the USB to Serial cable. Switch on the power and you should see the existing program running again.\n\n \n\n \n\n \n\n \n\n \n\n Step 5: Write a simple program in C using Keil STC89C52RC (i guess its better to buy a development board with the latest MCU i.e the 90, 10, 11, 12 or 15 series).I downloaded a later version (4.83) from stcmcu.com and installed itYou should see the factory loaded program running. :) The board is working !!!Don't worry if nothing happens, power off and recheck the connections. If still nothing happens, maybe there is no pre-installed program, just carry on.Now to program the MCU you need to connect the serial cable. Power off the board and connect the USB to Serial cable. Switch on the power and you should see the existing program running again.\n\nStartup Keil, create a new project and select the target as STC89C52RC(or the MCU you are using). Create a C source file and add it to the project. Google on how to use Keil.\n\nI just copied some code from the CD that came with the board, this displays numbers in the first 7 segment LED display"
    },
    {
        "link": "https://buydisplay.com/download/ic/STC89C51(STC89LE51).pdf?srsltid=AfmBOoqCM99alB5kmop4ZBvGFP4dTqLzI05zCegjLZ4D8d1-kr9o6CSZ",
        "document": ""
    },
    {
        "link": "https://ceptimus.co.uk/index.php/2015/12/15/isp-programmer-for-the-stc89c51-and-stc89c52",
        "document": "I couldn’t find an ISP (programmer) for the STC89C52RC that worked with modern versions of Windows. I found several programmers that work with other chips in the STC range.\n\nI did find one that worked on Windows XP, and with some hacking got it to work with Windows 7; however I had no luck with Windows 10. In any case, it was a Chinese program, and as I don’t read that language, I just had to remember which controls to use.\n\nI also found one that worked under Linux, from the command line. Using that source code as a guide I figured out how to write my own Windows version.\n\nIt’s pretty basic but all you really need. You select the COM port and the hex file you want to upload. Connect up to your chip with a 5-volt serial port such as an FTDI (or you can use an Arduino UNO or similar that has a 5V FTDI built-in).\n\nHere’s the video showing how to use the Arduino UNO as a programmer. Here it’s being used to program a Banggood POV kit which uses an STC89C52RC chip – but you could obviously adapt the Arduino sketch and/or make a wiring harness to work with any STC89 board:\n\nHere’s the Arduino sketch when you’re using the UNO as a programmer as shown in the video: Arduino sketch\n\nEdit: the programmer program is now at V0.4 which fixes a few bugs and lets you switch the microcontroller to high speed (6T per machine cycle) or normal speed (12T per machine cycle).\n\nFurther Edit (August 2017): the programmer program is now at V0.5, and supports some different STC-chip bootloader firmware versions that previous versions did not.\n\nIf you’re not using the Arduino (which powers up the STC chip by itself when it detects activity on the serial port) then press the button to start the upload and then apply power to the target chip. There’s a progress bar indicator – it takes maybe ten seconds to program the chip.\n\nI’ve tried it on Windows 10 and Windows 7. I’ve no reason to suspect that it won’t work with other versions of Windows.\n\nBeware the fake Prolific serial chips that come in some USB-serial adapters and some cheap STC89C5x development boards. I have one of those boards. I found an old version of the driver that let me get the Prolific chip operating as a loop back device – it even worked under Windows 10. But it’s flaky and doesn’t work for programming the chip. I found the only way I could get the programmer to work reliably was to cut the tracks leading from the STC chip’s serial port to the Prolific chip and connect an FTDI interface to the STC chip instead.\n\nYou may also need to fit a pull-up resistor to the STC’s TxD pin – only try that if you think you’ve connected everything up properly but it’s still not working – something like 10K or 100K should do the trick. It depends on how much pull-up effect is already present on the RxD line of your serial interface and on the amount of stray capacitance present on your boards and cables.\n\nHere is the link to download the install zip file for the programmer\n\nUpdate: Ewald Burger (see comments below) encountered problems with the installation that he eventually traced to his AVAST virus scanner. If you encounter problems with the installation you may want to try temporarily disabling your virus scanner while installing.\n\nHere’s the source code – unzip it to your ‘projects’ folder. It was done using the free version of Visual Studio 2015 source code"
    },
    {
        "link": "https://elprocus.com/embedded-system-programming-using-keil-c-language",
        "document": "Embedded C is the most popular programming language in the software field for developing electronic gadgets. Each processor is associated with embedded software. Embedded C Programming plays a major role in performing specific functions by the processor. In our day-to-day life, we frequently use many electronic devices such as washing machines, mobile phones, digital camera and so on will work based on microcontrollers that are programmed by embedded C.\n\nThe C code written is more reliable, portable, and scalable; and in fact, much easier to understand. The first and foremost tool is the embedded software that decides the operation of an embedded system. Embedded C programming language is most frequently used for programming the microcontrollers.\n\nFor writing the program the embedded designers must have sufficient knowledge on the hardware of particular processors or controllers as the embedded C programming is a full hardware related programming technique.\n\nEarlier, many embedded applications were developed by using assembly level programming. However, they did not provide portability to overcome this problem with the advent of various high-level languages like C, COBOL, and Pascal. However, it was the C language that got extensive acceptance for embedded systems application development, and it continues to do so.\n\nThe embedded system is defined as the combination of embedded C programming software and hardware part majorly consist of microcontrollers and it is intended to perform the specific task. These types of embedded systems are being used in our daily life such as washing machines and video recorders, refrigerators and so on. The embedded system was first introduced by the 8051 microcontrollers.\n\nThe 8051 microcontroller is a basic microcontroller, it is first introduced by the ‘Intel Corporation’ since 1970. It is developed by the 8086 processor architecture. The 8051 is a family of the microcontroller, which has been developed by different manufacturers such as Philips, Atmel, dalls, and so on. The 8051 microcontrollers has been used in lots of embedded products from small children’s toys to large automotive systems.\n\nThe 8051 microcontroller is the 8-bit ‘CISC’ architecture. It consists of memories, serial communication, interrupts, input/output ports and timer/counters, built into a single integrated chip, which is programmed to control the peripheral devices which are interfaced with it. The program is stored in the RAM of the microcontroller but before writing the program, we must aware of the RAM organization of the microcontroller.\n\nEvery function is a collection of statements that perform a specific task and the collection of one or more functions is called a programming language. Every language consists of some basic elements and grammatical rules. The C language programming is designed to function with the character set, variables, data types, constants, keywords, expressions and so on are used to write a C program. All these considered under header file or library file and it is represented as\n\nThe extension of the C language is called an Embedded C programming language. As compared with above, the embedded programming in C language has some additional features such as data types and keywords and header file or library file is represented as\n\nThe “sbit” is used for declaring the single PIN of the microcontroller. For example, LED is connected to the P0.1 pin, it is not recommended to send the value to the port pin directly, first, we have to declare the pin with another variable then after we can use anywhere in the program.\n\nSyntax: sbit a=P0^1; //declares the respective pin with a variable//\n\n a=0x01; //send the value to the port pin//\n\nThe “bit” is used for checking the status of the variable.\n\nSyntax: bit c; //declares the bit variable//\n\n c=a; //a value is assigned to the c variable //\n\n if(c==1) //check the condition true or false//\n\nThe “SFR” keyword is used to access the SFR registers by another name. The SFR register defined as a special function register, it contains all peripherally related registers by indicating the address. The SFR register is declared by the SFR keyword. The SFR keyword must be in capital letters.\n\nSyntax: SFR port=0x00; //0x00 is a port0 address it is declared by port variable//\n\n Port=0x01; //then send the value to the port0//\n\n delay();\n\n port=0x00;\n\n delay();\n\nThe “volatile” keyword is the most important in embedded system development. The variable that declares with the volatile keyword value could not be changed unexpectedly. It can be used in memory-mapped peripheral registers, global variables modified by the ISRs. Without using the volatile keyword for transmitting and receiving the data, code error or an optimization error will take place.\n\nThe macro is a name it is used to declare the block of statements as a pre-processor directive. Whenever the name is used, it is replaced by the contents of the macro. The macros represent the #define. The whole port pins are defined by the macros.\n\nSyntax: #define dat Po; //the whole port is declared by a variable//\n\n dat=0x01; //data send to the port0//\n\nThe microcontroller programming will differ for each type of operating system. Even though there are many operating systems are existing such as Linux, Windows, RTOS and so on. However, RTOS has several advantages for embedded system development. This article discusses basic embedded C programming to develop embedded C programming using an 8051 microcontroller.\n\nThe LED is a semiconductor device which is used in many applications, mostly for indication purpose. It is finding a huge range of applications as indicators during the test to check the validity of results at different stages. They are very cheap and easily available in a variety of shapes, colors, and sizes. The LEDs are used to design message display boards and traffic control signal lights etc. Here the LEDs are interfaced with the PORT0 of the 8051 microcontrollers.\n\n#include<reg51.h> //header file//\n\n void main() //the program execution stat point//\n\n {\n\n unsigned int i; //data type//\n\n while(1) //for continuous loop//\n\n {\n\n P0=0x55; //send the hexa value to the port0//\n\n for(i=0;i<30000;i++) //normal delay//\n\n P0=0x3AA; //send the hexa value to the port0//\n\n for(i=0;i<30000;i++) //normal delay//\n\n }\n\n }\n\nThe 7-segment displays is the basic electronic displays, which are used in many systems to display the numeric information. It consists of eight LEDs which are connected in sequential manner so as to display digits from 0 to 9, when proper combinations of LEDs are switched on. They can display only one digit at a time.\n\n1. WAP to display the numbers form ‘0 to F’ on four 7segment displays ?\n\n2. WAP to display the numbers from ’00 to 10’ on 7segment displays ?\n\nThe delay is the one of the important factors in the application software development. However, the normal delay will not give the precious result to overcome this problem for implementing the timer delay. The timers and counters are hardware components of the microcontroller, which is used in many applications to provide the precious time delay with count pulses.The both tasks are implemented by the software technique.\n\nWAP to generate the 500us time delay using T1M2(timer1 and mode2) ?\n\nvoid main()\n\n {\n\n unsigned char i;\n\n TMOD=0x20; //set the timer mode//\n\n for(i=0i<2;i++) //double the time daly//\n\n {\n\n TL1=0x19; //set the time delay//\n\n TH1=0x00;\n\n TR1=1; //timer oN//\n\n While(TF1==0); //check the flag bit//\n\n TF1=0;\n\n }\n\n TR1=0; //timer off//\n\n }\n\nSerial communication is commonly used for transmitting and receiving the signal. The 8051 microcontroller have consist UART serial communication the signals transmitted and received by the Rx and Tx pins. The UART takes bytes of data and sends the individual bits in a sequential manner. The registers are a way to collect and store the data in the memory. UART is a half-duplex protocol. Half-duplex means transferring and receiving the data, but not at the same time.\n\n1. WAP to transmit the character ‘S’ to the serial window use 9600 as the baud rate?\n\n28800 is the maximum baud rate of the 8051 microcontroller\n\nThat baud rate ‘3’ is stored in the timers\n\n{\n\n SCON=0x50; //start the serial communication//\n\n TNOD=0x20; //selected the timer mode//\n\n TH1=3; // load the baud rate//\n\n TR1=1; //Timer ON//\n\n SBUF=’S’; //store the character in the register//\n\n while(TI==0); //check the interrupt register//\n\n TI=0;\n\n TR1=0; //OFF the timer//\n\n while(1); //continuous loop//\n\n }\n\n2. WAP to receive the data from the hyperterminal and send that data to the PORT 0 of the Microcontroller using 9600 baud?\n\n28800 is the maximum baud rate of the 8051 microcontroller\n\nThat baud rate ‘3’ is stored in the timers\n\nvoid main()\n\n {\n\n SCON=0x50; //start the serial communication//\n\n TMOD=0x20; //selected the timer mode//\n\n TH1=3; // load the baud rate//\n\n TR1=1; //Timer ON//\n\n PORT0=SBUF; //send the data from SBUF to port0//\n\n while(RI==0); //check the interrupt register//\n\n RI=0;\n\n TR1=0; //OFF the timer//\n\n while(1); //stop the program when character is received//\n\n }\n\nThe interrupt is a signal that forcing to stop the current program and execute the other program immediately. The 8051 microcontroller provide 6 interrupt, which are internal and external interrupt sources. When the interrupt occurs the microcontroller pause the current task and attend to the interrupt by executing the ISR then microcontroller returns back to the recent task.\n\nWAP to perform left shift operation when timer 0 interrupts occurs then perform the interrupt operation for the P0 in the main function?\n\nThe matrix keypad is an analog switching device, which is used in many embedded applications to allow the user to perform the necessary tasks. A matrix keypad consists of an arrangement of switches in matrix format in rows and columns. The rows and columns are connected to the microcontroller such that the row of switches are connected to one pin and switches in each column are connected to another pin, then perform the operations.\n\n1. WAP to toggle the LED by pressing the switch\n\n#include<reg51.h>\n\n sbit a=P3^0;\n\n sbit b=P3^1;\n\n sbit c=P3^2;\n\n sbit d=P3^3;\n\n void delay();\n\n void main()\n\n {\n\n while(1)\n\n {\n\n a=0;\n\n b=1;\n\n c=1;\n\n d=1;\n\n delay();\n\n a=1;\n\n b=0;\n\n c=1;\n\n d=1;\n\n void delay()\n\n {\n\n unsigned char i;\n\n TMOD=0x20; //set the timer mode//\n\n for(i=0i<2;i++) //double the time daly//\n\n {\n\n TL1=0x19; //set the time delay//\n\n TH1=0x00;\n\n TR1=1; //timer oN//\n\n While(TF1==0); //check the flag bit//\n\n TF1=0;\n\n }\n\n TR1=0; //timer off//\n\n }\n\n2. WAP to Switch ON the LED by pressing the key ‘1’ on the keypad?\n\n3. WAP to display the number 0,1,2,3,4,5 on the seven segment by pressing the respective key on the keypad?\n\nThe LCD display is an electronic device, which is frequently used in many applications for displaying the information in a text or image format. The LCD is a display that can easily show characters on its screen. The LCD display have consists 8-data lines and 3-control lines which are used to interface to the microcontroller.\n\nWAP to display the “EDGEFX KITS” on LED display ?\n\nHope this article gives a basic information about embedded system programming using 8051 microcontroller with a few example programs. For detailed embedded C programming tutorial please post your comments and queries in the comment section below."
    },
    {
        "link": "https://geeksforgeeks.org/embedded-c",
        "document": "In this article, we will explore Embedded C in comparison with the C language. We will elaborate on its key characteristics and delve into its structure and data types. Additionally, we will examine its block diagram and programming steps. Furthermore, we will explore advanced techniques associated with Embedded C. Towards the end, we will review examples, advantages, and disadvantages of Embedded C.\n\nWhat is Embedded C?\n\nEmbedded C is a programming language that is used in the development of Embedded Systems. Embedded Systems are specialized systems designed to perform very specific functions or tasks. Embedded System is the combination of hardware and software, and the software is generally known as firmware which is embedded into the system hardware. Embedded C is used to program a wide range of microcontrollers and microprocessors. Embedded C requires less number of resources to execute in comparison with high-level languages such as assembly programming language.\n\nEmbedded C has some additional data types and keywords. There are some special datatypes in Embedded C like sbit, sfr which are used for addressing special function registers in memory. Embedded C allows us to work with hardware devices like sensors, and input-output devices. There are various Embedded C compilers to compile the embedded C program such as Keil Compiler, SPJ Compiler, Embedded GNU C Compiler, etc. Embedded Systems can be classified into small-scale, medium-scale, and sophisticated embedded systems. The devices like air conditioners, printers, and mobile phones that we use in our daily lives are programmed by embedded C.\n\nDifference between C and Embedded C\n\nEfficiency: In Embedded C we can create an efficient code to optimize the limited resources available in embedded systems. It aims to minimize memory usage and maximize performance.\n\nDirect Hardware Interaction: Embedded C allows programmers to interact directly with hardware components, such as microcontrollers, sensors, actuators, and other peripherals. This direct interaction facilitates precise control over the hardware, critical in embedded applications.\n\nLow-level Programming: Embedded C involves low-level programming, which deals with hardware-specific details like memory addresses, I/O ports, and register manipulation. This level of control is essential for efficiently managing hardware resources.\n\nReal-time Operations: Embedded systems often operate in real-time environments, requiring precise timing and response to events. Embedded C allows programmers to handle real-time tasks efficiently.\n• Comments: Comments are readable text written to help user understand the code easily. They are ignored by compiler and do not take up any memory in the final code. There are two types of comments, Single line comments and Multiline comments.\n• Preprocessor Directive: In Embedded C Preprocessor Directives are represented using #include or #define. Preprocessor Directives are used to indicate a header file specific to a microprocessor or microcontroller which contains all the functions, SFR's and the bits in those SFR's. reg51 header file is used in case of 8051 microcontroller.\n• Global Variables: Global variables as the name suggests are global to program that is they can be accessed anywhere in the program. Global variables are static variables and are placed in RAM memory locations.\n• Local Variables : Local variables in contrast to global variables are confined to their respective functions. Normally these variables are placed in stack or registers. It is only valid within the function in which it is declared.\n• Function: Function is a group of statements that together performs a task. A function declaration tells the compiler about the name, return type and parameter of the function. A function definition provides actual body of the function.\n• Main Function: program has one main function and may contain one or more functions in the main functions. The program execution starts from the main function, and it is a core of every execution. If more than one main function is written in the code, then compiler will confuse from where to start the program execution.\n\nProblem :Problem refers to a challenge or task which needs to be addressed by programming. The problem defines the purpose and functionality of the Embedded System. The necessary coding solutions should be achieved by understanding the problem statement. It includes functional requirements, non-functional requirements, Hardware Interfacing and Expected Output.\n\nAlgorithm :Algorithm is a set of instructions that tells us that how the task should be executed in step-wise manner in order to solve the problem. Algorithm helps us to visualize and design the logic before implementation of actual program. It is written in step by step order. Let's take a look at an example for better understanding.\n\nAlgorithm to add two numbers and store the result :\n• Make the Port 1 and Port 2 as Input port .\n• None Take the data from Port 1.\n• None Take the data from Port 2.\n• None Add the content of Port 1 with Port 2\n\nFlowchart : A flowchart is a graphical representation of an algorithm which shows the steps to be followed using some symbols and arrows. Flowchart makes it easy to understand the structure of program before coding by visualizing the flow of logic. It shows decision points such as conditional statement, loops and code terminations. As it uses symbols and shapes, debugging is easy and it takes less efforts in writing the logic of a program. Flowchart and Algorithm helps in identifying logical errors while troubleshooting the code which is a difficult process in itself.\n\nCompilation and Uploading of Code :Generally programmers write code using high level languages like C where human readable syntax is used. This language is not understandable by CPU of computer. We need to translate it into machine level code which a CPU can easily understand. So a compiler needs to be used for this purpose. Compiler is a specialized software tool which translates the human readable code (source code) into machine code (binary code) according to the specific microcontroller architecture.\n\nThe machine code is executed by the CPU by carrying out the instructions step-by-step to perform the tasks written in the actual code written by programmer/use. Machine code consists of instructions which are understandable by the computer's CPU. It is a string of 0's and 1's representing logical, arithmetic operations. A hex file is generated after compilation process that contains the machine code which is uploaded in microcontroller's flash memory through programmer/debugger. After uploading, the code is tested and verified for correct operation of Embedded System. In this way the solution for the problem statement is achieved in Embedded C\n• Requirement Analysis: Understanding the requirements of the Embedded System to be developed according to the problem | requirement should be done.\n• Selecting Environment Setup: Selection of proper tools such as choosing Integrated Development Environment (IDE) ,compiler, debugger and other necessary tools for Embedded C Programming.\n• Code Development : Writing the Embedded C code based on the system requirements and design specifications must be done in this step. The program should consume less memory space, must be reliable and scalable.\n• Compilation Process : In this stage the compiler translates the embedded C code into assembly language code or machine level code. The machine level code is in the form of 0's and 1's. Also the preprocessor handles the directives such as #include, #define.\n• Loading to Target device : Uploading the compiled code onto the target hardware ( microcontroller, FGPA ) using tools like debugger or flash programmers needs to be done.\n• Execution and Debugging : Run the embedded system and execution of code is performed. Employing debugging tools to identify and resolve any errors or issues in the code.\n• Documentation and Maintenance : Creating proper documentation detailing the system architecture, code functionalities and memory usage. Periodically updating and maintaining the codebase to address issues.\n• Pointer manipulation : Pointers in C are powerful but can be complex. They allow direct access to memory locations, aiding in efficient data manipulation. Understanding pointer arithmetic, dynamic memory allocation (malloc/free), and using pointers accessing hardware registers or structures are crucial in embedded C programming.\n• Interrupt handling: In embedded systems, interrupts are used to handle asynchronous events. Mastering ISR involves understanding how to write interrupt service routines, handle interrupt priorities, manage shared resources, and minimize interrupt latency to ensure timely response to events.\n• RTOS (Real-Time Operating Systems): RTOS facilitates multitasking within embedded systems. Understanding concepts like task scheduling, context switching, inter-process communication (IPC), and synchronization mechanisms (semaphores, mutexes) is very much important for developing real-time embedded applications.\n• Peripheral Interfacing: Embedded systems interact with various peripherals. Knowledge of communication protocols (UART, SPI, I2C), handling GPIO pins, configuring timers, and managing interrupts related to peripherals is important for effective interfacing.\n• Low-power Optimization: Embedded devices often run on limited power. Techniques to reduce power consumption involve utilizing low-power modes provided by microcontrollers, selectively shutting down unused peripherals, and optimizing algorithms for energy efficiency.\n• Memory Management: Embedded systems have limited memory. Efficiently managing memory includes minimizing memory fragmentation, choosing appropriate data types, implementing memory pooling, and handling dynamic memory allocation carefully to avoid memory leaks.\n\n1. Write a Program to read the number 1 from port 1, number 2 from port 2 , then add them ,store the result ,send it to Port 3. \n\n\n\n2. Write a program to Turn on and off the LED with some delay.\n\n3. Write a program to transfer the data from port P0 to port P1.\n\nAdvantages of writing a program in Embedded C\n• None It is easy and less time consuming to write code in Embedded C instead of assembly programming language.\n• None Embedded C program is easier to modify and update.\n• None Code available in function libraries can be used by the programmer.\n• None Embedded C code is portable to other microcontrollers with little or no modifications.\n• None Embedded C code tends to be more readable and maintainable than assembly language.\n• None It can only perform one task at a time, it cannot perform several activities. We need to update the hardware if we changed the application.\n• None Only the hardware system is supported.\n• None It is not scalable, scalability is a problem with Embedded C.\n• None It has limitations such as restricted RAM which affects the computer's compatibility.\n\nIn summary, Embedded C is a special kind of C programming language that's super important for embedded systems. In this article we will have seen how Embedded C is different from regular C, we have gone through its basic data types and highlights its main features. we have seen how crucial Embedded C is for getting the most out of embedded systems. By looking at its pros and cons, it's clear that this language gives a lot of control and works really efficiently, even though it can be tricky to use in systems with limited resources. Whether you're just starting out or you're an expert, using Embedded C helps programmers deal with hardware and time constraints, making strong and efficient apps. As technology changes, Embedded C stays super adaptable and powerful, making it a big player in shaping the future of embedded systems.\n\n\n\n\n\n 1. How is memory management handled in Embedded C?\n\n2. How are timing operations performed in Embedded Systems using Embedded C?\n\n\n\n 3. What is the role of interrupts in Embedded C Programming?"
    },
    {
        "link": "https://reddit.com/r/embedded/comments/mwbyvw/is_c_startup_code_bad_practice",
        "document": "I have been trying to wrap my head around writing startup code in assembly for an ARM processor this past week. My problem is that the GNU-AS directives are very convoluted and inconsistent, its like a whole other programming language.. each example code uses different directives for some reason.\n\nI took a look at C startup code, and it makes miles more sense to me. Is it bad practice to do this in industry however? Is it really necessary to do in assembly these days?"
    },
    {
        "link": "https://eng.auburn.edu/~nelson/courses/elec3040_3050/C%20programming%20for%20embedded%20system%20applications.pdf",
        "document": ""
    },
    {
        "link": "https://backlot.aths.org/fetch.php/Resources/1123734/DesignPatternsForEmbeddedSystemsInCDownload.pdf",
        "document": ""
    },
    {
        "link": "https://electronicsforu.com/electronics-projects/hardware-diy/design-interrupt-based-matrix-keypad-embedded-c-driver-for-microcontroller",
        "document": "Embedded system project that generally involves a microcontroller unit (MCU) user interface (UI) is a common and inevitable requirement. The simple form of arriving this option of UI is with the help of a monochrome LCD, which serves as a basic output device and a matrix keypad interface for accepting inputs from the user. In fact, majority of the UI designs are with 2×16 LCD ASCII compliant display, typically JHD162A along with either 4×4 or 4×3 matrix keypads.\n\nHere, we start with the development of a device driver for a matrix keypad, typically written in embedded-C for microcontroller. We will consider an 8-bit AT89S52 MCU (works well for any C51 MCU), which is easily available and whose architecture is familiar to many of us. We will implement a C driver for scanning a key in the polled mode first and see how to test it without implementing or coupling the output driver (LCD).\n\nWe shall then investigate the design aspects of converting this driver by binding/locking it into an asynchronous external interrupt pin (/INT0 pin) and present the implementation and testing aspects involved in achieving driver in embedded C. It is advised to consider further aspects with Keil µVision 5 IDE with C51 cross-compiler (that support legacy C51 microcontroller families) installed in Windows 10 host PC along with simulation software such as Proteus 7.7 or above for validation.\n\nThe project has four parts where the source program (Project1 through Project4) of each part is written in embedded C programming language. The hex code generated through Keil µVision 5 IDE is used for simulation and verification using Proteus software.\n\nBefore we dig into the technicality, we need to understand the need for this conversion. Since majority of the embedded projects deal with this standard polled-loop driver for keypad, the need to convert arises in following cases:\n\n(a) When the MCU is expected to handle the traffic over serial (typically UART) port for achieving networking. Let us consider an example of handling the data using GSM’s ASCII terminal commands (AT) in the form of SMS. While the MCU is busy in handling this SMS traffic using handshaking options, if user presses any input, forcing the microcontroller’s attention, the traditional approach of polled-loop driver fails to recognise the user inputs. This requirement causes a serious problem when the user is attempting to configure the data and traffic is flooding over networking (in this case serial) interface.\n\n(b) If the MCU is busy in performing the sensor data processing, either using the off-chip ADC interface option or on-chip ADC register polling, and the user is triggering an input using the input device. In this case also, the user attention will be unanswered as the MCU is already busy in sensory task.\n\nPolled mode 4×3 embedded C driver and its validation for C51 MCU\n\nLet us consider the 4×3 matrix keypad with four rows and three columns being connected to Port 1 of AT89S52 MCU, as shown in Fig. 1. This is basically the connections in Proteus simulation software. The four LEDs are used only for testing and are connected to P2.0 through P2.3. A typical keypad layout diagram is shown in Fig. 2. The polled-loop key-scanning algorithm is very simple and straightforward, as shown in steps 1 through 7 given below:\n\nStep-1: Configure the columns as inputs (logic-1) and rows as outputs (logic-0)\n\n Step-2: Start polling the KeyScan by looking for any change in column (1 to 0)\n\n Step-3: Is there any change in columns (i.e., C1=0 or C2=0 or C3=0)\n\n If yes,\n\n then, go to Step – 4.\n\n else\n\n Go to Step-2.\n\n Step-4: Make R1=0 and keep R2=R3=R4=1 and,\n\n If C1=0 then,\n\n pressed key is – ‘1’ and return.\n\n else if C2=0 then,\n\n pressed key is – ‘2’ and return.\n\n else if C3=0 then,\n\n pressed key is – ‘3’ and return.\n\n else\n\n go to step – 5:\n\n Step-5: Make R2=0 and keep R1=R3=R4=1 and,\n\n If C1=0 then,\n\n pressed key is – ‘4’ and return.\n\n else if C2=0 then,\n\n pressed key is – ‘5’ and return.\n\n else if C3=0 then,\n\n pressed key is – ‘6’ and return.\n\n else\n\n go to step – 6:\n\n Step-6: Make R3=0 and keep R1=R2=R4=1 and,\n\n If C1=0 then,\n\n pressed key is – ‘7’ and return.\n\n else if C2=0 then,\n\n pressed key is – ‘8’ and return.\n\n else if C3=0 then,\n\n pressed key is – ‘9’ and return.\n\n else\n\n go to step – 7\n\n Step-7: Make R4=0 and keep R1=R2=R3=1 and,\n\n If C1=0 then,\n\n pressed key is – ‘*’ and return.\n\n else if C2=0 then,\n\n pressed key is – ‘0’ and return.\n\n else if C3=0 then,\n\n pressed key is – ‘#’ and return.\n\n else\n\n go to step – 2\n\nThe implementation of this first part (Project1) in embedded C function is shown in Fig. 3. Upon any key press, the ASCII equivalent of the pressed key is identified and is returned. Hence, in the testing of the circuit given in Fig. 1, the lower nibble alone is sufficient as the LEDs indicate the pressed digit.\n\nAs an example, if the user presses key-‘1’, the ASCII of ‘1’, which is 0x31, i.e., 0110 0001, is shown on the LEDs. In the same way, all the keys of the keypad may be tested by observing their equivalent binary outputs on LEDs.\n\nLet us now look at the approach of converting the above polled-loop driver by binding the interrupt and demonstrate the process of context switching from the application to interrupt service routine (ISR), and vice-versa.\n\nThere are two external interrupt pins /INT0 and /INT1 of AT89S52, which are available as alternate-pin functions of the P3.2 and P3.3 GPIOs, respectively. Among these, let us consider usage of /INT0 pin, the P3.2 pin. A three-input AND gate 4073 IC is used such that its output must be connected to /INT0 (P3.2), while the inputs are connected to the three columns C1, C2, and C3, as shown in Fig. 4.\n\nFor achieving the key input, as the columns were locked to interrupt pin, any key pressed will result into a change of column signal and thereby generate an interrupt at /INT0 pin. We must enable the interrupt /INT0 pin by configuring the IE register. Moreover, we must configure it as an edge-triggered type of interrupt using TCON register in main application.\n\nThe basic configuration in the code for Project3 is shown in Fig. 5. The MCU’s C-ISR function ‘Keypad_ISR’ is implemented as indicated in Fig. 6.\n\nSome very important observations of the implemented ISR are:\n• The interrupt must be configured as edge triggered. This is achieved in AT89S52 by configuring TCON register. Otherwise, even for a single press the interrupt will keep on running as if multiple events are occurring.\n• An interrupt service routine function must not return any value. Hence, we use the concept of global shared resource, which in our case will be the global variable. In the implementation, the variable ‘Key’ will be acting as a shared resource. Notice that this shared resource is accessible not only in the main but also in the ISR.\n• In the implementation given here an LED is intentionally connected to the unused GPIO P1.7 pin of AT89S52, which will toggle upon the key press due to line-3 of Fig. 6.\n• Whenever a key is pressed by the user, the corresponding column status in the keypad will be changed to 1. As a result, the interrupt will be triggered, and the application will be paused as it enters into /INT0 ISR. This process is called hardware context switching. Notice that during this time, the system stack will be used. (Bank-1 in RAM)\n• Inside the ISR, the actual checking or identifying the specific row’s key, which is responsible for the key press, is detected and the confirmed key is kept in the shared resource variable ‘Key’ and the ISR ends by forcing it to return. The suspended application will now be ready by context retrieval using stack’s POP operations.\n• The pseudo-code shown in Fig. 7 is proposed for detecting a valid key pressed in main code for further application development.\n• Another important inference is that there will be no key debouncing problem, unlike in polled-loop keypad. As a result, the intentional delay for every consecutive key press is not necessary.\n\nBy considering this approach of interrupt-based keypad driver, one can implement and achieve the real-time response for UI without porting the RTOS into the MCU. This is because the ISR will run irrespective of what the application is doing, forcing the CPU’s attention. Therefore, as a result if the design is done with this recommended UI, apart from achieving the real-time response, the memory footprint (both Flash and RAM) is also greatly reduced.\n\nAfter downloading the source programs from EFY website, using circuit shown in Fig.8 along with Project2, the polled-loop application is tested with any 4-digit input as user ID and ‘1982’ as password. The ISR-locked keypad driver is tested using Fig.4 and Project3. Finally, the same application with LCD is tested using Fig. 9 and Project4.\n\nN. Abid Ali Khan is Assistant Professor in the Department of ECE at Vasavi College of Engineering (Autonomous), Hyderabad. He has been working on power-efficient embedded networking architectures and is passionate about microcontrollers, ARM, RTOS, embedded systems, and programming"
    },
    {
        "link": "https://embetronicx.com/tutorials/tech_devices/matrix_keypad",
        "document": "Most of the applications of embedded systems require keypads to take the user inputs, especially in the case where an application requires more keys. With simple architecture and easy interfacing procedure, matrix keypads are replacing normal push buttons by offering more inputs to the user with the lesser I/O pins. As a Human Machine Interface (HMI) keypad plays a major role in vital microprocessor and microcontroller-based projects and equipment. Therefore, this article gives you a brief idea about the matrix keypad.\n\nA Matrix keypad is the most commonly used input device in many of the application areas like digital circuits, telephone communications, calculators, ATMs, and so on. A matrix keypad consists of a set of push-button or switches which are arranged in a matrix format of rows and columns. These keypads are available in configurations like 3×4 and 4×4 based on the application it is implemented for.\n\nWe have our own EmbeTronicX store called ChipTronicX. You can purchase the hardware from there.\n\nAt the lowest level, keyboards are organized in a matrix of rows and columns. The CPU accesses both rows and columns through ports. When a key is pressed, a row and a column make a contact. otherwise, there is no connection between rows and columns. So this is the logic we are going to use.\n\nThe status of each key can be determined by a process called Scanning. There are many methods depending on how you connect your keypad with your controller, but the basic logic is the same. For the sake of explanation, let’s assume that all the column pins (Col1 – Col4) are connected to the inputs pins and all the row pins are connected to the output pins of the microcontroller. In the normal case, all the column pins are pulled up (HIGH state) by internal or external pull-up resistors. Now we can read the status of each switch through scanning.\n• None A logic LOW is given to Row1 and others (Row2 – Row-4) HIGH\n• None Now each Column is scanned. If any switch belongs to the 1st row is pressed the corresponding column will pull down (logic LOW) and we can detect the pressed key.\n• None This process is repeated for all rows.\n\nThat’s all guys. I think you could understand the operation of the keypad. Here I show a 4×4 matrix keypad. But if you take a 3×3 or 4×3 keypad the operation will be the same. If you got an idea you can try to write coding. Thank you.\n\nYou can also read the below tutorials."
    },
    {
        "link": "https://embedjournal.com/interface-4x4-matrix-keypad-with-microcontroller",
        "document": "In this post we will discuss logic and interface of a matrix keypad (4x4 for this post) with microcontroller to reduce the number of port pins required to read a certain number of inputs (digital). The same logic applies to any matrix keypad of order NxN. Where, N is the order of the matrix.\n\nTypically one port pin is required to read a digital input into the controller. When there are a lot of digital inputs that have to be read, it is not feasible to allocate one pin for each of them. This is when a matrix keypad arrangement is used to reduce the pin count.\n\nTherefore, the number of pins that are required to interface a given number of inputs decreases with increase in the order of the matrix.\n\nExample: If the matrix is 2x2, you will need 2 pins for the rows and 2 pins for the columns. In such a case there is no difference in the cost of reading that many inputs. But if you consider a 10x10 matrix you will just need 20 pins (10 for the rows and 10 for the columns) to read 100 digital inputs.\n\nHow is it wired up internally?\n\nHere is how the matrix keypad is wired internally.\n\nFrom the circuit you can see that when one of the 16 buttons are pressed, a pair of pins are connected together. We will use this feature to detect the button that was pressed in the following sections.\n\nInitially all switches are assumed to be released. So there is no connection between the rows and columns. When any one of the switches are pressed, the corresponding row and column are connected (short circuited). This will drive that column pin (initially high) low. Using this logic, the button press can be detected. The colors red and black is for logic high and low respectively. Here are the steps involved in determining the key that was pressed.\n\nThe first step involved in interfacing the matrix keypad is to write all logic 0’s to the rows and all logic 1’s to the columns. In the image, black line symbolizes logic 0 and red line symbolizes logic 1.\n\nFor now let us assume that, the circled key is pressed and see how the key press can be detected by a software routine.\n\nNow the software has to scan the pins connected to columns of the keypad. If it detects a logic 0 in any one of the columns, then a key press was made in that column. This is because the event of the switch press shorts the C2 line with R2. Hence C2 is driven low.\n\nNote: color of the lines indicate the logic values they return.\n\nOnce the column corresponding to the key pressed is located, the next thing that the software has to do is to start writing logic 1’s to the rows sequentially (one after the other) and check if C2 becomes high. The logic is that if a button in that row was pressed, then the value written to that row will be reflected in the corresponding column (C2) as they are short circuited. Note: color of the lines indicate the logic values they return.\n\nThe procedure is followed till C2 goes high when logic high is written to a row. In this case, a logic high to the second row will be reflected in the second column.\n\nNote: color of the lines indicate the logic values they return.\n\nWe already know that the key press happened at column 2. Now we have detected that the key is in row 2. So, the position of the key in the matrix is (2,2)\n\nOnce this is detected, its up to us to name it or provide it with a task on the event of the key press.\n\nNow lets see how the above logic can be implemented in embedded C. Here is the program I wrote to test it. This code is for PIC microcontrollers with c18 lite version compiler. I as usual, used a lot of macros so if you are an Arduino user you could easily make some alterations to the code and use it. The basic concept for keypad scan is inside the while(1) loop.\n\nHere is a video demonstration for the interface of the 4x4 matrix keypad using the above code.\n\nThe above program is done with polling and utilizes the entire time of the controller to scan the keypad and display the data on the 7 segment displays. There is a cool feature on Microcontrollers called as the Interrupt on Change (IOC). As the name suggests, the controller will interrupt if it finds any change in a port. In PIC the whole of PORT B has this feature. By using the feature without any change in the hardware setup we can scan the keypad in the ISR and have more of the controller’s time to do something useful.\n\nIn my upcoming posts I will use the IOC feature to interface the keypad."
    },
    {
        "link": "http://esd.cs.ucr.edu/labs/decode_key/decode_key.html",
        "document": "In this lab, you will be reading input from a keypad and display the corresponding button pressed unto a 7-segment display. You will be required to write a C program which will determine which key has been pressed on the key pad. The program will then display the corresponding character by configuring the output port correctly ( decimal counter lab discusses the 7-segment displays). The program will be compiled using the C51 compiler and burned unto an 8051 chip. A schematic is provided below to show connections needed to implement this lab.\n\nKeypads are often used as a primary input device for embedded microcontrollers. The keypads actually consist of a number of switches, connected in a row/column arrangement as shown in Fig 2.\n\nIn order for the microcontroller to scan the keypad, it outputs a nibble to force one (only one) of the columns low and then reads the rows to see if any buttons in that column have been pressed. The rows are pulled up by the internal weak pull-ups in the 8051 ports. Consequently, as long as no buttons are pressed, the microcontroller sees a logic high on each of the pins attached to the keypad rows. The nibble driven onto the columns always contains only a single 0. The only way the microcontroller can find a 0 on any row pin is for the keypad button to be pressed that connects the column set to 0 to a row. The controller knows which column is at a 0-level and which row reads 0, allowing it to determine which key is pressed. For the keypad, the pins from left to right are: R1, R2, R3, R4, C1, C2, C3, C4.\n\nIn this lab :\n• You will read in input from the keypad\n• If you read in a number or letter, display it on the 7-segment display. If you read in \"*\" or \"#\" then display error (light up s7).\n\n/* main.c */ /* Read from a keypad and display the key pressed */ /* on an 7-segment display */ #pragma SMALL DB OE #include <reg51.h> unsigned char SetDisplay(unsigned char value){ unsigned char LookupTable[17] = { 0xC0, ... }; /* use code from previous lab */ /* fill in entries to table to handle A, B, C, D, E, F */ } /* Routine to scan the key pressed */ unsigned char key_scan() { unsigned char i, j, temp1, temp2; while( 1 ) /* keep waiting for a key to be pressed */ for(i=0; i<4; i++) { /* Set each row to 0 */ P1 = 0xff & ~(1<<i); /* Scan each column to see which key was pressed */ for (j=4; j<8; j++) { /* Code to determine the position of the key which was pressed */ /* return(position) */ } } } void main() { /* You can have a conversion table to convert the key position into a valid number or letter. The \"*\" and \"#\" symbols result in errors and map into postion 17 of the LookupTable */ unsigned char conv_table[] = { 1, 2, 3, 10, 4, 5, 6, 11, 7, 8, 9, 12, 17, 0, 17, 13 }; char num; while(1) { /*read input from user */ /* display corresponding number */ } }\n• Follow same procedure as previous lab to map your network drive, edit, compile your program.\n• Wire up the circuit as shown in the schematic."
    },
    {
        "link": "https://forum.allaboutcircuits.com/threads/matrix-keypad-row-and-column-scanning-process.141566",
        "document": "I want make routine in c programming that will read keypad get the key from keypadThis picture is just for example to show keypadI have studied about matrix keyboard and after that I have created this table to scan keypad. Is it right logic to read keypad ? I tried to make flow chart but I don't understand where to start. while making flowchart i was not deciding where to go.I have made a routine. I know this will not work in programming. we don't write program like this . There are many errors in this routine . But I think this can be make better"
    }
]