[
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_grid_layout/Realizing_common_layouts_using_grids",
        "document": "To round off this set of CSS grid layout guides, we're going to walk through a few different layouts, which demonstrate some of the techniques you can use when designing with grid layout. We will look at an example using , a 12-column flexible grid system, and also a product listing using auto-placement. As you can see from this set of examples, there is often more than one way to get the results you want with CSS grid layout. Choose the method you find most helpful for the problems that you are solving and the designs that you need to implement.\n\nA responsive layout with 1 to 3 fluid columns using Many websites are a variation of this type of layout, with content, sidebars, a header and a footer. In a responsive design, you may want to display the layout as a single column, adding a sidebar at a certain breakpoint and then bring in a three-column layout for wider screens. We're going to create this layout using the named template areas that we learned about in the Grid template areas guide. The markup is a container with elements inside for a header, footer, main content, navigation, sidebar, and a block to place advertising. <div class=\"wrapper\"> <header class=\"main-head\">The header</header> <nav class=\"main-nav\"> <ul> <li><a href=\"\">Nav 1</a></li> <li><a href=\"\">Nav 2</a></li> <li><a href=\"\">Nav 3</a></li> </ul> </nav> <article class=\"content\"> <h1>Main article area</h1> <p> In this layout, we display the areas in source order for any screen less that 500 pixels wide. We go to a two column layout, and then to a three column layout by redefining the grid, and the placement of items on the grid. </p> </article> <aside class=\"side\">Sidebar</aside> <div class=\"ad\">Advertising</div> <footer class=\"main-footer\">The footer</footer> </div> As we are using to create the layout, we need to name the areas outside of any media queries. We name areas using the property. This does not create a layout. Rather, the items now have names we can use to do so. Staying outside of any media queries we're now going to set up the layout for the mobile width. Here we're keeping everything in source order to avoid any disconnect between the source and display as described in the Grid layout and accessibility guide. We've not explicitly defined any column or row tracks; this layout dictates a single column and creates rows as needed for each item in the implicit grid. With our mobile layout in place, we can now proceed to add a query to adapt this layout for bigger screens with enough real estate to display two columns. You can see the layout taking shape in the value of . The spans over two column tracks, as does the . In the third row track, we place the alongside the . We place the content in the fourth row track so it appears under the sidebar. The is next to it under the content. We use CSS flexible box layout on the navigation to evenly space the navigation items in a row. We can now add a final breakpoint for wider screens able to display a three-column layout. The three-column layout has two unit side columns and a middle column that has as the track size. This means the available space in the container is split into six parts and assigned in proportion to our three tracks – one part each to the side columns and four parts to the center. In this layout, we're displaying the in the left column, alongside the . In the right column we have the and underneath it the advertisements ( ). The now spans across the entire bottom of the layout. Again, we use flexbox to display the navigation, but this time we display it as a column instead of a row. This basic example demonstrates how to rearrange a grid layout across different breakpoints. In particular, we're changing the location of the block as appropriate in our different column setups. This named areas method can be very helpful, especially at the prototyping stage. You may find it easier to use names rather than numbers when playing with the location of elements on the grid.\n\nCSS frameworks and grid systems commonly use 12- or 16-column flexible grids. We can create this type of system using CSS grid layout. As an example, let's create a 12-column flexible grid with 12 -unit column tracks, each with a start line named . This means that we will have twelve grid lines named . To demonstrate how this grid system works, we have four child elements inside a wrapper. <div class=\"wrapper\"> <div class=\"item1\">Start column line 1, span 3 column tracks.</div> <div class=\"item2\"> Start column line 6, span 4 column tracks. 2 row tracks. </div> <div class=\"item3\">Start row 2 column line 2, span 2 column tracks.</div> <div class=\"item4\"> Start at column line 3, span to the end of the grid (-1). </div> </div> We can then place these on the grid using the named lines, and also the keyword. As described in the using named grid lines guide, we are using the named lines to place our items. As we have 12 lines all with the same name, we use the name and the index of the line. If you prefer, you can use the line index itself and avoid using named lines. Rather than setting the end line number, we define how many tracks this element should span using the keyword. When working with a multiple-column layout system, this method may be more intuitive for those who think of blocks in terms of the number of tracks of the grid they span, then adjusting for different breakpoints. To see how the blocks align themselves to the tracks, use the grid inspector in your browser developer tools; it likely clearly demonstrates how the items are placed. We don't need to add any markup to create a row. CSS framework grid systems often did this to stop elements popping up into the row above for browsers that don't support CSS grid layout. However, this point is now moot — all modern browsers have supported CSS grid layout for a long time. CSS grids allow us to place items into rows, with no danger of them rising up into the row above if it is left empty. Due to this strict column and row placement, we can also easily leave white space in our layout. We also don't need special classes to indent items into the grid. All we need to do is specify the start and end line for the item.\n\nTo see how this layout method works in practice, we can create the same layout we created with , this time using the 12-column grid system. Let's start with the same markup as used for the grid template areas example. <div class=\"wrapper\"> <header class=\"main-head\">The header</header> <nav class=\"main-nav\"> <ul> <li><a href=\"\">Nav 1</a></li> <li><a href=\"\">Nav 2</a></li> <li><a href=\"\">Nav 3</a></li> </ul> </nav> <article class=\"content\"> <h1>Main article area</h1> <p> In this layout, we display the areas in source order for any screen less that 500 pixels wide. We go to a two column layout, and then to a three column layout by redefining the grid, and the placement of items on the grid. </p> </article> <aside class=\"side\">Sidebar</aside> <div class=\"ad\">Advertising</div> <footer class=\"main-footer\">The footer</footer> </div> We set up our grid as we did for the 12-column layout example above. We are again going to make this a responsive layout, this time using named lines. Every breakpoint will use a 12-column grid. However, the number of tracks items will span will change depending on the size of the screen. We start mobile first. For the narrowest screens, we want the items to remain in source order and all span across the entire grid. At the next breakpoint, we want a two-column layout. Our header and navigation still span the full grid, so we do not need to specify any positioning for them. The sidebar is starting on the first column line named , spanning 3 lines. It goes after row line 3, as the header and navigation are in the first two row tracks. The panel is below the sidebar, starting at grid row line 4. Then we have the content and footer starting at col-start 4 and spanning nine tracks, taking both to the end of the grid. Finally, for screens larger than our largest breakpoint, we define a three-column version of this layout. The header continues to span right across the grid, but now the navigation moves down to become the first sidebar, with the content and then the sidebar next to it. The footer now also spans across the full layout. Once again, check the grid inspector in your browser developer tools to see how the layout has taken shape. Something to note as we created this layout is that we didn't need to explicitly position every element on the grid at each breakpoint. We inherited the placement set up for earlier breakpoints – an advantage of working \"mobile first\". We also took advantage of grid auto-placement. By keeping elements in a logical order, auto-placement does quite a lot of work for us in placing items onto the grid.\n\nIn this last example in this guide, we create a layout that entirely relies on auto-placement. Many layouts are essentially sets of \"cards\" – product listings, image galleries, and so on. A grid enables creating these listings in a way that is responsive without needing to add media queries. In this example, we combine CSS grid and flexbox layouts to make a basic product listing layout. The markup for the listing is an unordered list of items. Each item contains a heading, some text of varying height, and a call to action link. <ul class=\"listing\"> <li> <h2>Item One</h2> <div class=\"body\"> <p>The content of this listing item goes here.</p> </div> <div class=\"cta\"> <a href=\"\">Call to action!</a> </div> </li> <li> <h2>Item Two</h2> <div class=\"body\"> <p>The content of this listing item goes here.</p> </div> <div class=\"cta\"> <a href=\"\">Call to action!</a> </div> </li> <li class=\"wide\"> <h2>Item Three</h2> <div class=\"body\"> <p>The content of this listing item goes here.</p> <p>This one has more text than the other items.</p> <p>Quite a lot more</p> <p>Perhaps we could do something different with it?</p> </div> <div class=\"cta\"> <a href=\"\">Call to action!</a> </div> </li> <li> <h2>Item Four</h2> <div class=\"body\"> <p>The content of this listing item goes here.</p> </div> <div class=\"cta\"> <a href=\"\">Call to action!</a> </div> </li> <li> <h2>Item Five</h2> <div class=\"body\"> <p>The content of this listing item goes here.</p> </div> <div class=\"cta\"> <a href=\"\">Call to action!</a> </div> </li> </ul> We create a grid with a flexible number of flexible columns. We want them to be at least 200 pixels wide and share any available remaining space equally – so we always get equal-width column tracks. We achieve this with the function in our notation for track sizing. When we add this CSS, the items will be laid out as a grid. If we make the window smaller or wider, the number of column tracks changes – without media queries adding breakpoints and without needing to redefine the grid. We can tidy up the internals of the boxes using a touch of flexbox. We set the list item to and the to . We can then use an auto margin on the to push this bar down to the bottom of the box. This is one of the key reasons to use flexbox rather than CSS grid layout. If you're aligning or distributing content in a single dimension, that's a flexbox use case.\n\nThis is all looking fairly complete now. However, we sometimes have cards that contain far more content than the others. It might be nice to make those span two tracks, then they won't be so tall. We add a class on the larger item, and add a rule giving it a with a value of . When this item is encountered, it will be assigned to two tracks. This means that, at some breakpoints, we'll get a gap in the grid – where there isn't enough space to lay out a two-track item. We can make the grid backfill those gaps by setting on the grid container. Take care when doing this as it can cause items to be taken out of their logical source order. You should only do this if your items do not have a set order. Additionally, be aware of the accessibility and re-ordering issues resulting from the tab order following the source and not your reordered display. <ul class=\"listing\"> <li> <h2>Item One</h2> <div class=\"body\"><p>The content of this listing item goes here.</p></div> <div class=\"cta\"><a href=\"\">Call to action!</a></div> </li> <li> <h2>Item Two</h2> <div class=\"body\"><p>The content of this listing item goes here.</p></div> <div class=\"cta\"><a href=\"\">Call to action!</a></div> </li> <li class=\"wide\"> <h2>Item Three</h2> <div class=\"body\"> <p>The content of this listing item goes here.</p> <p>This one has more text than the other items.</p> <p>Quite a lot more</p> <p>Perhaps we could do something different with it?</p> </div> <div class=\"cta\"><a href=\"\">Call to action!</a></div> </li> <li> <h2>Item Four</h2> <div class=\"body\"><p>The content of this listing item goes here.</p></div> <div class=\"cta\"><a href=\"\">Call to action!</a></div> </li> <li> <h2>Item Five</h2> <div class=\"body\"><p>The content of this listing item goes here.</p></div> <div class=\"cta\"><a href=\"\">Call to action!</a></div> </li> </ul> Using auto-placement with some rules applied to certain items is very useful and can help with content you can't control, such as CMS output, where you have repeated items and can use structural pseudo-classes to target them."
    },
    {
        "link": "https://css-tricks.com/snippets/css/complete-guide-grid",
        "document": "CSS Grid Layout (aka “Grid” or “CSS Grid”), is a two-dimensional grid-based layout system that, compared to any web layout system of the past, completely changes the way we design user interfaces. CSS has always been used to layout our web pages, but it’s never done a very good job of it. First, we used tables, then floats, positioning and inline-block, but all of these methods were essentially hacks and left out a lot of important functionality (vertical centering, for instance). Flexbox is also a very great layout tool, but its one-directional flow has different use cases — and they actually work together quite well! Grid is the very first CSS module created specifically to solve the layout problems we’ve all been hacking our way around for as long as we’ve been making websites. The intention of this guide is to present the Grid concepts as they exist in the latest version of the specification. So I won’t be covering the out-of-date Internet Explorer syntax (even though you can absolutely use Grid in IE 11) or other historical hacks.\n\nAs of March 2017, most browsers shipped native, unprefixed support for CSS Grid: Chrome (including on Android), Firefox, Safari (including on iOS), and Opera. Internet Explorer 10 and 11 on the other hand support it, but it’s an old implementation with an outdated syntax. The time to build with grid is now! To get started you have to define a container element as a grid with , set the column and row sizes with and , and then place its child elements into the grid with and . Similarly to flexbox, the source order of the grid items doesn’t matter. Your CSS can place them in any order, which makes it super easy to rearrange your grid with media queries. Imagine defining the layout of your entire page, and then completely rearranging it to accommodate a different screen width all with only a couple lines of CSS. Grid is one of the most powerful CSS modules ever introduced.\n\nBefore diving into the concepts of Grid it’s important to understand the terminology. Since the terms involved here are all kinda conceptually similar, it’s easy to confuse them with one another if you don’t first memorize their meanings defined by the Grid specification. But don’t worry, there aren’t many of them. The element on which is applied. It’s the direct parent of all the grid items. In this example is the grid container. The dividing lines that make up the structure of the grid. They can be either vertical (“column grid lines”) or horizontal (“row grid lines”) and reside on either side of a row or column. Here the yellow line is an example of a column grid line. The space between two adjacent grid lines. You can think of them as the columns or rows of the grid. Here’s the grid track between the second and third-row grid lines. The total space surrounded by four grid lines. A grid area may be composed of any number of grid cells. Here’s the grid area between row grid lines 1 and 3, and column grid lines 1 and 3. The children (i.e. direct descendants) of the grid container. Here the elements are grid items, but isn’t. The space between two adjacent row and two adjacent column grid lines. It’s a single “unit” of the grid. Here’s the grid cell between row grid lines 1 and 2, and column grid lines 2 and 3."
    },
    {
        "link": "https://w3schools.com/css/css_rwd_grid.asp",
        "document": "Many web pages are based on a grid-view, which means that the page is divided into rows and columns.\n\nUsing a grid-view is very helpful when designing web pages. It makes it easier to place elements on the page.\n\nA responsive grid-view often has 6 or 12 columns, and will shrink and expand as you resize the browser window.\n\nFirst ensure that all HTML elements have the property set to . This makes sure that the padding and border are included in the total width and height of the elements.\n\nAdd the following at the begnning of your CSS:\n\nRead more about the property in our CSS Box Sizing chapter.\n\nWe create a grid container with five grid items (item1 = Header, item2 = Menu, item3 = Main content, item4 = right, item5 = Footer):\n\nHere is the complete HTML: <div class=\"grid-container\">\n\n\n\n <div class=\"item1\">\n\n <h1>Chania</h1>\n\n </div>\n\n \n\n <div class=\"item2\">\n\n <ul>\n\n <li>The Flight</li>\n\n <li>The City</li>\n\n <li>The Island</li>\n\n <li>The Food</li>\n\n </ul>\n\n </div>\n\n\n\n <div class=\"item3\">\n\n <h1>The City</h1>\n\n <p>Chania is the capital of the Chania region on the island of Crete.</p>\n\n <p>The city can be divided in two parts, the old town and the modern city. The old town is situated next to the old harbour and is the matrix around which the whole urban area was developed.</p>\n\n <p>Chania lies along the north west coast of the island Crete.</p>\n\n</div> \n\n\n\n <div class=\"item4\">\n\n <h2>Facts:</h2>\n\n <ul>\n\n <li>Chania is a city on the island of Crete</li>\n\n <li>Crete is a Greek island in the Mediterranean Sea</li>\n\n </ul>\n\n </div>\n\n\n\n <div class=\"item5\">\n\n <p>Resize the browser window to see how the content respond to the resizing.</p>\n\n </div>\n\n \n\n</div>\n\nWe also want to add some styles and colors to make it look better:"
    },
    {
        "link": "https://geeksforgeeks.org/how-to-create-a-responsive-css-grid-layout",
        "document": "Here are different ways to create a responsive grid layout with CSS.\n\nThis method can be used CSS Grid for a responsive layout. The grid-template-columns property adjusts columns based on space, keeping a minimum width of 200 pixels. Gaps between items are set with grid-gap. This approach ensures a flexible design that adapts to different screen sizes, ideal for responsive web development.\n\nThis approach provides flexibility in creating responsive grid layouts, allowing developers to choose between filling the space with fixed-width columns (auto-fill) or adjusting column widths to fit the container (auto-fit). The .auto-fill and .auto-fit classes are used to control the behavior of the grid columns. The .auto-fill class creates as many columns as possible with a minimum width of 200 pixels, while .auto-fit ensures that the columns fit snugly within the container, expanding or contracting as needed.\n\nThis method uses media queries to create a responsive webpage layout. The class defines the grid container with areas for the header, sidebar, content, and footer. Layout changes based on screen width, ensuring a flexible design that adapts to different sizes while maintaining structure and styling for each area."
    },
    {
        "link": "https://turing.com/kb/responsive-layouts-using-css-grid",
        "document": "What is the importance of responsive web design in today's web development landscape? Responsive web design is crucial because of the diversity of devices and screen sizes. Ensuring that a website looks and functions well across this spectrum is essential for providing a positive user experience. How can fractional units (fr), auto-sizing (auto), and percentage units be used in CSS Grid for responsive layouts? Fractional units (fr) distribute available space, auto-sizing (auto) adjusts track sizes based on content, and percentage units (%) enable proportional sizing. These are essential for creating flexible and responsive grids.\n\nWhat is CSS Grid, and how does it simplify the creation of responsive layouts? CSS Grid is a two-dimensional layout system that allows the creation of rows and columns. It simplifies responsive layout creation by providing a powerful and flexible way to design intricate layouts with ease. How do reordering and stacking of grid items contribute to responsive design? Reordering grid items using the order property allows for changes in the visual hierarchy, ensuring a logical arrangement on different screen sizes. This technique is crucial for maintaining a responsive and user-friendly layout.\n\nWhat are some key CSS Grid terminologies that developers should be familiar with? Key CSS Grid terminologies include Grid Container, Grid Item, Grid Line, Grid Cell, Grid Track, and Grid Area. Understanding these terms is essential for working effectively with CSS Grid. What role do media queries play in creating responsive designs with CSS Grid? Media queries are fundamental for adapting grid layouts to different devices and screen sizes. They allow developers to adjust grid properties based on specific conditions, ensuring optimal display on various screens."
    },
    {
        "link": "https://smashingmagazine.com/2018/04/best-practices-grid-layout",
        "document": "In some ways, we are all still so new to CSS Grid Layout. A lot of folks keep asking about best practices that are available out there. In this article, Rachel Andrew is going to try and cover some of the things that either could be described as best practices, and some things that you probably don’t need to worry about. She will ran a survey and share the results as well as her personal thoughts.\n\nAn increasingly common question — now that people are using CSS Grid Layout in production — seems to be “What are the best practices?” The short answer to this question is to use the layout method as defined in the specification. The particular parts of the spec you choose to use, and indeed how you combine Grid with other layout methods such as Flexbox, is down to what works for the patterns you are trying to build and how you and your team want to work.\n\nLooking deeper, I think perhaps this request for “best practices” perhaps indicates a lack of confidence in using a layout method that is very different from what came before. Perhaps a concern that we are using Grid for things it wasn’t designed for, or not using Grid when we should be. Maybe it comes down to worries about supporting older browsers, or in how Grid fits into our development workflow.\n\nIn this article, I’m going to try and cover some of the things that either could be described as best practices, and some things that you probably don’t need to worry about.\n\nTo help inform this article, I wanted to find out how other people were using Grid Layout in production, what were the challenges they faced, what did they really enjoy about it? Were there common questions, problems or methods being used. To find out, I put together a quick survey, asking questions about how people were using Grid Layout, and in particular, what they most liked and what they found challenging.\n\nIn the article that follows, I’ll be referencing and directly quoting some of those responses. I’ll also be linking to lots of other resources, where you can find out more about the techniques described. As it turned out, there was far more than one article worth of interesting things to unpack in the survey responses. I’ll address some of the other things that came up in a future post.\n\nIf there is any part of the Grid specification that you need to take care when using, it is when using anything that could cause content re-ordering:\n\nThis is not unique to Grid, however, the ability to rearrange content so easily in two dimensions makes it a bigger problem for Grid. However, if using any method that allows content re-ordering — be that Grid, Flexbox or even absolute positioning — you need to take care not to disconnect the visual experience from how the content is structured in the document. Screen readers (and people navigating around the document using a keyboard only) are going to be following the order of items in the source.\n\nThe places where you need to be particularly careful are when using to reverse the order in Flexbox; the property in Flexbox or Grid; any placement of Grid items using any method, if it moves items out of the logical order in the document; and using the dense packing mode of .\n\nFor more information on this issue, see the following resources:\n\nWhich Grid Layout Methods Should I Use?\n\nWhen you first take a look at Grid, it might seem overwhelming with so many different ways of creating a layout. Ultimately, however, it all comes down to things being positioned from one line of the grid to another. You have choices based on the of layout you are trying to achieve, as well as what works well for your team and the site you are building.\n\nThere is no right or wrong way. Below, I will pick up on some of the common themes of confusion. I’ve also already covered many other potential areas of confusion in a previous article “Grid Gotchas and Stumbling Blocks.”\n\nShould I Use An Implicit Or Explicit Grid?\n\nThe grid you define with and is known as the Explicit Grid. The Explicit Grid enables the naming of lines on the Grid and also gives you the ability to target the end line of the grid with . You’ll choose an Explicit Grid to do either of these things and in general when you have a layout all designed and know exactly where your grid lines should go and the size of the tracks.\n\nI use the Implicit Grid most often for row tracks. I want to define the columns but then rows will just be auto-sized and grow to contain the content. You can control the Implicit Grid to some extent with and , however, you have less control than if you are defining everything.\n\nYou need to decide whether you know exactly how much content you have and therefore the number of rows and columns — in which case you can create an Explicit Grid. If you do not know how much content you have, but simply want rows or columns created to hold whatever there is, you will use the Implicit Grid.\n\nNevertheless, it’s possible to combine the two. In the below CSS, I have defined three columns in the Explicit Grid and three rows, so the first three rows of content will be the following:\n• A track of at least 200px in height, but expanding to take content taller,\n• A track of at least 300px in height (but expands).\n\nAny further content will go into a row created in the Implicit Grid, and I am using the property to make those tracks at least 300px tall, expanding to .\n\nBy using Repeat Notation, autofill, and minmax you can create a pattern of as many tracks as will fit into a container, thus removing the need for Media Queries to some extent. This technique can be found in this video tutorial, and also demonstrated along with similar ideas in my recent article “Using Media Queries For Responsive Design In 2018.”\n\nChoose this technique when you are happy for content to drop below earlier content when there is less space, and are happy to allow a lot of flexibility in sizing. You have specifically asked for your columns to display with a minimum size, and to auto fill.\n\nThere were a few comments in the survey that made me wonder if people were choosing this method when they really wanted a grid with a fixed number of columns. If you are ending up with an unpredictable number of columns at certain breakpoints, you might be better to set the number of columns — and redefine it with media queries as needed — rather than using or .\n\nWhich Method Of Track Sizing Should I Use?\n\nI described track sizing in detail in my article “How Big Is That Box? Understanding Sizing In Grid Layout,” however, I often get questions as to which method of track sizing to use. Particularly, I get asked about the difference between percentage sizing and the unit.\n\nIf you simply use the unit as specced, then it differs from using a percentage because it distributes available space. If you place a larger item into a track then the way the until will work is to allow that track to take up more space and distribute what is left over.\n\nTo cause the unit to distribute all of the space in the grid container you need to give it a minimum size of using .\n\nSo you can choose to use in either of these scenarios: ones where you do want space distribution from a basis of auto (the default behavior), and those where you want equal distribution. I would typically use the unit as it then works out the sizing for you, and enables the use of fixed width tracks or gaps. The only time I use a percentage instead is when I am adding grid components to an existing layout that uses other layout methods too. If I want my grid components to line up with a float- or flex-based layout which is using percentages, using them in my grid layout means everything uses the same sizing method.\n\nYou will often find that you only need to place one or two items in your layout, and the rest fall into place based on content order. In fact, this is a really good test that you haven’t disconnected the source and visual display. If things pretty much drop into position based on auto-placement, then they are probably in a good order.\n\nOnce I have decided where everything goes, however, I do tend to assign a position to everything. This means that I don’t end up with strange things happening if someone adds something to the document and grid auto-places it somewhere unexpected, thus throwing out the layout. If everything is placed, Grid will put that item into the next available empty grid cell. That might not be exactly where you want it, but sat down at the end of your layout is probably better than popping into the middle and pushing other things around.\n\nWhich Positioning Method To Use?\n\nWhen working with Grid Layout, ultimately everything comes down to placing items from one line to another. Everything else is essentially a helper for that.\n\nDecide with your team if you want to name lines, use Grid Template Areas, or if you are going to use a combination of different types of layout. I find that I like to use Grid Template Areas for small components in particular. However, there is no right or wrong. Work out what is best for you.\n\nGrid In Combination With Other Layout Mechanisms\n\nRemember that Grid Layout isn’t the one true layout method to rule them all, it’s designed for a certain type of layout — namely two-dimensional layout. Other layout methods still exist and you should consider each pattern and what suits it best.\n\nI think this is actually quite hard for those of us used to hacking around with layout methods to make them do something they were not really designed for. It is a really good time to take a step back, look at the layout methods for the tasks they were designed for, and remember to use them for those tasks.\n\nIn particular, no matter how often I write about Grid versus Flexbox, I will be asked which one people should use. There are many patterns where either layout method makes perfect sense and it really is up to you. No-one is going to shout at you for selecting Flexbox over Grid, or Grid over Flexbox.\n\nIn my own work, I tend to use Flexbox for components where I want the natural size of items to strongly control their layout, essentially pushing the other items around. I also often use Flexbox because I want alignment, given that the Box Alignment properties are only available to use in Flexbox and Grid. I might have a Flex container with one child item, in order that I can align that child.\n\nA sign that perhaps Flexbox isn’t the layout method I should choose is when I start adding percentage widths to flex items and setting to 0. The reason to add percentage widths to flex items is often because I’m trying to line them up in two dimensions (lining things up in two dimensions is exactly what Grid is for). However, try both, and see which seems to suit the content or design pattern best. You are unlikely to be causing any problems by doing so.\n\nThis also comes up a lot, and there is absolutely no problem with making a Grid Item also a Grid Container, thus nesting one grid inside another. You can do the same with Flexbox, making a Flex Item and Flex Container. You can also make a Grid Item and Flex Container or a Flex Item a Grid Container — none of these things are a problem!\n\nWhat we can’t currently do is nest one grid inside another and have the nested grid use the grid tracks defined on the overall parent. This would be very useful and is what the subgrid proposals in Level 2 of the Grid Specification hope to solve. A nested grid currently becomes a new grid so you would need to be careful with sizing to ensure it aligns with any parent tracks.\n\nYou Can Have Many Grids On One Page\n\nA comment popped up a few times in the survey which surprised me, there seems to be an idea that a grid should be confined to the main layout, and that many grids on one page were perhaps not a good thing. You can have as many grids as you like! Use grid for big things and small things, if it makes sense laid out as a grid then use Grid.\n\nIn the survey, many people mentioned older browsers, however, there was a reasonably equal split between those who felt that supporting older browsers was hard and those who felt it was easy due to Feature Queries and the fact that Grid overrides other layout methods. I’ve written at length about the mechanics of creating these fallbacks in “Using CSS Grid: Supporting Browsers Without Grid.”\n\nIn general, modern browsers are far more interoperable than their earlier counterparts. We tend to see far fewer actual “browser bugs” and if you use HTML and CSS correctly, then you will generally find that what you see in one browser is the same as in another.\n\nWe do, of course, have situations in which one browser has not yet shipped support for a certain specification, or some parts of a specification. With Grid, we have been very fortunate in that browsers shipped Grid Layout in a very complete and interoperable way within a short time of each other. Therefore, our considerations for testing tend to be to need to test browsers with Grid and without Grid. You may also have chosen to use the prefixed version in IE10 and IE11, which would then require testing as a third type of browser.\n\nBrowsers which support modern Grid Layout (not the IE version) also support Feature Queries. This means that you can test for Grid support before using it.\n\nWhen using fallbacks for browsers without support for Grid Layout (or using the prefixed version for IE10 and 11), you will want to test how those browsers render Grid Layout. To do this, you need a way to view your site in an example browser.\n\nI would not take the approach of breaking your Feature Query by checking for support of something nonsensical, or misspelling the value . This approach will only work if your stylesheet is incredibly simple, and you have put absolutely everything to do with your Grid Layout inside the Feature Queries. This is a very fragile and time-consuming way to work, especially if you are extensively using Grid. In addition, an older browser will not just lack support for Grid Layout, there will be other CSS properties unsupported too. If you are looking for “best practice” then setting yourself up so you are in a good position to test your work is high up there!\n\nThere are a couple of straightforward ways to set yourself up with a proper method of testing your fallbacks. The easiest method — if you have a reasonably fast internet connection and don’t mind paying a subscription fee — is to use a service such as BrowserStack. This is a service that enables viewing of websites (even those in development on your computer) on a whole host of real browsers. BrowserStack does offer free accounts for open-source projects.\n\nTo test locally, my suggestion would be to use a Virtual Machine with your target browser installed. Microsoft offers free Virtual Machine downloads with versions of IE back to IE8, and also Edge. You can also install onto the VM an older version of a browser with no Grid support at all. For example by getting a copy of Firefox 51 or below. After installing your elderly Firefox, be sure to turn off automatic updates as explained here as otherwise it will quietly update itself!\n\nYou can then test your site in IE11 and in non-supporting Firefox on one VM (a far less fragile solution than misspelling values). Getting set up might take you an hour or so, but you’ll then be in a really good place to test your fallbacks.\n\nMany of the people responding to the survey mentioned the need to unlearn old habits and how learning Layout would be easier for people completely new to CSS. I tend to agree. When teaching people in person complete beginners have little problem using Grid while experienced developers try hard to return grid to a one-dimensional layout method. I’ve seen attempts at “grid systems” using CSS Grid which add back in the row wrappers needed for a float or flex-based grid.\n\nDon’t be afraid to try out new techniques. If you have the ability to test in a few browsers and remain mindful of potential issues of accessibility, you really can’t go too far wrong. And, if you find a great way to create a certain pattern, let everyone else know about it. We are all new to using Grid in production, so there is certainly plenty to discover and share.\n\nTo wrap up, here is a very short list of current best practices! If you have discovered things that do or don’t work well in your own situation, add them to the comments.\n• Be very aware of the possibility of content re-ordering. Check that you have not disconnected the visual display from the document order.\n• Test using real target browsers with a local or remote Virtual Machine.\n• Don’t forget that older layout methods are still valid and useful. Try different ways to achieve patterns. Don’t be hung up on having to use Grid.\n• Know that as an experienced front-end developer you are likely to have a whole set of preconceptions about how layout works. Try to look at these new methods anew rather than forcing them back into old patterns.\n• Keep trying things out. We’re all new to this. Test your work and share what you discover.\n• How To Build A Magazine Layout With CSS Grid Areas\n• Level Up Your CSS Skills With The :has() Selector"
    },
    {
        "link": "https://css-tricks.com/snippets/css/complete-guide-grid",
        "document": "CSS Grid Layout (aka “Grid” or “CSS Grid”), is a two-dimensional grid-based layout system that, compared to any web layout system of the past, completely changes the way we design user interfaces. CSS has always been used to layout our web pages, but it’s never done a very good job of it. First, we used tables, then floats, positioning and inline-block, but all of these methods were essentially hacks and left out a lot of important functionality (vertical centering, for instance). Flexbox is also a very great layout tool, but its one-directional flow has different use cases — and they actually work together quite well! Grid is the very first CSS module created specifically to solve the layout problems we’ve all been hacking our way around for as long as we’ve been making websites. The intention of this guide is to present the Grid concepts as they exist in the latest version of the specification. So I won’t be covering the out-of-date Internet Explorer syntax (even though you can absolutely use Grid in IE 11) or other historical hacks.\n\nAs of March 2017, most browsers shipped native, unprefixed support for CSS Grid: Chrome (including on Android), Firefox, Safari (including on iOS), and Opera. Internet Explorer 10 and 11 on the other hand support it, but it’s an old implementation with an outdated syntax. The time to build with grid is now! To get started you have to define a container element as a grid with , set the column and row sizes with and , and then place its child elements into the grid with and . Similarly to flexbox, the source order of the grid items doesn’t matter. Your CSS can place them in any order, which makes it super easy to rearrange your grid with media queries. Imagine defining the layout of your entire page, and then completely rearranging it to accommodate a different screen width all with only a couple lines of CSS. Grid is one of the most powerful CSS modules ever introduced.\n\nBefore diving into the concepts of Grid it’s important to understand the terminology. Since the terms involved here are all kinda conceptually similar, it’s easy to confuse them with one another if you don’t first memorize their meanings defined by the Grid specification. But don’t worry, there aren’t many of them. The element on which is applied. It’s the direct parent of all the grid items. In this example is the grid container. The dividing lines that make up the structure of the grid. They can be either vertical (“column grid lines”) or horizontal (“row grid lines”) and reside on either side of a row or column. Here the yellow line is an example of a column grid line. The space between two adjacent grid lines. You can think of them as the columns or rows of the grid. Here’s the grid track between the second and third-row grid lines. The total space surrounded by four grid lines. A grid area may be composed of any number of grid cells. Here’s the grid area between row grid lines 1 and 3, and column grid lines 1 and 3. The children (i.e. direct descendants) of the grid container. Here the elements are grid items, but isn’t. The space between two adjacent row and two adjacent column grid lines. It’s a single “unit” of the grid. Here’s the grid cell between row grid lines 1 and 2, and column grid lines 2 and 3."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_grid_layout/Realizing_common_layouts_using_grids",
        "document": "To round off this set of CSS grid layout guides, we're going to walk through a few different layouts, which demonstrate some of the techniques you can use when designing with grid layout. We will look at an example using , a 12-column flexible grid system, and also a product listing using auto-placement. As you can see from this set of examples, there is often more than one way to get the results you want with CSS grid layout. Choose the method you find most helpful for the problems that you are solving and the designs that you need to implement.\n\nA responsive layout with 1 to 3 fluid columns using Many websites are a variation of this type of layout, with content, sidebars, a header and a footer. In a responsive design, you may want to display the layout as a single column, adding a sidebar at a certain breakpoint and then bring in a three-column layout for wider screens. We're going to create this layout using the named template areas that we learned about in the Grid template areas guide. The markup is a container with elements inside for a header, footer, main content, navigation, sidebar, and a block to place advertising. <div class=\"wrapper\"> <header class=\"main-head\">The header</header> <nav class=\"main-nav\"> <ul> <li><a href=\"\">Nav 1</a></li> <li><a href=\"\">Nav 2</a></li> <li><a href=\"\">Nav 3</a></li> </ul> </nav> <article class=\"content\"> <h1>Main article area</h1> <p> In this layout, we display the areas in source order for any screen less that 500 pixels wide. We go to a two column layout, and then to a three column layout by redefining the grid, and the placement of items on the grid. </p> </article> <aside class=\"side\">Sidebar</aside> <div class=\"ad\">Advertising</div> <footer class=\"main-footer\">The footer</footer> </div> As we are using to create the layout, we need to name the areas outside of any media queries. We name areas using the property. This does not create a layout. Rather, the items now have names we can use to do so. Staying outside of any media queries we're now going to set up the layout for the mobile width. Here we're keeping everything in source order to avoid any disconnect between the source and display as described in the Grid layout and accessibility guide. We've not explicitly defined any column or row tracks; this layout dictates a single column and creates rows as needed for each item in the implicit grid. With our mobile layout in place, we can now proceed to add a query to adapt this layout for bigger screens with enough real estate to display two columns. You can see the layout taking shape in the value of . The spans over two column tracks, as does the . In the third row track, we place the alongside the . We place the content in the fourth row track so it appears under the sidebar. The is next to it under the content. We use CSS flexible box layout on the navigation to evenly space the navigation items in a row. We can now add a final breakpoint for wider screens able to display a three-column layout. The three-column layout has two unit side columns and a middle column that has as the track size. This means the available space in the container is split into six parts and assigned in proportion to our three tracks – one part each to the side columns and four parts to the center. In this layout, we're displaying the in the left column, alongside the . In the right column we have the and underneath it the advertisements ( ). The now spans across the entire bottom of the layout. Again, we use flexbox to display the navigation, but this time we display it as a column instead of a row. This basic example demonstrates how to rearrange a grid layout across different breakpoints. In particular, we're changing the location of the block as appropriate in our different column setups. This named areas method can be very helpful, especially at the prototyping stage. You may find it easier to use names rather than numbers when playing with the location of elements on the grid.\n\nCSS frameworks and grid systems commonly use 12- or 16-column flexible grids. We can create this type of system using CSS grid layout. As an example, let's create a 12-column flexible grid with 12 -unit column tracks, each with a start line named . This means that we will have twelve grid lines named . To demonstrate how this grid system works, we have four child elements inside a wrapper. <div class=\"wrapper\"> <div class=\"item1\">Start column line 1, span 3 column tracks.</div> <div class=\"item2\"> Start column line 6, span 4 column tracks. 2 row tracks. </div> <div class=\"item3\">Start row 2 column line 2, span 2 column tracks.</div> <div class=\"item4\"> Start at column line 3, span to the end of the grid (-1). </div> </div> We can then place these on the grid using the named lines, and also the keyword. As described in the using named grid lines guide, we are using the named lines to place our items. As we have 12 lines all with the same name, we use the name and the index of the line. If you prefer, you can use the line index itself and avoid using named lines. Rather than setting the end line number, we define how many tracks this element should span using the keyword. When working with a multiple-column layout system, this method may be more intuitive for those who think of blocks in terms of the number of tracks of the grid they span, then adjusting for different breakpoints. To see how the blocks align themselves to the tracks, use the grid inspector in your browser developer tools; it likely clearly demonstrates how the items are placed. We don't need to add any markup to create a row. CSS framework grid systems often did this to stop elements popping up into the row above for browsers that don't support CSS grid layout. However, this point is now moot — all modern browsers have supported CSS grid layout for a long time. CSS grids allow us to place items into rows, with no danger of them rising up into the row above if it is left empty. Due to this strict column and row placement, we can also easily leave white space in our layout. We also don't need special classes to indent items into the grid. All we need to do is specify the start and end line for the item.\n\nTo see how this layout method works in practice, we can create the same layout we created with , this time using the 12-column grid system. Let's start with the same markup as used for the grid template areas example. <div class=\"wrapper\"> <header class=\"main-head\">The header</header> <nav class=\"main-nav\"> <ul> <li><a href=\"\">Nav 1</a></li> <li><a href=\"\">Nav 2</a></li> <li><a href=\"\">Nav 3</a></li> </ul> </nav> <article class=\"content\"> <h1>Main article area</h1> <p> In this layout, we display the areas in source order for any screen less that 500 pixels wide. We go to a two column layout, and then to a three column layout by redefining the grid, and the placement of items on the grid. </p> </article> <aside class=\"side\">Sidebar</aside> <div class=\"ad\">Advertising</div> <footer class=\"main-footer\">The footer</footer> </div> We set up our grid as we did for the 12-column layout example above. We are again going to make this a responsive layout, this time using named lines. Every breakpoint will use a 12-column grid. However, the number of tracks items will span will change depending on the size of the screen. We start mobile first. For the narrowest screens, we want the items to remain in source order and all span across the entire grid. At the next breakpoint, we want a two-column layout. Our header and navigation still span the full grid, so we do not need to specify any positioning for them. The sidebar is starting on the first column line named , spanning 3 lines. It goes after row line 3, as the header and navigation are in the first two row tracks. The panel is below the sidebar, starting at grid row line 4. Then we have the content and footer starting at col-start 4 and spanning nine tracks, taking both to the end of the grid. Finally, for screens larger than our largest breakpoint, we define a three-column version of this layout. The header continues to span right across the grid, but now the navigation moves down to become the first sidebar, with the content and then the sidebar next to it. The footer now also spans across the full layout. Once again, check the grid inspector in your browser developer tools to see how the layout has taken shape. Something to note as we created this layout is that we didn't need to explicitly position every element on the grid at each breakpoint. We inherited the placement set up for earlier breakpoints – an advantage of working \"mobile first\". We also took advantage of grid auto-placement. By keeping elements in a logical order, auto-placement does quite a lot of work for us in placing items onto the grid.\n\nIn this last example in this guide, we create a layout that entirely relies on auto-placement. Many layouts are essentially sets of \"cards\" – product listings, image galleries, and so on. A grid enables creating these listings in a way that is responsive without needing to add media queries. In this example, we combine CSS grid and flexbox layouts to make a basic product listing layout. The markup for the listing is an unordered list of items. Each item contains a heading, some text of varying height, and a call to action link. <ul class=\"listing\"> <li> <h2>Item One</h2> <div class=\"body\"> <p>The content of this listing item goes here.</p> </div> <div class=\"cta\"> <a href=\"\">Call to action!</a> </div> </li> <li> <h2>Item Two</h2> <div class=\"body\"> <p>The content of this listing item goes here.</p> </div> <div class=\"cta\"> <a href=\"\">Call to action!</a> </div> </li> <li class=\"wide\"> <h2>Item Three</h2> <div class=\"body\"> <p>The content of this listing item goes here.</p> <p>This one has more text than the other items.</p> <p>Quite a lot more</p> <p>Perhaps we could do something different with it?</p> </div> <div class=\"cta\"> <a href=\"\">Call to action!</a> </div> </li> <li> <h2>Item Four</h2> <div class=\"body\"> <p>The content of this listing item goes here.</p> </div> <div class=\"cta\"> <a href=\"\">Call to action!</a> </div> </li> <li> <h2>Item Five</h2> <div class=\"body\"> <p>The content of this listing item goes here.</p> </div> <div class=\"cta\"> <a href=\"\">Call to action!</a> </div> </li> </ul> We create a grid with a flexible number of flexible columns. We want them to be at least 200 pixels wide and share any available remaining space equally – so we always get equal-width column tracks. We achieve this with the function in our notation for track sizing. When we add this CSS, the items will be laid out as a grid. If we make the window smaller or wider, the number of column tracks changes – without media queries adding breakpoints and without needing to redefine the grid. We can tidy up the internals of the boxes using a touch of flexbox. We set the list item to and the to . We can then use an auto margin on the to push this bar down to the bottom of the box. This is one of the key reasons to use flexbox rather than CSS grid layout. If you're aligning or distributing content in a single dimension, that's a flexbox use case.\n\nThis is all looking fairly complete now. However, we sometimes have cards that contain far more content than the others. It might be nice to make those span two tracks, then they won't be so tall. We add a class on the larger item, and add a rule giving it a with a value of . When this item is encountered, it will be assigned to two tracks. This means that, at some breakpoints, we'll get a gap in the grid – where there isn't enough space to lay out a two-track item. We can make the grid backfill those gaps by setting on the grid container. Take care when doing this as it can cause items to be taken out of their logical source order. You should only do this if your items do not have a set order. Additionally, be aware of the accessibility and re-ordering issues resulting from the tab order following the source and not your reordered display. <ul class=\"listing\"> <li> <h2>Item One</h2> <div class=\"body\"><p>The content of this listing item goes here.</p></div> <div class=\"cta\"><a href=\"\">Call to action!</a></div> </li> <li> <h2>Item Two</h2> <div class=\"body\"><p>The content of this listing item goes here.</p></div> <div class=\"cta\"><a href=\"\">Call to action!</a></div> </li> <li class=\"wide\"> <h2>Item Three</h2> <div class=\"body\"> <p>The content of this listing item goes here.</p> <p>This one has more text than the other items.</p> <p>Quite a lot more</p> <p>Perhaps we could do something different with it?</p> </div> <div class=\"cta\"><a href=\"\">Call to action!</a></div> </li> <li> <h2>Item Four</h2> <div class=\"body\"><p>The content of this listing item goes here.</p></div> <div class=\"cta\"><a href=\"\">Call to action!</a></div> </li> <li> <h2>Item Five</h2> <div class=\"body\"><p>The content of this listing item goes here.</p></div> <div class=\"cta\"><a href=\"\">Call to action!</a></div> </li> </ul> Using auto-placement with some rules applied to certain items is very useful and can help with content you can't control, such as CMS output, where you have repeated items and can use structural pseudo-classes to target them."
    },
    {
        "link": "https://joshwcomeau.com/css/interactive-guide-to-grid",
        "document": "CSS Grid is one of the most amazing parts of the CSS language. It gives us a ton of new tools we can use to create sophisticated and fluid layouts.\n\nIt's also surprisingly complex. It took me quite a while to truly become comfortable with CSS Grid!\n\nIn this tutorial, I'm going to share the biggest 💡 lightbulb moments I've had in my own journey with CSS Grid. You'll learn the fundamentals of this layout mode, and see how to do some pretty cool stuff with it. ✨\n\nCSS is comprised of several different layout algorithms, each designed for different types of user interfaces. The default layout algorithm, Flow layout, is designed for digital documents. Table layout is designed for tabular data. Flexbox is designed for distributing items along a single axis.\n\nCSS Grid is the latest and greatest layout algorithm. It's incredibly powerful: we can use it to build complex layouts that fluidly adapt based on a number of constraints.\n\nThe most unusual part of CSS Grid, in my opinion, is that the grid structure, the rows and columns, are defined purely in CSS:\n\nWith CSS Grid, a single DOM node is sub-divided into rows and columns. In this tutorial, we're highlighting the rows/columns with dashed lines, but in reality, they're invisible.\n\nThis is super weird! In every other layout mode, the only way to create compartments like this is by adding more DOM nodes. In Table layout, for example, each row is created with a , and each cell within that row using or :\n\nUnlike Table layout, CSS Grid lets us manage the layout entirely from within CSS. We can slice up the container however we wish, creating compartments that our grid children can use as anchors.\n\nWe opt in to the Grid layout mode with the property:\n\nBy default, CSS Grid uses a single column, and will create rows as needed, based on the number of children. This is known as an implicit grid, since we aren't explicitly defining any structure.\n\nImplicit grids are dynamic; rows will be added and removed based on the number of children. Each child gets its own row.\n\nBy default, the height of the grid parent is determined by its children. It grows and shrinks dynamically. Interestingly, this isn't even a “CSS Grid” thing; the grid parent is still using Flow layout, and block elements in Flow layout grow vertically to contain their content. Only the children are arranged using Grid layout.\n\nBut what if we give the grid a fixed height? In that case, the total surface area is divided into equally-sized rows:\n\nBy default, CSS Grid will create a single-column layout. We can specify columns using the property:\n\nBy passing two values to — and — I'm telling the CSS Grid algorithm to slice the element up into two columns.\n\nColumns can be defined using any valid CSS <length-percentage> value (opens in new tab), including pixels, rems, viewport units, and so on. Additionally, we also gain access to a new unit, the unit:\n\nstands for “fraction”. In this example, we're saying that the first column should consume 1 unit of space, while the second column consumes 3 units of space. That means there are 4 total units of space, and this becomes the denominator. The first column eats up ¼ of the available space, while the second column consumes ¾.\n\nThe unit brings Flexbox-style flexibility to CSS Grid. Percentages and values create hard constraints, while columns are free to grow and shrink as required, to contain their contents.\n\nTry shrinking this container to see the difference:\n\nIn this scenario, our first column has a cuddly ghost that has been given an explicit width of 55px. But what if the column is too small to contain it?\n• None Percentage-based columns are rigid, and so our ghost image will overflow, spilling out of the column.\n• None -based columns are flexible, and so the column won't shrink below its minimum content size, even if that means breaking the proportions.\n\nTo be more precise: the unit distributes extra space. First, column widths will be calculated based on their contents. If there's any leftover space, it'll be distributed based on the values. This is very similar to , as discussed in my Interactive Guide to Flexbox.\n\nIn general, this flexibility is a good thing. Percentages are too strict.\n\nWe can see a perfect example of this with . is a magical CSS property that adds a fixed amount of space between all of the columns and rows within our grid.\n\nCheck out what happens when we toggle between percentages and fractions:\n\nNotice how the contents spill outside the grid parent when using percentage-based columns? This happens because percentages are calculated using the total grid area. The two columns consume 100% of the parent's content area, and they aren't allowed to shrink. When we add 16px of , the columns have no choice but to spill beyond the container.\n\nThe unit, by contrast, is calculated based on the extra space. In this case, the extra space has been reduced by 16px, for the . The CSS Grid algorithm distributes the remaining space between the two grid columns.\n\nWhat happens if we add more than two children to a two-column grid?\n\nInteresting! Our grid gains a second row. The grid algorithm wants to ensure that every child has its own grid cell. It’ll spawn new rows as-needed to fulfill this goal. This is handy in situations where we have a variable number of items (eg. a photo grid), and we want the grid to expand automatically.\n\nIn other situations, though, we want to define the rows explicitly, to create a specific layout. We can do that with the property:\n\nBy defining both and , we've created an explicit grid. This is perfect for building page layouts, like the This was the name given to the most common layout in the days of the early web: a header, sidebar, main content area, and footer. layout at the top of this tutorial.\n\nCSS Grid is a wonderful tool for this sort of thing. We can structure it as a 7-column grid, with each column consuming 1 unit of space:\n\nThis works, but it's a bit annoying to have to count each of those ’s. Imagine if we had 50 columns!\n\nFortunately, there's a nicer way to solve for this:\n\nThe function will do the copy/pasting for us. We're saying we want 7 columns that are each wide.\n\nHere's the playground showing the full code, if you're curious:\n\nBy default, the CSS Grid algorithm will assign each child to the first unoccupied grid cell, much like how a tradesperson might lay tiles in a bathroom floor.\n\nHere's the cool thing though: we can assign our items to whichever cells we want! Children can even span across multiple rows/columns.\n\nHere's an interactive demo that shows how this works. Click/press and drag to place a child in the grid If you're not using a pointer device like a mouse or touchscreen, keyboard-based controls have also been provided. Check out the “Help” screen below for more information. :\n\nThe and properties allow us to specify which track(s) our grid child should occupy.\n\nIf we want the child to occupy a single row or column, we can specify it by its number. will set the child to sit in the third column.\n\nGrid children can also stretch across multiple rows/columns. The syntax for this uses a slash to delineate start and end:\n\nAt first glance, this looks like a fraction, ¼. In CSS, though, the slash character is not used for division, it's used to separate groups of values. In this case, it allows us to set the start and end columns in a single declaration.\n\nIt's essentially a shorthand for this:\n\nThere's a sneaky gotcha here: The numbers we're providing are based on the column lines, not the column indexes.\n\nIt'll be easiest to understand this gotcha with a diagram:\n\nConfusingly, a 4-column grid actually has 5 column lines. When we assign a child to our grid, we anchor them using these lines. If we want our child to span the first 3 columns, it needs to start on the 1st line and end on the 4th line.\n\nAlright, time to talk about one of the coolest parts of CSS Grid. 😄\n\nUsing what we've learned so far, we could structure it like this:\n\nThis works, but there's a more ergonomic way to do this: grid areas.\n\nHere's what it looks like:\n\nLike before, we're defining the grid structure with and . But then, we have this curious declaration:\n\nHere's how this works: We're drawing out the grid we want to create, almost as if we were making Art made out of typographical characters. Popular in the days of command-line computing. . Each line represents a row, and each word is a name we're giving to a particular slice of the grid. See how it sorta looks like the grid, visually?\n\nThen, instead of assigning a child with and , we assign it with !\n\nWhen we want a particular area to span multiple rows or columns, we can repeat the name of that area in our template. In this example, the “sidebar” area spans both rows, and so we write for both cells in the first column.\n\nShould we use areas, or rows/columns? When building explicit layouts like this, I really like using areas. It allows me to give semantic meaning to my grid assignments, instead of using inscrutable row/column numbers. That said, areas work best when the grid has a fixed number of rows and columns. and can be useful for implicit grids.\n\nThere's a big gotcha when it comes to grid assignments: tab order will still be based on DOM position, not grid position.\n\nIt'll be easier to explain with an example. In this playground, I've set up a group of buttons, and arranged them with CSS Grid:\n\nIn the “RESULT” pane, the buttons appear to be in order. By reading from left to right, and from top to bottom, we go from one to six.\n\nIf you're using a device with a keyboard, try to tab through these buttons. You can do this by clicking the first button in the top left (“One”), and then pressing to move through the buttons one at a time.\n\nYou should see something like this:\n\nThe focus outline jumps around the page without rhyme or reason, from the user's perspective. This happens because the buttons are being focused based on the order they appear in the DOM.\n\nTo fix this, we should re-order the grid children in the DOM so that they match the visual order, so that I can tab through from left to right, and from top to bottom. This will even work correctly for right-to-left languages like Arabic and Hebrew; CSS Grid columns will be mirrored in these languages, with column 1 being on the right instead of the left. And so, the same DOM order works for all languages.\n\nIn all the examples we've seen so far, our columns and rows stretch to fill the entire grid container. This doesn't need to be the case, however!\n\nFor example, let's suppose we define two columns that are each 90px wide. As long as the grid parent is larger than 180px, there will be some dead space at the end:\n\nWe can control the distribution of the columns using the property:\n\nIf you're familiar with the Flexbox layout algorithm, this probably feels pretty familiar. CSS Grid builds on the alignment properties first introduced with Flexbox, taking them even further.\n\nThe big difference is that we're aligning the columns, not the items themselves. Essentially, lets us arrange the compartments of our grid, distributing them across the grid however we wish.\n\nIf we want to align the items themselves within their columns, we can use the property:\n\nWhen we plop a DOM node into a grid parent, the default behaviour is for it to stretch across that entire column, just like how a in Flow layout will stretch horizontally to fill its container. With , however, we can tweak that behaviour.\n\nThis is useful because it allows us to break free from the rigid symmetry of columns. When we set to something other than , the children will shrink down to their default width, as determined by their contents. As a result, items in the same column can be different widths.\n\nWe can even control the alignment of a specific grid child using the property:\n\nUnlike , which is set on the grid parent and controls the alignment of all grid children, is set on the child. We can think of as a way to set a default value for on all grid children.\n\nSo far, we've been talking about how to align stuff in the horizontal direction. CSS Grid provides an additional set of properties to align stuff in the vertical direction:\n\nis like , but it affects rows instead of columns. Similarly, is like , but it handles the vertical alignment of items inside their grid area, rather than horizontal.\n\nTo break things down even further:\n• None — deals with the DOM nodes within the grid structure.\n\nFinally, in addition to , we also have . This property controls the vertical position of a single grid item within its cell.\n\nThere's one last thing I want to show you. It's one of my favourite little tricks with CSS Grid.\n\nUsing only two CSS properties, we can center a child within a container, both horizontally and vertically:\n\nThe property is a shorthand. It's syntactic sugar for this:\n\nAs we've learned, controls the position of columns. controls the position of rows. In this situation, we have an implicit grid with a single child, and so we wind up with a 1×1 grid. pushes both the row and column to the center.\n\nThere are lots of ways to center a div in modern CSS, but this is the only way I know of that only requires two CSS declarations!\n\nIn this tutorial, we've covered some of the most fundamental parts of the CSS Grid layout algorithm, but honestly, there's so much more stuff we haven't talked about!\n\nIf you found this blog post helpful, you might be interested to know that I've created a comprehensive learning resource that goes way deeper. It's called CSS for JavaScript Developers (opens in new tab).\n\nThe course uses the same technologies as my blog, and so it's chock full of interactive explanations. But there are also bite-sized videos, practice exercises, real-world-inspired projects, and even a few mini-games.\n\nIf you found this blog post helpful, you'll love the course. It follows a similar approach, but for the entire CSS language, and with hands-on practice to make sure you're actually developing new skills.\n\nIt's specifically built for folks who use a JS framework like React/Angular/Vue. 80% of the course focuses on CSS fundamentals, but we also see how to integrate those fundamentals into a modern JS application, how to structure our CSS, stuff like that.\n\nIf you struggle with CSS, I hope you'll check it out. Gaining confidence with CSS is game-changing, especially if you're already comfortable with HTML and JS. When you complete the holy trinity, it becomes so much easier to stay in flow, to truly enjoy developing web applications.\n\nYou can learn more here:\n\nI hope you found this tutorial useful. ❤️"
    },
    {
        "link": "https://w3schools.com/css/css_grid.asp",
        "document": "Try it Yourself »\n\nThe Grid Layout Module offers a grid-based layout system, with rows and columns.\n\nThe Grid Layout Module allows developers to easily create complex web layouts.\n\nThe Grid Layout Module makes it easier to design a responsive layout structure, without using float or positioning.\n\nThe CSS grid properties are supported in all modern browsers.\n\nThe CSS Grid Layout should be used for two-dimensional layout, with rows AND columns. The CSS Flexbox Layout should be used for one-dimensional layout, with rows OR columns.\n\nA grid layout consists of a parent element (the grid container), with one or more grid items.\n\nAll direct children of the grid container automatically become grid items.\n\nThe element becomes a grid container when its property is set to or ."
    }
]