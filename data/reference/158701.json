[
    {
        "link": "https://reddit.com/r/vulkan/comments/13h16id/question_regarding_vulkan_pipeline_best_practices",
        "document": "From what I could gather, in Vulkan if you want to use a different shader you have to bind a different pipeline. In following this philosophy I have found myself with increasingly complex code with what I feel is an excessive number of vulkan pipelines.\n\nIt becomes worse when you consider that different primitives require different pipelines alongside all the different combinations in between.\n\nCurrently I have this many different pipelines and it's already a little overwhelming...\n\nSo i'm wondering if there is a better approach? I did hear about so that's probably something I might try next."
    },
    {
        "link": "https://developer.arm.com/documentation/101897/latest/CPU-overheads/Pipeline-creation-in-Vulkan",
        "document": ""
    },
    {
        "link": "https://reddit.com/r/vulkan/comments/msrh2d/vulkan_best_practices_on_graphics_pipelines",
        "document": "Hi everyone, I've been learning Vulkan for a while now and I know the fundamentals. Recently I've read a bit about GPU driven rendering and bindless techniques and I really like the ideas behind it. But I would like to know more about how to aproach real world problems.\n\nHow common is this type of design on game engines or other 3D software? I know that material switches on mobile are expensive and should be avoided as much as possible, what about high end desktop GPUs? These techniques scale really nice to high polygon counts but are they worth implementing for not-so-demanding renderers too? Do you see them as \"future\", \"absolutely necessary\" for high end engines or just another tool to pick for the right job?\n\nThis is only a small part of the GPU driven rendering but to narrow down my questions a bit, I want to ask what are the best practices on pipelines, descriptor sets and shaders in general. Create pipelines and shaders per material (this is what the likes of Unreal does I think, though not necessarily on Vulkan)? Create only a few pipelines, an uber shader and use different descriptor sets for materials to access them? Limit descriptor sets too and use buffers and push constants as indices to access necessary material arrays in that uber shader? What kind of applications should use each one?\n\nAnother performance related topic I want to ask is the usage of dynamic buffers on descriptor sets. Is it always better than using separate descriptor sets or are there some cases where using separate descriptor sets are better than dynamic buffers?\n\nI know these are a lot of questions in one thread and most of the answers will be opinion based and \"depends on the use case or platform\" but that's what I want to know. I don't have experience as a professional Vulkan developer so your experiences are really appreciated. Partial answers to only some questions are also welcome. Thanks in advance."
    },
    {
        "link": "https://akmetiuk.com/posts/2022-06-17-graphics-pipeline-setup",
        "document": "This is the second article in the series covering the Vulkan graphics API, its organisation and how to get started with it. We'll cover the concept of a graphics pipeline and how one can leverage features of Scala to effectively set it up.\n\nIn this article, I'd like to summarize and share my impressions after going through the Vulkan tutorial's Presentation and Graphics pipeline basics sections.\n\nThe Vulkan tutorial's section on Presentation covers the interaction of Vulkan with the OS's window system. Vulkan's specification does not define a way to interface with the window system – for that, we need to enable WSI – Window System Integration – via an extension.\n\nEvery OS has its own window system and thus interfacing with them is platform-dependent. Fortunately, there are libraries like GLFW which abstracts the platform away, allowing the code to run on any operating system.\n\nThe WSI API provides our application with a so-called Window Surface which represents a window to render to.\n\nA swap chain is a queue of frames that are waiting to be displayed on the screen. The frames present us with buffers we can render to. These buffers are represented with views when we work with them. These views allow us to specify which part of the buffer we want to access and for which purpose. Our application will render to these views, and the result will be displayed on the screen.\n\nAn important goal we try to achieve with the swap chain is to sync image presentation with the screen refresh rate. If the presentation rate is higher than the screen refresh rate, then the presented image may change in the middle of the screen refresh, thus causing the tearing effect.\n\nThe process of rendering an image on the screen consists of a sequence of steps called the graphics pipeline. The tutorial on the graphics pipeline has the following image as an overview of the pipeline:\n\nSay you want to render a model of a car on screen. The model is composed of polygons – geometric 2D shapes that exist in the 3D space and look like a car when put together.\n\nEach polygon in turn is defined by a set of vertices. We also associate a certain texture with the model that defines the color of each point of the model's surface. Also, things like lighting affect the way the car will be rendered.\n\nThe objective of the graphics pipeline is to take the coordinates of the vertices, the associated textures, and any other information that affects how the model will be displayed. After a sequence of stages, the pipeline renders pixels to a framebuffer – a buffer that holds the resulting image.\n\nThere are two kinds of stages. Programmable stages, also called shader stages, allow you to define a program that will be executed on the GPU in a C language dialect called GLSL – OpenGL Shading Language. Fixed-function stages are GPU stages that you can't program but can configure.\n\nBefore executing the shader code, we must compile it. The code is compiled from GLSL to a binary format – the bytecode called SPIR-V. These binaries can be precompiled and shipped with the application, or they can be compiled at runtime using the compiler library.\n\nOn the graphics pipeline diagram above, yellow stages are programmable and green – fixed function:\n• Input Assembler reads the vertices and their attributes such as color.\n• Vertex Shader is a programmable stage that maps the vertex coordinates from the model space to the screen space.\n• Tessellation (the word means \"mosaic\") increases the number of polygons, thus making models more detailed.\n• Geometry Shader adds or removes primitives. This can be useful e.g. when rendering hair: a hair can be defined with a single line primitive, and the geometry shader can add two triangles around it to make it take more space.\n• Rasterization maps geometric primitives to on-screen pixels. The artifacts created during this stage are called fragments.\n• Color Blend defines how to handle overlapping fragments. E.g., should we completely replace one with another, or should we mix their colors in some way?\n\nThe objective of the graphics pipeline tutorial section is to walk us through the process of setting up the graphics pipeline. To set it up, we need to set up each of the stages that we are going to use.\n\nFor a simple application of drawing a triangle on screen (the task posed for the learner in the tutorial), the only programmable stages we need are the Vertex shader and the Fragment shader stages.\n\nVulkan's API is written in C. However, writing a Vulkan-powered program in Java brings some architectural advantages over C, such as better collection support and the fact that you don't need to specify the size of the collections you pass when instantiating Vulkan objects.\n\nScala takes the design possibilities to the next level. Here are some patterns I noticed that Scala is particularly good at when working with Vulkan via LWJGL.\n\nSetting up Vulkan for rendering is complicated, the initialization takes a lot of steps. One step may have several substeps and those may in turn have their own substeps which are useful to represent as functions. Some of those steps need helper functions. So, those functions can be conceptualized as a tree, for example:\n\nIn Java, you can't have nested methods, so you define all the functions as class members, thus losing structure. In Scala, you can define the setup functions nested one inside another, following the dependencies between steps, substeps and the utility functions. This way, you can better see the scope of usage of a given function. And, when using code folding to fold a top-level step, you also get out of the way all of its substeps and utility functions making it much easier to navigate through the code.\n\nAnother advantage of nested methods is context sharing. For example, the Java implementation with its flat methods layout needs to define a for allocation of variables in virtually every function. In contrast, the Scala implementation needs to define exactly once in the main Vulkan setup function. This is automatically available to all the functions nested inside this setup function.\n\nC, and by extension Vulkan, has a low-level memory model. When interfacing with the Vulkan API using LWJGL, you need to manually do memory allocation and deallocation. The Vulkan objects are usually represented as pointers.\n\nThere are some patterns related to this memory model that are heavily used in the Vulkan code. For example, creating a Vulkan object adheres to the following pattern:\n\nThe above code aims to create used to store all the Vulkan's global state. To do so, we:\n• Allocate the memory that will hold the pointer to the Vulkan instance we are creating, via .\n• Create by calling the function and passing to it the memory buffer for the pointer.\n• Check if the operation was successful by examining the status code returned by the method. In case of an error, throw an exception.\n• Read the pointer to the object via , possibly wrapping it in a domain object.\n\nSuch a pattern repeats itself every time we need to create some Vulkan object. Scala allows to abstract it away and the application of the pattern is now a single line:\n\nThe entire pattern is encapsulated in the method defined as follows:\n\nAnother pattern is querying Vulkan for a collection of something. Before querying for a collection, we first need to query for its size and then query for the collection itself. For example:\n\nIt is possible to replace the above with the following:\n\nThe implementation of the function is:\n\nIf you want to see more of such pattern replacements, see this PR.\n\nOne problem for me was overlooking that you need to call on s before passing them to Vulkan. This resulted in a very obscure error message that would have taken me ages to debug if not for the reference Java tutorial implementation. It is important to pay special attention to learning the protocol of interaction with all the new concepts while learning Vulkan: Vulkan often stays silent about the errors you make and they break your application in obscure ways.\n\nSetting up Vulkan is a long and complicated process. Thus, it is good to treat the tutorials as a reference, that is, the same way you treat a specification or a javadoc. This means you refer to them when you need to do a certain thing – as opposed to reading them once for learning purposes and forgetting about them afterward. For example, it's hard and frustrating to remember the entire setup sequence, and this sequence is not outlined clearly in the specification. However, it is described in detail in the tutorial, so, if you treat the tutorial as a reference, you don't need to memorize the setup sequence.\n\nScala's capability for abstraction proved instrumental while working with the low-level API. A simple thing such as a nested method structure can dramatically simplify code navigation. And features such as context parameters, structural types and an expressive type system allow for abstraction of repeating patterns. As a result, you can replace five lines with one in a dozen places in your code."
    },
    {
        "link": "https://docs.vulkan.org/samples/latest/samples/performance/pipeline_cache/README.html",
        "document": "Vulkan gives applications the ability to save internal representation of a pipeline (graphics or compute) to enable recreating the same pipeline later. This sample will look in detail at the implementation and performance implications of the pipeline creation, caching and management.\n\nCreating a Vulkan pipeline requires compiling internally. This will have a significant increase in frame time if performed at runtime. To reduce this time, you can provide a previously initialised object when calling the or functions. This object behaves like a cache container which stores the pipeline internal representation for reuse. In order to benefit from using a object, the data recorded during pipeline creation needs to be saved to disk and reused between application runs. Vulkan allows an application to obtain the binary data of a object and save it to a file on disk before terminating the application. This operation can be achieved using two calls to the function to obtain the size and object’s binary data. In the next application run, the can be initialised with the previous run’s data. This will allow the or functions to reuse the baked state and avoid repeating costly operations such as shader compilation.\n\nA graphics pipeline needs information from the render pass, render state, mesh data and shaders. This makes it harder for a game engine to prepare the Vulkan pipeline upfront because rendering is controlled by game logic. Vulkan tutorials typically show pipelines being built upfront because their state is known. This can also be achieved in a game engine by recording the pipelines created during a game run and then using the information to warmup the internal resource cache in subsequent runs of the game. In order for this system to work, resource management must be done to track the state of all the Vulkan objects required for pipeline creation and cache them for later reuse. This process is usually done by hashing the input data ( structure members) used to create the Vulkan objects. This enables a future similar request to return immediately with the cached object. The mapping between input data and the Vulkan object can also alternatively be done by creating the hash using the bitfield hash of the structure members. While the application is loading, the Vulkan resources can be prepared so that the rendering for the first frames will have minimal CPU impact as all the data necessary has been pre-computed. For example, when the level changes or the game exits, the recorded Vulkan objects can be serialised and written to a file on disk. In the next run the file can be read and deserialised to warmup the internal resource cache.\n\nThe sample demonstrates this behaviour, by allowing you to enable or disable the use of pipeline cache objects. Destroying the existing pipelines will trigger re-caching, which is a process that will slow down the application. In this case there are only 2 pipelines, and the effect is noticeable, therefore we can expect it to have a much greater impact in a real game. On the first run of the sample on a device, the first frames will have a slightly bigger execution time because the pipelines are created for the first time - this is expected behaviour. In the next runs of the sample, the is created with the data saved from the previous run and the internal resource cache. Below is a screenshot of the sample on a phone with Mali G76 GPU: Pipeline cache is enabled and Sponza is rendered at 60 FPS when the existing pipelines are destroyed. Pipeline re-creation takes 24.4 ms thanks to the pipeline cache. If we disable the pipeline cache, re-creating the pipelines takes 50.4 ms, more than double the previous time. Building pipelines dynamically without a pipeline cache can result in a sudden framerate drop."
    },
    {
        "link": "https://glfw.org/docs/latest/vulkan_guide.html",
        "document": "This guide is intended to fill the gaps between the official Vulkan resources and the rest of the GLFW documentation and is not a replacement for either. It assumes some familiarity with Vulkan concepts like loaders, devices, queues and surfaces and leaves it to the Vulkan documentation to explain the details of Vulkan functions.\n\nTo develop for Vulkan you should download the LunarG Vulkan SDK for your platform. Apart from headers and link libraries, they also provide the validation layers necessary for development.\n\nThe Vulkan Tutorial has more information on how to use GLFW and Vulkan. The Khronos Vulkan Samples also use GLFW, although with a small framework in between.\n\nFor details on a specific Vulkan support function, see the Vulkan support reference. There are also guides for the other areas of the GLFW API.\n\nGLFW itself does not ever need to be linked against the Vulkan loader.\n\nBy default, GLFW will load the Vulkan loader dynamically at runtime via its standard name: on Windows, on Linux and other Unix-like systems and on macOS.\n\nmacOS: GLFW will also look up and search the subdirectory of your application bundle.\n\nIf your code is using a Vulkan loader with a different name or in a non-standard location you will need to direct GLFW to it. Pass your version of to glfwInitVulkanLoader before initializing GLFW and it will use that function for all Vulkan entry point retrieval. This prevents GLFW from dynamically loading the Vulkan loader.\n\nmacOS: To make your application be redistributable you will need to set up the application bundle according to the LunarG SDK documentation. This is explained in more detail in the SDK documentation for macOS.\n\nTo have GLFW include the Vulkan header, define GLFW_INCLUDE_VULKAN before including the GLFW header.\n\nIf you instead want to include the Vulkan header from a custom location or use your own custom Vulkan header then do this before the GLFW header.\n\nUnless a Vulkan header is included, either by the GLFW header or above it, the following GLFW functions will not be declared, as depend on Vulkan types.\n\nThe macros do not need to be defined for the Vulkan part of GLFW to work. Define them only if you are using these extensions directly.\n\nIf you are linking directly against the Vulkan loader then you can skip this section. The canonical desktop loader library exports all Vulkan core and Khronos extension functions, allowing them to be called directly.\n\nIf you are loading the Vulkan loader dynamically instead of linking directly against it, you can check for the availability of a loader and ICD with glfwVulkanSupported.\n\nThis function returns if the Vulkan loader and any minimally functional ICD was found.\n\nIf one or both were not found, calling any other Vulkan related GLFW function will generate a GLFW_API_UNAVAILABLE error.\n\nTo load any Vulkan core or extension function from the found loader, call glfwGetInstanceProcAddress. To load functions needed for instance creation, pass as the instance.\n\nOnce you have created an instance, you can load from it all other Vulkan core functions and functions from any instance extensions you enabled.\n\nThis function in turn calls . If that fails, the function falls back to a platform-specific query of the Vulkan loader (i.e. or ). If that also fails, the function returns . For more information about , see the Vulkan documentation.\n\nVulkan also provides for loading device-specific versions of Vulkan function. This function can be retrieved from an instance with glfwGetInstanceProcAddress.\n\nDevice-specific functions may execute a little faster, due to not having to dispatch internally based on the device passed to them. For more information about , see the Vulkan documentation.\n\nTo do anything useful with Vulkan you need to create an instance. If you want to use Vulkan to render to a window, you must enable the instance extensions GLFW requires to create Vulkan surfaces.\n\nThese extensions must all be enabled when creating instances that are going to be passed to glfwGetPhysicalDevicePresentationSupport and glfwCreateWindowSurface. The set of extensions will vary depending on platform and may also vary depending on graphics drivers and other factors.\n\nIf it fails it will return and GLFW will not be able to create Vulkan window surfaces. You can still use Vulkan for off-screen rendering and compute work.\n\nIf successful the returned array will always include , so if you don't require any additional extensions you can pass this list directly to the struct.\n\nAdditional extensions may be required by future versions of GLFW. You should check whether any extensions you wish to enable are already in the returned array, as it is an error to specify an extension more than once in the struct.\n\nmacOS: MoltenVK is (as of July 2022) not yet a fully conformant implementation of Vulkan. As of Vulkan SDK 1.3.216.0, this means you must also enable the instance extension and set the bit in the instance creation info flags for MoltenVK to show up in the list of physical devices. For more information, see the Vulkan and MoltenVK documentation.\n\nNot every queue family of every Vulkan device can present images to surfaces. To check whether a specific queue family of a physical device supports image presentation without first having to create a window and surface, call glfwGetPhysicalDevicePresentationSupport.\n\nThe extension additionally provides the function, which performs the same test on an existing Vulkan surface.\n\nUnless you will be using OpenGL or OpenGL ES with the same window as Vulkan, there is no need to create a context. You can disable context creation with the GLFW_CLIENT_API hint.\n\nSee Windows without contexts for more information.\n\nYou can create a Vulkan surface (as defined by the extension) for a GLFW window with glfwCreateWindowSurface.\n\nIf an OpenGL or OpenGL ES context was created on the window, the context has ownership of the presentation on the window and a Vulkan surface cannot be created.\n\nIt is your responsibility to destroy the surface. GLFW does not destroy it for you. Call function from the same extension to destroy it."
    },
    {
        "link": "https://glfw.org/docs/3.3/vulkan_guide.html",
        "document": "This guide is intended to fill the gaps between the official Vulkan resources and the rest of the GLFW documentation and is not a replacement for either. It assumes some familiarity with Vulkan concepts like loaders, devices, queues and surfaces and leaves it to the Vulkan documentation to explain the details of Vulkan functions.\n\nTo develop for Vulkan you should download the LunarG Vulkan SDK for your platform. Apart from headers and link libraries, they also provide the validation layers necessary for development.\n\nThe Vulkan Tutorial has more information on how to use GLFW and Vulkan. The Khronos Vulkan Samples also use GLFW, although with a small framework in between.\n\nFor details on a specific Vulkan support function, see the Vulkan support reference. There are also guides for the other areas of the GLFW API.\n\nBy default, GLFW will look for the Vulkan loader on demand at runtime via its standard name ( on Windows, on Linux and other Unix-like systems and on macOS). This means that GLFW does not need to be linked against the loader. However, it also means that if you are using the static library form of the Vulkan loader GLFW will either fail to find it or (worse) use the wrong one.\n\nThe GLFW_VULKAN_STATIC CMake option makes GLFW call the Vulkan loader directly instead of dynamically loading it at runtime. Not linking against the Vulkan loader will then be a compile-time error.\n\nmacOS: To make your application be redistributable you will need to set up the application bundle according to the LunarG SDK documentation. This is explained in more detail in the SDK documentation for macOS.\n\nTo include the Vulkan header, define GLFW_INCLUDE_VULKAN before including the GLFW header.\n\nIf you instead want to include the Vulkan header from a custom location or use your own custom Vulkan header then do this before the GLFW header.\n\nUnless a Vulkan header is included, either by the GLFW header or above it, any GLFW functions that take or return Vulkan types will not be declared.\n\nThe macros do not need to be defined for the Vulkan part of GLFW to work. Define them only if you are using these extensions directly.\n\nIf you are linking directly against the Vulkan loader then you can skip this section. The canonical desktop loader library exports all Vulkan core and Khronos extension functions, allowing them to be called directly.\n\nIf you are loading the Vulkan loader dynamically instead of linking directly against it, you can check for the availability of a loader and ICD with glfwVulkanSupported.\n\nThis function returns if the Vulkan loader and any minimally functional ICD was found.\n\nIf one or both were not found, calling any other Vulkan related GLFW function will generate a GLFW_API_UNAVAILABLE error.\n\nTo load any Vulkan core or extension function from the found loader, call glfwGetInstanceProcAddress. To load functions needed for instance creation, pass as the instance.\n\nOnce you have created an instance, you can load from it all other Vulkan core functions and functions from any instance extensions you enabled.\n\nThis function in turn calls . If that fails, the function falls back to a platform-specific query of the Vulkan loader (i.e. or ). If that also fails, the function returns . For more information about , see the Vulkan documentation.\n\nVulkan also provides for loading device-specific versions of Vulkan function. This function can be retrieved from an instance with glfwGetInstanceProcAddress.\n\nDevice-specific functions may execute a little faster, due to not having to dispatch internally based on the device passed to them. For more information about , see the Vulkan documentation.\n\nTo do anything useful with Vulkan you need to create an instance. If you want to use Vulkan to render to a window, you must enable the instance extensions GLFW requires to create Vulkan surfaces.\n\nThese extensions must all be enabled when creating instances that are going to be passed to glfwGetPhysicalDevicePresentationSupport and glfwCreateWindowSurface. The set of extensions will vary depending on platform and may also vary depending on graphics drivers and other factors.\n\nIf it fails it will return and GLFW will not be able to create Vulkan window surfaces. You can still use Vulkan for off-screen rendering and compute work.\n\nIf successful the returned array will always include , so if you don't require any additional extensions you can pass this list directly to the struct.\n\nAdditional extensions may be required by future versions of GLFW. You should check whether any extensions you wish to enable are already in the returned array, as it is an error to specify an extension more than once in the struct.\n\nmacOS: MoltenVK is (as of July 2022) not yet a fully conformant implementation of Vulkan. As of Vulkan SDK 1.3.216.0, this means you must also enable the instance extension and set the bit in the instance creation info flags for MoltenVK to show up in the list of physical devices. For more information, see the Vulkan and MoltenVK documentation.\n\nNot every queue family of every Vulkan device can present images to surfaces. To check whether a specific queue family of a physical device supports image presentation without first having to create a window and surface, call glfwGetPhysicalDevicePresentationSupport.\n\nThe extension additionally provides the function, which performs the same test on an existing Vulkan surface.\n\nUnless you will be using OpenGL or OpenGL ES with the same window as Vulkan, there is no need to create a context. You can disable context creation with the GLFW_CLIENT_API hint.\n\nSee Windows without contexts for more information.\n\nYou can create a Vulkan surface (as defined by the extension) for a GLFW window with glfwCreateWindowSurface.\n\nIf an OpenGL or OpenGL ES context was created on the window, the context has ownership of the presentation on the window and a Vulkan surface cannot be created.\n\nIt is your responsibility to destroy the surface. GLFW does not destroy it for you. Call function from the same extension to destroy it."
    },
    {
        "link": "https://glfw.org/docs/3.3/intro_guide.html",
        "document": "This guide introduces the basic concepts of GLFW and describes initialization, error handling and API guarantees and limitations. For a broad but shallow tutorial, see Getting started instead. For details on a specific function in this category, see the Initialization, version and error reference.\n\nThere are also guides for the other areas of GLFW.\n\nBefore most GLFW functions may be called, the library must be initialized. This initialization checks what features are available on the machine, enumerates monitors and joysticks, initializes the timer and performs any required platform-specific initialization.\n\nOnly the following functions may be called before the library has been successfully initialized, and only from the main thread.\n\nCalling any other function before successful initialization will cause a GLFW_NOT_INITIALIZED error.\n\nThe library is initialized with glfwInit, which returns if an error occurred.\n\nIf any part of initialization fails, any parts that succeeded are terminated as if glfwTerminate had been called. The library only needs to be initialized once and additional calls to an already initialized library will return immediately.\n\nOnce the library has been successfully initialized, it should be terminated before the application exits. Modern systems are very good at freeing resources allocated by programs that exit, but GLFW sometimes has to change global system settings and these might not be restored without termination.\n\nInitialization hints are set before glfwInit and affect how the library behaves until termination. Hints are set with glfwInitHint.\n\nThe values you set hints to are never reset by GLFW, but they only take effect during initialization. Once GLFW has been initialized, any values you set will be ignored until the library is terminated and initialized again.\n\nSome hints are platform specific. These may be set on any platform but they will only affect their specific platform. Other platforms will ignore them. Setting these hints requires no platform specific headers or functions.\n\nGLFW_JOYSTICK_HAT_BUTTONS specifies whether to also expose joystick hats as buttons, for compatibility with earlier versions of GLFW that did not have glfwGetJoystickHats. Possible values are and .\n\nGLFW_COCOA_CHDIR_RESOURCES specifies whether to set the current directory to the application to the subdirectory of the application's bundle, if present. Set this with glfwInitHint.\n\nGLFW_COCOA_MENUBAR specifies whether to create a basic menu bar, either from a nib or manually, when the first window is created, which is when AppKit is initialized. Set this with glfwInitHint.\n\nGLFW_WAYLAND_LIBDECOR specifies whether to use libdecor for window decorations where available. Possible values are and . This is ignored on other platforms.\n\nBefore your application exits, you should terminate the GLFW library if it has been initialized. This is done with glfwTerminate.\n\nThis will destroy any remaining window, monitor and cursor objects, restore any modified gamma ramps, re-enable the screensaver if it had been disabled and free any other resources allocated by GLFW.\n\nOnce the library is terminated, it is as if it had never been initialized, therefore you will need to initialize it again before being able to use GLFW. If the library was not initialized or had already been terminated, it returns immediately.\n\nSome GLFW functions have return values that indicate an error, but this is often not very helpful when trying to figure out what happened or why it occurred. Other functions have no return value reserved for errors, so error notification needs a separate channel. Finally, far from all GLFW functions have return values.\n\nThe last error code for the calling thread can be queried at any time with glfwGetError.\n\nIf no error has occurred since the last call, GLFW_NO_ERROR (zero) is returned. The error is cleared before the function returns.\n\nThe error code indicates the general category of the error. Some error codes, such as GLFW_NOT_INITIALIZED has only a single meaning, whereas others like GLFW_PLATFORM_ERROR are used for many different errors.\n\nGLFW often has more information about an error than its general category. You can retrieve a UTF-8 encoded human-readable description along with the error code. If no error has occurred since the last call, the description is set to .\n\nThe retrieved description string is only valid until the next error occurs. This means you must make a copy of it if you want to keep it.\n\nYou can also set an error callback, which will be called each time an error occurs. It is set with glfwSetErrorCallback.\n\nThe error callback receives the same error code and human-readable description returned by glfwGetError.\n\nThe error callback is called after the error is stored, so calling glfwGetError from within the error callback returns the same values as the callback argument.\n\nThe description string passed to the callback is only valid until the error callback returns. This means you must make a copy of it if you want to keep it.\n\nReported errors are never fatal. As long as GLFW was successfully initialized, it will remain initialized and in a safe state until terminated regardless of how many errors occur. If an error occurs during initialization that causes glfwInit to fail, any part of the library that was initialized will be safely terminated.\n\nDo not rely on a currently invalid call to generate a specific error, as in the future that same call may generate a different error or become valid.\n\nGLFW has two primary coordinate systems: the virtual screen and the window content area or content area. Both use the same unit: virtual screen coordinates, or just screen coordinates, which don't necessarily correspond to pixels.\n\nBoth the virtual screen and the content area coordinate systems have the X-axis pointing to the right and the Y-axis pointing down.\n\nWindow and monitor positions are specified as the position of the upper-left corners of their content areas relative to the virtual screen, while cursor positions are specified relative to a window's content area.\n\nBecause the origin of the window's content area coordinate system is also the point from which the window position is specified, you can translate content area coordinates to the virtual screen by adding the window position. The window frame, when present, extends out from the content area but does not affect the window position.\n\nAlmost all positions and sizes in GLFW are measured in screen coordinates relative to one of the two origins above. This includes cursor positions, window positions and sizes, window frame sizes, monitor positions and video mode resolutions.\n\nTwo exceptions are the monitor physical size, which is measured in millimetres, and framebuffer size, which is measured in pixels.\n\nPixels and screen coordinates may map 1:1 on your machine, but they won't on every other machine, for example on a Mac with a Retina display. The ratio between screen coordinates and pixels may also change at run-time depending on which monitor the window is currently considered to be on.\n\nThis section describes the conditions under which GLFW can be expected to function, barring bugs in the operating system or drivers. Use of GLFW outside these limits may work on some platforms, or on some machines, or some of the time, or on some versions of GLFW, but it may break at any time and this will not be considered a bug.\n\nGLFW will never free any pointer you provide to it, and you must never free any pointer it provides to you.\n\nMany GLFW functions return pointers to dynamically allocated structures, strings or arrays, and some callbacks are provided with strings or arrays. These are always managed by GLFW and should never be freed by the application. The lifetime of these pointers is documented for each GLFW function and callback. If you need to keep this data, you must copy it before its lifetime expires.\n\nMany GLFW functions accept pointers to structures or strings allocated by the application. These are never freed by GLFW and are always the responsibility of the application. If GLFW needs to keep the data in these structures or strings, it is copied before the function returns.\n\nPointer lifetimes are guaranteed not to be shortened in future minor or patch releases.\n\nGLFW event processing and object destruction are not reentrant. This means that the following functions must not be called from any callback function:\n\nThese functions may be made reentrant in future minor or patch releases, but functions not on this list will not be made non-reentrant.\n\nMost GLFW functions must only be called from the main thread (the thread that calls main), but some may be called from any thread once the library has been initialized. Before initialization the whole library is thread-unsafe.\n\nThe reference documentation for every GLFW function states whether it is limited to the main thread.\n\nInitialization, termination, event processing and the creation and destruction of windows, cursors and OpenGL and OpenGL ES contexts are all restricted to the main thread due to limitations of one or several platforms.\n\nBecause event processing must be performed on the main thread, all callbacks except for the error callback will only be called on that thread. The error callback may be called on any thread, as any GLFW function may generate errors.\n\nThe error code and description may be queried from any thread.\n\nEmpty events may be posted from any thread.\n\nThe window user pointer and close flag may be read and written from any thread, but this is not synchronized by GLFW.\n\nThese functions for working with OpenGL and OpenGL ES contexts may be called from any thread, but the window object is not synchronized by GLFW.\n\nThe raw timer functions may be called from any thread.\n\nThe regular timer may be used from any thread, but reading and writing the timer offset is not synchronized by GLFW.\n\nLibrary version information may be queried from any thread.\n\nAll Vulkan related functions may be called from any thread.\n\nGLFW uses synchronization objects internally only to manage the per-thread context and error states. Additional synchronization is left to the application.\n\nFunctions that may currently be called from any thread will always remain so, but functions that are currently limited to the main thread may be updated to allow calls from any thread in future releases.\n\nGLFW uses Semantic Versioning. This guarantees source and binary backward compatibility with earlier minor versions of the API. This means that you can drop in a newer version of the library and existing programs will continue to compile and existing binaries will continue to run.\n\nOnce a function or constant has been added, the signature of that function or value of that constant will remain unchanged until the next major version of GLFW. No compatibility of any kind is guaranteed between major versions.\n\nUndocumented behavior, i.e. behavior that is not described in the documentation, may change at any time until it is documented.\n\nIf the reference documentation and the implementation differ, the reference documentation will almost always take precedence and the implementation will be fixed in the next release. The reference documentation will also take precedence over anything stated in a guide.\n\nThe order of arrival of related events is not guaranteed to be consistent across platforms. The exception is synthetic key and mouse button release events, which are always delivered after the window defocus event.\n\nGLFW provides mechanisms for identifying what version of GLFW your application was compiled against as well as what version it is currently running against. If you are loading GLFW dynamically (not just linking dynamically), you can use this to verify that the library binary is compatible with your application.\n\nThe compile-time version of GLFW is provided by the GLFW header with the , and macros.\n\nThe run-time version can be retrieved with glfwGetVersion, a function that may be called regardless of whether GLFW is initialized.\n\nGLFW 3 also provides a compile-time generated version string that describes the version, platform, compiler and any platform-specific compile-time options. This is primarily intended for submitting bug reports, to allow developers to see which code paths are enabled in a binary.\n\nThe version string is returned by glfwGetVersionString, a function that may be called regardless of whether GLFW is initialized.\n\nDo not use the version string to parse the GLFW library version. The glfwGetVersion function already provides the version of the running library binary.\n\nThe format of the string is as follows:\n• The name of the window system API\n• The name of the context creation API\n\nFor example, when compiling GLFW 3.3.9 with MinGW for Windows, may result in a version string like this:"
    },
    {
        "link": "https://gist.github.com/MaverickTse/c8061794d8f1dbfe08099b9329cb6605",
        "document": "You signed in with another tab or window. Reload to refresh your session.\n\nYou signed out in another tab or window. Reload to refresh your session.\n\nYou switched accounts on another tab or window. Reload to refresh your session."
    },
    {
        "link": "https://vulkan-tutorial.com/Drawing_a_triangle/Setup/Instance",
        "document": "The very first thing you need to do is initialize the Vulkan library by creating an instance. The instance is the connection between your application and the Vulkan library and creating it involves specifying some details about your application to the driver.\n\nStart by adding a function and invoking it in the function.\n\nAdditionally add a data member to hold the handle to the instance:\n\nNow, to create an instance we'll first have to fill in a struct with some information about our application. This data is technically optional, but it may provide some useful information to the driver in order to optimize our specific application (e.g. because it uses a well-known graphics engine with certain special behavior). This struct is called :\n\nAs mentioned before, many structs in Vulkan require you to explicitly specify the type in the member. This is also one of the many structs with a member that can point to extension information in the future. We're using value initialization here to leave it as .\n\nA lot of information in Vulkan is passed through structs instead of function parameters and we'll have to fill in one more struct to provide sufficient information for creating an instance. This next struct is not optional and tells the Vulkan driver which global extensions and validation layers we want to use. Global here means that they apply to the entire program and not a specific device, which will become clear in the next few chapters.\n\nThe first two parameters are straightforward. The next two layers specify the desired global extensions. As mentioned in the overview chapter, Vulkan is a platform agnostic API, which means that you need an extension to interface with the window system. GLFW has a handy built-in function that returns the extension(s) it needs to do that which we can pass to the struct:\n\nThe last two members of the struct determine the global validation layers to enable. We'll talk about these more in-depth in the next chapter, so just leave these empty for now.\n\nWe've now specified everything Vulkan needs to create an instance and we can finally issue the call:\n\nAs you'll see, the general pattern that object creation function parameters in Vulkan follow is:\n• Pointer to custom allocator callbacks, always in this tutorial\n• Pointer to the variable that stores the handle to the new object\n\nIf everything went well then the handle to the instance was stored in the class member. Nearly all Vulkan functions return a value of type that is either or an error code. To check if the instance was created successfully, we don't need to store the result and can just use a check for the success value instead:\n\nNow run the program to make sure that the instance is created successfully.\n\nIf using MacOS with the latest MoltenVK sdk, you may get returned from . According to the Getting Start Notes. Beginning with the 1.3.216 Vulkan SDK, the extension is mandatory.\n\nTo get over this error, first add the bit to struct's flags, then add to instance enabled extension list.\n\nTypically the code could be like this:\n\nIf you look at the documentation then you'll see that one of the possible error codes is . We could simply specify the extensions we require and terminate if that error code comes back. That makes sense for essential extensions like the window system interface, but what if we want to check for optional functionality?\n\nTo retrieve a list of supported extensions before creating an instance, there's the function. It takes a pointer to a variable that stores the number of extensions and an array of to store details of the extensions. It also takes an optional first parameter that allows us to filter extensions by a specific validation layer, which we'll ignore for now.\n\nTo allocate an array to hold the extension details we first need to know how many there are. You can request just the number of extensions by leaving the latter parameter empty:\n\nNow allocate an array to hold the extension details ( ):\n\nFinally we can query the extension details:\n\nEach struct contains the name and version of an extension. We can list them with a simple for loop ( is a tab for indentation):\n\nYou can add this code to the function if you'd like to provide some details about the Vulkan support. As a challenge, try to create a function that checks if all of the extensions returned by are included in the supported extensions list.\n\nThe should be only destroyed right before the program exits. It can be destroyed in with the function:\n\nThe parameters for the function are straightforward. As mentioned in the previous chapter, the allocation and deallocation functions in Vulkan have an optional allocator callback that we'll ignore by passing to it. All of the other Vulkan resources that we'll create in the following chapters should be cleaned up before the instance is destroyed.\n\nBefore continuing with the more complex steps after instance creation, it's time to evaluate our debugging options by checking out validation layers."
    },
    {
        "link": "https://github.com/g-truc/glm",
        "document": "OpenGL Mathematics (GLM) is a header only C++ mathematics library for graphics software based on the OpenGL Shading Language (GLSL) specifications.\n\nGLM provides classes and functions designed and implemented with the same naming conventions and functionality than GLSL so that anyone who knows GLSL, can use GLM as well in C++.\n\nThis project isn't limited to GLSL features. An extension system, based on the GLSL extension conventions, provides extended capabilities: matrix transformations, quaternions, data packing, random numbers, noise, etc...\n\nThis library works perfectly with OpenGL but it also ensures interoperability with other third party libraries and SDK. It is a good candidate for software rendering (raytracing / rasterisation), image processing, physics simulations and any development context that requires a simple and convenient mathematics library.\n\nGLM is written in C++98 but can take advantage of C++11 when supported by the compiler. It is a platform independent library with no dependence and it officially supports the following compilers:\n\nFor more information about GLM, please have a look at the manual and the API reference documentation. The source code and the documentation are licensed under either the Happy Bunny License (Modified MIT) or the MIT License.\n\nThanks for contributing to the project by submitting pull requests.\n\nAnd then in your :\n\nIf your prefer to use header-only version of GLM\n\nYou can add glm to your CMake project to be built together.\n• Unit tests are not build by default, set to required.\n• Enables only warnings as errors while building unit tests\n• Added and to GLM_EXT_scalar_common and GLM_EXT_vector_common\n• Added GLM_FORCE_UNRESTRICTED_FLOAT to prevent static asserts when using other scalar types with function expecting floats.\n• Fixed discards the sign of result for angles in range (2pi-1, 2pi) #1038\n• Removed ban on using with CUDA host code #1041\n• Added , , and function to and extensions with tests\n• Added to store quat data as w,x,y,z instead of x,y,z,w #983\n• Added GLM_EXT_scalar_integer extension with power of two and multiple scalar functions\n• Added GLM_EXT_vector_integer extension with power of two and multiple vector functions\n• Fixed for g++6 where -std=c++1z sets __cplusplus to 201500 instead of 201402 #921\n• Added GLM_FORCE_INTRINSICS to enable SIMD instruction code path. By default, it's disabled allowing constexpr support by default. #865\n• Fixed being defined as unsigned char with some compiler #839\n• Added and overload with max ULPs parameters for scalar numbers #121\n• Added to silent GLM warnings when using language extensions but using W4 or Wpedantic warnings #814 #775\n• Added to enable aligned types and SIMD instruction are not enabled. This disable #816\n• Fixed default initialization with vector and quaternion types using #812\n• Added missing and with epsilon for quaternion types to GLM_GTC_quaternion\n• Added GLM_EXT_matrix_relational: and with epsilon for matrix types\n• Added a section to the manual for contributing to GLM\n• Redesigned constexpr support which excludes both SIMD and #783\n• Clarified refract valid range of the indices of refraction, between -1 and 1 inclusively #806\n• Fixed invalid conversion from int scalar with vec4 constructor when using SSE instruction\n• Fixed infinite loop in random functions when using negative radius values using an assert #739\n• Added GLM_GTX_matrix_factorisation to factor matrices in various forms #654\n• Added GLM_EXT_vector_relational: extend and to take an epsilon argument\n• Added separate functions to use both negative one and zero near clip plans #680\n• Added to use GLM on platforms that don't support double #627\n• No more default initialization of vector, matrix and quaternion types\n• Added error for including of different versions of GLM #619\n• Added GLM_FORCE_IGNORE_VERSION to ignore error caused by including different version of GLM #619\n• Reduced warnings when using very strict compilation flags #646\n• Removed doxygen references to GLM_GTC_half_float which was removed in 0.9.4\n• Fixed references to which was removed #642\n• Fixed when OpenMP is not enabled\n• Fixed Visual C++ internal error when declaring a global vec type with siwzzle expression enabled #594\n• Fixed with Clang and libstlc++ which wasn't using C++11 STL features. #604\n• Added warning messages when using but the compiler is known to not fully support the requested C++ version #555\n• Added right and left handed projection and clip control support #447 #415 #119\n• Added and to GLM_GTC_packing for RGB9E5 #416\n• Added and to GLM_GTC_integer, fast round on positive values\n• Improved SIMD and swizzle operators interactions with GCC and Clang #474\n• Use Cuda built-in function for abs function implementation with Cuda compiler\n• No more warnings for use of long long\n• Fixed to not do any unintentional backface culling\n• Fixed long long warnings when using C++98 on GCC and Clang #482\n• Fixed long long warnings when using C++98 on GCC and Clang #482\n• Fixed to_string when used with GLM_FORCE_INLINE #506\n• Fixed intersectRayTriangle to not do any unintentional backface culling\n• Fixed outerProduct definitions and operator signatures for mat2x4 and vec4 #475\n• Fixed various 'X is not defined' warnings #468\n• Added to_string for quat and dual_quat in GTX_string_cast #375\n• Fixed builtin bitscan never being used #392\n• Added static components and precision members to all vector and quat types #350\n• Added support of defaulted functions to GLM types, to use them in unions #366\n• Don't show status message in 'FindGLM' if 'QUIET' option is set. #317\n• Fixed use of libstdc++ with Clang #351\n• Added display of GLM version with other GLM_MESSAGES\n• Clean up GLM_MESSAGES compilation log to report only detected capabilities\n• Fixed missing explicit conversion when using integer log2 with *vec1 types\n• Fixed Android build issue, STL C++11 is not supported by the NDK #284\n• Added GTX_scalar_multiplication for C++ 11 compiler only #242\n• Added GTX_range for C++ 11 compiler only #240\n• Added support of precision and integers to linearRand #230\n• Rely on C++11 to implement isinf and isnan\n• Undetected C++ compiler automatically compile with GLM_FORCE_CXX98 and GLM_FORCE_PURE\n• Added not function (from GLSL specification) on VC12\n• Used std features within GLM without redeclaring\n• Added explicit cast from quat to mat3 and mat4 #275\n• Fixed std::nextafter not supported with C++11 on Android #217\n• Fixed implicit conversion from another tvec2 type to another tvec2 #241\n• Fixed lack of consistency of quat and dualquat constructors\n• Fixed glm::isinf and glm::isnan for with Android NDK 9d #191\n• Fixed lerp when cosTheta is close to 1 in quaternion slerp #210\n• Fixed std::nextafter not supported with C++11 on Android #213\n• Fixed corner cases in exp and log functions for quaternions #199\n• Added instruction set auto detection with Visual C++ using _M_IX86_FP - /arch compiler argument\n• Added support for all extensions but GTX_string_cast to CUDA\n• Fixed non power of two matrix products\n• Fixed angle and orientedAngle that sometimes return NaN values (#145)\n• Fixed error 'inverse' is not a member of 'glm' from glm::unProject (#146)\n• Fixed mismatch between some declarations and definitions\n• Replaced C cast by C++ casts\n• Fixed .length() that should return a int and not a size_t\n• Removed the normalization of the up argument of lookAt function (#114)\n• Replaced GLM traits by STL traits when possible\n• Added creating of a quaternion from two vectors\n• Fixed detection to select the last known compiler if newer version #106\n• Fixed is_int and is_uint code duplication with GCC and C++11 #107\n• Fixed test suite build while using Clang in C++11 mode\n• Removed ms extension mode to CMake when no using Visual C++\n• Added pedantic mode to CMake test suite for Clang and GCC\n• Added use of GCC frontend on Unix for ICC and Visual C++ fronted on Windows for ICC\n• Fixed language detection on GCC when the C++0x mode isn't enabled #95\n• Fixed slerp when costheta is close to 1 #65\n• Added assert in inversesqrt to detect division by zero #61\n• Fixed glm::perspective when zNear is zero #71\n• Fixed C++11 mode for GCC, couldn't be enabled without MS extensions\n• Clarify the license applying on the manual\n• Fixed isnan and isinf on Android with Clang\n• Autodetected C++ version using __cplusplus value\n• Fixed mix for bool and bvec* third parameter\n• Fixed 0x2013 dash character in comments that cause issue in Windows Japanese mode\n• Fixed quat slerp using mix function when cosTheta close to 1\n• Added GLM_FORCE_RADIANS so that all functions takes radians for arguments\n• Fixed detection of Clang and LLVM GCC on MacOS X\n• Removed VIRTREV_xstream and the incompatibility generated with GCC\n• Fixed many warnings across platforms and compilers\n• Fixed errors and warnings in VC with C++ extensions disabled\n• Clarify that GLM is a header only library.\n• Added == and != operators for every types.\n• New method to use extension."
    },
    {
        "link": "https://eecs.oregonstate.edu/~mjb/cs491/Handouts/GLM.1pp.pdf",
        "document": ""
    },
    {
        "link": "http://glm.g-truc.net/glm.pdf",
        "document": ""
    },
    {
        "link": "https://stackoverflow.com/questions/7574125/multiplying-a-matrix-and-a-vector-in-glm-opengl",
        "document": "I have a transformation matrix, , and a vector, . I want to do a linear transformation on the vector using the matrix. I'd expect that I would be able to do something like this:\n\nThis doesn't seem to work, though. What is the correct way to do this kind of operation in GLM?\n\nJust a note to anyone who runs into a similar problem. GLM requires all operands to use the same type. Don't try multiplying a with a and expect it to work, you need a ."
    },
    {
        "link": "https://glm.g-truc.net/0.9.4/glm-0.9.4.pdf",
        "document": ""
    }
]