[
    {
        "link": "https://gradio.app",
        "document": "Gradio can be installed with pip. Creating a Gradio interface only requires adding a couple lines of code to your project. Seamlessly use any python library on your computer. If you can write a python function, gradio can run it. Gradio can be embedded in Python notebooks or presented as a webpage. A Gradio interface can automatically generate a public link you can share with colleagues that lets them interact with the model on your computer remotely from their own devices. Once you've created an interface, you can permanently host it on Hugging Face. Hugging Face Spaces will host the interface on its servers and provide you with a link you can share."
    },
    {
        "link": "https://gradio.app/docs",
        "document": "Introducing FastRTC, a new way to build real-time AI apps"
    },
    {
        "link": "https://github.com/gradio-app/gradio",
        "document": "Gradio is an open-source Python package that allows you to quickly build a demo or web application for your machine learning model, API, or any arbitrary Python function. You can then share a link to your demo or web application in just a few seconds using Gradio's built-in sharing features. No JavaScript, CSS, or web hosting experience needed!\n\nIt just takes a few lines of Python to create your own demo, so let's get started üí´\n\nWe recommend installing Gradio using , which is included by default in Python. Run this in your terminal or command prompt:\n\nYou can run Gradio in your favorite code editor, Jupyter notebook, Google Colab, or anywhere else you write Python. Let's write your first Gradio app:\n\nNow, run your code. If you've written the Python code in a file named , then you would run from the terminal.\n\nThe demo below will open in a browser on http://localhost:7860 if running from a file. If you are running within a notebook, the demo will appear embedded within the notebook.\n\nType your name in the textbox on the left, drag the slider, and then press the Submit button. You should see a friendly greeting on the right.\n\nYou'll notice that in order to make your first demo, you created an instance of the class. The class is designed to create demos for machine learning models which accept one or more inputs, and return one or more outputs.\n\nThe class has three core arguments:\n‚Ä¢ : the function to wrap a user interface (UI) around\n‚Ä¢ : the Gradio component(s) to use for the input. The number of components should match the number of arguments in your function.\n‚Ä¢ : the Gradio component(s) to use for the output. The number of components should match the number of return values from your function.\n\nThe argument is very flexible -- you can pass any Python function that you want to wrap with a UI. In the example above, we saw a relatively simple function, but the function could be anything from a music generator to a tax calculator to the prediction function of a pretrained machine learning model.\n\nThe and arguments take one or more Gradio components. As we'll see, Gradio includes more than 30 built-in components (such as the , , and components) that are designed for machine learning applications.\n\nIf your function accepts more than one argument, as is the case above, pass a list of input components to , with each input component corresponding to one of the arguments of the function, in order. The same holds true if your function returns more than one value: simply pass in a list of components to . This flexibility makes the class a very powerful way to create demos.\n\nWe'll dive deeper into the on our series on building Interfaces.\n\nWhat good is a beautiful demo if you can't share it? Gradio lets you easily share a machine learning demo without having to worry about the hassle of hosting on a web server. Simply set in , and a publicly accessible URL will be created for your demo. Let's revisit our example demo, but change the last line as follows:\n\nWhen you run this code, a public URL will be generated for your demo in a matter of seconds, something like:\n\nNow, anyone around the world can try your Gradio demo from their browser, while the machine learning model and all computation continues to run locally on your computer.\n\nTo learn more about sharing your demo, read our dedicated guide on sharing your Gradio application.\n\nSo far, we've been discussing the class, which is a high-level class that lets to build demos quickly with Gradio. But what else does Gradio include?\n\nGradio offers a low-level approach for designing web apps with more customizable layouts and data flows with the class. Blocks supports things like controlling where components appear on the page, handling multiple data flows and more complex interactions (e.g. outputs can serve as inputs to other functions), and updating properties/visibility of components based on user interaction ‚Äî still all in Python.\n\nYou can build very custom and complex applications using . For example, the popular image generation Automatic1111 Web UI is built using Gradio Blocks. We dive deeper into the on our series on building with Blocks.\n\nGradio includes another high-level class, , which is specifically designed to create Chatbot UIs. Similar to , you supply a function and Gradio creates a fully working Chatbot UI. If you're interested in creating a chatbot, you can jump straight to our dedicated guide on .\n\nThat's the gist of the core Python library, but Gradio is actually so much more! It's an entire ecosystem of Python and JavaScript libraries that let you build machine learning applications, or query them programmatically, in Python or JavaScript. Here are other related parts of the Gradio ecosystem:\n‚Ä¢ Gradio-Lite ( ): write Gradio apps in Python that run entirely in the browser (no server needed!), thanks to Pyodide.\n‚Ä¢ Hugging Face Spaces: the most popular place to host Gradio applications ‚Äî for free!\n\nKeep learning about Gradio sequentially using the Gradio Guides, which include explanations as well as example code and embedded interactive demos. Next up: let's dive deeper into the Interface class.\n\nOr, if you already know the basics and are looking for something specific, you can search the more technical API documentation.\n\nYou can also build Gradio applications without writing any code. Simply type into your terminal to open up an editor that lets you define and modify Gradio components, adjust their layouts, add events, all through a web editor. Or use this hosted version of Gradio Sketch, running on Hugging Face Spaces.\n\nIf you'd like to report a bug or have a feature request, please create an issue on GitHub. For general questions about usage, we are available on our Discord server and happy to help.\n\nIf you like Gradio, please leave us a ‚≠ê on GitHub!\n\nGradio is built on top of many wonderful open-source libraries!\n\nGradio is licensed under the Apache License 2.0 found in the LICENSE file in the root directory of this repository.\n\nAlso check out the paper Gradio: Hassle-Free Sharing and Testing of ML Models in the Wild, ICML HILL 2019, and please cite it if you use Gradio in your work."
    },
    {
        "link": "https://pyimagesearch.com/2025/02/03/introduction-to-gradio-for-building-interactive-applications",
        "document": "In this tutorial, you‚Äôll dive into Gradio and learn how it empowers Python developers to create interactive applications ideal for showcasing machine learning (ML) models. We‚Äôll cover what makes Gradio popular, explore high-impact projects built with it, and review the latest enhancements in Gradio 5. You‚Äôll also get hands-on with Gradio‚Äôs core classes, essential components like TextBox, Buttons, and Sliders, and learn how to handle common errors like the ‚ÄúAttributeError: module ‚Äògradio‚Äô has no attribute ‚Äòinputs‚Äô.‚Äù Finally, we‚Äôll show you how to connect with external models using the Gradio API, unlocking dynamic data interactions for your applications.\n\nThis lesson is the 1st of a 2-part series on Gradio for building interactive applications:\n‚Ä¢ Introduction to Gradio for Building Interactive Applications (this tutorial)\n\nTo learn how to get started with Gradio, explore its latest features, and work with its core components and API, just keep reading.\n\nIn the world of machine learning and AI (artificial intelligence), building a powerful model is only half the battle; the other half lies in demonstrating its impact. For machine learning engineers and data scientists, creating intuitive user interfaces (UIs) to showcase their models can be a game-changer. A well-designed interface allows end-users ‚Äî who might not be technically inclined ‚Äî to interact with models, provide input, and observe results in real-time. This not only enhances the model‚Äôs accessibility but also enables feedback collection, collaboration, and practical application in real-world scenarios.\n\nThis is where Gradio comes into play. Gradio is an open-source Python library that empowers developers to build interactive web interfaces for their machine learning models, APIs, or any Python functions with ease. With Gradio, engineers can go beyond code and present their work engagingly and tangibly, allowing users to test, validate, and gain insights from models firsthand. In essence, Gradio serves as a bridge between complex machine learning models and the non-technical users who can benefit from them.\n\nGradio is an open-source Python library that simplifies the creation of user-friendly web interfaces for machine learning models, APIs, or any Python function. Initially developed as a way to help machine learning practitioners showcase their models, Gradio has evolved into a powerful tool for creating interactive applications across various domains. It‚Äôs especially popular among developers, educators, and data scientists who need to demonstrate complex models to a non-technical audience.\n\nGradio was founded by Abid et al. (2019) with the goal of making machine learning models accessible to everyone. The tool quickly gained popularity due to its simplicity and the ability to create fully functional web interfaces with minimal code. In 2021, Gradio was acquired by Hugging Face, a leader in the machine learning space known for its extensive Transformers library and model hub. This acquisition further boosted Gradio‚Äôs development, adding more resources, community support, and deep integrations with Hugging Face‚Äôs powerful model ecosystem.\n\nToday, Gradio is a favorite among Python developers and machine learning practitioners. It was even the #1 trending GitHub repository at the time of writing, reflecting its strong adoption and the enthusiasm within the developer community. It has become a staple tool in machine learning, with over 6.7 million downloads per month, making it one of the most widely used libraries for building ML interfaces. Gradio‚Äôs easy setup, component versatility, and rich integration with other Python tools and frameworks have made it a top choice for prototyping, deploying, and sharing machine learning applications quickly.\n\nAUTOMATIC1111 is a widely used web interface for Stable Diffusion, built entirely with Gradio. This tool allows users to generate images from text prompts and make adjustments in real-time, highlighting Gradio‚Äôs ability to handle advanced image generation workflows in an accessible format, bypassing the need for extensive programming knowledge or hardware setup.\n\nYou can learn more about it here.\n\nThe Text Generation Web UI by oobabooga leverages Gradio to create a powerful interactive interface for large language models (LLMs). This project allows users to load pre-trained models across various formats and frameworks, including Transformers, Llama.cpp, AutoGPTQ, and more. The flexibility of model loading means users can experiment with a wide range of LLMs, making it ideal for those interested in text generation, creative writing, chatbots, and conversational AI.\n\nOne of the standout features of this Gradio-powered UI is the Training Tab, which enables users to fine-tune models directly within the interface. Techniques like Low-Rank Adaptation (LoRA) make it possible to customize models (e.g., fine-tuning a Llama model for specific tasks) without needing extensive computational resources.\n\nFor a deeper dive into its features and a step-by-step guide to training LLMs like Llama with LoRA, you can refer to our blog post, Exploring Oobabooga Text Generation Web UI.\n\nThe Next Generation of Gradio: What‚Äôs New in Version 5\n\nGradio 5 introduces several enhancements aimed at improving performance, security, and user experience for developers building machine learning applications. Key updates include the following.\n\nGradio 5 incorporates server-side rendering (SSR), enabling applications to load almost instantaneously in the browser, eliminating previous loading delays.\n\nA comprehensive security audit was conducted by Trail of Bits, leading to the identification and resolution of potential vulnerabilities. These fixes have been validated and integrated into Gradio 5, ensuring safer deployment of applications.\n\nThe new AI Playground allows developers to generate or modify Gradio applications using natural language prompts, facilitating rapid prototyping and experimentation.\n\nYou can preview the app right in your browser immediately: https://www.gradio.app/playground\n\nCore components (e.g., Buttons, Tabs, and Sliders) have been refreshed with a modern design, enhancing the visual appeal and usability of applications.\n\nGradio 5 introduces a set of built-in themes, enabling developers to create fresh-looking applications without extensive customization easily (Hugging Face).\n\nSupport for low-latency streaming has been added, allowing for real-time applications (e.g., webcam-based object detection, video streaming, and conversational chatbots).\n\nTo follow this guide, you‚Äôll need to install the library. For the latest version (Gradio 5), ensure your Python version is 3.10 or higher.\n\nOptional Installations: If you plan to use the Gradio Client for remote API calls or experiment with text generation models, you may also want to install the following libraries:\n\nNote: These optional libraries are primarily needed for the Gradio API section. If you only need the Gradio interface, installing gradio alone will suffice.\n\nNeed Help Configuring Your Development Environment?\n\nAll that said, are you:\n‚Ä¢ Wanting to skip the hassle of fighting with the command line, package managers, and virtual environments?\n‚Ä¢ Ready to run the code immediately on your Windows, macOS, or Linux system?\n\nGain access to Jupyter Notebooks for this tutorial and other PyImageSearch guides pre-configured to run on Google Colab‚Äôs ecosystem right in your web browser! No installation required.\n\nAnd best of all, these Jupyter Notebooks will run on Windows, macOS, and Linux!\n\nGradio offers several foundational classes for building interfaces, each suited to different levels of complexity. The primary classes are Interface and Blocks, which allow developers to tailor Gradio to their needs, from simple demos to highly customizable applications.\n\nThe Interface class is ideal for quick, high-level demos where you want to connect a function to input and output components with minimal setup. It‚Äôs designed for simplicity, making it perfect for single-function applications.\n\nLet‚Äôs build a basic greeting app that simply takes a user‚Äôs name and returns a greeting.\n\nWith Interface, you specify the input and output types directly. The layout is handled automatically, so there‚Äôs minimal setup, but also limited control over customization.\n\nThe Blocks class, on the other hand, provides a lower-level API for greater flexibility and control. With Blocks, you can arrange multiple components, group them in custom layouts, and define interactions between them, making it the go-to choice for more complex applications.\n\nLet‚Äôs revisit the greeting app but add a button that only triggers the greeting when clicked, demonstrating how Blocks allows for customized layouts and functionality.\n‚Ä¢ You have full control over the layout, positioning the , , and elements as desired.\n‚Ä¢ The triggers the greeting function only when clicked, offering an interactive flow.\n‚Ä¢ Blocks enable flexibility in designing complex workflows, which is not achievable with Interface alone.\n\nWhen to Use Each\n‚Ä¢ Use Interface: For quick, straightforward demos without the need for custom layouts.\n‚Ä¢ Use Blocks: When building multi-component or more interactive applications where layout customization and component control are needed.\n\nGradio also offers ChatInterface, a specialized class tailored for conversational applications. It simplifies the creation of chatbots and conversational agents by automatically managing chat history and responses, making it ideal for large language model (LLM) interactions.\n\nIn conversational AI applications, ChatInterface saves development time by handling chat history and responses intuitively.\n\nGradio offers a suite of interactive components that facilitate the creation of user-friendly interfaces for machine learning models and data applications. These components enable developers to design intuitive and responsive user experiences. Below, we explore some of the key elements:\n\nThe Textbox component allows users to input text data, making it essential for tasks (e.g., receiving user queries or textual data). It supports various configurations, including single-line and multi-line inputs, and can be customized with placeholders, labels, and default values.\n\nThe Button component triggers specific actions or functions when clicked. It‚Äôs commonly used to initiate processes like data submission, machine learning model inference, or other interactive tasks.\n\nThe Slider component enables users to select a numerical value within a specified range by dragging a handle along a track. It‚Äôs particularly useful for adjusting parameters like thresholds, learning rates, or any variable that benefits from fine-tuning.\n\nThe Dropdown component presents a list of options from which users can select. It‚Äôs ideal for scenarios where a predefined set of choices is available (e.g., selecting a model type or choosing a dataset).\n\nThe Checkbox component allows users to make binary choices (e.g., enabling or disabling a feature). It‚Äôs useful for toggling options or settings within an application.\n\nBy combining these components, developers can create rich, interactive interfaces that enhance user engagement and streamline the interaction with machine learning models and data-driven applications.\n\nAttributeError: Module ‚ÄòGradio‚Äô Has No Attribute ‚ÄòInputs‚Äô ‚Äî How to Fix It\n\nThe error is common when using outdated syntax. In previous Gradio versions, components like , , and were accessed with (e.g., ). In newer Gradio versions, however, this syntax has been deprecated, and components are now called directly (e.g., ).\n\nCause of the Error\n\nThis error appears when the older structure is used with a recent Gradio version. Gradio updated its API to simplify syntax, eliminating prefixes like .\n\nTo resolve this, update the syntax by removing :\n\nIf you‚Äôre using code from an older repository where the Gradio version isn‚Äôt specified in the file, Gradio will automatically install the latest version that‚Äôs compatible with your Python environment. This can lead to errors if the code relies on the syntax but doesn‚Äôt specify an older Gradio version.\n\nTo ensure compatibility with older syntax, you may need to specify a Gradio version compatible with the syntax (e.g., Gradio 3.5):\n\nPlease keep in mind that Gradio 3.5 is not compatible with Python 3.10 and above. If you‚Äôre working with Python 3.10+, you‚Äôll need to use a newer Gradio version and update the code syntax accordingly.\n\nThe Gradio API (a.k.a. the Gradio Python Client) enables developers to interact with Gradio applications programmatically. Rather than manually using the Gradio web interface, the API allows for remote communication with Gradio apps, making it an ideal tool for automation, integration with other applications, and backend connections.\n\nWhy Use the Gradio API?\n‚Ä¢ Remote Interactions: With the Gradio API, you can connect to and control Gradio applications from anywhere. This is particularly useful when deploying machine learning models as remote services that other applications or scripts can access.\n‚Ä¢ Automation and Testing: The API allows you to programmatically send inputs to the Gradio app, retrieve outputs, and automate testing workflows.\n‚Ä¢ Data Integration: For scenarios where Gradio apps are part of a larger pipeline, the API lets you connect the app with other systems (e.g., data preprocessing or external databases).\n\nIn essence, the Gradio API makes Gradio applications far more versatile and extensible, allowing for seamless integration with a variety of use cases.\n\nExample: Creating a Gradio App and Connecting via the Gradio API\n\nNow, let‚Äôs walk through a complete example where:\n‚Ä¢ We create a Gradio app that generates text based on input prompts.\n‚Ä¢ We connect to it remotely using the Gradio API.\n\nThis Gradio app will take a text prompt as input and generate text completions using a Hugging Face Transformer model.\n\nIn this setup, we‚Äôre using the Hugging Face model as the text-generation pipeline, which powers the function. This function is then exposed through a Gradio interface, allowing users to enter prompts and receive generated responses. By setting , Gradio provides a public URL for easy access to the app, which we‚Äôll use to connect through the Gradio API.\n\nStep 2: Connecting to the Gradio App Using the Gradio API (Client-Side)\n\nWith the Gradio app deployed, you can use the Gradio API to interact with it programmatically from a different script or environment.\n\nThe client connects to the Gradio app using the exact URL generated by Gradio, enabling remote interaction with the deployed app. To send data, the predict method takes a prompt and sends it to the app‚Äôs function. By specifying , we‚Äôre able to target the first function defined in the Gradio app (in this case, ) and retrieve the generated text as the output.\n\nNote: Replace with the specific URL generated when the Gradio app was launched.\n\nAlternative for Stability: For a more robust API setup, consider deploying your Gradio app to Hugging Face Spaces. Spaces provides a stable, permanent URL, and the functionality is expected to work consistently. You can run from your project directory to set this up. This deployment can prevent the issues encountered when using URLs, making it ideal for long-term applications or integrations.\n\nWhy This Gradio API Example Matters\n\nThis setup demonstrates the practical use of the Gradio API for creating and connecting to machine learning applications. By combining server-side app deployment with client-side automation, you can:\n‚Ä¢ Automate testing and run batch processes, further extending the use of Gradio beyond a simple GUI interface.\n\nFor additional capabilities, you can refer to the official Gradio Python Client documentation here.\n\nWhen using Gradio as an API, we can think of it as a client-server model. Here, the Gradio app acts as the server, handling incoming requests and executing the functions you‚Äôve defined (e.g., ). The Gradio Client, meanwhile, serves as the client that makes remote API calls to the app‚Äôs server-side functions.\n\nThough Gradio is primarily known as an interface library for interactive web apps, this setup demonstrates its versatility. It can function as both a user-facing application and a backend service that supports programmatic interaction, making it useful for remote API calls and automated workflows.\n\nThis guide introduced Gradio, a powerful Python library for building interactive applications to showcase machine learning models. It began with an overview of What Is Gradio, explaining its role in democratizing machine learning through accessible, user-friendly interfaces and highlighting high-impact projects that relied on it. Then, it covered What‚Äôs New in Version 5, outlining key improvements (e.g., enhanced performance, better security measures, AI-powered app creation, and low-latency streaming).\n\nFollowing that, it explored the Gradio Core Classes (e.g., Interface, Blocks, and the optional ChatInterface), which are essential for structuring applications in Gradio. Key components like Textbox, Buttons, and Sliders were discussed to help users understand how to build intuitive interfaces.\n\nA section on AttributeError: Module ‚ÄòGradio‚Äô Has No Attribute ‚ÄòInputs‚Äô addressed common errors, offering solutions and compatibility notes for older code repositories and Python versions. Finally, Understanding the Gradio API (Python Client) provided an example of connecting to a Gradio app via the API, illustrating how to send data and retrieve responses programmatically, with an explanation of why this approach is valuable for remote interactions.\n\nMartinez, H. ‚ÄúIntroduction to Gradio for Building Interactive Applications,‚Äù PyImageSearch, P. Chugh, S. Huot, A. Sharma, and P. Thakur, eds., 2025, https://pyimg.co/8dxkj\n\nTo download the source code to this post (and be notified when future tutorials are published here on PyImageSearch), simply enter your email address in the form below!"
    },
    {
        "link": "https://geeksforgeeks.org/creating-interactive-machine-learning-demos-with-gradio",
        "document": "Machine learning (ML) models are powerful tools that can drive innovation across various sectors. However, presenting these models in an accessible and engaging manner can be challenging. Gradio, an open-source Python package, offers a solution by enabling developers to create interactive web interfaces for machine learning models with minimal code.\n\nThis article delves into how to create interactive ML demonstrations using Gradio, covering use cases, best practices, and a step-by-step tutorial.\n\nGradio is a Python package designed to simplify the creation of user interfaces for machine learning models. With just a few lines of code, developers can transform their models into fully functional web applications. Gradio offers a range of input and output components that are easy to connect to your model, whether you are working on image classification, natural language processing, or other ML tasks.\n‚Ä¢ User-Friendly: Gradio handles the front-end development, eliminating the need for web development skills.\n‚Ä¢ Interactive: It provides a platform for users to interact with and better understand your model through hands-on engagement.\n‚Ä¢ Flexible: Gradio is adaptable to various machine learning applications due to its extensive support for different input types (text, images, audio, etc.) and outputs.\n‚Ä¢ Deployable: It includes simple deployment tools for sharing your models with others.\n‚Ä¢ Easy Interface Development: Gradio removes the complexity of designing an interface, allowing developers to focus on the machine learning aspect.\n‚Ä¢ Multiple Input/Output Components: Gradio supports a wide range of data types, including text, audio, video, images, and more.\n‚Ä¢ Real-Time Feedback: Users can see the results of their interactions instantly, enhancing the interactive experience.\n‚Ä¢ Customizable Layouts: Gradio allows customization of interface layouts to meet specific needs.\n‚Ä¢ Flexibility in Deployment: It can be deployed locally or in the cloud and integrated with Hugging Face Spaces for easy sharing.\n\nTo get started with Gradio, you need to install it via pip:\n\nLet's walk through a simple example of creating an interactive demo for a machine learning model. Suppose you have a pre-trained image classification model, and you want to create a demo that allows users to upload an image and see the model's predictions.\n\nIn this example:\n‚Ä¢ None We use a pre-trained MobileNetV2 model to classify images.\n‚Ä¢ None function resizes the uploaded image, preprocesses it, and returns the top 3 predictions.\n‚Ä¢ None We create a Gradio interface with an image input and a label output, and launch it.\n\nGradio is not limited to image classification; you can also use it to create demos for text generation models. Here's an example using a pre-trained GPT-2 model from the Hugging Face Transformers library.\n\nIn this example:\n‚Ä¢ None We use the GPT-2 model for text generation.\n‚Ä¢ None We create a Gradio interface with text input and output fields, and launch it.\n\nGradio also supports more advanced features such as chaining multiple models together, handling multiple inputs and outputs, and customizing the layout and design of the interface. You can even integrate it with other libraries like Hugging Face for NLP tasks or OpenAI's GPT models.\n\nGradio makes it easy to share your demo with others. By default, the method will create a local server that you can access in your browser. If you want to share your demo with others, you can enable the parameter:\n\nThis will generate a public URL that you can share with anyone, allowing them to interact with your model directly in their browser.\n\nDespite Gradio's ease of use, you may run into problems with deployment, input/output management, or model compatibility. The following are some recommended procedures:\n‚Ä¢ Model Optimization: To cut down on latency, make sure your model is optimized for inference.\n‚Ä¢ Input validation: Check user input to make sure there are no unforeseen mistakes.\n‚Ä¢ Security: If your Gradio demo handles important data, you should think about safeguarding it.\n‚Ä¢ Documentation: To help people navigate your demo, provide clear directions and examples.\n\nGradio provides a powerful yet simple way to create interactive machine learning demos. Whether you're a researcher, educator, or developer, Gradio can help you bring your models to life and share them with others. Its ease of use, flexibility, and sharing capabilities make it an invaluable tool in the machine learning ecosystem. So, the next time you want to demonstrate your model's capabilities, consider using Gradio to create an engaging and interactive experience."
    },
    {
        "link": "https://platform.openai.com/docs/api-reference",
        "document": ""
    },
    {
        "link": "https://platform.openai.com/docs/api-reference/introduction",
        "document": ""
    },
    {
        "link": "https://platform.openai.com/docs/models/gpt-4",
        "document": ""
    },
    {
        "link": "https://platform.openai.com/docs/models/gpt-4o",
        "document": ""
    },
    {
        "link": "https://platform.openai.com/docs/api-reference/chat/create",
        "document": ""
    }
]