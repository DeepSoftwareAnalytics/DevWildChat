[
    {
        "link": "https://github.com/node-pcap/node_pcap/blob/master/node_ko_article.md",
        "document": "OK, I hear you. Capturing packets is hard and best left to kernel hackers, assembly language programmers, and black hat security researches. If you just want to make things for the web using node.js, why should you care?\n\nPulling packets off the network can show you what your computers are saying to each other without disrupting the flow of or changing any applications. Packet capture is a fantastic debugging tool that will remove a lot of the mystery from writing and running network programs. The point of is to provide a good HTTP debugging tool and a framework for doing your own network analysis.\n\nThere are plenty of ways to do packet inspection these days, but none of them let you interact with your network traffic the way that node lets you write network programs: by writing a few event handlers in JavaScript. not only let's you capture and process packets in JavaScript, but since it is built on node.js, data from the packets can be easily routed around to web browsers, databases, or whatever else you can think of.\n\nHere's an example of capturing packets and sending them back to a web browser using WebSocket:\n\nIf you still aren't convinced, check out how easy it is to write a simple \"network grep\" type of program using :\n\nThis program will look at all TCP packets that flow past the default network interface and run the regular expression against the data section of the packet. If it matches, the data section will be printed.\n\nStill not convinced? I understand. This packet business can be astonishingly low level compared to the abstractions you are comfortable working with. If this doesn't seem awesome yet, it probably won't until you actually need it. When you can't figure out what your program is doing by just adding log messages, come back and check out what packet capture can do for you.\n\nexposes packets as JavaScript objects, but it also comes with a few examples that are useful on their own. If you do nothing else, check out and . Look at the source code and see how they work. It's really easy.\n\nAnyway, if you are still here, let's get this sucker installed. The first thing you'll need is . If you are on OSX 10.6, you already have it. If you are on a Linux system that uses to install things, you can get it like this:\n\nIf you are on some other kind of system, I don't know the exact command to install , but it is a very common library that's widely available.\n\nOnce you have and node, you just need . Install with like this:\n\nThis will install the pcap libraries and three executable.\n\nIf you want to hack on the code, and I encourage you to do so, use to clone the repository on github:\n\nYou'll still need to use to build and install the files where they need to go:\n\nTo verify that things are working, run:\n\nIt should look something like this:\n\nYour traffic might not be ARP requests, but some packets should be flowing, and you should see one line per packet.\n\nOpening the capture interface on most operating systems requires root access, so most of the time that you run a program using you'll need to use sudo.\n\nis a tool that distills the packets involved in an HTTP session into higher level events. There are command line options to adjust the output and select different requests. Here's a simple example of looking for any requests that have \"favicon\" in the URL and showing request and response headers:\n\nTo see the full list of options do:\n\nWith no arguments, will listen on the default interface for any IPv4 TCP traffic on any port. If it finds HTTP on any TCP connection, it'll start decoding it. You might be surprised by how many HTTP connections your computer is making that you didn't know about, especially if you run OSX. Fire it up and see what you find.\n\nHere's why you need all of this. Let's say you have a node program that makes an outgoing connection, but the outgoing connection doesn't seem like it is working. This reason in this case is that a firewall rule is filtering the traffic. Here's how to detect it:\n\nThe option will expose events for TCP connection setup, close, and reset. It'll also let you know about SYN retries and packets retransmissions. SYN retry happens when a new TCP connection is getting set up, but the other side isn't responding. Retransmissions occur when packets are dropped by the network, and TCP on either end of the connection resends data that has already sent. If data is moving slowly, but you don't appear to be out of CPU, turn on and see if you are getting retransmissions or SYN retries. If so, you can blame the network and not your node program.\n\nAnother common case is when the data going over the network isn't quite the data you were expecting. Here's a simple example using curl from the command line. Let's say you wanted to send some JSON to your local CouchDB, but CouchDB keeps rejecting it.\n\nThat looks like pretty well-formed JSON, so what's going on here? Run with the --bodies option to dump the request and response body. Since this is a connection to , we need to explicitly listen on the loopback interface.\n\nHere we can see that the request body was simply, \"{foo:\", which is clearly not valid JSON. The problem in this case is that the shell and curl couldn't figure out what part of the command line arguments to use for the POST body, and they got it wrong. This works if quoted properly:\n\ncan piece back together a TCP session from individual packets as long as it sees them all go by. It will emit events at TCP connection setup, teardown, and reset.\n\nOn top of TCP, it can decode HTTP and WebSocket messages, emitting events for request, response, upgrade, data, etc.\n\nIt looks sort of like this:\n\nYou set up to capture the packets you want, and then you can work with the captured data in JavaScript at whatever level is the most useful.\n\nThere are a lot of cases that doesn't handle, and for these you'll need a more complete packet decoder like Wireshark. I'm trying to handle the common case of OSX/Linux, IPv4, TCP, HTTP, and WebSocket first, and then add support for other variants of the protocol stack.\n\nIf you like this kind of stuff and want to help expand the protocols that understands, patches are certainly welcome.\n\nI hope this software is useful and fun. Thanks for reading."
    },
    {
        "link": "https://github.com/node-pcap/node_pcap",
        "document": "Disclaimer: There's been some API changes between v2 and v3; the and arguments now accept an object. Also, if you're capturing on monitor wifi interfaces, the Radiotap header now has different fields.\n\nThis is a set of bindings from to node as well as some useful libraries to decode, print, and analyze packets. is a packet capture library used by programs like and . It has been tested on OSX and Linux.\n\nis useful for many things, but it does not yet understand all common protocols. Common reasons to use this package are http_trace (works only on node 4), and htracr.\n\nThere are already many tools for capturing, decoding, and analyzing packets. Many of them are thoroughly tested and very fast. Why would anybody want to do such low level things like packet capture and analysis in JavaScript? A few reasons:\n• JavaScript makes writing event-based programs very natural. Each packet that is captured generates an event, and as higher level protocols are decoded, they might generate events as well. Writing code to handle these events is much easier and more readable with anonymous functions and closures.\n• node makes handling binary data in JavaScript fast and efficient with its Buffer class. Decoding packets involves a lot of binary slicing and dicing which can be awkward with JavaScript strings.\n• Writing servers that capture packets, process them somehow, and then serve the processed data up in some way is very straightforward in node.\n• Node has a very good HTTP parser that is used to progressively decode HTTP sessions.\n\nYou will need installed. Most OSX machines seem to have it. All major Linux distributions have it available either by default or with a package like .\n\nThe easiest way to get and its tools is with :\n\nIf you want to hack on the source code, you can get it from github. Clone the repo like this:\n\nTo compile the native code bindings, do this:\n\nAssuming it built without errors, you should be able to run the examples and then write your own packet capture programs.\n\nThere are several example programs that show how to use . These examples are best documentation. Try them out and see what they do.\n\nTo start a capture session, call with an interface name and a pcap filter string:\n\nis the name of the network interface on which to capture packets. If passed an empty string, will try to pick a \"default\" interface, which is often just the first one in some list and not what you want.\n\nThe object accepts the following properties:\n• On broadcast LANs such as Ethernet, if the network isn't switched, or if the adapter is connected to a \"mirror port\" on a switch to which all packets passing through the switch are sent, a network adapter receives all packets on the LAN, including unicast or multicast packets not sent to a network address that the network adapter isn't configured to recognize. Normally, the adapter will discard those packets; however, many network adapters support \"promiscuous mode\", which is a mode in which all packets, even if they are not sent to an address that the adapter recognizes, are provided to the host. This is useful for passively capturing traffic between two or more other hosts for analysis. Note that even if an application does not set promiscuous mode, the adapter could well be in promiscuous mode for some other reason. For now, this doesn't work on the \"any\" device; if an argument of \"any\" or NULL is supplied, the setting of promiscuous mode is ignored.\n• Packets that arrive for a capture are stored in a buffer, so that they do not have to be read by the application as soon as they arrive. On some platforms, the buffer's size can be set; a size that's too small could mean that, if too many packets are being captured and the snapshot length doesn't limit the amount of data that's buffered, packets could be dropped if the buffer fills up before the application can read packets from it, while a size that's too large could use more non-pageable operating system memory than is necessary to prevent packets from being dropped.\n• If, when capturing, packets are delivered as soon as they arrive, the application capturing the packets will be woken up for each packet as it arrives, and might have to make one or more calls to the operating system to fetch each packet. If, instead, packets are not delivered as soon as they arrive, but are delivered after a short delay (called a \"packet buffer timeout\"), more than one packet can be accumulated before the packets are delivered, so that a single wakeup would be done for multiple packets, and each set of calls made to the operating system would supply multiple packets, rather than a single packet. This reduces the per-packet CPU overhead if packets are arriving at a high rate, increasing the number of packets per second that can be captured. The packet buffer timeout is required so that an application won't wait for the operating system's capture buffer to fill up before packets are delivered; if packets are arriving slowly, that wait could take an arbitrarily long period of time. Not all platforms support a packet buffer timeout; on platforms that don't, the packet buffer timeout is ignored. A zero value for the timeout, on platforms that support a packet buffer timeout, will cause a read to wait forever to allow enough packets to arrive, with no timeout. A negative value is invalid; the result of setting the timeout to a negative value is unpredictable. NOTE: the packet buffer timeout cannot be used to cause calls that read packets to return within a limited period of time, because, on some platforms, the packet buffer timeout isn't supported, and, on other platforms, the timer doesn't start until at least one packet arrives. This means that the packet buffer timeout should NOT be used, for example, in an interactive application to allow the packet capture loop to 'poll' for user input periodically, as there's no guarantee that a call reading packets will return after the timeout expires even if no packets have arrived. If set to zero or negative, then instead immediate mode is enabled: In immediate mode, packets are always delivered as soon as they arrive, with no buffering.\n• On IEEE 802.11 wireless LANs, even if an adapter is in promiscuous mode, it will supply to the host only frames for the network with which it's associated. It might also supply only data frames, not management or control frames, and might not provide the 802.11 header or radio information pseudo-header for those frames. In \"monitor mode\", sometimes also called \"rfmon mode\" (for \"Radio Frequency MONitor\"), the adapter will supply all frames that it receives, with 802.11 headers, and might supply a pseudo-header with radio information about the frame as well. Note that in monitor mode the adapter might disassociate from the network with which it's associated, so that you will not be able to use any wireless networks with that adapter. This could prevent accessing files on a network server, or resolving host names or network addresses, if you are capturing in monitor mode and are not connected to another network with another adapter.\n• If, when capturing, you capture the entire contents of the packet, that requires more CPU time to copy the packet to your application, more disk and possibly network bandwidth to write the packet data to a file, and more disk space to save the packet. If you don't need the entire contents of the packet - for example, if you are only interested in the TCP headers of packets - you can set the \"snapshot length\" for the capture to an appropriate value. If the snapshot length is set to snaplen, and snaplen is less than the size of a packet that is captured, only the first snaplen bytes of that packet will be captured and provided as packet data. A snapshot length of 65535 should be sufficient, on most if not all networks, to capture all the data available from the packet.\n\nNote that by default opens the interface in promiscuous mode, which generally requires running as root. Unless you are recklessly roaming about as root already, you'll probably want to start your node program like this:\n\nis an that emits a event. The only argument to the callback will be a object containing the raw bytes returned by :\n\nThis contains and ( s) and .\n\nTo convert into a JavaScript object that is easy to work with, decode it:\n\nThe protocol stack is exposed as a nested set of objects. For example, the TCP destination port is part of TCP which is encapsulated within IP, which is encapsulated within a link layer. Each layer is contained within the attribute of the upper layer (or the packet itself):\n\nThis structure is easy to explore with .\n\nHowever, if you decide to parse yourself, make sure to truncate it to the first bytes first.\n\nTCP can be analyzed by feeding the packets into a and then listening for and events.\n\nYou must only send IPv4 TCP packets to the TCP tracker. Explore the object with to see the wonderful things it can do for you. Hopefully the names of the properties are self-explanatory:\n\nSee http_trace for an example of how to use these events to decode HTTP (Works only on node 4).\n\nTo know the format of the link-layer headers, use or . The property is a string, see this list.\n\nTo get current capture statistics, use . This returns an object with the following properties:\n• : number of packets dropped by the network interface or its driver\n• : number of packets dropped because there was no room in the operating system's buffer when they arrived, because packets weren't being read fast enough\n\nFor more info, see .\n\nIf you no longer need to receive packets, you can use .\n\nTo read packets from a file instead of from a live interface, use instead:\n\nWhere only accepts the property.\n\nTSO is a technique that modern operating systems use to offload the burden of IP/TCP header computation to the network hardware. It also reduces the number of times that data is moved data between the kernel and the network hardware. TSO saves CPU when sending data that is larger than a single IP packet.\n\nThis is amazing and wonderful, but it does make some kinds of packet sniffing more difficult. In many cases, it is important to see the exact packets that are sent, but if the network hardware is sending the packets, these are not available to . The solution is to disable TSO.\n\nThe symptoms of needing to disable TSO are messages like, \"Received ACK for packet we didn't see get sent\".\n\nSadly, does not know how to decode IPv6 packets yet. Often when capturing traffic to , IPv6 traffic will arrive surprisingly, even though you were expecting IPv4. A common case is the hostname , which many client programs will resolve to the IPv6 address and then will try . Until we get IPv6 decode support, a filter can be set to only see IPv4 traffic:\n\nThe backslash is important. The pcap filter language has an ambiguity with the word \"tcp\", so by escaping it, you'll get the correct interpretation for this case.\n\nThere are several levels of buffering involved in capturing packets. Sometimes these buffers fill up, and you'll drop packets. If this happens, it becomes difficult to reconstruct higher level protocols. The best way to keep the buffers from filling up is to use pcap filters to only consider traffic that you need to decode. The pcap filters are very efficient and run close to the kernel where they can process high packet rates.\n\nIf the pcap filters are set correctly and still drops packets, you can increase the option. To check if there's any packet loss, you can use as indicated above.\n\nlibpcap may sometimes emit warnings (for instance, when an interface has no address). By default these are printed to the console, but you can override the warning handler with your own function:"
    },
    {
        "link": "https://npmjs.com/package/pcap",
        "document": "Disclaimer: There's been some API changes between v2 and v3; the and arguments now accept an object. Also, if you're capturing on monitor wifi interfaces, the Radiotap header now has different fields.\n\nThis is a set of bindings from to node as well as some useful libraries to decode, print, and analyze packets. is a packet capture library used by programs like and . It has been tested on OSX and Linux.\n\nis useful for many things, but it does not yet understand all common protocols. Common reasons to use this package are http_trace (works only on node 4), and htracr.\n\nThere are already many tools for capturing, decoding, and analyzing packets. Many of them are thoroughly tested and very fast. Why would anybody want to do such low level things like packet capture and analysis in JavaScript? A few reasons:\n• JavaScript makes writing event-based programs very natural. Each packet that is captured generates an event, and as higher level protocols are decoded, they might generate events as well. Writing code to handle these events is much easier and more readable with anonymous functions and closures.\n• node makes handling binary data in JavaScript fast and efficient with its Buffer class. Decoding packets involves a lot of binary slicing and dicing which can be awkward with JavaScript strings.\n• Writing servers that capture packets, process them somehow, and then serve the processed data up in some way is very straightforward in node.\n• Node has a very good HTTP parser that is used to progressively decode HTTP sessions.\n\nYou will need installed. Most OSX machines seem to have it. All major Linux distributions have it available either by default or with a package like .\n\nThe easiest way to get and its tools is with :\n\nIf you want to hack on the source code, you can get it from github. Clone the repo like this:\n\nTo compile the native code bindings, do this:\n\nAssuming it built without errors, you should be able to run the examples and then write your own packet capture programs.\n\nThere are several example programs that show how to use . These examples are best documentation. Try them out and see what they do.\n\nTo start a capture session, call with an interface name and a pcap filter string:\n\nis the name of the network interface on which to capture packets. If passed an empty string, will try to pick a \"default\" interface, which is often just the first one in some list and not what you want.\n\nThe object accepts the following properties:\n• On broadcast LANs such as Ethernet, if the network isn't switched, or if the adapter is connected to a \"mirror port\" on a switch to which all packets passing through the switch are sent, a network adapter receives all packets on the LAN, including unicast or multicast packets not sent to a network address that the network adapter isn't configured to recognize. Normally, the adapter will discard those packets; however, many network adapters support \"promiscuous mode\", which is a mode in which all packets, even if they are not sent to an address that the adapter recognizes, are provided to the host. This is useful for passively capturing traffic between two or more other hosts for analysis. Note that even if an application does not set promiscuous mode, the adapter could well be in promiscuous mode for some other reason. For now, this doesn't work on the \"any\" device; if an argument of \"any\" or NULL is supplied, the setting of promiscuous mode is ignored.\n• Packets that arrive for a capture are stored in a buffer, so that they do not have to be read by the application as soon as they arrive. On some platforms, the buffer's size can be set; a size that's too small could mean that, if too many packets are being captured and the snapshot length doesn't limit the amount of data that's buffered, packets could be dropped if the buffer fills up before the application can read packets from it, while a size that's too large could use more non-pageable operating system memory than is necessary to prevent packets from being dropped.\n• If, when capturing, packets are delivered as soon as they arrive, the application capturing the packets will be woken up for each packet as it arrives, and might have to make one or more calls to the operating system to fetch each packet. If, instead, packets are not delivered as soon as they arrive, but are delivered after a short delay (called a \"packet buffer timeout\"), more than one packet can be accumulated before the packets are delivered, so that a single wakeup would be done for multiple packets, and each set of calls made to the operating system would supply multiple packets, rather than a single packet. This reduces the per-packet CPU overhead if packets are arriving at a high rate, increasing the number of packets per second that can be captured. The packet buffer timeout is required so that an application won't wait for the operating system's capture buffer to fill up before packets are delivered; if packets are arriving slowly, that wait could take an arbitrarily long period of time. Not all platforms support a packet buffer timeout; on platforms that don't, the packet buffer timeout is ignored. A zero value for the timeout, on platforms that support a packet buffer timeout, will cause a read to wait forever to allow enough packets to arrive, with no timeout. A negative value is invalid; the result of setting the timeout to a negative value is unpredictable. NOTE: the packet buffer timeout cannot be used to cause calls that read packets to return within a limited period of time, because, on some platforms, the packet buffer timeout isn't supported, and, on other platforms, the timer doesn't start until at least one packet arrives. This means that the packet buffer timeout should NOT be used, for example, in an interactive application to allow the packet capture loop to 'poll' for user input periodically, as there's no guarantee that a call reading packets will return after the timeout expires even if no packets have arrived. If set to zero or negative, then instead immediate mode is enabled: In immediate mode, packets are always delivered as soon as they arrive, with no buffering.\n• On IEEE 802.11 wireless LANs, even if an adapter is in promiscuous mode, it will supply to the host only frames for the network with which it's associated. It might also supply only data frames, not management or control frames, and might not provide the 802.11 header or radio information pseudo-header for those frames. In \"monitor mode\", sometimes also called \"rfmon mode\" (for \"Radio Frequency MONitor\"), the adapter will supply all frames that it receives, with 802.11 headers, and might supply a pseudo-header with radio information about the frame as well. Note that in monitor mode the adapter might disassociate from the network with which it's associated, so that you will not be able to use any wireless networks with that adapter. This could prevent accessing files on a network server, or resolving host names or network addresses, if you are capturing in monitor mode and are not connected to another network with another adapter.\n• If, when capturing, you capture the entire contents of the packet, that requires more CPU time to copy the packet to your application, more disk and possibly network bandwidth to write the packet data to a file, and more disk space to save the packet. If you don't need the entire contents of the packet - for example, if you are only interested in the TCP headers of packets - you can set the \"snapshot length\" for the capture to an appropriate value. If the snapshot length is set to snaplen, and snaplen is less than the size of a packet that is captured, only the first snaplen bytes of that packet will be captured and provided as packet data. A snapshot length of 65535 should be sufficient, on most if not all networks, to capture all the data available from the packet.\n\nNote that by default opens the interface in promiscuous mode, which generally requires running as root. Unless you are recklessly roaming about as root already, you'll probably want to start your node program like this:\n\nis an that emits a event. The only argument to the callback will be a object containing the raw bytes returned by :\n\nThis contains and ( s) and .\n\nTo convert into a JavaScript object that is easy to work with, decode it:\n\nThe protocol stack is exposed as a nested set of objects. For example, the TCP destination port is part of TCP which is encapsulated within IP, which is encapsulated within a link layer. Each layer is contained within the attribute of the upper layer (or the packet itself):\n\nThis structure is easy to explore with .\n\nHowever, if you decide to parse yourself, make sure to truncate it to the first bytes first.\n\nTCP can be analyzed by feeding the packets into a and then listening for and events.\n\nYou must only send IPv4 TCP packets to the TCP tracker. Explore the object with to see the wonderful things it can do for you. Hopefully the names of the properties are self-explanatory:\n\nSee http_trace for an example of how to use these events to decode HTTP (Works only on node 4).\n\nTo know the format of the link-layer headers, use or . The property is a string, see this list.\n\nTo get current capture statistics, use . This returns an object with the following properties:\n• : number of packets dropped by the network interface or its driver\n• : number of packets dropped because there was no room in the operating system's buffer when they arrived, because packets weren't being read fast enough\n\nFor more info, see .\n\nIf you no longer need to receive packets, you can use .\n\nTo read packets from a file instead of from a live interface, use instead:\n\nWhere only accepts the property.\n\nTSO is a technique that modern operating systems use to offload the burden of IP/TCP header computation to the network hardware. It also reduces the number of times that data is moved data between the kernel and the network hardware. TSO saves CPU when sending data that is larger than a single IP packet.\n\nThis is amazing and wonderful, but it does make some kinds of packet sniffing more difficult. In many cases, it is important to see the exact packets that are sent, but if the network hardware is sending the packets, these are not available to . The solution is to disable TSO.\n\nThe symptoms of needing to disable TSO are messages like, \"Received ACK for packet we didn't see get sent\".\n\nSadly, does not know how to decode IPv6 packets yet. Often when capturing traffic to , IPv6 traffic will arrive surprisingly, even though you were expecting IPv4. A common case is the hostname , which many client programs will resolve to the IPv6 address and then will try . Until we get IPv6 decode support, a filter can be set to only see IPv4 traffic:\n\nThe backslash is important. The pcap filter language has an ambiguity with the word \"tcp\", so by escaping it, you'll get the correct interpretation for this case.\n\nThere are several levels of buffering involved in capturing packets. Sometimes these buffers fill up, and you'll drop packets. If this happens, it becomes difficult to reconstruct higher level protocols. The best way to keep the buffers from filling up is to use pcap filters to only consider traffic that you need to decode. The pcap filters are very efficient and run close to the kernel where they can process high packet rates.\n\nIf the pcap filters are set correctly and still drops packets, it is possible to increase 's buffer size. At the moment, this requires changing . Look for and set to a larger value.\n\nlibpcap may sometimes emit warnings (for instance, when an interface has no address). By default these are printed to the console, but you can override the warning handler with your own function:"
    },
    {
        "link": "https://npmjs.com/package/pcap/v/1.0.0",
        "document": "This is a set of bindings from to node as well as some useful libraries to decode, print, and analyze packets. is a packet capture library used by programs like and . It has been tested on OSX and Linux.\n\nis useful for many things, but it does not yet understand all common protocols. Common reasons to use this package are http_trace, and htracr.\n\nThere are already many tools for capturing, decoding, and analyzing packets. Many of them are thoroughly tested and very fast. Why would anybody want to do such low level things like packet capture and analysis in JavaScript? A few reasons:\n• JavaScript makes writing event-based programs very natural. Each packet that is captured generates an event, and as higher level protocols are decoded, they might generate events as well. Writing code to handle these events is much easier and more readable with anonymous functions and closures.\n• node makes handling binary data in JavaScript fast and efficient with its Buffer class. Decoding packets involves a lot of binary slicing and dicing which can be awkward with JavaScript strings.\n• Writing servers that capture packets, process them somehow, and then serve the processed data up in some way is very straightforward in node.\n• Node has a very good HTTP parser that is used to progressively decode HTTP sessions.\n\nYou will need installed. Most OSX machines seem to have it. All major Linux distributions have it available either by default or with a package like .\n\nThe easiest way to get and its tools is with :\n\nIf you want to hack on the source code, you can get it from github. Clone the repo like this:\n\nTo compile the native code bindings, do this:\n\nAssuming it built without errors, you should be able to run the examples and then write your own packet capture programs.\n\nThere are several example programs that show how to use . These examples are best documentation. Try them out and see what they do.\n\nTo use this library in your own program, and must be in . takes care of this automatically.\n\nTo start a capture session, call with an interface name and a pcap filter string:\n\nis the name of the interface on which to capture packets. If passed an empty string, will try to pick a \"default\" interface, which is often just the first one in some list and not what you want.\n\nis a pcap filter expression, see for more information. An empty string will capture all packets visible on the interface.\n\nNote that always opens the interface in promiscuous mode, which generally requires running as root. Unless you are recklessly roaming about as root already, you'll probably want to start your node program like this:\n\nis an that emits a event. The only argument to the callback will be a object with the raw bytes returned by .\n\nTo convert into a JavaScript object that is easy to work with, decode it:\n\nThe protocol stack is exposed as a nested set of objects. For example, the TCP destination port is part of TCP which is encapsulated within IP, which is encapsulated within a link layer. Access it like this:\n\nThis structure is easy to explore with .\n\nTCP can be analyzed by feeding the packets into a and then listening for and events.\n\nYou must only send IPv4 TCP packets to the TCP tracker. Explore the object with to see the wonderful things it can do for you. Hopefully the names of the properties are self-explanatory:\n\nThe also detects and decodes HTTP on all streams it receives. If HTTP is detected, several new events will be emitted:\n• Note that is a node Buffer object sliced from the original packet. If you want to use it past the current tick, you'll need to make a copy somehow.\n• is a Buffer slice. See above.\n\nSee for an example of how to use these events to decode HTTP.\n\nThe further detects and decodes WebSocket traffic on all streams it receives.\n\nSee for an example of how to use these events to decode WebSocket.\n\nTSO is a technique that modern operating systems use to offload the burden of IP/TCP header computation to the network hardware. It also reduces the number of times that data is moved data between the kernel and the network hardware. TSO saves CPU when sending data that is larger than a single IP packet.\n\nThis is amazing and wonderful, but it does make some kinds of packet sniffing more difficult. In many cases, it is important to see the exact packets that are sent, but if the network hardware is sending the packets, these are not available to . The solution is to disable TSO.\n\nThe symptoms of needing to disable TSO are messages like, \"Received ACK for packet we didn't see get sent\".\n\nSadly, does not know how to decode IPv6 packets yet. Often when capturing traffic to , IPv6 traffic will arrive surprisingly, even though you were expecting IPv4. A common case is the hostname , which many client programs will resolve to the IPv6 address and then will try . Until we get IPv6 decode support, a filter can be set to only see IPv4 traffic:\n\nThe backslash is important. The pcap filter language has an ambiguity with the word \"tcp\", so by escaping it, you'll get the correct interpretation for this case.\n\nThere are several levels of buffering involved in capturing packets. Sometimes these buffers fill up, and you'll drop packets. If this happens, it becomes difficult to reconstruct higher level protocols. The best way to keep the buffers from filling up is to use pcap filters to only consider traffic that you need to decode. The pcap filters are very efficient and run close to the kernel where they can process high packet rates.\n\nIf the pcap filters are set correctly and still drops packets, it is possible to increase 's buffer size. At the moment, this requires changing . Look for and set to a larger value.\n\nThis program captures packets and prints them using the built in simple printer. Here's a sample of it's output. In another window I ran .\n\nRunning on the first three decoded packets of this TCP session.\n\nThird packet, TCP ACK, 3-way handshake is now complete:\n\nI want to build up decoders and printers for all popular protocols. Patches are welcome.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE."
    },
    {
        "link": "https://tcpdump.org",
        "document": "This is the home web site of tcpdump, a powerful command-line packet analyzer; and libpcap, a portable C/C++ library for network traffic capture. Here you can find the latest stable version of tcpdump and libpcap, as well as current development versions, a complete documentation, and information about how to report bugs or contribute patches.\n\nThis tcpdump release makes various improvements and bug fixes available whilst the work on tcpdump 5.0 is still in progress. This release requires libpcap 1.10.0 or later to pass all test cases. This libpcap release makes various improvements and bug fixes available whilst the work on libpcap 1.11 is still in progress. Among other things this includes the fixes to two vulnerabilities (CVE-2023-7256 discovered by Dora Sweet and CVE-2024-8006 discovered by Flavio Toffalini and reported by Nicolas Badoux) in the remote packet capture code, which is disabled by default.\n\nThe current development versions are freely accessible through the GitHub Git hosting site (tcpdump, libpcap). You can clone these repositories with the following commands: A read-only git mirror of all project repositories is available here in case anyone needs it. After cloning the git repositories you can configure and compile the source via either GNU Autoconf or CMake. There is various continuous integration involved in the development process.\n\ntcpdump and libpcap are open source software and anyone can make contributions. You can help by:\n• downloading and testing libpcap and tcpdump on your platform\n• proofreading the documentation and the man pages\n• providing files for protocols or protocol features that tcpdump supports, but does not test yet\n• helping to improve the continuous integration scripts and infrastructure If you want to contribute, please subscribe to the tcpdump-workers mailing list. It's a good idea to discuss bugfixes and new feature additions in advance, because the changes may have bigger implications than you think and your patch may not get accepted.\n\ntcpdump and libpcap are under a 3-clause BSD license. While the current authors have no objection to converting to a 2-clause BSD license, the number of contributors that would need to agree makes this change unpracticable."
    },
    {
        "link": "https://stackoverflow.com/questions/29938319/nodejs-pcap-tcp-segment",
        "document": "My Node.js program use for capture packet from specific port and analyse the data from binary stream.\n\nNormally the range of packet length should be 100 - 300 but sometime with some reason the destination server got hang and didn't send data to my program. And later on when it back, it sent a bulk of binary data. Which is separate to many TCP stream packets as a picture in this link. Picture to show the packets detail\n\nI capture those packets and open with Wireshark. I realise that those packets doesn't came with PSH flag in TCP layer except the last one. And with incorrect sequence, my program can't work properly as expectation (it crash).\n\nCan somebody tell me how to handle with this situation ? Do I need to consider the PSH flag and reassembly those packets before process the logic by node.js program."
    },
    {
        "link": "https://stackoverflow.com/questions/11272383/capturing-packets-with-nodejs-on-windows",
        "document": "I was trying to capture, decode and monitor AMF requests on a windows machine and came up with the following solution for capturing packets using node.js, edge.js and pcap.net library.\n\nMake sure you have the correct version (32bit or 64bit) of node.js and the requirements for edge.js\n\nAlso make sure to change/remove the packet filter around line 64 in the code."
    },
    {
        "link": "https://medium.com/@nikolaystoykov/build-custom-protocol-on-top-of-tcp-with-node-js-part-1-fda507d5a262",
        "document": "When I first started to experiment with Node.js, I wanted to get my hands dirty with TCP sockets. So I encountered several problems I want to share with you.\n\nWhat you see is NOT what you get…\n\nLet’s suppose you have the following server code:\n\nThe code for the server should be pretty straightforward and self-explanatory.\n\nThen the client code looks the following:\n\nWhat you expect is that on data event you will receive the whole “Hello World” message or in other means 11 bytes, but sometimes it might happen that you will get the whole message in 2 “data” events. Don’t get me wrong — TCP will make sure that every peace of data is received in order. The fragmentation of the data is due to the streaming nature of TCP.\n\nIn some cases the “socket.write” invocations might come as one data event. This is called TCP coalescing. This happens due to Nagle’s algorithm. Generally it is there to protect misbehaving applications from congesting the network with many small packets. Because every TCP packet has an overhead of 40 bytes header, if the application is sending only 1 byte of valuable information every second you can imagine what can happen. I won’t go into more detail about Nagle’s algorithm. I find this article interesting on the subject.\n\nIf you are familiar with Web sockets and have written client-server using this, you will know that they have the concept of messages. The web socket standard, defines it in very details. If you feel okay with reading RFCs (or it will be a great way to start), I strongly encourage you to read the web socket standard.\n\nSo, lets tackle with our problem. First we’ll need to define our own protocol on top of TCP and define what a message is. Let’s assume that we want to transmit plain text over the network. We need something to denote the end of a message. For example, we can use “\n\n”(newline) character for message separator.\n\nBecause our message contains only plain text, for every newly received data, we concatenate what we received. The next step is to process what we have received so far, so we split on “\n\n” character and display the message.\n\nThe server’s purpose is to only send data to the client and show how the client processes it.\n\nThe next figure shows the output on the client-side application. As you can see the client received 2 packets — one containing 112 bytes and the other 83 bytes of data. If you look closely to the server.js code, you will see that the long dashed line is sent before the setTimeout, but is shown as it is received after the timeout has fired. This is because the client is expecting to see an end of a message, which is not yet sent.\n\nNow if you stop for a moment and think, you’ll notice that the above solution will not work in case you want your messages to contain new lines.\n\nAnother way to overcome this is to use longer sequence of unique characters. You may use some kind of random generator to create this sequence. This approach has several drawbacks:\n• You need to send the sequence to the other side (client or server).\n• The longer the sequence, the longer the message size — this leads to more bytes over the network\n• If someone accidentally sends the same sequence of bytes, this will lead to malformed messages.\n\nWe thought long and hard and we finally came out with an award-winning format to send messages over the network.\n\nWe’ll separate each message in 2 segments — header and actual payload. The header will always be 2 bytes in size and will contain 1 unsigned integer. This integer will show how many bytes the payload contains. The quotes around Hello World are just to show that it is a string, but you can send whatever bytes you want.\n\nIt is important to note the way numbers can be stored. As we are using Node.js for client and server implementation — the built-in Buffer module will come to help. We’ll have to decide in what Endianness to write the integer. The order in which you write the integer, have to be the order in which you read it. Buffer module has a number of convenient methods for reading and writing integers in different orders and sizes.\n\nAn example from the Node.js documentation:\n\nThe following code contains the class Networker which will take care of reading the header and the actual payload of the packets. For every received data it checks whether there is enough bytes to read. So, first it tries to read 2 bytes for the header and then proceeds to the payload.\n\nI suggest you to first start with _onData method on line 89. Then go to the method _readBytes.\n\nNext is the server.js and client.js code:\n\nThey both take advantage of the previously shown networker.js to send and receive messages. In later articles we’ll extend client’s code to be able to send arbitrary messages from the console.\n\nTo go deeper in this challenge you can try to define some structure for the payload. For example if you want to send an object, how can you encode it in the payload, and so on.\n\nIn the following articles I will try to show and explain you how to create a simple chat application using the above techniques. Also we’ll go into the details of how to send files not only plain text messages."
    },
    {
        "link": "https://github.com/node-pcap/node_pcap",
        "document": "Disclaimer: There's been some API changes between v2 and v3; the and arguments now accept an object. Also, if you're capturing on monitor wifi interfaces, the Radiotap header now has different fields.\n\nThis is a set of bindings from to node as well as some useful libraries to decode, print, and analyze packets. is a packet capture library used by programs like and . It has been tested on OSX and Linux.\n\nis useful for many things, but it does not yet understand all common protocols. Common reasons to use this package are http_trace (works only on node 4), and htracr.\n\nThere are already many tools for capturing, decoding, and analyzing packets. Many of them are thoroughly tested and very fast. Why would anybody want to do such low level things like packet capture and analysis in JavaScript? A few reasons:\n• JavaScript makes writing event-based programs very natural. Each packet that is captured generates an event, and as higher level protocols are decoded, they might generate events as well. Writing code to handle these events is much easier and more readable with anonymous functions and closures.\n• node makes handling binary data in JavaScript fast and efficient with its Buffer class. Decoding packets involves a lot of binary slicing and dicing which can be awkward with JavaScript strings.\n• Writing servers that capture packets, process them somehow, and then serve the processed data up in some way is very straightforward in node.\n• Node has a very good HTTP parser that is used to progressively decode HTTP sessions.\n\nYou will need installed. Most OSX machines seem to have it. All major Linux distributions have it available either by default or with a package like .\n\nThe easiest way to get and its tools is with :\n\nIf you want to hack on the source code, you can get it from github. Clone the repo like this:\n\nTo compile the native code bindings, do this:\n\nAssuming it built without errors, you should be able to run the examples and then write your own packet capture programs.\n\nThere are several example programs that show how to use . These examples are best documentation. Try them out and see what they do.\n\nTo start a capture session, call with an interface name and a pcap filter string:\n\nis the name of the network interface on which to capture packets. If passed an empty string, will try to pick a \"default\" interface, which is often just the first one in some list and not what you want.\n\nThe object accepts the following properties:\n• On broadcast LANs such as Ethernet, if the network isn't switched, or if the adapter is connected to a \"mirror port\" on a switch to which all packets passing through the switch are sent, a network adapter receives all packets on the LAN, including unicast or multicast packets not sent to a network address that the network adapter isn't configured to recognize. Normally, the adapter will discard those packets; however, many network adapters support \"promiscuous mode\", which is a mode in which all packets, even if they are not sent to an address that the adapter recognizes, are provided to the host. This is useful for passively capturing traffic between two or more other hosts for analysis. Note that even if an application does not set promiscuous mode, the adapter could well be in promiscuous mode for some other reason. For now, this doesn't work on the \"any\" device; if an argument of \"any\" or NULL is supplied, the setting of promiscuous mode is ignored.\n• Packets that arrive for a capture are stored in a buffer, so that they do not have to be read by the application as soon as they arrive. On some platforms, the buffer's size can be set; a size that's too small could mean that, if too many packets are being captured and the snapshot length doesn't limit the amount of data that's buffered, packets could be dropped if the buffer fills up before the application can read packets from it, while a size that's too large could use more non-pageable operating system memory than is necessary to prevent packets from being dropped.\n• If, when capturing, packets are delivered as soon as they arrive, the application capturing the packets will be woken up for each packet as it arrives, and might have to make one or more calls to the operating system to fetch each packet. If, instead, packets are not delivered as soon as they arrive, but are delivered after a short delay (called a \"packet buffer timeout\"), more than one packet can be accumulated before the packets are delivered, so that a single wakeup would be done for multiple packets, and each set of calls made to the operating system would supply multiple packets, rather than a single packet. This reduces the per-packet CPU overhead if packets are arriving at a high rate, increasing the number of packets per second that can be captured. The packet buffer timeout is required so that an application won't wait for the operating system's capture buffer to fill up before packets are delivered; if packets are arriving slowly, that wait could take an arbitrarily long period of time. Not all platforms support a packet buffer timeout; on platforms that don't, the packet buffer timeout is ignored. A zero value for the timeout, on platforms that support a packet buffer timeout, will cause a read to wait forever to allow enough packets to arrive, with no timeout. A negative value is invalid; the result of setting the timeout to a negative value is unpredictable. NOTE: the packet buffer timeout cannot be used to cause calls that read packets to return within a limited period of time, because, on some platforms, the packet buffer timeout isn't supported, and, on other platforms, the timer doesn't start until at least one packet arrives. This means that the packet buffer timeout should NOT be used, for example, in an interactive application to allow the packet capture loop to 'poll' for user input periodically, as there's no guarantee that a call reading packets will return after the timeout expires even if no packets have arrived. If set to zero or negative, then instead immediate mode is enabled: In immediate mode, packets are always delivered as soon as they arrive, with no buffering.\n• On IEEE 802.11 wireless LANs, even if an adapter is in promiscuous mode, it will supply to the host only frames for the network with which it's associated. It might also supply only data frames, not management or control frames, and might not provide the 802.11 header or radio information pseudo-header for those frames. In \"monitor mode\", sometimes also called \"rfmon mode\" (for \"Radio Frequency MONitor\"), the adapter will supply all frames that it receives, with 802.11 headers, and might supply a pseudo-header with radio information about the frame as well. Note that in monitor mode the adapter might disassociate from the network with which it's associated, so that you will not be able to use any wireless networks with that adapter. This could prevent accessing files on a network server, or resolving host names or network addresses, if you are capturing in monitor mode and are not connected to another network with another adapter.\n• If, when capturing, you capture the entire contents of the packet, that requires more CPU time to copy the packet to your application, more disk and possibly network bandwidth to write the packet data to a file, and more disk space to save the packet. If you don't need the entire contents of the packet - for example, if you are only interested in the TCP headers of packets - you can set the \"snapshot length\" for the capture to an appropriate value. If the snapshot length is set to snaplen, and snaplen is less than the size of a packet that is captured, only the first snaplen bytes of that packet will be captured and provided as packet data. A snapshot length of 65535 should be sufficient, on most if not all networks, to capture all the data available from the packet.\n\nNote that by default opens the interface in promiscuous mode, which generally requires running as root. Unless you are recklessly roaming about as root already, you'll probably want to start your node program like this:\n\nis an that emits a event. The only argument to the callback will be a object containing the raw bytes returned by :\n\nThis contains and ( s) and .\n\nTo convert into a JavaScript object that is easy to work with, decode it:\n\nThe protocol stack is exposed as a nested set of objects. For example, the TCP destination port is part of TCP which is encapsulated within IP, which is encapsulated within a link layer. Each layer is contained within the attribute of the upper layer (or the packet itself):\n\nThis structure is easy to explore with .\n\nHowever, if you decide to parse yourself, make sure to truncate it to the first bytes first.\n\nTCP can be analyzed by feeding the packets into a and then listening for and events.\n\nYou must only send IPv4 TCP packets to the TCP tracker. Explore the object with to see the wonderful things it can do for you. Hopefully the names of the properties are self-explanatory:\n\nSee http_trace for an example of how to use these events to decode HTTP (Works only on node 4).\n\nTo know the format of the link-layer headers, use or . The property is a string, see this list.\n\nTo get current capture statistics, use . This returns an object with the following properties:\n• : number of packets dropped by the network interface or its driver\n• : number of packets dropped because there was no room in the operating system's buffer when they arrived, because packets weren't being read fast enough\n\nFor more info, see .\n\nIf you no longer need to receive packets, you can use .\n\nTo read packets from a file instead of from a live interface, use instead:\n\nWhere only accepts the property.\n\nTSO is a technique that modern operating systems use to offload the burden of IP/TCP header computation to the network hardware. It also reduces the number of times that data is moved data between the kernel and the network hardware. TSO saves CPU when sending data that is larger than a single IP packet.\n\nThis is amazing and wonderful, but it does make some kinds of packet sniffing more difficult. In many cases, it is important to see the exact packets that are sent, but if the network hardware is sending the packets, these are not available to . The solution is to disable TSO.\n\nThe symptoms of needing to disable TSO are messages like, \"Received ACK for packet we didn't see get sent\".\n\nSadly, does not know how to decode IPv6 packets yet. Often when capturing traffic to , IPv6 traffic will arrive surprisingly, even though you were expecting IPv4. A common case is the hostname , which many client programs will resolve to the IPv6 address and then will try . Until we get IPv6 decode support, a filter can be set to only see IPv4 traffic:\n\nThe backslash is important. The pcap filter language has an ambiguity with the word \"tcp\", so by escaping it, you'll get the correct interpretation for this case.\n\nThere are several levels of buffering involved in capturing packets. Sometimes these buffers fill up, and you'll drop packets. If this happens, it becomes difficult to reconstruct higher level protocols. The best way to keep the buffers from filling up is to use pcap filters to only consider traffic that you need to decode. The pcap filters are very efficient and run close to the kernel where they can process high packet rates.\n\nIf the pcap filters are set correctly and still drops packets, you can increase the option. To check if there's any packet loss, you can use as indicated above.\n\nlibpcap may sometimes emit warnings (for instance, when an interface has no address). By default these are printed to the console, but you can override the warning handler with your own function:"
    },
    {
        "link": "https://github.com/wanderview/node-pcap-socket",
        "document": "This module is a pure JavaScript implementation built on top of the pcap-parser module.\n\nHere is an example test case using a recorded HTTP request to verify that the typical node.js hello world server responds correctly.\n\n: // When the server sends back a packet, validate that it makes sense // Supply the pcap socket to the HTTP server as a new connection\n• Only supports IPv4 at the moment.\n• Do something more intelligent with duplicate and out-of-order TCP packets. Currently packets are delivered as they are seen by pcap. No attempt is made to de-duplicate or re-order packets.\n\nThe PcapSocket class inherits from . Therefore it provides both streaming and interfaces.\n\nCalling will return bytes sent to the configured address in the pcap file.\n\nCalling will direct bytes to the stream. This allows your test code to monitor the stream to validate that your code is sending the correct values.\n\nNote, while PcapSocket uses the new streams2 API provided in node 0.9.6 and greater, this class should still work in older versions of node. This backward compatibility is implemented using the readable-stream module.\n• {String | Stream} If a String, pcapSource is interpreted as the name of a pcap file to read from. Otherwise is treated as a stream providing pcap data.\n• {String} An IPv4 address used in the pcap file. The socket will act as that IP address. Packets sent to this address will be available on the socket's method.\n• {Object | null} Optional parameters\n• {Number | null} The TCP port associated with the passed as the second argument. Packets sent to this port at the given address wil be available on the socket's method. If not provided then the port will be automatically set to the port used on the first TCP packet with data.\n• {String | null} The IPv4 address of the remote peer in the pcap file's TCP session. Only packets originating from this address will be available via . If not set, then the address will be automatically configured based on the first TCP packet with data.\n• {Number | null} The TCP port number of the remote pper in the pcap file's TCP session. Only packets originating from this port will be available via . If not set, then port will be automatically configured based on the first TCP packet with data.\n\nThe property provides a stream. All data passed to the function will be directed into this stream. This allows test code to validate that the code using the socket writes out the correct values.\n\nThese properties are provided in order to maintain compatibility with the net.Socket API.\n\nIf the , , or are not set via the constructor options, then they will default to either the address or port . Once a packet is processed they will then represent the selected TCP session addresses and ports.\n\nIf the properties changing is a problem for your code or tests, then make sure to set the addresses and ports via the constructor options.\n\nThese properties are provided in order to maintain compatibility with the net.Socket API. They should work as expected.\n\nThese functions are provided in order to maintain compatibility with the net.Socket API. They are only stubs and effectively do nothing."
    }
]