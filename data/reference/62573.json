[
    {
        "link": "https://docs.python.org/3/faq/programming.html",
        "document": "When a module is imported for the first time (or when the source file has changed since the current compiled file was created) a file containing the compiled code should be created in a subdirectory of the directory containing the file. The file will have a filename that starts with the same name as the file, and ends with , with a middle component that depends on the particular binary that created it. (See PEP 3147 for details.) One reason that a file may not be created is a permissions problem with the directory containing the source file, meaning that the subdirectory cannot be created. This can happen, for example, if you develop as one user but run as another, such as if you are testing with a web server. Unless the environment variable is set, creation of a .pyc file is automatic if you’re importing a module and Python has the ability (permissions, free space, etc…) to create a subdirectory and write the compiled module to that subdirectory. Running Python on a top level script is not considered an import and no will be created. For example, if you have a top-level module that imports another module , when you run (by typing as a shell command), a will be created for because is imported, but no file will be created for since isn’t being imported. If you need to create a file for – that is, to create a file for a module that is not imported – you can, using the and modules. The module can manually compile any module. One way is to use the function in that module interactively: This will write the to a subdirectory in the same location as (or you can override that with the optional parameter ). You can also automatically compile all files in a directory or directories using the module. You can do it from the shell prompt by running and providing the path of a directory containing Python files to compile: How do I find the current module name?¶ A module can find out its own module name by looking at the predefined global variable . If this has the value , the program is running as a script. Many modules that are usually used by importing them also provide a command-line interface or a self-test, and only execute this code after checking : How can I have modules that mutually import each other?¶ Suppose you have the following modules: The problem is that the interpreter will perform the following steps:\n• None imports (which is a no-op since there already is a module named )\n• None The import mechanism tries to read from globals, to set The last step fails, because Python isn’t done with interpreting yet and the global symbol dictionary for is still empty. The same thing happens when you use , and then try to access in global code. There are (at least) three possible workarounds for this problem. Guido van Rossum recommends avoiding all uses of , and placing all code inside functions. Initializations of global variables and class variables should use constants or built-in functions only. This means everything from an imported module is referenced as . Jim Roskind suggests performing steps in the following order in each module:\n• None exports (globals, functions, and classes that don’t need imported base classes)\n• None active code (including globals that are initialized from imported values). Van Rossum doesn’t like this approach much because the imports appear in a strange place, but it does work. Matthias Urlichs recommends restructuring your code so that the recursive import is not necessary in the first place. These solutions are not mutually exclusive. __import__(‘x.y.z’) returns <module ‘x’>; how do I get z?¶ Consider using the convenience function from instead: When I edit an imported module and reimport it, the changes don’t show up. Why does this happen?¶ For reasons of efficiency as well as consistency, Python only reads the module file on the first time a module is imported. If it didn’t, in a program consisting of many modules where each one imports the same basic module, the basic module would be parsed and re-parsed many times. To force re-reading of a changed module, do this: Warning: this technique is not 100% fool-proof. In particular, modules containing statements like will continue to work with the old version of the imported objects. If the module contains class definitions, existing class instances will not be updated to use the new class definition. This can result in the following paradoxical behaviour: # Create an instance of C The nature of the problem is made clear if you print out the “identity” of the class objects:"
    },
    {
        "link": "https://docs.python.org/3/reference/simple_stmts.html",
        "document": "A simple statement is comprised within a single logical line. Several simple statements may occur on a single line separated by semicolons. The syntax for simple statements is:\n\nExpression statements are used (mostly interactively) to compute and write a value, or (usually) to call a procedure (a function that returns no meaningful result; in Python, procedures return the value ). Other uses of expression statements are allowed and occasionally useful. The syntax for an expression statement is: An expression statement evaluates the expression list (which may be a single expression). In interactive mode, if the value is not , it is converted to a string using the built-in function and the resulting string is written to standard output on a line by itself (except if the result is , so that procedure calls do not cause any output.)\n\nAssignment statements are used to (re)bind names to values and to modify attributes or items of mutable objects: An assignment statement evaluates the expression list (remember that this can be a single expression or a comma-separated list, the latter yielding a tuple) and assigns the single resulting object to each of the target lists, from left to right. Assignment is defined recursively depending on the form of the target (list). When a target is part of a mutable object (an attribute reference, subscription or slicing), the mutable object must ultimately perform the assignment and decide about its validity, and may raise an exception if the assignment is unacceptable. The rules observed by various types and the exceptions raised are given with the definition of the object types (see section The standard type hierarchy). Assignment of an object to a target list, optionally enclosed in parentheses or square brackets, is recursively defined as follows.\n• None If the target list is a single target with no trailing comma, optionally in parentheses, the object is assigned to that target.\n• \n• None If the target list contains one target prefixed with an asterisk, called a “starred” target: The object must be an iterable with at least as many items as there are targets in the target list, minus one. The first items of the iterable are assigned, from left to right, to the targets before the starred target. The final items of the iterable are assigned to the targets after the starred target. A list of the remaining items in the iterable is then assigned to the starred target (the list can be empty).\n• None Else: The object must be an iterable with the same number of items as there are targets in the target list, and the items are assigned, from left to right, to the corresponding targets. Assignment of an object to a single target is recursively defined as follows.\n• None If the target is an identifier (name):\n• None If the name does not occur in a or statement in the current code block: the name is bound to the object in the current local namespace.\n• None Otherwise: the name is bound to the object in the global namespace or the outer namespace determined by , respectively. The name is rebound if it was already bound. This may cause the reference count for the object previously bound to the name to reach zero, causing the object to be deallocated and its destructor (if it has one) to be called.\n• None If the target is an attribute reference: The primary expression in the reference is evaluated. It should yield an object with assignable attributes; if this is not the case, is raised. That object is then asked to assign the assigned object to the given attribute; if it cannot perform the assignment, it raises an exception (usually but not necessarily ). Note: If the object is a class instance and the attribute reference occurs on both sides of the assignment operator, the right-hand side expression, can access either an instance attribute or (if no instance attribute exists) a class attribute. The left-hand side target is always set as an instance attribute, creating it if necessary. Thus, the two occurrences of do not necessarily refer to the same attribute: if the right-hand side expression refers to a class attribute, the left-hand side creates a new instance attribute as the target of the assignment: This description does not necessarily apply to descriptor attributes, such as properties created with .\n• None If the target is a subscription: The primary expression in the reference is evaluated. It should yield either a mutable sequence object (such as a list) or a mapping object (such as a dictionary). Next, the subscript expression is evaluated. If the primary is a mutable sequence object (such as a list), the subscript must yield an integer. If it is negative, the sequence’s length is added to it. The resulting value must be a nonnegative integer less than the sequence’s length, and the sequence is asked to assign the assigned object to its item with that index. If the index is out of range, is raised (assignment to a subscripted sequence cannot add new items to a list). If the primary is a mapping object (such as a dictionary), the subscript must have a type compatible with the mapping’s key type, and the mapping is then asked to create a key/value pair which maps the subscript to the assigned object. This can either replace an existing key/value pair with the same key value, or insert a new key/value pair (if no key with the same value existed). For user-defined objects, the method is called with appropriate arguments.\n• None If the target is a slicing: The primary expression in the reference is evaluated. It should yield a mutable sequence object (such as a list). The assigned object should be a sequence object of the same type. Next, the lower and upper bound expressions are evaluated, insofar they are present; defaults are zero and the sequence’s length. The bounds should evaluate to integers. If either bound is negative, the sequence’s length is added to it. The resulting bounds are clipped to lie between zero and the sequence’s length, inclusive. Finally, the sequence object is asked to replace the slice with the items of the assigned sequence. The length of the slice may be different from the length of the assigned sequence, thus changing the length of the target sequence, if the target sequence allows it. CPython implementation detail: In the current implementation, the syntax for targets is taken to be the same as for expressions, and invalid syntax is rejected during the code generation phase, causing less detailed error messages. Although the definition of assignment implies that overlaps between the left-hand side and the right-hand side are ‘simultaneous’ (for example swaps two variables), overlaps within the collection of assigned-to variables occur left-to-right, sometimes resulting in confusion. For instance, the following program prints : # i is updated, then x[i] is updated The specification for the feature. Augmented assignment is the combination, in a single statement, of a binary operation and an assignment statement: An augmented assignment evaluates the target (which, unlike normal assignment statements, cannot be an unpacking) and the expression list, performs the binary operation specific to the type of assignment on the two operands, and assigns the result to the original target. The target is only evaluated once. An augmented assignment statement like can be rewritten as to achieve a similar, but not exactly equal effect. In the augmented version, is only evaluated once. Also, when possible, the actual operation is performed in-place, meaning that rather than creating a new object and assigning that to the target, the old object is modified instead. Unlike normal assignments, augmented assignments evaluate the left-hand side before evaluating the right-hand side. For example, first looks-up , then it evaluates and performs the addition, and lastly, it writes the result back to . With the exception of assigning to tuples and multiple targets in a single statement, the assignment done by augmented assignment statements is handled the same way as normal assignments. Similarly, with the exception of the possible in-place behavior, the binary operation performed by augmented assignment is the same as the normal binary operations. For targets which are attribute references, the same caveat about class and instance attributes applies as for regular assignments. Annotation assignment is the combination, in a single statement, of a variable or attribute annotation and an optional assignment statement: The difference from normal Assignment statements is that only a single target is allowed. The assignment target is considered “simple” if it consists of a single name that is not enclosed in parentheses. For simple assignment targets, if in class or module scope, the annotations are evaluated and stored in a special class or module attribute that is a dictionary mapping from variable names (mangled if private) to evaluated annotations. This attribute is writable and is automatically created at the start of class or module body execution, if annotations are found statically. If the assignment target is not simple (an attribute, subscript node, or parenthesized name), the annotation is evaluated if in class or module scope, but not stored. If a name is annotated in a function scope, then this name is local for that scope. Annotations are never evaluated and stored in function scopes. If the right hand side is present, an annotated assignment performs the actual assignment before evaluating annotations (where applicable). If the right hand side is not present for an expression target, then the interpreter evaluates the target except for the last or call. The proposal that added syntax for annotating the types of variables (including class variables and instance variables), instead of expressing them through comments. The proposal that added the module to provide a standard syntax for type annotations that can be used in static analysis tools and IDEs. Changed in version 3.8: Now annotated assignments allow the same expressions in the right hand side as regular assignments. Previously, some expressions (like un-parenthesized tuple expressions) caused a syntax error.\n\nIf no expressions are present, re-raises the exception that is currently being handled, which is also known as the active exception. If there isn’t currently an active exception, a exception is raised indicating that this is an error. Otherwise, evaluates the first expression as the exception object. It must be either a subclass or an instance of . If it is a class, the exception instance will be obtained when needed by instantiating the class with no arguments. The type of the exception is the exception instance’s class, the value is the instance itself. A traceback object is normally created automatically when an exception is raised and attached to it as the attribute. You can create an exception and set your own traceback in one step using the exception method (which returns the same exception instance, with its traceback set to its argument), like so: The clause is used for exception chaining: if given, the second expression must be another exception class or instance. If the second expression is an exception instance, it will be attached to the raised exception as the attribute (which is writable). If the expression is an exception class, the class will be instantiated and the resulting exception instance will be attached to the raised exception as the attribute. If the raised exception is not handled, both exceptions will be printed: File , line , in : The above exception was the direct cause of the following exception: File , line , in : A similar mechanism works implicitly if a new exception is raised when an exception is already being handled. An exception may be handled when an or clause, or a statement, is used. The previous exception is then attached as the new exception’s attribute: File , line , in : During handling of the above exception, another exception occurred: File , line , in : Exception chaining can be explicitly suppressed by specifying in the clause: Additional information on exceptions can be found in section Exceptions, and information about handling exceptions is in section The try statement. Changed in version 3.3: is now permitted as in . Added the attribute to suppress automatic display of the exception context. Changed in version 3.11: If the traceback of the active exception is modified in an clause, a subsequent statement re-raises the exception with the modified traceback. Previously, the exception was re-raised with the traceback it had when it was caught.\n\nimport_stmt ::= \"import\" [\"as\" ] (\",\" [\"as\" ])* | \"from\" \"import\" [\"as\" ] (\",\" [\"as\" ])* | \"from\" \"import\" \"(\" [\"as\" ] (\",\" [\"as\" ])* [\",\"] \")\" | \"from\" \"import\" \"*\" module ::= ( \".\")* relative_module ::= \".\"* | \".\"+ The basic import statement (no clause) is executed in two steps:\n• None find a module, loading and initializing it if necessary\n• None define a name or names in the local namespace for the scope where the statement occurs. When the statement contains multiple clauses (separated by commas) the two steps are carried out separately for each clause, just as though the clauses had been separated out into individual import statements. The details of the first step, finding and loading modules, are described in greater detail in the section on the import system, which also describes the various types of packages and modules that can be imported, as well as all the hooks that can be used to customize the import system. Note that failures in this step may indicate either that the module could not be located, or that an error occurred while initializing the module, which includes execution of the module’s code. If the requested module is retrieved successfully, it will be made available in the local namespace in one of three ways:\n• None If the module name is followed by , then the name following is bound directly to the imported module.\n• None If no other name is specified, and the module being imported is a top level module, the module’s name is bound in the local namespace as a reference to the imported module\n• None If the module being imported is not a top level module, then the name of the top level package that contains the module is bound in the local namespace as a reference to the top level package. The imported module must be accessed using its full qualified name rather than directly The form uses a slightly more complex process:\n• None find the module specified in the clause, loading and initializing it if necessary;\n• None for each of the identifiers specified in the clauses:\n• None check if the imported module has an attribute by that name\n• None if not, attempt to import a submodule with that name and then check the imported module again for that attribute\n• None if the attribute is not found, is raised.\n• None otherwise, a reference to that value is stored in the local namespace, using the name in the clause if it is present, otherwise using the attribute name If the list of identifiers is replaced by a star ( ), all public names defined in the module are bound in the local namespace for the scope where the statement occurs. The public names defined by a module are determined by checking the module’s namespace for a variable named ; if defined, it must be a sequence of strings which are names defined or imported by that module. The names given in are all considered public and are required to exist. If is not defined, the set of public names includes all names found in the module’s namespace which do not begin with an underscore character ( ). should contain the entire public API. It is intended to avoid accidentally exporting items that are not part of the API (such as library modules which were imported and used within the module). The wild card form of import — — is only allowed at the module level. Attempting to use it in class or function definitions will raise a . When specifying what module to import you do not have to specify the absolute name of the module. When a module or package is contained within another package it is possible to make a relative import within the same top package without having to mention the package name. By using leading dots in the specified module or package after you can specify how high to traverse up the current package hierarchy without specifying exact names. One leading dot means the current package where the module making the import exists. Two dots means up one package level. Three dots is up two levels, etc. So if you execute from a module in the package then you will end up importing . If you execute from within you will import . The specification for relative imports is contained in the Package Relative Imports section. is provided to support applications that determine dynamically the modules to be loaded. A future statement is a directive to the compiler that a particular module should be compiled using syntax or semantics that will be available in a specified future release of Python where the feature becomes standard. The future statement is intended to ease migration to future versions of Python that introduce incompatible changes to the language. It allows use of the new features on a per-module basis before the release in which the feature becomes standard. future_stmt ::= \"from\" \"__future__\" \"import\" [\"as\" ] (\",\" [\"as\" ])* | \"from\" \"__future__\" \"import\" \"(\" [\"as\" ] (\",\" [\"as\" ])* [\",\"] \")\" feature ::= A future statement must appear near the top of the module. The only lines that can appear before a future statement are:\n• None the module docstring (if any), The only feature that requires using the future statement is (see PEP 563). All historical features enabled by the future statement are still recognized by Python 3. The list includes , , , , , , and . They are all redundant because they are always enabled, and only kept for backwards compatibility. A future statement is recognized and treated specially at compile time: Changes to the semantics of core constructs are often implemented by generating different code. It may even be the case that a new feature introduces new incompatible syntax (such as a new reserved word), in which case the compiler may need to parse the module differently. Such decisions cannot be pushed off until runtime. For any given release, the compiler knows which feature names have been defined, and raises a compile-time error if a future statement contains a feature not known to it. The direct runtime semantics are the same as for any import statement: there is a standard module , described later, and it will be imported in the usual way at the time the future statement is executed. The interesting runtime semantics depend on the specific feature enabled by the future statement. Note that there is nothing special about the statement: That is not a future statement; it’s an ordinary import statement with no special semantics or syntax restrictions. Code compiled by calls to the built-in functions and that occur in a module containing a future statement will, by default, use the new syntax or semantics associated with the future statement. This can be controlled by optional arguments to — see the documentation of that function for details. A future statement typed at an interactive interpreter prompt will take effect for the rest of the interpreter session. If an interpreter is started with the option, is passed a script name to execute, and the script includes a future statement, it will be in effect in the interactive session started after the script is executed. The original proposal for the __future__ mechanism."
    },
    {
        "link": "https://uvm.edu/~cbcafier/cs1210/supplemental/global_keyword.html",
        "document": ""
    },
    {
        "link": "https://docs.python.org/3/library/functions.html",
        "document": "The Python interpreter has a number of functions and types built into it that are always available. They are listed here in alphabetical order.\n\nOpen file and return a corresponding file object. If the file cannot be opened, an is raised. See Reading and Writing Files for more examples of how to use this function. file is a path-like object giving the pathname (absolute or relative to the current working directory) of the file to be opened or an integer file descriptor of the file to be wrapped. (If a file descriptor is given, it is closed when the returned I/O object is closed unless closefd is set to .) mode is an optional string that specifies the mode in which the file is opened. It defaults to which means open for reading in text mode. Other common values are for writing (truncating the file if it already exists), for exclusive creation, and for appending (which on some Unix systems, means that all writes append to the end of the file regardless of the current seek position). In text mode, if encoding is not specified the encoding used is platform-dependent: is called to get the current locale encoding. (For reading and writing raw bytes use binary mode and leave encoding unspecified.) The available modes are: open for writing, truncating the file first open for exclusive creation, failing if the file already exists open for writing, appending to the end of file if it exists The default mode is (open for reading text, a synonym of ). Modes and open and truncate the file. Modes and open the file with no truncation. As mentioned in the Overview, Python distinguishes between binary and text I/O. Files opened in binary mode (including in the mode argument) return contents as objects without any decoding. In text mode (the default, or when is included in the mode argument), the contents of the file are returned as , the bytes having been first decoded using a platform-dependent encoding or using the specified encoding if given. Python doesn’t depend on the underlying operating system’s notion of text files; all the processing is done by Python itself, and is therefore platform-independent. buffering is an optional integer used to set the buffering policy. Pass 0 to switch buffering off (only allowed in binary mode), 1 to select line buffering (only usable when writing in text mode), and an integer > 1 to indicate the size in bytes of a fixed-size chunk buffer. Note that specifying a buffer size this way applies for binary buffered I/O, but (i.e., files opened with ) would have another buffering. To disable buffering in , consider using the flag for . When no buffering argument is given, the default buffering policy works as follows:\n• None Binary files are buffered in fixed-size chunks; the size of the buffer is chosen using a heuristic trying to determine the underlying device’s “block size” and falling back on . On many systems, the buffer will typically be 4096 or 8192 bytes long.\n• None “Interactive” text files (files for which returns ) use line buffering. Other text files use the policy described above for binary files. encoding is the name of the encoding used to decode or encode the file. This should only be used in text mode. The default encoding is platform dependent (whatever returns), but any text encoding supported by Python can be used. See the module for the list of supported encodings. errors is an optional string that specifies how encoding and decoding errors are to be handled—this cannot be used in binary mode. A variety of standard error handlers are available (listed under Error Handlers), though any error handling name that has been registered with is also valid. The standard names include:\n• None to raise a exception if there is an encoding error. The default value of has the same effect.\n• None ignores errors. Note that ignoring encoding errors can lead to data loss.\n• None causes a replacement marker (such as ) to be inserted where there is malformed data.\n• None will represent any incorrect bytes as low surrogate code units ranging from U+DC80 to U+DCFF. These surrogate code units will then be turned back into the same bytes when the error handler is used when writing data. This is useful for processing files in an unknown encoding.\n• None is only supported when writing to a file. Characters not supported by the encoding are replaced with the appropriate XML character reference .\n• None (also only supported when writing) replaces unsupported characters with escape sequences. newline determines how to parse newline characters from the stream. It can be , , , , and . It works as follows:\n• None When reading input from the stream, if newline is , universal newlines mode is enabled. Lines in the input can end in , , or , and these are translated into before being returned to the caller. If it is , universal newlines mode is enabled, but line endings are returned to the caller untranslated. If it has any of the other legal values, input lines are only terminated by the given string, and the line ending is returned to the caller untranslated.\n• None When writing output to the stream, if newline is , any characters written are translated to the system default line separator, . If newline is or , no translation takes place. If newline is any of the other legal values, any characters written are translated to the given string. If closefd is and a file descriptor rather than a filename was given, the underlying file descriptor will be kept open when the file is closed. If a filename is given closefd must be (the default); otherwise, an error will be raised. A custom opener can be used by passing a callable as opener. The underlying file descriptor for the file object is then obtained by calling opener with (file, flags). opener must return an open file descriptor (passing as opener results in functionality similar to passing ). The following example uses the dir_fd parameter of the function to open a file relative to a given directory: 'This will be written to somedir/spamspam.txt' The type of file object returned by the function depends on the mode. When is used to open a file in a text mode ( , , , , etc.), it returns a subclass of (specifically ). When used to open a file in a binary mode with buffering, the returned class is a subclass of . The exact class varies: in read binary mode, it returns an ; in write binary and append binary modes, it returns an , and in read/write mode, it returns an . When buffering is disabled, the raw stream, a subclass of , , is returned. See also the file handling modules, such as , (where is declared), , , , and . The and arguments may have been modified or inferred from the original call.\n• None used to be raised, it is now an alias of .\n• None is now raised if the file opened in exclusive creation mode ( ) already exists.\n• None The file is now non-inheritable.\n• None If the system call is interrupted and the signal handler does not raise an exception, the function now retries the system call instead of raising an exception (see PEP 475 for the rationale).\n• None On Windows, opening a console buffer may return a subclass of other than . Changed in version 3.11: The mode has been removed.\n\nReturn a proxy object that delegates method calls to a parent or sibling class of type. This is useful for accessing inherited methods that have been overridden in a class. The object_or_type determines the method resolution order to be searched. The search starts from the class right after the type. For example, if of object_or_type is and the value of type is , then searches . The attribute of the class corresponding to object_or_type lists the method resolution search order used by both and . The attribute is dynamic and can change whenever the inheritance hierarchy is updated. If the second argument is omitted, the super object returned is unbound. If the second argument is an object, must be true. If the second argument is a type, must be true (this is useful for classmethods). When called directly within an ordinary method of a class, both arguments may be omitted (“zero-argument ”). In this case, type will be the enclosing class, and obj will be the first argument of the immediately enclosing function (typically ). (This means that zero-argument will not work as expected within nested functions, including generator expressions, which implicitly create nested functions.) There are two typical use cases for super. In a class hierarchy with single inheritance, super can be used to refer to parent classes without naming them explicitly, thus making the code more maintainable. This use closely parallels the use of super in other programming languages. The second use case is to support cooperative multiple inheritance in a dynamic execution environment. This use case is unique to Python and is not found in statically compiled languages or languages that only support single inheritance. This makes it possible to implement “diamond diagrams” where multiple base classes implement the same method. Good design dictates that such implementations have the same calling signature in every case (because the order of calls is determined at runtime, because that order adapts to changes in the class hierarchy, and because that order can include sibling classes that are unknown prior to runtime). For both use cases, a typical superclass call looks like this: # This does the same thing as: In addition to method lookups, also works for attribute lookups. One possible use case for this is calling descriptors in a parent or sibling class. Note that is implemented as part of the binding process for explicit dotted attribute lookups such as . It does so by implementing its own method for searching classes in a predictable order that supports cooperative multiple inheritance. Accordingly, is undefined for implicit lookups using statements or operators such as . Also note that, aside from the zero argument form, is not limited to use inside methods. The two argument form specifies the arguments exactly and makes the appropriate references. The zero argument form only works inside a class definition, as the compiler fills in the necessary details to correctly retrieve the class being defined, as well as accessing the current instance for ordinary methods. For practical suggestions on how to design cooperative classes using , see guide to using super()."
    },
    {
        "link": "https://geeksforgeeks.org/global-keyword-in-python",
        "document": "The global keyword in Python allows a function to modify variables that are defined outside its scope, making them accessible globally. Without it, variables inside a function are treated as local by default. It’s commonly used when we need to update the value of a global variable within a function, ensuring the changes persist outside the function.\n\nExplanation: This code uses the global keyword inside the function to modify the global variable x. By calling fun(), the global x is updated to 20 .\n\nExamples of using the global keyword\n\nExplanation: In this example, the global variables a and b are accessed inside the function without needing the global keyword because we are just referencing them.\n\nExample 2: Modifying Global Variable From Inside the Function\n\nExplanation: Here, Python assumes a is a local variable inside the function since we try to assign a value to it. To modify the global a, we need to use the global keyword.\n\nExplanation: In this example, we first define x as a global keyword inside the function change(). The value of x is then incremented by 5, i.e. x=x+5 and hence we get the output as 20. As we can see by changing the value inside the function change(), the change is also reflected in the value outside the global variable.\n\nUnlike immutable objects (e.g., integers, strings), mutable objects (e.g., lists, dictionaries) can be modified without needing the global keyword.\n\nExample 1: Modifying list elements without using global keyword.\n\nHere, we can modify list elements defined in global scope without using global keyword. Because we are not modifying the object associated with the variable a, but we are modifying the items the list contains. Since lists are mutable data structures, thus we can modify its contents.\n\nHere we are trying to assign a new list to the global variable. Thus, we need to use the global keyword as a new object is created. Here, if we don’t use the global keyword, then a new local variable a will be created with the new list elements. But the global variable arr will be unchanged.\n\nglobal keyword is also useful when we need to share global variables between different Python modules. We can define a separate configuration module to hold global variables and import them into other modules.\n\nExplanation : In this example, the variables x, y, and z are defined in config.py, modified in modify.py, and then accessed in main.py. This is an efficient way to share global variables across different modules.\n\nIn order to use global inside a nested function, we have to declare a variable with a global keyword inside a nested function\n\nExplanation: In this example, the outer function add has a local variable x. The nested function change modifies the global x. The changes to x are reflected outside the function."
    },
    {
        "link": "https://stackoverflow.com/questions/69792108/how-do-i-use-the-python-keyboard-module-to-detect-a-key-press",
        "document": "There are usually many different ways to code something. Some are better than others. In a problem that is based on keyboard input, like your cash register/adding machine project, I would go with an event-driven approach. Your sample code represents a polling approach. It can work, but it may not be as efficient.\n\nI've never used the keyboard module before, but I did some quick research and came up with the below program, which may give you guidance. Every time a key in the keyboard is pressed, the routine is triggered. Digits are stored, and the Enter key causes an addition and then clearing of the stored digits."
    },
    {
        "link": "https://stackoverflow.com/questions/74326247/how-to-detect-keypress-in-python-using-keyboard-module",
        "document": "I am making a program in python to detect what key is pressed and based on my keyboard it will make a decision.\n\nI want to implement it using keyboard module in python.\n\nI would do something like this,\n\nBut it doesn't work. When I execute this program, I have to press s twice to execute the \"s\" block.\n\nAlso, I have a problem that is after the execution is finished, it writes all the keys in my command prompt is it possible to fix that?"
    },
    {
        "link": "https://pypi.org/project/keyboard",
        "document": "A required part of this site couldn’t load. This may be due to a browser extension, network issues, or browser settings. Please check your connection, disable any ad blockers, or try using a different browser."
    },
    {
        "link": "https://pynput.readthedocs.io/en/latest/keyboard.html",
        "document": "The package contains classes for controlling and monitoring the keyboard.\n\nUse like this: A keyboard listener is a , and all callbacks will be invoked from the thread. Call from anywhere, raise or return from a callback to stop the listener. The parameter passed to callbacks is a , for special keys, a for normal alphanumeric keys, or just for unknown keys. When using the non-blocking version above, the current thread will continue executing. This might be necessary when integrating with other GUI frameworks that incorporate a main-loop, but when run from a script, this will cause the program to terminate immediately. The listener callbacks are invoked directly from an operating thread on some platforms, notably Windows. This means that long running procedures and blocking operations should not be invoked from the callback, as this risks freezing input for all processes. A possible workaround is to just dispatch incoming messages to a queue, and let a separate thread handle them. If a callback handler raises an exception, the listener will be stopped. Since callbacks run in a dedicated thread, the exceptions will not automatically be reraised. To be notified about callback errors, call on the listener instance: Once has been called, the listener cannot be restarted, since listeners are instances of . If your application requires toggling listening events, you must either add an internal flag to ignore events when not required, or create a new listener when resuming listening. To simplify scripting, synchronous event listening is supported through the utility class . This class supports reading single events in a non-blocking fashion, as well as iterating over all events. To read a single event, use the following code: # The event listener will be running in this block # Block at most one second 'You did not press a key within one second' To iterate over keyboard events, use the following code: # The event listener will be running in this block Please note that the iterator method does not support non-blocking operation, so it will wait for at least one keyboard event. The events will be instances of the inner classes found in . A common use case for keyboard monitors is reacting to global hotkeys. Since a listener does not maintain any state, hotkeys involving multiple keys must store this state somewhere. pynput provides the class for this purpose. It contains two methods to update the state, designed to be easily interoperable with a keyboard listener: and which can be directly passed as listener callbacks. The intended usage is as follows: This will create a hotkey, and then use a listener to update its state. Once all the specified keys are pressed simultaneously, will be invoked. Note that keys are passed through before being passed to the instance. This is to remove any modifier state from the key events, and to normalise modifiers with more than one physical button. The method is a convenience function to transform shortcut strings to key collections. Please see its documentation for more information. To register a number of global hotkeys, use the convenience class :\n\nA controller for sending virtual keyboard events to the system. The exception raised when an invalid character is encountered in the string passed to . Its first argument is the index of the character in the string, and the second the character. The exception raised when an invalid parameter is passed to either or . Its first argument is the parameter. Please note that this reflects only the internal state of this controller. See for more information. Whether any alt key is pressed. Please note that this reflects only the internal state of this controller. See for more information. Whether any ctrl key is pressed. Please note that this reflects only the internal state of this controller. See for more information. Please note that this reflects only the internal state of this controller, and not the state of the operating system keyboard buffer. This property cannot be used to determine whether a key is physically pressed. Only the generic modifiers will be set; when pressing either , or , only will be present. Use this property within a context block thus: This ensures that the modifiers cannot be modified by another thread. A key may be either a string of length 1, one of the members or a . Strings will be transformed to using . Members of will be translated to their .\n• InvalidKeyException – if the key is invalid\n• ValueError – if is a string, but its length is not keys – The keys to keep pressed. A key may be either a string of length 1, one of the members or a . Strings will be transformed to using . Members of will be translated to their . key – The key to release. If this is a string, it is passed to and the returned releases are used.\n• InvalidKeyException – if the key is invalid\n• ValueError – if is a string, but its length is not Whether any shift key is pressed, or caps lock is toggled. Please note that this reflects only the internal state of this controller. See for more information. This is equivalent to the following code:\n• InvalidKeyException – if the key is invalid\n• ValueError – if is a string, but its length is not Calls either or depending on the value of .\n• key – The key to press or release.\n• is_press (bool) – Whether to press the key. InvalidKeyException – if the key is invalid This method will send all key presses and releases necessary to type all characters in the string. InvalidCharacterException – if an untypable character is encountered Instances of this class can be used as context managers. This is equivalent to the following code: This class inherits from and supports all its methods. It will set to when created.\n• on_press (callable) – The callback to call when a button is pressed. It will be called with the argument , where is a , a or if the key is unknown.\n• on_release (callable) – The callback to call when a button is released. It will be called with the argument , where is a , a or if the key is unknown.\n• suppress (bool) – Whether to suppress events. Setting this to will prevent the input events from being passed to the rest of the system.\n• kwargs – Any non-standard platform dependent options. These should be prefixed with the platform name thus: , , or . A callable taking the arguments , where is or , and is a . This callable can freely modify the event using functions like . If this callable does not return the event, the event is suppressed system wide. A list of device paths. If this is specified, pynput will limit the number of devices checked for the capabilities needed to those passed, otherwise all system devices will be used. Passing this might be required if an incorrect device is chosen. A callable taking the arguments , where is the current message, and associated data as a KBDLLHOOKSTRUCT. If this callback returns , the event will not be propagated to the listener callback. If is called, the event is suppressed system wide. This constructor should always be called with keyword arguments. Arguments are: group should be None; reserved for future extension when a ThreadGroup class is implemented. target is the callable object to be invoked by the run() method. Defaults to None, meaning nothing is called. name is the thread name. By default, a unique name is constructed of the form “Thread-N” where N is a small decimal number. args is the argument tuple for the target invocation. Defaults to (). kwargs is a dictionary of keyword arguments for the target invocation. Defaults to {}. If a subclass overrides the constructor, it must make sure to invoke the base class constructor (Thread.__init__()) before doing anything else to the thread. Whether the listener is currently running. It must be called at most once per thread object. It arranges for the object’s run() method to be invoked in a separate thread of control. This method will raise a RuntimeError if called more than once on the same thread object. When this method returns, no more events will be delivered. Once this method has been called, the listener instance cannot be used any more, since a listener is a , and once stopped it cannot be restarted. To resume listening for event, a new listener must be created. Waits for this listener to become ready. A class representing various buttons that may not correspond to letters. This includes modifier keys and function keys. The actual values for these items differ between platforms. Some platforms may have additional buttons, but these are guaranteed to be present everywhere. The AltGr key. This is a modifier. The left Alt key. This is a modifier. The right Alt key. This is a modifier. A generic command button. On PC platforms, this corresponds to the Super key or Windows key, and on Mac it corresponds to the Command key. This may be a modifier. The left command button. On PC platforms, this corresponds to the Super key or Windows key, and on Mac it corresponds to the Command key. This may be a modifier. The right command button. On PC platforms, this corresponds to the Super key or Windows key, and on Mac it corresponds to the Command key. This may be a modifier. The left Ctrl key. This is a modifier. The right Ctrl key. This is a modifier. The function keys. F1 to F20 are defined. The Insert key. This may be undefined for some platforms. The Menu key. This may be undefined for some platforms. The NumLock key. This may be undefined for some platforms. The Pause/Break key. This may be undefined for some platforms. The PrintScreen key. This may be undefined for some platforms. The ScrollLock key. This may be undefined for some platforms. The left Shift key. This is a modifier. The right Shift key. This is a modifier. A represents the description of a key code used by the operating system. char – The dead key. This should be the unicode character representing the stand alone character, such as for COMBINING TILDE.\n• kwargs – Any other parameters to pass. Applies this dead key to another key and returns the result. Joining a dead key with space ( ) or itself yields the non-dead version of this key, if one exists; for example, equals and . key (KeyCode) – The key to join with this key. ValueError – if the keys cannot be joined"
    },
    {
        "link": "https://playwright.dev/python/docs/api/class-keyboard",
        "document": "Keyboard provides an api for managing a virtual keyboard. The high level api is keyboard.type(), which takes raw characters and generates proper , / , and events on your page.\n\nFor finer control, you can use keyboard.down(), keyboard.up(), and keyboard.insert_text() to manually fire events as if they were generated from a real keyboard.\n\nAn example of holding down in order to select and delete some text:\n\nAn example of pressing uppercase\n\nAn example to trigger select-all with the keyboard\n\nkey can specify the intended keyboardEvent.key value or a single character to generate the text for. A superset of the key values can be found here. Examples of the keys are:\n\nFollowing modification shortcuts are also supported: , , , , , . resolves to on Windows and Linux and to on macOS.\n\nHolding down will type the text that corresponds to the key in the upper case.\n\nIf key is a single character, it is case-sensitive, so the values and will generate different respective texts.\n\nIf key is a modifier key, , , , or , subsequent key presses will be sent with that modifier active. To release the modifier key, use keyboard.up().\n\nAfter the key is pressed once, subsequent calls to keyboard.down() will have repeat set to true. To release the key, use keyboard.up().\n• Name of the key to press or a character to generate, such as or .\n\nDispatches only event, does not emit the , or events.\n• Sets input to the specified text value.\n\nkey can specify the intended keyboardEvent.key value or a single character to generate the text for. A superset of the key values can be found here. Examples of the keys are:\n\nFollowing modification shortcuts are also supported: , , , , , . resolves to on Windows and Linux and to on macOS.\n\nHolding down will type the text that corresponds to the key in the upper case.\n\nIf key is a single character, it is case-sensitive, so the values and will generate different respective texts.\n\nShortcuts such as , or are supported as well. When specified with the modifier, modifier is pressed and being held while the subsequent key is being pressed.\n• Name of the key to press or a character to generate, such as or .\n• Time to wait between and in milliseconds. Defaults to 0.\n\nSends a , / , and event for each character in the text.\n\nTo press a special key, like or , use keyboard.press().\n• Time to wait between key presses in milliseconds. Defaults to 0.\n• Name of the key to press or a character to generate, such as or ."
    },
    {
        "link": "https://docs.python.org/3/library/random.html",
        "document": "This module implements pseudo-random number generators for various distributions.\n\nFor integers, there is uniform selection from a range. For sequences, there is uniform selection of a random element, a function to generate a random permutation of a list in-place, and a function for random sampling without replacement.\n\nOn the real line, there are functions to compute uniform, normal (Gaussian), lognormal, negative exponential, gamma, and beta distributions. For generating distributions of angles, the von Mises distribution is available.\n\nAlmost all module functions depend on the basic function , which generates a random float uniformly in the half-open range . Python uses the Mersenne Twister as the core generator. It produces 53-bit precision floats and has a period of 2**19937-1. The underlying implementation in C is both fast and threadsafe. The Mersenne Twister is one of the most extensively tested random number generators in existence. However, being completely deterministic, it is not suitable for all purposes, and is completely unsuitable for cryptographic purposes.\n\nThe functions supplied by this module are actually bound methods of a hidden instance of the class. You can instantiate your own instances of to get generators that don’t share state.\n\nClass can also be subclassed if you want to use a different basic generator of your own devising: see the documentation on that class for more details.\n\nThe module also provides the class which uses the system function to generate random numbers from sources provided by the operating system.\n\nReturn a random element from the non-empty sequence seq. If seq is empty, raises . Return a k sized list of elements chosen from the population with replacement. If the population is empty, raises . If a weights sequence is specified, selections are made according to the relative weights. Alternatively, if a cum_weights sequence is given, the selections are made according to the cumulative weights (perhaps computed using ). For example, the relative weights are equivalent to the cumulative weights . Internally, the relative weights are converted to cumulative weights before making selections, so supplying the cumulative weights saves work. If neither weights nor cum_weights are specified, selections are made with equal probability. If a weights sequence is supplied, it must be the same length as the population sequence. It is a to specify both weights and cum_weights. The weights or cum_weights can use any numeric type that interoperates with the values returned by (that includes integers, floats, and fractions but excludes decimals). Weights are assumed to be non-negative and finite. A is raised if all weights are zero. For a given seed, the function with equal weighting typically produces a different sequence than repeated calls to . The algorithm used by uses floating-point arithmetic for internal consistency and speed. The algorithm used by defaults to integer arithmetic with repeated selections to avoid small biases from round-off error. Changed in version 3.9: Raises a if all weights are zero. To shuffle an immutable sequence and return a new shuffled list, use instead. Note that even for small , the total number of permutations of x can quickly grow larger than the period of most random number generators. This implies that most permutations of a long sequence can never be generated. For example, a sequence of length 2080 is the largest that can fit within the period of the Mersenne Twister random number generator. Return a k length list of unique elements chosen from the population sequence. Used for random sampling without replacement. Returns a new list containing elements from the population while leaving the original population unchanged. The resulting list is in selection order so that all sub-slices will also be valid random samples. This allows raffle winners (the sample) to be partitioned into grand prize and second place winners (the subslices). Members of the population need not be hashable or unique. If the population contains repeats, then each occurrence is a possible selection in the sample. Repeated elements can be specified one at a time or with the optional keyword-only counts parameter. For example, is equivalent to . To choose a sample from a range of integers, use a object as an argument. This is especially fast and space efficient for sampling from a large population: . If the sample size is larger than the population size, a is raised. Changed in version 3.11: The population must be a sequence. Automatic conversion of sets to lists is no longer supported.\n\nThe following functions generate specific real-valued distributions. Function parameters are named after the corresponding variables in the distribution’s equation, as used in common mathematical practice; most of these equations can be found in any statistics text. Return the next random floating-point number in the range Return a random floating-point number N such that for and for . The end-point value may or may not be included in the range depending on floating-point rounding in the expression . Return a random floating-point number N such that and with the specified mode between those bounds. The low and high bounds default to zero and one. The mode argument defaults to the midpoint between the bounds, giving a symmetric distribution. Beta distribution. Conditions on the parameters are and . Returned values range between 0 and 1. Exponential distribution. lambd is 1.0 divided by the desired mean. It should be nonzero. (The parameter would be called “lambda”, but that is a reserved word in Python.) Returned values range from 0 to positive infinity if lambd is positive, and from negative infinity to 0 if lambd is negative. Changed in version 3.12: Added the default value for . Gamma distribution. (Not the gamma function!) The shape and scale parameters, alpha and beta, must have positive values. (Calling conventions vary and some sources define ‘beta’ as the inverse of the scale). Normal distribution, also called the Gaussian distribution. mu is the mean, and sigma is the standard deviation. This is slightly faster than the function defined below. Multithreading note: When two threads call this function simultaneously, it is possible that they will receive the same return value. This can be avoided in three ways. 1) Have each thread use a different instance of the random number generator. 2) Put locks around all calls. 3) Use the slower, but thread-safe function instead. Changed in version 3.11: mu and sigma now have default arguments. Log normal distribution. If you take the natural logarithm of this distribution, you’ll get a normal distribution with mean mu and standard deviation sigma. mu can have any value, and sigma must be greater than zero. Normal distribution. mu is the mean, and sigma is the standard deviation. Changed in version 3.11: mu and sigma now have default arguments. mu is the mean angle, expressed in radians between 0 and 2*pi, and kappa is the concentration parameter, which must be greater than or equal to zero. If kappa is equal to zero, this distribution reduces to a uniform random angle over the range 0 to 2*pi. Weibull distribution. alpha is the scale parameter and beta is the shape parameter.\n\n# Even integer from 0 to 100 inclusive ['four', 'two', 'ace', 'three'] # of 52 playing cards, and determine the proportion of cards # Estimate the probability of getting 5 or more heads from 7 spins # of a biased coin that settles on heads 60% of the time. # Probability of the median of 5 samples being in middle two quartiles Example of statistical bootstrapping using resampling with replacement to estimate a confidence interval for the mean of a sample: Example of a resampling permutation test to determine the statistical significance or p-value of an observed difference between the effects of a drug versus a placebo: # Example from \"Statistics is Easy\" by Dennis Shasha and Manda Wilson 'at least as extreme as the observed difference of leads us to reject the null' 'hypothesis that there is no difference between the drug and the placebo.' Simulation of arrival times and service deliveries for a multiserver queue: # time when each server becomes available Statistics for Hackers a video tutorial by Jake Vanderplas on statistical analysis using just a few fundamental concepts including simulation, sampling, shuffling, and cross-validation. Economics Simulation a simulation of a marketplace by Peter Norvig that shows effective use of many of the tools and distributions provided by this module (gauss, uniform, sample, betavariate, choice, triangular, and randrange). A Concrete Introduction to Probability (using Python) a tutorial by Peter Norvig covering the basics of probability theory, how to write simulations, and how to perform data analysis using Python.\n\nThese recipes show how to efficiently make random selections from the combinatoric iterators in the module: \"Choose r elements with replacement. Order the result to match the iterable.\" # Result will be in set(itertools.combinations_with_replacement(iterable, r)). The default returns multiples of 2⁻⁵³ in the range 0.0 ≤ x < 1.0. All such numbers are evenly spaced and are exactly representable as Python floats. However, many other representable floats in that interval are not possible selections. For example, isn’t an integer multiple of 2⁻⁵³. The following recipe takes a different approach. All floats in the interval are possible selections. The mantissa comes from a uniform distribution of integers in the range 2⁵² ≤ mantissa < 2⁵³. The exponent comes from a geometric distribution where exponents smaller than -53 occur half as often as the next larger exponent. All real valued distributions in the class will use the new method: The recipe is conceptually equivalent to an algorithm that chooses from all the multiples of 2⁻¹⁰⁷⁴ in the range 0.0 ≤ x < 1.0. All such numbers are evenly spaced, but most have to be rounded down to the nearest representable Python float. (The value 2⁻¹⁰⁷⁴ is the smallest positive unnormalized float and is equal to .) Generating Pseudo-random Floating-Point Values a paper by Allen B. Downey describing ways to generate more fine-grained floats than normally generated by ."
    },
    {
        "link": "https://w3schools.com/python/module_random.asp",
        "document": "Python has a built-in module that you can use to make random numbers.\n\nThe module has a set of methods:"
    },
    {
        "link": "https://docs.python.org/2/library/random.html",
        "document": "This module implements pseudo-random number generators for various distributions.\n\nFor integers, uniform selection from a range. For sequences, uniform selection of a random element, a function to generate a random permutation of a list in-place, and a function for random sampling without replacement.\n\nOn the real line, there are functions to compute uniform, normal (Gaussian), lognormal, negative exponential, gamma, and beta distributions. For generating distributions of angles, the von Mises distribution is available.\n\nAlmost all module functions depend on the basic function , which generates a random float uniformly in the semi-open range [0.0, 1.0). Python uses the Mersenne Twister as the core generator. It produces 53-bit precision floats and has a period of 2**19937-1. The underlying implementation in C is both fast and threadsafe. The Mersenne Twister is one of the most extensively tested random number generators in existence. However, being completely deterministic, it is not suitable for all purposes, and is completely unsuitable for cryptographic purposes.\n\nThe functions supplied by this module are actually bound methods of a hidden instance of the class. You can instantiate your own instances of to get generators that don’t share state. This is especially useful for multi-threaded programs, creating a different instance of for each thread, and using the method to make it likely that the generated sequences seen by each thread don’t overlap.\n\nClass can also be subclassed if you want to use a different basic generator of your own devising: in that case, override the , , , and methods. Optionally, a new generator can supply a method — this allows to produce selections over an arbitrarily large range.\n\nAs an example of subclassing, the module provides the class that implements an alternative generator in pure Python. The class provides a backward compatible way to reproduce results from earlier versions of Python, which used the Wichmann-Hill algorithm as the core generator. Note that this Wichmann-Hill generator can no longer be recommended: its period is too short by contemporary standards, and the sequence generated is known to fail some stringent randomness tests. See the references below for a recent variant that repairs these flaws.\n\nThe module also provides the class which uses the system function to generate random numbers from sources provided by the operating system.\n\nReturn a k length list of unique elements chosen from the population sequence. Used for random sampling without replacement. Returns a new list containing elements from the population while leaving the original population unchanged. The resulting list is in selection order so that all sub-slices will also be valid random samples. This allows raffle winners (the sample) to be partitioned into grand prize and second place winners (the subslices). Members of the population need not be hashable or unique. If the population contains repeats, then each occurrence is a possible selection in the sample. To choose a sample from a range of integers, use an object as an argument. This is especially fast and space efficient for sampling from a large population: .\n\nThe following functions generate specific real-valued distributions. Function parameters are named after the corresponding variables in the distribution’s equation, as used in common mathematical practice; most of these equations can be found in any statistics text."
    },
    {
        "link": "https://geeksforgeeks.org/python-random-module",
        "document": "Python Random module generates random numbers in Python. These are pseudo-random numbers means they are not truly random.\n\nThis module can be used to perform random actions such as generating random numbers, printing random a value for a list or string, etc. It is an in-built function in Python.\n\nList of all the functions Python Random Module\n\nThere are different random functions in the Random Module of Python. Look at the table below to learn more about these functions:\n\nLet’s discuss some common operations performed by Random module in Python.\n\nExample 1: Printing a random value from a list in Python.\n\nThis code uses the module to select a random element from the list using the function. It prints a random element from the list, demonstrating how to pick a random item from a sequence in Python.\n\nExample 2: Creating random numbers with Python seed() in Python.\n\nAs stated above random module creates pseudo-random numbers. Random numbers depend on the seeding value. For example, if the seeding value is 5 then the output of the below program will always be the same. Therefore, it must not be used for encryption.\n\nThe code sets the random number generator’s seed to 5 using , ensuring reproducibility. It then prints two random floating-point numbers between 0 and 1 using . The seed makes these numbers the same every time you run the code with a seed of 5, providing consistency in the generated random values.\n\nrandom.randint() method is used to generate random integers between the given range.\n\nThis code uses the ‘ module to generate random integers within specific ranges. It first generates a random integer between 5 and 15 (inclusive) and then between -10 and -2 (inclusive). The generated integers are printed with appropriate formatting.\n\nA random.random() method is used to generate random floats between 0.0 to 1.\n\nIn this code, we are using the function from the ‘ module in Python. It prints a random floating-point number between 0 and 1 when you call .\n\nRandom sampling from a list in Python (random.choice, and sample)\n\nExample 1: Python random.choice() function is used to return a random item from a list, tuple, or string.\n\nThe code uses the function from the module to randomly select elements from different data types. It demonstrates selecting a random element from a list, a string, and a tuple. The chosen elements will vary each time you run the code, making it useful for random selection from various data structures.\n\nExample 2: Python random.sample() function is used to return a random item from a list, tuple, or string.\n\nThis code utilizes the function from the ‘ module to obtain random samples from various data types. It selects three random elements without replacement from a list, a tuple, and a string, demonstrating its versatility in generating distinct random samples. With each execution, the selected elements will differ, providing random subsets from the input data structures.\n\nA random.shuffle() method is used to shuffle a sequence (list). Shuffling means changing the position of the elements of the sequence. Here, the shuffling operation is inplace.\n\nThis code uses the function from the ‘ module to shuffle the elements of a list named ‘ . It first prints the original order of the list, then shuffles it twice. The second shuffle creates a new random order, and the list’s content is displayed after each shuffle. This demonstrates how the elements are rearranged randomly in the list with each shuffle operation.\n\nIn this article we discussed about Python Random module, and also saw some examples of functions in random module in Python. Random module in Python is very important and contains very useful functions.\n\nHope this helps you in using Python Random module functions.\n\nWhat is a random module in Python?\n\nWhat is random vs Randint in Python?\n\nHow many functions are there in the random module?\n\nWhat is the syntax of the random function?\n\nWhat is the difference between the math module and the random module?"
    },
    {
        "link": "https://geeksforgeeks.org/random-numbers-in-python",
        "document": "Python defines a set of functions that are used to generate or manipulate random numbers through the random module.\n\nFunctions in the random module rely on a pseudo-random number generator function random(), which generates a random float number between 0.0 and 1.0. These particular type of functions is used in a lot of games, lotteries, or any application requiring a random number generation.\n\nLet us see an example of generating a random number in Python using the random() function.\n\nDifferent Ways to Generate a Random Number in Python\n\nThere are a number of ways to generate a random numbers in Python using the functions of the Python random module. Let us see a few different ways.\n\nPython random.choice() is an inbuilt function in the Python programming language that returns a random item from a list, tuple, or string.\n\nThe random module offers a function that can generate Python random numbers from a specified range and also allows room for steps to be included, called randrange().\n\nPython random.seed() function is used to save the state of a random function so that it can generate some random numbers in Python on multiple executions of the code on the same machine or on different machines (for a specific seed value). The seed value is the previous value number generated by the generator. For the first time when there is no previous value, it uses the current system time.\n\nThe shuffle() function is used to shuffle a sequence (list). Shuffling means changing the position of the elements of the sequence. Here, the shuffling operation is in place.\n\nThe uniform() function is used to generate a floating point Python random number between the numbers mentioned in its arguments. It takes two arguments, lower limit(included in generation) and upper limit(not included in generation).\n\nHow to generate random numbers in Python?\n\nWhat modules can be used for random number generation in Python?\n\nHow to create random integers within a range in Python?\n\nHow to ensure reproducibility using random seeds in Python?\n\nWhat are the ways to use random numbers in Python projects?"
    }
]