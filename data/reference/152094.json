[
    {
        "link": "https://w3schools.com/html/html5_syntax.asp",
        "document": "Consistent, clean, and tidy HTML code makes it easier for others to read and understand your code.\n\nHere are some guidelines and tips for creating good HTML code.\n\nAlways declare the document type as the first line in your document.\n\nThe correct document type for HTML is:\n\nHTML allows mixing uppercase and lowercase letters in element names.\n\nHowever, we recommend using lowercase element names, because:\n\nIn HTML, you do not have to close all elements (for example the element).\n\nHowever, we strongly recommend closing all HTML elements, like this:\n\nHTML allows mixing uppercase and lowercase letters in attribute names.\n\nHowever, we recommend using lowercase attribute names, because:\n\nHowever, we recommend quoting attribute values, because:\n• You MUST use quotes if the value contains spaces\n\nAlways Specify alt, width, and height for Images\n\nAlways specify the attribute for images. This attribute is important if the image for some reason cannot be displayed.\n\nAlso, always define the and of images. This reduces flickering, because the browser can reserve space for the image before loading.\n\nHTML allows spaces around equal signs. But space-less is easier to read and groups entities better together.\n\nWhen using an HTML editor, it is NOT convenient to scroll right and left to read the HTML code.\n\nTry to avoid too long code lines.\n\nDo not add blank lines, spaces, or indentations without a reason.\n\nFor readability, add blank lines to separate large or logical code blocks.\n\nFor readability, add two spaces of indentation. Do not use the tab key.\n\nThe element is required in HTML.\n\nThe contents of a page title is very important for search engine optimization (SEO)! The page title is used by search engine algorithms to decide the order when listing pages in search results.\n• provides a title for the page when it is added to favorites\n• displays a title for the page in search-engine results\n\nSo, try to make the title as accurate and meaningful as possible:\n\nAn HTML page will validate without the and tags:\n\nHowever, we strongly recommend to always add the and tags!\n\nOmitting and can also crash DOM and XML software.\n\nThe HTML <head> tag can also be omitted.\n\nBrowsers will add all elements before , to a default element.\n\nHowever, we recommend using the tag.\n\nIn HTML, it is optional to close empty elements.\n\nIf you expect XML/XHTML software to access your page, keep the closing slash (/), because it is required in XML and XHTML.\n\nYou should always include the attribute inside the tag, to declare the language of the Web page. This is meant to assist search engines and browsers.\n\nTo ensure proper interpretation and correct search engine indexing, both the language and the character encoding should be defined as early as possible in an HTML document:\n\nThe viewport is the user's visible area of a web page. It varies with the device - it will be smaller on a mobile phone than on a computer screen.\n\nYou should include the following element in all your web pages:\n\nThis gives the browser instructions on how to control the page's dimensions and scaling.\n\nThe part sets the width of the page to follow the screen-width of the device (which will vary depending on the device).\n\nThe part sets the initial zoom level when the page is first loaded by the browser.\n\nHere is an example of a web page without the viewport meta tag, and the same web page with the viewport meta tag:\n\nShort comments should be written on one line, like this:\n\nComments that spans more than one line, should be written like this:\n\nLong comments are easier to observe if they are indented with two spaces.\n\nUse simple syntax for linking to style sheets (the attribute is not necessary):\n\nShort CSS rules can be written compressed, like this:\n\nLong CSS rules should be written over multiple lines:\n• Place the opening bracket on the same line as the selector\n• Use one space before the opening bracket\n• Use two spaces of indentation\n• Use semicolon after each property-value pair, including the last\n• Only use quotes around values if the value contains spaces\n• Place the closing bracket on a new line, without leading spaces\n\nUse simple syntax for loading external scripts (the attribute is not necessary):\n\nUsing \"untidy\" HTML code can result in JavaScript errors.\n\nThese two JavaScript statements will produce different results:\n\nSome web servers (Apache, Unix) are case sensitive about file names: \"london.jpg\" cannot be accessed as \"London.jpg\".\n\nOther web servers (Microsoft, IIS) are not case sensitive: \"london.jpg\" can be accessed as \"London.jpg\".\n\nIf you use a mix of uppercase and lowercase, you have to be aware of this.\n\nIf you move from a case-insensitive to a case-sensitive server, even small errors will break your web!\n\nTo avoid these problems, always use lowercase file names!\n\nHTML files should have a .html extension (.htm is allowed).\n\nThere is no difference between the .htm and .html file extensions!\n\nBoth will be treated as HTML by any web browser and web server.\n\nWhen a URL does not specify a filename at the end (like \"https://www.w3schools.com/\"), the server just adds a default filename, such as \"index.html\", \"index.htm\", \"default.html\", or \"default.htm\".\n\nIf your server is configured only with \"index.html\" as the default filename, your file must be named \"index.html\", and not \"default.html\".\n\nHowever, servers can be configured with more than one default filename; usually you can set up as many default filenames as you want."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Learn_web_development/Core/Structuring_content/Structuring_documents",
        "document": "In addition to defining individual parts of your page (such as \"a paragraph\" or \"an image\"), HTML also boasts a number of block level elements used to define areas of your website (such as \"the header\", \"the navigation menu\", \"the main content column\"). This article looks into how to plan a basic website structure, and write the HTML to represent this structure. Basic HTML familiarity, as covered in Basic HTML Syntax. Text-level semantics such as headings and paragraphs and lists.\n• The common HTML semantic structural elements, for example , , , , , and , and how to use them correctly.\n• The need to use semantic elements in appropriate places, rather than just using elements wherever a block-level container is required, and the benefits of this (such as improved accessibility).\n\nWebpages can and will look pretty different from one another, but they all tend to share similar standard components, unless the page is displaying a fullscreen video or game, is part of some kind of art project, or is just badly structured: Usually a big strip across the top with a big heading, logo, and perhaps a tagline. This usually stays the same from one page of a website to another. Links to the site's main sections; usually represented by menu buttons, links, or tabs. Like the header, this content usually remains consistent from one webpage to another — having inconsistent navigation on your website will just lead to confused, frustrated users. Many web designers consider the navigation bar to be part of the header rather than an individual component, but that's not a requirement; in fact, some also argue that having the two separate is better for accessibility, as screen readers can read the two features better if they are separate. A big area in the center that contains most of the unique content of a given webpage, for example, the video you want to watch, or the main story you're reading, or the map you want to view, or the news headlines, etc. This is the one part of the website that definitely will vary from page to page! Some peripheral info, links, quotes, ads, etc. Usually, this is contextual to what is contained in the main content (for example on a news article page, the sidebar might contain the author's bio, or links to related articles) but there are also cases where you'll find some recurring elements like a secondary navigation system. A strip across the bottom of the page that generally contains fine print, copyright notices, or contact info. It's a place to put common information (like the header) but usually, that information is not critical or secondary to the website itself. The footer is also sometimes used for SEO purposes, by providing links for quick access to popular content. A \"typical website\" could be structured something like this: Note: The image above illustrates the main sections of a document, which you can define with HTML. However, the appearance of the page shown here — including the layout, colors, and fonts — is achieved by applying CSS to the HTML.\n\nActive learning: exploring the code for our example Our example seen above is represented by the following code (you can also find the example in our GitHub repository). We'd like you to look at the example above, and then look over the listing below to see what parts make up what section of the visual. <!doctype html> <html lang=\"en-US\"> <head> <meta charset=\"utf-8\" /> <meta name=\"viewport\" content=\"width=device-width\" /> <title>My page title</title> <link href=\"https://fonts.googleapis.com/css?family=Open+Sans+Condensed:300|Sonsie+One\" rel=\"stylesheet\" /> <link rel=\"stylesheet\" href=\"style.css\" /> </head> <body> <!-- The main header used across all the pages of our website --> <header> <h1>Header</h1> </header> <nav> <ul> <li><a href=\"#\">Home</a></li> <li><a href=\"#\">Our team</a></li> <li><a href=\"#\">Projects</a></li> <li><a href=\"#\">Contact</a></li> </ul> <!-- A Search form: another common non-linear way to navigate through a site. --> <form> <input type=\"search\" name=\"q\" placeholder=\"Search query\" /> <input type=\"submit\" value=\"Go!\" /> </form> </nav> <!-- Our page's main content --> <main> <!-- An article --> <article> <h2>Article heading</h2> <p> Lorem ipsum dolor sit amet, consectetur adipisicing elit. Donec a diam lectus. Set sit amet ipsum mauris. Maecenas congue ligula as quam viverra nec consectetur ant hendrerit. Donec et mollis dolor. Praesent et diam eget libero egestas mattis sit amet vitae augue. Nam tincidunt congue enim, ut porta lorem lacinia consectetur. </p> <section> <h3>Subsection</h3> <p> Donec ut librero sed accu vehicula ultricies a non tortor. Lorem ipsum dolor sit amet, consectetur adipisicing elit. Aenean ut gravida lorem. Ut turpis felis, pulvinar a semper sed, adipiscing id dolor. </p> <p> Pelientesque auctor nisi id magna consequat sagittis. Curabitur dapibus, enim sit amet elit pharetra tincidunt feugiat nist imperdiet. Ut convallis libero in urna ultrices accumsan. Donec sed odio eros. </p> </section> <section> <h3>Another subsection</h3> <p> Donec viverra mi quis quam pulvinar at malesuada arcu rhoncus. Cum soclis natoque penatibus et manis dis parturient montes, nascetur ridiculus mus. In rutrum accumsan ultricies. Mauris vitae nisi at sem facilisis semper ac in est. </p> <p> Vivamus fermentum semper porta. Nunc diam velit, adipscing ut tristique vitae sagittis vel odio. Maecenas convallis ullamcorper ultricied. Curabitur ornare, ligula semper consectetur sagittis, nisi diam iaculis velit, is fringille sem nunc vet mi. </p> </section> </article> <!-- the aside content can also be nested within the main content --> <aside> <h2>Related</h2> <ul> <li><a href=\"#\">Oh I do like to be beside the seaside</a></li> <li><a href=\"#\">Oh I do like to be beside the sea</a></li> <li><a href=\"#\">Although in the North of England</a></li> <li><a href=\"#\">It never stops raining</a></li> <li><a href=\"#\">Oh well…</a></li> </ul> </aside> </main> <!-- The footer that is used across all the pages of our website --> <footer> <p>©Copyright 2050 by nobody. All rights reversed.</p> </footer> </body> </html> Take some time to look over the code and understand it — the comments inside the code should also help you to understand it. We aren't asking you to do much else in this article, because the key to understanding document layout is writing a sound HTML structure, and then laying it out with CSS. We'll wait for this until you start to study CSS layout as part of the CSS topic.\n\nSometimes you'll come across a situation where you can't find an ideal semantic element to group some items together or wrap some content. Sometimes you might want to just group a set of elements together to affect them all as a single entity with some CSS or JavaScript. For cases like these, HTML provides the and elements. You should use these preferably with a suitable attribute, to provide some kind of label for them so they can be easily targeted. is an inline non-semantic element, which you should only use if you can't think of a better semantic text element to wrap your content, or don't want to add any specific meaning. For example: <p> The King walked drunkenly back to his room at 01:00, the beer doing nothing to aid him as he staggered through the door. <span class=\"editor-note\"> [Editor's note: At this point in the play, the lights should be down low]. </span> </p> In this case, the editor's note is supposed to merely provide extra direction for the director of the play; it is not supposed to have extra semantic meaning. For sighted users, CSS would perhaps be used to distance the note slightly from the main text. is a block level non-semantic element, which you should only use if you can't think of a better semantic block element to use, or don't want to add any specific meaning. For example, imagine a shopping cart widget that you could choose to pull up at any point during your time on an e-commerce site: This isn't really an , as it doesn't necessarily relate to the main content of the page (you want it viewable from anywhere). It doesn't even particularly warrant using a , as it isn't part of the main content of the page. So a is fine in this case. We've included a heading as a signpost to aid screen reader users in finding it. Warning: Divs are so convenient to use that it's easy to use them too much. As they carry no semantic value, they just clutter your HTML code. Take care to use them only when there is no better semantic solution and try to reduce their usage to the minimum otherwise you'll have a hard time updating and maintaining your documents.\n\nTwo elements that you'll use occasionally and will want to know about are and . creates a line break in a paragraph; it is the only way to force a rigid structure in a situation where you want a series of fixed short lines, such as in a postal address or a poem. For example: <p> There once was a man named O'Dell<br /> Who loved to write HTML<br /> But his structure was bad, his semantics were sad<br /> and his markup didn't read very well. </p> Without the elements, the paragraph would just be rendered in one long line (as we said earlier in the course, HTML ignores most whitespace); with elements in the code, the markup renders like this: elements create a horizontal rule in the document that denotes a thematic change in the text (such as a change in topic or scene). Visually it just looks like a horizontal line. As an example: <p> Ron was backed into a corner by the marauding netherbeasts. Scared, but determined to protect his friends, he raised his wand and prepared to do battle, hoping that his distress call had made it through. </p> <hr /> <p> Meanwhile, Harry was sitting at home, staring at his royalty statement and pondering when the next spin off series would come out, when an enchanted distress letter flew through his window and landed in his lap. He read it hazily and sighed; \"better get back to work then\", he mused. </p>"
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Learn_web_development/Core/Structuring_content/Basic_HTML_syntax",
        "document": "In this article, we cover the absolute basics of HTML. To get you started, this article defines elements, attributes, and all the other important terms you may have heard. It also explains where these fit into HTML. You will learn how HTML elements are structured, how a typical HTML page is structured, and other important basic language features. Along the way, there will be an opportunity to play with HTML too! Basic software installed, and basic knowledge of working with files.\n• The anatomy of an HTML element — element, opening tag, content, closing tag, attributes.\n• The HTML body and its purpose as a container for the page content.\n• What void elements (also known as empty elements) are, and how they differ from other elements.\n• The need for a doctype at the top of HTML documents. Its original intended purpose, and the fact that now it is somewhat of a historical artifact.\n• Understanding that HTML needs to be correctly nested.\n\nHTML (HyperText Markup Language) is a markup language that tells web browsers how to structure the web pages you visit. It can be as complicated or as simple as the web developer wants it to be. HTML consists of a series of elements, which you use to enclose, wrap, or mark up different parts of content to make it appear or act in a certain way. The enclosing tags can make content into a hyperlink to connect to another page, italicize words, and so on. For example, consider the following line of text: My cat is very grumpy If we wanted the text to stand by itself, we could specify that it is a paragraph by enclosing it in a paragraph ( ) element: HTML lives inside text files called HTML documents, or just documents, with a file extension. Where previously we've talked about web pages, an HTML document contains the web page's content and specifies its structure. The most common HTML file you'll encounter is , which is generally used to contain a website's home page content. It's also common to see subfolders with their own , so a website can have multiple index files in different places. Note: Tags in HTML are not case-sensitive. This means they can be written in uppercase or lowercase. For example, a tag could be written as , , , , etc., and it will work. However, it is best practice to write all tags in lowercase for consistency and readability.\n\nEdit the line below in the \"Editable code\" area by wrapping it with the tags and To open the element, put the opening tag at the start of the line. To close the element, put the closing tag at the end of the line. Doing this should give the line italic text formatting! See your changes update live in the Output area. If you make a mistake, you can clear your work using the Reset button. If you get really stuck, press the Show solution button to see the answer. <h2>Live output</h2> <div class=\"output\" style=\"min-height: 50px;\"></div> <h2>Editable code</h2> <p class=\"a11y-label\"> Press Esc to move focus away from the code area (Tab inserts a tab character). </p> <textarea id=\"code\" class=\"playable-code\" style=\"min-height: 100px;width: 95%\"> This is my text. </textarea> <div class=\"controls\"> <input id=\"reset\" type=\"button\" value=\"Reset\" /> <input id=\"solution\" type=\"button\" value=\"Show solution\" /> </div> const textarea = document.getElementById(\"code\"); const reset = document.getElementById(\"reset\"); const solution = document.getElementById(\"solution\"); const output = document.querySelector(\".output\"); const code = textarea.value; let userEntry = textarea.value; function updateCode() { output.innerHTML = textarea.value; } const htmlSolution = \"<em>This is my text.</em>\"; let solutionEntry = htmlSolution; reset.addEventListener(\"click\", () => { textarea.value = code; userEntry = textarea.value; solutionEntry = htmlSolution; solution.value = \"Show solution\"; updateCode(); }); solution.addEventListener(\"click\", () => { if (solution.value === \"Show solution\") { textarea.value = solutionEntry; solution.value = \"Hide solution\"; } else { textarea.value = userEntry; solution.value = \"Show solution\"; } updateCode(); }); textarea.addEventListener(\"input\", updateCode); window.addEventListener(\"load\", updateCode); // stop tab key tabbing out of textarea and // make it write a tab at the caret position instead textarea.onkeydown = (e) => { if (e.code === \"Tab\") { e.preventDefault(); insertAtCaret(\"\\t\"); } if (e.code === \"Escape\") { textarea.blur(); } }; function insertAtCaret(text) { const scrollPos = textarea.scrollTop; let caretPos = textarea.selectionStart; const front = textarea.value.substring(0, caretPos); const back = textarea.value.substring( textarea.selectionEnd, textarea.value.length, ); textarea.value = front + text + back; caretPos += text.length; textarea.selectionStart = caretPos; textarea.selectionEnd = caretPos; textarea.focus(); textarea.scrollTop = scrollPos; } // Update the saved userCode every time the user updates the text area code textarea.onkeyup = () => { // We only want to save the state when the user code is being shown, // not the solution, so that solution is not saved over the user code if (solution.value === \"Show solution\") { userEntry = textarea.value; } else { solutionEntry = textarea.value; } updateCode(); };\n\nElements can be placed within other elements. This is called nesting. If we wanted to state that our cat is very grumpy, we could wrap the word very in a element, which means that the word is to have strong(er) text formatting: There is a right and wrong way to do nesting. In the example above, we opened the element first, then opened the element. For proper nesting, we should close the element first, before closing the . The following is an example of the wrong way to do nesting: The tags have to open and close in a way that they are inside or outside one another. With the kind of overlap in the example above, the browser has to guess at your intent. This kind of guessing can result in unexpected results.\n\nThe element can take a number of attributes, including: The attribute is a required attribute that specifies the location of the image. For example: . The attribute specifies a text description of the image. For example: . The attribute specifies the width of the image with the unit being pixels. For example: . The attribute specifies the height of the image with the unit being pixels. For example: . Edit the line below in the Input area to turn it into an image.\n• Find your favorite image online, right click it, and press Copy Image Link/Address.\n• Back in the area below, add the attribute and fill it with the link from step 1. You will be able to see your changes live in the Output area. If you make a mistake, you can always reset it using the Reset button. If you get really stuck, press the Show solution button to see the answer. <h2>Live output</h2> <div class=\"output\" style=\"min-height: 50px;\"></div> <h2>Editable code</h2> <p class=\"a11y-label\"> Press Esc to move focus away from the code area (Tab inserts a tab character). </p> <textarea id=\"code\" class=\"input\" style=\"min-height: 100px;width: 95%\"> <img alt=\"I should be an image\" > </textarea> <div class=\"playable-buttons\"> <input id=\"reset\" type=\"button\" value=\"Reset\" /> <input id=\"solution\" type=\"button\" value=\"Show solution\" /> </div> const textarea = document.getElementById(\"code\"); const reset = document.getElementById(\"reset\"); const solution = document.getElementById(\"solution\"); const output = document.querySelector(\".output\"); const code = textarea.value; let userEntry = textarea.value; function updateCode() { output.innerHTML = textarea.value; } const htmlSolution = '<img src=\"https://raw.githubusercontent.com/mdn/beginner-html-site/gh-pages/images/firefox-icon.png\" alt=\"Firefox icon\" width=\"100\" height=\"100\" />'; let solutionEntry = htmlSolution; reset.addEventListener(\"click\", () => { textarea.value = code; userEntry = textarea.value; solutionEntry = htmlSolution; solution.value = \"Show solution\"; updateCode(); }); solution.addEventListener(\"click\", () => { if (solution.value === \"Show solution\") { textarea.value = solutionEntry; solution.value = \"Hide solution\"; } else { textarea.value = userEntry; solution.value = \"Show solution\"; } updateCode(); }); textarea.addEventListener(\"input\", updateCode); window.addEventListener(\"load\", updateCode); // stop tab key tabbing out of textarea and // make it write a tab at the caret position instead textarea.onkeydown = (e) => { if (e.code === \"Tab\") { e.preventDefault(); insertAtCaret(\"\\t\"); } if (e.code === \"Escape\") { textarea.blur(); } }; function insertAtCaret(text) { const scrollPos = textarea.scrollTop; let caretPos = textarea.selectionStart; const front = textarea.value.substring(0, caretPos); const back = textarea.value.substring( textarea.selectionEnd, textarea.value.length, ); textarea.value = front + text + back; caretPos += text.length; textarea.selectionStart = caretPos; textarea.selectionEnd = caretPos; textarea.focus(); textarea.scrollTop = scrollPos; } // Update the saved userCode every time the user updates the text area code textarea.onkeyup = () => { // We only want to save the state when the user code is being shown, // not the solution, so that solution is not saved over the user code if (solution.value === \"Show solution\") { userEntry = textarea.value; } else { solutionEntry = textarea.value; } updateCode(); };\n\nSometimes you will see attributes written without values. This is entirely acceptable. These are called Boolean attributes. When a boolean attribute is written without a value, or with any value, even like , the boolean attribute is always set to true. Otherwise, if the attribute is not written in an HTML tag, the attribute is set to false. The spec requires the attribute's value to either be the empty string (including when the attribute has no value explicitly specified) or the same as the attribute's name, but other values work the same. For example, consider the attribute, which you can assign to form input elements. (You use this to disable the form input elements so the user can't make entries. The disabled elements typically have a grayed-out appearance.) For example: As shorthand, it is acceptable to write this as follows: <!-- using the disabled attribute prevents the end user from entering text into the input box --> <input type=\"text\" disabled /> <!-- text input is allowed, as it doesn't contain the disabled attribute --> <input type=\"text\" /> For reference, the example above also includes a non-disabled form input element. The HTML from the example above produces this result:\n\nIf you look at code for a lot of other sites, you might come across a number of strange markup styles, including attribute values without quotes. This is permitted in certain circumstances, but it can also break your markup in other circumstances. The element in the code snippet below, , is called an anchor. Anchors enclose text and turn them into links. The attribute specifies the web address the link points to. You can write this basic version below with only the attribute, like this: Anchors can also have a attribute, a description of the linked page. However, as soon as we add the in the same fashion as the attribute there are problems: As written above, the browser misinterprets the markup, mistaking the attribute for three attributes: a title attribute with the value , and two Boolean attributes, and . Obviously, this is not intended! It will cause errors or unexpected behavior, as you can see in the live example below. Try hovering over the link to view the title text! Always include the attribute quotes. It avoids such problems, and results in more readable code.\n\nIn this article, you will also notice that the attributes are wrapped in double quotes. However, you might see single quotes in some HTML code. This is a matter of style. You can feel free to choose which one you prefer. Both of these lines are equivalent: <a href='https://www.example.com'>A link to my example.</a> <a href=\"https://www.example.com\">A link to my example.</a> Make sure you don't mix single quotes and double quotes. This example (below) shows a kind of mixing of quotes that will go wrong: However, if you use one type of quote, you can include the other type of quote inside your attribute values: <a href=\"https://www.example.com\" title=\"Isn't this fun?\"> A link to my example. </a> To use quote marks inside other quote marks of the same type (single quote or double quote), use character references. For example, this will break: Instead, you need to do this:\n\nIndividual HTML elements aren't very useful on their own. Next, let's examine how individual elements combine to form an entire HTML page:\n• : The doctype. When HTML was young (1991-1992), doctypes were meant to act as links to a set of rules that the HTML page had to follow to be considered good HTML. Doctypes used to look something like this: More recently, the doctype is a historical artifact that needs to be included for everything else to work right. is the shortest string of characters that counts as a valid doctype. That is all you need to know!\n• : The element. This element wraps all the content on the page. It is sometimes known as the root element.\n• : The element. This element acts as a container for everything you want to include on the HTML page, that isn't the content the page will show to viewers. This includes keywords and a page description that would appear in search results, CSS to style content, character set declarations, and more. You will learn more about this in the next article of the series.\n• : The element. This element represents metadata that cannot be represented by other HTML meta-related elements, like , , , or . The attribute specifies the character encoding for your document as UTF-8, which includes most characters from the vast majority of human written languages. With this setting, the page can now handle any textual content it might contain. There is no reason not to set this, and it can help avoid some problems later.\n• : The element. This sets the title of the page, which is the title that appears in the browser tab the page is loaded in. The page title is also used to describe the page when it is bookmarked.\n• : The element. This contains all the content that displays on the page, including text, images, videos, games, playable audio tracks, or whatever else.\n\nActive learning: Adding some features to an HTML document If you want to experiment with writing some HTML on your local computer, you can:\n• Copy the HTML page example listed above.\n• Create a new file in your text editor.\n• Paste the code into the new text file. Note: You can also find this basic HTML template on the MDN Learning Area GitHub repo. You can now open this file in a web browser to see what the rendered code looks like. Edit the code and refresh the browser to see what the result is. Initially, the page looks like this: In this exercise, you can edit the code locally on your computer, as described previously, or you can edit it in the sample window below (the editable sample window represents just the contents of the element, in this case). Sharpen your skills by implementing the following tasks:\n• Just below the opening tag of the element, add a main title for the document. This should be wrapped inside an opening tag and closing tag.\n• Edit the paragraph content to include text about a topic that you find interesting.\n• Make important words stand out in bold by wrapping them inside a opening tag and closing tag.\n• Add a link to your paragraph, as explained earlier in the article.\n• Add an image to your document. Place it below the paragraph, as explained earlier in the article. Earn bonus points if you manage to link to a different image (either locally on your computer or somewhere else on the web). If you make a mistake, you can always reset it using the Reset button. If you get really stuck, press the Show solution button to see the answer. <h2>Live output</h2> <div class=\"output\" style=\"min-height: 50px;\"></div> <h2>Editable code</h2> <p class=\"a11y-label\"> Press Esc to move focus away from the code area (Tab inserts a tab character). </p> <textarea id=\"code\" class=\"input\" style=\"min-height: 100px;width: 95%\"> <p>This is my page</p> </textarea> <div class=\"playable-buttons\"> <input id=\"reset\" type=\"button\" value=\"Reset\" /> <input id=\"solution\" type=\"button\" value=\"Show solution\" /> </div> const textarea = document.getElementById(\"code\"); const reset = document.getElementById(\"reset\"); const solution = document.getElementById(\"solution\"); const output = document.querySelector(\".output\"); const code = textarea.value; let userEntry = textarea.value; function updateCode() { output.innerHTML = textarea.value; } const htmlSolution = '<h1>Some music</h1><p>I really enjoy <strong>playing the drums</strong>. One of my favorite drummers is Neal Peart, who plays in the band <a href=\"https://en.wikipedia.org/wiki/Rush_%28band%29\" title=\"Rush Wikipedia article\">Rush</a>. My favorite Rush album is currently <a href=\"http://www.deezer.com/album/942295\">Moving Pictures</a>.</p> <img src=\"http://www.cygnus-x1.net/links/rush/images/albums/sectors/sector2-movingpictures-cover-s.jpg\" alt=\"Rush Moving Pictures album cover\">'; let solutionEntry = htmlSolution; reset.addEventListener(\"click\", () => { textarea.value = code; userEntry = textarea.value; solutionEntry = htmlSolution; solution.value = \"Show solution\"; updateCode(); }); solution.addEventListener(\"click\", () => { if (solution.value === \"Show solution\") { textarea.value = solutionEntry; solution.value = \"Hide solution\"; } else { textarea.value = userEntry; solution.value = \"Show solution\"; } updateCode(); }); textarea.addEventListener(\"input\", updateCode); window.addEventListener(\"load\", updateCode); // stop tab key tabbing out of textarea and // make it write a tab at the caret position instead textarea.onkeydown = (e) => { if (e.code === \"Tab\") { e.preventDefault(); insertAtCaret(\"\\t\"); } if (e.code === \"Escape\") { textarea.blur(); } }; function insertAtCaret(text) { const scrollPos = textarea.scrollTop; let caretPos = textarea.selectionStart; const front = textarea.value.substring(0, caretPos); const back = textarea.value.substring( textarea.selectionEnd, textarea.value.length, ); textarea.value = front + text + back; caretPos += text.length; textarea.selectionStart = caretPos; textarea.selectionEnd = caretPos; textarea.focus(); textarea.scrollTop = scrollPos; } // Update the saved userCode every time the user updates the text area code textarea.onkeyup = () => { // We only want to save the state when the user code is being shown, // not the solution, so that solution is not saved over the user code if (solution.value === \"Show solution\") { userEntry = textarea.value; } else { solutionEntry = textarea.value; } updateCode(); };\n\nIn the examples above, you may have noticed that a lot of whitespace is included in the code. This is optional. These two code snippets are equivalent: No matter how much whitespace you use inside HTML element content (which can include one or more space characters, but also line breaks), the HTML parser reduces each sequence of whitespace to a single space when rendering the code. So why use so much whitespace? The answer is readability. It can be easier to understand what is going on in your code if you have it nicely formatted. In our HTML we've got each nested element indented by two spaces more than the one it is sitting inside. It is up to you to choose the style of formatting (how many spaces for each level of indentation, for example), but you should consider formatting it. Let's have a look at how the browser renders the two paragraphs above with and without whitespace: Note: Accessing the innerHTML of elements from JavaScript will keep all the whitespace intact. This may return unexpected results if the whitespace is trimmed by the browser.\n\nIn HTML, the characters , , , , and are special characters. They are parts of the HTML syntax itself. So how do you include one of these special characters in your text? For example, if you want to use an ampersand or less-than sign, and not have it interpreted as code. You do this with character references. These are special codes that represent characters, to be used in these exact circumstances. Each character reference starts with an ampersand (&), and ends with a semicolon (;). The character reference equivalent could be easily remembered because the text it uses can be seen as less than for , quotation for and similarly for others. To find more about entity references, see List of XML and HTML character entity references (Wikipedia). In the example below, there are two paragraphs: <p>In HTML, you define a paragraph using the <p> element.</p> <p>In HTML, you define a paragraph using the <p> element.</p> In the live output below, you can see that the first paragraph has gone wrong. The browser interprets the second instance of as starting a new paragraph. The second paragraph looks fine because it has angle brackets with character references. Note: You don't need to use entity references for any other symbols, as modern browsers will handle the actual symbols just fine as long as your HTML's character encoding is set to UTF-8."
    },
    {
        "link": "https://geeksforgeeks.org/html5-introduction",
        "document": "HTML (HyperText Markup Language) is the standard language used to create and structure web pages. It organizes the content and layout of a webpage using tags.\n\nHTML5, the newest version, brings key improvements like better support for multimedia, new semantic tags, and powerful APIs, making web development easier and more interactive.\n• None This is a basic HTML structure with a heading (<h1>) and a paragraph (<p>).\n• None The page displays “Hello, World!” as the main title and a simple text paragraph.\n\nHTML5 introduces several new elements and attributes to improve web development:\n• Semantic Elements:\n• None New tags like <article>, <aside>, <nav>, <header>, <footer>, and <section> provide meaning and structure to the content, improving both accessibility and SEO.\n• Multimedia Support:\n• None Native support for <audio> and <video> tags removes the need for third-party plugins like Flash.\n• Canvas API:\n• None Allows drawing graphics, animations, and games directly in the browser using JavaScript.\n• Geolocation API:\n• None Provides access to the user’s geographical location (with permission), enabling location-based services.\n• Web Workers:\n• None Allows background processing of JavaScript, improving performance by preventing blocking of the main thread.\n• Form Enhancements:\n• None New input types (e.g., date, email, number) and form validation make forms easier and more efficient to create.\n• Drag and Drop API:\n• None Allows users to drag and drop elements within a web page or between applications, enhancing interactivity.\n• SVG Integration:\n• None Improved support for Scalable Vector Graphics (SVG), allowing for resolution-independent vector graphics to be embedded directly into HTML.\n\nHTML5 has removed several outdated elements, replacing them with newer, more flexible solutions:\n\nHTML5 introduces a variety of new tags to improve the structure and functionality of web documents:\n• <article>: The <article> tag is used to represent an article. More specifically, the content within the <article> tag is independent from the other content of the site (even though it can be related).\n• <aside>: The <aside> tag is used to describe the main object of the web page in a shorter way like a highlighter. It basically identifies the content that is related to the primary content of the web page but does not constitute the main intent of the primary page. The <aside> tag contains mainly author information, links, related content and so on.\n• <figcaption>: The <figcaption> tag in HTML is used to set a caption to the figure element in a document.\n• <figure>: The <figure> tag in HTML is used to add self-contained content like illustrations, diagrams, photos or codes listing in a document. It is related to main flow, but it can be used in any position of a document and the figure goes with the flow of the document and if it is removed it should not affect the flow of the document.\n• <header>: It contains the section heading as well as other content, such as a navigation links, table of contents, etc.\n• <footer>: The <footer> tag in HTML is used to define a footer of HTML document. This section contains the footer information (author information, copyright information, carriers etc.). The footer tag is used within body tag. The <footer> tag is new in the HTML 5. The footer elements require a start tag as well as an end tag.\n• <main>: Delineates the main content of the body of a document or web app.\n• <mark>: The <mark> tag in HTML is used to define the marked text. It is used to highlight the part of the text in the paragraph.\n• <nav>: The <nav> tag is used to declaring the navigational section in HTML documents. Websites typically have sections dedicated to navigational links, which enables user to navigate the site. These links can be placed inside a nav tag.\n• <details>: The <details> tag is used for the content/information which is initially hidden but could be displayed if the user wishes to see it. This tag is used to create interactive widget which user can open or close it. The content of details tag is visible when open the set attributes.\n• <summary>: The <summary> tag in HTML is used to define a summary for the <details> element. The <summary> element is used along with the <details> element and provides a summary visible to the user. When the summary is clicked by the user, the content placed inside the <details> element becomes visible which was previously hidden. The <summary> tag was added in HTML 5. The <summary> tag requires both starting and ending tag.\n• <time>: The <time> tag is used to display the human-readable data/time. It can also be used to encode dates and times in a machine-readable form. The main advantage for users is that they can offer to add birthday reminders or scheduled events in their calendars and search engines can produce smarter search results.\n• <bdi>: The <bdi> tag refers to the Bi-Directional Isolation. It differentiates a text from other text that may be formatted in different direction. This tag is used when a user generated text with an unknown direction.\n• <wbr>: The <wbr> tag in HTML stands for word break opportunity and is used to define the position within the text which is treated as a line break by the browser. It is mostly used when the used word is too long and there are chances that the browser may break lines at the wrong place for fitting the text.\n• <datalist>: The <datalist> tag is used to provide autocomplete feature in the HTML files. It can be used with input tag, so that users can easily fill the data in the forms using select the data.\n• <keygen>: The <keygen> tag in HTML is used to specify a key-pair generator field in a form. The purpose of <keygen> element is to provide a secure way to authenticate users. When a form is submitted then two keys are generated, private key and public key. The private key stored locally, and the public key is sent to the server. The public key is used to generate client certificate to authenticate user in future.\n• <output>: The <output> tag in HTML is used to represent the result of a calculation performed by the client-side script such as JavaScript.\n• <progress>: It is used to represent the progress of a task. It also defines how much work is done and how much is left to download a task. It is not used to represent the disk space or relevant query.\n• <svg>: It is the Scalable Vector Graphics.\n• <canvas>: The <canvas> tag in HTML is used to draw graphics on web page using JavaScript. It can be used to draw paths, boxes, texts, gradient and adding images. By default, it does not contain border and text.\n• <audio>: It defines the music or audio content.\n• <source>: It defines the sources for <video> and <audio>.\n• <track>: It defines the tracks for <video> and <audio>.\n• None Easy to use and implement.\n• None Works well with CSS and JavaScript to create dynamic and attractive websites.\n• None Some older browsers may not support all features.\n\nMore Example of HTML5\n\nIn this example,\n• None The <video> tag is used to embed a video in the HTML page.\n• None The <source> tag specifies the video file and format. If the video is not supported, the text inside the <video> tag will be displayed.\n\nUsing the <canvas> Element for Drawing\n\nIn this example,\n• None The <canvas> tag is used to create an area for drawing graphics using JavaScript.\n• None The getContext(“2d”) method is used to set up a 2D drawing context on the canvas.\n• None The fillRect method draws a blue rectangle within the canvas.\n\nUsing the <progress> Element to Show Task Progress\n• None The <progress> tag is used to display a progress bar on the webpage.\n• None The value attribute sets the current progress, and the max attribute defines the maximum value.\n\nBest Practices of Using HTML5\n• Use Semantic Tags: Improve SEO and accessibility by using tags like <header>, <footer>, <article>, and <section>.\n• Ensure Cross-Browser Compatibility: Test your code across multiple browsers, especially older versions.\n• Use <meta charset=”UTF-8″> : Always specify the character encoding at the start to avoid encoding issues.\n• Mobile Responsiveness : Use the <meta name=”viewport” content=”width=device-width, initial-scale=1.0″> tag for mobile-friendly designs.\n\nWhat are the new features in HTML5?\n\nWhy should I use semantic tags in HTML5?\n\nCan I use HTML5 in older browsers?"
    },
    {
        "link": "https://kinsta.com/blog/html-best-practices",
        "document": "HTML best practices help developers offer innovative and highly interactive websites and web apps. These best practices help you develop the most feature-rich and business-centric applications. Plus, organizations can harness these best practices to provide a seamless user experience.\n\nToday, when we talk about HTML, we typically discuss HTML5 (and not its immediate predecessors). HTML5 is a powerful markup language that allows web developers to create a web document. It’s easy to use and understand, and almost all browsers support it. Also, it’s the foundation of almost all Content Management Systems (CMS)\n\nAs a web developer with minimal experience, questions such as “How can I write better HTML?” often arise. This article aims to help you get started on the right foot.\n\nYou probably already have a grasp of this markup language, but here are some HTML5 best practices that will let you code better.\n\nWhen creating an HTML document, the declaration is required for informing the browser what standards you’re using. Its purpose is to render your markup correctly.\n\nThe declaration should be in the first line of your HTML document. Here is a comparison between its right and wrong implementation:\n\nAlternatively, you can use the doctype corresponding to the HTML/XHTML version you want to use. Learn about the recommended list of doctype declarations to help you choose the right one.\n\nDevelopers know that the purpose of tags is to help web browsers distinguish between HTML content and ordinary content. HTML tags contain an opening tag, content, and closing tag. However, they’re often confused about the proper placement of tags, the elements that require closing tags, or when to omit tags.\n\nFor instance, where’s the best place to put tags?\n\nScript tags are typically placed inside the element. But a modern HTML best practice is to place them at the bottom of the document instead, before closing the tag, to delay their download. The webpage will load the Document Object Model (DOM) first, show it to the user, and then request the scripts afterward, reducing time to first byte (TTFB).\n\nThe browser interprets your HTML document line by line from top to bottom. So, when it reads the head and comes across a script tag, it starts a request to the server to get the file. There’s nothing inherently wrong with this process, but if the page is loading a huge file, it will take a long time and greatly affect the user experience.\n\nUnder the root element is the , or language, attribute. This attribute helps in translating an HTML document into the proper language. The best practice is to keep this attribute’s value as short as possible.\n\nFor example, the Japanese language is mostly used in Japan. Therefore, the country code is not necessary when targeting the Japanese language.\n\nOne of the most common HTML best practices is to check on the do’s and don’ts. Here are some known don’ts in HTML coding:\n\nLike any coding practice, the “keep it simple” principle is very applicable to HTML and HTML5. Generally, HTML5 is compatible with older HTML versions and XHTML. For that reason, we recommend avoiding the use of XML declarations or attributes.\n\nYou don’t need to declare code as such unless you want to write an XHTML document. Similarly, you don’t need XML attributes, such as:\n\nDevelopers should code with SEO in mind. Web contents that are not found are also not indexed. For that reason, here are some best SEO best practices to consider:\n\nThe tag is a handy tag, but misusing it may result in some non-intuitive behaviors. Thus, if you declare a base tag, then every link in the document will be relative unless explicitly specified:\n\nThis syntax changes the default behavior of some links. For example, linking to an external webpage with only the page name and extension:\n\nOr the browser will interpret it as:\n\nThis interpretation becomes chaotic, so it’s safer to always use absolute paths for your links.\n\nOn the other hand, writing metatag descriptions is not strictly a part of HTML best practices, but it’s still equally important. The attribute is what search engine crawlers reference when they index your page, so it’s vital to your SEO health.\n\nThe tag makes a web page search engine-friendly. For one thing, the text inside the tag appears in Google’s Search Engine Result Pages (SERP) and the user’s web browser bar and tabs.\n\nTake, for example, when you search the keyword “HTML5.” The title in this search result indicates the specific title attribute and the author. This is very important in SEO and site traffic generation.\n\nImages Must Have an Alt Attribute\n\nUsing a meaningful alt attribute with elements is a must for writing valid and semantic code.\n\nIn the table below, the bad practice column shows an element without an alt attribute. Although the second example in the same column has an alt attribute, its value is meaningless.\n\nThe meta description is an HTML element that describes and summarizes the contents of a webpage. Its purpose is for the users to find the context of the page. Although metadata doesn’t help anymore with SEO rankings, the meta description still plays a significant role in on-page SEO.\n\nHere is a sample code that includes the keywords, description, author’s name, and character set. The character set is used to support almost all the characters and symbols from different languages. On the other hand, you can set cookies, add a revision date, and allow the page to refresh.\n\nIn the anchor elements, the best practice is to use title attributes to improve accessibility. The title attribute increases the meaning of the anchor tag. The tag (or anchor element) paired with its attribute, creates a hyperlink to web pages, email addresses, and files. It is used to link locations within the same page or external addresses.\n\nCheck the example under the bad practice column — it’s there for being redundant. This type of practice is evident if a user uses a screen reader to read the anchor tag and read the same text twice to the listener. A screen reader is an assistive technology provided to the visually impaired or those with a learning disability. As a good practice, if you’re just repeating the anchor’s text, then it’s better not to use a title at all.\n\nWebsite development isn’t simply a matter of creating a block of text and headers, link pages, and you’re done. There are some best practices in HTML to consider to make the best of your website.\n\nThe HTML documents will still work without the primary elements: , , and . However, pages may not render correctly if these elements are missing. To that end, it’s important to use proper document structure consistently.\n\nFor a thematic grouping of content, use the section element. According to the W3C specification, a should contain a heading (H1, H2, etc.). Some developers skip the use of the heading element entirely, but we recommend including it to reach those better using screen readers:\n\nThe tag serves as a container for an external resource. This includes web pages, pictures, videos, or plug-ins. However, you must consider that most browsers no longer support Java Applets and plug-ins. What’s more, ActiveX controls are no longer supported in any browser, and the support for Shockwave Flash has also been turned off in modern browsers.\n\nWe recommend the following:\n• For a picture, use the tag.\n• For HTML pulled in from another site, use the tag.\n• For videos or audios, use the and tags.\n\nThe alt attribute in the element provides an image description useful to search engines and screen readers. It can come in especially handy to users when the images can’t be processed:\n\nLeave the alt attribute empty if there’s supplemental text to explain the image. This is to avoid redundancy:\n\nLeave elements empty if there are some restrictions in its content. An empty iframe element is always safe:\n\nDevelopers should provide fallback content, or backup links, for any or elements, just as with images. Fallback content is needed, especially for newly introduced elements in HTML:\n\nHTML documents become complicated, especially for web pages with a lot of content. It’s best to reduce the number of elements on a page to as few as you can manage. Learn how to use the heading elements wisely and follow how to elements denote HTML’s content hierarchy. This makes your content more meaningful for your readers, screen-reading software, and search engines.\n\nFor WordPress developers and content creators, use the element for the blog post’s title instead of the site’s name. This helps in search engine crawling, and this approach is SEO-friendly.\n\nIn addition, use the right HTML element to convey the information it contains to achieve a semantic and meaningful content structure. For example, use for emphasis and for heavy emphasis instead of their predecessors or , which are now deprecated.\n\nJust as importantly, use for paragraphs, and avoid using to add a new line between paragraphs. Instead, make use of CSS margin and/or padding properties to position your content better. Sometimes, you might find yourself tempted to use the tag for indentation purposes. Avoid this pitfall — use it exclusively when quoting text.\n\nOne of the best HTML best practices is to use semantically appropriate elements in your page layout. Several elements will help you organize your layout in sections.\n\nWith the wide breadth of topics under HTML layout, it’s best to highlight the do’s and don’ts in layout quickly. For instance, HTML gives more semantic meaning to the header and footer elements, so don’t neglect the use of the tag as it’s used in any given section or article. Aside from controlling the and tags and other stylistic elements of the document, it’s used in headings, publish dates, and other introductory content of your page or section. Similarly, you can do away with the notion that footers belong to the copyright section only — now, you can use it just about everywhere.\n\nFor the element, you should use it for site-wide navigation. There is no need to declare a role as the usage is already implied in the tag.\n\nAs for the element, it is already part of the latest HTML5 versions, which denote the main content of the document body. So, there is no longer any need to use when we have a more specific tag for our main content.\n\nThe is used for a content block. It is a stand-alone and makes sense without the need to give further explanation, while the tag is used to divide a page into different subject areas or to section an individual article. Unfortunately, many developers still use the two interchangeably.\n\nConsider that the tag is a more generic tag than the tag. This means that the former denotes content related to the topic at hand, but not necessarily self-contained. The latter, conversely, is a stand-alone property.\n\nBut when there’s no appropriate markup tag for your purposes, what should you use? The answer is to use when no other element works or when it’s a specifically stylistic element. For our purposes, using is also a bad practice.\n\nLet’s go back to the tag, which is a semantic markup tag. It is not a stylistic one, and it is important to emphasize it. In effect, a good coding practice should include a heading tag.\n\nNow, the don’ts with follows that you shouldn’t use it to tag a wrapper, a container, or any other purely stylistic block. Below is an example of bad coding practice with the tag:\n\nHere is a better approach, but it overuses the tag:\n\nHence, a much better coding practice is:\n\nA popular part of many layouts are figures for data representation, and the element is mostly used with pictures. However, it has a wider range of possible uses, as anything related to the document could be positioned anywhere and wrapped in a element. Some examples include illustrations, tables, or diagrams in a book.\n\nAn interesting characteristic of is that it does not contribute to the document’s outline. Therefore, you can use it to group elements with a common theme — for instance, several images with one common , or even a block of code.\n\nIn grouping elements with , use . The caption should go either directly after the opening tag, or directly before the closing tag :\n\nHTML is one of the core technologies in web development. It has awesome power and features that made it popular with developers and business owners. Frontend development keeps on innovating, and to keep up with it, developers should know the best practices in HTML scripting.\n\nInline styles will make your code cluttered and unreadable. To that end, always link to and use external stylesheets. Also, avoid using import statements in your CSS files as they produce an extra server request.\n\nThe same goes for inline CSS and JavaScript. Apart from readability issues, this will make your document heavier and more difficult to maintain so that you can avoid inlining code.\n\nUsing lowercase characters in code is an industry-standard practice. Although using uppercase or other text cases will still render your page, the problem is not standardization but code readability.\n\nCode readability is an important aspect of coding as it helps make applications maintainable and secure. Not only that, web development mostly comprises a team. Making your code readable makes your work and the work of your team less complicated.\n\nWhile there are many don’ts in coding HTML, we’ll share two basics don’ts in scripting:\n• Write well-indented and consistently formatted codes: Clean and well-written code promotes better readability on your site, which is a huge help to your developer and other people who might work with the site. It also shows great professionalism and attention to detail, reflecting well on your attitude as a developer.\n• Refrain from including excessive comments: Comments are essential and make your code easier to understand. However, HTML syntax is very self-explanatory, so commenting is not necessary unless you have to clarify semantics and naming conventions.\n\nValidating and minifying codes are used to identify errors early on. Don’t wait until you finish your HTML document — make it a habit to validate and identify errors frequently. You can do validation either manually or use any known validator tool such as W3C Markup Validator.\n\nAt the same time, practice minification by removing anything that is not essential such as comments or whitespace. Ensure that you write clean and concise codes to reduce the size of your HTML file. You can use tools such as HTML Minifier and others.\n\nMany HTML5 best practices resources for 2021 are available online to assist you. However, remember the general rule in coding: consistency. This article has provided basic insights and helped you kick-start that frontend development journey. Using this guide, you’ll be an expert in semantically correct HTML5 in no time.\n\nWhen you’re ready, look beyond what HTML can offer and explore some open source HTML frameworks too for building modern, single-page web apps. They offer excellent synchronization between the data and UI and work seamlessly with CSS and JavaScript.\n\nDid we miss any HTML best practices that you use in your own coding? Let us know in the comments section!"
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Learn_web_development/Getting_started/Your_first_website/Styling_the_content",
        "document": "Like HTML, CSS is not a programming language. It's not a markup language either. CSS is a style sheet language. CSS is what you use to selectively style HTML elements. For example, this CSS selects paragraph text, setting the color to red:\n• Inside your folder, create another new folder called .\n• Using a text editor, paste the three lines of CSS shown above into a new file.\n• Save the file inside your folder with a filename of . To make the code work, we still need to apply this CSS (above) to your HTML document. Otherwise, the styling won't change the appearance of the HTML.\n• Open your file. Paste the following line inside the HTML head (between the and tags):\n• Save and load it in your browser. You should see something like this: If your paragraph text is red, congratulations! Your CSS is working.\n\nLet's dissect the CSS code for red paragraph text to understand how it works: The whole structure is called a ruleset. (The term ruleset is often referred to as just rule.) Note the names of the individual parts: This is the HTML element name at the start of the ruleset. It defines the element(s) to be styled (in this example, elements). To style a different element, change the selector. This is a single rule like . It specifies which of the element's properties you want to style. These are features of an HTML element that you can change the values of, to make it styled differently. (In this example, is a property of the elements.) In CSS, you choose which properties you want to affect in the rule. To the right of the property—after the colon—there is the property value. This chooses one out of many possible appearances for a given property. (For example, there are many values in addition to .) Note the other important parts of the syntax:\n• Apart from the selector, each ruleset must be wrapped in curly braces. ( )\n• Within each declaration, you must use a colon ( ) to separate the property from its value or values.\n• Within each ruleset, you must use a semicolon ( ) to separate each declaration from the next one. To modify multiple property values in one ruleset, write them separated by semicolons, like this:\n\nThere are many different types of selectors. The examples above use element selectors, which select all elements of a given type. But we can make more specific selections as well. Here are some of the more common types of selectors: What does it select All HTML elements of the specified type. The element on the page with the specified ID. On a given HTML page, each id value should be unique. The element(s) on the page with the specified class. Multiple instances of the same class can appear on a page. The element(s) on the page with the specified attribute. The specified element(s), but only when in the specified state. (For example, when a cursor hovers over a link.) \n\nselects , but only when the mouse pointer is hovering over the link. There are many more selectors to discover. To learn more, see our selectors tutorials, starting with Basic selectors.\n\nNow that we've explored some CSS fundamentals, let's improve the appearance of the example by adding more rules and information to the file.\n• First, find the output from Google Fonts that you previously saved from What will your website look like?. Add the element somewhere inside your 's head (anywhere between the and tags). It looks something like this: This code links your page to a style sheet that loads the Open Sans font family with your webpage.\n• Next, delete the existing rule you have in your file. It was a good test, but let's not continue with lots of red text.\n• Add the following lines (shown below), replacing the assignment with your selection from What will your website look like?. The property refers to the font(s) you want to use for text. This rule defines a global base font and font size for the whole page. Since is the parent element of the whole page, all elements inside it inherit the same and . html { font-size: 10px; /* px means \"pixels\": the base font size is now 10 pixels high */ font-family: \"Open Sans\", sans-serif; /* this should be the rest of the output you got from Google Fonts */ } Note: Anything in CSS between and is a CSS comment. The browser ignores comments as it renders the code. CSS comments are a way for you to write helpful notes about your code or logic.\n• Now let's set font sizes for elements that will have text inside the HTML body (<h1>, , and ). We'll also center the heading. Finally, let's expand the second ruleset (below) with settings for line height and letter spacing to make body content more readable. Adjust the values as you like. Your work-in-progress should look similar to this:\n\nSomething you'll notice about CSS as you use it more: a lot of it is about boxes. This includes setting size, color, and position. Most HTML elements on your page can be thought of as boxes sitting on top of other boxes. CSS layout is mostly based on the box model. Each box taking up space on your page has properties like:\n• , the space around the content. In the example below, it is the space around the paragraph text.\n• , the solid line that is just outside the padding.\n• , the space around the outside of the border. In this section we also use:\n• , the color behind an element's content and padding.\n• , the color of an element's content (usually text).\n• sets a drop shadow on the text inside an element.\n• sets the display mode of an element. (keep reading to learn more) To continue, let's add more CSS. Keep adding these new rules at the bottom of . Experiment with changing values to see what happens.\n\nYou may have noticed there's a horrible gap at the top of the body. That happens because browsers apply default styling to the h1 element (among others). That might seem like a bad idea, but the intent is to provide basic readability for unstyled pages. To eliminate the gap, we overwrite the browser's default styling with the setting . Next, we set the heading's top and bottom padding to 20 pixels. Following that, we set the heading text to be the same color as the HTML background color. Finally, applies a shadow to the text content of the element. Its four values are:\n• The first pixel value sets the horizontal offset of the shadow from the text: how far it moves across.\n• The second pixel value sets the vertical offset of the shadow from the text: how far it moves down.\n• The third pixel value sets the blur radius of the shadow. A larger value produces a more fuzzy-looking shadow.\n• The fourth value sets the base color of the shadow. Try experimenting with different values to see how it changes the appearance.\n\nNext, we center the image to make it look better. We could use the same trick as we did for the body. But there are differences that require an additional setting to make the CSS work. The is a block element, meaning it takes up space on the page. The margin applied to a block element will be respected by other elements on the page. In contrast, images are inline elements; for the auto margin trick to work on this image, we must give it block-level behavior using . Finally, we include to make sure that, if the image is larger than the set on the body (600 pixels), it will be displayed at this width, and no bigger. Note: Don't be too concerned if you don't completely understand and the differences between a block element and an inline element, or . They will make more sense as you continue your study of CSS. You can find more information about these properties on MDN's and reference pages."
    },
    {
        "link": "https://etwinworkshop.medium.com/css-fundamentals-enhance-your-html-with-basic-styling-techniques-bab3e905527e",
        "document": "CSS (Cascading Style Sheets) is a powerful tool that allows you to add style and design to your HTML web pages.\n\nIn this post, we’ll delve into CSS properties, selectors, units, and basic styling techniques. By the end, you’ll be able to apply CSS styles to your HTML web pages created earlier.\n\nCSS is used to control the appearance of web pages. It allows you to separate content (HTML) from presentation (CSS), making your web pages more flexible and easier to maintain.\n• Properties: Specify the style to apply.\n• Values: Define the setting for the property.\n\nSelectors are patterns used to select the elements you want to style.\n\nCSS properties are used to style elements. Units define the values of these properties.\n• font-size: Sets the size of the text.\n• em: Relative to the font-size of the element.\n• rem: Relative to the font-size of the root element.\n\nLet’s apply some basic CSS styles to a simple welcome page with a heading and a paragraph.\n• The selector applies a light grey background color and sets the font family to Arial.\n• The selector changes the main heading color to blue, sets the font size, centers the text, and adds a top margin.\n• The selector styles the paragraph with dark grey text color, larger font size, centered text, margin, width, line-height, background color, padding, rounded corners, and a subtle shadow.\n\nTo further enhance your understanding of CSS, you can explore the following resources:\n• CSS Tricks — Articles, guides, and tips for all things CSS.\n\nBy learning CSS fundamentals, you can enhance the appearance of your HTML web pages. Understanding selectors, properties, units, and basic styling techniques allows you to create visually appealing and responsive designs.\n\nPractice applying CSS styles to your HTML content to become more proficient and confident in your web development skills."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Learn_web_development/Core/Styling_basics",
        "document": "CSS allows you to create great-looking web pages, but how does it work under the hood? This article explains what CSS, what the basic syntax looks like, and how your browser applies CSS to HTML to style it.\n\nIn this article, we will take a simple HTML document and apply CSS to it, learning some practical details of the language along the way. We will also review the CSS syntax features you've not looked at yet.\n\nAs you know from your study of HTML, elements can have attributes that give further detail about the element being marked up. In CSS you can use attribute selectors to target elements with certain attributes. This lesson will show you how to use these very useful selectors.\n\nThe next set of selectors we will look at are referred to as pseudo-classes and pseudo-elements. There are a large number of these, and they often serve quite specific purposes. Once you know how to use them, you can look through the different types to see if there is something which works for the task you are trying to achieve.\n\nThe final selectors we will look at are called combinators. Combinators are used to combine other selectors in a way that allows us to select elements based on their location in the DOM relative to other elements (for example, child or sibling).\n\nEverything in CSS has a box around it, and understanding these boxes is key to being able to create more complex layouts with CSS, or to align items with other items. In this lesson, we will take a look at the CSS Box model. You'll get an understanding of how it works and the terminology that relates to it.\n\nThe aim of this lesson is to develop your understanding of some of the most fundamental concepts of CSS — the cascade, specificity, and inheritance — which control how CSS is applied to HTML and how conflicts between style declarations are resolved.\n\nCSS rules contain declarations, which in turn are composed of properties and values. Each property used in CSS has a value type that describes what kind of values it is allowed to have. In this lesson, we will take a look at some of the most frequently used value types, what they are, and how they work.\n\nUnderstanding how big the different features in your design will be is important. In this lesson we will summarize the various ways elements get a size via CSS and define a few terms about sizing that will help you in the future.\n\nIn this lesson, we will take a look at some of the creative things you can do with CSS backgrounds and borders. From adding gradients, background images, and rounded corners, backgrounds and borders are the answer to a lot of styling questions in CSS.\n\nIn this lesson we will take a look at how certain special elements are treated in CSS. Images, other media, and form elements behave a little differently from regular boxes in terms of your ability to style them with CSS. Understanding what is and isn't possible can save some frustration, and this lesson will highlight some of the main things that you need to know.\n\nThis article will give you guidance on how to go about debugging a CSS problem, and show you how the DevTools included in all modern browsers can help you to find out what is going on."
    },
    {
        "link": "https://nobledesktop.com/learn/html-css/a-beginners-guide-to-css-styling-your-first-web-page",
        "document": "Discover the art of coding links for external websites and internal pages through our HTML & CSS tutorial that delves into the use of anchor tags, hrefs, and the method of opening a link in a fresh browser window/tab."
    },
    {
        "link": "https://w3schools.com/html/html_css.asp",
        "document": "CSS saves a lot of work. It can control the layout of multiple web pages all at once.\n\nCascading Style Sheets (CSS) is used to format the layout of a webpage.\n\nWith CSS, you can control the color, font, the size of text, the spacing between elements, how elements are positioned and laid out, what background images or background colors are to be used, different displays for different devices and screen sizes, and much more!\n\nTip: The word cascading means that a style applied to a parent element will also apply to all children elements within the parent. So, if you set the color of the body text to \"blue\", all headings, paragraphs, and other text elements within the body will also get the same color (unless you specify something else)!\n\nCSS can be added to HTML documents in 3 ways:\n• Inline - by using the attribute inside HTML elements\n• Internal - by using a element in the section\n• External - by using a element to link to an external CSS file\n\nThe most common way to add CSS, is to keep the styles in external CSS files. However, in this tutorial we will use inline and internal styles, because this is easier to demonstrate, and easier for you to try it yourself.\n\nAn inline CSS is used to apply a unique style to a single HTML element.\n\nAn inline CSS uses the attribute of an HTML element.\n\nThe following example sets the text color of the element to blue, and the text color of the element to red:\n\nAn internal CSS is used to define a style for a single HTML page.\n\nAn internal CSS is defined in the section of an HTML page, within a element.\n\nThe following example sets the text color of ALL the elements (on that page) to blue, and the text color of ALL the elements to red. In addition, the page will be displayed with a \"powderblue\" background color:\n\nAn external style sheet is used to define the style for many HTML pages.\n\nTo use an external style sheet, add a link to it in the section of each HTML page:\n\nThe external style sheet can be written in any text editor. The file must not contain any HTML code, and must be saved with a .css extension.\n\nHere is what the \"styles.css\" file looks like:\n\nHere, we will demonstrate some commonly used CSS properties. You will learn more about them later.\n\nThe CSS property defines the text color to be used.\n\nThe CSS property defines the font to be used.\n\nThe CSS property defines the text size to be used.\n\nThe CSS property defines a border around an HTML element.\n\nTip: You can define a border for nearly all HTML elements.\n\nThe CSS property defines a padding (space) between the text and the border.\n\nThe CSS property defines a margin (space) outside the border.\n\nExternal style sheets can be referenced with a full URL or with a path relative to the current web page.\n• Use the HTML attribute for inline styling\n• Use the HTML element to define internal CSS\n• Use the HTML element to refer to an external CSS file\n• Use the HTML element to store <style> and <link> elements\n• Use the CSS property for text colors\n• Use the CSS property for text fonts\n• Use the CSS property for text sizes\n• Use the CSS property for borders\n• Use the CSS property for space inside the border\n• Use the CSS property for space outside the border"
    },
    {
        "link": "https://freecodecamp.org/news/create-and-validate-modern-web-forms-html5",
        "document": "HTML forms consist of a body of text boxes, buttons, dropdowns and other selection widgets. Web developers use these elements to receive users' information on a website.\n\nIf you've ever searched on Google, signed up or logged into a website, made a payment, or responded to a questionnaire, you have interacted with a web form.\n\nWhen building for the web, you must ensure that your application is accessible to all users. This includes those who require assistive technologies such as screen readers to navigate a website.\n\nHTML5 has semantic form elements which are the best way to achieve this. Thankfully, the benefits are beyond accessibility:\n• They make it easier to develop because they come with some free functionality, and is generally easier to understand.\n• Better on mobile — semantic HTML is easier to make responsive for different screen sizes. Its file are generally lighter than non-semantic spaghetti code.\n• Good for SEO — your web page will have a higher chance of being found by customers because search engines prioritize keywords inside headings, links, and so on over those in non-semantic s etc.\n\nIn this article, we’re going to discuss the latest elements and attributes in HTML5 forms that you can use to build and validate the simple yet modern form you see here:\n\nYou can see the source code here.\n\nHow to Use New HTML5 Form Elements\n\nOver the years, web forms have gone through various changes until the arrival of HTML5.\n\nWith the introduction of new and improved HTML5 elements and their attributes, anyone can learn to build beautiful, functional, and accessible forms.\n\nOut of the numerous form elements, some of the most essential include:\n\nYou use the tag to group related elements (controls and labels) in a web form by drawing a box around them. It usually contains elements like legend, label and inputs.\n\nYou use the tag to define captions for fieldset elements. This way it can also be used as a way to group elements. And the tag gives a definition to several elements.\n\nYou should always link the tag to an element because:\n• A user can focus on the input by clicking the label\n• When the input is focused, screen readers read out the label to help differently-abled users.\n• For checkboxes, especially on mobile, users who aren't able to easily click on smaller items can click on the label to toggle the checkbox on.\n\nIn the code above, we're using the fieldset tag to create an initial group tagged \"first-section\". The legend tag contains text that provides a description for the group of elements. Finally, the label tag identifies each of the inputs and their purpose.\n\nHow to Use Placeholder Text\n\nYou use placeholder text within input fields, and it's only removed when the input field is focused or filled.\n\nUsually, placeholder text has a lighter font color compared to the color of the input labels and values. You'll mostly use placeholders to give a user further insights as to what to fill out in a form. Here's an example:\n\nThe type=\"email\" attribute ensures that the input doesn't accept any other value than emails. The id attribute links the input element to its label to allow for association and focusing. The \"ob2@hotmail.com\" gives the user a hint of the kind of value the input expects.\n\nHow to Use Focus\n\nInitially, users had to click within the first input box in a form in order to start filling it out. But HTML5 lets web developers place emphasis on the inputs users should interact with first.\n\nAutofocus is an attribute that you can add on an or element for this purpose. It's an important accessibility feature too because it makes life easier for people who use screen readers, for example.\n\nHere's an example of how to use autofocus:\n\nAs seen in the code above, you can put the autofocus attribute anywhere within the input tag. It's often followed or surrounded by the other generic attributes like name, id, and so on.\n\nHow to Use New HTML5 Inputs\n\nIt's probably safe to say that is the most popular attribute of a web form. Actually, everything in a form is an input because it requires some form of data from users. You use this attribute the most to receive text, numbers and emails, and so on.\n\nVarious elements are differentiated using the value of the type attribute in inputs. Below are three new and useful examples:\n\nHow to Use the Search Element\n\nYou use the search element to let users enter queries when they need to search for something. It is very similar to text inputs.\n\nThe main thing that differentiates them would be in the styling as accessing the input using the type input[type=search] tends to be super handy as compared to giving a text input a class.\n\nOn certain browsers like Chrome, once you start typing, an 'x' icon is placed at the end of the input field. Clicking on this icon clears the value typed into the input and using the esc key on your keyboard gives the same result.\n\nHow to Use the Hidden Element\n\nWeb developers use hidden elements to render an input's content hidden and inaccessible to a user interacting with a form. This input type doesn't exactly render visually. Its content is not seen by the user but upon submitting the form, its sent to the server.\n\nHow to Use the Progress Element\n\nThis is an element you can use to indicate the progress of a task. The max attribute is used to indicate the total value of the progress bar. The value attribute essentially shows the percentage of the task that's been completed by coloring in the bar to that extent. The id attribute, as always, is used to link to the the label.\n\nUnlike the input with the type range, the progress element does not allow users to make changes. Instead, it communicates in a read-only style.\n\nHow to Use the Data List Element\n\nThe data list element specifies a list of pre-defined options for an element. It's often used to offer autocomplete features for a list of items. This is because once you start typing, you get a preview of the list of options available.\n\nAs shown below, in order to link an tag with a , you have to ensure the value of the 'list' attribute is the same as the 'id' on the datalist.\n\nThis input is rendered differently on the various browsers:\n\nChrome: Once you hover on the input, there's a dropdown icon added at the end of the input. When you click within the input or on the label, the values of the various options are also shown in a dropdown.\n\nFirefox: In order to see the option values, the user has to enter a part of the text and the options will be displayed in sort of an autocomplete style.\n\nBuilding the form is the first step in this process. As a developer, you have to always make sure that your users are providing accurate responses. This is necessary because you shouldn't assume that users will do the right thing.\n\nThis is the concept of validation in forms – preventing mistakes or catching them as soon as they happen.\n\nThere are two popular types of validating a web form. They are:\n\nClient-side validation can be linked to the 'preventing mistakes' part of validation. It involves strategies such as doing certain checks in the browser before submitting the form.\n\nMethods of client-side validation include adding error popups and not letting a user proceed until they fill in the correct info.\n\nServer-side validation can be linked to the 'catching mistakes' part of validation.\n\nUnlike the client-side, this type doesn't check for errors while users are still on the form. Instead it checks when the form data is sent to your web server.\n\nIn this case, you'd show an error page as feedback to indicate the presence of errors.\n\nSome examples of basic client-side validation include \"This field is required\", \"Enter a valid email\", and \"Password should be at least 8 characters long\".\n\nThese are just a few of the many error messages thrown at users when they don't enter data in the format a form expects.\n\nThe most commonly used of these attributes include:\n• Required: Specifies input fields that need to be filled in before submitting the form.\n• Minlength and Maxlength: Specify a string's minimum and maximum length expected.\n• Min and Max: Specify the minimum and maximum values of numbers.\n• Type: Specifies what kind of data is needed for specific input fields, for example date, number, name, email, and so on.\n\nAs the name suggests, the Constraint Validation API is a Web API that offers validating features to web forms. You can use its new properties and methods to modify a form input's validity.\n\nDevelopers can now easily give custom functionality and error messages. Basically, this API allows you to detect errors and display a custom message based on the type of error.\n\nYou can create custom validation and error messages with the setCustomValidity method as well as the validationMessage property.\n\nOther Helpful Elements to Know\n\nPutting it All Together\n\nHere's the outcome of putting the various elements you've learned about in this article together:\n\nHere's the code for that:\n\nThe new HTML5 form elements and attributes make it easy to access certain essential functionalities. Especially those that were otherwise only possible with CSS or many lines of JavaScript.\n\nIt's now easier than ever to create web forms that are both modern and functional with only HTML. Most importantly, it brings peace of mind to web developers. Because you know that you can easily create forms that will be uniform across the various browsers.\n\nThanks for reading 👋🏾. I hope you found this helpful."
    },
    {
        "link": "https://blog.pixelfreestudio.com/best-practices-for-html5-form-validation",
        "document": "Forms are a crucial part of any website. They help gather information from users, whether it’s for signing up, logging in, or submitting feedback. However, to ensure the data collected is accurate and useful, proper validation is essential. HTML5 introduces powerful form validation features that make this task easier and more efficient. In this guide, we’ll explore the best practices for HTML5 form validation to help you create user-friendly and secure forms.\n\nHTML5 form validation provides a way to ensure that user input matches certain criteria before the form is submitted. This can be done using built-in attributes and methods, which offer a simple yet effective way to validate user input without relying on JavaScript for basic validation tasks.\n\nHTML5 comes with several built-in validation attributes that you can use to enforce rules on user input. These attributes include , , , , , , , and .\n\nUsing these attributes, you can set various constraints on form fields.\n\nIn this example, the attribute ensures that the fields are not left empty. The and attributes set limits on the number of characters for the username.\n\nThe ensures that the email address is in the correct format, and the and attributes set age constraints.\n\nOne of the key advantages of HTML5 form validation is providing real-time feedback to users. This immediate response can guide users to correct their input before submitting the form, leading to a smoother and more pleasant experience.\n\nIn this example, as the user types their password, real-time feedback is provided if the password does not meet the required pattern.\n\nWhile the default validation messages provided by browsers are functional, customizing these messages can improve user experience by providing more specific guidance.\n\nThis script provides custom feedback based on the user’s input, making the validation messages more informative and helpful.\n\nThe attribute allows you to define a regular expression that the input field’s value must match. This is particularly useful for fields like phone numbers, postal codes, and custom formats.\n\nExample of Using the Attribute\n\nIn this example, the attribute ensures that the phone number entered matches the specified format.\n\nWhile HTML5 validation handles many scenarios, some complex validations require JavaScript. For instance, checking that two password fields match or ensuring a username is available can’t be done with HTML5 alone.\n\nThis example checks if the password and confirm password fields match and provides real-time feedback to the user.\n\nConditional validation is useful when the requirements for a field depend on the value of another field. For example, additional fields might be required if a specific option is selected from a dropdown menu.\n\nIn this example, the employer name field is required only if the user selects “Employed” as their employment status.\n\nCSS can be used to style form fields based on their validation state, providing visual feedback to users. You can use the and pseudo-classes to apply styles.\n\nHere, valid fields have a green border, while invalid fields have a red border, giving users immediate visual feedback.\n\nThe Constraint Validation API provides methods and properties to customize and control form validation. You can use it to check the validity of form fields and display custom validation messages.\n\nExample of Using the Constraint Validation API\n\nThis example uses the Constraint Validation API to provide custom validation messages and ensure form fields meet the specified criteria.\n\nWhile client-side validation improves user experience by providing immediate feedback, it’s crucial to implement server-side validation as well. This ensures that data is validated regardless of the client’s capabilities or actions and protects against malicious inputs.\n\nExample of Server-Side Validation (Node.js and Express)\n\nThis example demonstrates how to validate form data on the server using Node.js and Express. It checks the username length and the email format before accepting the submission.\n\nBest Practices for Form Design and Validation\n\nA simple and focused form is easier for users to complete. Avoid unnecessary fields and break long forms into smaller sections if needed.\n\nEnsure that all form fields have clear labels and instructions. Use real-time feedback to guide users as they fill out the form.\n\nMake sure your forms are accessible to all users, including those using assistive technologies. Use proper HTML semantics and ARIA attributes where necessary.\n\nTest your forms across different browsers and devices to ensure they work correctly for all users. This includes testing both client-side and server-side validation.\n\nProtect your forms against common security threats such as cross-site scripting (XSS) and SQL injection. Use server-side validation and sanitize user inputs.\n\nReal-time feedback and error handling can significantly enhance the user experience by guiding users through the form completion process. Implementing these features ensures users understand exactly what is required and can correct errors immediately.\n\nExample of Real-Time Feedback with Custom Messages\n\nThis example provides immediate feedback to the user as they input their email and phone number, ensuring the data format is correct before submission.\n\nJavaScript can handle complex validation scenarios that go beyond what HTML5 attributes can manage. This is useful for custom validation rules, dynamic form changes, and cross-field validation.\n\nThis example checks if the password and confirm password fields match, providing real-time feedback and preventing form submission if the passwords do not match.\n\nWhile client-side validation enhances user experience by providing instant feedback, it should not replace server-side validation. Combining both ensures robust security and data integrity.\n\nExample of Combined Client-Side and Server-Side Validation (PHP)\n\nIn this example, the client-side script validates the form before submission, and the server-side script revalidates the data for security.\n\nAccessibility is critical to ensure that all users, including those with disabilities, can use your forms. Use ARIA attributes and accessible error messages to improve usability.\n\nThis example uses ARIA attributes to make error messages accessible, ensuring that screen readers can announce them to users.\n\nHTML5 introduces new input types for dates and times, such as , , , , and . These types offer built-in validation and user-friendly interfaces, but they also require specific handling to ensure compatibility across different browsers.\n\nExample of Date and Time Input Validation\n\nIn this example, the form ensures that users provide valid date and time inputs. The JavaScript script further checks the validity of each field before submission.\n\nFile inputs require special validation to ensure that users upload the correct type and size of files. HTML5 provides the attribute to specify the types of files allowed, but additional JavaScript validation is often needed.\n\nThis example validates that the uploaded file is of the correct type and size, providing immediate feedback to the user if the file does not meet the criteria.\n\nMulti-step forms break down long forms into smaller, more manageable sections. Each step should be validated before moving on to the next to ensure that users provide complete and accurate information.\n\nThis example demonstrates a multi-step form where each step is validated before moving to the next, ensuring users provide all required information incrementally.\n\nFor applications targeting a global audience, localizing validation messages is crucial. You can provide custom validation messages in multiple languages using JavaScript.\n\nThis example provides validation messages in both English and Spanish, switching the language by changing the variable.\n\nWhile HTML5 provides robust validation tools, third-party libraries can offer additional features and flexibility. Libraries like or enhance form validation with more options and ease of use.\n\nExample of Using Parsley.js\n\nParsley.js makes it easy to add client-side form validation with minimal setup. It supports various validation rules and provides a straightforward way to enhance your forms.\n\nCAPTCHA (Completely Automated Public Turing test to tell Computers and Humans Apart) is an effective tool to prevent automated bots from submitting your forms.\n\nIt adds an extra layer of security by requiring users to complete a challenge.\n\nThis example integrates Google reCAPTCHA into the form, providing an extra layer of security to ensure that submissions are made by real users.\n\nModern browsers come with built-in capabilities that can enhance form validation and user experience. Ensuring compatibility across different browsers and utilizing their native features can save time and effort.\n\nExample of Using Browser-Specific Features\n\nIn this example, the and input types leverage browser capabilities to ensure proper formatting and validation.\n\nPlaceholder text can guide users on what to input, improving form completion rates and accuracy. However, it’s important to ensure placeholders are not used as a substitute for proper labels.\n\nExample of Using Placeholder Text\n\nAuto-complete attributes help users fill out forms more quickly by suggesting previously entered values. This feature enhances usability and reduces input errors.\n\nExample of Using Auto-Complete\n\nContextual help can assist users in filling out forms correctly by providing additional information or examples. This can be achieved using tooltips, hints, or help icons.\n\nExample of Providing Contextual Help\n\nReducing the number of form fields can significantly improve form completion rates. Only ask for information that is necessary and consider breaking long forms into multi-step processes.\n\nWith the increasing use of mobile devices, ensuring your forms are mobile-friendly is essential. Use responsive design techniques to make forms easy to complete on smaller screens.\n\nProgressive disclosure involves showing only a few fields initially and revealing additional fields as needed. This technique helps prevent users from feeling overwhelmed.\n\nAfter form submission, providing a clear confirmation message reassures users that their information has been received. This can be a thank you message, a summary of their submission, or a confirmation email.\n\nA/B testing involves creating multiple versions of your form to see which performs better. This can help you optimize form fields, design, and validation messages to improve conversion rates.\n\nExample of Setting Up A/B Testing\n\nUsing AJAX, you can validate form data in real-time against server-side logic without requiring a page refresh. This is particularly useful for checking data like usernames or email addresses for availability.\n\nThis example uses an AJAX request to check if a username is already taken when the input field loses focus.\n\nIn some forms, the validity of one field might depend on another. For instance, a “State” field should be required only if the “Country” field is set to a specific value.\n\nThis example shows or hides the “State” field based on the selected country, dynamically adjusting its required attribute.\n\nRegular expressions (regex) are powerful tools for validating complex patterns such as serial numbers, license keys, or specific formats that built-in HTML5 validation can’t handle.\n\nExample of Using Regular Expressions for Validation\n\nIn this example, the attribute uses a regex to ensure the serial number matches the specified format.\n\nSometimes, users might encounter edge cases that are not covered by standard validation rules. Preparing for these cases ensures a smooth user experience.\n\nThis example ensures that the phone number is exactly 10 digits long, providing custom feedback if it is not.\n\nHidden fields can be used to pass additional data to the server without displaying it to the user. This is useful for tracking, session management, or including metadata.\n\nExample of Using Hidden Fields\n\nIn this example, a hidden field is used to pass a session ID along with the form data.\n\nSometimes, integrating third-party APIs can enhance the validation process by verifying data like addresses, phone numbers, or credit card information.\n\nExample of Using a Third-Party API for Address Validation\n\nThis example validates an address using a third-party API when the input field loses focus.\n\nEffective HTML5 form validation is essential for creating user-friendly and secure web applications. By utilizing built-in validation attributes, JavaScript for advanced scenarios, real-time feedback with AJAX, and integrating third-party APIs, you can ensure accurate data collection while enhancing user experience.\n\nImplementing best practices like mobile-friendly design, progressive disclosure, and providing contextual help further optimizes the user journey. These strategies together make your forms robust, accessible, and efficient, ensuring data integrity and user satisfaction.\n• How to Use CSS Grid for Complex Layouts\n• The Importance of Code Reviews in Frontend Development"
    },
    {
        "link": "https://savannahsoftwaresolutions.co.ke/a-beginners-guide-to-creating-custom-form-validation-in-html5-and-javascript",
        "document": "In the digital age, forms are essential components of web applications, serving as the primary means for users to interact with websites. Whether it is signing up for a newsletter, entering payment information, or submitting feedback, forms collect critical data that can influence user experience and business outcomes. However, ensuring that users input valid data is equally important; this is where form validation comes into play. This guide will provide a comprehensive overview of custom form validation using HTML5 and JavaScript, covering everything from basic validation techniques to advanced custom solutions. By the end of this article, you will have the knowledge and tools necessary to implement effective form validation in your web applications.\n\nForms are ubiquitous on the internet, and they play a crucial role in user interaction. However, poorly designed forms can lead to user frustration, data entry errors, and ultimately lost opportunities. Form validation ensures that the data submitted by users meets specific criteria before it is processed. This not only enhances data integrity but also improves user experience by providing immediate feedback on input errors.\n\nHTML5 introduced several built-in validation features that simplify the process of validating form inputs without requiring extensive JavaScript code. These features include attributes such as , , , , , and . While these attributes can handle many common validation scenarios, there are instances where more complex validation rules are needed. In such cases, JavaScript comes into play, allowing developers to create custom validation logic tailored to specific requirements.\n\nIn this guide, we will explore both HTML5 built-in validation features and custom JavaScript validation techniques. We will start with the basics of form creation and validation attributes before moving on to more advanced topics such as dynamic validation rules and error message handling. Throughout this article, we will provide practical examples and best practices to ensure that you can implement effective form validation in your projects.\n\nHTML5 form validation refers to the set of features introduced in HTML5 that allow developers to validate user input directly within the browser before submitting a form. This client-side validation reduces server load and improves user experience by providing immediate feedback on input errors.\n\nHTML5 provides several built-in attributes that can be added to form elements to enforce specific validation rules:\n• required: This attribute specifies that a field must be filled out before submitting the form. If the field is empty, the browser will display an error message.\n• pattern: The pattern attribute allows you to specify a regular expression that the input value must match for the form submission to be successful.\n• min and max: These attributes set minimum and maximum values for numeric inputs.\n• minlength and maxlength: These attributes define the minimum and maximum number of characters allowed in text inputs.\n• type: The type attribute specifies the kind of data expected (e.g., email, number, date). Using appropriate types helps browsers apply relevant validations automatically.\n\nHere’s an example of a simple registration form utilizing various HTML5 validation attributes:\n\nIn this example:\n• The email field must contain a valid email format.\n• The password field requires at least 8 characters.\n\nWhile HTML5 provides powerful built-in validation features, there are scenarios where custom logic is necessary. For example, you may need to validate multiple fields against each other or implement complex rules that cannot be expressed using standard attributes alone.\n\nLet’s create a more comprehensive registration form with additional fields and custom JavaScript validation:\n\nNow we will write JavaScript code to validate our form before submission:\n• Event Listener: We attach an event listener to handle the event on our form.\n• Prevent Default Submission: The default action is prevented using , allowing us to validate inputs first.\n• Input Retrieval: We retrieve values from each input field.\n• Check if the username length is within specified limits.\n• If any validations fail, we push corresponding messages into an array.\n• If there are errors, we display them below the form; otherwise, we simulate successful registration.\n\nWhile validating forms upon submission is essential, providing real-time feedback as users fill out fields can significantly enhance user experience. This approach allows users to correct mistakes immediately rather than waiting until they submit the entire form.\n\nTo implement real-time validation feedback in our registration form:\n• Update your JavaScript code as follows:\n• We add event listeners for each relevant input field that trigger on user input ( event).\n• We check conditions similar to those used during submission.\n• If conditions fail, we use to set a custom error message which will be displayed when users attempt to submit.\n\nThis approach provides instant feedback without waiting for form submission, enhancing overall usability.\n\nWhen implementing form validation in your web applications, consider these best practices:\n\nA well-designed form should be easy to understand and fill out. Avoid overwhelming users with too many fields at once; instead, use progressive disclosure techniques where necessary.\n\nEnsure all fields have clear labels and instructions explaining what information is expected from users. Use tooltips or placeholder text where appropriate to guide users through filling out forms correctly.\n\nWhile client-side validation enhances user experience by catching errors early on—always follow up with server-side validation as well! Client-side checks can be bypassed by malicious users; hence server-side checks ensure data integrity regardless of client behavior.\n\nMake sure your forms are accessible to all users—including those utilizing assistive technologies like screen readers! Utilize proper HTML semantics (e.g., elements associated with inputs) along with ARIA attributes when necessary so everyone can effectively interact with your forms!\n\nDifferent browsers may interpret HTML5 validations differently; therefore testing across various browsers ensures consistent behavior before deployment!\n\nCreating custom form validations using HTML5 & JavaScript empowers developers with tools necessary for building secure & user-friendly applications! Throughout this guide we’ve covered everything—from foundational concepts surrounding built-in validations through detailed implementations showcasing their capabilities within various contexts—all while emphasizing best practices ensuring optimal performance throughout development cycles!\n\nAs you continue exploring these technologies remember there are endless possibilities available when leveraging powerful tools like HTML alongside robust scripting languages like JavaScript! Whether you’re looking into adding advanced features or refining existing ones—embracing these concepts will undoubtedly enhance both user experiences & overall application effectiveness! Happy coding!"
    },
    {
        "link": "https://stackoverflow.com/questions/12035396/custom-form-validation-function-on-element-with-html-5",
        "document": "For a custom image selection tool I would like to create form validation based on html 5 form validation.\n\nFor example my form consists of the following elements:\n\nI have a Javascript that changes the textarea (.cms-input-file) into some html to add images and hides the original textarea. It looks something like this:\n\nSince I have allot of existing forms using html5 form validation I would like to validate this element using the default form validation within html5 supported browsers, but using a hopefully existing event.\n\nI'm looking for something like this:\n\nDoes anyone know if something like this is possible using default html 5 events or how would I go about adding this event to the submit event? To actually trigger the default browser validation look and feel.\n\nSo far I have made an attempt to get this result using a div element which hides the original element. But now I need to add a pattern to the element to match according to my options. Is this possible?"
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Learn_web_development/Extensions/Forms/Form_validation",
        "document": "It is important to ensure all required form controls are filled out, in the correct format, before submitting user entered form data to the server. This client-side form validation helps ensure data entered matches the requirements set forth in the various form controls. This article leads you through basic concepts and examples of client-side form validation. To understand what client-side form validation is, why it's important, and how to apply various techniques to implement it. Client-side validation is an initial check and an important feature of good user experience; by catching invalid data on the client-side, the user can fix it straight away. If it gets to the server and is then rejected, a noticeable delay is caused by a round trip to the server and then back to the client-side to tell the user to fix their data. However, client-side validation should not be considered an exhaustive security measure! Your apps should always perform validation, including security checks, on any form-submitted data on the server-side as well as the client-side, because client-side validation is too easy to bypass, so malicious users can still easily send bad data through to your server. Note: Read Website security for an idea of what could happen; implementing server-side validation is somewhat beyond the scope of this module, but you should bear it in mind.\n\nGo to any popular site with a registration form, and you will notice that they provide feedback when you don't enter your data in the format they are expecting. You'll get messages such as:\n• \"This field is required\" (You can't leave this field blank).\n• \"Please enter your phone number in the format xxx-xxxx\" (A specific data format is required for it to be considered valid).\n• \"Please enter a valid email address\" (the data you entered is not in the right format).\n• \"Your password needs to be between 8 and 30 characters long and contain one uppercase letter, one symbol, and a number.\" (A very specific data format is required for your data). This is called form validation. When you enter data, the browser (and the web server) will check to see that the data is in the correct format and within the constraints set by the application. Validation done in the browser is called client-side validation, while validation done on the server is called server-side validation. In this chapter we are focusing on client-side validation. If the information is correctly formatted, the application allows the data to be submitted to the server and (usually) saved in a database; if the information isn't correctly formatted, it gives the user an error message explaining what needs to be corrected, and lets them try again. We want to make filling out web forms as easy as possible. So why do we insist on validating our forms? There are three main reasons:\n• We want to get the right data, in the right format. Our applications won't work properly if our users' data is stored in the wrong format, is incorrect, or is omitted altogether.\n• We want to protect our users' data. Forcing our users to enter secure passwords makes it easier to protect their account information.\n• We want to protect ourselves. There are many ways that malicious users can misuse unprotected forms to damage the application. See Website security. Warning: Never trust data passed to your server from the client. Even if your form is validating correctly and preventing malformed input on the client-side, a malicious user can still alter the network request.\n\nA common HTML validation feature is the attribute. Add this attribute to an input to make an element mandatory. When this attribute is set, the element matches the UI pseudo-class and the form won't submit, displaying an error message on submission, if the input is empty. While empty, the input will also be considered invalid, matching the UI pseudo-class. If any radio button in a same-named group has the attribute, one of the radio buttons in that group must be checked for the group to be valid; the checked radio doesn't have to be the one with the attribute set. Note: Only require users to input data you need: For example, is it really necessary to know someone's gender or title? Add a attribute to your input, as shown below. We added \"(required)\" to the to inform the user that the is required. Indicating to the user when form fields are required is not only good user experience, it is required by WCAG accessibility guidelines. We include CSS styles that are applied based on whether the element is required, valid, and invalid: This CSS causes the input to have a red dashed border when it is invalid and a more subtle solid black border when valid. We also added a background gradient when the input is required and invalid. Try out the new behavior in the example below: Try submitting the form from the live example without a value. Note how the invalid input gets focus, a default error message (\"Please fill out this field\") appears, and the form is prevented from being sent. You can also see the source code on GitHub.\n\nAnother useful validation feature is the attribute, which expects a Regular Expression as its value. A regular expression (regexp) is a pattern that can be used to match character combinations in text strings, so regexps are ideal for form validation and serve a variety of other uses in JavaScript. Regexps are quite complex, and we don't intend to teach you them exhaustively in this article. Below are some examples to give you a basic idea of how they work.\n• — Matches one character that is (not , not , and so on).\n• — Matches , followed by , followed by .\n• — Matches , optionally followed by a single , followed by . ( or )\n• — Matches , optionally followed by any number of s, followed by . ( , , , and so on).\n• — Matches one character that is or .\n• — Matches exactly or exactly (but not or or , and so on). There are many more possibilities that we don't cover here. For a complete list and many examples, consult our Regular expression documentation. Let's implement an example. Update your HTML to add a attribute like this: This gives us the following update — try it out: You can find this example live on GitHub along with the source code. In this example, the element accepts one of four possible values: the strings \"banana\", \"Banana\", \"cherry\", or \"Cherry\". Regular expressions are case-sensitive, but we've made it support capitalized as well as lower-case versions using an extra \"Aa\" pattern nested inside square brackets. At this point, try changing the value inside the attribute to equal some of the examples you saw earlier, and look at how that affects the values you can enter to make the input value valid. Try writing some of your own, and see how it goes. Make them fruit-related where possible so that your examples make sense! If a non-empty value of the doesn't match the regular expression's pattern, the will match the pseudo-class. If empty, and the element is not required, it is not considered invalid. Some element types don't need a attribute to be validated against a regular expression. For example, specifying the type validates the inputs value against a well-formed email address pattern or a pattern matching a comma-separated list of email addresses if it has the attribute.\n\nThe Constraint Validation API consists of a set of methods and properties available on the following form element DOM interfaces: The Constraint Validation API makes the following properties available on the above elements.\n• : Returns a localized message describing the validation constraints that the control doesn't satisfy (if any). If the control is not a candidate for constraint validation ( is ) or the element's value satisfies its constraints (is valid), this will return an empty string.\n• : Returns a object that contains several properties describing the validity state of the element. You can find full details of all the available properties in the reference page; below is listed a few of the more common ones:\n• : Returns if the value does not match the specified , and if it does match. If true, the element matches the CSS pseudo-class.\n• : Returns if the value is longer than the maximum length specified by the attribute, or if it is shorter than or equal to the maximum. If true, the element matches the CSS pseudo-class.\n• : Returns if the value is shorter than the minimum length specified by the attribute, or if it is greater than or equal to the minimum. If true, the element matches the CSS pseudo-class.\n• : Returns if the value is greater than the maximum specified by the attribute, or if it is less than or equal to the maximum. If true, the element matches the and CSS pseudo-classes.\n• : Returns if the value is less than the minimum specified by the attribute, or if it is greater than or equal to the minimum. If true, the element matches the and CSS pseudo-classes.\n• : Returns if the value is not in the required syntax (when is or ), or if the syntax is correct. If , the element matches the CSS pseudo-class.\n• : Returns if the element meets all its validation constraints, and is therefore considered to be valid, or if it fails any constraint. If true, the element matches the CSS pseudo-class; the CSS pseudo-class otherwise.\n• : Returns if the element has a attribute, but no value, or otherwise. If true, the element matches the CSS pseudo-class.\n• : Returns if the element will be validated when the form is submitted; otherwise. The Constraint Validation API also makes the following methods available on the above elements and the element.\n• : Returns if the element's value has no validity problems; otherwise. If the element is invalid, this method also fires an event on the element.\n• : Reports invalid field(s) using events. This method is useful in combination with in an event handler.\n• : Adds a custom error message to the element; if you set a custom error message, the element is considered to be invalid, and the specified error is displayed. This lets you use JavaScript code to establish a validation failure other than those offered by the standard HTML validation constraints. The message is shown to the user when reporting the problem. As you saw in the HTML validation constraint examples earlier, each time a user tries to submit an invalid form, the browser displays an error message. The way this message is displayed depends on the browser. These automated messages have two drawbacks:\n• There is no standard way to change their look and feel with CSS.\n• They depend on the browser locale, which means that you can have a page in one language but an error message displayed in another language, as seen in the following Firefox screenshot. Customizing these error messages is one of the most common use cases of the Constraint Validation API. Let's work through an example of how to do this. We'll start with some HTML (feel free to put this in a blank HTML file; use a fresh copy of fruit-start.html as a basis, if you like): <form> <label for=\"mail\"> I would like you to provide me with an email address: </label> <input type=\"email\" id=\"mail\" name=\"mail\" /> <button>Submit</button> </form> Add the following JavaScript to the page: const email = document.getElementById(\"mail\"); email.addEventListener(\"input\", (event) => { if (email.validity.typeMismatch) { email.setCustomValidity(\"I am expecting an email address!\"); } else { email.setCustomValidity(\"\"); } }); Here we store a reference to the email input, then add an event listener to it that runs the contained code each time the value inside the input is changed. Inside the contained code, we check whether the email input's property returns , meaning that the contained value doesn't match the pattern for a well-formed email address. If so, we call the method with a custom message. This renders the input invalid, so that when you try to submit the form, submission fails and the custom error message is displayed. If the property returns , we call the method with an empty string. This renders the input valid, so the form will submit. During validation, if any form control has a that is not the empty string, form submission is blocked. You can try it out below: You can find this example live on GitHub as custom-error-message.html, along with the source code. The previous example showed how you can add a customized message for a particular type of error ( ). It is also possible to use all of the built in form validation, and then add to it using . Here we demonstrate how you can extend the built in validation to only accept addresses with the domain. We start with the HTML below. The validation code is shown below. In the event of any new input the code first resets the custom validity message by calling . It then uses to check if the entered address is invalid and if so, returns from the event handler. This ensures that all the normal built-in validation checks are run while the entered text is not a valid email address. Once the email address is valid, the code adds a custom constraint, calling with an error message if the address does not end with . const email = document.getElementById(\"mail\"); email.addEventListener(\"input\", (event) => { // Validate with the built-in constraints email.setCustomValidity(\"\"); if (!email.validity.valid) { return; } // Extend with a custom constraints if (!email.value.endsWith(\"@example.com\")) { email.setCustomValidity(\"Please enter an email address of @example.com\"); } }); You can try this example in the page at the Live sample demo link. Try submitting an invalid email address, a valid email address that doesn't end in , and one that does end in . Now that we've seen a really basic example, let's see how we can use this API to build some slightly more complex custom validation. First, the HTML. Again, feel free to build this along with us: This form uses the attribute to turn off the browser's automatic validation. Setting the attribute on the form stops the form from showing its own error message bubbles, and allows us to instead display the custom error messages in the DOM in some manner of our own choosing. However, this doesn't disable support for the constraint validation API nor the application of CSS pseudo-classes like , etc. That means that even though the browser doesn't automatically check the validity of the form before sending its data, you can still do it yourself and style the form accordingly. Our input to validate is an , which is , and has a of 8 characters. Let's check these using our own code, and show a custom error message for each one. We are aiming to show the error messages inside a element. The attribute is set on that to make sure that our custom error message will be presented to everyone, including it being read out to screen reader users. Now onto some basic CSS to improve the look of the form slightly, and provide some visual feedback when the input data is invalid: Now let's look at the JavaScript that implements the custom error validation. There are many ways to pick a DOM node; here we get the form itself and the email input box, as well as the span element into which we will place the error message. Using event handlers, we check if the form fields are valid each time the user types something. If there is an error, we show it. If there is no error, we remove any error messaging. const form = document.querySelector(\"form\"); const email = document.getElementById(\"mail\"); const emailError = document.querySelector(\"#mail + span.error\"); email.addEventListener(\"input\", (event) => { if (email.validity.valid) { emailError.textContent = \"\"; // Remove the message content emailError.className = \"error\"; // Removes the `active` class } else { // If there is still an error, show the correct error showError(); } }); form.addEventListener(\"submit\", (event) => { // if the email field is invalid if (!email.validity.valid) { // display an appropriate error message showError(); // prevent form submission event.preventDefault(); } }); function showError() { if (email.validity.valueMissing) { // If empty emailError.textContent = \"You need to enter an email address.\"; } else if (email.validity.typeMismatch) { // If it's not an email address, emailError.textContent = \"Entered value needs to be an email address.\"; } else if (email.validity.tooShort) { // If the value is too short, emailError.textContent = `Email should be at least ${email.minLength} characters; you entered ${email.value.length}.`; } // Add the `active` class emailError.className = \"error active\"; } Every time we change the value of the input, we check to see if it contains valid data. If it has then we remove any error message being shown. If the data is not valid, we run to show the appropriate error. Every time we try to submit the form, we again check to see if the data is valid. If so, we let the form submit. If not, we run to show the appropriate error, and stop the form submitting with . The function uses various properties of the input's object to determine what the error is, and then displays an error message as appropriate. You can find this example live on GitHub as detailed-custom-validation.html along with the source code. The constraint validation API gives you a powerful tool to handle form validation, letting you have enormous control over the user interface above and beyond what you can do with HTML and CSS alone.\n\nIn some cases, such as custom controls, you won't be able to or won't want to use the Constraint Validation API. You're still able to use JavaScript to validate your form, but you'll just have to write your own. To validate a form, ask yourself a few questions: What kind of validation should I perform? You need to determine how to validate your data: string operations, type conversion, regular expressions, and so on. It's up to you. This is clearly a UI matter. You have to decide how the form will behave. Does the form send the data anyway? Should you highlight the fields that are in error? Should you display error messages? How can I help the user to correct invalid data? In order to reduce the user's frustration, it's very important to provide as much helpful information as possible in order to guide them in correcting their inputs. You should offer up-front suggestions so they know what's expected, as well as clear error messages. If you want to dig into form validation UI requirements, here are some useful articles you should read:\n• Help users enter the right data in forms\n• How to Report Errors in Forms: 10 Design Guidelines An example that doesn't use the constraint validation API In order to illustrate this, the following is a simplified version of the previous example without the Constraint Validation API. The HTML is almost the same; we just removed the HTML validation features. Similarly, the CSS doesn't need to change very much; we've just turned the CSS pseudo-class into a real class and avoided using the attribute selector. body { font: 1em sans-serif; width: 200px; padding: 0; margin: 0 auto; } form { max-width: 200px; } p * { display: block; } input { appearance: none; width: 100%; border: 1px solid #333; margin: 0; font-family: inherit; font-size: 90%; box-sizing: border-box; } /* invalid fields */ input.invalid { border: 2px solid #900; background-color: #fdd; } input:focus.invalid { outline: none; /* make sure keyboard-only users see a change when focusing */ border-style: dashed; } /* error messages */ #error { width: 100%; font-size: 80%; color: white; background-color: #900; border-radius: 0 0 5px 5px; box-sizing: border-box; } .active { padding: 0.3rem; } The big changes are in the JavaScript code, which needs to do much more heavy lifting. const form = document.querySelector(\"form\"); const email = document.getElementById(\"mail\"); const error = document.getElementById(\"error\"); // Regular expression for email validation as per HTML specification const emailRegExp = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9-]+(?:\\.[a-zA-Z0-9-]+)*$/; // Check if the email is valid const isValidEmail = () => { const validity = email.value.length !== 0 && emailRegExp.test(email.value); return validity; }; // Update email input class based on validity const setEmailClass = (isValid) => { email.className = isValid ? \"valid\" : \"invalid\"; }; // Update error message and visibility const updateError = (isValidInput) => { if (isValidInput) { error.textContent = \"\"; error.removeAttribute(\"class\"); } else { error.textContent = \"I expect an email, darling!\"; error.setAttribute(\"class\", \"active\"); } }; // Initialize email validity on page load const initializeValidation = () => { const emailInput = isValidEmail(); setEmailClass(emailInput); }; // Handle input event to update email validity const handleInput = () => { const emailInput = isValidEmail(); setEmailClass(emailInput); updateError(emailInput); }; // Handle form submission to show error if email is invalid const handleSubmit = (event) => { event.preventDefault(); const emailInput = isValidEmail(); setEmailClass(emailInput); updateError(emailInput); }; // Now we can rebuild our validation constraint // Because we do not rely on CSS pseudo-class, we have to // explicitly set the valid/invalid class on our email field window.addEventListener(\"load\", initializeValidation); // This defines what happens when the user types in the field email.addEventListener(\"input\", handleInput); // This defines what happens when the user tries to submit the data form.addEventListener(\"submit\", handleSubmit); The result looks like this: As you can see, it's not that hard to build a validation system on your own. The difficult part is to make it generic enough to use both cross-platform and on any form you might create. There are many libraries available to perform form validation, such as Validate.js."
    }
]