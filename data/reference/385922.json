[
    {
        "link": "https://html2canvas.hertzen.com/documentation.html",
        "document": "Before you get started with the script, there are a few things that are good to know regarding the script and some of its limitations.\n\nThe script allows you to take “screenshots” of webpages or parts of it, directly on the users browser. The screenshot is based on the DOM and as such may not be 100% accurate to the real representation as it does not make an actual screenshot, but builds the screenshot based on the information available on the page.\n\nThe script traverses through the DOM of the page it is loaded on. It gathers information on all the elements there, which it then uses to build a representation of the page. In other words, it does not actually take a screenshot of the page, but builds a representation of it based on the properties it reads from the DOM.\n\nAs a result, it is only able to render correctly properties that it understands, meaning there are many CSS properties which do not work. For a full list of supported CSS properties, check out the supported features page.\n\nAll the images that the script uses need to reside under the same origin for it to be able to read them without the assistance of a proxy. Similarly, if you have other elements on the page, which have been tainted with cross-origin content, they will become dirty and no longer readable by html2canvas.\n\nThe script doesn’t render plugin content such as Flash or Java applets.\n\nThe library should work fine on the following browsers (with polyfill):"
    },
    {
        "link": "https://github.com/niklasvh/html2canvas",
        "document": "The script allows you to take \"screenshots\" of webpages or parts of it, directly on the users browser. The screenshot is based on the DOM and as such may not be 100% accurate to the real representation as it does not make an actual screenshot, but builds the screenshot based on the information available on the page.\n\nThe script renders the current page as a canvas image, by reading the DOM and the different styles applied to the elements.\n\nIt does not require any rendering from the server, as the whole image is created on the client's browser. However, as it is heavily dependent on the browser, this library is not suitable to be used in nodejs. It doesn't magically circumvent any browser content policy restrictions either, so rendering cross-origin content will require a proxy to get the content to the same origin.\n\nThe script is still in a very experimental state, so I don't recommend using it in a production environment nor start building applications with it yet, as there will be still major changes made.\n\nThe library should work fine on the following browsers (with polyfill):\n\nAs each CSS property needs to be manually built to be supported, there are a number of properties that are not yet supported.\n\nThe html2canvas library utilizes s and expects them to be available in the global context. If you wish to support older browsers that do not natively support s, please include a polyfill such as es6-promise before including .\n\nTo render an with html2canvas, simply call:\n\nThe function returns a Promise containing the element. Simply add a promise fulfillment handler to the promise using :\n\nYou can download ready builds here.\n\nFor more information and examples, please visit the homepage or try the test console.\n\nIf you wish to contribute to the project, please send the pull requests to the develop branch. Before submitting any changes, try and test that the changes work with all the support browsers. If some CSS property isn't supported or is incomplete, please create appropriate tests for it as well before submitting any code changes."
    },
    {
        "link": "https://npmjs.com/package/html2canvas/v/1.4.1",
        "document": "The script allows you to take \"screenshots\" of webpages or parts of it, directly on the users browser. The screenshot is based on the DOM and as such may not be 100% accurate to the real representation as it does not make an actual screenshot, but builds the screenshot based on the information available on the page.\n\nHow does it work?\n\nThe script renders the current page as a canvas image, by reading the DOM and the different styles applied to the elements.\n\nIt does not require any rendering from the server, as the whole image is created on the client's browser. However, as it is heavily dependent on the browser, this library is not suitable to be used in nodejs. It doesn't magically circumvent any browser content policy restrictions either, so rendering cross-origin content will require a proxy to get the content to the same origin.\n\nThe script is still in a very experimental state, so I don't recommend using it in a production environment nor start building applications with it yet, as there will be still major changes made.\n\nThe library should work fine on the following browsers (with polyfill):\n\nAs each CSS property needs to be manually built to be supported, there are a number of properties that are not yet supported.\n\nThe html2canvas library utilizes s and expects them to be available in the global context. If you wish to support older browsers that do not natively support s, please include a polyfill such as es6-promise before including .\n\nTo render an with html2canvas, simply call:\n\nThe function returns a Promise containing the element. Simply add a promise fulfillment handler to the promise using :\n\nYou can download ready builds here.\n\nFor more information and examples, please visit the homepage or try the test console.\n\nIf you wish to contribute to the project, please send the pull requests to the develop branch. Before submitting any changes, try and test that the changes work with all the support browsers. If some CSS property isn't supported or is incomplete, please create appropriate tests for it as well before submitting any code changes."
    },
    {
        "link": "https://github.com/niklasvh/html2canvas/blob/master/README.md",
        "document": "The script allows you to take \"screenshots\" of webpages or parts of it, directly on the users browser. The screenshot is based on the DOM and as such may not be 100% accurate to the real representation as it does not make an actual screenshot, but builds the screenshot based on the information available on the page.\n\nThe script renders the current page as a canvas image, by reading the DOM and the different styles applied to the elements.\n\nIt does not require any rendering from the server, as the whole image is created on the client's browser. However, as it is heavily dependent on the browser, this library is not suitable to be used in nodejs. It doesn't magically circumvent any browser content policy restrictions either, so rendering cross-origin content will require a proxy to get the content to the same origin.\n\nThe script is still in a very experimental state, so I don't recommend using it in a production environment nor start building applications with it yet, as there will be still major changes made.\n\nThe library should work fine on the following browsers (with polyfill):\n\nAs each CSS property needs to be manually built to be supported, there are a number of properties that are not yet supported.\n\nThe html2canvas library utilizes s and expects them to be available in the global context. If you wish to support older browsers that do not natively support s, please include a polyfill such as es6-promise before including .\n\nTo render an with html2canvas, simply call:\n\nThe function returns a Promise containing the element. Simply add a promise fulfillment handler to the promise using :\n\nYou can download ready builds here.\n\nFor more information and examples, please visit the homepage or try the test console.\n\nIf you wish to contribute to the project, please send the pull requests to the develop branch. Before submitting any changes, try and test that the changes work with all the support browsers. If some CSS property isn't supported or is incomplete, please create appropriate tests for it as well before submitting any code changes."
    },
    {
        "link": "https://html2canvas.hertzen.com",
        "document": "Test out html2canvas by rendering the viewport from the current page."
    },
    {
        "link": "https://stackoverflow.com/questions/19065562/add-image-in-pdf-using-jspdf",
        "document": "I am using jspdf to convert an image into a PDF.\n\nI have converted the image into a URI using base64encode. But the problem is that there are no errors or warnings shown in the console.\n\nA PDF is generated with the text Hello World on it but no image is added in it.\n\nHere is my code."
    },
    {
        "link": "https://stackoverflow.com/questions/71349387/html-to-pdf-using-jspdf-is-not-working-with-react-app",
        "document": "I am using react as a frontend application, I want to export a portion of react component as pdf file using jsPdf.\n\nAfter click on button I want a pdf file which consists tag data with style. But here I got blank pdf with this function .\n\nI don't want to use canvas to generate image and then make pdf.. If I use canvas then, when page size minimize the pdf will change.\n\nHow can I get exact html generated page as pdf?"
    },
    {
        "link": "https://medium.com/@aalam-info-solutions-llp/creating-dynamic-pdfs-with-jspdf-and-customizing-autotables-in-react-a846a6f3fdca",
        "document": "In this tutorial, we’ll explore how to generate dynamic PDFs in a React application using jsPDF. We’ll focus on enhancing the PDF generation process by customizing AutoTable, implementing dynamic page numbering, and ensuring flexible page allocation.\n\n7. Create the pdfGenerator file component and Import Necessary Libraries\n\n10. Add Images and Text to the PDF\n\nBefore proceeding, check if Node.js and npm are already installed on your machine. Open your terminal and run the following commands.\n\nOpen your terminal and run the following commands to create a new React app.\n\nImport the Button and DownloadIcon components from the ‘lumina-ui’ library.\n\nDefine a function named generatePdf responsible for triggering the PDF generation when the button is clicked.\n\nUse JSX to define the structure of the App component.\n\nCreate a div with inline styles that center its content both horizontally and vertically using flexbox.\n\nInclude a paragraph (<p>) with the text “Click here to download the PDF file.”\n\nonClick: Specifies the generatePdf function to be executed when the button is clicked.\n\nStep7: Create the pdfGenerator file component and Import Necessary Libraries\n\nHere, we import the required libraries: jsPDF for PDF generation, jspdf-autotable for creating tables in the PDF, and format from date-fns for formatting dates.\n\nSample data for the vendor and items. You can replace this with dynamic data from your application.\n\nInitialize a new jsPDF instance and set properties for the PDF, such as the title.\n\nStep10: Add Images and Text to the PDF\n\nThis line of code adds an image to the RFQ PDF at a specific location with a defined size. The image is positioned 10 units from the left and 5 units from the top, and it has a width of 40 units and a height of 12 units.\n\nThis line of code adds a title to the RFQ PDF at a specific location. The title is positioned 150 units from the left and 12 units from the top. Adjust these coordinates based on your layout preferences.\n\npdf.autoTable: This function is provided by the jsPDF-AutoTable library. It automatically generates a table based on the provided data and settings.\n\nhead: An array containing the headers of the table. In this case, it’s an array of strings representing the header names.\n\nbody: A 2D array containing the rows of the table. Each row is represented by an array of strings or numbers.\n\nstartY: The Y-axis position where the table should start. Adjust this based on the layout and positioning in your document.\n\nheadStyles: Styles for the table headers, including fill color, text color, font style, font size, font family, and horizontal alignment.\n\ncolumnStyles: Styles for individual columns, allowing you to set specific widths for each column.\n\nalternateRowStyles: Styles for alternating rows, providing a different fill color for better readability.\n\nbodyStyles: Styles for the body of the table, including font size, font family, cell padding, text color, and avoiding row page breaks.\n\nmargin: Sets the top and left margin for the table.\n\npdf.internal.pageSize.getHeight(): This part retrieves the height of the current PDF page. The pdf.internal.pageSize object contains information about the dimensions of the page, and getHeight() specifically fetches the height of the page.\n\nconst totalPages = pdf.internal.getNumberOfPages();: This line calculates the total number of pages in the generated PDF using the getNumberOfPages() method provided by jsPDF.\n\nfor (let i = 1; i <= totalPages; i++) This initiates a loop that iterates through each page of the PDF.\n\npdf.line(10, 283, 200, 283);: Draws a horizontal line at the bottom of each page. The line starts at coordinates (10, 283) and ends at (200, 283). This line serves as a separator between the content and the page number.\n\npdf.setPage(i);: Sets the current page to the ith page in the loop, allowing the following operations to be applied to the correct page.\n\npdf.setFont(‘Newsreader’);: Sets the font for the page number text. In this case, it uses the ‘Newsreader’ font.\n\npdf.text(Page ${i} of ${totalPages}, 185, pdf.internal.pageSize.getHeight() — 5);: Adds the page number text to the current page. It displays the current page number and the total number of pages at coordinates (185, pdf.internal.pageSize.getHeight() — 5). Adjust the coordinates and text formatting as needed for your layout.\n\nThis code ensures that each page of the PDF includes a horizontal line at the bottom and displays the page number and total number of pages in the specified font and position.\n\npdf.save(RFQ.pdf): This line of code saves the generated PDF with the filename “RFQ.pdf”. The save method is provided by the jsPDF library and triggers the browser’s download functionality to save the PDF file.\n\nconst pdfDataUri = pdf.output(‘datauristring’): The output method with the parameter ‘datauristring’ is used to obtain the data URI of the generated PDF. A data URI is a base64-encoded representation of the file, allowing it to be embedded directly into the HTML.\n\nconst newTab = window.open(): This code opens a new browser tab using the window.open() method. This new tab will be used to display the preview of the generated PDF.\n\nnewTab?.document.write(<iframe width=’100%’ height=’100%’ src=’${pdfDataUri}’></iframe>): The document.write method is used to write an HTML iframe element into the new tab’s document. The iframe is set to display the PDF using its data URI as the source (src).\n\nThis command will start your application. Once the application is running, open your web browser and go to the specified localhost address (usually http://localhost:3000). You should be able to see your application running like this.\n\nTo download the PDF, click on the download button, and the browser will prompt you to save the file with the filename “RFQ.pdf”.\n\nThis step-by-step breakdown helps understand how the PdfGenerator component creates a detailed RFQ PDF document.\n\nBelow is the sample code for App.js:\n\nBelow is the sample code for pdfGenerator.js:\n\nEstablished in 2016, with the goal of being the company of right choice for clients, talents and solution providers. We design, develop and integrate software applications to meet the challenges of a dynamic business environment that suits our client’s needs. Today, we are one of the growing software service provider in the industry aimed at providing custom application development and suitable technical solution. Our team aspires to do quality work for our clients in providing end-to-end solutions and services at an affordable price ."
    },
    {
        "link": "https://codesandbox.io/s/jspdf-react-example-7i8xe",
        "document": ""
    },
    {
        "link": "https://quora.com/How-do-I-create-a-PDF-using-JSPDF-in-ReactJS",
        "document": "Something went wrong. Wait a moment and try again."
    }
]