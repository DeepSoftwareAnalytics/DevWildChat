[
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia",
        "document": "Secure context: This feature is available only in secure contexts (HTTPS), in some or all supporting browsers. The method of the interface prompts the user for permission to use a media input which produces a with tracks containing the requested types of media. That stream can include, for example, a video track (produced by either a hardware or virtual video source such as a camera, video recording device, screen sharing service, and so forth), an audio track (similarly, produced by a physical or virtual audio source like a microphone, A/D converter, or the like), and possibly other track types. It returns a that resolves to a object. If the user denies permission, or matching media is not available, then the promise is rejected with or respectively. Note: It's possible for the returned promise to neither resolve nor reject, as the user is not required to make a choice at all and may ignore the request.\n\nAlthough the user and operating system both granted access to the hardware device, and no hardware issues occurred that would cause a , throw if some problem occurred which prevented the device from being used. Thrown if current document is not fully active. Thrown if one or more of the requested source devices cannot be used at this time. This will happen if the browsing context is insecure (that is, the page was loaded using HTTP rather than HTTPS). It also happens if the user has specified that the current browsing instance is not permitted access to the device, the user has denied access for the current session, or the user has denied all access to user media devices globally. On browsers that support managing media permissions with Permissions Policy, this error is returned if Permissions Policy is not configured to allow access to the input source(s). Note: Older versions of the specification used for this instead; has taken on a new meaning. Thrown if no media tracks of the type specified were found that satisfy the given constraints. Thrown if, although the user granted permission to use the matching devices, a hardware error occurred at the operating system, browser, or Web page level which prevented access to the device. Thrown if the specified constraints resulted in no candidate devices which met the criteria requested. The error is an object of type , and has a property whose string value is the name of a constraint which was impossible to meet, and a property containing a human-readable string explaining the problem. Note: Because this error can occur even when the user has not yet granted permission to use the underlying device, it can potentially be used as a fingerprinting surface. Thrown if user media support is disabled on the on which was called. The mechanism by which user media support is enabled and disabled is left up to the individual user agent. Thrown if the list of constraints specified is empty, or has all constraints set to . This can also happen if you try to call in an insecure context, since is in an insecure context.\n\nAs an API that may involve significant privacy concerns, 's specification lays out a wide array of privacy and security requirements that browsers are obligated to meet. is a powerful feature that can only be used in secure contexts; in insecure contexts, is , preventing access to . A secure context is, in short, a page loaded using HTTPS or the URL scheme, or a page loaded from . In addition, user permission is always required to access the user's audio and video inputs. Only a window's top-level document context for a valid origin can even request permission to use , unless the top-level context expressly grants permission for a given to do so using Permissions Policy. Otherwise, the user will never even be asked for permission to use the input devices. For additional details on these requirements and rules, how they are reflected in the context in which your code is running, and about how browsers manage user privacy and security issues, read on.\n\nAs an API that may involve significant privacy concerns, is held by the specification to very specific requirements for user notification and permission management. First, must always get user permission before opening any media gathering input such as a webcam or microphone. Browsers may offer a once-per-domain permission feature, but they must ask at least the first time, and the user must specifically grant ongoing permission if they choose to do so. Of equal importance are the rules around notification. Browsers are required to display an indicator that shows that a camera or microphone is in use, above and beyond any hardware indicator that may exist. They must also show an indicator that permission has been granted to use a device for input, even if the device is not actively recording at the moment. For example in Firefox, the URL bar displays a pulsing red icon to indicate that recording is underway. The icon is gray if the permission is in place but recording is not currently underway. The device's physical light is used to indicate whether or not recording is currently active. If you've muted your camera (so-called \"facemuting\"), your camera's activity light goes out to indicate that the camera is not actively recording you, without discarding the permission to resume using the camera once muting is over.\n\nThere are a number of ways security management and controls in a user agent can cause to return a security-related error. The two Permissions Policy directives that apply to are and . For example, this HTTP header will enable use of a camera by the document and any embedded elements that are loaded from the same origin: This will request access to the microphone for the current origin and the specific origin : If you're using within an , you can request permission just for that frame, which is clearly more secure than requesting a more general permission. Here, indicate we need the ability to use both camera and microphone: The method is only available in secure contexts. A secure context is one the browser is reasonably confident contains a document which was loaded securely, using HTTPS/TLS, and has limited exposure to insecure contexts. If a document isn't loaded in a secure context, the property is , making access to impossible. Attempting to access in this situation will result in a . Because of the obvious security concern associated with if used unexpectedly or without security being carefully managed, it can only be used in secure contexts. There are a number of insecure ways to load a document that might, in turn, attempt to call . The following are examples of situations in which is not permitted to be called:\n• A document loaded into a sandboxed element cannot call unless the has its attribute set to .\n• A document loaded using a or URL which has no origin (such as when one of these URLs is typed by the user into the address bar) cannot call . These kinds of URLs loaded from JavaScript code inherit the script's permissions.\n• Any other situation in which there is no origin, such as when the attribute is used to specify the contents of a frame.\n\nGenerally, you will access the singleton object using , like this: async function getMedia(constraints) { let stream = null; try { stream = await navigator.mediaDevices.getUserMedia(constraints); /* use the stream */ } catch (err) { /* handle the error */ } } Similarly, using the raw promises directly, the code looks like this: navigator.mediaDevices .getUserMedia(constraints) .then((stream) => { /* use the stream */ }) .catch((err) => { /* handle the error */ }); Note: If the current document isn't loaded securely, will be , and you cannot use . See Security for more information on this and other security issues related to using . Below are some examples of the parameter. The following requests both audio and video without any specific requirements: While information about a user's cameras and microphones are inaccessible for privacy reasons, an application can request the camera and microphone capabilities it needs and wants, using additional constraints. The following expresses a preference for 1280x720 camera resolution: The browser will try to honor this, but may return other resolutions if an exact match is not available, or the user overrides it. To require a capability, use the keywords , , or (a.k.a. ). The following demands a minimum resolution of 1280x720: If no camera exists with this resolution or higher, then the returned promise will be rejected with , and the user will not be prompted. The reason for the difference in behavior is that the keywords , , and are inherently mandatory — whereas plain values and a keyword called are not. Here's a full example: An value, when used, has gravity — which means that the browser will try to find the setting (and camera, if you have more than one), with the smallest fitness distance from the ideal values given. Plain values are inherently ideal, which means that the first of our resolution examples above could have been written like this: Not all constraints are numbers. For example, on mobile devices, the following will prefer the front camera (if one is available) over the rear one: To require the rear camera, use: Another non-number constraint is the constraint. If you have a from , you can use it to request a specific device: The above will return the camera you requested, or a different camera if that specific camera is no longer available. Again, to require the specific camera, you would use:"
    },
    {
        "link": "https://webrtc.org/getting-started/media-devices",
        "document": "When developing for the web, the WebRTC standard provides APIs for accessing cameras and microphones connected to the computer or smartphone. These devices are commonly referred to as Media Devices and can be accessed with JavaScript through the object, which implements the interface. From this object we can enumerate all connected devices, listen for device changes (when a device is connected or disconnected), and open a device to retrieve a Media Stream (see below).\n\nThe most common way this is used is through the function , which returns a promise that will resolve to a for the matching media devices. This function takes a single object that specifies the requirements that we have. For instance, to simply open the default microphone and camera, we would do the following.\n\nThe call to will trigger a permissions request. If the user accepts the permission, the promise is resolved with a containing one video and one audio track. If the permission is denied, a is thrown. In case there are no matching devices connected, a will be thrown.\n\nThe full API reference for the interface is available at MDN web docs.\n\nIn a more complex application, we will most likely want to check all the connected cameras and microphones and provide the appropriate feedback to the user. This can be done by calling the function . This will return a promise that resolves to an array of that describe each known media device. We can use this to present a UI to the user which let's them pick the one they prefer. Each contains a property named with the value , or , indicating what type of media device it is.\n\nMost computers support plugging in various devices during runtime. It could be a webcam connected by USB, a Bluetooth headset, or a set of external speakers. In order to properly support this, a web application should listen for the changes of media devices. This can be done by adding a listener to for the event.\n\nThe constraints object, which must implement the interface, that we pass as a parameter to allows us to open a media device that matches a certain requirement. This requirement can be very loosely defined (audio and/or video), or very specific (minimum camera resolution or an exact device ID). It is recommended that applications that use the API first check the existing devices and then specifies a constraint that matches the exact device using the constraint. Devices will also, if possible, be configured according to the constraints. We can enable echo cancellation on microphones or set a specific or minimum width and height of the video from the camera.\n\nThe full documentation for the interface can be found on the MDN web docs.\n\nOnce a media device has been opened and we have a available, we can assign it to a video or audio element to play the stream locally.\n\nThe HTML needed for a typical video element used with will usually have the attributes and . The attribute will cause new streams assigned to the element to play automatically. The attribute allows video to play inline, instead of only in full screen, on certain mobile browsers. It is also recommended to use for live streams, unless the user should be able to pause them."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/API/WebRTC_API/Build_a_phone_with_peerjs/Connect_peers/Get_microphone_permission",
        "document": "After you've created the peer, you'll want to get the browser's permission to access the microphone. We'll be using the method on the object. The endpoint takes a object that specifies which permissions are needed. is a promise which, when successfully resolved, returns a object. In our case this is going to contain the audio from our stream. If the promise isn't successfully resolved, you'll want to catch and display the error.\n• Add the following code to the bottom of your file: function getLocalStream() { navigator.mediaDevices .getUserMedia({ video: false, audio: true }) .then((stream) => { window.localStream = stream; // A window.localAudio.srcObject = stream; // B window.localAudio.autoplay = true; // C }) .catch((err) => { console.error(`you got an error: ${err}`); }); }\n• attaches the object (which we have assigned to on the previous line) to the window as the .\n• sets the element with the ID of 's attribute to be the returned by the promise so that it will play our stream.\n• sets the attribute of the element to true, so that the audio plays automatically. Warning: If you've done some sleuthing online, you may have come across and assumed you can use that instead of . You'd be wrong. The former is a deprecated method, which requires callbacks as well as constraints as arguments. The latter uses a promise so you don't need to use callbacks.\n• Try calling your function by adding the following line at the bottom of your code:\n• Refresh your app, which should still be running at ; you should see the following permission pop up:\n• Plugin in some headphones before you allow the microphone usage so that when you unmute yourself later, you don't get any feedback. If you didn't see the permission prompt, open the inspector to see if you have any errors. Make sure your JavaScript file is correctly linked to your too.\n\nThis what it should all look like together:"
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/API/Navigator/getUserMedia",
        "document": "Deprecated: This feature is no longer recommended. Though some browsers might still support it, it may have already been removed from the relevant web standards, may be in the process of being dropped, or may only be kept for compatibility purposes. Avoid using it, and update existing code if possible; see the compatibility table at the bottom of this page to guide your decision. Be aware that this feature may cease to work at any time.\n\nThe deprecated method prompts the user for permission to use up to one video input device (such as a camera or shared screen) and up to one audio input device (such as a microphone) as the source for a .\n\nIf permission is granted, a whose video and/or audio tracks come from those devices is delivered to the specified success callback. If permission is denied, no compatible input devices exist, or any other error condition occurs, the error callback is executed with an object describing what went wrong. If the user instead doesn't make a choice at all, neither callback is executed.\n\nNote: This is a legacy method. Please use the newer instead. While technically not deprecated, this old callback version is marked as such, since the specification strongly encourages using the newer promise returning version."
    },
    {
        "link": "https://stackoverflow.com/questions/15993581/reprompt-for-permissions-with-getusermedia-after-initial-denial",
        "document": "How do we go about requesting camera/microphone access with getUserMedia() after being denied once?\n\nI'm working with getUserMedia to access the user's camera and pipe the data to a canvas. That bit all works fine.\n\nIn testing, I hit deny once. At this point in Chrome and Firefox, any subsequent requests with getUserMedia() default to the denied state.\n\nWe obviously don't want to annoy the hell out of our users by requesting permissions for camera/microphone on every page load after being denied. That's already annoying enough with the geolocation api.\n\nHowever, there has to be a way to request it again. Simply because a user hit deny once doesn't mean they want to deny webcam access for all time.\n\nI've been reading about the spec and googling around for a while but I'm not finding anything explicitly about this problem.\n\nEdit: Further research, it appears that hitting Deny in Chrome adds the current site to a block list. This can be manually accessed via chrome://settings/content. Scroll to Media. Manage Exceptions, remove the blocked site(s).\n\nLinking to chrome://settings/content doesn't work (in the case where we want to add a helpful link to let people re-enable permissions).\n\nThe whole UX for dealing with permissions around getUserMedia stinks. =("
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API/Writing_WebSocket_client_applications",
        "document": "In order to communicate using the WebSocket protocol, you need to create a object; this will automatically attempt to open the connection to the server. The WebSocket constructor accepts one required and one optional parameter: The URL to which to connect; this should be the URL to which the WebSocket server will respond. This should use the URL scheme , although some software may allow you to use the insecure for a local connection. Relative URL values and and schemes are also allowed in most recent browser versions. Either a single protocol string or an array of protocol strings. These strings are used to indicate sub-protocols, so that a single server can implement multiple WebSocket sub-protocols (for example, you might want one server to be able to handle different types of interactions depending on the specified ). If you don't specify a protocol string, an empty string is assumed. The constructor will throw a if the destination doesn't allow access. This may happen if you attempt to use an insecure connection (most user agents now require a secure link for all WebSocket connections unless they're on the same device or possibly on the same network).\n\nIf an error occurs while attempting to connect, an event is first sent to the object (thereby invoking any handlers), followed by a event that indicates the reason for the connection's closing. The browser may also output to its console a more descriptive error message as well as a closing code as defined in RFC 6455, Section 7.4 through the .\n\nThis simple example creates a new WebSocket, connecting to the server at . A custom protocol of \"protocolOne\" is named in the request for the socket in this example, though this can be omitted. On return, is . The will become once the connection is ready to transfer data. If you want to open a connection and are flexible about the protocols you support, you can specify an array of protocols: Once the connection is established (that is, is ), will tell you which protocol the server selected. Establishing a WebSocket relies on the HTTP Upgrade mechanism, so the request for the protocol upgrade is implicit when we address the web server as or .\n\nOnce you've opened your connection, you can begin transmitting data to the server. To do this, call the object's method for each message you want to send: exampleSocket.send(\"Here's some text that the server is urgently awaiting!\"); You can send data as a string, , or . As establishing a connection is asynchronous and prone to failure there is no guarantee that calling the method immediately after creating a WebSocket object will be successful. We can at least be sure that attempting to send data only takes place once a connection is established by defining an event handler to do the work: exampleSocket.onopen = (event) => { exampleSocket.send(\"Here's some text that the server is urgently awaiting!\"); };\n\nLet's consider the chat client application first alluded to in Using JSON to transmit objects. There are assorted types of data packets the client might receive, such as: The code that interprets these incoming messages might look like this: exampleSocket.onmessage = (event) => { const f = document.getElementById(\"chat-box\").contentDocument; let text = \"\"; const msg = JSON.parse(event.data); const time = new Date(msg.date); const timeStr = time.toLocaleTimeString(); switch (msg.type) { case \"id\": clientID = msg.id; setUsername(); break; case \"username\": text = `User <em>${msg.name}</em> signed in at ${timeStr}<br>`; break; case \"message\": text = `(${timeStr}) ${msg.name} : ${msg.text} <br>`; break; case \"reject-username\": text = `Your username has been set to <em>${msg.name}</em> because the name you chose is in use.<br>`; break; case \"user-list\": document.getElementById(\"user-list-box\").innerText = msg.users.join(\"\n\n\"); break; } if (text.length) { f.write(text); document.getElementById(\"chat-box\").contentWindow.scrollByPages(1); } }; Here we use to convert the JSON object back into the original object, then examine and act upon its contents."
    },
    {
        "link": "https://geeksforgeeks.org/how-to-create-a-websocket-connection-in-javascript",
        "document": "How to Create a WebSocket Connection in JavaScript ?\n\nWebSocket is a powerful communication protocol enabling real-time data exchange between clients and servers. In this guide, we'll explore how to establish a WebSocket connection using JavaScript. Below are the steps outlined for implementation:\n\n\"To establish a WebSocket connection in JavaScript, we need to configure a WebSocket server on the backend and WebSocket clients on the front end. The server listens for incoming WebSocket connections, while the client initiates a WebSocket handshake and communicates with the server using JavaScript's WebSocket API.\n\nFor the backend, we'll use Node.js and the ws library to create a WebSocket server. The ws library facilitates WebSocket connection management, message handling, and broadcasting to connected clients.\n\nOn the front end, we'll instantiate a WebSocket object using the WebSocket constructor. We'll utilize the onopen, onmessage, and onclose events to manage various operations, and employ the send() method to transmit messages to the server.\"\n\nStep 1: Create a NodeJS application using the following command:\n\nThe updated dependencies in package.json file will look like:\n\nExample: The Below example is demonstrating the use of WebSocket.\n\nWebSocket Client WebSocket Example Send Message to Server: Send // and connect to the server // Alert the user that they are 'You are Connected to WebSocket Server' // is received from the server // Event listener for when the\n\nTo launch the application, execute the following command in your terminal:\n\nThen, open the `index.html` file in your web browser.\""
    },
    {
        "link": "https://medium.com/@wu.victor.95/connecting-websocket-backend-to-frontend-9e9b27e7099e",
        "document": "We’ve written a lot of code to get to this point. We are finally connecting our backend WebSocket to the frontend to support live interactions among multiple connected users. To accomplish this, we first need a frontend WebSocket client to manage the connection as well as send and receive messages. Let’s encapsulate this functionality into a convenient hook:\n\nThis hook basically connects to a provided url and returns state variables that we can listen to in hooks to handle any changes (connection, messages, etc). Before we get to that, let’s create some helper functions to build out our WebSocket message requests. Similar to how we have a folder, let’s create a folder with the following files:\n\nAs you can see from the code, every message request follows the JSON structure:\n\nThis is inline with what we’ve built in our backend. If you recall, we set up our WebSocket in a way where the user needs to first establish the WebSocket connection, then authenticate themselves, and finally connect to the board. We’ll be putting all of this logic where we call the hook:\n\n'use client';\n\n\n\nimport update from 'immutability-helper';\n\nimport { FC, useEffect } from 'react';\n\nimport { useState } from 'react';\n\nimport { useDrop } from 'react-dnd';\n\n\n\nimport { DraggablePost } from './draggablePost';\n\nimport type { DragItem } from './interfaces';\n\nimport { ItemTypes } from './itemTypes';\n\nimport { snapToGrid as doSnapToGrid } from './snapToGrid';\n\nimport { Post } from '@/api/post';\n\nimport {\n\n BOARD_SPACE_ADD,\n\n COOKIE_NAME_JWT_TOKEN,\n\n EVENT_BOARD_CONNECT,\n\n EVENT_POST_CREATE,\n\n EVENT_POST_DELETE,\n\n EVENT_POST_FOCUS,\n\n EVENT_POST_UPDATE,\n\n EVENT_USER_AUTHENTICATE,\n\n NAVBAR_HEIGHT,\n\n POST_COLORS,\n\n POST_HEIGHT,\n\n POST_WIDTH,\n\n SIDEBAR_WIDTH,\n\n WS_URL,\n\n} from '@/constants';\n\nimport { useWebSocket } from '@/hooks/useWebSocket';\n\nimport Cookies from 'universal-cookie';\n\nimport {\n\n authenticateUser as authenticateUserWS,\n\n connectBoard as connectBoardWS,\n\n createPost as createPostWS,\n\n updatePost as updatePostWS,\n\n} from '@/ws/events';\n\nimport { Overlay } from '../overlay';\n\nimport { getMaxFieldFromObj } from '@/utils';\n\nimport { toast } from 'react-toastify';\n\nimport { BoardWithMembers } from '@/api/board';\n\nimport Sidebar from '../sidebar';\n\nimport { User } from '@/api';\n\n\n\nexport type PostUI = {\n\n typingBy: User | null;\n\n} & Post;\n\n\n\nexport type PostMap = {\n\n [key: string]: Partial<PostUI>;\n\n};\n\nexport interface BoardProps {\n\n snapToGrid: boolean;\n\n board: BoardWithMembers;\n\n posts: PostMap;\n\n}\n\n\n\nexport const Board: FC<BoardProps> = ({ board, snapToGrid, posts: initialPosts }) => {\n\n const TEXT_CONNECTING = 'Connecting to board';\n\n const TEXT_NOT_CONNECTED = 'Not connected, try refreshing';\n\n const [posts, setPosts] = useState<PostMap>(initialPosts);\n\n const [overlayText, setOverlayText] = useState(TEXT_CONNECTING);\n\n const [showOverlay, setShowOverlay] = useState(true);\n\n const [user, setUser] = useState<User>();\n\n const [connectedUsers, setConnectedUsers] = useState([]);\n\n const [boardDimension, setBoardDimension] = useState({ height: 0, width: 0 });\n\n const [highestZ, setHighestZ] = useState(getMaxFieldFromObj(initialPosts, 'z_index'));\n\n const [colorSetting, setColorSetting] = useState(pickColor(posts));\n\n const { data, error, send, readyState } = useWebSocket(WS_URL);\n\n const cookies = new Cookies();\n\n\n\n useEffect(() => {\n\n // Scroll to the top left portion of the page\n\n window.scrollTo(0, 0);\n\n }, []);\n\n\n\n // Expands the board based on post locations\n\n useEffect(() => {\n\n const newWidth = getMaxFieldFromObj(posts, 'pos_x') + POST_WIDTH + BOARD_SPACE_ADD;\n\n const newHeight = getMaxFieldFromObj(posts, 'pos_y') + POST_HEIGHT + BOARD_SPACE_ADD;\n\n setBoardDimension({ height: newHeight, width: newWidth });\n\n }, [posts]);\n\n\n\n // Handles the different connection states. Will authenticate the user if connection is established\n\n // or will show an error overlay if trouble connecting.\n\n useEffect(() => {\n\n if (readyState == WebSocket.OPEN) {\n\n setOverlayText(TEXT_CONNECTING);\n\n setShowOverlay(true);\n\n const jwtToken = cookies.get(COOKIE_NAME_JWT_TOKEN);\n\n authenticateUserWS(jwtToken, send);\n\n }\n\n if (readyState == WebSocket.CLOSED || readyState == WebSocket.CLOSING) {\n\n setOverlayText(TEXT_NOT_CONNECTED);\n\n setShowOverlay(true);\n\n }\n\n }, [readyState]);\n\n\n\n // Handles all the different post events\n\n useEffect(() => {\n\n if (data == null) {\n\n return;\n\n }\n\n const { event, result, success, error_message } = JSON.parse(data);\n\n switch (event) {\n\n case EVENT_USER_AUTHENTICATE:\n\n setUser(result.user);\n\n connectBoardWS(board.id, send);\n\n break;\n\n case EVENT_BOARD_CONNECT:\n\n if (success) {\n\n setShowOverlay(false);\n\n setConnectedUsers(result.connected_users.concat([result.new_user]));\n\n } else {\n\n toast.error(error_message);\n\n }\n\n break;\n\n case EVENT_POST_CREATE:\n\n if (success) {\n\n addPost(result);\n\n } else {\n\n toast.error(error_message);\n\n }\n\n break;\n\n case EVENT_POST_UPDATE:\n\n if (success) {\n\n updatePost({ ...result, typingBy: null });\n\n } else {\n\n toast.error(error_message);\n\n }\n\n break;\n\n case EVENT_POST_DELETE:\n\n if (success) {\n\n deletePost(result.post_id);\n\n } else {\n\n toast.error(error_message);\n\n }\n\n break;\n\n case EVENT_POST_FOCUS:\n\n if (success) {\n\n if (result.user.id != user?.id) {\n\n updatePost({ id: result.id, typingBy: result.user });\n\n }\n\n } else {\n\n toast.error(error_message);\n\n }\n\n break;\n\n\n\n default:\n\n break;\n\n }\n\n }, [data]);\n\n\n\n // handleDoubleClick creates a new post\n\n const handleDoubleClick = (event: React.MouseEvent<HTMLDivElement>) => {\n\n if (event.target === event.currentTarget) {\n\n const { offsetX, offsetY } = event.nativeEvent;\n\n const newZIndex = highestZ + 1;\n\n const params = {\n\n board_id: board.id,\n\n content: '',\n\n pos_x: offsetX,\n\n pos_y: offsetY,\n\n color: colorSetting,\n\n z_index: highestZ + 1,\n\n };\n\n createPostWS(params, send);\n\n setHighestZ(newZIndex);\n\n }\n\n };\n\n\n\n const addPost = (post: PostUI) => {\n\n setPosts(\n\n update(posts, {\n\n [post.id]: {\n\n $set: post,\n\n },\n\n })\n\n );\n\n };\n\n\n\n const updatePost = (post: { id: string } & Partial<PostUI>) => {\n\n setPosts(\n\n update(posts, {\n\n [post.id]: {\n\n $merge: post,\n\n },\n\n })\n\n );\n\n };\n\n\n\n const deletePost = (id: string) => {\n\n setPosts(\n\n update(posts, {\n\n $unset: [id],\n\n })\n\n );\n\n };\n\n\n\n const sendUpdatePost = (post: Partial<PostUI>) => {\n\n updatePostWS(post, send);\n\n };\n\n\n\n const [, drop] = useDrop(\n\n () => ({\n\n accept: ItemTypes.POST,\n\n drop(item: DragItem, monitor) {\n\n const delta = monitor.getDifferenceFromInitialOffset() as {\n\n x: number;\n\n y: number;\n\n };\n\n\n\n let pos_x = Math.max(item.pos_x + delta.x, 0);\n\n let pos_y = Math.max(item.pos_y + delta.y, 0);\n\n if (snapToGrid) {\n\n [pos_x, pos_y] = doSnapToGrid(pos_x, pos_y);\n\n }\n\n const newZIndex = getMaxFieldFromObj(posts, 'z_index') + 1;\n\n const newParams = { id: item.id, board_id: board.id, z_index: newZIndex, pos_x, pos_y };\n\n // pre-emptively update post on frontend before waiting on websocket to smoothen out experience\n\n updatePost({ id: item.id, z_index: newZIndex, pos_x, pos_y });\n\n sendUpdatePost(newParams);\n\n return undefined;\n\n },\n\n }),\n\n [updatePost]\n\n );\n\n\n\n return (\n\n <div className=\"flex\">\n\n <Overlay show={showOverlay || !user} text={overlayText} />\n\n {user ? <Sidebar board={board} width={SIDEBAR_WIDTH} user={user} connectedUsers={connectedUsers} /> : null}\n\n <div\n\n ref={drop}\n\n className=\"relative sketchbook-bg\"\n\n style={{\n\n minHeight: `calc(100vh - ${NAVBAR_HEIGHT})`,\n\n minWidth: `calc(100vw - ${SIDEBAR_WIDTH})`,\n\n height: boardDimension.height,\n\n width: boardDimension.width,\n\n }}\n\n onDoubleClick={handleDoubleClick}\n\n >\n\n {user\n\n ? Object.keys(posts).map((key) => (\n\n <DraggablePost\n\n key={key}\n\n user={user}\n\n board={board}\n\n {...(posts[key] as PostUI)}\n\n send={send}\n\n setColorSetting={setColorSetting}\n\n />\n\n ))\n\n : null}\n\n </div>\n\n </div>\n\n );\n\n};\n\n\n\n// pickColor returns the first color that hasn't been picked yet among the board. If no\n\n// colors are available, return a random color\n\nconst pickColor = (posts: PostMap) => {\n\n const chosenColors = Object.values(posts).map(({ color }) => color);\n\n const availableColors = Object.values(POST_COLORS);\n\n availableColors.forEach((color) => {\n\n if (!chosenColors.includes(color)) {\n\n return color;\n\n }\n\n });\n\n const randIndex = Math.floor(Math.random() * availableColors.length);\n\n return availableColors[randIndex];\n\n};\n\nOk. There is a decently large file. It does quite a few things. Let’s first discuss the most relevant portion — the WebSocket stuff. It listens to the variable from the hook to detect if the connection is open:\n\nIf the connection is open, we still display an overlay that the user has not connected yet. This is because we are sending a message request using . The stands for WebSocket. In another hook, we are listening for changes to :\n\nHere is where we hide the overlay when we get a successful . We also set the connected users that we get back from the message data. Just below that, we have code to update the frontend UI:\n\nThe workflow for rendering a newly created post on the frontend is as follows:\n• Handle the create post message. If successful, call to set a new post into the map.\n\nThis same workflow applies to drag and update events (text, color, height, etc.). The difference is that the object, which holds the connection to our WebSocket, is passed down into the child component. Let’s take a look at that file next:\n\nYou can see that when a user updates the post, we call with the updated data. Let’s look at an example:\n\nHere we have a handler that triggers every time a user clicks off of a post’s textarea. We capture the new and send it through as a message request. In the parent where state is held, we listen for a successful update event to update the map.\n\nThis then gets reflected in the UI for the requesting user and all connected users. Take a look at the demo showcasing two separate users. When John Doe is updating the textarea, it sends a event to the backend. Jane Smith gets that event and updates the relevant post. Once John Doe clicks off of the post, it sends an update request to the server which eventually renders onto Jane Smith’s screen.\n\nWe can achieve the same live interactivity when dragging and deleting posts:\n\nSome other notable changes made include:\n• When a post is updated, it is automatically assigned the highest z-index between all the posts. This is a nice UI touch to ensure that freshly interacted posts are not buried underneath.\n• The canvas also auto expands depending on the positions of the post. If a post is created near the bottom or right border of the page, the canvas will dynamically adjust.\n• We’ve also disable dragging capability when a post is currently being typed on.\n\nThe last component I’ll highlight is the component. It makes use of the that are provided on a event to build a list of online users. User names that are bold are currently online, with a stats display at the bottom of the sidebar:\n\nWe’ve made a ton of progress on the main features of the app. Users can see other connected users and what they’re doing on the board. Currently this is all possible due to mocked data in the DB. Ideally we’d like our users to be able to invite whomever they choose. The next MVP features we’ll be focusing is board invites and notifications. To enable that, we’ll be building a separate notification service!"
    },
    {
        "link": "https://stackoverflow.com/questions/41470482/java-server-javascript-client-websockets",
        "document": "To start with, both your code looks identical the Java and JavaScript one. Both work for what they are design to, but the facts is that you are trying to connect a WebSocket client to a socket server.\n\nAs I know they are two different things regarding this answer.\n\nI have never tried it your way. That said if I have a network application that use socket than it would be pure client/server socket, and if it was a web application than I would use WebSocket on both side as well.\n\nSo far so good..\n\nTo make this work, this answer suggests to use any available WebSocket on server side and your problem is solved.\n\nI am using WebSocket for Java and here is a sample implementation that I have tested with your client code and it works, both on client and server side.\n\nOn your main method just:\n\nYou might need to manipulate your code to fit it with this implementation, but that should be part of the job.\n\nHere is the test output with 2 tests:\n\nhere is WebSocket maven configuration, otherwise download the JAR file/s manually and import it in your IDE/development environment:"
    },
    {
        "link": "https://spring.io/guides/gs/messaging-stomp-websocket",
        "document": "This guide walks you through the process of creating a “Hello, world” application that sends messages back and forth between a browser and a server. WebSocket is a thin, lightweight layer above TCP. This makes it suitable for using “subprotocols” to embed messages. In this guide, we use STOMP messaging with Spring to create an interactive web application. STOMP is a subprotocol operating on top of the lower-level WebSocket.\n\nHow to complete this guide Like most Spring Getting Started guides, you can start from scratch and complete each step or you can bypass basic setup steps that are already familiar to you. Either way, you end up with working code. To start from scratch, move on to Starting with Spring Initializr. To skip the basics, do the following:\n• Download and unzip the source repository for this guide, or clone it using Git: When you finish, you can check your results against the code in .\n\nYou can use this pre-initialized project and click Generate to download a ZIP file. This project is configured to fit the examples in this tutorial.\n• Navigate to https://start.spring.io. This service pulls in all the dependencies you need for an application and does most of the setup for you.\n• Choose either Gradle or Maven and the language you want to use. This guide assumes that you chose Java.\n• Download the resulting ZIP file, which is an archive of a web application that is configured with your choices. If your IDE has the Spring Initializr integration, you can complete this process from your IDE. You can also fork the project from Github and open it in your IDE or other editor.\n\nNow that you have set up the project and build system, you can create your STOMP message service. Begin the process by thinking about service interactions. The service will accept messages that contain a name in a STOMP message whose body is a JSON object. If the name is , the message might resemble the following: To model the message that carries the name, you can create a plain old Java object with a property and a corresponding method, as the following listing (from ) shows: package com.example.messagingstompwebsocket; public class HelloMessage { private String name; public HelloMessage() { } public HelloMessage(String name) { this.name = name; } public String getName() { return name; } public void setName(String name) { this.name = name; } } Upon receiving the message and extracting the name, the service will process it by creating a greeting and publishing that greeting on a separate queue to which the client is subscribed. The greeting will also be a JSON object, which as the following listing shows: To model the greeting representation, add another plain old Java object with a property and a corresponding method, as the following listing (from ) shows: Spring will use the Jackson JSON library to automatically marshal instances of type into JSON. Next, you will create a controller to receive the hello message and send a greeting message.\n\nIn Spring’s approach to working with STOMP messaging, STOMP messages can be routed to classes. For example, the (from ) is mapped to handle messages to the destination, as the following listing shows: This controller is concise and simple, but plenty is going on. We break it down step by step. The annotation ensures that, if a message is sent to the destination, the method is called. The payload of the message is bound to a object, which is passed into . Internally, the implementation of the method simulates a processing delay by causing the thread to sleep for one second. This is to demonstrate that, after the client sends a message, the server can take as long as it needs to asynchronously process the message. The client can continue with whatever work it needs to do without waiting for the response. After the one-second delay, the method creates a object and returns it. The return value is broadcast to all subscribers of , as specified in the annotation. Note that the name from the input message is sanitized, since, in this case, it will be echoed back and re-rendered in the browser DOM on the client side.\n\nNow that the essential components of the service are created, you can configure Spring to enable WebSocket and STOMP messaging. Create a Java class named that resembles the following listing (from ): is annotated with to indicate that it is a Spring configuration class. It is also annotated with . As its name suggests, enables WebSocket message handling, backed by a message broker. The method implements the default method in to configure the message broker. It starts by calling to enable a simple memory-based message broker to carry the greeting messages back to the client on destinations prefixed with . It also designates the prefix for messages that are bound for methods annotated with . This prefix will be used to define all the message mappings. For example, is the endpoint that the method is mapped to handle. The method registers the endpoint for websocket connections.\n\nWith the server-side pieces in place, you can turn your attention to the JavaScript client that will send messages to and receive messages from the server side. Create an file similar to the following listing (from ): <!DOCTYPE html> <html> <head> <title>Hello WebSocket</title> <link rel=\"stylesheet\" href=\"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css\" integrity=\"sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u\" crossorigin=\"anonymous\"> <link href=\"/main.css\" rel=\"stylesheet\"> <script src=\"https://code.jquery.com/jquery-3.1.1.min.js\"></script> <script src=\"https://cdn.jsdelivr.net/npm/@stomp/[email protected]/bundles/stomp.umd.min.js\"></script> <script src=\"/app.js\"></script> </head> <body> <noscript><h2 style=\"color: #ff0000\">Seems your browser doesn't support Javascript! Websocket relies on Javascript being enabled. Please enable Javascript and reload this page!</h2></noscript> <div id=\"main-content\" class=\"container\"> <div class=\"row\"> <div class=\"col-md-6\"> <form class=\"form-inline\"> <div class=\"form-group\"> <label for=\"connect\">WebSocket connection:</label> <button id=\"connect\" class=\"btn btn-default\" type=\"submit\">Connect</button> <button id=\"disconnect\" class=\"btn btn-default\" type=\"submit\" disabled=\"disabled\">Disconnect </button> </div> </form> </div> <div class=\"col-md-6\"> <form class=\"form-inline\"> <div class=\"form-group\"> <label for=\"name\">What is your name?</label> <input type=\"text\" id=\"name\" class=\"form-control\" placeholder=\"Your name here...\"> </div> <button id=\"send\" class=\"btn btn-default\" type=\"submit\">Send</button> </form> </div> </div> <div class=\"row\"> <div class=\"col-md-12\"> <table id=\"conversation\" class=\"table table-striped\"> <thead> <tr> <th>Greetings</th> </tr> </thead> <tbody id=\"greetings\"> </tbody> </table> </div> </div> </div> </body> </html> This HTML file imports the javascript library that will be used to communicate with our server through STOMP over websocket. We also import , which contains the logic of our client application. The following listing (from ) shows that file: const stompClient = new StompJs.Client({ brokerURL: 'ws://localhost:8080/gs-guide-websocket' }); stompClient.onConnect = (frame) => { setConnected(true); console.log('Connected: ' + frame); stompClient.subscribe('/topic/greetings', (greeting) => { showGreeting(JSON.parse(greeting.body).content); }); }; stompClient.onWebSocketError = (error) => { console.error('Error with websocket', error); }; stompClient.onStompError = (frame) => { console.error('Broker reported error: ' + frame.headers['message']); console.error('Additional details: ' + frame.body); }; function setConnected(connected) { $(\"#connect\").prop(\"disabled\", connected); $(\"#disconnect\").prop(\"disabled\", !connected); if (connected) { $(\"#conversation\").show(); } else { $(\"#conversation\").hide(); } $(\"#greetings\").html(\"\"); } function connect() { stompClient.activate(); } function disconnect() { stompClient.deactivate(); setConnected(false); console.log(\"Disconnected\"); } function sendName() { stompClient.publish({ destination: \"/app/hello\", body: JSON.stringify({'name': $(\"#name\").val()}) }); } function showGreeting(message) { $(\"#greetings\").append(\"<tr><td>\" + message + \"</td></tr>\"); } $(function () { $(\"form\").on('submit', (e) => e.preventDefault()); $( \"#connect\" ).click(() => connect()); $( \"#disconnect\" ).click(() => disconnect()); $( \"#send\" ).click(() => sendName()); }); The main pieces of this JavaScript file to understand are the and functions. is initialized with referring to path , which is where our websockets server waits for connections. Upon a successful connection, the client subscribes to the destination, where the server will publish greeting messages. When a greeting is received on that destination, it will append a paragraph element to the DOM to display the greeting message. The function retrieves the name entered by the user and uses the STOMP client to send it to the destination (where will receive it). The can be omitted if you like, or you can create an empty one, just so the can be resolved.\n\nSpring Boot creates an application class for you. In this case, it needs no further modification. You can use it to run this application. The following listing (from ) shows the application class: is a convenience annotation that adds all of the following:\n• : Tags the class as a source of bean definitions for the application context.\n• : Tells Spring Boot to start adding beans based on classpath settings, other beans, and various property settings. For example, if is on the classpath, this annotation flags the application as a web application and activates key behaviors, such as setting up a .\n• : Tells Spring to look for other components, configurations, and services in the package, letting it find the controllers. The method uses Spring Boot’s method to launch an application. Did you notice that there was not a single line of XML? There is no file, either. This web application is 100% pure Java and you did not have to deal with configuring any plumbing or infrastructure. You can run the application from the command line with Gradle or Maven. You can also build a single executable JAR file that contains all the necessary dependencies, classes, and resources and run that. Building an executable jar makes it easy to ship, version, and deploy the service as an application throughout the development lifecycle, across different environments, and so forth. If you use Gradle, you can run the application by using . Alternatively, you can build the JAR file by using and then run the JAR file, as follows: If you use Maven, you can run the application by using . Alternatively, you can build the JAR file with and then run the JAR file, as follows: The steps described here create a runnable JAR. You can also build a classic WAR file. Logging output is displayed. The service should be up and running within a few seconds."
    },
    {
        "link": "https://videosdk.live/developer-hub/websocket/java-websocket",
        "document": "WebSockets are a powerful technology that enables real-time, bidirectional communication between clients and servers over a single, long-lived connection. Unlike traditional HTTP, which follows a request-response pattern, WebSockets allow data to flow freely in both directions, making them ideal for applications that require instant updates, such as live chats, online gaming, and real-time notifications.\n\nIn this article, we will explore how to implement WebSocket Server in Java. By the end of this guide, you will have a comprehensive understanding of how to set up a WebSocket server and client, manage connections, handle messages, and ensure secure communication. Whether you are building a simple chat application or a complex real-time data streaming service, this guide will provide you with the tools and knowledge you need to get started with Java WebSockets.\n\nWebSockets are a communication protocol that provides full-duplex communication channels over a single TCP connection. They enable real-time interaction between a client (such as a web browser) and a server, which is essential for applications requiring immediate data updates, like chat applications and live streaming. Unlike HTTP, which relies on a request-response model, WebSockets facilitate continuous, two-way communication.\n\nBefore diving into the implementation of WebSockets in Java, ensure you have the following tools and libraries installed:\n• An Integrated Development Environment (IDE) like IntelliJ IDEA or Eclipse\n• Open your IDE and create a new Maven project.\n• Configure the file to include dependencies for WebSocket support:\n• Ensure a clean separation of concerns by having different packages for server and client implementations.\n\nCreate a new Java class, , and annotate it with :\n• : Adds new client sessions to the set of active clients.\n• : Broadcasts messages received from one client to all other connected clients.\n\nCreate a client that connects to the WebSocket server.\n• : Connects to the WebSocket server at ."
    },
    {
        "link": "https://stackoverflow.com/questions/57922238/how-to-implement-a-websocket-server-in-java",
        "document": "Don't be confused about the name WebSocket. A TCP socket and a WebSocket are entirely different kind of \"sockets\".\n\nIn Java you use a ServerSocket for TCP sockets. TCP is a transport layer protocol used to implement application layer protocols like POP3 and HTTP.\n\nWebSocket is a HTTP/1.1 protocol upgrade commonly used in web servers and web browsers. You cannot use a ServerSocket for the WebSocket protocol, at least not so straight forward as you might think. First, you have to implement the HTTP/1.1 protocol and then the WebSocket protocol on top of that.\n\nIn the Java world you can use web servers like Tomcat or Jetty which provide WebSocket implementations and a high level Java API. This API is part of the Jave Enterprise Edition (JEE). See also the Jave EE 7 Tutorial - Chapter 18 Java API for WebSocket.\n\nE.g. Jetty is a lightweight JEE web server which can be embedded in your application or run as a stand-alone server. See Jetty Development Guide - Chapter 26. WebSocket Introduction.\n\nSo in a Java web application running in a WebSocket enabled JEE web server like Jetty you can implement a server side WebSocket as follows:\n\nYou register your class as a WebSocket handler for the specific path with the annotation. Your WebSocket URL is then or for HTTPS connections.\n\nEdit: Here is a very simplistic HTML page to demonstrate the client side connection to the above WebSocket. This page is served by the same webserver as the WebSocket. The webapplication containing the WebSocket is deployed at context \"websocket\" on localhost port 7777."
    },
    {
        "link": "https://emily-elim04.medium.com/building-real-time-apps-using-websockets-dc137ccdd34b",
        "document": "As a developer, (especially a new one like me) it can be intimidating opening yourself up to learning about the world of technology. Every day I often find myself saying “What the heck is that?!”. And every day, after doing a little research on my previously stated conundrum, I also find myself saying “Wow, that is so neat!”. (I’m serious I do say that…) However, that is what I love most about becoming a software developer, the continuous learning that it provides me with. Speaking of continuous learning… one of those topics that gave me a big question mark over my head was WebSockets. So, I thought I would write an intro guide on what I learned and how they are used in real-time applications. Cue the lights, the music, …. let’s get into WebSockets.\n\nSo what exactly is a WebSocket?\n\nWell person of the internet, I am glad you asked. According to the MDN Web Docs the WebSocket API is …\n\nWait… What is normally used?\n\nBefore we dive deep into WebSockets, let’s take a step back and look at HTTP. The HTTP protocol is a set of rules for how computers communicate on the web. It allows for the fetching of resources and is the foundation of any data exchange. It works as a request/response mechanism where a connection is open, a request is sent from the client(eg. the web browser), the server sends a response back and the connection is closed. HTTP is unidirectional, only the client can send a request to the server, and it must wait until the server sends back a separate response for each request. A common example used for this type of communication is a kitchen in a restaurant.\n• You, as the client place an order (HTTP request) and a waiter takes that order to the back kitchen (aka the server).\n• The kitchen receives the order and confirms that the order is correct (an item on the menu).\n• If the kitchen knows how to make it, they will find the ingredients to prepare the order (which is like the server processing the request and fetching data from a database to prepare the response) and will send the food back with the waiter as a successful response.\n• Say you asked for something not on the menu, well the kitchen might not accept that order or maybe doesn’t have the ingredients to prepare it so the kitchen will send the waiter back with a message that they can’t complete the request. Similarly to the server sending back an error message or status code 404.\n\nIt is also important to highlight that HTTP is “stateless”, it doesn’t know who specifically the request is coming from (ie. the kitchen doesn’t know who you specifically are when ordering the food). It treats and fulfills every request independently. Because this protocol is unidirectional, the kitchen (server) isn’t able to send the waiter back to you if there is a question they want to ask or update your order. It can only send a response after YOU specifically send the request in. The only way for you to get updated information from the kitchen is if you send the requests through the waiter. In a HTTP protocol the connection is closed after the response has been sent back from the server. This protocol does not lend itself well to real-time applications as a user would have to refresh the page every time they wanted to see an update to the page which, could be quite frustrating.\n\nBefore WebSockets were created, several ways that developers would create a work around for this problem were through short polling, long polling or server-sent events (SSE). We won’t get into the nitty gritty details about these but lets just say these solutions were not the most effective for real-time applications and some were not supported by older browsers.\n\nTo put it simply, WebSockets are just another protocol for sending and receiving messages. Similar to HTTP, they both send messages over a TCP (Transmission Control Protocol) connection. The only difference is how they structure the messages. WebSockets allow for a bidirectional, real-time communication between clients and servers. Once the connection is established between the client and server, it is kept alive until it is terminated by either party. Messages can be sent back and forth between the the client and the server until one of them dies or decides to close the connection. The WebSockets API allow the server to be able to keep track of each client and push messages to a subset of clients.\n\nHow does it work?\n\nLooking at the kitchen example again, if you were using a WebSocket, now you and the kitchen both have an open connection for the duration you are at the restaurant. You can both send requests/responses to each other until someone leaves the connection or terminates it.\n\nTo establish a WebSocket connection the client can send an HTTP “hand shake” request with an upgraded header, specifying that the client wants to establish a WebSocket connection. This request is sent to a ws: or wss: URI and if the server is able to establish the connection, it will send a successful response back and the handshake is complete. The TCP/IP connection is left open, allowing bidirectional messages to pass through between each party. This is often referred to as a full-duplex connection.\n\nWhat are they used for?\n\nAs mentioned above, they can be used for real-time web applications. Say you have an interview scheduler app and the calendar being displayed needs to be updated every time a new interview is booked or cancelled. WebSockets provide the perfect solution to this to make sure each user is looking at the most up to date calendar. Another place you might want to use WebSockets is in a multiplayer gaming application where you have a leaderboard that is constantly changing on the server. Alternatively you could also use this for building a chat application. In a chat app, users are constantly sending messages to recipients and the server needs to be able to push these messages to the right recipients and allow for multiple messages to be sent to multiple people at once.\n\nIf you want to learn more, I found that this youtube video below by Fireship to be helpful in providing a quick review!"
    },
    {
        "link": "https://stackoverflow.com/questions/64187809/how-to-stream-a-live-video-along-audio-with-syn-via-java-over-socket",
        "document": "This is a really broad question, so it's difficult to provide a satisfactory answer. I can point you to some resources though.\n\nFirstly, a popular protocol for this kind of application is the following: https://en.wikipedia.org/wiki/Real_Time_Streaming_Protocol\n\nHere is a link to a promising paper going in-depth on how this protocol can be implemented using Java: https://www.researchgate.net/publication/228974152_A_Java-based_adaptive_media_streaming_on-demand_platform\n\nOf course, you can also choose to use a pre-existing API (there are plenty of options). Additionally here are some StackOverflow posts that also touch upon this subject:\n\nReal-time audio streaming using HTTP - choosing the protocol and Java implementation"
    },
    {
        "link": "https://wowza.com/docs/how-to-create-a-websocket-server",
        "document": "With Wowza Streaming Engine™ media server software version 4.5.0 and later, you can use an HTTP provider to host a WebSocket communication session. HTTP providers are Java classes that are configured on a per-virtual host basis. They are lightweight web applications that can send information to or obtain information from a Wowza Streaming Engine server instance. This article describes how to create an HTTP provider to host a WebSocket session.\n\nA WebSocket session provides a persistent connection between a browser and Wowza Streaming Engine. The WebSocket protocol can be used to send text or binary data between browsers. Examples of WebSocket applications are text, chat, out-of-band metadata, and control data.\n\nHTTP providers are lighweight HTTP web applications that extend Wowza Streaming Engine functionality. They are configured on a per-port basis in [install-dir]/conf/VHost.xml. An individual HTTP provider can be protected by a user name and password. Multiple HTTP providers can be attached to a single port and a specific HTTP provider can be selected based on a request filter. HTTP providers can also host WebSocket sessions for sending asynchronous, bi-directional information to and from a Wowza Streaming Engine instance.\n\nThe WebSocket protocol provides full-duplex communication changes over a TCP connection. The WebSocket protocol is supported by most modern web browsers and can be used with socket servers such as node.js. A WebSocket connection starts as an HTTP upgrade request. In your HTTP provider, you can accept the upgrade request and a WebSocket session is created and used to send and receive messages.\n\n\n\nYou'll need the Wowza™ IDE for Eclipse. See Extend Wowza Streaming Engine using the Wowza IDE.\n\n\n\nEach HTTP provider extends the HTTPProvider2Base. For more information about creating and configuring HTTP providers, see Create a Wowza Streaming Engine HTTP provider.\n\nThe following is an example of an HTTP provider that supports the WebSocket protocol:\n\nThis HTTP provider echos back the WebSocket messages it receives and periodically broadcasts a text WebSocket message to all connected sessions.\n\n\n\nWebSocket messages are received by a listener class that implements the IWebSocketEventNotify interface. We recommend that you create a class that extends the WebSocketEventNotifyBase and overrides the callback methods you want to use.\n\n \n\n There are two types of WebSocket messages: binary and text.\n• A text WebSocket message is created using the following API:\n• A binary Websocket message is created using one of the following APIs:\n\nA WebSocket message can be sent over an individual WebSocketSession using the following API:\n\nAn HTTP provider maintains a list of active WebSocket sessions. A message can be broadcast to all sessions of a given HTTP provider using the following API:\n\nWith an HTTP provider, you can view information from your own specified URL. For example:\n\nThe following is an example of HTML and JavaScript that corresponds to the WebSocket HTTP provider above, and can be used to send and receive message to a web browser. This file must be hosted on a web server as an HTML file. You need to change the wsURL variable to point to your Wowza Streaming Engine instance that's running the WebSocket HTTP provider:\n• Make an HTML page with graphics and scripts using an HTTP provider in the Wowza Streaming Engine Java API"
    }
]