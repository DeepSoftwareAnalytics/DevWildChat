[
    {
        "link": "https://airsdk.dev/reference/actionscript/3.0/flash/filters/BlurFilter.html",
        "document": "The BlurFilter class lets you apply a blur visual effect to display objects. A blur effect softens the details of an image. You can produce blurs that range from a softly unfocused look to a Gaussian blur, a hazy appearance like viewing an image through semi-opaque glass. When theproperty of this filter is set to low, the result is a softly unfocused look. When theproperty is set to high, it approximates a Gaussian blur filter. You can apply the filter to any display object (that is, objects that inherit from the DisplayObject class), such as MovieClip, SimpleButton, TextField, and Video objects, as well as to BitmapData objects.\n\nTo create a new filter, use the constructor . The use of filters depends on the object to which you apply the filter:\n• To apply filters to movie clips, text fields, buttons, and video, use the property (inherited from DisplayObject). Setting the property of an object does not modify the object, and you can remove the filter by clearing the property.\n• To apply filters to BitmapData objects, use the method. Calling on a BitmapData object takes the source BitmapData object and the filter object and generates a filtered image as a result.\n\nIf you apply a filter to a display object, the property of the display object is set to . If you remove all filters, the original value of is restored.\n\nThis filter supports Stage scaling. However, it does not support general scaling, rotation, and skewing. If the object itself is scaled ( and are not set to 100%), the filter effect is not scaled. It is scaled only when the user zooms in on the Stage.\n\nA filter is not applied if the resulting image exceeds the maximum dimensions. In AIR 1.5 and Flash Player 10, the maximum is 8,191 pixels in width or height, and the total number of pixels cannot exceed 16,777,215 pixels. (So, if an image is 8,191 pixels wide, it can only be 2,048 pixels high.) In Flash Player 9 and earlier and AIR 1.1 and earlier, the limitation is 2,880 pixels in height and 2,880 pixels in width. If, for example, you zoom in on a large movie clip with a filter applied, the filter is turned off if the resulting image exceeds the maximum dimensions."
    },
    {
        "link": "https://bensilvis.com/as3-blurry-vision-effect",
        "document": "So I’m sitting here, having recently misplaced my glasses, and it’s become quite apparent to me that I can’t see. Somehow in the midst of the unfortunate circumstances I find the inspiration for my first tutorial:\n\nThe BlurFilter applies a blur to visual objects in your scene.\n\n It is one of AS3’s various filter effects including: Glow, Drop Shadow, and Bevel\n\n Play around with slider in the example above and you will see something similar to a Gaussian blur effect.\n\nLet’s look at some code then, shall we?\n\nThese are all the imports we should need in our package to achieve a blur effect.\n\nWhat we do here is:\n• Create an array which we add our filter to\n• Apply our filter array to a specified object\n• blurX: the amount of blur to apply in the X direction (0 – 255)\n• blurY: the amount of blur to apply in the Y direction (0 – 255)\n\nThe higher the blur values, the more blur you will see applied to your object. In the code above we set both of these values to 10. You can just as easily though blur in only the X or Y direction for a clever motion blur effect. Remember that the higher the blur value the more cpu intensive the blur becomes.\n\nNote: The way that the blur passes are processed it is more efficient to use powers of 2. (2, 4, 8, 16, etc.)\n\nYou may have been confused that my example code has quality set to BitmapFilterQuality.HIGH, while the default parameters directly above show quality as an integer of 1. The quality in itself is just a value telling Flash how many times to apply the blur. Generally the pre-made quality types are sufficient, but if you need you can replace BitmapFilterQuality with an integer (0 – 15).\n\nHere we create a new array myFilters and then push the BlurFilter we previously created into it. If we were planning on applying multiple kinds of filters to our object, we would add each of them to this array.\n\nHere we apply all of our filters (in this case the BlurFilter) to DisplayObject blurredMC.\n\nI guess I should mention that if you don’t want to deal with all this code crap, you can still apply filters to your object via the Filter’s tab. (Flash 8 and higher). You can find this at Window > Properties > Filters\n\nSo wraps up my first ever Flash tutorial! I hope it was exceedingly beneficial to you. Well, even if it wasn’t I would love to hear any constructive criticism.\n\nI’ve provided the source to the example above. Enjoy!"
    },
    {
        "link": "https://doc.neolao.com/as3_langref/flash/filters/BlurFilter.html",
        "document": "The BlurFilter class lets you apply a blur visual effect to display objects. A blur effect softens the details of an image. You can produce blurs that range from a softly unfocused look to a Gaussian blur, a hazy appearance like viewing an image through semi-opaque glass. When theproperty of this filter is set to low, the result is a softly unfocused look. When theproperty is set to high, it approximates a Gaussian blur filter. You can apply the filter to any display object (that is, objects that inherit from the DisplayObject class), such as MovieClip, SimpleButton, TextField, and Video objects, as well as to BitmapData objects.\n\nTo create a new filter, use the constructor . The use of filters depends on the object to which you apply the filter:\n• To apply filters to movie clips, text fields, buttons, and video, use the property (inherited from DisplayObject). Setting the property of an object does not modify the object, and you can remove the filter by clearing the property.\n• To apply filters to BitmapData objects, use the method. Calling on a BitmapData object takes the source BitmapData object and the filter object and generates a filtered image as a result.\n\nIf you apply a filter to a display object, the property of the display object is set to . If you remove all filters, the original value of is restored.\n\nThis filter supports Stage scaling. However, it does not support general scaling, rotation, and skewing. If the object itself is scaled ( and are not set to 100%), the filter effect is not scaled. It is scaled only when the user zooms in on the Stage.\n\nA filter is not applied if the resulting image exceeds the maximum dimensions. In AIR 1.5 and Flash Player 10, the maximum is 8,191 pixels in width or height, and the total number of pixels cannot exceed 16,777,215 pixels. (So, if an image is 8,191 pixels wide, it can only be 2,048 pixels high.) In Flash Player 9 and earlier and AIR 1.1 and earlier, the limitation is 2,880 pixels in height and 2,880 pixels in width. If, for example, you zoom in on a large movie clip with a filter applied, the filter is turned off if the resulting image exceeds the maximum dimensions."
    },
    {
        "link": "https://stackoverflow.com/questions/1189226/apply-filter-to-everything-in-as3",
        "document": "I'm trying to add a filter in AS3/Flex SDK. I can add a filter just fine to any one single object - but I want to apply the filter to everything that is a child of a certain object.\n\nThink a pause window pops up, and everything below the pause window goes blurry.\n\nApplying a filter to each individual object (eg: iterating through a list) doesn't work, as the filters from each object can then overlap and look pretty ugly.\n\nDoes anyone know how to go about doing this? Is there a way to apply a filter to everything?\n\nNeither the directly-drawn graphics nor the children get the blur effect applied. I've tried altering the defaults and tried other filters:\n\nWith identical effects (that is to say: none). What DOES work, is:\n\nbut produces the above mentioned problems with multiple filters not aligning properly."
    },
    {
        "link": "https://helpx.adobe.com/animate/using/graphic-filters.html",
        "document": ""
    },
    {
        "link": "https://airsdk.dev/docs/development/display/filtering-display-objects/available-display-filters",
        "document": "ActionScript 3.0 includes ten filter classes that you can apply to display objects and BitmapData objects:\n\nThe first six filters are simple filters that can be used to create one specific effect, with some customization of the effect available. Those six filters can be applied using ActionScript, and can also be applied to objects in Flash Professional using the Filters panel. Consequently, even if you're applying filters using ActionScript, if you have Flash Professional you can use the visual interface to quickly try out different filters and settings to figure out how to create a desired effect.\n\nThe final four filters are available in ActionScript only. Those filters, the color matrix filter, convolution filter, displacement map filter, and shader filter, are much more flexible in the types of effects that they can be used to create. Rather than being optimized for a single effect, they provide power and flexibility. For example, by selecting different values for its matrix, the convolution filter can be used to create effects such as blurring, embossing, sharpening, finding color edges, transformations, and more.\n\nEach of the filters, whether simple or complex, can be customized using their properties. Generally, you have two choices for setting filter properties. All the filters let you set the properties by passing parameter values to the filter object's constructor. Alternatively, whether or not you set the filter properties by passing parameters, you can adjust the filters later by setting values for the filter object's properties. Most of the example code listings set the properties directlyto make the example easier to follow. Nevertheless, you could usually achieve the same result in fewer lines of code by passing the values as parameters in the filter object's constructor. For more details on the specifics of each filter, its properties and its constructor parameters, see the listings for the flash.filters package in the ActionScript 3.0 Reference for the Adobe Flash Platform."
    },
    {
        "link": "https://home.csulb.edu/~arezaei/ETEC570/Action%20script%203.pdf",
        "document": ""
    },
    {
        "link": "https://airsdk.dev/reference/actionscript/3.0/flash/display/DisplayObject.html",
        "document": "For more information, see the \"Display Programming\" chapter of the ActionScript 3.0 Developer's Guide.\n\nSome properties previously used in the ActionScript 1.0 and 2.0 MovieClip, TextField, and Button classes (such as _alpha , _height , _name , _width , _x , _y , and others) have equivalents in the ActionScript 3.0 DisplayObject class that are renamed so that they no longer begin with the underscore (_) character.\n\nThe DisplayObject class contains several broadcast events. Normally, the target of any particular event is a specific DisplayObject instance. For example, the target of an added event is the specific DisplayObject instance that was added to the display list. Having a single target restricts the placement of event listeners to that target and in some cases the target's ancestors on the display list. With broadcast events, however, the target is not a specific DisplayObject instance, but rather all DisplayObject instances, including those that are not on the display list. This means that you can add a listener to any DisplayObject instance to listen for broadcast events. In addition to the broadcast events listed in the DisplayObject class's Events table, the DisplayObject class also inherits two broadcast events from the EventDispatcher class: activate and deactivate .\n\nThe DisplayObject class itself does not include any APIs for rendering content onscreen. For that reason, if you want create a custom subclass of the DisplayObject class, you will want to extend one of its subclasses that do have APIs for rendering content onscreen, such as the Shape, Sprite, Bitmap, SimpleButton, TextField, or MovieClip class.\n\nDisplayObject is an abstract base class; therefore, you cannot call DisplayObject directly. Invoking new DisplayObject() throws an ArgumentError exception.\n\nThe DisplayObject class supports basic functionality like the x and y position of an object, as well as more advanced properties of the object such as its transformation matrix.\n\nThe DisplayObject class is the base class for all objects that can be placed on the display list. The display list manages all objects displayed in the Flash runtimes. Use the DisplayObjectContainer class to arrange the display objects in the display list. DisplayObjectContainer objects can have child display objects, while other display objects, such as Shape and TextField objects, are \"leaf\" nodes that have only parents and siblings, no children.\n\nIndicates the z coordinate position along the z-axis of the DisplayObject instance relative to the 3D parent container.\n\nIndicates the y coordinate of the DisplayObject instance relative to the local coordinates of the parent DisplayObjectContainer.\n\nIndicates the x coordinate of the DisplayObject instance relative to the local coordinates of the parent DisplayObjectContainer.\n\nIndicates the depth scale (percentage) of an object as applied from the registration point of the object.\n\nIndicates the vertical scale (percentage) of an object as applied from the registration point of the object.\n\nIndicates the horizontal scale (percentage) of the object as applied from the registration point.\n\nIndicates the z-axis rotation of the DisplayObject instance, in degrees, from its original orientation relative to the 3D parent container.\n\nIndicates the y-axis rotation of the DisplayObject instance, in degrees, from its original orientation relative to the 3D parent container.\n\nIndicates the x-axis rotation of the DisplayObject instance, in degrees, from its original orientation relative to the 3D parent container.\n\nIndicates the rotation of the DisplayObject instance, in degrees, from its original orientation.\n\n[read-only] For a display object in a loaded SWF file, the root property is the top-most display object in the portion of the display list's tree structure represented by that SWF file.\n\n[read-only] Indicates the y coordinate of the mouse or user input device position, in pixels.\n\n[read-only] Indicates the x coordinate of the mouse or user input device position, in pixels.\n\nObtains the meta data object of the DisplayObject instance if meta data was stored alongside the the instance of this DisplayObject in the SWF file through a PlaceObject4 tag.\n\n[read-only] Returns a LoaderInfo object containing information about loading the file to which this display object belongs.\n\nAn indexed array that contains each filter object currently associated with the display object.\n\nIf non-null, this Matrix object defines how a display object is rendered when cacheAsBitmap is set to true .\n\n[write-only] Sets a shader that is used for blending the foreground and background.\n\nA value from the BlendMode class that specifies which blend mode to use.\n\nIndicates the alpha transparency value of the object specified.\n\nChecks whether an event listener is registered with this EventDispatcher object or any of its ancestors for the specified event type.\n\nIndicates whether the specified property exists and is enumerable.\n\nIndicates whether an instance of the Object class is in the prototype chain of the object specified as the parameter.\n\nEvaluates the display object to see if it overlaps or intersects with the point specified by the x and y parameters.\n\nEvaluates the bounding box of the display object to see if it overlaps or intersects with the bounding box of the obj display object.\n\nChecks whether the EventDispatcher object has any listeners registered for a specific type of event.\n\nReturns a rectangle that defines the boundary of the display object, based on the coordinate system defined by the targetCoordinateSpace parameter, excluding any strokes on shapes.\n\nReturns a rectangle that defines the area of the display object relative to the coordinate system of the targetCoordinateSpace object.\n\nRegisters an event listener object with an EventDispatcher object so that the listener receives notification of an event.\n\n[read-write] A value from the BlendMode class that specifies which blend mode to use. A bitmap can be drawn internally in two ways. If you have a blend mode enabled or an external clipping mask, the bitmap is drawn by adding a bitmap-filled square shape to the vector render. If you attempt to set this property to an invalid value, Flash runtimes set the value to . The property affects each pixel of the display object. Each pixel is composed of three constituent colors (red, green, and blue), and each constituent color has a value between 0x00 and 0xFF. Flash Player or Adobe AIR compares each constituent color of one pixel in the movie clip with the corresponding color of the pixel in the background. For example, if is set to , Flash Player or Adobe AIR compares the red value of the display object with the red value of the background, and uses the lighter of the two as the value for the red component of the displayed color. The following table describes the settings. The BlendMode class defines string values you can use. The illustrations in the table show values applied to a circular display object (2) superimposed on another display object (1). The display object appears in front of the background. Pixel values of the display object override those of the background. Where the display object is transparent, the background is visible. Forces the creation of a transparency group for the display object. This means that the display object is pre-composed in a temporary buffer before it is processed further. This is done automatically if the display object is pre-cached using bitmap caching or if the display object is a display object container with at least one child object with a setting other than . Not supported under GPU rendering. Multiplies the values of the display object constituent colors by the colors of the background color, and then normalizes by dividing by 0xFF, resulting in darker colors. This setting is commonly used for shadows and depth effects. For example, if a constituent color (such as red) of one pixel in the display object and the corresponding color of the pixel in the background both have the value 0x88, the multiplied result is 0x4840. Dividing by 0xFF yields a value of 0x48 for that constituent color, which is a darker shade than the color of the display object or the color of the background. Multiplies the complement (inverse) of the display object color by the complement of the background color, resulting in a bleaching effect. This setting is commonly used for highlights or to remove black areas of the display object. Selects the lighter of the constituent colors of the display object and the color of the background (the colors with the larger values). This setting is commonly used for superimposing type. For example, if the display object has a pixel with an RGB value of 0xFFCC33, and the background pixel has an RGB value of 0xDDF800, the resulting RGB value for the displayed pixel is 0xFFF833 (because 0xFF > 0xDD, 0xCC < 0xF8, and 0x33 > 0x00 = 33). Not supported under GPU rendering. Selects the darker of the constituent colors of the display object and the colors of the background (the colors with the smaller values). This setting is commonly used for superimposing type. For example, if the display object has a pixel with an RGB value of 0xFFCC33, and the background pixel has an RGB value of 0xDDF800, the resulting RGB value for the displayed pixel is 0xDDCC00 (because 0xFF > 0xDD, 0xCC < 0xF8, and 0x33 > 0x00 = 33). Not supported under GPU rendering. Compares the constituent colors of the display object with the colors of its background, and subtracts the darker of the values of the two constituent colors from the lighter value. This setting is commonly used for more vibrant colors. For example, if the display object has a pixel with an RGB value of 0xFFCC33, and the background pixel has an RGB value of 0xDDF800, the resulting RGB value for the displayed pixel is 0x222C33 (because 0xFF - 0xDD = 0x22, 0xF8 - 0xCC = 0x2C, and 0x33 - 0x00 = 0x33). Adds the values of the constituent colors of the display object to the colors of its background, applying a ceiling of 0xFF. This setting is commonly used for animating a lightening dissolve between two objects. For example, if the display object has a pixel with an RGB value of 0xAAA633, and the background pixel has an RGB value of 0xDD2200, the resulting RGB value for the displayed pixel is 0xFFC833 (because 0xAA + 0xDD > 0xFF, 0xA6 + 0x22 = 0xC8, and 0x33 + 0x00 = 0x33). Subtracts the values of the constituent colors in the display object from the values of the background color, applying a floor of 0. This setting is commonly used for animating a darkening dissolve between two objects. For example, if the display object has a pixel with an RGB value of 0xAA2233, and the background pixel has an RGB value of 0xDDA600, the resulting RGB value for the displayed pixel is 0x338400 (because 0xDD - 0xAA = 0x33, 0xA6 - 0x22 = 0x84, and 0x00 - 0x33 < 0x00). Applies the alpha value of each pixel of the display object to the background. This requires the setting of the parent display object to be set to . For example, in the illustration, the parent display object, which is a white background, has . Not supported under GPU rendering. Erases the background based on the alpha value of the display object. This requires the of the parent display object to be set to . For example, in the illustration, the parent display object, which is a white background, has . Not supported under GPU rendering. Adjusts the color of each pixel based on the darkness of the background. If the background is lighter than 50% gray, the display object and background colors are screened, which results in a lighter color. If the background is darker than 50% gray, the colors are multiplied, which results in a darker color. This setting is commonly used for shading effects. Not supported under GPU rendering. Adjusts the color of each pixel based on the darkness of the display object. If the display object is lighter than 50% gray, the display object and background colors are screened, which results in a lighter color. If the display object is darker than 50% gray, the colors are multiplied, which results in a darker color. This setting is commonly used for shading effects. Not supported under GPU rendering. Adjusts the color using a custom shader routine. The shader that is used is specified as the Shader instance assigned to the property. Setting the property of a display object to a Shader instance automatically sets the display object's property to . If the property is set to without first setting the property, the property is set to . Not supported under GPU rendering. \n\n \n\n \n\n \n\n \n\nThe following code creates two sprite objects, a square and a circle, and sets the blend mode of the circle (in the foreground) to when the pointer rolls over the circle: The following code creates two sprite objects, a square and a circle, and sets the blend mode of the circle (in the foreground) towhen the pointer rolls over the circle:\n\n[read-write] If set to , Flash runtimes cache an internal bitmap representation of the display object. This caching can increase performance for display objects that contain complex vector content. All vector data for a display object that has a cached bitmap is drawn to the bitmap instead of the main display. If is null or unsupported, the bitmap is then copied to the main display as unstretched, unrotated pixels snapped to the nearest pixel boundaries. Pixels are mapped 1 to 1 with the parent object. If the bounds of the bitmap change, the bitmap is recreated instead of being stretched. If is non-null and supported, the object is drawn to the off-screen bitmap using that matrix and the stretched and/or rotated results of that rendering are used to draw the object to the main display. No internal bitmap is created unless the property is set to . After you set the property to , the rendering does not change, however the display object performs pixel snapping automatically. The animation speed can be significantly faster depending on the complexity of the vector content. The property is automatically set to whenever you apply a filter to a display object (when its array is not empty), and if a display object has a filter applied to it, is reported as for that display object, even if you set the property to . If you clear all filters for a display object, the setting changes to what it was last set to. A display object does not use a bitmap even if the property is set to and instead renders from vector data in the following cases:\n• The bitmap is too large. In AIR 1.5 and Flash Player 10, the maximum size for a bitmap image is 8,191 pixels in width or height, and the total number of pixels cannot exceed 16,777,215 pixels. (So, if a bitmap image is 8,191 pixels wide, it can only be 2,048 pixels high.) In Flash Player 9 and earlier, the limitation is is 2880 pixels in height and 2,880 pixels in width.\n• The bitmap fails to allocate (out of memory error). The property is best used with movie clips that have mostly static content and that do not scale and rotate frequently. With such movie clips, can lead to performance increases when the movie clip is translated (when its x and y position is changed). \n\n \n\n \n\n \n\n \n\nThe following example applies a drop shadow to a Shape instance. It then traces the value of the property, which is set to when the filter is applied: The following example applies a drop shadow to a Shape instance. It then traces the value of theproperty, which is set towhen the filter is applied:\n\n[read-write] If non-null, this Matrix object defines how a display object is rendered when is set to . The application uses this matrix as a transformation matrix that is applied when rendering the bitmap version of the display object. AIR profile support: This feature is supported on mobile devices, but it is not supported on desktop operating systems. It also has limited support on AIR for TV devices. Specifically, on AIR for TV devices, supported transformations include scaling and translation, but not rotation and skewing. See AIR Profile Support for more information regarding API support across multiple profiles. With set, the application retains a cached bitmap image across various 2D transformations, including translation, rotation, and scaling. If the application uses hardware acceleration, the object will be stored in video memory as a texture. This allows the GPU to apply the supported transformations to the object. The GPU can perform these transformations faster than the CPU. To use the hardware acceleration, set Rendering to GPU in the General tab of the iPhone Settings dialog box in Flash Professional CS5. Or set the property to in the application descriptor file. Note that AIR for TV devices automatically use hardware acceleration if it is available. For example, the following code sends an untransformed bitmap representation of the display object to the GPU: Usually, the identity matrix ( ) suffices. However, you can use another matrix, such as a scaled-down matrix, to upload a different bitmap to the GPU. For example, the following example applies a matrix that is scaled by 0.5 on the x and y axes. The bitmap object that the GPU uses is smaller, however the GPU adjusts its size to match the transform.matrix property of the display object: matrix:Matrix = new Matrix(); // creates an identity matrix matrix.scale(0.5, 0.5); // scales the matrix mySprite.cacheAsBitmapMatrix = matrix; mySprite.cacheAsBitmap = true; Generally, you should choose to use a matrix that transforms the display object to the size that it will appear in the application. For example, if your application displays the bitmap version of the sprite scaled down by a half, use a matrix that scales down by a half. If you application will display the sprite larger than its current dimensions, use a matrix that scales up by that factor. Note: The property is suitable for 2D transformations. If you need to apply transformations in 3D, you may do so by setting a 3D property of the object and manipulating its property. If the application is packaged using GPU mode, this allows the 3D transforms to be applied to the object by the GPU. The is ignored for 3D objects. \n\n \n\n \n\n \n\n \n\nThe following example applies uses the property to apply transformations to a bitmap version of the movie clip . import flash.geom.Matrix; import flash.display.*; import flash.utils.Timer; var my_shape:MovieClip = new MovieClip(); my_shape.graphics.beginFill(0xCCFF00); my_shape.graphics.drawRect(200, 0, 100, 100); addChild(my_shape); var my_timer:Timer = new Timer(250); my_timer.start(); my_timer.addEventListener(TimerEvent.TIMER, timerHandler); // make sure this Display Object remains cached for all 2D transforms my_shape.cacheAsBitmap = true; my_shape.cacheAsBitmapMatrix = new Matrix(); // rotation variables const initAngle:Number = 0; const pi:Number = 3.142; const incrAngle:Number = pi/10; // scaling variables const initScale:Number = 0.25; const incrScale: Number = 1.1; var initHeight : Number = my_shape.height; var initWidth : Number = my_shape.width; // translation variables var incrX : Number = root.width / 20; var incrY : Number = root.height / 10; // do some initial transforms var tempMat : Matrix = my_shape.transform.matrix; tempMat.rotate(initAngle); tempMat.scale(initScale, initScale); my_shape.transform.matrix = tempMat; function timerHandler(evt:TimerEvent):void { tempMat = my_shape.transform.matrix; tempMat.rotate(incrAngle); tempMat.translate(incrX, incrY); tempMat.scale(incrScale, incrScale); my_shape.transform.matrix = tempMat; // ensure we are still in a reasonable state or reset if(my_shape.height > stage.stageHeight/2) { my_shape.height = initHeight; } if(my_shape.width > stage.stageWidth/2) { my_shape.width = initWidth; } if(my_shape.x > stage.stageWidth) { my_shape.x = 0; } else if (my_shape.x < 0) { my_shape.x = stage.stageWidth; } if(my_shape.y > stage.stageHeight) { my_shape.y = 0; } else if (my_shape.y < 0) { my_shape.y = stage.stageHeight; } } The following example applies uses theproperty to apply transformations to a bitmap version of the movie clip\n\n[read-write] An indexed array that contains each filter object currently associated with the display object. The flash.filters package contains several classes that define specific filters you can use. Filters can be applied in Flash Professional at design time, or at run time by using ActionScript code. To apply a filter by using ActionScript, you must make a temporary copy of the entire array, modify the temporary array, then assign the value of the temporary array back to the array. You cannot directly add a new filter object to the array. To add a filter by using ActionScript, perform the following steps (assume that the target display object is named ):\n• Create a new filter object by using the constructor method of your chosen filter class.\n• Assign the value of the array to a temporary array, such as one named .\n• Add the new filter object to the temporary array.\n• Assign the value of the temporary array to the array. If the array is undefined, you do not need to use a temporary array. Instead, you can directly assign an array literal that contains one or more filter objects that you create. The first example in the Examples section adds a drop shadow filter by using code that handles both defined and undefined arrays. To modify an existing filter object, you must use the technique of modifying a copy of the array:\n• Assign the value of the array to a temporary array, such as one named .\n• Modify the property by using the temporary array, . For example, to set the quality property of the first filter in the array, you could use the following code:\n• Assign the value of the temporary array to the array. At load time, if a display object has an associated filter, it is marked to cache itself as a transparent bitmap. From this point forward, as long as the display object has a valid filter list, the player caches the display object as a bitmap. This source bitmap is used as a source image for the filter effects. Each display object usually has two bitmaps: one with the original unfiltered source display object and another for the final image after filtering. The final image is used when rendering. As long as the display object does not change, the final image does not need updating. The flash.filters package includes classes for filters. For example, to create a DropShadow filter, you would write: You can use the operator to determine the type of filter assigned to each index position in the array. For example, the following code shows how to determine the position of the first filter in the array that is a DropShadowFilter: import flash.text.TextField; import flash.filters.*; var tf:TextField = new TextField(); var filter1:DropShadowFilter = new DropShadowFilter(); var filter2:GradientGlowFilter = new GradientGlowFilter(); tf.filters = [filter1, filter2]; tf.text = \"DropShadow index: \" + filterPosition(tf, DropShadowFilter).toString(); // 0 addChild(tf) function filterPosition(displayObject:DisplayObject, filterClass:Class):int { for (var i:uint = 0; i < displayObject.filters.length; i++) { if (displayObject.filters[i] is filterClass) { return i; } } return -1; } Note: Since you cannot directly add a new filter object to the array, the following code has no effect on the target display object, named : \n\n \n\n \n\n \n\n \n\n — When includes a ShaderFilter and the shader output type is not compatible with this operation (the shader must specify a output). — When includes a ShaderFilter and the shader doesn't specify any image input or the first input is not an input. — When includes a ShaderFilter and the shader specifies an image input that isn't provided. — When includes a ShaderFilter, a ByteArray or Vector.<Number> instance as a shader input, and the and properties aren't specified for the ShaderInput object, or the specified values don't match the amount of data in the input data. See the property for more information."
    },
    {
        "link": "https://isbe.net/CTEDocuments/BMCE-680098.pdf",
        "document": "Every child will make significant academic gains each year, increasing their knowledge, skills, and opportunities so they graduate equipped to pursue a successful future, with the state paying special attention to addressing historic inequities.\n\nAll districts and schools will receive the resources necessary to create safe, healthy, and welcoming learning environments, and will be equipped to meet the unique academic and social and emotional needs of each and every student."
    },
    {
        "link": "https://dl.icdst.org/pdfs/files/0f48b384430965fe36fd4db403d59b6f.pdf",
        "document": ""
    }
]