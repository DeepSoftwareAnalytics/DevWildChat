[
    {
        "link": "https://stackoverflow.com/questions/834270/visual-studio-post-build-event-copy-to-relative-directory-location",
        "document": "Would it not make sense to use msbuild directly? If you are doing this with every build, then you can add a msbuild task at the end? If you would just like to see if you can’t find another macro value that is not showed on the Visual Studio IDE, you could switch on the msbuild options to diagnostic and that will show you all of the variables that you could use, as well as their current value.\n\nTo switch this on in visual studio, go to Tools/Options then scroll down the tree view to the section called Projects and Solutions, expand that and click on Build and Run, at the right their is a drop down that specify the build output verbosity, setting that to diagnostic, will show you what other macro values you could use.\n\nBecause I don’t quite know to what level you would like to go, and how complex you want your build to be, this might give you some idea. I have recently been doing build scripts, that even execute SQL code as part of the build. If you would like some more help or even some sample build scripts, let me know, but if it is just a small process you want to run at the end of the build, the perhaps going the full msbuild script is a bit of over kill."
    },
    {
        "link": "https://stackoverflow.com/questions/30319490/visual-studio-post-build-event-command-line-for-syntax",
        "document": "Trying to copy all .dll(s) I get from after compiling , from the default directory (same as the .exe) to a sub-folder.\n\nI have problem with the syntax. What is the correct way of doing it?\n\nNote: This would give no errors (but would copy only 1 .dll, not all):"
    },
    {
        "link": "https://learn.microsoft.com/en-us/visualstudio/ide/reference/pre-build-event-post-build-event-command-line-dialog-box?view=vs-2019",
        "document": "You can type pre- or post-build events for the Build Events Page, Project Designer (C#) directly in the edit box, or you can select pre- and post-build macros from a list of available macros.\n\nContains the events to run either for pre-build or post-build.\n\nExpands the edit box to display a list of macros to insert in the command-line edit box.\n\nLists the available macros and its value. See Macros below for a description of each. You can select only one macro at a time to insert into the command-line edit box.\n\nInserts into the command line edit box the macro selected in the macro table.\n\nYou can use any of these macros to specify locations for files, or to get the actual name of the input file in the case of multiple selections. These macros are not case-sensitive.\n• How to: Specify Build Events (Visual Basic)\n• How to: Specify Build Events (C#)"
    },
    {
        "link": "https://jeremybytes.blogspot.com/2020/05/post-build-events-and-net-core.html",
        "document": ".NET Core and the Lack of Solutions\n\nI have used post-build events in Visual Studio for a long time, primarily to copy files from one location to another. But due to changes in how we work with .NET Core, I have changed the way I write build events.Short version:Let's look at an example of how I use post-build events. Here's the folder structure for a solution:This solution has 4 projects: (1) \"Common\" is a shared library with cross-cutting classes defined; (2) \"PeopleViewer\" is a desktop application, (3) \"PeopleViewer.Presentation\" is a view-model class library, and (4) \"PersonReader.CSV\" is a data reader.The top folder, \"AdditionalFiles\", contains a text file with the data. The \"PeopleViewer\" needs access to this file in order for the application to work. So, in this scenario,Here is a post-build event that does this:The \"$(SolutionDir)\" macro expands into the fully qualified path for the solution. This includes the trailing \"\\\". The \"$(TargetDir)\" macro expands to the fully-qualified location where the .exe file ends up -- something like \"[fullpath]\\PeopleViewer\\bin\\Debug\\\" for .NET Framework and \"[fullpath]\\PeopleViewer\\bin\\Debug\n\netcoreapp3.1\" for .NET Core.This works fine when we build the application from Visual Studio:The build succeeds and the file is copied.The problem arises when we leave Visual Studio.In the .NET Core world, the concept of the \"Solution\" is less important. We often open folders (not solutions) in Visual Studio Code. And when we use the command-line tools, we build projects (not solutions). The \".sln\" file is not important in this scenario, and it is generally not used at all.This works because the projects have all of the information that they need to build, including dependencies on other projects and on NuGet packages.So to build the \"PeopleViewer\" project, I can open the command line to the project location and type \"\".But, the post-build event fails:The message tells us that the copy step failed. And if we look closer at the message, we can see why:When trying to expand the macros, the '$(SolutionDir)' is undefined. There is no concept of a solution at this level, just the project. So the build fails.The fix for this is to not use any of the \"Solution\" macros in the post-build events. Instead, set things relative to the current project.Here's an updated post-build event:To get to the \"AdditionalFiles\" folder, we start with the current project folder, then go up a level (with the \"..\").When we build this from Visual Studio, it still works. But more importantly, it works when we build from the command line:Success!Post-build events are really useful, and I'm often using them to copy data files or late-bound assemblies to the output folder of my projects. But I've changed how I use them.It's always exciting to come up with a fix to an issue. But this isn't completely solved.One of the really awesome things about .NET Core is that it is cross platform. I can create applications that will run on Windows, macOS, and Linux.But \"xcopy\" is a Windows command. How do we copy files for other OSes?For that we need to dig into MSBuild. That will wait for the next article, but here's a preview:This block in the project file will copy the files from the \"AdditionalFiles\" folder to the output folder. And it works on macOS and Linux.We'll explore that in the next article.Happy Coding!"
    },
    {
        "link": "https://learn.microsoft.com/en-us/visualstudio/ide/how-to-specify-build-events-csharp?view=vs-2022",
        "document": "Use build events to specify commands that run before the build starts or after the build finishes.\n\nThe build event commands can include any command that is valid at a command prompt or in a .bat file. Available commands are documented in the Windows command reference. The name of a batch file should be preceded by to ensure that all subsequent commands are executed. The batch file itself runs from the output folder, for example, . If you need the same batch file for all configurations, you could put it in the same folder as the project file and use a relative path to it, for example, .\n\nYou can execute PowerShell scripts by entering a command like . The path to the PowerShell script may be absolute, or may be relative to the project directory. You would need to make sure that the execution policy for PowerShell scripts on your operating system is set appropriately in order to run the script. See About execution policies.\n\nIf you want to use another shell, such as bash, you would generally use the same command syntax as you would use to launch a shell script from the Windows command prompt. Using third-party shells is beyond the scope of this documentation, but sites like Stack Overflow might be helpful.\n\nWhen you perform the previous steps, Visual Studio modifies your project file by adding the or target and the necessary MSBuild code to execute the steps you provided. You can open the project file and see the steps. Modifying the steps in the project file is fine. You'll see your changes in the Build > Events section of the project properties after you save changes.\n\nThe element refers to the MSBuild task. See Exec task for information on what other parameters you can use to customize the execution. For example, you can use to set the folder from which the executable is run. The default is the directory that contains the project file.\n\nYou can use MSBuild properties (macros), such as in the previous example, as discussed later in this article at Macros.\n\nThe output of your build events is written to the Build section of the Output Window. To open it, choose View > Other Windows, Output Window, or press Ctrl+Alt+O. In the dropdown next to Show output from, choose Build.\n\nIf your pre-build or post-build event doesn't complete successfully, you can terminate the build by having your event action exit with a code other than zero (0). A zero exit code indicates a successful action; any other exit code is considered an error.\n\nIf your pre-build event fails, you might see an error like this in the Error List window:\n\nIf there's not enough information in the Error List window, you can try using the Output Window to view the full build output, including any output from batch files.\n\nFor guidance on the commands you can use in batch files, see Windows commands.\n\nCommonly available \"macros\" (actually MSBuild properties) are listed at MSBuild common properties. For .NET SDK projects (.NET Core or .NET 5 and later), additional properties are listed at MSBuild properties for Microsoft.NET.Sdk.\n\nIn your scripts for build events, you might want to reference the values of some project-level variables such as the name of the project or the location of the output folder. In prior versions of Visual Studio, these were called macros. The equivalent to macros in recent versions of Visual Studio are MSBuild properties. MSBuild is the build engine that Visual Studio uses to process your project file when it performs a build. A build event in the IDE results in an MSBuild target in the project file. You can use any MSBuild property that is available in the target in your project file (for example, or ). The MSBuild properties that are available to you in these events depend on the files implicitly or explicitly imported in a project file, such and files, and properties set in your project file, such as in elements. Be careful to use the exact spelling of each property. No error is reported if you misspell a property; instead, an undefined property evaluates to an empty string.\n\nFor example, suppose you specify a pre-build event as follows:\n\nThat pre-build event results in the following entry, called a in your project file:\n\nThe build event appears as a target that includes the Exec task with the input you specified as the . Newlines are encoded in the XML.\n\nWhen you build the project in this example, the pre-build event prints the values of some properties. In this example, doesn't produce any output, because it's not defined. It's an optional property that you can define in your project file to give the path to a customized instance of the C# compiler (for example, if you were testing a different version of csc.exe, or an experimental compiler).\n\nOutput from your build events is written to the build output, which can be found in the Output window. In the Show output from dropdown, choose Build.\n• None Create a batch file named in the project folder, with the following contents: Recall that in a batch file, refers to the first argument passed in.\n• None Call the batch file in the Post-build event section of the project properties, and pass an argument using the MSBuild property .\n• None Build your project and check the output folder. You should see the copied file next to the built assembly. In the Output Window, in the Build section, you should see the batch file output: 1>Output file is C:\\source\\repos\\ConsoleApp-BuildEvents\\ConsoleApp-BuildEvents\\bin\\Debug\n\net6.0\\ConsoleApp-BuildEvents.dll 1> 1 file(s) copied. ========== Build: 1 succeeded, 0 failed, 0 up-to-date, 0 skipped ========== ========== Build started at 12:00 PM and took 00.723 seconds ==========\n• How to: Specify build events (Visual Basic)"
    },
    {
        "link": "https://emgu.com/wiki/index.php/Version_History_3.x",
        "document": ""
    },
    {
        "link": "https://emgu.com/wiki/index.php/Version_History",
        "document": ""
    },
    {
        "link": "https://en.morzel.net/post/detecting-a-drone-opencv-in-dotnet-for-beginners-emgu-cv-3-visual-studio-2017-part-1",
        "document": "Emgu CV is a .NET wrapper for OpenCV (Open Source Computer Vision Library) which is a collection of over 2500 algorithms focused on real-time image processing and machine learning. OpenCV lets you write software for:\n• and much, much more...\n\nOpen CV is written in highly optimized C/C++, supports multi-core execution and heterogeneous execution platforms (CPU, GPU, DSP...) thanks to OpenCL. The project was launched in 1999 by Intel Research and is now actively developed by open source community members and contributors from companies like Google, Microsoft or Honda...\n\nMy experience with Emgu CV/OpenCV comes mostly from working on paintball turret project (which I use to have a break from \"boring\" banking stuff at work). I'm far from computer vision expert but I know enough to teach you how to detect a mini quadcopter flying in a room:\n\nIn the upper-left corner you can see frame captured from video file, following that is the background frame (static background and camera makes our task simpler)... Next to it are various stages of image processing run before drone (contour) detection is executed. Last frame shows original frame with drone position marked. Job done! Oh, and if you are wondering what is the \"snow\" seen in the video: these are some particles I put to make the video a bit more \"noisy\"...\n\nI assume that you know a bit about C# programming but are completely new to Emgu CV/OpenCV.\n\nBy the end of this tutorial you will know how to:\n• use Emgu CV 3.2 in C# 7 (Visual Studio 2017) application (most tutorials available online are quite outdated!),\n• find changes between images (diff and binary threshold),\n\nI plan to give detailed description of the whole program (don't worry: it's just about 200 lines) but if you would like to jump straight to the code visit this GitHub repository: https://github.com/morzel85/blog-post-emgucv. It's a simple console app - I've put everything into Program.cs so you can't get lost!\n\nMind that because Emgu CV/OpenCV binaries are quite large these are not included in the repo. This should not be a problem because Visual Studio 2017 should be able to automatically download (restore) the packages...\n\nHere you can download the video I've used for testing: http://morzel.net/download/emgu_cv_drone_test_video.mp4 (4.04 MB, MPEG4 H264 640x480 25fps).\n\nTo start lets use Visual Studio Community 2017 to create new console application:\n\nNow we need to add Emgu CV to our project. The easiest way to do it is to use Nuget to install Emgu CV package published by Emgu Corporation. To do so run \"Install-Package Emgu.CV\" command in Package Manager Console or utilize Visual Studio UI:\n\nIf all goes well package.config and DLL references should look like this (you don't have to worry about ZedGraph):\n\nNow we are ready to test if OpenCV's magic is available to us through Emgu CV wrapper library. Let's do it by creating super simple program that loads an image file and shows it in a window with obligatory \"Hello World!\" title:\n\nRun it and you should see a window with the image you've selected. Here's what I got - visit Kraków if you like my picture :)\n\nAbove code loads picture from a file into Mat class instance. Mat is a n-dimensional dense array containing pointer to image matrix and a header describing this matrix. It supports a reference counting mechanism that saves memory if multiple image processing operations act on same data... Don't worry if it sounds a bit confusing. All you need to know now is that we can load images (from files, webcams, video frames etc.) into Mat objects. If you are curious read this nice description of Mat.\n\nThe other interesting thing you can see in the code is the CvInvoke class. You can use it to call OpenCV functions from your C# application without dealing with complexity of operating native code and data structures from managed code - Emgu the wrapper will do it for you through PInvoke mechanism.\n\nOk, so now you have some idea on what Emgu CV/OpenCV libraries are and how to bring them into your application. Next post coming soon..."
    },
    {
        "link": "https://emgu.com/wiki/index.php/Documentation",
        "document": ""
    },
    {
        "link": "https://emgu.com/wiki/index.php/Setting_up_EMGU_C_Sharp",
        "document": ""
    },
    {
        "link": "https://stackoverflow.com/questions/3704549/visual-studio-post-build-event-throwing-errors",
        "document": "Here are two approaches for interrupting the build when a PowerShell script errors.\n\nUse to terminate the PowerShell process\n\nTo return a status code from the script which, if non-zero, will show up in the error list, use the following:\n\nThis doesn't precisely get the error text onto your error list, but it does terminate the script and get a little something in your error list to indicate which pre- or post-build command failed.\n\nUse a custom MSBuild task to execute the PowerShell script\n\nI spent a little time working out the details of executing a PowerShell script within an MSBuild task. I have a full article with sample code on my blog. Do check it out, as it includes more discussion, and some explanation of how to handle the sample projects. It's probably not a complete or perfect solution, but I got it Working on My MachineTM with a very simple script.\n\nThis approach provides line and column precision when reporting PowerShell errors, and even supports the double-click-takes-me-to-the-file behavior we're accustomed to in Visual Studio. If it's lacking, I'm sure you'll be able to extend it to meet your needs. Also, depending on your version of Visual Studio, you may need to massage details like assembly reference versions.\n\nFirst off, build a custom MSBuild Task in a class library project. The library should reference the following assemblies for MSBuild and PowerShell integration. (Note that this example requires PowerShell 2.0.)\n\nBuild a task class, and expose a property to specify the path to the PowerShell script, like so:\n\nWithin the method, start the PowerShell run time, execute the script, and collect errors. Use the property to log the errors. When finished, close the runspace and return true if the script logged no errors.\n\nAnd that's it. With this assembly in hand, we can configure another project to consume the MSBuild task.\n\nConsider, for example, a C#-based class library project (.csproj). Integrating the task in a post build event requires just a few things.\n\nFirst, register the task just inside the node of the .csproj file like so:\n\nTaskName should be the name of the task class, though it would seem the namespace is not required. is an absolute path to the custom MSBuild task assembly, or relative path with respect to the .csproj file. For assemblies in the GAC, you can use the attribute instead.\n\nOnce registered, the task can be used within pre- and post-build events. Configure a build event within the element of the .csproj file like so:\n\nAnd that's it. When Visual Studio compiles the project, it loads the custom assembly and task object and executes the task. Errors raised by the pipeline are retrieved and reported."
    },
    {
        "link": "https://stackoverflow.com/questions/55853595/how-to-suppress-initial-post-build-event-error-in-visual-studio-2017-c",
        "document": "I have a C# solution in Visual Studio 2017. I also have a batch script called that contains the following code:\n\nMy goal is to get only the test error message above to appear in Visual Studio's Error List when I build a particular project and for the build to stop when it appears. So I put in the project's post-build event command line and then build. Now I'm getting two error messages in the Visual Studio Error List:\n• None The command \"[path to script]\\foobar.bat\" exited with code -1.\n\nIn this case, seeing that first error message that just prints out the contents of my post-build event isn't helpful. I want to suppress this initial error so that only my custom error messages show up in the Error List (or at least change it to say something more useful).\n• Adding to the end of my batch script has no effect.\n• Adding to the end of my batch script suppresses both errors, which isn't what I want.\n• Adding to the end of my batch script has no effect.\n• Adding the line to the end of my batch script has no effect.\n• Adding the following to the end of my .csproj file (per this article) suppresses the first error, but makes it so the build no longer fails:\n\nThe last option almost gets me what I want. However, in spite of there being an error message, the Error List doesn't pop up and the build does not fail. It appears as though anything that would cause the initial error message to not appear will also cause the build to no longer fail. Is that the case? Or is there some way I can get the build to fail without showing that initial error message?"
    },
    {
        "link": "https://medium.com/@jepozdemir/effective-error-handling-in-c-best-practices-ed1052717714",
        "document": "One of the key components of software development is error handling, ensuring that applications gracefully handle unexpected situations and provide a smooth user experience. In C#, a robust error-handling strategy can significantly enhance the reliability and maintainability of your codebase. In this blog post, we’ll explore the best practices for effective error handling in C#.\n\nC# provides a powerful exception handling mechanism using blocks. Use them to catch and handle exceptions gracefully. However, avoid catching generic exceptions ( ) unless absolutely necessary, as it may mask unexpected errors and make debugging challenging.\n\nHandle exceptions at an appropriate level of abstraction. Catch exceptions where you can handle them effectively. This might be at the UI level for user-friendly error messages or at lower levels for logging and recovery.\n\nSwallowing exceptions by catching them without taking any action can hide bugs and make troubleshooting difficult. Log exceptions or handle them appropriately to ensure that issues are addressed or escalated when necessary.\n\nUse blocks to execute cleanup code regardless of whether an exception occurs. This ensures resources are properly released, even if an exception is thrown.\n\nImplement logging to capture details about exceptions, including stack traces, timestamps, and contextual information. Popular logging frameworks in C# include Serilog, NLog, and log4net. Logging assists in diagnosing issues and monitoring application health.\n\nDefine custom exception types for specific error conditions in your application. This enhances code readability and allows callers to handle exceptions more precisely.\n\nIdentify critical errors that indicate the application is in an unstable state and terminate execution promptly. Failing fast helps prevent further damage and facilitates quicker resolution of issues.\n\nValidate inputs, enforce preconditions, and anticipate potential failure points to reduce the likelihood of encountering exceptions. Defensive programming minimizes the occurrence of errors and makes code more robust.\n\nWrite comprehensive unit tests that cover different error scenarios to validate the behavior of error-handling code. Unit tests help identify bugs early in the development process and ensure that error-handling mechanisms function as expected.\n\nProvide clear and consistent error messages to users to aid in troubleshooting and resolution. Include relevant information such as error codes, descriptions, and suggested actions to mitigate the issue.\n\nIn conclusion, effective error handling is essential for developing reliable and maintainable C# applications. By following these best practices, you can improve the resilience of your codebase, enhance the user experience, and streamline troubleshooting and maintenance efforts.\n\nEmbrace a proactive approach to error handling to build robust and resilient software solutions.\n\nThank you for reading. I hope it was helpful."
    },
    {
        "link": "https://stackify.com/csharp-exception-handling-best-practices",
        "document": "Welcome to Stackify’s guide to C# exception handling. In this post, we cover the following topics:\n• How to Create Your Own Custom C# Exception Types\n• Why is this topic so important\n\nIn modern languages like C#, problems are typically modeled using exceptions. Jeff Atwood (of StackOverflow fame) once called exceptions “the bread and butter of modern programming languages.” That should give you an idea of how important this construct is.\n\nRegrettably, booming software developers overlook a crucial subject in their education – effectively managing errors and other code-related issues. In my personal experience, this topic receives insufficient attention.\n\nTutorials and lessons showcasing sample application development too often skip how you manage exceptions, omitting this step for brevity’s sake.\n\nAnd this is a shame, since we could argue that software development is all about handling errors and managing exceptions. When you prioritize brevity, too many programming students become programming professionals who lack an understanding of real-world exception-handling mechanisms.\n\nThis post is our humble contribution to changing that scenario. Let’s dig in.\n\nWhat is an Exception?\n\nExceptions are a type of error that occurs during the execution of an application. Typically, problems that are not anticipated result in errors, whereas the application’s code intentionally foresees exceptions due to various reasons.\n\nApplications use exception handling logic to explicitly handle the exceptions when they happen. Exceptions can occur for a wide variety of reasons. From the infamous NullReferenceException to a database query timeout.\n\nThe Anatomy of C# Exceptions\n\nExceptions allow an application to transfer control from one part of the code to another. When an exception occurs, it disrupts the ongoing code flow and returns control to a parent try-catch block. In C#, you handle exceptions using the following keywords:\n• try – A try block encloses a section of code. When code throws an exception within this block, the corresponding catch handles the exception\n• catch – When an exception happens, the code within the Catch block executes. This is where you are able to handle the exception, log it, or ignore it\n• finally – The finally block enables the execution of specific code irrespective of exception. For instance, it facilitates the disposal of an object that requires disposal\n\nThe C# try and catch keywords help establish a try-catch block, which surrounds code capable of throwing exceptions. This block serves to manage potential exceptions that might arise during execution.\n\nIn case an exception occurs, this try-catch block will manage the exception, which guarantees the application avoids triggering an unhandled exception, user errors, or application crash.\n\nHere, we present a straightforward instance of a method that might raise an exception. We’ll delve into the correct approach of employing a try-catch-finally construct to manage errors effectively.\n\nYour exception handling code can utilize multiple C# catch statements for different types of exceptions, which can be very useful depending on what your code is doing.\n\nIn the previous example, ArgumentNullException occurs only when the website URL passed in is null. A WebException is caused by a wide array of issues. Catching specific types of exceptions can help tailor how to handle them.\n\nException filters introduced in C# 6 enable you to have even more control over your catch blocks and further tailor how you handle specific exceptions. These features help you fine-tune exactly how you handle exceptions and which ones you want to catch.\n\nBefore C# 6, you would have had to catch all types of WebException and handle them. You can now select to manage them only in specific situations and allow different situations to rise to the calling code. Here is a modified example with filters:\n\nProper exception handling is critical to all application code. In the programming world, we often rely on numerous common exceptions that see frequent use. The most common being the dreaded null reference exception. Below are some of the common C# Exception types that you will see regularly.\n\nThe follow is a list of common .NET exceptions:\n• System.NullReferenceException – Very common exception related to calling a method on a null object reference\n• System.IndexOutOfRangeException – Occurs attempting to access an array element that does not exist\n• System.IO.IOException – Used around many file I/O type operations\n• System.StackOverflowException – If a method calls itself recursively, you may get this exception\n• System.OutOfMemoryException – If your app runs out of memory\n• System.InvalidCastException – When attempting to convert an object to an incompatible type\n• System.ObjectDisposedException – Attempting to utilize an object that has already undergone disposal\n\nHow to Create Your Own C# Custom Exception Types\n\nC# exceptions, akin to any other C# object, take the form of classes. All exceptions inherit from a base System.Exception class. You can use many common exceptions within your own code. Commonly, developers use the generic ApplicationException or Exception object to throw custom exceptions. However, you can also create your own type of exceptions.\n\nCrafting your unique C# custom exceptions are most beneficial when you intend to catch a particular exception type and manage it distinctively. Custom exceptions can also be helpful to track a very specific type of exception that you deem extremely critical. You can create a custom exception type to monitor application errors, then use an error monitoring tool to keep track of the logs.\n\nAt Stackify by Netreo, we have created a few custom exception types. One good example is a ClientBillingException. Billing is something we don’t want to mess up. And if it does happen, we want to prioritize handling those exceptions.\n\nUsing a custom exception type, we can write special code to handle that exception. We can also monitor our application for that specific type of exception and notify the on-call person when it happens.\n• Calling code can do custom handling of the custom exception type\n• Ability to do custom monitoring around that custom exception type\n\nHere is a simple example from our code:\n\nWhat Are First Chance Exceptions?\n\nExperiencing numerous exceptions is common; we often throw, catch and subsequently disregard them. The .NET Framework’s internals also throw exceptions that people simply discard. One of the features of C# is something called first chance exceptions, which gives you visibility into every single .NET Exception being thrown.\n\nThe usage of code like the one below is widespread in applications. This code can throw thousands of exceptions a minute and nobody would ever know it. This code is from another blog post about an app that had serious performance problems due to bad exception handling.\n\nIf the reader is null, exceptions will occur.\n\nIf columnName is null, exceptions will occur.\n\nIf columnName does not exist in the results, exceptions will occur.\n\nIf the value for the column is null, exceptions will occur.\n\nIf the value is not a proper DateTime, exceptions will occur.\n\nHow to Enable First Chance Exceptions with Visual Studio\n\nWhen you run your application in Visual Studio, the debugger is running. You can make Visual Studio pause if a C# Exception happens, which can help you find exceptions in your code that you did not know existed.\n\nTo access Exception Settings, go to Debug -> Windows -> Exception Settings\n\nUnder “Common Language Runtime Exceptions” you can select the exceptions you want the debugger to break for automatically. We would suggest just toggling the checkbox for all. When you break for an exception, you can instruct the system to ignore that specific type of exception,if you want to exclude it.\n\nHow to View All Exceptions with Prefix\n\nPrefix, Stackify by Netreo’s .NET profiler, can also show you all of your exceptions and more. Check out the latest on Prefix or start your free trial today!\n\nStackify by Netreo’s Retrace solution for your servers can also collect all first chance exceptions via the .NET profiler. Without any code or config changes, Retrace will automatically collect and show you all of your exceptions.\n\nHow to Subscribe to First Chance Exceptions in Your Code\n\nThe .NET Framework provides a way to subscribe to an event to get a callback anytime an Exception occurs. You could use this feature to capture all of the exceptions in your apps and output exceptions to your Debug window for easy visibility without cluttering your log files.\n\nWhen your console app first starts, you only want to do this once in the Main() method. Or, when an ASP.NET web app starts, you only want to do this once at startup.\n\nProper exception handling is critical for any application. A key part of this process is using a logging library, where you can log exceptions and keep a record of any that occur. Please check out our guide to C# Logging Best Practices to learn more on this subject.\n\nYou can also log your exceptions using NLog, Serilog or log4net. All three frameworks give you the ability to log your exceptions to a file. Each framework enables you to send your logs to various other targets, like a database, Windows Event Viewer, email or an error monitoring service.\n\nExceptions play a critical role in identifying issues within your code, so logging every exception in your application is crucial.\n\nLogging more contextual details helps with troubleshooting an exceptions,knowing the specific customer involved and understanding the key variables in use.\n\nTo learn more about logging contextual data, read this: What is structured logging and why developers need it\n\nWhy Logging Exceptions to a File Is Not Enough\n\nLogging your exceptions to a file is a good best practice. However, this is not enough once your application is running in production. If you don’t log into each server every day and check the log files, you won’t know the exceptions happen. That file becomes a black hole.\n\nAn error monitoring service is a key tool for any development team that allows you to collect all of your exceptions in a central location.\n• View and search all exceptions across all servers and applications\n• Receive email alerts on new exceptions or high error rates\n\nC# Exception Handling: What Comes Next?\n\nError management does not receive enough attention in software development education. This lack of focus is surprising, since handling errors is a basic concern when you write applications.\n\nC#, being a modern language, uses exceptions for handling problematic scenarios in the code. So, learning proper exception handling is essential when you use that language.\n\nIn this post, we’ve offered a comprehensive guide on C# exception handling, covered the basics, like what exceptions are and why they matter, and explored more advanced topics, specifically those related to C#.\n\nWhat should be your next step? For one, don’t stop studying. There is plenty of useful content on exceptions and related topics around the web. As a C# developer, you might find the Microsoft technical documentation portal particularly useful.\n\nAlso, keep reading the Stackify blog, where we often publish content on various tech topics that might be useful for you.\n\nFinally, leverage the power of tools available to you, including Prefix to monitor all exceptions happening in your web app, as they happen. Besides C#/.NET, Prefix is also available for Java. Download and try Prefix today."
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/standard/exceptions/best-practices-for-exceptions",
        "document": "Proper exception handling is essential for application reliability. You can intentionally handle expected exceptions to prevent your app from crashing. However, a crashed app is more reliable and diagnosable than an app with undefined behavior.\n\nThis article describes best practices for handling and creating exceptions.\n\nThe following best practices concern how you handle exceptions:\n• Use try/catch/finally blocks to recover from errors or release resources\n• Design classes so that exceptions can be avoided\n\nUse try/catch/finally blocks to recover from errors or release resources\n\nFor code that can potentially generate an exception, and when your app can recover from that exception, use / blocks around the code. In blocks, always order exceptions from the most derived to the least derived. (All exceptions derive from the Exception class. More derived exceptions aren't handled by a clause that's preceded by a clause for a base exception class.) When your code can't recover from an exception, don't catch that exception. Enable methods further up the call stack to recover if possible.\n\nClean up resources that are allocated with either statements or blocks. Prefer statements to automatically clean up resources when exceptions are thrown. Use blocks to clean up resources that don't implement IDisposable. Code in a clause is almost always executed even when exceptions are thrown.\n\nFor conditions that are likely to occur but might trigger an exception, consider handling them in a way that avoids the exception. For example, if you try to close a connection that's already closed, you'll get an . You can avoid that by using an statement to check the connection state before trying to close it.\n\nIf you don't check the connection state before closing, you can catch the exception.\n\nThe approach to choose depends on how often you expect the event to occur.\n• None Use exception handling if the event doesn't occur often, that is, if the event is truly exceptional and indicates an error, such as an unexpected end-of-file. When you use exception handling, less code is executed in normal conditions.\n• None Check for error conditions in code if the event happens routinely and could be considered part of normal execution. When you check for common error conditions, less code is executed because you avoid exceptions. Up-front checks eliminate exceptions most of the time. However, there can be race conditions where the guarded condition changes between the check and the operation, and in that case, you could still incur an exception.\n\nIf the performance cost of exceptions is prohibitive, some .NET library methods provide alternative forms of error handling. For example, Int32.Parse throws an OverflowException if the value to be parsed is too large to be represented by Int32. However, Int32.TryParse doesn't throw this exception. Instead, it returns a Boolean and has an parameter that contains the parsed valid integer upon success. Dictionary<TKey,TValue>.TryGetValue has similar behavior for attempting to get a value from a dictionary.\n\nIt's better to catch OperationCanceledException instead of TaskCanceledException, which derives from , when you call an asynchronous method. Many asynchronous methods throw an OperationCanceledException exception if cancellation is requested. These exceptions enable execution to be efficiently halted and the callstack to be unwound once a cancellation request is observed.\n\nAsynchronous methods store exceptions that are thrown during execution in the task they return. If an exception is stored into the returned task, that exception will be thrown when the task is awaited. Usage exceptions, such as ArgumentException, are still thrown synchronously. For more information, see Asynchronous exceptions.\n\nDesign classes so that exceptions can be avoided\n\nA class can provide methods or properties that enable you to avoid making a call that would trigger an exception. For example, the FileStream class provides methods that help determine whether the end of the file has been reached. You can call these methods to avoid the exception that's thrown if you read past the end of the file. The following example shows how to read to the end of a file without triggering an exception:\n\nAnother way to avoid exceptions is to return (or default) for most common error cases instead of throwing an exception. A common error case can be considered a normal flow of control. By returning (or default) in these cases, you minimize the performance impact to an app.\n\nFor value types, consider whether to use or as the error indicator for your app. By using , becomes instead of . Sometimes, adding can make it clearer when a value is present or absent. Other times, adding can create extra cases to check that aren't necessary and only serve to create potential sources of errors.\n\nCallers should be able to assume that there are no side effects when an exception is thrown from a method. For example, if you have code that transfers money by withdrawing from one account and depositing in another account, and an exception is thrown while executing the deposit, you don't want the withdrawal to remain in effect.\n\nThe preceding method doesn't directly throw any exceptions. However, you must write the method so that the withdrawal is reversed if the deposit operation fails.\n\nOne way to handle this situation is to catch any exceptions thrown by the deposit transaction and roll back the withdrawal.\n\nThis example illustrates the use of to rethrow the original exception, making it easier for callers to see the real cause of the problem without having to examine the InnerException property. An alternative is to throw a new exception and include the original exception as the inner exception.\n\nOnce an exception is thrown, part of the information it carries is the stack trace. The stack trace is a list of the method call hierarchy that starts with the method that throws the exception and ends with the method that catches the exception. If you rethrow an exception by specifying the exception in the statement, for example, , the stack trace is restarted at the current method and the list of method calls between the original method that threw the exception and the current method is lost. To keep the original stack trace information with the exception, there are two options that depend on where you're rethrowing the exception from:\n• If you rethrow the exception from within the handler ( block) that's caught the exception instance, use the statement without specifying the exception. Code analysis rule CA2200 helps you find places in your code where you might inadvertently lose stack trace information.\n• If you're rethrowing the exception from somewhere other than the handler ( block), use ExceptionDispatchInfo.Capture(Exception) to capture the exception in the handler and ExceptionDispatchInfo.Throw() when you want to rethrow it. You can use the ExceptionDispatchInfo.SourceException property to inspect the captured exception.\n\nThe following example shows how the ExceptionDispatchInfo class can be used, and what the output might look like.\n\nIf the file in the example code doesn't exist, the following output is produced:\n\nThe following best practices concern how you throw exceptions:\n\nIntroduce a new exception class only when a predefined one doesn't apply. For example:\n• If a property set or method call isn't appropriate given the object's current state, throw an InvalidOperationException exception.\n• If invalid parameters are passed, throw an ArgumentException exception or one of the predefined classes that derive from ArgumentException.\n\nIt's common for a class to throw the same exception from different places in its implementation. To avoid excessive code, create a helper method that creates the exception and returns it. For example:\n\nSome key .NET exception types have such static helper methods that allocate and throw the exception. You should call these methods instead of constructing and throwing the corresponding exception type:\n\nIf you're implementing an asynchronous method, call CancellationToken.ThrowIfCancellationRequested() instead of checking if cancellation was requested and then constructing and throwing OperationCanceledException. For more information, see CA2250.\n\nThe error message the user sees is derived from the Exception.Message property of the exception that was thrown, and not from the name of the exception class. Typically, you assign a value to the Exception.Message property by passing the message string to the argument of an Exception constructor.\n\nFor localized applications, you should provide a localized message string for every exception that your application can throw. You use resource files to provide localized error messages. For information on localizing applications and retrieving localized strings, see the following articles:\n• How to: Create user-defined exceptions with localized exception messages\n\nWrite clear sentences and include ending punctuation. Each sentence in the string assigned to the Exception.Message property should end in a period. For example, \"The log table has overflowed.\" uses correct grammar and punctuation.\n\nPlace throw statements where the stack trace will be helpful. The stack trace begins at the statement where the exception is thrown and ends at the statement that catches the exception.\n\nDon't raise exceptions in clauses. For more information, see code analysis rule CA2219.\n\nSome methods, such as , , and methods, static constructors, and equality operators, shouldn't throw exceptions. For more information, see code analysis rule CA1065.\n\nIn task-returning methods, you should validate arguments and throw any corresponding exceptions, such as ArgumentException and ArgumentNullException, before entering the asynchronous part of the method. Exceptions that are thrown in the asynchronous part of the method are stored in the returned task and don't emerge until, for example, the task is awaited. For more information, see Exceptions in task-returning methods.\n\nThe following best practices concern custom exception types:\n\nWhen a custom exception is necessary, name it appropriately and derive it from the Exception class. For example:\n\nUse at least the three common constructors when creating your own exception classes: the parameterless constructor, a constructor that takes a string message, and a constructor that takes a string message and an inner exception.\n• Exception(String, Exception), which accepts a string message and an inner exception.\n\nFor an example, see How to: Create user-defined exceptions.\n\nProvide additional properties for an exception (in addition to the custom message string) only when there's a programmatic scenario where the additional information is useful. For example, the FileNotFoundException provides the FileName property."
    }
]