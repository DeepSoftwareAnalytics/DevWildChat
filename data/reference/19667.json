[
    {
        "link": "https://simplilearn.com/tutorials/cpp-tutorial/iterators-in-cpp",
        "document": ""
    },
    {
        "link": "https://stackoverflow.com/questions/11445025/get-a-pointer-to-stl-container-an-iterator-is-referencing",
        "document": "No, there is no portable way to do this.\n\nAn iterator may not even have a reference to the container. For example, an implementation could use as the type for both and , since both store their elements as arrays.\n\nIn addition, iterators are far more general than containers, and not all iterators point into containers (for example, there are input and output iterators that read to and write from streams)."
    },
    {
        "link": "https://home.csulb.edu/~pnguyen/cecs282/lecnotes/iterators.pdf",
        "document": ""
    },
    {
        "link": "https://users.cs.northwestern.edu/~riesbeck/programming/c++/stl-iterators.html",
        "document": "This is a quick summary of iterators in the Standard Template Library. For information on defining iterators for new containers, see here.\n\nIterators are generated by STL container member functions, such as and . Some containers return iterators that support only the above operations, while others return iterators that can move forward and backward, be compared with , and so on.\n\nThe generic algorithms use iterators just as you use pointers in C to get elements from and store elements to various containers. Passing and returning iterators makes the algorithms\n• more generic, because the algorithms will work for any containers, including ones you invent, as long as you define iterators for them\n• more efficient (as discussed here)\n\nSome algorithms can work with the minimal iterators, others may require the extra features. So a certain algorithm may require certain containers because only those containers can return the necessary kind of iterators.\n\nHere's an example call to , an algorithm that we'll use in our examples below:\n• an iterator pointing to the first location to copy from\n• an iterator pointing one element past to the last location to copy from\n• an iterator pointing to the first location to copy into\n\nIn this case, and are some STL containers and and are member functions that return iterators pointing to locations within those containers.\n\nIterators are divided into classes. These are not real C++ classes, but simply categories of kind of iterators. Each category specifies the operations the iterator supports. For example, some iterators support incrementing but not decrementing, some support dereferencing for getting data but not for storing data, some support scalar arithmetic, i.e., adding , and some don't. Each STL container defines what class of iterators it can return. Each algorithm specifies what class of iterators it requires. The more powerful iterator classes are usually subclasses of the weaker ones, so if an algorithm requires a minimal iterator, it will work just fine with an iterator with more power.\n\nis a useful but limited class of iterators. If is an , you can use:\n• and to increment it, i.e., advance the pointer to the next element\n• to dereference it, i.e., get the element pointed to\n• to compare it another iterator (typically the \"end\" iterator)\n\nAll STL containers can return at least this level of iterator. Here's typical code that prints out everything in a vector:\n\nThis is called an input iterator because you can only use it to \"read\" data from a container. You can't use it to store data, that is,\n\nis illegal if is no more than an input iterator. It will work for the iterator above because vectors return iterators more powerful than just input iterators. But if were an istream iterator (discussed shortly), then the above restriction would apply.\n\nis another limited class of iterators, basically the opposite of . If is an , you can use:\n• and to increment it, i.e., advance the pointer to the next element\n• to store data in the location pointed to\n\nOutput iterators are only for storing. If something is no more an output iterator, you can't read from it with , nor can you test it with and .\n\nIt may seem like an iterator you can only write to, not read from, is about as sensible as Barnstable Bear in Pogo who could write but not read what he wrote. But there are two very useful subclasses of :\n\nInsert iterators let you \"point\" to some location in a container and insert elements. You do this with just dereferencing and assignment:\n\nThis inserts the value in the place pointed to by the iterator. If you assign again, a new value will be inserted. Whether value goes before or after the previous value depends on what kind of insert operator you've created. Notice that you don't need to increment the iterator. You just keep assigning.\n\nYou create an insert iterator with one of the following:\n• returns an pointing to the end of the container. Output to this iterator gets added to the end of the container, using the container's operation.\n• returns an pointing to the front of the container. Output to this iterator gets added to the front of the container, using the container's operation.\n• returns an pointing to the location pointed to by of the container. Output to this iterator gets added to the container from that point forward, using the container's operation.\n\nAn example of using the insert iterators appears when describing istream iterators.\n\nOstream iterators let you \"point\" to an output stream and insert elements into it, i.e., write to the output stream.\n\nWe can construct an ostream iterator from a C++ output stream as follows:\n\nThe first line defines to be an ostream iterator for integers. The means \"put a space between each integer.\" If we'd said then would put a newline between each integer. The second line uses the generic algorithm to copy our vector from beginning to end to . Note how much simpler this is than the equivalent loop with and .\n\nIstream iterators for input streams work similarly to ostream iterators. Istream iterators are . The following code fragment constructs an istream iterator that reads integers from and copies them into a vector . We use a to add the elements to the end of the vector, which could beempty:\n\nThe first argument to copy calls an istream iterator constructor that simply points to the input stream . The second argument calls a special constructor that creates a pointer to \"the end of the input.\" What this actually means, especially for terminal input, depends on your operating system. So the above says \"copy from the current item in the input sream to the end of the input stream into the container v.\"\n\ncombines and . You can use them to read and write to a container. They also support:\n\nA trivial example of this is\n\nThis will work if the iterators are 's. Note that it can't work for 's and 's, such as istream and ostream iterators. I/O streams such as standard input and output don't support backing up and starting over.\n\nIf is a , you can use:\n• and to decrement it, i.e., advance the pointer to the previous element\n\nIf and are 's, you can use:\n• standard pointer arithmetic, i.e., , , , , and (but not )\n\nSince 's support ++ and --, don't they support these operations too? The answer is that 's support these operations in constant time. That is, you can jump N elements in the same time it takes to jump 1 element. So an STL container can return a , but not a . Vectors and deques can return 's.\n\nThere are two rules for making container-based code general and efficient:\n• Never pass containers into a function. Pass iterators instead.\n• Never return containers. Return -- or pass -- iterators instead.\n\nSuppose we wanted to define to multiply together the numbers in a container.\n\nWe can immediately reject any definition like this:\n• not general; it only works for vectors\n\nBut we could define it like this:\n\nThis definition seems general. It works for any STL container, e.g.,\n\nUnfortunately, it won't work with regular arrays, e.g.,\n\nbecause there are no or methods for regular C-style arrays. Furthermore, it doesn't let us calculate the product of a subrange of the container.\n\nThe following definition is clearly more general:\n\nas well as with STL containers and subranges.\n\nBoth definitions of above are efficient. Neither copies the container involved. But consider a function -- let's call it -- that has to generate multiple answers. There are two common situations:\n• There's a container of objects and is supposed to return certain ones, e.g., all the odd numbers in the container.\n• There is no container. is supposed to generate new objects, e.g., all the prime numbers less than N.\n\nThe obvious way to define is like this:\n\nWe would call like this:\n\nbut this has two bad properties:\n• It's ugly to write calls to\n• creates a container which then has to be copied and returned\n\nIf the container already exists and is returning a subset of the elements in it, e.g., all the odd numbers, then the thing to do is to\n• pass iterators pointing to the start and end, as usual, and\n• have return an iterator pointing to the first answer, if any, else the end iterator\n\nThe template for this kind of definition is simple:\n\nThe following loop would then get the answers and print or store them, as desired:\n\nIf the container does not exist, you have to be a little smarter. In particular, both of the following are very bad (and won't even compile without some more work):\n\nBoth of these return references to which no longer exists when exits.\n\nThe following is better\n\nbut now we're dealing with pointers and we have to guarantee that the container that dynamically allocates gets deallocated by some other piece of code. Otherwise, we have a bad memory leak.\n\nThe clever way to solve this problem is to do this:\n\nIn other words, don't have any container in at all. Just pass an iterator to store answers in. As before, what container to use (if any) is up to the calling code. Two ways we could call are:\n\nAs before, by using iterators, we have made far more useful and general and efficient than any version that takes or returns containers.\n\nComments? Let me know!"
    },
    {
        "link": "https://stackoverflow.com/questions/37101525/obtain-iterator-from-pointer-or-reference",
        "document": "I would like to know if it is possible to obtain an iterator to an object inside a container (e.g. ) by only having access to the object inside the container, e.g. through a reference (which implies we have access to a pointer to it using the operator). For example, normally we declare an iterator as\n\nbut in the first example we are most probably about to iterate through the container, in order, while in the second example we know the index of the object we require. I would like to know if we can obtain the iterator to an object without knowing at which index it resides in the container, but if we do have a reference or a pointer to it, as explained above.\n\nIt might appear that this question has already been asked here, but it seems more like the OP wanted others to fix his code, rather than answering the general question, so the answers are not so satisfactory in my opinion. Also, the answer here seems to say that we can initialize an iterator with a constructor, as shown below\n\nbut I have not been able to find any evidence of a constructor for the std::iterator class in the official documentation (and neither have I been able to find any documentation on std::vector<...>::iterator) so I am wary to use the constructor shown above, even if it compiles.\n\nI use as an example above, but ideally I would like this to work for any container, e.g. or"
    },
    {
        "link": "https://stackoverflow.com/questions/4114503/rules-for-iterator-invalidation",
        "document": "The invalidation rules are inspired from the very fundamental Data Structures and Algorithms used to implement these containers. If you do not plan to learn the fundamentals, then you will need to remember the iterator documentation by heart.\n\nThe C++ standard defines the behaviors of in a way that makes it possible to implement with simple C pointers. It does not require the library to actually use pointers; it simply makes it possible to do so.\n\nBasically, an iterator is invalidated if an operation causes an underlying storage element (a heap array used in a , a linked-list node used in a , or a tree node used in a or ) to be deallocated, or shifed into a different memory location.\n\nA is usually implemented by allocating an array from the dynamic memory (heap). In order to reduce the number of reallocations, the array is always allocated with some slack, i.e. initially unused space. As elements are added to the array, the slack space is being used up. When all slack space has been taken up and a new element needs to be inserted, then a new array with a bigger size will be allocated. This will cause the invalidation of all iterators pointing to the old array.\n\nLikewise, when an element is erased from a , this will cause all subsequent elements to be copied forward. An iterator pointing to the shifted elements will still reference the same index in the array, but that index now contains a different element. This is also an example of invalidation.\n\nFor , and , the tree-node or list-node remains valid until the element it contains is erased. Note that an iterator pointing to an invalidated node cannot be used for anything; not even for iterator increment/decrement. This is because in a linked-list or tree implementation, the iterator depends on child pointers that are stored in the node itself.\n\nIn order to always guarantee correct operation, the standard is worded in a more restrictive way than if simple data structures are used (which, paradoxically gives more freedom to library implementers to use more advanced data structures). For example, see http://c2.com/cgi/wiki?IteratorInvalidationProblem and http://www.threadingbuildingblocks.org/codesamples.php ."
    },
    {
        "link": "https://stackoverflow.com/questions/6438086/iterator-invalidation-rules-for-c-containers",
        "document": ". Edit existing answers to improve this post. It is not currently accepting new answers or interactions.\n• : all iterators and references before the point of insertion are unaffected, unless the new container size is greater than the previous capacity (in which case all iterators and references are invalidated) [23.2.4.3/1]\n• : all iterators and references are invalidated, unless the inserted member is at an end (front or back) of the deque (in which case all iterators are invalidated, but references to elements are unaffected) [23.2.1.3/1]\n• : every iterator and reference after the point of erase is invalidated [23.2.4.3/3]\n• : all iterators and references are invalidated, unless the erased members are at an end (front or back) of the deque (in which case only iterators and references to the erased members are invalidated) [23.2.1.3/4]\n• : only the iterators and references to the erased element is invalidated [23.2.2.3/3]\n• : only iterators and references to the erased elements are invalidated [23.1.2/8] Unless otherwise specified (either explicitly or by defining a function in terms of other functions), invoking a container member function or passing a container as an argument to a library function shall not invalidate iterators to, or change the values of, objects within that container. [23.1/11] It's not clear in C++2003 whether \"end\" iterators are subject to the above rules; you should assume, anyway, that they are (as this is the case in practice). The rules for invalidation of pointers are the sames as the rules for invalidation of references.\n• : all iterators and references before the point of insertion are unaffected, unless the new container size is greater than the previous capacity (in which case all iterators and references are invalidated) [23.3.6.5/1]\n• : all iterators and references are invalidated, unless the inserted member is at an end (front or back) of the deque (in which case all iterators are invalidated, but references to elements are unaffected) [23.3.3.4/1]\n• : all iterators and references unaffected (applies to ) [23.3.4.5/1]\n• : all iterators invalidated when rehashing occurs, but references unaffected [23.2.5/8]. Rehashing does not occur if the insertion does not cause the container's size to exceed where is the maximum load factor and the current number of buckets. [23.2.5/14]\n• : every iterator and reference at or after the point of erase is invalidated [23.3.6.5/3]\n• : erasing the last element invalidates only iterators and references to the erased elements and the past-the-end iterator; erasing the first element invalidates only iterators and references to the erased elements; erasing any other elements invalidates all iterators and references (including the past-the-end iterator) [23.3.3.4/4]\n• : only the iterators and references to the erased element is invalidated [23.3.5.4/3]\n• : only the iterators and references to the erased element is invalidated (applies to ) [23.3.4.5/1]\n• : only iterators and references to the erased elements are invalidated [23.2.4/9]\n• : only iterators and references to the erased elements are invalidated [23.2.5/13] Unless otherwise specified (either explicitly or by defining a function in terms of other functions), invoking a container member function or passing a container as an argument to a library function shall not invalidate iterators to, or change the values of, objects within that container. [23.2.1/11] no swap() function invalidates any references, pointers, or iterators referring to the elements of the containers being swapped. [ Note: The end() iterator does not refer to any element, so it may be invalidated. —end note ] [23.2.1/10] Other than the above caveat regarding , it's not clear whether \"end\" iterators are subject to the above listed per-container rules; you should assume, anyway, that they are. and all unordered associative containers support which guarantees that no automatic resizing will occur at least until the size of the container grows to . Caution should be taken with unordered associative containers because a future proposal will allow the specification of a minimum load factor, which would allow rehashing to occur on after enough operations reduce the container size below the minimum; the guarantee should be considered potentially void after an .\n\nC++17 (All references are from the final working draft of CPP17 - n4659)\n• None : The functions , , , cause reallocation if the new size is greater than the old capacity. Reallocation invalidates all the references, pointers, and iterators referring to the elements in the sequence. If no reallocation happens, all the iterators and references before the insertion point remain valid. [26.3.11.5/1]\n\n With respect to the function, reallocation invalidates all the references, pointers, and iterators referring to the elements in the sequence. No reallocation shall take place during insertions that happen after a call to until the time when an insertion would make the size of the vector greater than the value of . [26.3.11.3/6]\n• None : An insertion in the middle of the deque invalidates all the iterators and references to elements of the deque. An insertion at either end of the deque invalidates all the iterators to the deque, but has no effect on the validity of references to elements of the deque. [26.3.8.4/1]\n• None : Does not affect the validity of iterators and references. If an exception is thrown there are no effects. [26.3.10.4/1].\n\n The , , , , , functions are covered under this rule.\n• None : None of the overloads of shall affect the validity of iterators and references [26.3.9.5/1]\n• None : As a rule, iterators to an array are never invalidated throughout the lifetime of the array. One should take note, however, that during swap, the iterator will continue to point to the same array element, and will thus change its value.\n• : The and members shall not affect the validity of iterators and references to the container [26.2.6/9]\n• None : Rehashing invalidates iterators, changes ordering between elements, and changes which buckets elements appear in, but does not invalidate pointers or references to elements. [26.2.7/9]\n\n The and members shall not affect the validity of references to container elements, but may invalidate all iterators to the container. [26.2.7/14]\n\n The and members shall not affect the validity of iterators if , where is the number of elements in the container prior to the insert operation, is the number of elements inserted, is the container’s bucket count, and is the container’s maximum load factor. [26.2.7/15]\n• None : In case of a merge operation (e.g., ), iterators referring to the transferred elements and all iterators referring to will be invalidated, but iterators to elements remaining in will remain valid. (Table 91 — Unordered associative container requirements)\n• None : The functions and invalidate iterators and references at or after the point of the erase. [26.3.11.5/3]\n• None : An erase operation that erases the last element of a invalidates only the past-the-end iterator and all iterators and references to the erased elements. An erase operation that erases the first element of a but not the last element invalidates only iterators and references to the erased elements. An erase operation that erases neither the first element nor the last element of a invalidates the past-the-end iterator and all iterators and references to all the elements of the . [ Note: and are erase operations. —end note ] [26.3.8.4/4]\n• None : Invalidates only the iterators and references to the erased elements. [26.3.10.4/3]. This applies to , , , functions.\n\n and member functions: Erases all the elements in the list referred by a list iterator for which the following conditions hold: , . Invalidates only the iterators and references to the erased elements [26.3.10.5/15].\n\n member function - Erases all but the first element from every consecutive group of equal elements referred to by the iterator in the range for which (for the version of unique with no arguments) or (for the version of unique with a predicate argument) holds. Invalidates only the iterators and references to the erased elements. [26.3.10.5/19]\n• None : shall invalidate only iterators and references to the erased elements. [26.3.9.5/1].\n\n and member functions - Erases all the elements in the list referred by a list iterator i for which the following conditions hold: (for ), is true (for ). Invalidates only the iterators and references to the erased elements. [26.3.9.6/12].\n\n member function - Erases all but the first element from every consecutive group of equal elements referred to by the iterator i in the range [first + 1, last) for which (for the version with no arguments) or (for the version with a predicate argument) holds. Invalidates only the iterators and references to the erased elements. [26.3.9.6/16]\n• None : invalidates all references, pointers, and iterators referring to the elements of a and may invalidate the past-the-end iterator (Table 87 — Sequence container requirements). But for , does not invalidate past-the-end iterators. [26.3.9.5/32]\n• None : invalidates all references, pointers and iterators referring to the elements of the container. For and , also invalidates the past-the-end iterator. (Table 87 — Sequence container requirements)\n• None : The members shall invalidate only iterators and references to the erased elements [26.2.6/9]\n• None : The members invalidate only iterators to the removed element; pointers and references to the removed element remain valid [26.2.6/10]\n• None Unless otherwise specified (either explicitly or by defining a function in terms of other functions), invoking a container member function or passing a container as an argument to a library function shall not invalidate iterators to, or change the values of, objects within that container. [26.2.1/12]\n• None no function invalidates any references, pointers, or iterators referring to the elements of the containers being swapped. [ Note: The end() iterator does not refer to any element, so it may be invalidated. —end note ] [26.2.1/(11.6)] As examples of the above requirements:\n• None algorithm: The and functions shall not invalidate iterators or subranges, or modify elements in the ranges [28.6.4/1]\n• None algorithm: In the range [first, last], shall neither modify elements nor invalidate iterators or subranges [29.8.2/1]\n• None algorithm: binary_op shall neither invalidate iterators or subranges, nor modify elements in the range [first, last]. [29.8.3/5]\n\nIt is probably worth adding that an insert iterator of any kind ( , , ) is guaranteed to remain valid as long as all insertions are performed through this iterator and no other independent iterator-invalidating event occurs. For example, when you are performing a series of insertion operations into a by using it is quite possible that these insertions will trigger vector reallocation, which will invalidate all iterators that \"point\" into that vector. However, the insert iterator in question is guaranteed to remain valid, i.e. you can safely continue the sequence of insertions. There's no need to worry about triggering vector reallocation at all. This, again, applies only to insertions performed through the insert iterator itself. If iterator-invalidating event is triggered by some independent action on the container, then the insert iterator becomes invalidated as well in accordance with the general rules. std::vector<int> v(10); std::vector<int>::iterator it = v.begin() + 5; std::insert_iterator<std::vector<int> > it_ins(v, it); for (unsigned n = 20; n > 0; --n) *it_ins++ = rand(); is guaranteed to perform a valid sequence of insertions into the vector, even if the vector \"decides\" to reallocate somewhere in the middle of this process. Iterator will obviously become invalid, but will continue to remain valid.\n\nSince this question draws so many votes and kind of becomes an FAQ, I guess it would be better to write a separate answer to mention one significant difference between C++03 and C++11 regarding the impact of 's insertion operation on the validity of iterators and references with respect to and , which the most upvoted answer failed to notice. Reallocation invalidates all the references, pointers, and iterators referring to the elements in the sequence. It is guaranteed that no reallocation takes place during insertions that happen after a call to reserve() until the time when an insertion would make the size of the vector greater than the size specified in the most recent call to reserve(). Reallocation invalidates all the references, pointers, and iterators referring to the elements in the sequence. It is guaranteed that no reallocation takes place during insertions that happen after a call to reserve() until the time when an insertion would make the size of the vector greater than the value of capacity(). So in C++03, it is not \" unless the new container size is greater than the previous capacity (in which case all iterators and references are invalidated) \" as mentioned in the other answer, instead, it should be \" greater than the size specified in the most recent call to reserve() \". This is one thing that C++03 differs from C++11. In C++03, once an causes the size of the vector to reach the value specified in the previous call (which could well be smaller than the current since a could result a bigger than asked for), any subsequent could cause reallocation and invalidate all the iterators and references. In C++11, this won't happen and you can always trust to know with certainty that the next reallocation won't take place before the size overpasses . In conclusion, if you are working with a C++03 vector and you want to make sure a reallocation won't happen when you perform insertion, it's the value of the argument you previously passed to that you should check the size against, not the return value of a call to , otherwise you may get yourself surprised at a \"premature\" reallocation."
    },
    {
        "link": "https://labex.io/tutorials/cpp-how-to-resolve-iterator-lifetime-issues-419975",
        "document": "What is an Iterator?\n\nAn iterator in C++ is an object that allows traversing through elements of a container, providing a way to access data sequentially without exposing the underlying container's structure. Iterators act as a bridge between containers and algorithms, offering a uniform method of accessing elements.\n\nC++ provides several types of iterators with different capabilities:\n• : Returns iterator to position after last element\n• Prefer range-based for loops in modern C++\n\nWhen learning iterators, practice on LabEx's C++ programming environments to gain hands-on experience with different iterator scenarios."
    },
    {
        "link": "https://softwareengineering.stackexchange.com/questions/290482/c-iterators-best-practice-to-represent-end-of-range-last-or-beyond-last",
        "document": "Stack Exchange network consists of 183 Q&A communities including Stack Overflow, the largest, most trusted online community for developers to learn, share their knowledge, and build their careers."
    },
    {
        "link": "https://geeksforgeeks.org/iterator-invalidation-cpp",
        "document": "When the container to which an Iterator points changes shape internally, i.e. when elements are moved from one position to another, and the initial iterator still points to the old invalid location, then it is called Iterator invalidation. One should be careful while using iterators in C++. When we iterate over our container using iterators then it may happen that the iterator gets invalidated. This may be due to change in the shape and size of the container while iterating.\n\nFor example, Iterator invalidation in a vector whenever either, at any point in the vector, an element is inserted or an element from the vector is removed. Let us take an example to understand this,\n\nIn the above example code, it may happen that when we add an element -1 while iterating the vector, the size of the vector can get more than the maximum size due to which a new memory is allocated to the vector and all elements are copied there. But, our iterator still points to the previous old memory address. So, now we can say that iterator gets invalidated. This is one example of invalidation. Given below are some rules for iterator invalidation.\n\n1. Insertion All iterators which point to an element before the point of insertion are unaffected but all others are invalidated. But, in case if due to insertion the size of the vector becomes more than the previous capacity then all iterators get invalidated as discussed in the above example. All iterators and references are invalidated unless the inserted member is at an end (front or back) of the deque (in which case all iterators are invalidated, but references to elements are unaffected). All iterators and references are unaffected."
    },
    {
        "link": "https://en.cppreference.com/w/cpp/memory/addressof",
        "document": "Obtains the actual address of the object or function , even in presence of overloaded .\n\nRvalue overload is deleted to prevent taking the address of rvalues.\n\nThe implementation below is not constexpr, because reinterpret_cast is not usable in a constant expression. Compiler support is needed (see below).\n\nconstexpr for is added by LWG2296, and MSVC STL applies the change to C++14 mode as a defect report.\n\nThere are some weird cases where use of built-in operator& is ill-formed due to argument-dependent lookup even if it is not overloaded, and can be used instead.\n\nThe following behavior-changing defect reports were applied retroactively to previously published C++ standards."
    },
    {
        "link": "https://stackoverflow.com/questions/14820307/when-to-use-addressofx-instead-of-x",
        "document": "How do I decide whether I need instead of when taking the address of an object?\n\nSeems like the question was confusing, so a clarification is in order:\n\nobviously bypasses the overloaded address-of operator. I'm already aware of that.\n\nWhat I want to know is:\n\n How do I know if that's what I really want to do? (Especially when inside a template, etc.)\n\nIs there some kind of \"rule\" that helps me figure out when I need instead of ?\n\n After all, they both return the \"address of\" the object, so when do I use which?"
    },
    {
        "link": "https://stackoverflow.com/questions/16195032/implementation-of-addressof",
        "document": "It's actually quite simple when you think about it, to get the real adress of an object/function in precense of an overloaded you will need to treat the object as something other than what it really is, some type which cannot have an overloaded operator.. an intrinsic type (such as ).\n\nA has no alignment and can reside anywhere any other object can, with that said; casting an object to a reference to char is a very good start.\n\nBut what about the black magic involved when doing ?\n\nIn order to reinterpret the returned pointer from the implementation of we will eventually want to discard qualifiers such as and (to end up with a plain reference ). These two can be added easily with , but asking it to remove them is illegal.\n\nIt's a little bit of a \"better safe than sorry\" trick.. \"Let us add them, just in case, we will remove them later.\"\n\nLater we cast away the qualifiers (const and volatile) with to end up with a plain reference to , this result is, as the final step, turned back into a pointer to whatever type we passed into our implementation.\n\nA relevant question on this stage is why we didn't skip the use of and went directly to the ? this too has a simple answer: can add/remove qualifiers, but it cannot change the underlying type.\n\nit might not be easy as pie, but it sure tastes good when you get it.."
    },
    {
        "link": "https://cplusplus.com/reference/memory/addressof",
        "document": ""
    },
    {
        "link": "https://saco-evaluator.org.za/docs/cppreference/en/cpp/memory/addressof.html",
        "document": "Obtains the actual address of the object or function , even in presence of overloaded\n\nRvalue overload is deleted to prevent taking the address of rvalues.\n\nNote: the above implementation is oversimplified and is not (which requires compiler support).\n\noperator& may be overloaded for a pointer wrapper class to obtain a pointer to pointer: T Ptr T pad // add pad to show difference between 'this' and 'data' T data Ptr T arg pad nullptr , data arg this ~Ptr delete data T operator data T f Ptr T p p f p p main Ptr p new f p f std p Ctor this = 0x7fff59ae6e88 int** overload called with p = 0x7fff59ae6e90 Ptr overload called with p = 0x7fff59ae6e88"
    }
]