[
    {
        "link": "https://docs.oracle.com/javase/8/docs/api/java/lang/StringBuffer.html",
        "document": "\n• the length of the sequence of characters currently represented by this object\n• Returns the current capacity. The capacity is the amount of storage available for newly inserted characters, beyond which an allocation will occur.\n• \n• Twice the old capacity, plus . If the argument is nonpositive, this method takes no action and simply returns. Note that subsequent operations on this object can reduce the actual capacity below that requested here. Ensures that the capacity is at least equal to the specified minimum. If the current capacity is less than the argument, then a new internal array is allocated with greater capacity. The new capacity is the larger of:If theargument is nonpositive, this method takes no action and simply returns. Note that subsequent operations on this object can reduce the actual capacity below that requested here.\n• Attempts to reduce storage used for the character sequence. If the buffer is larger than necessary to hold its current sequence of characters, then it may be resized to become more space efficient. Calling this method may, but is not required to, affect the value returned by a subsequent call to the method.\n• k less than , the character at index k in the new character sequence is the same as the character at index k in the old sequence if k is less than the length of the old character sequence; otherwise, it is the null character . In other words, if the argument is less than the current length, the length is changed to the specified length. Sets the length of the character sequence. The sequence is changed to a new character sequence whose length is specified by the argument. For every nonnegative indexless than, the character at indexin the new character sequence is the same as the character at indexin the old sequence ifis less than the length of the old character sequence; otherwise, it is the null character. In other words, if theargument is less than the current length, the length is changed to the specified length. If the argument is greater than or equal to the current length, sufficient null characters ( ) are appended so that length becomes the argument. The argument must be greater than or equal to . - if the argument is negative.\n• value in this sequence at the specified index. The first value is at index , the next at index , and so on, as in array indexing. Returns thevalue in this sequence at the specified index. The firstvalue is at index, the next at index, and so on, as in array indexing. The index argument must be greater than or equal to , and less than the length of this sequence. If the value specified by the index is a surrogate, the surrogate value is returned. - the index of the desired value. the value at the specified index. - if is negative or greater than or equal to .\n• values (Unicode code units) and ranges from to . Returns the character (Unicode code point) at the specified index. The index refers tovalues (Unicode code units) and ranges fromto If the value specified at the given index is in the high-surrogate range, the following index is less than the length of this sequence, and the value at the following index is in the low-surrogate range, then the supplementary code point corresponding to this surrogate pair is returned. Otherwise, the value at the given index is returned. - the index to the values the code point value of the character at the\n• values (Unicode code units) and ranges from to Returns the character (Unicode code point) before the specified index. The index refers tovalues (Unicode code units) and ranges fromto If the value at is in the low-surrogate range, is not negative, and the value at is in the high-surrogate range, then the supplementary code point value of the surrogate pair is returned. If the value at is an unpaired low-surrogate or a high-surrogate, the surrogate value is returned. - the index following the code point that should be returned the Unicode code point value before the given index.\n• Returns the number of Unicode code points in the specified text range of this sequence. The text range begins at the specified and extends to the at index . Thus the length (in s) of the text range is . Unpaired surrogates within this sequence count as one code point each. - the index to the first of the text range. - the index after the last of the text range. the number of Unicode code points in the specified text range\n• Returns the index within this sequence that is offset from the given by code points. Unpaired surrogates within the text range given by and count as one code point each. - the index to be offset the index within this sequence\n• . The first character to be copied is at index ; the last character to be copied is at index . The total number of characters to be copied is . The characters are copied into the subarray of starting at index and ending at index: Characters are copied from this sequence into the destination character array. The first character to be copied is at index; the last character to be copied is at index. The total number of characters to be copied is. The characters are copied into the subarray ofstarting at indexand ending at index: - the array to copy the data into. - if any of the following is true:\n• the argument is greater than the argument.\n• . This sequence is altered to represent a new character sequence that is identical to the old character sequence, except that it contains the character at position . The character at the specified index is set to. This sequence is altered to represent a new character sequence that is identical to the old character sequence, except that it contains the characterat position The index argument must be greater than or equal to , and less than the length of this sequence. - the index of the character to modify. - if is negative or greater than or equal to .\n• argument. The overall effect is exactly as if the argument were converted to a string by the method , and the characters of that string were then to this character sequence.\n• Appends the specified string to this character sequence. The characters of the argument are appended, in order, increasing the length of this sequence by the length of the argument. If is , then the four characters are appended. Let n be the length of this character sequence just prior to execution of the method. Then the character at index k in the new character sequence is equal to the character at index k in the old character sequence, if k is less than n; otherwise, it is equal to the character at index k-n in the argument .\n• to this sequence. The characters of the argument are appended, in order, to the contents of this , increasing the length of this by the length of the argument. If is , then the four characters are appended to this . Let n be the length of the old character sequence, the one contained in the just prior to execution of the method. Then the character at index k in the new character sequence is equal to the character at index k in the old character sequence, if k is less than n; otherwise, it is equal to the character at index k-n in the argument . This method synchronizes on , the destination object, but does not synchronize on the source ( ).\n• to this sequence. The characters of the argument are appended, in order, increasing the length of this sequence by the length of the argument. The result of this method is exactly the same as if it were an invocation of this.append(s, 0, s.length()); This method synchronizes on , the destination object, but does not synchronize on the source ( ). If is , then the four characters are appended.\n• to this sequence. Appends a subsequence of the specifiedto this sequence. Characters of the argument , starting at index , are appended, in order, to the contents of this sequence up to the (exclusive) index . The length of this sequence is increased by the value of . Let n be the length of this character sequence just prior to execution of the method. Then the character at index k in this character sequence becomes equal to the character at index k in this sequence, if k is less than n; otherwise, it is equal to the character at index k+start-n in the argument . If is , then this method appends characters as if the s parameter was a sequence containing the four characters . - the starting index of the subsequence to be appended. - the end index of the subsequence to be appended. - if is negative, or is greater than or is greater than\n• array argument to this sequence. Appends the string representation of thearray argument to this sequence. The characters of the array argument are appended, in order, to the contents of this sequence. The length of this sequence increases by the length of the argument. The overall effect is exactly as if the argument were converted to a string by the method , and the characters of that string were then to this character sequence. - the characters to be appended.\n• array argument to this sequence. Appends the string representation of a subarray of thearray argument to this sequence. Characters of the array , starting at index , are appended, in order, to the contents of this sequence. The length of this sequence increases by the value of . The overall effect is exactly as if the arguments were converted to a string by the method , and the characters of that string were then to this character sequence. - the characters to be appended. - the index of the first to append. - the number of s to append. - if or or\n• argument to the sequence. Appends the string representation of theargument to the sequence. The overall effect is exactly as if the argument were converted to a string by the method , and the characters of that string were then to this character sequence.\n• argument to this sequence. Appends the string representation of theargument to this sequence. The argument is appended to the contents of this sequence. The length of this sequence increases by . The overall effect is exactly as if the argument were converted to a string by the method , and the character in that string were then to this character sequence.\n• argument to this sequence. Appends the string representation of theargument to this sequence. The overall effect is exactly as if the argument were converted to a string by the method , and the characters of that string were then to this character sequence.\n• argument to this sequence. Appends the string representation of theargument to this sequence. The argument is appended to the contents of this sequence. The length of this sequence increases by . The overall effect is exactly as if the argument were converted to a array by the method and the character in that array were then to this character sequence.\n• argument to this sequence. Appends the string representation of theargument to this sequence. The overall effect is exactly as if the argument were converted to a string by the method , and the characters of that string were then to this character sequence.\n• argument to this sequence. Appends the string representation of theargument to this sequence. The overall effect is exactly as if the argument were converted to a string by the method , and the characters of that string were then to this character sequence.\n• argument to this sequence. Appends the string representation of theargument to this sequence. The overall effect is exactly as if the argument were converted to a string by the method , and the characters of that string were then to this character sequence.\n• Removes the characters in a substring of this sequence. The substring begins at the specified and extends to the character at index or to the end of the sequence if no such character exists. If is equal to , no changes are made. - if is negative, greater than , or greater than .\n• at the specified position in this sequence. This sequence is shortened by one . Removes theat the specified position in this sequence. This sequence is shortened by one Note: If the character at the given index is a supplementary character, this method does not remove the entire character. If correct handling of supplementary characters is required, determine the number of s to remove by calling , where is this sequence. - if the is negative or greater than or equal to .\n• Replaces the characters in a substring of this sequence with characters in the specified . The substring begins at the specified and extends to the character at index or to the end of the sequence if no such character exists. First the characters in the substring are removed and then the specified is inserted at . (This sequence will be lengthened to accommodate the specified String if necessary.) - if is negative, greater than , or greater than .\n• Returns a new that contains a subsequence of characters currently contained in this character sequence. The substring begins at the specified index and extends to the end of this sequence. - if is less than zero, or greater than the length of this object.\n• Returns a new character sequence that is a subsequence of this sequence. An invocation of this method of the form behaves in exactly the same way as the invocation This method is provided so that this class can implement the behaves in exactly the same way as the invocationThis method is provided so that this class can implement the interface. - if or are negative, if is greater than , or if is greater than\n• Returns a new that contains a subsequence of characters currently contained in this sequence. The substring begins at the specified and extends to the character at index . - if or are negative or greater than , or is greater than .\n• Inserts the string representation of a subarray of the array argument into this sequence. The subarray begins at the specified and extends s. The characters of the subarray are inserted into this sequence at the position indicated by . The length of this sequence increases by s. - position at which to insert subarray. - the index of the first in subarray to be inserted. - the number of s in the subarray to be inserted. - if is negative or greater than , or or are negative, or is greater than .\n• argument into this character sequence. Inserts the string representation of theargument into this character sequence. The overall effect is exactly as if the second argument were converted to a string by the method , and the characters of that string were then into this character sequence at the indicated offset. The argument must be greater than or equal to , and less than or equal to the length of this sequence. - if the offset is invalid.\n• Inserts the string into this character sequence. The characters of the argument are inserted, in order, into this sequence at the indicated offset, moving up any characters originally above that position and increasing the length of this sequence by the length of the argument. If is , then the four characters are inserted into this sequence. The character at index k in the new character sequence is equal to:\n• the character at index k in the old character sequence, if k is less than\n• the character at index k in the argument , if k is not less than but is less than\n• the character at index k in the old character sequence, if k is not less than The argument must be greater than or equal to , and less than or equal to the length of this sequence. - if the offset is invalid.\n• array argument into this sequence. Inserts the string representation of thearray argument into this sequence. The characters of the array argument are inserted into the contents of this sequence at the position indicated by . The length of this sequence increases by the length of the argument. The overall effect is exactly as if the second argument were converted to a string by the method , and the characters of that string were then into this character sequence at the indicated offset. The argument must be greater than or equal to , and less than or equal to the length of this sequence. - if the offset is invalid.\n• into this sequence. The characters of the argument are inserted, in order, into this sequence at the indicated offset, moving up any characters originally above that position and increasing the length of this sequence by the length of the argument s. The result of this method is exactly the same as if it were an invocation of this object's (dstOffset, s, 0, s.length()) method. If is , then the four characters are inserted into this sequence. - the sequence to be inserted - if the offset is invalid.\n• into this sequence. Inserts a subsequence of the specifiedinto this sequence. The subsequence of the argument specified by and are inserted, in order, into this sequence at the specified destination offset, moving up any characters originally above that position. The length of this sequence is increased by . The character at index k in this sequence becomes equal to:\n• the character at index k in this sequence, if k is less than\n• the character at index k in the argument , if k is greater than or equal to but is less than\n• the character at index k in this sequence, if k is greater than or equal to The argument must be greater than or equal to , and less than or equal to the length of this sequence. The start argument must be nonnegative, and not greater than . The end argument must be greater than or equal to , and less than or equal to the length of s. If is , then this method inserts characters as if the s parameter was a sequence containing the four characters . - the offset in this sequence. - the sequence to be inserted. - the starting index of the subsequence to be inserted. - the end index of the subsequence to be inserted. - if is negative or greater than , or or are negative, or is greater than or is greater than\n• argument into this sequence. Inserts the string representation of theargument into this sequence. The overall effect is exactly as if the second argument were converted to a string by the method , and the characters of that string were then into this character sequence at the indicated offset. The argument must be greater than or equal to , and less than or equal to the length of this sequence. - if the offset is invalid.\n• argument into this sequence. Inserts the string representation of theargument into this sequence. The overall effect is exactly as if the second argument were converted to a string by the method , and the character in that string were then into this character sequence at the indicated offset. The argument must be greater than or equal to , and less than or equal to the length of this sequence. - if the offset is invalid.\n• argument into this sequence. Inserts the string representation of the secondargument into this sequence. The overall effect is exactly as if the second argument were converted to a string by the method , and the characters of that string were then into this character sequence at the indicated offset. The argument must be greater than or equal to , and less than or equal to the length of this sequence. - if the offset is invalid.\n• argument into this sequence. Inserts the string representation of theargument into this sequence. The overall effect is exactly as if the second argument were converted to a string by the method , and the characters of that string were then into this character sequence at the indicated offset. The argument must be greater than or equal to , and less than or equal to the length of this sequence. - if the offset is invalid.\n• argument into this sequence. Inserts the string representation of theargument into this sequence. The overall effect is exactly as if the second argument were converted to a string by the method , and the characters of that string were then into this character sequence at the indicated offset. The argument must be greater than or equal to , and less than or equal to the length of this sequence. - if the offset is invalid.\n• argument into this sequence. Inserts the string representation of theargument into this sequence. The overall effect is exactly as if the second argument were converted to a string by the method , and the characters of that string were then into this character sequence at the indicated offset. The argument must be greater than or equal to , and less than or equal to the length of this sequence. - if the offset is invalid.\n• k such that: is . Returns the index within this string of the first occurrence of the specified substring. The integer returned is the smallest valuesuch that:is if the string argument occurs as a substring within this object, then the index of the first character of the first such substring is returned; if it does not occur as a substring, is returned.\n• for which: If no such value of k exists, then -1 is returned. Returns the index within this string of the first occurrence of the specified substring, starting at the specified index. The integer returned is the smallest valuefor which:If no such value ofexists, then -1 is returned. - the substring for which to search. - the index from which to start the search. the index within this string of the first occurrence of the specified substring, starting at the specified index.\n• . The returned index is the largest value k such that is true. Returns the index within this string of the rightmost occurrence of the specified substring. The rightmost empty string \"\" is considered to occur at the index value. The returned index is the largest valuesuch thatis true. - the substring to search for. if the string argument occurs one or more times as a substring within this object, then the index of the first character of the last such substring is returned. If it does not occur as a substring, is returned.\n• k such that: If no such value of k exists, then -1 is returned. Returns the index within this string of the last occurrence of the specified substring. The integer returned is the largest valuesuch that:If no such value ofexists, then -1 is returned. - the substring to search for. - the index to start the search from. the index within this sequence of the last occurrence of the specified substring.\n• n be the character length of this character sequence (not the length in values) just prior to execution of the method. Then the character at index k in the new character sequence is equal to the character at index n-k-1 in the old character sequence. Causes this character sequence to be replaced by the reverse of the sequence. If there are any surrogate pairs included in the sequence, these are treated as single characters for the reverse operation. Thus, the order of the high-low surrogates is never reversed. Letbe the character length of this character sequence (not the length invalues) just prior to execution of themethod. Then the character at indexin the new character sequence is equal to the character at indexin the old character sequence. Note that the reverse operation may result in producing surrogate pairs that were unpaired low-surrogates and high-surrogates before the operation. For example, reversing \"\\uDC00\\uD800\" produces \"\\uD800\\uDC00\" which is a valid surrogate pair.\n• Returns a string representing the data in this sequence. A new object is allocated and initialized to contain the character sequence currently represented by this object. This is then returned. Subsequent changes to this sequence do not affect the contents of the . a string representation of this sequence of characters."
    },
    {
        "link": "https://docs.oracle.com/javase/8/docs/api?java/lang/StringBuffer.html",
        "document": "JavaScript is disabled on your browser.\n\nThis document is designed to be viewed using the frames feature. If you see this message, you are using a non-frame-capable web client. Link to Non-frame version."
    },
    {
        "link": "https://geeksforgeeks.org/stringbuffer-class-in-java",
        "document": "StringBuffer is a class in Java that represents a mutable sequence of characters. It provides an alternative to the immutable String class, allowing you to modify the contents of a string without creating a new object every time.\n\nHere are some important features and methods of the StringBuffer class:\n• None StringBuffer objects are mutable, meaning that you can change the contents of the buffer without creating a new object.\n• None The initial capacity of a StringBuffer can be specified when it is created, or it can be set later with the ensureCapacity() method.\n• None The append() method is used to add characters, strings, or other objects to the end of the buffer.\n• None The insert() method is used to insert characters, strings, or other objects at a specified position in the buffer.\n• None The delete() method is used to remove characters from the buffer.\n• None The reverse() method is used to reverse the order of the characters in the buffer.\n\nHere is an example of using StringBuffer to concatenate strings:\n\nAdvantages of using StringBuffer in Java\n\nThere are several advantages of using StringBuffer over regular String objects in Java:\n• None Mutable: StringBuffer objects are mutable, which means that you can modify the contents of the object after it has been created. In contrast, String objects are immutable, which means that you cannot change the contents of a String once it has been created.\n• Efficient : Because StringBuffer objects are mutable, they are more efficient than creating new String objects each time you need to modify a string. This is especially true if you need to modify a string multiple times, as each modification to a String object creates a new object and discards the old one.\n\nOverall, if you need to perform multiple modifications to a string, using StringBuffer can be more efficient than regular String objects.\n\nStringBuffer is a peer class of String that provides much of the functionality of strings. The string represents fixed-length, immutable character sequences while StringBuffer represents growable and writable character sequences. StringBuffer may have characters and substrings inserted in the middle or appended to the end. It will automatically grow to make room for such additions and often has more characters preallocated than are actually needed, to allow room for growth.\n\nStringBuffer class is used to create mutable (modifiable) strings. The StringBuffer class in Java is the same as the String class except it is mutable i.e. it can be changed.\n\nThe append() method concatenates the given argument with this string.\n\nThe insert() method inserts the given string with this string at the given position.\n\nThe replace() method replaces the given string from the specified beginIndex and endIndex-1.\n\nThe delete() method of the StringBuffer class deletes the string from the specified beginIndex to endIndex-1.\n\nThe reverse() method of the StringBuilder class reverses the current string.\n• None The capacity() method of the StringBuffer class returns the current capacity of the buffer. The default capacity of the buffer is 16. If the number of characters increases from its current capacity, it increases the capacity by (oldcapacity*2)+2.\n• None For instance, if your current capacity is 16, it will be (16*2)+2=34.\n\nSome Interesting Facts about the StringBuffer Class\n\nDo keep the following points in the back of your mind:\n• None String buffers are safe for use by multiple threads. The methods can be synchronized wherever necessary so that all the operations on any particular instance behave as if they occur in some serial order.\n• None Whenever an operation occurs involving a source sequence (such as appending or inserting from a source sequence) this class synchronizes only on the string buffer performing the operation, not on the source.\n• None It inherits some of the methods from the Object class which such as clone(), equals(), finalize(), getClass(), hashCode(), , notifyAll().\n\nThese auxiliary methods are as follows:\n\nE xamples of the above methods\n\nIt is used to add text at the end of the existing text. Here are a few of its forms:\n\nIt is used to insert text at the specified index position. Syntax of method is mentioned below:\n\nHere, the index specifies the index at which point the string will be inserted into the invoking StringBuffer object.\n\nIt can reverse the characters within a StringBuffer object using reverse( ). This method returns the reversed object on which it was called.\n\nIt can delete characters within a StringBuffer by using the methods delete( ) and deleteCharAt( ).The delete( ) method deletes a sequence of characters from the invoking object. Here, the start Index specifies the index of the first character to remove, and the end Index specifies an index one past the last character to remove. Thus, the substring deleted runs from start Index to endIndex–1. The resulting StringBuffer object is returned. The deleteCharAt( ) method deletes the character at the index specified by loc. It returns the resulting StringBuffer object.\n\nIt can replace one set of characters with another set inside a StringBuffer object by calling replace( ). The substring being replaced is specified by the indexes start Index and endIndex. Thus, the substring at start Index through endIndex–1 is replaced. The replacement string is passed in str. The resulting StringBuffer object is returned."
    },
    {
        "link": "https://javadoc.scijava.org/Java8/index.html?java/lang/String.html",
        "document": "JavaScript is disabled on your browser.\n\nThis document is designed to be viewed using the frames feature. If you see this message, you are using a non-frame-capable web client. Link to Non-frame version."
    },
    {
        "link": "https://eecs.yorku.ca/teaching/docs/java-api/java/lang/StringBuffer.html",
        "document": ""
    },
    {
        "link": "https://netty.io/wiki/user-guide-for-4.x.html",
        "document": "Nowadays we use general purpose applications or libraries to communicate with each other. For example, we often use an HTTP client library to retrieve information from a web server and to invoke a remote procedure call via web services. However, a general purpose protocol or its implementation sometimes does not scale very well. It is like how we don't use a general purpose HTTP server to exchange huge files, e-mail messages, and near-realtime messages such as financial information and multiplayer game data. What's required is a highly optimized protocol implementation that is dedicated to a special purpose. For example, you might want to implement an HTTP server that is optimized for AJAX-based chat application, media streaming, or large file transfer. You could even want to design and implement a whole new protocol that is precisely tailored to your need. Another inevitable case is when you have to deal with a legacy proprietary protocol to ensure the interoperability with an old system. What matters in this case is how quickly we can implement that protocol while not sacrificing the stability and performance of the resulting application.\n\nThe Netty project is an effort to provide an asynchronous event-driven network application framework and tooling for the rapid development of maintainable high-performance and high-scalability protocol servers and clients.\n\nIn other words, Netty is an NIO client server framework that enables quick and easy development of network applications such as protocol servers and clients. It greatly simplifies and streamlines network programming such as TCP and UDP socket server development.\n\n'Quick and easy' does not mean that a resulting application will suffer from a maintainability or a performance issue. Netty has been designed carefully with the experiences learned from the implementation of a lot of protocols such as FTP, SMTP, HTTP, and various binary and text-based legacy protocols. As a result, Netty has succeeded to find a way to achieve ease of development, performance, stability, and flexibility without a compromise.\n\nSome users might already have found other network application frameworks that claim to have the same advantage, and you might want to ask what makes Netty so different from them. The answer is the philosophy it is built on. Netty is designed to give you the most comfortable experience both in terms of the API and the implementation from day one. It is not something tangible but you will realize that this philosophy will make your life much easier as you read this guide and play with Netty.\n\nThis chapter tours around the core constructs of Netty with simple examples to let you get started quickly. You will be able to write a client and a server on top of Netty right away when you are at the end of this chapter.\n\nIf you prefer a top-down approach in learning something, you might want to start from Chapter 2, Architectural Overview and get back here.\n\nThe minimum requirements to run the examples in this chapter are only two; the latest version of Netty and JDK 1.6 or above. The latest version of Netty is available in the project download page. To download the right version of JDK, please refer to your preferred JDK vendor's web site.\n\nAs you read, you might have more questions about the classes introduced in this chapter. Please refer to the API reference whenever you want to know more about them. All class names in this document are linked to the online API reference for your convenience. Also, please don't hesitate to contact the Netty project community and let us know if there's any incorrect information, errors in grammar or typos, and if you have any good ideas to help improve the documentation.\n\nThe most simplistic protocol in the world is not 'Hello, World!' but . It's a protocol that discards any received data without any response.\n\nTo implement the protocol, the only thing you need to do is to ignore all received data. Let us start straight from the handler implementation, which handles I/O events generated by Netty.\n• extends , which is an implementation of . provides various event handler methods that you can override. For now, it is just enough to extend rather than to implement the handler interface by yourself.\n• We override the event handler method here. This method is called with the received message, whenever new data is received from a client. In this example, the type of the received message is .\n• To implement the protocol, the handler has to ignore the received message. is a reference-counted object which has to be released explicitly via the method. Please keep in mind that it is the handler's responsibility to release any reference-counted object passed to the handler. Usually, handler method is implemented like the following:\n• The event handler method is called with a Throwable when an exception was raised by Netty due to an I/O error or by a handler implementation due to the exception thrown while processing events. In most cases, the caught exception should be logged and its associated channel should be closed here, although the implementation of this method can be different depending on what you want to do to deal with an exceptional situation. For example, you might want to send a response message with an error code before closing the connection.\n\nSo far so good. We have implemented the first half of the server. What's left now is to write the method which starts the server with the .\n• is a multithreaded event loop that handles I/O operation. Netty provides various implementations for different kind of transports. We are implementing a server-side application in this example, and therefore two will be used. The first one, often called 'boss', accepts an incoming connection. The second one, often called 'worker', handles the traffic of the accepted connection once the boss accepts the connection and registers the accepted connection to the worker. How many Threads are used and how they are mapped to the created s depends on the implementation and may be even configurable via a constructor.\n• is a helper class that sets up a server. You can set up the server using a directly. However, please note that this is a tedious process, and you do not need to do that in most cases.\n• Here, we specify to use the class which is used to instantiate a new to accept incoming connections.\n• The handler specified here will always be evaluated by a newly accepted . The is a special handler that is purposed to help a user configure a new . It is most likely that you want to configure the of the new by adding some handlers such as to implement your network application. As the application gets complicated, it is likely that you will add more handlers to the pipeline and extract this anonymous class into a top-level class eventually.\n• You can also set the parameters which are specific to the implementation. We are writing a TCP/IP server, so we are allowed to set the socket options such as and . Please refer to the apidocs of and the specific implementations to get an overview about the supported s.\n• Did you notice and ? is for the that accepts incoming connections. is for the s accepted by the parent , which is in this case.\n• We are ready to go now. What's left is to bind to the port and to start the server. Here, we bind to the port of all NICs (network interface cards) in the machine. You can now call the method as many times as you want (with different bind addresses.)\n\nCongratulations! You've just finished your first server on top of Netty.\n\nNow that we have written our first server, we need to test if it really works. The easiest way to test it is to use the telnet command. For example, you could enter in the command line and type something.\n\nHowever, can we say that the server is working fine? We cannot really know that because it is a discard server. You will not get any response at all. To prove it is really working, let us modify the server to print what it has received.\n\nWe already know that method is invoked whenever data is received. Let us put some code into the method of the :\n• This inefficient loop can actually be simplified to:\n• Alternatively, you could do here.\n\nIf you run the telnet command again, you will see the server prints what it has received.\n\nThe full source code of the discard server is located in the package of the distribution.\n\nSo far, we have been consuming data without responding at all. A server, however, is usually supposed to respond to a request. Let us learn how to write a response message to a client by implementing the protocol, where any received data is sent back.\n\nThe only difference from the discard server we have implemented in the previous sections is that it sends the received data back instead of printing the received data out to the console. Therefore, it is enough again to modify the method:\n• A object provides various operations that enable you to trigger various I/O events and operations. Here, we invoke to write the received message in verbatim. Please note that we did not release the received message unlike we did in the example. It is because Netty releases it for you when it is written out to the wire.\n• does not make the message written out to the wire. It is buffered internally and then flushed out to the wire by . Alternatively, you could call for brevity.\n\nIf you run the telnet command again, you will see the server sends back whatever you have sent to it.\n\nThe full source code of the echo server is located in the package of the distribution.\n\nThe protocol to implement in this section is the protocol. It is different from the previous examples in that it sends a message, which contains a 32-bit integer, without receiving any requests and closes the connection once the message is sent. In this example, you will learn how to construct and send a message, and to close the connection on completion.\n\nBecause we are going to ignore any received data but to send a message as soon as a connection is established, we cannot use the method this time. Instead, we should override the method. The following is the implementation:\n• As explained, the method will be invoked when a connection is established and ready to generate traffic. Let's write a 32-bit integer that represents the current time in this method.\n• To send a new message, we need to allocate a new buffer which will contain the message. We are going to write a 32-bit integer, and therefore we need a whose capacity is at least 4 bytes. Get the current via and allocate a new buffer.\n• As usual, we write the constructed message. But wait, where's the flip? Didn't we used to call before sending a message in NIO? does not have such a method because it has two pointers; one for read operations and the other for write operations. The writer index increases when you write something to a while the reader index does not change. The reader index and the writer index represents where the message starts and ends respectively. In contrast, NIO buffer does not provide a clean way to figure out where the message content starts and ends without calling the flip method. You will be in trouble when you forget to flip the buffer because nothing or incorrect data will be sent. Such an error does not happen in Netty because we have different pointer for different operation types. You will find it makes your life much easier as you get used to it -- a life without flipping out! Another point to note is that the (and ) method returns a . A represents an I/O operation which has not yet occurred. It means, any requested operation might not have been performed yet because all operations are asynchronous in Netty. For example, the following code might close the connection even before a message is sent: Therefore, you need to call the method after the is complete, which was returned by the method, and it notifies its listeners when the write operation has been done. Please note that, also might not close the connection immediately, and it returns a .\n• How do we get notified when a write request is finished then? This is as simple as adding a to the returned . Here, we created a new anonymous which closes the when the operation is done. Alternatively, you could simplify the code using a pre-defined listener:\n\nTo test if our time server works as expected, you can use the UNIX command:\n\nwhere is the port number you specified in the method and is usually .\n\nUnlike and servers, we need a client for the protocol because a human cannot translate a 32-bit binary data into a date on a calendar. In this section, we discuss how to make sure the server works correctly and learn how to write a client with Netty.\n\nThe biggest and only difference between a server and a client in Netty is that different and implementations are used. Please take a look at the following code:\n• is similar to except that it's for non-server channels such as a client-side or connectionless channel.\n• If you specify only one , it will be used both as a boss group and as a worker group. The boss worker is not used for the client side though.\n• Instead of , is being used to create a client-side .\n• Note that we do not use here unlike we did with because the client-side does not have a parent.\n• We should call the method instead of the method.\n\nAs you can see, it is not really different from the server-side code. What about the implementation? It should receive a 32-bit integer from the server, translate it into a human-readable format, print the translated time, and close the connection:\n• In TCP/IP, Netty reads the data sent from a peer into a .\n\nIt looks very simple and does not look any different from the server side example. However, this handler sometimes will refuse to work raising an . We discuss why this happens in the next section.\n\nIn a stream-based transport such as TCP/IP, received data is stored into a socket receive buffer. Unfortunately, the buffer of a stream-based transport is not a queue of packets but a queue of bytes. It means, even if you sent two messages as two independent packets, an operating system will not treat them as two messages but as just a bunch of bytes. Therefore, there is no guarantee that what you read is exactly what your remote peer wrote. For example, let us assume that the TCP/IP stack of an operating system has received three packets:\n\nBecause of this general property of a stream-based protocol, there's a high chance of reading them in the following fragmented form in your application:\n\nTherefore, a receiving part, regardless it is server-side or client-side, should defrag the received data into one or more meaningful frames that could be easily understood by the application logic. In the case of the example above, the received data should be framed like the following:\n\nNow let us get back to the client example. We have the same problem here. A 32-bit integer is a very small amount of data, and it is not likely to be fragmented often. However, the problem is that it can be fragmented, and the possibility of fragmentation will increase as the traffic increases.\n\nThe simplistic solution is to create an internal cumulative buffer and wait until all 4 bytes are received into the internal buffer. The following is the modified implementation that fixes the problem:\n• A has two life cycle listener methods: and . You can perform an arbitrary (de)initialization task as long as it does not block for a long time.\n• First, all received data should be cumulated into .\n• And then, the handler must check if has enough data, 4 bytes in this example, and proceed to the actual business logic. Otherwise, Netty will call the method again when more data arrives, and eventually all 4 bytes will be cumulated.\n\nAlthough the first solution has resolved the problem with the client, the modified handler does not look that clean. Imagine a more complicated protocol which is composed of multiple fields such as a variable length field. Your implementation will become unmaintainable very quickly.\n\nAs you may have noticed, you can add more than one to a , and therefore, you can split one monolithic into multiple modular ones to reduce the complexity of your application. For example, you could split into two handlers:\n• which deals with the fragmentation issue, and\n\nFortunately, Netty provides an extensible class which helps you write the first one out of the box:\n• is an implementation of which makes it easy to deal with the fragmentation issue.\n• calls the method with an internally maintained cumulative buffer whenever new data is received.\n• can decide to add nothing to when there is not enough data in the cumulative buffer. will call again when there is more data received.\n• If adds an object to , it means the decoder decoded a message successfully. will discard the read part of the cumulative buffer. Please remember that you don't need to decode multiple messages. will keep calling the method until it adds nothing to .\n\nNow that we have another handler to insert into the , we should modify the implementation in the :\n\nIf you are an adventurous person, you might want to try the which simplifies the decoder even more. You will need to consult the API reference for more information though.\n\nAdditionally, Netty provides out-of-the-box decoders which enables you to implement most protocols very easily and helps you avoid from ending up with a monolithic unmaintainable handler implementation. Please refer to the following packages for more detailed examples:\n\nAll the examples we have reviewed so far used a as a primary data structure of a protocol message. In this section, we will improve the protocol client and server example to use a POJO instead of a .\n\nThe advantage of using a POJO in your s is obvious; your handler becomes more maintainable and reusable by separating the code which extracts information from out from the handler. In the client and server examples, we read only one 32-bit integer and it is not a major issue to use directly. However, you will find it is necessary to make the separation as you implement a real-world protocol.\n\nFirst, let us define a new type called .\n\nWe can now revise the to produce a instead of a .\n\nWith the updated decoder, the does not use anymore:\n\nMuch simpler and elegant, right? The same technique can be applied on the server side. Let us update the first this time:\n\nNow, the only missing piece is an encoder, which is an implementation of that translates a back into a . It's much simpler than writing a decoder because there's no need to deal with packet fragmentation and assembly when encoding a message.\n• There are quite a few important things in this single line. First, we pass the original as-is so that Netty marks it as success or failure when the encoded data is actually written out to the wire. Second, we did not call . There is a separate handler method which is purposed to override the operation.\n\nTo simplify even further, you can make use of :\n\nThe last task left is to insert a into the on the server side before the , and it is left as a trivial exercise.\n\nShutting down a Netty application is usually as simple as shutting down all s you created via . It returns a that notifies you when the has been terminated completely and all s that belong to the group have been closed.\n\nIn this chapter, we had a quick tour of Netty with a demonstration on how to write a fully working network application on top of Netty.\n\nThere is more detailed information about Netty in the upcoming chapters. We also encourage you to review the Netty examples in the package.\n\nPlease also note that the community is always waiting for your questions and ideas to help you and keep improving Netty and its documentation based on your feedback."
    },
    {
        "link": "https://netty.io/4.1/api/io/netty/channel/ChannelHandlerContext.html",
        "document": "Retrieving for later use\n\nA handler can have more than one\n\nEnables a to interact with its and other handlers. Among other things a handler can notify the next in the as well as modify the it belongs to dynamically.You can notify the closest handler in the same by calling one of the various methods provided here. Please refer to to understand how an event flows.You can get the your handler belongs to by calling . A non-trivial application could insert, remove, or replace handlers in the pipeline dynamically at runtime.You can keep the for later use, such as triggering an event outside the handler methods, even from a different thread. allow you to store and access stateful information that is related with a and its context. Please refer to to learn various recommended ways to manage stateful information.Please note that a instance can be added to more than one . It means a single instance can have more than one and therefore the single instance can be invoked with different s if it is added to one or more s more than once. Also note that a that is supposed to be added to multiple s should be marked as\n\nPlease refer to the , and to find out more about inbound and outbound operations, what fundamental differences they have, how they flow in a pipeline, and how to handle the operation in your application."
    },
    {
        "link": "https://baeldung.com/netty",
        "document": "In this article, we’re going to take a look at Netty — an asynchronous event-driven network application framework.\n\nThe main purpose of Netty is building high-performance protocol servers based on NIO (or possibly NIO.2) with separation and loose coupling of the network and business logic components. It might implement a widely known protocol, such as HTTP, or your own specific protocol.\n\nNetty is a non-blocking framework. This leads to high throughput compared to blocking IO. Understanding non-blocking IO is crucial to understanding Netty’s core components and their relationships.\n\nChannel is the base of Java NIO. It represents an open connection which is capable of IO operations such as reading and writing.\n\nEvery IO operation on a Channel in Netty is non-blocking.\n\nThis means that every operation is returned immediately after the call. There is a Future interface in the standard Java library, but it’s not convenient for Netty purposes — we can only ask the Future about the completion of the operation or to block the current thread until the operation is done.\n\nThat’s why Netty has its own ChannelFuture interface. We can pass a callback to ChannelFuture which will be called upon operation completion.\n\nNetty uses an event-driven application paradigm, so the pipeline of the data processing is a chain of events going through handlers. Events and handlers can be related to the inbound and outbound data flow. Inbound events can be the following:\n\nOutbound events are simpler and, generally, are related to opening/closing a connection and writing/flushing data.\n\nNetty applications consist of a couple of networking and application logic events and their handlers. The base interfaces for the channel event handlers are ChannelHandler and its successors ChannelOutboundHandler and ChannelInboundHandler.\n\nNetty provides a huge hierarchy of implementations of ChannelHandler. It is worth noting the adapters which are just empty implementations, e.g. ChannelInboundHandlerAdapter and ChannelOutboundHandlerAdapter. We could extend these adapters when we need to process only a subset of all events.\n\nAlso, there are many implementations of specific protocols such as HTTP, e.g. HttpRequestDecoder, HttpResponseEncoder, HttpObjectAggregator. It would be good to get acquainted with them in Netty’s Javadoc.\n\nAs we work with the network protocol, we need to perform data serialization and deserialization. For this purpose, Netty introduces special extensions of the ChannelInboundHandler for decoders which are capable of decoding incoming data. The base class of most decoders is ByteToMessageDecoder.\n\nFor encoding outgoing data, Netty has extensions of the ChannelOutboundHandler called encoders. MessageToByteEncoder is the base for most encoder implementations. We can convert the message from byte sequence to Java object and vice versa with encoders and decoders.\n\nFirst of all, we need to provide the Netty dependency in our pom.xml:\n\nWe can find the latest version over on Maven Central.\n\nThe request data class would have the following structure:\n\nLet’s assume that the server receives the request and returns the intValue multiplied by 2. The response would have the single int value:\n\nNow we need to create encoders and decoders for our protocol messages.\n\nIt should be noted that Netty works with socket receive buffer, which is represented not as a queue but just as a bunch of bytes. This means that our inbound handler can be called when the full message is not received by a server.\n\nWe must make sure that we have received the full message before processing and there are many ways to do that.\n\nFirst of all, we can create a temporary ByteBuf and append to it all inbound bytes until we get the required amount of bytes:\n\nThe example shown above looks a bit weird but helps us to understand how Netty works. Every method of our handler is called when its corresponding event occurs. So we initialize the buffer when the handler is added, fill it with data on receiving new bytes and start processing it when we get enough data.\n\nWe deliberately did not use a stringValue — decoding in such a manner would be unnecessarily complex. That’s why Netty provides useful decoder classes which are implementations of ChannelInboundHandler: ByteToMessageDecoder and ReplayingDecoder.\n\nAs we noted above we can create a channel processing pipeline with Netty. So we can put our decoder as the first handler and the processing logic handler can come after it.\n\nThe decoder for RequestData is shown next:\n\nAn idea of this decoder is pretty simple. It uses an implementation of ByteBuf which throws an exception when there is not enough data in the buffer for the reading operation.\n\nWhen the exception is caught the buffer is rewound to the beginning and the decoder waits for a new portion of data. Decoding stops when the out list is not empty after decode execution.\n\nBesides decoding the RequestData we need to encode the message. This operation is simpler because we have the full message data when the write operation occurs.\n\nWe can write data to Channel in our main handler or we can separate the logic and create a handler extending MessageToByteEncoder which will catch the write ResponseData operation:\n\nSince we carried out the decoding and encoding in separate handlers we need to change our ProcessingHandler:\n\nNow let’s put it all together and run our server:\n\nThe details of the classes used in the above server bootstrap example can be found in their Javadoc. The most interesting part is this line:\n\nHere we define inbound and outbound handlers that will process requests and output in the correct order.\n\nThe client should perform reverse encoding and decoding, so we need to have a RequestDataEncoder and ResponseDataDecoder:\n\nAlso, we need to define a ClientHandler which will send the request and receive the response from server:\n\nAs we can see, there are many details in common with the server bootstrapping.\n\nNow we can run the client’s main method and take a look at the console output. As expected, we got ResponseData with intValue equal to 246.\n\nIn this article, we had a quick introduction to Netty. We showed its core components such as Channel and ChannelHandler. Also, we’ve made a simple non-blocking protocol server and a client for it."
    },
    {
        "link": "https://netty.io/wiki/user-guide-for-5.x.html",
        "document": "Nowadays we use general purpose applications or libraries to communicate with each other. For example, we often use an HTTP client library to retrieve information from a web server and to invoke a remote procedure call via web services.\n\nHowever, a general purpose protocol or its implementation sometimes does not scale very well. It is like we don't use a general purpose HTTP server to exchange huge files, e-mail messages, and near-realtime messages such as financial information and multiplayer game data. What's required is a highly optimized protocol implementation which is dedicated to a special purpose. For example, you might want to implement an HTTP server which is optimized for AJAX-based chat application, media streaming, or large file transfer. You could even want to design and implement a whole new protocol which is precisely tailored to your need.\n\nAnother inevitable case is when you have to deal with a legacy proprietary protocol to ensure the interoperability with an old system. What matters in this case is how quickly we can implement that protocol while not sacrificing the stability and performance of the resulting application.\n\nThe Netty project is an effort to provide an asynchronous event-driven network application framework and tooling for the rapid development of maintainable high-performance · high-scalability protocol servers and clients.\n\nIn other words, Netty is a NIO client server framework which enables quick and easy development of network applications such as protocol servers and clients. It greatly simplifies and streamlines network programming such as TCP and UDP socket server development.\n\n'Quick and easy' does not mean that a resulting application will suffer from a maintainability or a performance issue. Netty has been designed carefully with the experiences earned from the implementation of a lot of protocols such as FTP, SMTP, HTTP, and various binary and text-based legacy protocols. As a result, Netty has succeeded to find a way to achieve ease of development, performance, stability, and flexibility without a compromise.\n\nSome users might already have found other network application framework that claims to have the same advantage, and you might want to ask what makes Netty so different from them. The answer is the philosophy where it is built on. Netty is designed to give you the most comfortable experience both in terms of the API and the implementation from the day one. It is not something tangible but you will realize that this philosophy will make your life much easier as you read this guide and play with Netty.\n\nThis chapter tours around the core constructs of Netty with simple examples to let you get started quickly. You will be able to write a client and a server on top of Netty right away when you are at the end of this chapter.\n\nIf you prefer top-down approach in learning something, you might want to start from Chapter 2, Architectural Overview and get back here.\n\nThe minimum requirements to run the examples which are introduced in this chapter are only two; the latest version of Netty and JDK 1.6 or above. The latest version of Netty is available in the project download page. To download the right version of JDK, please refer to your preferred JDK vendor's web site.\n\nAs you read, you might have more questions about the classes introduced in this chapter. Please refer to the API reference whenever you want to know more about them. All class names in this document are linked to the online API reference for your convenience. Also, please don't hesitate to contact the Netty project community and let us know if there's any incorrect information, errors in grammar and typo, and if you have a good idea to improve the documentation.\n\nThe most simplistic protocol in the world is not 'Hello, World!' but . It's a protocol which discards any received data without any response.\n\nTo implement the protocol, the only thing you need to do is to ignore all received data. Let us start straight from the handler implementation, which handles I/O events generated by Netty.\n• extends , which is an implementation of . provides various event handler methods that you can override. For now, it is just enough to extend rather than to implement the handler interface by yourself.\n• We override the event handler method here. This method is called with the received message, whenever new data is received from a client. In this example, the type of the received message is .\n• To implement the protocol, the handler has to ignore the received message. is a reference-counted object which has to be released explicitly via the method. Please keep in mind that it is the handler's responsibility to release any reference-counted object passed to the handler. Usually, handler method is implemented like the following:\n• The event handler method is called with a when an exception was raised by Netty due to an I/O error or by a handler implementation due to the exception thrown while processing events. In most cases, the caught exception should be logged and its associated channel should be closed here, although the implementation of this method can be different depending on what you want to do to deal with an exceptional situation. For example, you might want to send a response message with an error code before closing the connection.\n\nSo far so good. We have implemented the first half of the server. What's left now is to write the method which starts the server with the .\n• is a multithreaded event loop that handles I/O operation. Netty provides various implementations for different kind of transports. We are implementing a server-side application in this example, and therefore two will be used. The first one, often called 'boss', accepts an incoming connection. The second one, often called 'worker', handles the traffic of the accepted connection once the boss accepts the connection and registers the accepted connection to the worker. How many Threads are used and how they are mapped to the created s depends on the implementation and may be even configurable via a constructor.\n• is a helper class that sets up a server. You can set up the server using a directly. However, please note that this is a tedious process, and you do not need to do that in most cases.\n• Here, we specify to use the class which is used to instantiate a new to accept incoming connections.\n• The handler specified here will always be evaluated by a newly accepted . The is a special handler that is purposed to help a user configure a new . It is most likely that you want to configure the of the new by adding some handlers such as to implement your network application. As the application gets complicated, it is likely that you will add more handlers to the pipeline and extract this anonymous class into a top level class eventually.\n• You can also set the parameters which are specific to the implementation. We are writing a TCP/IP server, so we are allowed to set the socket options such as and . Please refer to the apidocs of and the specific implementations to get an overview about the supported s.\n• Did you notice and ? is for the that accepts incoming connections. is for the s accepted by the parent , which is in this case.\n• We are ready to go now. What's left is to bind to the port and to start the server. Here, we bind to the port of all NICs (network interface cards) in the machine. You can now call the method as many times as you want (with different bind addresses.)\n\nCongratulations! You've just finished your first server on top of Netty.\n\nNow that we have written our first server, we need to test if it really works. The easiest way to test it is to use the telnet command. For example, you could enter in the command line and type something.\n\nHowever, can we say that the server is working fine? We cannot really know that because it is a discard server. You will not get any response at all. To prove it is really working, let us modify the server to print what it has received.\n\nWe already know that method is invoked whenever data is received. Let us put some code into the method of the :\n• This inefficient loop can actually be simplified to:\n• Alternatively, you could do here.\n\nIf you run the telnet command again, you will see the server prints what has received.\n\nThe full source code of the discard server is located in the package of the distribution.\n\nSo far, we have been consuming data without responding at all. A server, however, is usually supposed to respond to a request. Let us learn how to write a response message to a client by implementing the protocol, where any received data is sent back.\n\nThe only difference from the discard server we have implemented in the previous sections is that it sends the received data back instead of printing the received data out to the console. Therefore, it is enough again to modify the method:\n• A object provides various operations that enable you to trigger various I/O events and operations. Here, we invoke to write the received message in verbatim. Please note that we did not release the received message unlike we did in the example. It is because Netty releases it for you when it is written out to the wire.\n• does not make the message written out to the wire. It is buffered internally, and then flushed out to the wire by . Alternatively, you could call for brevity.\n\nIf you run the telnet command again, you will see the server sends back whatever you have sent to it.\n\nThe full source code of the echo server is located in the package of the distribution.\n\nThe protocol to implement in this section is the protocol. It is different from the previous examples in that it sends a message, which contains a 32-bit integer, without receiving any requests and closes the connection once the message is sent. In this example, you will learn how to construct and send a message, and to close the connection on completion.\n\nBecause we are going to ignore any received data but to send a message as soon as a connection is established, we cannot use the method this time. Instead, we should override the method. The following is the implementation:\n• As explained, the method will be invoked when a connection is established and ready to generate traffic. Let's write a 32-bit integer that represents the current time in this method.\n• To send a new message, we need to allocate a new buffer which will contain the message. We are going to write a 32-bit integer, and therefore we need a whose capacity is at least 4 bytes. Get the current via and allocate a new buffer.\n• As usual, we write the constructed message. But wait, where's the flip? Didn't we used to call before sending a message in NIO? does not have such a method because it has two pointers; one for read operations and the other for write operations. The writer index increases when you write something to a while the reader index does not change. The reader index and the writer index represents where the message starts and ends respectively. In contrast, NIO buffer does not provide a clean way to figure out where the message content starts and ends without calling the flip method. You will be in trouble when you forget to flip the buffer because nothing or incorrect data will be sent. Such an error does not happen in Netty because we have different pointer for different operation types. You will find it makes your life much easier as you get used to it -- a life without flipping out! Another point to note is that the (and ) method returns a . A represents an I/O operation which has not yet occurred. It means, any requested operation might not have been performed yet because all operations are asynchronous in Netty. For example, the following code might close the connection even before a message is sent: Therefore, you need to call the method after the is complete, which was returned by the method, and it notifies its listeners when the write operation has been done. Please note that, also might not close the connection immediately, and it returns a .\n• How do we get notified when a write request is finished then? This is as simple as adding a to the returned . Here, we created a new anonymous which closes the when the operation is done. Alternatively, you could simplify the code using a pre-defined listener:\n\nTo test if our time server works as expected, you can use the UNIX command:\n\nwhere is the port number you specified in the method and is usually .\n\nUnlike and servers, we need a client for the protocol because a human cannot translate a 32-bit binary data into a date on a calendar. In this section, we discuss how to make sure the server works correctly and learn how to write a client with Netty.\n\nThe biggest and only difference between a server and a client in Netty is that different and implementations are used. Please take a look at the following code:\n• is similar to except that it's for non-server channels such as a client-side or connectionless channel.\n• If you specify only one , it will be used both as a boss group and as a worker group. The boss worker is not used for the client side though.\n• Instead of , is being used to create a client-side .\n• Note that we do not use here unlike we did with because the client-side does not have a parent.\n• We should call the method instead of the method.\n\nAs you can see, it is not really different from the the server-side code. What about the implementation? It should receive a 32-bit integer from the server, translate it into a human readable format, print the translated time, and close the connection:\n• In TCP/IP, Netty reads the data sent from a peer into a [ ].\n\nIt looks very simple and does not look any different from the server side example. However, this handler sometimes will refuse to work raising an . We discuss why this happens in the next section.\n\nIn a stream-based transport such as TCP/IP, received data is stored into a socket receive buffer. Unfortunately, the buffer of a stream-based transport is not a queue of packets but a queue of bytes. It means, even if you sent two messages as two independent packets, an operating system will not treat them as two messages but as just a bunch of bytes. Therefore, there is no guarantee that what you read is exactly what your remote peer wrote. For example, let us assume that the TCP/IP stack of an operating system has received three packets:\n\nBecause of this general property of a stream-based protocol, there's high chance of reading them in the following fragmented form in your application:\n\nTherefore, a receiving part, regardless it is server-side or client-side, should defrag the received data into one or more meaningful frames that could be easily understood by the application logic. In case of the example above, the received data should be framed like the following:\n\nNow let us get back to the client example. We have the same problem here. A 32-bit integer is a very small amount of data, and it is not likely to be fragmented often. However, the problem is that it can be fragmented, and the possibility of fragmentation will increase as the traffic increases.\n\nThe simplistic solution is to create an internal cumulative buffer and wait until all 4 bytes are received into the internal buffer. The following is the modified implementation that fixes the problem:\n• A has two life cycle listener methods: and . You can perform an arbitrary (de)initialization task as long as it does not block for a long time.\n• First, all received data should be cumulated into .\n• And then, the handler must check if has enough data, 4 bytes in this example, and proceed to the actual business logic. Otherwise, Netty will call the method again when more data arrives, and eventually all 4 bytes will be cumulated.\n\nAlthough the first solution has resolved the problem with the client, the modified handler does not look that clean. Imagine a more complicated protocol which is composed of multiple fields such as a variable length field. Your implementation will become unmaintainable very quickly.\n\nAs you may have noticed, you can add more than one to a , and therefore, you can split one monolithic into multiple modular ones to reduce the complexity of your application. For example, you could split into two handlers:\n• which deals with the fragmentation issue, and\n\nFortunately, Netty provides an extensible class which helps you write the first one out of the box:\n• is an implementation of which makes it easy to deal with the fragmentation issue.\n• calls the method with an internally maintained cumulative buffer whenever new data is received.\n• can decide to add nothing to where there is not enough data in the cumulative buffer. will call again when there is more data received.\n• If adds an object to , it means the decoder decoded a message successfully. will discard the read part of the cumulative buffer. Please remember that you don't need to decode multiple messages. will keep calling the method until it adds nothing to .\n\nNow that we have another handler to insert into the , we should modify the implementation in the :\n\nIf you are an adventurous person, you might want to try the which simplifies the decoder even more. You will need to consult the API reference for more information though.\n\nAdditionally, Netty provides out-of-the-box decoders which enables you to implement most protocols very easily and helps you avoid from ending up with a monolithic unmaintainable handler implementation. Please refer to the following packages for more detailed examples:\n\nAll the examples we have reviewed so far used a as a primary data structure of a protocol message. In this section, we will improve the protocol client and server example to use a POJO instead of a .\n\nThe advantage of using a POJO in your s is obvious; your handler becomes more maintainable and reusable by separating the code which extracts information from out from the handler. In the client and server examples, we read only one 32-bit integer and it is not a major issue to use directly. However, you will find it is necessary to make the separation as you implement a real world protocol.\n\nFirst, let us define a new type called .\n\nWe can now revise the to produce a instead of a .\n\nWith the updated decoder, the does not use anymore:\n\nMuch simpler and elegant, right? The same technique can be applied on the server side. Let us update the first this time:\n\nNow, the only missing piece is an encoder, which is an implementation of that translates a back into a . It's much simpler than writing a decoder because there's no need to deal with packet fragmentation and assembly when encoding a message.\n• There are a few important things to notice in this handler method: First, we pass the original as-is so that Netty marks it as success or failure when the encoded data is actually written out to the wire. Second, we did not call . There is a separate handler method which is purposed to override the operation.\n\nTo simplify even further, you can make use of :\n\nThe last task left is to insert a into the on the server side before the , and it is left as a trivial exercise.\n\nShutting down a Netty application is usually as simple as shutting down all s you created via . It returns a that notifies you when the has been terminated completely and all s that belong to the group have been closed.\n\nIn this chapter, we had a quick tour of Netty with a demonstration on how to write a fully working network application on top of Netty.\n\nThere is more detailed information about Netty in the upcoming chapters. We also encourage you to review the Netty examples in the package.\n\nPlease also note that the community is always waiting for your questions and ideas to help you and keep improving Netty and its documentation based on your feed back."
    },
    {
        "link": "https://projectreactor.io/docs/netty/milestone/reference/http-server.html",
        "document": "To receive data from a connected client, you must attach an I/O handler by using either or . The I/O handler has access to , to be able to read data. The following example uses the method: When you receive data from the connected clients, you might need to check request headers, parameters, and other metadata. You can obtain this additional metadata by using . The following example shows how to do so: When you receive data from the connected clients, you might want to access ( ) or ( ) data. You can obtain this data by using . When you need to change the default settings, you can configure the or you can provide a configuration per request: Configuration on the that specifies that the data is stored on disk only. Configuration per request that specifies that if the data size exceed the specified size, the data is stored on the disk. The following listing shows the available configurations: Configures the directory where to store the data on the disk. Default to generated temp directory. Configures the for the data. Default to . Configures the maximum in-memory size per data i.e. the data is written on disk if the size is greater than , else it is in memory. If set to the entire contents is stored in memory. If set to the entire contents is stored on disk. Default to . Configures the maximum size per data. When the limit is reached, an exception is raised. If set to this means no limitation. Default to - unlimited. Configures the scheduler to be used for offloading disk operations in the decoding phase. Default to When set to , the data is streamed directly from the parsed input buffer stream, which means it is not stored either in memory or file. When , parts are backed by in-memory and/or file storage. Default to . NOTE that with streaming enabled, the provided data might not be in a complete state i.e. has to be checked. Also note that enabling this property effectively ignores , , and . In addition to the metadata that you can obtain from the request, you can also receive the address, the address and the . Depending on the chosen factory method, you can retrieve the information directly from the channel or by using the or request headers. The following example shows how to do so: Specifies that the information about the connection is to be obtained from the and request headers, if possible. Returns the address of the remote (client) peer. It is also possible to customize the behavior of the or header handler. The following example shows how to do so: Returns the address of the remote (client) peer. By default, configures some restrictions for the incoming requests, such as:\n• The maximum length of the initial line.\n• The maximum length of all headers.\n• The maximum length of the content or each chunk. For more information, see and By default, the server is configured with the following settings: public static final int DEFAULT_MAX_INITIAL_LINE_LENGTH = 4096; public static final int DEFAULT_MAX_HEADER_SIZE = 8192; /** * Default max chunk size. * * @deprecated as of 1.1.0. This will be removed in 2.0.0 as Netty 5 does not support this configuration. */ @Deprecated public static final int DEFAULT_MAX_CHUNK_SIZE = 8192; public static final boolean DEFAULT_VALIDATE_HEADERS = true; public static final int DEFAULT_INITIAL_BUFFER_SIZE = 128; public static final boolean DEFAULT_ALLOW_DUPLICATE_CONTENT_LENGTHS = false; public static final boolean DEFAULT_ALLOW_PARTIAL_CHUNKS = true; /** * The maximum length of the content of the HTTP/2.0 clear-text upgrade request. * By default, the server will reject an upgrade request with non-empty content, * because the upgrade request is most likely a GET request. */ public static final int DEFAULT_H2C_MAX_CONTENT_LENGTH = 0; When you need to change these default settings, you can configure the server as follows: The maximum length of all headers will be . When this value is exceeded, a TooLongFrameException is raised.\n\nWhen you need to change configuration on the TCP level, you can use the following snippet to extend the default server configuration: See TCP Server for more detail about TCP-level configuration. Reactor Netty provides wire logging for when the traffic between the peers needs to be inspected. By default, wire logging is disabled. To enable it, you must set the logger level to and apply the following configuration: /** * When wire logging is enabled with this format, both events and content will be logged. * The content will be in hex format. * <p>Examples:</p> * <pre> * {@code * reactor.netty.http.HttpTests - [d5230a14, L:/0:0:0:0:0:0:0:1:60267 - R:/0:0:0:0:0:0:0:1:60269] REGISTERED * reactor.netty.http.HttpTests - [d5230a14, L:/0:0:0:0:0:0:0:1:60267 - R:/0:0:0:0:0:0:0:1:60269] ACTIVE * reactor.netty.http.HttpTests - [d5230a14, L:/0:0:0:0:0:0:0:1:60267 - R:/0:0:0:0:0:0:0:1:60269] READ: 145B * +-------------------------------------------------+ * | 0 1 2 3 4 5 6 7 8 9 a b c d e f | * +--------+-------------------------------------------------+----------------+ * |00000000| 50 4f 53 54 20 2f 74 65 73 74 2f 57 6f 72 6c 64 |POST /test/World| * |00000010| 20 48 54 54 50 2f 31 2e 31 0d 0a 43 6f 6e 74 65 | HTTP/1.1..Conte| * |00000020| 6e 74 2d 54 79 70 65 3a 20 74 65 78 74 2f 70 6c |nt-Type: text/pl| * |00000030| 61 69 6e 0d 0a 75 73 65 72 2d 61 67 65 6e 74 3a |ain..user-agent:| * |00000040| 20 52 65 61 63 74 6f 72 4e 65 74 74 79 2f 64 65 | ReactorNetty/de| * ... * reactor.netty.http.HttpTests - [d5230a14, L:/0:0:0:0:0:0:0:1:60267 - R:/0:0:0:0:0:0:0:1:60269] WRITE: 38B * +-------------------------------------------------+ * | 0 1 2 3 4 5 6 7 8 9 a b c d e f | * +--------+-------------------------------------------------+----------------+ * |00000000| 48 54 54 50 2f 31 2e 31 20 32 30 30 20 4f 4b 0d |HTTP/1.1 200 OK.| * |00000010| 0a 63 6f 6e 74 65 6e 74 2d 6c 65 6e 67 74 68 3a |.content-length:| * |00000020| 20 30 0d 0a 0d 0a | 0.... | * +--------+-------------------------------------------------+----------------+ * } * </pre> */ /** * When wire logging is enabled with this format, only the events will be logged. * <p>Examples:</p> * <pre> * {@code * reactor.netty.http.HttpTests - [230d3686, L:/0:0:0:0:0:0:0:1:60241 - R:/0:0:0:0:0:0:0:1:60245] REGISTERED * reactor.netty.http.HttpTests - [230d3686, L:/0:0:0:0:0:0:0:1:60241 - R:/0:0:0:0:0:0:0:1:60245] ACTIVE * reactor.netty.http.HttpTests - [230d3686, L:/0:0:0:0:0:0:0:1:60241 - R:/0:0:0:0:0:0:0:1:60245] READ: 145B * reactor.netty.http.HttpTests - [230d3686, L:/0:0:0:0:0:0:0:1:60241 - R:/0:0:0:0:0:0:0:1:60245] WRITE: 38B * } * </pre> */ /** * When wire logging is enabled with this format, both events and content will be logged. * The content will be in plain text format. * <p>Examples:</p> * <pre> * {@code * reactor.netty.http.HttpTests - [02c3db6c, L:/0:0:0:0:0:0:0:1:60317 - R:/0:0:0:0:0:0:0:1:60319] REGISTERED * reactor.netty.http.HttpTests - [02c3db6c, L:/0:0:0:0:0:0:0:1:60317 - R:/0:0:0:0:0:0:0:1:60319] ACTIVE * reactor.netty.http.HttpTests - [02c3db6c, L:/0:0:0:0:0:0:0:1:60317 - R:/0:0:0:0:0:0:0:1:60319] READ: 145B POST /test/World HTTP/1.1 * Content-Type: text/plain * user-agent: ReactorNetty/dev * ... * reactor.netty.http.HttpTests - [02c3db6c, L:/0:0:0:0:0:0:0:1:60317 - R:/0:0:0:0:0:0:0:1:60319] WRITE: 38B HTTP/1.1 200 OK * content-length: 0 * } * </pre> */ When you need to change the default formatter you can configure it as follows: Enables the wire logging, AdvancedByteBufFormat#TEXTUAL is used for printing the content. By default uses an “Event Loop Group”, where the number of the worker threads equals the number of processors available to the runtime on initialization (but with a minimum value of 4). This “Event Loop Group” is shared between all servers and clients in one JVM. When you need a different configuration, you can use one of the methods. The following listing shows the default configuration for the Event Loop Group: /** * Default worker thread count, fallback to available processor * (but with a minimum value of 4). */ public static final String IO_WORKER_COUNT = \"reactor.netty.ioWorkerCount\"; /** * Default selector thread count, fallback to -1 (no selector thread) * <p><strong>Note:</strong> In most use cases using a worker thread also as a selector thread works well. * A possible use case for specifying a separate selector thread might be when the worker threads are too busy * and connections cannot be accepted fast enough. * <p><strong>Note:</strong> Although more than 1 can be configured as a selector thread count, in reality * only 1 thread will be used as a selector thread. */ public static final String IO_SELECT_COUNT = \"reactor.netty.ioSelectCount\"; /** * Default worker thread count for UDP, fallback to available processor * (but with a minimum value of 4). */ public static final String UDP_IO_THREAD_COUNT = \"reactor.netty.udp.ioThreadCount\"; /** * Default quiet period that guarantees that the disposal of the underlying LoopResources * will not happen, fallback to 2 seconds. */ public static final String SHUTDOWN_QUIET_PERIOD = \"reactor.netty.ioShutdownQuietPeriod\"; /** * Default maximum amount of time to wait until the disposal of the underlying LoopResources * regardless if a task was submitted during the quiet period, fallback to 15 seconds. */ public static final String SHUTDOWN_TIMEOUT = \"reactor.netty.ioShutdownTimeout\"; /** * Default value whether the native transport (epoll, kqueue) will be preferred, * fallback it will be preferred when available. */ public static final String NATIVE = \"reactor.netty.native\"; If you need changes to these settings, you can apply the following configuration:\n• If you use the default provided by Reactor Netty, invoke / method. Disposing means that every server/client that is using it, will not be able to use it anymore!\n• If you use custom , invoke / method. Disposing the custom means that every server/client that is configured to use it, will not be able to use it anymore!\n\nBy default, the server supports . If you need , you can get it through configuration. In addition to the protocol configuration, if you need but not , you must also configure SSL. As Application-Layer Protocol Negotiation (ALPN) is not supported “out-of-the-box” by JDK8 (although some vendors backported ALPN to JDK8), you need an additional dependency to a native library that supports it — for example, . The following listing presents a simple example: Configures the server to support only The application should now behave as follows: The following listing presents a simple example: The application should now behave as follows: public enum HttpProtocol { /** * The default supported HTTP protocol by HttpServer and HttpClient. */ HTTP11, /** * HTTP/2.0 support with TLS * <p>If used along with HTTP/1.1 protocol, HTTP/2.0 will be the preferred protocol. * While negotiating the application level protocol, HTTP/2.0 or HTTP/1.1 can be chosen. * <p>If used without HTTP/1.1 protocol, HTTP/2.0 will always be offered as a protocol * for communication with no fallback to HTTP/1.1. */ H2, /** * HTTP/2.0 support with clear-text. * <p>If used along with HTTP/1.1 protocol, will support H2C \"upgrade\": * Request or consume requests as HTTP/1.1 first, looking for HTTP/2.0 headers * and {@literal Connection: Upgrade}. A server will typically reply a successful * 101 status if upgrade is successful or a fallback HTTP/1.1 response. When * successful the client will start sending HTTP/2.0 traffic. * <p>If used without HTTP/1.1 protocol, will support H2C \"prior-knowledge\": Doesn't * require {@literal Connection: Upgrade} handshake between a client and server but * fallback to HTTP/1.1 will not be supported. */ H2C, /** * HTTP/3.0 support. * @since 1.2.0 */ @Incubating HTTP3 }\n\nThe following table provides information for the HTTP server spans: Information and total time for the request. See Http Server Response Span. The following example enables that integration. This concrete example uses and reports the information to . See the documentation for setup. public class Application { public static void main(String[] args) { init(); (1) DisposableServer server = HttpServer.create() .metrics(true, s -> { if (s.startsWith(\"/stream/\")) { (2) return \"/stream/{n}\"; } return s; }) (3) .route(r -> r.get(\"/stream/{n}\", (req, res) -> res.sendString(Mono.just(req.param(\"n\"))))) .bindNow(); server.onDispose() .block(); } /** * This setup is based on * <a href=\"https://micrometer.io/docs/tracing#_micrometer_tracing_brave_setup\">Micrometer Tracing Brave Setup</a>. */ static void init() { AsyncZipkinSpanHandler spanHandler = AsyncZipkinSpanHandler .create(URLConnectionSender.create(\"http://localhost:9411/api/v2/spans\")); StrictCurrentTraceContext braveCurrentTraceContext = StrictCurrentTraceContext.create(); CurrentTraceContext bridgeContext = new BraveCurrentTraceContext(braveCurrentTraceContext); Tracing tracing = Tracing.newBuilder() .currentTraceContext(braveCurrentTraceContext) .supportsJoin(false) .traceId128Bit(true) .sampler(Sampler.ALWAYS_SAMPLE) .addSpanHandler(spanHandler) .localServiceName(\"reactor-netty-examples\") .build(); brave.Tracer braveTracer = tracing.tracer(); Tracer tracer = new BraveTracer(braveTracer, bridgeContext, new BraveBaggageManager()); Propagator propagator = new BravePropagator(tracing); OBSERVATION_REGISTRY.observationConfig() .observationHandler(new ReactorNettyPropagatingReceiverTracingObservationHandler(tracer, propagator)); } } Templated URIs are used as an URI tag value when possible. The result in looks like: Project Micrometer provides that assists with context propagation across different types of context mechanisms such as , and others. The following example shows how to use this library in a custom : public class Application { public static void main(String[] args) { init(); (1) DisposableServer server = HttpServer.create() .metrics(true, s -> { if (s.startsWith(\"/stream/\")) { (2) return \"/stream/{n}\"; } return s; }) (3) .doOnConnection(conn -> conn.addHandlerLast(CustomChannelOutboundHandler.INSTANCE)) (4) .route(r -> r.get(\"/stream/{n}\", (req, res) -> res.sendString(Mono.just(req.param(\"n\"))))) .bindNow(); server.onDispose() .block(); } static final class CustomChannelOutboundHandler extends ChannelOutboundHandlerAdapter { static final ChannelHandler INSTANCE = new CustomChannelOutboundHandler(); @Override public boolean isSharable() { return true; } @Override public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) { try (ContextSnapshot.Scope scope = ContextSnapshotFactory.builder().build().setThreadLocalsFrom(ctx.channel())) { System.out.println(\"Current Observation in Scope: \" + OBSERVATION_REGISTRY.getCurrentObservation()); //\"FutureReturnValueIgnored\" this is deliberate ctx.write(msg, promise); } System.out.println(\"Current Observation: \" + OBSERVATION_REGISTRY.getCurrentObservation()); } } Templated URIs are used as an URI tag value when possible. Custom that uses context propagation library. This concrete example overrides only , if it is needed, the same logic can be used for the rest of the methods. Also, this concrete example sets all values for which there is a value in the given , if another behaviour is needed please check . For example, you may want to set only some of the values. When you enable Reactor Netty tracing within a framework, you may need to let Reactor Netty use the created by this framework. For this purpose you need to invoke . You may also need to configure the Reactor Netty using the API provided by the framework."
    },
    {
        "link": "https://stackoverflow.com/questions/174502/string-to-int-in-java-likely-bad-data-need-to-avoid-exceptions",
        "document": "Seeing as Java doesn't have nullable types, nor does it have a TryParse(), how do you handle input validation without throwing an exceptions?\n\nI could use a regex to check if it's parseable, but that seems like a lot of overhead as well.\n\nWhat's the best practice for handling this situation?\n\nEDIT: Rationale: There's been a lot of talk on SO about exception handling, and the general attitude is that exceptions should be used for unexpected scenarios only. However, I think bad user input is EXPECTED, not rare. Yes, it really is an academic point.\n\nSome of the answers demonstrate exactly what is wrong with SO. You ignore the question being asked, and answer another question that has nothing to do with it. The question isn't asking about transition between layers. The question isn't asking what to return if the number is un-parseable. For all you know, val = Integer.MIN_VALUE; is exactly the right option for the application that this completely context free code snippet was take from."
    },
    {
        "link": "https://stackoverflow.com/questions/16513718/parsing-user-input-getting-integers-from-strings-and-exception-handling",
        "document": "my application will have a text box which the user will edit with numbers (hopefully)\n\nI am using to convert the string into a integer, however, there's always the chance the user will not pass in numbers which will throw an exception during . I am not sure what the convention is for error handling in GWT. Does this work?"
    },
    {
        "link": "https://java-programming.mooc.fi/part-11/3-exceptions",
        "document": ""
    },
    {
        "link": "https://labex.io/tutorials/java-how-to-handle-number-parsing-errors-418186",
        "document": "Number parsing is a fundamental operation in Java programming that involves converting string representations of numbers into their corresponding numeric types. This process is crucial for handling user inputs, reading data from files, or processing external data sources.\n\nJava provides several methods for parsing numbers across different numeric types:\n\ngraph TD A[Input String] --> B{Is Valid Number?} B -->|Yes| C[Convert to Numeric Type] B -->|No| D[Throw NumberFormatException]\n• Always use try-catch blocks when parsing numbers\n• Be aware of potential overflow for different numeric types\n• Consider using for locale-specific parsing\n\nNumber parsing can be computationally expensive, especially with large volumes of data. When working with LabEx performance-critical applications, consider using more efficient parsing techniques."
    },
    {
        "link": "https://labex.io/tutorials/java-how-to-handle-java-integer-input-safely-468023",
        "document": "In Java programming, handling integer input safely is crucial for developing robust and error-resistant applications. This tutorial explores comprehensive techniques to parse, validate, and manage integer inputs, helping developers prevent common pitfalls and ensure data integrity across various input scenarios.\n\n%%%%{init: {'theme':'neutral'}}%%%% flowchart RL java((\"Java\")) -.-> java/BasicSyntaxGroup([\"Basic Syntax\"]) java((\"Java\")) -.-> java/StringManipulationGroup([\"String Manipulation\"]) java((\"Java\")) -.-> java/ProgrammingTechniquesGroup([\"Programming Techniques\"]) java((\"Java\")) -.-> java/ObjectOrientedandAdvancedConceptsGroup([\"Object-Oriented and Advanced Concepts\"]) java/BasicSyntaxGroup -.-> java/operators(\"Operators\") java/BasicSyntaxGroup -.-> java/type_casting(\"Type Casting\") java/StringManipulationGroup -.-> java/strings(\"Strings\") java/ProgrammingTechniquesGroup -.-> java/method_overloading(\"Method Overloading\") java/ObjectOrientedandAdvancedConceptsGroup -.-> java/user_input(\"User Input\") java/ObjectOrientedandAdvancedConceptsGroup -.-> java/exceptions(\"Exceptions\") subgraph Lab Skills java/operators -.-> lab-468023{{\"How to handle Java integer input safely\"}} java/type_casting -.-> lab-468023{{\"How to handle Java integer input safely\"}} java/strings -.-> lab-468023{{\"How to handle Java integer input safely\"}} java/method_overloading -.-> lab-468023{{\"How to handle Java integer input safely\"}} java/user_input -.-> lab-468023{{\"How to handle Java integer input safely\"}} java/exceptions -.-> lab-468023{{\"How to handle Java integer input safely\"}} end"
    }
]