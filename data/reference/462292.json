[
    {
        "link": "https://datacamp.com/tutorial/depth-first-search-in-python",
        "document": "Level up your data science skills by creating visualizations using Matplotlib and manipulating DataFrames with pandas."
    },
    {
        "link": "https://geeksforgeeks.org/python-program-for-depth-first-search-or-dfs-for-a-graph",
        "document": "Depth First Traversal (or DFS) for a graph is similar to Depth First Traversal of a tree. The only catch here is, that, unlike trees, graphs may contain cycles (a node may be visited twice). To avoid processing a node more than once, use a Boolean visited array. A graph can have more than one DFS traversal.\n\nNote : There can be multiple DFS traversals of a graph according to the order in which we pick adjacent vertices. Here we pick vertices as per the insertion order. Output: 1 0 2 3 4\n\nExplanation: The source vertex s is 1. We visit it first, then we visit an adjacent. \n\nStart at 1: Mark as visited. Output: 1\n\nMove to 0: Mark as visited. Output: 0 (backtrack to 1)\n\nMove to 2: Mark as visited. Output: 2 (backtrack to 0)\n\nMove to 3: Mark as visited. Output: 3 (backtrack to 2)\n\nMove to 4: Mark as visited. Output: 4 (backtrack to 2) Not that there can be more than one DFS Traversals of a Graph. For example, after 1, we may pick adjacent 2 instead of 0 and get a different DFS. Here we pick in the insertion order. Start at 0: Mark as visited. Output: 0\n\nMove to 2: Mark as visited. Output: 2\n\nMove to 4: Mark as visited. Output: 4 (backtrack to 2, then backtrack to 0)\n\nMove to 3: Mark as visited. Output: 3 (backtrack to 0)\n\nMove to 1: Mark as visited. Output: 1\n\nPython Depth First Search Algorithm is used for traversing or searching tree or graph data structures. The algorithm starts at the root node (selecting some arbitrary node as the root node in the case of a graph) and explores as far as possible along each branch before backtracking.\n\nLet us understand the working of Depth First Search with the help of the following illustration: for the source as 0.\n\nBelow is the implementation of the above approach:\n\nDFS Algorithm Time Complexity: O(V+E) where V is the number of vertices in the graph and E is the number of edges\n\nAuxiliary Space: O(V+E)\n\nPython Program for Depth First Search or DFS for a Graph – FAQs\n\nWhat is Depth First Search (DFS)?\n\nWhat is the difference between DFS and BFS?\n\nCan DFS be used for finding the shortest path?"
    },
    {
        "link": "https://favtutor.com/blogs/depth-first-search-python",
        "document": "We uphold a strict editorial policy that emphasizes factual accuracy, relevance, and impartiality. Our content is crafted by top technical writers with deep knowledge in the fields of computer science and data science, ensuring each piece is meticulously reviewed by a team of seasoned editors to guarantee compliance with the highest standards in educational content creation and publishing.\n\nTraversal means that visiting all the nodes of a graph which can be done through Depth-first search or Breadth-first search in python. Depth-first traversal or Depth-first Search is an algorithm to look at all the vertices of a graph or tree data structure. Here we will study what depth-first search in python is, understand how it works with its bfs algorithm, implementation with python code, and the corresponding output to it.\n\nWhat is Depth First Search?\n\nWhat do we do once have to solve a maze? We tend to take a route, keep going until we discover a dead end. When touching the dead end, we again come back and keep coming back till we see a path we didn't attempt before. Take that new route. Once more keep going until we discover a dead end. Take a come back again… This is exactly how Depth-First Search works.\n\nThe Depth-First Search is a recursive algorithm that uses the concept of backtracking. It involves thorough searches of all the nodes by going ahead if potential, else by backtracking. Here, the word backtrack means once you are moving forward and there are not any more nodes along the present path, you progress backward on an equivalent path to seek out nodes to traverse. All the nodes are progressing to be visited on the current path until all the unvisited nodes are traversed after which subsequent paths are going to be selected.\n\nBefore learning the python code for Depth-First and its output, let us go through the algorithm it follows for the same. The recursive method of the Depth-First Search algorithm is implemented using stack. A standard Depth-First Search implementation puts every vertex of the graph into one in all 2 categories: 1) Visited 2) Not Visited. The only purpose of this algorithm is to visit all the vertex of the graph avoiding cycles.\n\nThe DSF algorithm follows as:\n• We will start by putting any one of the graph's vertex on top of the stack.\n• After that take the top item of the stack and add it to the visited list of the vertex.\n• Next, create a list of that adjacent node of the vertex. Add the ones which aren't in the visited list of vertexes to the top of the stack.\n• Lastly, keep repeating steps 2 and 3 until the stack is empty.\n\nThe pseudocode for Depth-First Search in python goes as below: In the init() function, notice that we run the DFS function on every node because many times, a graph may contain two different disconnected part and therefore to make sure that we have visited every vertex, we can also run the DFS algorithm at every node.\n\nNow, knowing the algorithm to apply the Depth-First Search implementation in python, we will see how the source code of the program works.\n\nConsider the following graph which is implemented in the code below:\n\nIn the above code, first, we will create the graph for which we will use the depth-first search. After creation, we will create a set for storing the value of the visited nodes to keep track of the visited nodes of the graph.\n\nAfter the above process, we will declare a function with the parameters as visited nodes, the graph itself and the node respectively. And inside the function, we will check whether any node of the graph is visited or not using the “if” condition. If not, then we will print the node and add it to the visited set of nodes.\n\nThen we will go to the neighboring node of the graph and again call the DFS function to use the neighbor parameter.\n\nAt last, we will run the driver code which prints the final result of DFS by calling the DFS the first time with the starting vertex of the graph.\n\nThe output of the above code is as follow:\n\nLet us see how the DFS algorithm works with an example. Here, we will use an undirected graph with 5 vertices.\n\nWe begin from the vertex P, the DFS rule starts by putting it within the Visited list and putting all its adjacent vertices within the stack.\n\nNext, we tend to visit the part at the highest of the stack i.e. Q, and head to its adjacent nodes. Since P has already been visited, we tend to visit R instead.\n\nVertex R has the unvisited adjacent vertex in T, therefore we will be adding that to the highest of the stack and visit it.\n\nAt last, we will visit the last component S, it does not have any unvisited adjacent nodes, thus we've completed the Depth First Traversal of the graph.\n\nThe time complexity of the Depth-First Search algorithm is represented within the sort of O(V + E), where V is that the number of nodes and E is that the number of edges.\n\n\n\nThe space complexity of the algorithm is O(V).\n\nDepth-First Search Algorithm has a wide range of applications for practical purposes. Some of them are as discussed below:\n• For finding the strongly connected components of the graph\n• To test if the graph is bipartite\n• Solving the puzzle with only one solution.\n\nHence, Depth-First Search is used to traverse the graph or tree. By understanding this article, you will be able to implement Depth-First Search in python for traversing connected components and find the path."
    },
    {
        "link": "https://geeksforgeeks.org/depth-first-search-or-dfs-for-a-graph",
        "document": "Depth First Search or DFS for a Graph\n\nIn Depth First Search (or DFS) for a graph, we traverse all adjacent vertices one by one. When we traverse an adjacent vertex, we completely finish the traversal of all vertices reachable through that adjacent vertex. This is similar to a tree, where we first completely traverse the left subtree and then move to the right subtree. The key difference is that, unlike trees, graphs may contain cycles (a node may be visited more than once). To avoid processing a node multiple times, we use a boolean visited array.\n\nNote : There can be multiple DFS traversals of a graph according to the order in which we pick adjacent vertices. Here we pick vertices as per the insertion order. Output: 1 0 2 3 4\n\nExplanation: The source vertex s is 1. We visit it first, then we visit an adjacent. \n\nStart at 1: Mark as visited. Output: 1\n\nMove to 0: Mark as visited. Output: 0 (backtrack to 1)\n\nMove to 2: Mark as visited. Output: 2 (backtrack to 0)\n\nMove to 3: Mark as visited. Output: 3 (backtrack to 2)\n\nMove to 4: Mark as visited. Output: 4 (backtrack to 2) Not that there can be more than one DFS Traversals of a Graph. For example, after 1, we may pick adjacent 2 instead of 0 and get a different DFS. Here we pick in the insertion order. Start at 0: Mark as visited. Output: 0\n\nMove to 2: Mark as visited. Output: 2\n\nMove to 4: Mark as visited. Output: 4 (backtrack to 2, then backtrack to 0)\n\nMove to 3: Mark as visited. Output: 3 (backtrack to 0)\n\nMove to 1: Mark as visited. Output: 1\n\nDFS from a Given Source of Undirected Graph:\n\nThe algorithm starts from a given source and explores all reachable vertices from the given source. It is similar to Preorder Tree Traversal where we visit the root, then recur for its children. In a graph, there might be loops. So we use an extra visited array to make sure that we do not process a vertex again.\n\nLet us understand the working of Depth First Search with the help of the following illustration: for the source as 0.\n\nBelow is the implementation of the above approach:\n\n// that are not visited yet // To add an edge in an undirected graph // Traverse all adjacent vertices that are not visited yet // Function to add an edge to the adjacency list // Define the edges of the graph // Recursively visit all adjacent vertices that are // Function to add an edge to the adjacency list // Number of vertices in the graph // Create an adjacency list for the graph // Define the edges of the graph # that are not visited yet # Create an adjacency list for the graph # Define the edges of the graph // that are not visited yet // Create an adjacency list for the graph // Define the edges of the graph // Recursively visit all adjacent vertices that are not // Number of vertices in the graph // Create an adjacency list for the graph // Define the edges of the graph\n\nTime complexity: O(V + E), where V is the number of vertices and E is the number of edges in the graph.\n\nAuxiliary Space: O(V + E), since an extra visited array of size V is required, And stack size for recursive calls to DFSRec function.\n\nPlease refer Complexity Analysis of Depth First Search: for details.\n\nThe above implementation takes a source as an input and prints only those vertices that are reachable from the source and would not print all vertices in case of disconnected graph. Let us now talk about the algorithm that prints all vertices without any source and the graph maybe disconnected.\n\nThe idea is simple, instead of calling DFS for a single vertex, we call the above implemented DFS for all all non-visited vertices one by one.\n\n// Recursively visit all adjacent vertices that are not visited yet // Main DFS function to perform DFS for the entire graph // Loop through all vertices to handle disconnected graph // If vertex i has not been visited, // Create an adjacency list for the graph // Define the edges of the graph // Function to add an edge to the adjacency list // Add edge from t to s (for undirected graph) // Traverse all adjacent vertices that are not visited yet // Main DFS function to perform DFS for the entire graph // Loop through all vertices to handle disconnected graph // If vertex i has not been visited, // Define the edges of the graph // Function to add an edge to the adjacency list // Recursively visit all adjacent vertices that are // Main DFS function to perform DFS for the entire graph // Loop through all vertices to handle disconnected // Create an adjacency list for the graph // Define the edges of the graph # that are not visited yet # Loop through all vertices to handle disconnected # Define the edges of the graph // Function to add an edge to the adjacency list // that are not visited yet // Main DFS function to perform DFS for the entire graph // Loop through all vertices to handle // If vertex i has not been visited, // Create an adjacency list for the graph // Define the edges of the graph using tuples // Recursively visit all adjacent vertices that are not // Main DFS function to perform DFS for the entire graph // Loop through all vertices to handle disconnected // Create an adjacency list for the graph // Define the edges of the graph\n\nTime complexity: O(V + E). Note that the time complexity is same here because we visit every vertex at most once and every edge is traversed at most once (in directed) and twice in undirected.\n\nAuxiliary Space: O(V + E), since an extra visited array of size V is required, And stack size for recursive calls to DFSRec function.\n• None Depth First Search or DFS on Directed Graph\n• None Breadth First Search or BFS for a Graph"
    },
    {
        "link": "https://stackoverflow.com/questions/43430309/depth-first-search-dfs-code-in-python",
        "document": "I think you have an indentation problem there. Assuming your code looks like this:\n\nI would say a couple of things:\n• Avoid globals if you can\n• Instead of a list for visited, use a set\n• This will not work for forests but I assume you already know that\n• It will fail if you reference a node that does not exist."
    },
    {
        "link": "https://geeksforgeeks.org/python-dictionary",
        "document": "A Python dictionary is a data structure that stores the value in key: value pairs. Values in a dictionary can be of any data type and can be duplicated, whereas keys can’t be repeated and must be immutable.\n\nExample: Here, The data is stored in key:value pairs in dictionaries, which makes it easier to find values.\n\nIn Python, a dictionary can be created by placing a sequence of elements within curly {} braces, separated by a ‘comma’.\n• Dictionary keys are case sensitive: the same name but different cases of Key will be treated distinctly.\n• Keys must be immutable: This means keys can be strings, numbers, or tuples but not lists.\n• Keys must be unique: Duplicate keys are not allowed and any duplicate key will overwrite the previous value.\n• None . Hence, operations like search, insert, delete can be performed in Constant Time\n\nWe can access a value from a dictionary by using the key within square brackets orget()method.\n\nWe can add new key-value pairs or update existing keys by using assignment.\n\nWe can remove items from dictionary using the following methods:\n• None : Removes an item by key and returns its value.\n• None : Removes and returns the last key-value pair.\n\nWe can iterate over keys [using keys() method] , values [using values() method] or both [using item() method] with a for loop.\n\nRead in detail – Ways to Iterating Over a Dictionary\n• None Check if two arrays are equal or not\n• None Max distance between two occurrences in array\n• None Count all pairs with absolute difference equal to k\n• None Remove minimum elements such that no common elements exist in two arrays\n• None Count distinct elements in every window of size k\n\nHow to use dictionaries in Python?\n\nHow to print dictionaries in Python?\n\nHow to declare a dictionary in Python?\n\nWhat are dictionary keys and values in Python?"
    },
    {
        "link": "https://realpython.com/python-dicts",
        "document": "Python dictionaries are a powerful built-in data type that allows you to store key-value pairs for efficient data retrieval and manipulation. Learning about them is essential for developers who want to process data efficiently. In this tutorial, you’ll explore how to create dictionaries using literals and the constructor, as well as how to use Python’s operators and built-in functions to manipulate them.\n\nBy learning about Python dictionaries, you’ll be able to access values through key lookups and modify dictionary content using various methods. This knowledge will help you in data processing, configuration management, and dealing with JSON and CSV data.\n\nBy the end of this tutorial, you’ll understand that:\n• A dictionary in Python is a mutable collection of key-value pairs that allows for efficient data retrieval using unique keys.\n• Both and can create dictionaries in Python. Use for concise syntax and for dynamic creation from iterable objects.\n• is a class used to create dictionaries. However, it’s commonly called a built-in function in Python.\n• is a special attribute in Python that holds an object’s writable attributes in a dictionary.\n• Python is implemented as a hashmap, which allows for fast key lookups.\n\nTo get the most out of this tutorial, you should be familiar with basic Python syntax and concepts such as variables, loops, and built-in functions. Some experience with basic Python data types will also be helpful.\n\nDictionaries are one of Python’s most important and useful built-in data types. They provide a mutable collection of key-value pairs that lets you efficiently access and mutate values through their corresponding keys: # Access a value through its key A Python dictionary consists of a collection of key-value pairs, where each key corresponds to its associated value. In this example, is a key, and is the associated value. Dictionaries are a fundamental part of Python. You’ll find them behind core concepts like scopes and namespaces as seen with the built-in functions and : The function returns a dictionary containing key-value pairs that map names to objects that live in your current global scope. Python also uses dictionaries to support the internal implementation of classes. Consider the following demo class: The special attribute is a dictionary that maps attribute names to their corresponding values in Python classes and objects. This implementation makes attribute and method lookup fast and efficient in object-oriented code. You can use dictionaries to approach many programming tasks in your Python code. They come in handy when processing CSV and JSON files, working with databases, loading configuration files, and more. Python’s dictionaries have the following characteristics:\n• Mutable: The dictionary values can be updated in place.\n• Dynamic: Dictionaries can grow and shrink as needed.\n• Efficient: They’re implemented as hash tables, which allows for fast key lookup.\n• Ordered: Starting with Python 3.7, dictionaries keep their items in the same order they were inserted. The keys of a dictionary have a couple of restrictions. They need to be:\n• Hashable: This means that you can’t use unhashable objects like lists as dictionary keys.\n• Unique: This means that your dictionaries won’t have duplicate keys. In contrast, the values in a dictionary aren’t restricted. They can be of any Python type, including other dictionaries, which makes it possible to have nested dictionaries. It’s important to note that dictionaries are collections of pairs. So, you can’t insert a key without its corresponding value or vice versa. Since they come as a pair, you always have to insert a key with its corresponding value. Note: In some situations, you may want to add keys to a dictionary without deciding what the associated value should be. In those cases, you can use the method to create keys with a default or placeholder value. In practice, you can use a dictionary when you need an efficient and mutable data structure that maps keys to values. In the following sections, you’ll learn how to create and use dictionaries in your Python code.\n\nYou can create Python dictionaries in a couple of ways, depending on your needs. The most common way is to use dictionary literals, which are a comma-separated series of key-value pairs in curly braces. The second way is to use the constructor, which lets you create dictionaries from iterables of key-value pairs, other mappings, or a series of keyword arguments. It also lets you create empty dictionaries when you call it without arguments. In the following sections, you’ll dive deeper into how to create Python dictionaries using literals and the constructor. You can define a dictionary by enclosing a comma-separated series of key-value pairs in curly braces ( ). To separate the keys from their values, you need to use a colon ( ). Here’s the syntax for a dictionary literal: The keys and values are completely optional, which means that you can use an empty pair of curly braces to create an empty dictionary. Then, you have the keys, a colon, and the value associated with the current key. To separate the pairs, you use a comma. The keys must be hashable objects like numbers, strings, or tuples. Being hashable means they can be passed to a hash function. A hash function takes data of arbitrary size and maps it to a fixed-size value called a hash value—or just hash—which is used for table lookup and comparison. In Python, the built-in immutable data types are hashable, and the mutable types are unhashable. Note: Python sets also use curly braces to define their literals, but they enclose individual elements rather than key-value pairs. To create an empty set, you need to use instead of an empty pair of curly braces because this syntax is reserved for empty dictionaries. The following code defines a dictionary that maps cities or states to the names of their corresponding Major League Baseball (MLB) teams: You can only use hashable Python objects as dictionary keys. The following example shows a dictionary with integer, float, and Boolean objects used as keys: You can even use objects like data types and functions as keys: However, you can’t use unhashable objects as keys. If you try to, then you’ll get an error: Python lists are unhashable because any changes to their content would change their hash value, violating the requirement that hash values must remain constant for hashable types. In practice, you can’t use any mutable data type as a key in a dictionary. This means that lists, sets, and dictionaries themselves aren’t allowed. If you need to use sequences as dictionary keys, then you can use tuples because tuples are immutable: It’s important to note that even though tuples are immutable, they can contain mutable objects. You can’t use a tuple that contains mutable objects as a dictionary key: In this example, the tuple that you try to use as a dictionary key contains a list. As a result, the tuple isn’t hashable anymore, so you get an error. Duplicate keys aren’t allowed in Python’s data type. Because of this restriction, when you assign a value to an existing key, you won’t add a second instance of the key. Instead, you’ll replace the previously associated value with a new one. For example, say that a given city has a second MLB team. You may try to add the second team by assigning it to the same key: In this example, you try to add a new key-value pair for the second MLB team in Chicago. However, what happens is that you replace the old team name ( ) with the new one ( ). Similarly, if you specify a key a second time during the creation of a dictionary, the second occurrence will override the first: In this example, your dictionary ends up containing the pair because you inserted it after with the same key. Unlike dictionary keys, there are no restrictions for dictionary values. Literally none at all. A dictionary value can be any type of object, including mutable types like lists and dictionaries, as well as user-defined objects: In this example, you create a dictionary with a list, a set, an integer, and a custom object as values. All these objects work because values have no restrictions. There’s also no restriction against a particular value appearing in a dictionary multiple times: In this example, your dictionary contains multiple instances of the letter as a value. This is completely okay because values don’t have the restriction of needing to be unique. You can also build dictionaries with the constructor. The arguments to can be a series of keyword arguments, another mapping, or an iterable of key-value pairs. Here are the constructor’s signatures: If you call the constructor without arguments, then you get an empty dictionary: In most cases, you’ll use an empty pair of curly braces to create empty dictionaries. However, in some situations, using the constructor might be more explicit. If the keys of your dictionary are strings representing valid Python identifiers, then you can specify them as keyword arguments. Here’s how you’d create the dictionary with this approach: Again, to build a dictionary using keyword arguments, the keys must be strings holding valid Python names. Otherwise, they won’t work as argument names. This is a syntactical restriction of Python. You can also create a dictionary from an iterable of key-value pairs. Here’s how you can build the dictionary this way: In this example, you build the dictionary using a list of two-item tuples. The first item acts as the key, and the second is the associated value. A cool way to create dictionaries from sequences of values is to combine them with the built-in function and then call as shown below: The function takes one or more iterables as arguments and yields tuples that combine items from each iterable. Note that your original data must be stored in ordered sequences for this technique to work correctly because the order is essential. Otherwise, you can end up with a dictionary that maps keys to values incorrectly. The data type has a class method called that lets you create new dictionaries from an iterable of keys and a default value. The method’s signature looks like the following: The argument provides the keys that you want to include in your dictionary. Even though the input iterable can have duplicate items, the final dictionary will have unique keys as usual. The argument allows you to define an appropriate default value for all the keys. This argument defaults to , which can serve as a good default value in several scenarios. Here’s an example of how to create a new dictionary with the method: In this example, you create a dictionary to store an inventory of fruits. Initially, you have the list of fruits in stock but don’t have the corresponding amounts. So, you use as the default amount in the call to .\n\nPython dictionaries have several methods that you can call to perform common actions like accessing keys, values, and items. You’ll also find methods for updating and removing values. In the following sections, you’ll learn about these methods and how to use them in your Python code. To get started, you’ll learn about methods you can use to access the data stored in an existing dictionary. You’ll also learn about methods for getting a single key and retrieving all the values, keys, and pairs from a dictionary. These methods are useful in real-world Python programming. The method provides a convenient way to retrieve the value associated with a key without checking whether the key exists beforehand. The key you want to search for is the first argument to . The second argument, which is optional, is a default value that will be used if the target key doesn’t exist in the dictionary. Note that the default value of is : If the target key exists in the dictionary, then you get the corresponding value. If the key isn’t found in the dictionary and the optional argument is specified, then you get as a result. You can also provide a convenient value to : In this example, the key isn’t in the dictionary. Because of this, you get the custom default value ( ) as a result. The method returns a dictionary view object, which provides a dynamic view of the values in a dictionary: The object contains all the values in . Note that any duplicate values will be returned as many times as they occur. The method returns a dictionary view object with a dynamic view of the keys in the target dictionary: Again, the view object contains all the keys in the dictionary. Since dictionary keys are unique, you won’t get any duplicate keys. Getting All the Items or Key-Value Pairs: The method returns a dictionary view containing tuples of keys and values. The first item in each tuple is the key, while the second item is the associated value: The view object contains the key-value pairs of your dictionary as two-item tuples of the form . Python’s built-in data type also has methods for adding and updating key-value pairs. For this purpose, you have the and methods. You’ll learn about them in the following sections. The method lets you set default values to keys. If is in the dictionary, then the method returns the associated value. If isn’t in the dictionary, it’s inserted with as its associated value. Then, it returns : When you call with an existing key, you get the associated value. If the key is missing, you get —which is the value—and a new key-value pair is inserted. If the key is missing and you provide a custom value, then you get the custom and a new key-value pair. The method merges a dictionary with another dictionary or with an iterable of key-value pairs. If is a dictionary, then merges the entries from into . For each key in , you can have one of the following results:\n• If the key isn’t present in , then the key-value pair from is added to .\n• If the key is present in , then the corresponding value in is updated to the value in . Here’s an example showing two dictionaries merged together: In this example, you update the dictionary with content from the dictionary. Note how the existing keys were updated while the missing ones were added to the end of . The argument may also be a sequence of key-value pairs: Here, you pass a list of tuples as an argument to . The method updates the existing keys or adds new keys as needed. Finally, you can also call with keyword arguments: In this example, you call with keyword arguments, and the method updates the existing keys or adds new keys as needed. Removing key-value pairs is another common operation that you may need to perform on your dictionaries. To do this, the class provides a few useful methods. In the following sections, you’ll learn about these methods and how they work. The method removes key-value pairs by keys. If the key exists, then the method returns its associated value. On the other hand, if the key doesn’t exist and isn’t provided, then you get a . Otherwise, you get the value: If the target key isn’t present in the dictionary, and the optional argument is specified, then that value is returned and no exception is raised. When you want to both delete an item and retain its value, you’ll commonly use . If you just want to remove the item, then you typically go with the statement: In this example, you remove the key and its associated value without returning the value as does. The method removes a key-value pair from a dictionary. This method returns the removed pair as a tuple of the form . The pairs are removed in LIFO (last-in, first-out) order: Calling removes a key-value pair from the dictionary and returns it as a two-item tuple. The first item is the key, and the second is the value. Note that the items are removed from right to left, starting with the last item added. Note: In Python versions prior to 3.6, returned an arbitrary key-value pair because Python dictionaries were unordered before this version. If the dictionary is empty, then raises a exception: When you call on an empty dictionary, you get a because there are no items to remove. The method removes all the items from a dictionary: Calling the method on an existing dictionary will remove all the current key-value pairs from the dictionary.\n\nThere are a few Python operators you can use with dictionaries. The most notable ones are the membership, equality, and union operators. In the following sections, you’ll learn how these operators work with dictionaries by coding and running some quick examples. The membership operators and allow you to determine whether a given key, value, or item is in a dictionary, depending on the target iterable you use. Note: To learn more about membership tests, check out Python’s “in” and “not in” Operators: Check for Membership. For example, to check whether:\n• A key is in a dictionary, you can use the dictionary itself or the method to provide the target iterable\n• A value is in a dictionary, you can use the method to provide the target iterable\n• An item is in a dictionary, you can use the method to provide the target iterable To illustrate, say that you want to check whether a given city is in your dictionary. To do this, you can use the and operator with the dictionary itself or with the method: In the first membership test, you check whether Milwaukee is included in the dictionary. Because this city is in the dictionary, you get as a result. Then, you check whether Indianapolis is a member of the dictionary, which returns . In this first series of examples, you use the dictionary as the target iterable for the and operators. In the second series of examples, you use . As you can see, both techniques work the same. However, using in membership is redundant and slightly less efficient than using the dictionary directly. For an execution time comparison, click to open the collapsible section below and run the script on your computer: Run this script to test the speed of membership tests on vs : The script uses to repeat the membership tests one million times each. When you run it, you’ll see output similar to the following: You can see that while the differences are noticeable, they aren’t particularly significant. You can also use the and operators with the method to determine whether a given value is in your dictionary: In this example, you use the method to provide the target iterable for the membership test. This is how to know if a given team is in your dictionary. Finally, in some situations, you may want to know whether a key-value pair is in the target dictionary. To figure this out, you can use the membership operators with the method: Note that in this example, you use a tuple containing the key-value pair as the value to check. Then, you use the method to provide the target iterable. The equality ( ) and inequality ( ) operators also work with dictionaries. These operators disregard element order when you use them with dictionaries, which is different from what happens with lists, for example: When you compare a list using the equality operator, the result depends on both the content and the order. In contrast, when you compare two dictionaries that contain the same series of key-value pairs, the order of those pairs isn’t considered. The inequality operator when used with dictionaries doesn’t consider the order of pairs either. The union operator ( ) creates a new dictionary by merging the keys and values of two initial dictionaries. The values of the dictionary to the right of the operator take precedence when both dictionaries share keys: In this example, you merge the and dictionaries to build the final dictionary using the union operator. Note that the and keys are common to both initial dictionaries, and . After the union, the values associated with these keys in prevail. The key-value pairs that didn’t exist in are added to the end of the new dictionary. Similarly, the augmented union operator ( ) updates an existing dictionary with key-value pairs from another dictionary, mapping, or iterable of key-value pairs. Again, when the operands share keys, the values from the right-hand side operand take priority: In this new version of the dictionary, you don’t create a new dictionary for the final configuration. Instead, you update the existing dictionary with the content of using the augmented union operator. In a sense, the augmented union operator works like the method, updating an existing dictionary with the content of another.\n\nIn Python, you’ll find several built-in functions that you can use for processing or working with dictionaries. Here’s a quick summary of some of these functions: Returns if all the items in an iterable are truthy and otherwise. Returns if at least one element in the iterable is truthy and otherwise. Returns an integer representing the number of items in the input object. Returns the largest value in an iterable or series of arguments. Returns the smallest value in an iterable or series of arguments. Returns a new sorted list of the elements in the iterable. Returns the sum of a start value and the values in the input iterable from left to right. As you can see, all these functions have different goals. Also, you can use them with different dictionary components. In the following sections, you’ll learn about using these functions to process Python dictionaries. Checking for Truthy Data in Dictionaries: and To start off, say that you have a dictionary that maps products to their amounts. You want to know whether all of the products are stocked. To figure this out, you can use the function with the dictionary values as a target: In the first call to , you get because all product amounts differ from . In the second example, you get because you’re out of mangoes. You can use the function in a similar fashion. Note: To learn more about and , check out the following tutorials:\n• How to Use in Python You can use these functions with keys as well. To do this, you can use either the dictionary directly or the method. Finally, using these functions with items doesn’t make sense because the method returns non-empty tuples. Sometimes, you need to know the number of key-value pairs in an existing dictionary. The built-in function returns exactly that number: When you use a dictionary as an argument for , the function returns the number of items in the dictionary. In this example, the input dictionary has six key-value pairs, so you get 6 as a result. If you ever need to find the minimum and maximum value stored in a dictionary, then you can use the built-in and functions: In this example, you use the and functions to find the lower and higher prices with the method. You can also use the functions with dictionary keys and even with items. However, note that these functions are mostly used with numeric values. Sorting the items of a dictionary may be another common requirement. To do this, you can use the built-in function. To illustrate, say that you have a dictionary matching student names with their average grades and you want to sort the data by grades. Here’s how you can do this sorting: The function returns a list of sorted values, so you wrap its call with to build a new sorted dictionary. In the first call, you sort the items by value in ascending order. To do this, you use a function that takes a two-value tuple as an argument and returns the second item, which has an index of . In the second call to , you set the argument to so that the function returns a list of items stored in reverse order. Note: To dive deeper into sorting dictionaries, check out the Sorting a Python Dictionary: Values, Keys, and More tutorial. You can also sort the dictionary by its keys: In this example, you sort the dictionary by keys using a function that returns the first value in the input tuple. Finally, you can also use to sort the keys and values: In the first call to , you use the dictionary as an argument. This results in a list of sorted keys. Next, you use the method to get a list of sorted values. You can also use the built-in function with dictionaries. For example, you can use the function to sum up numeric dictionary values or keys. Note: To learn more about about , check out Python’s : The Pythonic Way to Sum Values. To illustrate, say that you have a dictionary containing daily sales data and want to know the average daily sales. In this scenario, you can do something like the following: In this example, you use the function to calculate the total sales. To do this, you use the method. Then, you compute the average with the help of .\n\nIterating over data collections, including dictionaries, is a common task in programming. In this sense, Python dictionaries are pretty versatile, allowing you to iterate over their keys, values, and items. Note: To learn more about dictionary iteration, check out the How to Iterate Through a Dictionary in Python tutorial. In the following sections, you’ll learn the basics of iterating over Python dictionaries and their components. To kick things off, you’ll start by iterating over dictionary keys. There are two different ways you can iterate over the keys of a dictionary. You can either use the dictionary directly, or use the method. The following examples show how to use these two approaches: In these examples, you first iterate over the keys of a dictionary using the dictionary directly in the loop header. In the second loop, you use the method to iterate over the keys. Both loops are equivalent. The second loop is more explicit and readable, but it can be less efficient than the first loop because of the additional method call. Note that in both loops, you can access the dictionary values as well: To access the values in this type of iteration, you can use the original dictionary and a key lookup operation, as shown in the highlighted line. When it comes to iterating through dictionary values, you can use the method to feed the loop. To illustrate, say that you’re working with the dictionary and need to iterate over the team names only: To iterate over the values of a dictionary, you can use the method. In this example, you iterate over the registered MLB teams one by one. Note that when you use the method, you can’t access the dictionary keys. Finally, in many cases, you’ll need to iterate over both keys and values in a Python dictionary. In this case, the recommended and most Pythonic approach is to use the method: When iterating over keys and values this way, you typically use a tuple of loop variables. The first variable will get the key, while the second will get the associated value. In this example, you have the and variables, which make the code clear and readable.\n\nIn the Python standard library, you’ll find a few dictionary-like classes that have been adapted to perform specific tasks. The most notable examples are the following: A dictionary subclass specially designed to remember the order of items, which is defined by the insertion order of keys. A dictionary subclass specially designed to provide efficient counting capabilities out of the box. All these classes and a few others are available in the module found in the Python standard library. isn’t that useful anymore because since Python 3.6, dictionaries keep their items in the same insertion order. However, you may find some interesting differences between and that can help you decide which dictionary best suits your needs. The class provides an efficient tool convenient for counting objects: In this example, you use to count the letters in a string. The resulting dictionary’s keys are the letters, while the values are the number of occurrences of each letter. Note that the items in a instance are sorted in descending order out of the box, which can be useful for building rankings. The class automatically creates a new key and generates a default value for it when you try to access or modify a missing key. To illustrate, say that you have the following data in a list of tuples: You want to create a dictionary that uses the departments as keys. Each key should map a list of people working in the department. Here’s how you can do this quickly with , which is an invaluable tool when you want to group elements together: In this example, you create a called and use a loop to iterate through your list. The line creates the keys for the departments, initializes them to an empty list if necessary, and then appends the employees to each department."
    },
    {
        "link": "https://medium.com/@madhuri15/python-mapper-dictionary-3860367cf64e",
        "document": "The dictionary is another most popular, mutable, and only mapper type of data structure in Python. The mapping type is a container that is a collection of key and value data pairs. So, we can define a dictionary as a collection of key and value pairs.\n\nDictionaries are indexed by keys rather than a range of numbers like other sequential data types(like list, tuple) of Python. We know that other containers use indexing to access values, but dictionaries are an unordered collection of data and hence do not work with indexing. But still, we can update or change the values in dictionaries since they are mutable types; using keys.\n\nKeys of dictionaries must be immutable types of Python, it can be strings, numbers, or frozen sets. Tuple can also use as keys in the dictionary only if it contains immutable types, for example tuple of numbers or strings but if a tuple contains any mutable type like a list as a value then it cannot be used as a key.\n\nDictionaries are created by placing comma-separated sets of key and value pairs in curly brackets({}). An item has a key and the corresponding value is expressed as pair, key: value.\n\nAs we know now that dictionaries do not work with indexing, therefore we can not use indexes to access the values but we can access the value by using its associated keys.\n\nWe can also use method which returns the value for a key. The difference while using method is that it returns instead of if the key is not found.\n\nYou can easily update the value of existing keys in the dictionary which is as simple as assigning a value to its associate key.\n\nSimilarly, we can add new key and value pairs.\n\nTo update a dictionary with more than one key and value pairs, you can use the method.\n\nIt takes one argument which may be another dictionary or the iterable of key-value pair. It will merge object key-value pairs into a dictionary.\n• If the key already exists in a dictionary then only the value gets an update.\n• If the key is not present then a new key-value item will add to the current dictionary.\n\nYou can delete a particular key and its associate value from the dictionary using a statement or by using dictionaries’ built-in methods like and methods.\n\nWe can remove a particular value from the dictionary using the method. If the key is present in the dictionary then it removes and returns the value of that key. Otherwise, raise if the key is not present in the dictionary.\n\nis another built-in method of a dictionary that does not take any argument, it removes and returns some arbitrary (key, value) pair as a 2-tuple; and raises Key-Error if a dictionary is empty.\n\nWe can delete a particular value from the dictionary or the entire dictionary using a statement. The will be raised if the key is not present in the dictionary.\n\nWe can remove all the items from a dictionary using method like a list.\n\nWe can iterate over a dictionary using for loop; since dictionaries are iterable objects which return a single value at a time.\n• for loop will iterate over the keys of the dictionary by default.\n• we can use the items() method of the dictionary, it returns a list of tuples of key-value pairs present in the dictionary.\n\nLike a list, we can create a dictionary using dictionary comprehension. Dictionary comprehension consists of for loop with an expression of key and value in curly brackets.\n\nIn this article, you learned some basic concepts and how to access and update the dictionaries data. Lists and Dictionaries are the most popular data structure of Python and are most frequently used by developers. As we can see, there are many similarities between lists and dictionaries. The only difference between them is the way they store data. Therefore there are different ways to manipulate data. List works with indexing, and dictionaries uses keys.\n\nI hope this article helps you to understand dictionaries and their methods. Thank you for reading."
    },
    {
        "link": "https://glinteco.com/en/post/python-dictionary-tips-tricks-and-best-practices",
        "document": "Python dictionary is a built-in data type that is used to store data in key-value pairs. Each key-value pair is called an item, and dictionaries are created by enclosing key-value pairs in curly braces {} separated by commas. Dictionaries in Python are mutable, unordered, and can have keys of any immutable data type.\n\nDictionaries are one of the most frequently used data structures in Python programming due to their flexibility and efficiency. They provide a way to access and manipulate data quickly and efficiently, making them an essential tool for developers in various fields.\n\nIn this article, we will explore some of the best practices, tips, and tricks for working with Python dictionaries. By the end of this article, you will be equipped with the knowledge to improve your Python dictionary skills and write more efficient and effective code.\n\n\n\nPython dictionaries are versatile and allow for different ways to iterate over their content.\n\nHere are some tips and tricks on how to iterate over Python dictionaries\n\n\n\n2.1 Using for loops to iterate over dictionaries\n\nA for loop can be used to iterate over a dictionary's keys and then access the corresponding values.\n\nmy_dict = {'a': 1, 'b': 2, 'c': 3}\n\n for key in my_dict:\n\n print(key, my_dict[key])\n\n \n\n # Output\n\n a 1\n\n b 2\n\n c 3\n\n\n\n 2.2 Using dictionary comprehension to iterate over dictionaries\n\nDictionary comprehension is a concise way to create a new dictionary based on an existing one. It can also be used to iterate over a dictionary and filter its items.\n\nmy_dict = {'a': 1, 'b': 2, 'c': 3}\n\n new_dict = {key: value for key, value in my_dict.items() if value % 2 == 0}\n\n print(new_dict)\n\n #Output\n\n {'b': 2}\n\n\n\n 2.3 Using the items() method to iterate over keys and values\n\nThe method returns a view object that contains tuples of the dictionary's (key, value) pairs. It can be used to iterate over both keys and values.\n\nmy_dict = {'a': 1, 'b': 2, 'c': 3}\n\n for key, value in my_dict.items():\n\n print(key, value)\n\n # Output\n\n a 1\n\n b 2\n\n c 3\n\n\n\n 2.4 Using the keys() method to iterate over keys\n\nThe method returns a view object that contains the dictionary's keys. It can be used to iterate over only the keys.\n\nmy_dict = {'a': 1, 'b': 2, 'c': 3}\n\n for key in my_dict.keys():\n\n print(key)\n\n # Output\n\n a\n\n b\n\n c\n\n\n\n 2.5 Using the values() method to iterate over values\n\nThe method returns a view object that contains the dictionary's values. It can be used to iterate over only the values.\n\nmy_dict = {'a': 1, 'b': 2, 'c': 3}\n\n for value in my_dict.values():\n\n print(value)\n\n # Output\n\n 1\n\n 2\n\n 3\n\n\n\n 2.6 Using the enumerate() function to iterate over dictionaries\n\nThe function can be used to iterate over a dictionary and return the index and the corresponding (key, value) pair.\n\nmy_dict = {'a': 1, 'b': 2, 'c': 3}\n\n for index, (key, value) in enumerate(my_dict.items()):\n\n print(index, key, value)\n\n # Output\n\n 0 a 1\n\n 1 b 2\n\n 2 c 3\n\nPython dictionaries are powerful data structures that come with several built-in methods and tricks that can help you work with them more effectively. Here are some of the most useful tricks for working with Python dictionaries\n\n\n\nIf you have two dictionaries with overlapping keys and you want to merge them, you can use the method. This method takes another dictionary as an argument and adds its key-value pairs to the original dictionary. If a key already exists in the original dictionary, its value is updated with the value from the new dictionary.\n\n\n\n 3.2 Use the get() Method to Handle Missing Keys\n\nIf you try to access a key that doesn't exist in a dictionary, you'll get a exception. To avoid this, you can use the method, which returns the value for a given key if it exists in the dictionary, and a default value if it doesn't.\n\n\n\n In this example, the method returns 0 because the key doesn't exist in the dictionary.\n\n\n\nThe method is similar to the method, but it also sets a default value for a key if it doesn't already exist in the dictionary.\n\nIn this example, the method sets the value of the key to 0 because it doesn't already exist in the dictionary.\n\n\n\nIf you have a list with duplicate values and you want to remove them, you can use the method. This method takes a list as an argument and returns a dictionary with the list values as keys and as the default value.\n\nmy_list = [1, 2, 2, 3, 3, 3]\n\n my_dict = dict.fromkeys(my_list)\n\n print(my_dict) \n\n # Output\n\n {1: None, 2: None, 3: None}\n\nIn this example, the method returns a dictionary with the unique values from .\n\n\n\n3.5 Convert Two Lists into a Dictionary with dict()\n\nIf you have two lists of equal length and you want to combine them into a dictionary, you can use the constructor with the function. The function creates an iterator that aggregates elements from each of the lists.\n\n\n\n In this example, the function creates an iterator that aggregates the elements from\n\nThe iterator is then passed to the dict() function, which converts it into a dictionary. The resulting dictionary has keys from the keys list and values from the values list. Here's an example code snippet:\n\nkeys = ['name', 'age', 'city']\n\n values = ['Joe', '25', 'New York']\n\n my_dict = dict(zip(keys, values))\n\n print(my_dict)\n\n # Output\n\n {'name': 'Joe', 'age': '25', 'city': 'New York'}\n\n\n\n This code creates a dictionary with keys 'name', 'age', and 'city', and values 'Joe', '25', and 'New York', respectively.\n\n\n\nIn addition to using the function to convert two lists into a dictionary, you can also use the function. The function takes two or more lists and returns an iterator of tuples, where each tuple contains the corresponding elements from each list.\n\nTo convert two lists into a dictionary with zip(), you simply pass the two lists to the zip() function, and then pass the resulting iterator to the dict() function.\n\n\n\n In this example, the zip() function creates an iterator that aggregates the elements from keys and values into tuples. The resulting iterator is then passed to the dict() function, which converts it into a dictionary. The resulting dictionary maps the elements from keys to the corresponding elements from values.\n\nNote that the zip() function returns an iterator of tuples, so you can also use it to create a list of tuples, or to iterate over the tuples directly.\n\n\n\nTo check if a dictionary is empty, you can use a simple if statement.\n\nmy_dict = {}\n\n if not my_dict:\n\n print(\"The dictionary is empty\")\n\n else:\n\n print(\"The dictionary is not empty\")\n\n # Output\n\n The dictionary is empty\n\nThis code initializes an empty dictionary, checks if it is empty using an if statement, and prints a message accordingly.\n\n\n\n3.8 Sort a Dictionary by Value or Key\n\nYou can sort a dictionary by either its values or keys using the sorted() function. By default, the sorted() function sorts a dictionary by its keys. However, you can use the items() method to sort a dictionary by its values. Here are some examples:\n\nmy_dict = {'a': 1, 'c': 3, 'b': 2}\n\n \n\n # Sort by key\n\n sorted_dict = {k: my_dict[k] for k in sorted(my_dict)}\n\n print(sorted_dict)\n\n \n\n # Sort by value\n\n sorted_dict = {k: v for k, v in sorted(my_dict.items(), key=lambda item: item[1])}\n\n print(sorted_dict)\n\n {'a': 1, 'b': 2, 'c': 3}\n\n {'a': 1, 'b': 2, 'c': 3}\n\n\n\n In the first example, we sort the dictionary by its keys using the sorted() function. We create a new dictionary with keys sorted in ascending order and their corresponding values.\n\nIn the second example, we sort the dictionary by its values using the sorted() function and the lambda function as a key. The lambda function specifies that the sorting should be based on the second element (value) of each item in the dictionary. We create a new dictionary with keys in the same order as the original dictionary and their corresponding values sorted in ascending order.\n\nThese are just a few examples of the various tips and tricks you can use with Python dictionaries. By using these techniques, you can write more efficient and elegant code and make the most of the powerful features offered by Python dictionaries.\n\nPython dictionaries are a powerful data structure used to store and manipulate key-value pairs. They are versatile and easy to use, making them a popular choice for storing and organizing data. In this section, we will cover some intermediate-level tips, tricks, and shortcuts for using Python dictionaries effectively.\n\nYou can create a dictionary using a list of tuples. Each tuple in the list represents a key-value pair in the dictionary.\n\nThe defaultdict class from the collections module provides a convenient way to set default values for dictionary keys. If a key is not found in the dictionary, defaultdict will return the default value instead of raising a KeyError.\n\n\n\n In this example, we set the default value to 0 using the int() function. If we try to access the value of a key that does not exist in the dictionary, the default value of 0 will be returned instead of raising a KeyError.\n\n\n\n4.3 Using Counter to count items in a dictionary\n\nThe Counter class from the collections module provides an easy way to count the frequency of items in a dictionary.\n\n\n\n In this example, we create a object from the list . The Counter object counts the frequency of each item in the list and returns a new dictionary where the keys are the original dictionary keys and the values are the counts.\n\n\n\n4.4 Using sorted() to sort a dictionary by value or key\n\nYou can use the function to sort a dictionary by value or key.\n\n\n\n In this example, we sort the dictionary by value using a lambda function as the key argument. The lambda function returns the value of each key-value pair, which is used for sorting. To sort by key, we can simply omit the lambda function.\n\n\n\n4.5 Using max() and min() to find the maximum and minimum values in a dictionary\n\nYou can use the and functions to find the maximum and minimum values in a dictionary.\n\n\n\n In this example, we find the maximum and minimum values in the dictionary using the max() and min() functions, respectively.\n\n\n\nPython provides an easy way to merge dictionaries using the . This operator allows you to combine two or more dictionaries into a single dictionary. The is also known as the \"unpacking\" operator because it unpacks the contents of a dictionary.\n\nHere is an example of how to merge two dictionaries using the ** operator:\n\n\n\n In this example, the ** operator is used to merge `dict1` and `dict2` into `merged_dict`.\n\n\n\nSometimes, you may have a dictionary with duplicate values and want to remove them. You can use the method to remove duplicates from a dictionary.\n\nHere is an example of how to remove duplicates from a dictionary using the method:\n\nd = {'a': 1, 'b': 2, 'c': 1}\n\n deduped_dict = dict.fromkeys(d)\n\n print(deduped_dict)\n\n # Output\n\n {'a': None, 'b': None, 'c': None}\n\n\n\n In this example, is used to create a new dictionary deduped_dict with the keys of the original dictionary and the values set to .\n\n\n\n4.8 Using copy() to create a copy of a dictionary\n\nIf you want to create a copy of a dictionary, you can use the method. This method returns a new dictionary with the same key-value pairs as the original dictionary.\n\nHere is an example of how to use the method to create a copy of a dictionary:\n\n\n\n In this example, the method is used to create a copy of and assign it to .\n\n\n\n4.9 Using update() to add key-value pairs to a dictionary\n\nThe method is used to add key-value pairs to a dictionary. You can pass a dictionary or an iterable of key-value pairs to the method to add them to the dictionary.\n\nHere is an example of how to use the update() method to add key-value pairs to a dictionary:\n\n\n\n In this example, the method is used to add the key-value pair to the dictionary .\n\n\n\n4.10 Using pop() to remove key-value pairs from a dictionary\n\nThe method removes and returns the value for a given key from a dictionary. If the key is not found in the dictionary, an optional default value can be provided.\n\n\n\n - key: Key to be searched and deleted from the dictionary\n\n - default: Value to be returned if the key is not found in the dictionary. If not specified and the key is not found, it raises a KeyError\n\nmy_dict = {'a': 1, 'b': 2, 'c': 3}\n\n value = my_dict.pop('b')\n\n print(value) 2\n\n print(my_dict) \n\n # Output\n\n {'a': 1, 'c': 3}\n\n\n\n In the above example, the method removes the key and returns its value 2. The updated dictionary contains only the remaining key-value pairs.\n\nIt's important to note that using pop() on an empty dictionary raises a , so it's a good idea to check if the dictionary is empty before calling the method.\n\n\n\n In this example, since the dictionary is empty, the pop() method returns the default value 'default_value'.\n\n\n\n5. Tips to Write Better Python Code with Dictionaries\n\nPython dictionaries are powerful and versatile data structures that can help you write efficient and readable code. Here are some tips to help you use dictionaries effectively and write better Python code:\n\n5.1 Use List Comprehensions Instead of Loops\n\nList comprehensions are a concise and efficient way to create lists and dictionaries in Python. They are faster and more readable than traditional for loops, and can help simplify your code.\n\n For example, instead of writing:\n\n\n\n You can use a list comprehension to achieve the same result with less code:\n\n5.2 Use Built-In Functions to Simplify Your Code\n\nPython has many built-in functions that can help you write simpler and more readable code. For example, the sum() function can be used to calculate the sum of values in a dictionary:\n\nOne common mistake when working with dictionaries is overusing them. While dictionaries can be powerful tools, they can also be overcomplicated and unnecessary for simple tasks.\n\nFor example, if you only need to store a small amount of data, it may be more efficient to use variables instead of dictionaries.\n\n# Instead of using a dictionary to store variables, simply define them\n\n name = \"Joe\"\n\n age = 25\n\n gender = \"Male\"\n\nDescriptive variable names can make your code much easier to understand and maintain. When working with dictionaries, it's important to use clear and descriptive keys to make the data more accessible.\n\n# Using descriptive keys to store data in a dictionary\n\n person = {\"name\": \"Joe\", \"age\": 25, \"gender\": \"Male\"}\n\nThe Don't Repeat Yourself (DRY) principle is a programming concept that emphasizes code reuse and reducing redundancy. When working with dictionaries, it's important to follow this principle by avoiding duplicating code or repeating yourself.\n\n# Duplicating code in a dictionary\n\n person1 = {\"name\": \"Joe\", \"age\": 25, \"gender\": \"Male\"}\n\n person2 = {\"name\": \"Jane\", \"age\": 30, \"gender\": \"Female\"}\n\n \n\n # Using a dictionary to avoid code duplication\n\n person_data = {\n\n \"Joe\": {\"age\": 25, \"gender\": \"Male\"},\n\n \"Jane\": {\"age\": 30, \"gender\": \"Female\"}\n\n }\n\n\n\n 5.6 Use the Correct Data Type for Your Data\n\nUsing the correct data type for your data can make your code more efficient and reduce errors. For example, if you're working with numerical data, it's important to use integers or floats instead of strings.\n\n# Using the correct data type for numerical data\n\n numbers = {\"one\": 1, \"two\": 2, \"three\": 3}\n\nUsing a consistent style guide can make your code more readable and maintainable. When working with dictionaries, it's important to follow a consistent style guide for key naming and formatting. For example, you could use camel case for key names and indent your code consistently.\n\nWriting readable code is essential for collaboration and maintenance. When working with dictionaries, it's important to make your code as clear and concise as possible. This can be achieved by using comments, whitespace, and descriptive variable names.\n\nIn conclusion, Python dictionaries are a crucial data structure that every programmer must master to become proficient in Python. In this article, we have covered various tips, tricks, and best practices for working with Python dictionaries, including iteration, merging, default values, sorting, and removing duplicates. We have also emphasized the importance of using descriptive variable names, avoiding overusing dictionaries, and following consistent style guides to write better Python code.\n\nBy mastering these tips and continuously learning and practicing, you can become more efficient and effective in your coding. Dictionaries are an essential part of many Python applications and can greatly improve the speed and functionality of your code. We hope that this article has provided you with valuable insights and resources to improve your Python programming skills."
    },
    {
        "link": "https://docs.python.org/3/tutorial/datastructures.html",
        "document": "This chapter describes some things you’ve learned about already in more detail, and adds some new things as well.\n\nThe list data type has some more methods. Here are all of the methods of list objects: Add an item to the end of the list. Similar to . Extend the list by appending all the items from the iterable. Similar to . Insert an item at a given position. The first argument is the index of the element before which to insert, so inserts at the front of the list, and is equivalent to . Remove the first item from the list whose value is equal to x. It raises a if there is no such item. Remove the item at the given position in the list, and return it. If no index is specified, removes and returns the last item in the list. It raises an if the list is empty or the index is outside the list range. Remove all items from the list. Similar to . Return zero-based index in the list of the first item whose value is equal to x. Raises a if there is no such item. The optional arguments start and end are interpreted as in the slice notation and are used to limit the search to a particular subsequence of the list. The returned index is computed relative to the beginning of the full sequence rather than the start argument. Return the number of times x appears in the list. Sort the items of the list in place (the arguments can be used for sort customization, see for their explanation). Reverse the elements of the list in place. Return a shallow copy of the list. Similar to . An example that uses most of the list methods: You might have noticed that methods like , or that only modify the list have no return value printed – they return the default . This is a design principle for all mutable data structures in Python. Another thing you might notice is that not all data can be sorted or compared. For instance, doesn’t sort because integers can’t be compared to strings and can’t be compared to other types. Also, there are some types that don’t have a defined ordering relation. For example, isn’t a valid comparison. The list methods make it very easy to use a list as a stack, where the last element added is the first element retrieved (“last-in, first-out”). To add an item to the top of the stack, use . To retrieve an item from the top of the stack, use without an explicit index. For example: It is also possible to use a list as a queue, where the first element added is the first element retrieved (“first-in, first-out”); however, lists are not efficient for this purpose. While appends and pops from the end of list are fast, doing inserts or pops from the beginning of a list is slow (because all of the other elements have to be shifted by one). To implement a queue, use which was designed to have fast appends and pops from both ends. For example: # The first to arrive now leaves # The second to arrive now leaves List comprehensions provide a concise way to create lists. Common applications are to make new lists where each element is the result of some operations applied to each member of another sequence or iterable, or to create a subsequence of those elements that satisfy a certain condition. For example, assume we want to create a list of squares, like: Note that this creates (or overwrites) a variable named that still exists after the loop completes. We can calculate the list of squares without any side effects using: which is more concise and readable. A list comprehension consists of brackets containing an expression followed by a clause, then zero or more or clauses. The result will be a new list resulting from evaluating the expression in the context of the and clauses which follow it. For example, this listcomp combines the elements of two lists if they are not equal: Note how the order of the and statements is the same in both these snippets. If the expression is a tuple (e.g. the in the previous example), it must be parenthesized. # create a new list with the values doubled # apply a function to all the elements # the tuple must be parenthesized, otherwise an error is raised File , line : did you forget parentheses around the comprehension target? # flatten a list using a listcomp with two 'for' List comprehensions can contain complex expressions and nested functions: The initial expression in a list comprehension can be any arbitrary expression, including another list comprehension. Consider the following example of a 3x4 matrix implemented as a list of 3 lists of length 4: The following list comprehension will transpose rows and columns: As we saw in the previous section, the inner list comprehension is evaluated in the context of the that follows it, so this example is equivalent to: which, in turn, is the same as: # the following 3 lines implement the nested listcomp In the real world, you should prefer built-in functions to complex flow statements. The function would do a great job for this use case: See Unpacking Argument Lists for details on the asterisk in this line.\n\nWe saw that lists and strings have many common properties, such as indexing and slicing operations. They are two examples of sequence data types (see Sequence Types — list, tuple, range). Since Python is an evolving language, other sequence data types may be added. There is also another standard sequence data type: the tuple. A tuple consists of a number of values separated by commas, for instance: File , line , in : # but they can contain mutable objects: As you see, on output tuples are always enclosed in parentheses, so that nested tuples are interpreted correctly; they may be input with or without surrounding parentheses, although often parentheses are necessary anyway (if the tuple is part of a larger expression). It is not possible to assign to the individual items of a tuple, however it is possible to create tuples which contain mutable objects, such as lists. Though tuples may seem similar to lists, they are often used in different situations and for different purposes. Tuples are immutable, and usually contain a heterogeneous sequence of elements that are accessed via unpacking (see later in this section) or indexing (or even by attribute in the case of ). Lists are mutable, and their elements are usually homogeneous and are accessed by iterating over the list. A special problem is the construction of tuples containing 0 or 1 items: the syntax has some extra quirks to accommodate these. Empty tuples are constructed by an empty pair of parentheses; a tuple with one item is constructed by following a value with a comma (it is not sufficient to enclose a single value in parentheses). Ugly, but effective. For example: The statement is an example of tuple packing: the values , and are packed together in a tuple. The reverse operation is also possible: This is called, appropriately enough, sequence unpacking and works for any sequence on the right-hand side. Sequence unpacking requires that there are as many variables on the left side of the equals sign as there are elements in the sequence. Note that multiple assignment is really just a combination of tuple packing and sequence unpacking.\n\nPython also includes a data type for sets. A set is an unordered collection with no duplicate elements. Basic uses include membership testing and eliminating duplicate entries. Set objects also support mathematical operations like union, intersection, difference, and symmetric difference. Curly braces or the function can be used to create sets. Note: to create an empty set you have to use , not ; the latter creates an empty dictionary, a data structure that we discuss in the next section. Here is a brief demonstration: # show that duplicates have been removed # Demonstrate set operations on unique letters from two words # letters in a but not in b # letters in a or b or both # letters in both a and b # letters in a or b but not both Similarly to list comprehensions, set comprehensions are also supported:\n\nAnother useful data type built into Python is the dictionary (see Mapping Types — dict). Dictionaries are sometimes found in other languages as “associative memories” or “associative arrays”. Unlike sequences, which are indexed by a range of numbers, dictionaries are indexed by keys, which can be any immutable type; strings and numbers can always be keys. Tuples can be used as keys if they contain only strings, numbers, or tuples; if a tuple contains any mutable object either directly or indirectly, it cannot be used as a key. You can’t use lists as keys, since lists can be modified in place using index assignments, slice assignments, or methods like and . It is best to think of a dictionary as a set of key: value pairs, with the requirement that the keys are unique (within one dictionary). A pair of braces creates an empty dictionary: . Placing a comma-separated list of key:value pairs within the braces adds initial key:value pairs to the dictionary; this is also the way dictionaries are written on output. The main operations on a dictionary are storing a value with some key and extracting the value given the key. It is also possible to delete a key:value pair with . If you store using a key that is already in use, the old value associated with that key is forgotten. It is an error to extract a value using a non-existent key. Performing on a dictionary returns a list of all the keys used in the dictionary, in insertion order (if you want it sorted, just use instead). To check whether a single key is in the dictionary, use the keyword. Here is a small example using a dictionary: The constructor builds dictionaries directly from sequences of key-value pairs: In addition, dict comprehensions can be used to create dictionaries from arbitrary key and value expressions: When the keys are simple strings, it is sometimes easier to specify pairs using keyword arguments:\n\nWhen looping through dictionaries, the key and corresponding value can be retrieved at the same time using the method. When looping through a sequence, the position index and corresponding value can be retrieved at the same time using the function. To loop over two or more sequences at the same time, the entries can be paired with the function. What is your name? It is lancelot. What is your quest? It is the holy grail. What is your favorite color? It is blue. To loop over a sequence in reverse, first specify the sequence in a forward direction and then call the function. To loop over a sequence in sorted order, use the function which returns a new sorted list while leaving the source unaltered. Using on a sequence eliminates duplicate elements. The use of in combination with over a sequence is an idiomatic way to loop over unique elements of the sequence in sorted order. It is sometimes tempting to change a list while you are looping over it; however, it is often simpler and safer to create a new list instead.\n\nThe conditions used in and statements can contain any operators, not just comparisons. The comparison operators and are membership tests that determine whether a value is in (or not in) a container. The operators and compare whether two objects are really the same object. All comparison operators have the same priority, which is lower than that of all numerical operators. Comparisons can be chained. For example, tests whether is less than and moreover equals . Comparisons may be combined using the Boolean operators and , and the outcome of a comparison (or of any other Boolean expression) may be negated with . These have lower priorities than comparison operators; between them, has the highest priority and the lowest, so that A and not B or C is equivalent to (A and (not B)) or C . As always, parentheses can be used to express the desired composition. The Boolean operators and are so-called short-circuit operators: their arguments are evaluated from left to right, and evaluation stops as soon as the outcome is determined. For example, if and are true but is false, A and B and C does not evaluate the expression . When used as a general value and not as a Boolean, the return value of a short-circuit operator is the last evaluated argument. It is possible to assign the result of a comparison or other Boolean expression to a variable. For example, Note that in Python, unlike C, assignment inside expressions must be done explicitly with the walrus operator . This avoids a common class of problems encountered in C programs: typing in an expression when was intended.\n\nSequence objects typically may be compared to other objects with the same sequence type. The comparison uses lexicographical ordering: first the first two items are compared, and if they differ this determines the outcome of the comparison; if they are equal, the next two items are compared, and so on, until either sequence is exhausted. If two items to be compared are themselves sequences of the same type, the lexicographical comparison is carried out recursively. If all items of two sequences compare equal, the sequences are considered equal. If one sequence is an initial sub-sequence of the other, the shorter sequence is the smaller (lesser) one. Lexicographical ordering for strings uses the Unicode code point number to order individual characters. Some examples of comparisons between sequences of the same type: Note that comparing objects of different types with or is legal provided that the objects have appropriate comparison methods. For example, mixed numeric types are compared according to their numeric value, so 0 equals 0.0, etc. Otherwise, rather than providing an arbitrary ordering, the interpreter will raise a exception."
    },
    {
        "link": "https://geeksforgeeks.org/dynamic-programming",
        "document": ""
    },
    {
        "link": "https://skerritt.blog/dynamic-programming",
        "document": "Dynamic programming is breaking down a problem into smaller sub-problems, solving each sub-problem and storing the solutions to each of these sub-problems in an array (or similar data structure) so each sub-problem is only calculated once.\n\nIt is both a mathematical optimisation method and a computer programming method.\n\nOptimisation problems seek the maximum or minimum solution. The general rule is that if you encounter a problem where the initial algorithm m is solved in O(2n) time, it is better solved using Dynamic Programming.\n\nRichard Bellman invented DP in the 1950s. Bellman named it Dynamic Programmingbecause at the time, RAND (his employer), disliked mathematical research and didn’t want to fund it. He named it Dynamic Programming to hide the fact he was really doing mathematical research.\n\nBellman explains the reasoning behind the term Dynamic Programming in his autobiography, Eye of the Hurricane: An Autobiography (1984, page 159). He explains:\n\nSub-problems are smaller versions of the original problem. Let’s see an example. With the equation below:\n\nWe can break this down to:\n\nOnce we solve these two smaller problems, we can add the solutions to these sub-problems to find the solution to the overall problem.\n\nNotice how these sub-problems break down the original problem into components that build up the solution. This is a small example but it illustrates the beauty of Dynamic Programming well. If we expand the problem to adding hundreds of numbers it becomes clearer why we need Dynamic Programming. Take this example:\n\nWe have 6 + 5 twice. The first time we see it, we work out 6+56+5. When we see it the second time we think to ourselves:\n\nIn Dynamic Programming we store the solution to the problem so we do not need to recalculate it. By finding the solutions for every single sub-problem, we can tackle the original problem itself.\n\n*Memoisation *is the act of storing a solution.\n\n🧠 What is Memoisation in Dynamic Programming?\n\nLet’s see why storing answers to solutions make sense. We’re going to look at a famous problem, Fibonacci sequence. This problem is normally solved in Divide and Conquer.\n\nThere are 3 main parts to divide and conquer:\n• Divide the problem into smaller sub-problems of the same type.\n• Combine - Combine all the sub-problems to create a solution to the original problem.\n\nDynamic programming has one extra step added to step 2. This is memoisation.\n\nThe Fibonacci sequence is a sequence of numbers. It’s the last number + the current number. We start at 1.\n\nIn Python, this is:\n\nIf you’re not familiar with recursion I have a blog post written for you that you should read first.\n\nLet’s calculate F(4). In an execution tree, this looks like:\n\nWe calculate F(2) twice. On bigger inputs (such as F(10)) the repetition builds up. The purpose of dynamic programming is to not calculate the same thing twice.\n\nInstead of calculating F(2) twice, we store the solution somewhere and only calculate it once.\n\nWe’ll store the solution in an array. F[2] = 1. Below is some Python code to calculate the Fibonacci sequence using Dynamic Programming.\n\nIn theory, Dynamic Programming can solve every problem. The question is then:\n\nWe should use dynamic programming for problems that are between *tractable *and *intractable *problems.\n\nTractable problems are those that can be solved in polynomial time. That’s a fancy way of saying we can solve it in a fast manner. Binary search and sorting are all fast. Intractable problems are those that run in exponential time. They’re slow. Intractable problems are those that can only be solved by brute-forcing through every single combination (NP hard).\n\nWhen we see terms like:\n\nWe know it’s an optimisation problem.\n\nDynamic Programming algorithms' proof of correctness is usually self-evident. Other algorithmic strategies are often much harder to prove correct. Thus, more error-prone.\n\nWhen we see these kinds of terms, the problem may ask for a specific number ( “find the minimum number of edit operations”) or it may ask for a result ( “find the longest common subsequence”). The latter type of problem is harder to recognize as a dynamic programming problem. If something sounds like optimisation, Dynamic Programming can solve it.\n\nImagine we’ve found a problem that’s an optimisation problem, but we’re not sure if it can be solved with Dynamic Programming. First, identify what we’re optimising for. Once we realize what we’re optimising for, we have to decide how easy it is to perform that optimisation. Sometimes, the greedy approach is enough for an optimal solution.\n\nDynamic programming takes the brute force approach. It Identifies repeated work and eliminates repetition.\n\nBefore we even start to plan the problem as a dynamic programming problem, think about what the brute-force solution might look like. Are sub-steps repeated in the brute-force solution? If so, we try to imagine the problem as a dynamic programming problem.\n\nMastering dynamic programming is all about understanding the problem. List all the inputs that can affect the answers. Once we’ve identified all the inputs and outputs, try to identify whether the problem can be broken into subproblems. If we can identify subproblems, we can probably use Dynamic Programming.\n\nThen, figure out what the recurrence is and solve it. When we’re trying to figure out the recurrence, remember that whatever recurrence we write has to help us find the answer. Sometimes the answer will be the result of the recurrence, and sometimes we will have to get the result by looking at a few results from the recurrence.\n\nDynamic Programming can solve many problems, but that does not mean there isn’t a more efficient solution out there. Solving a problem with Dynamic Programming feels like magic, but remember that dynamic programming is merely a clever brute force. Sometimes it pays off well, and sometimes it helps only a little.\n\n👩‍🏫 How to Solve Problems Using Dynamic Programming\n\n\n\nNow we have an understanding of what Dynamic programming is and how it generally works. Let’s look at to create a Dynamic Programming solution to a problem. We’re going to explore the process of Dynamic Programming using the Weighted Interval Scheduling Problem.\n\nPretend you’re the owner of a dry cleaner. You have n customers come in and give you clothes to clean. You can only clean one customer’s pile of clothes (PoC) at a time. Each pile of clothes, i, must be cleaned at some pre-determined start time sisi​ and some predetermined finish time \\(f_i\\)\n\nEach pile of clothes has an associated value, \\(v_i\\), based on how important it is to your business. For example, some customers may pay more to have their clothes cleaned faster. Or some may be repeating customers and you want them to be happy.\n\nAs the owner of this dry cleaner, you must determine the optimal schedule of clothes that maximises the total value of this day. This problem is a re-wording of the Weighted Interval scheduling problem.\n\nYou will now see 4 steps to solving a Dynamic Programming problem. Sometimes, you can skip a step. Sometimes, your problem is already well-defined and you don’t need to worry about the first few steps.\n• What is the problem?\n• What are the sub-problems?\n• What would the solution roughly look like?\n\nIn the dry cleaner problem, let’s put down into words the subproblems. What we want to determine is the maximum value schedule for each pile of clothes such that the clothes are sorted by start time.\n\nWhy sort by start time? Good question! We want to keep track of processes which are currently running. If we sort by finish time, it doesn’t make much sense in our heads. We could have 2 with similar finish times, but different start times. Time moves in a linear fashion, from start to finish. If we have piles of clothes that start at 1 pm, we know to put them on when it reaches 1pm. If we have a pile of clothes that finishes at 3 pm, we might need to put them on at 12 pm, but it’s 1pm now.\n\nWe can find the maximum value schedule for piles \\(n-1\\) through to n. And then for \\(n-2\\) through to n. And so on. By finding the solution to every single sub-problem, we can tackle the original problem itself. The maximum value schedule for piles 1 through n. Sub-problems can be used to solve the original problem since they are smaller versions of the original problem.\n\nWith the interval scheduling problem, the only way we can solve it is by brute-forcing all subsets of the problem until we find an optimal one. What we’re saying is that instead of brute-forcing one by one, we divide it up. We brute force from \\(n−1\\)through to n. Then we do the same for \\(n−2\\) through to n. Finally, we have loads of smaller problems, which we can solve dynamically. We want to build the solutions to our sub-problems such that each sub-problem builds on the previous problems.\n\nI know, mathematics sucks. If you’ll bare with me here you’ll find that this isn’t that hard. Mathematical recurrences are used to:\n\nRecurrences are also used to define problems. If it’s difficult to turn your subproblems into maths, then it may be the wrong subproblem.\n\nThere are 2 steps to creating a mathematical recurrence:\n\nBase cases are the smallest possible denomination of a problem.\n\nWhen creating a recurrence, ask yourself these questions:\n\nIt doesn’t have to be 0. The base case is the smallest possible denomination of a problem. We saw this with the Fibonacci sequence. The base was:\n\nIt’s important to know where the base case lies, so we can create the recurrence. In our problem, we have one decision to make:\n• Put that pile of clothes on to be washed\n\nIf n is 0, that is, if we have 0 PoC then we do nothing. Our base case is:\n\n2: What Decision Do I Make at Step n?\n\nNow we know what the base case is, if we’re at step n what do we do? For each pile of clothes that is compatible with the schedule so far. Compatible means that the start time is after the finish time of the pile of clothes currently being washed. The algorithm has 2 options:\n\nWe know what happens at the base case, and what happens else. We now need to find out what information the algorithm needs to go backwards (or forwards).\n\nTo decide between the two options, the algorithm needs to know the next compatible PoC (pile of clothes). The next compatible PoC for a given pile, p, is the PoC, n, such that \\(s_{n}\\) ​(the start time for PoC n) happens after \\(f_{p}\\)​ (the finish time for PoC p). The difference between \\(s_{n}\\)​ and \\(f_p\\) should be minimised.\n\nIn English, imagine we have one washing machine. We put in a pile of clothes at 13:00. Our next pile of clothes starts at 13:01. We can’t open the washing machine and put in the one that starts at 13:00. Our next compatible pile of clothes is the one that starts after the finish time of the one currently being washed.\n\nThe algorithm needs to know about future decisions. The ones made for PoC i through n to decide whether to run or not run PoC i-1.\n\nNow that we’ve answered these questions, we’ve started to form a recurring mathematical decision in our minds. If not, that’s also okay, it becomes easier to write recurrences as we get exposed to more problems.\n\nLet’s explore in detail what makes this mathematical recurrence. OPT(i) represents the maximum value schedule for PoC i through to n such that PoC is sorted by start times. OPT(i) is our subproblem from earlier.\n\nWe start with the base case. All recurrences need somewhere to stop. If we call OPT(0) we’ll be returned with 0.\n\nTo determine the value of OPT(i), there are two options. We want to take the maximum of these options to meet our goal. Our goal is the maximum value schedule for all piles of clothes. Once we choose the option that gives the maximum result at step i, we memoize its value as OPT(i).\n\nMathematically, the two options - run or not run PoC i, are represented as:\n\n$$v_i + OPT(next[n])$$ \n\n\n\nThis represents the decision to run PoC i. It adds the value gained from PoC i to OPT(next[n]), where next[n] represents the next compatible pile of clothing following PoC i. When we add these two values together, we get the maximum value schedule from i through to n such that they are sorted by start time if i runs.\n\nSorted by start time here because next[n] is the one immediately after \\(v_i\\), so by default, they are sorted by start time.\n\nIf we decide not to run i, our value is then OPT(i + 1). The value is not gained. OPT(i + 1) gives the maximum value schedule for i+1 through to n, such that they are sorted by start times.\n\n3. Determine the Dimensions of the Memoisation Array and the Direction in Which It Should Be Filled\n\nThe solution to our Dynamic Programming problem is OPT(1). We can write out the solution as the maximum value schedule for PoC 1 through n such that PoC is sorted by start time. This goes hand in hand with the “maximum value schedule for PoC i through to n”.\n\nGoing back to our Fibonacci numbers earlier, our Dynamic Programming solution relied on the fact that the Fibonacci numbers for 0 through to n - 1 were already memoised. That is, to find F(5) we already memoised F(0), F(1), F(2), F(3), F(4). We want to do the same thing here.\n\nThe problem we have is figuring out how to fill out a memoisation table. In the scheduling problem, we know that OPT(1) relies on the solutions to OPT(2) and OPT(next[1]). PoC 2 and next[1] have start times after PoC 1 due to sorting. We need to fill our memoisation table from OPT(n) to OPT(1).\n\nWe can see our array is one-dimensional, from 1 to n. But, if we couldn’t see that we can work it out another way. The dimensions of the array are equal to the number and size of the variables on which OPT(x) relies. In our algorithm, we have OPT(i) - one variable, i. This means our array will be 1-dimensional and its size will be n, as there are n piles of clothes.\n\nIf we know that n = 5, then our memoisation array might look like this:\n\n0 is also the base case. memo[0] = 0, per our recurrence from earlier.\n\nWhen I am coding a Dynamic Programming solution, I like to read the recurrence and try to recreate it. Our first step is to initialise the array to size (n + 1). In Python, we don’t need to do this. But you may need to do it if you’re using a different language.\n\nOur second step is to set the base case.\n\nTo find the profit with the inclusion of job[i]. we need to find the latest job that doesn’t conflict with job[i]. The idea is to use Binary Search to find the latest non-conflicting job. I’ve copied the code from here but edited it.\n\nFirst, let’s define what a “job” is. As we saw, a job consists of 3 things:\n\nStart time, finish time, and the total profit (benefit) of running that job.\n\nThe next step we want to program is the schedule.\n\nEarlier, we learnt that the table is 1 dimensional. We sort the jobs by start time, create this empty table and set table[0] to be the profit of job[0]. Since we’ve sorted by start times, the first compatible job is always job[0].\n\nOur next step is to fill in the entries using the recurrence we learnt earlier. To find the next compatible job, we’re using Binary Search. In the full code posted later, it’ll include this. For now, let’s worry about understanding the algorithm.\n\nIf the next compatible job returns -1, that means that all jobs before the index, i, conflict with it (so cannot be used). means we’re including that item in the maximum value set. We then store it in table[i], so we can use this calculation again later.\n\nOur final step is then to return the profit of all items up to n-1.\n\nThe full code can be seen below:\n\nCongrats! 🥳 We’ve just written our first dynamic program! Now that we’ve wet our feet, let’s walk through a different type of dynamic programming problem.\n\nImagine you are a criminal. Dastardly smart. You break into Bill Gates’s mansion. Wow, okay!?!? How many rooms is this? His washing machine room is larger than my entire house??? Ok, time to stop getting distracted. You brought a small bag with you. A knapsack - if you will.\n\nYou can only fit so much into it. Let’s give this an arbitrary number. The bag will support weight 15, but no more. What we want to do is maximise how much money we’ll make, b.\n\nThe greedy approach is to pick the item with the highest value which can fit into the bag. Let’s try that. We’re going to steal Bill Gates’s TV. £4000? Nice. But his TV weighs 15. So… We leave with £4000.\n\nBill Gates has a lot of watches. Let’s say he has 2 watches. Each watch weighs 5 and each one is worth £2250. When we steal both, we get £4500 with a weight of 10.\n\nIn the greedy approach, we wouldn’t choose these watches first. But to us as humans, it makes sense to go for smaller items which have higher values. The Greedy approach cannot optimally solve the {0,1} Knapsack problem. The {0, 1} means we either take the item whole item {1} or we don’t {0}. However, Dynamic programming can optimally solve the {0, 1} knapsack problem.\n\nThe simple solution to this problem is to consider all the subsets of all items. For every single combination of Bill Gates’s stuff, we calculate the total weight and value of this combination.\n\nOnly those with a weight less than \\(w_{max}\\)​ are considered. We then pick the combination which has the highest value. This is a disaster! How long would this take? Bill Gates would come back home far before you’re even 1/3rd of the way there! In Big O, this algorithm takes O(n2) time.\n\nYou can see we already have a rough idea of the solution and what the problem is, without having to write it down in maths!\n\nImagine we had a listing of every single thing in Bill Gates’s house. We stole it from some insurance papers. Now, think about the future. What is the optimal solution to this problem?\n\nWe have a subset, L, which is the optimal solution. L is a subset of S, the set containing all of Bill Gates’s stuff.\n\nLet’s pick a random item, N. L either contains N or it doesn’t. If it doesn’t use N, the optimal solution for the problem is the same as 1,2,…,N−1. This is assuming that Bill Gates’s stuff is sorted by value/weight.\n\nSuppose that the optimum of the original problem is not the optimum of the sub-problem. if we have a sub-optimum of the smaller problem then we have a contradiction - we should have an optimum of the whole problem.\n\nIf L contains N, then the optimal solution for the problem is the same as 1,2,3,…,N−1. We know the item is in, so L already contains N. To complete the computation we focus on the remaining items. We find the optimal solution to the remaining items.\n\nBut, we now have a new maximum allowed weight of \\(W_{max} - W_n\\). If item N is contained in the solution, the total weight is now the max weight take away item N (which is already in the knapsack).\n\nThese are the 2 cases. Either item N is in the optimal solution or it isn’t.\n\nIf the weight of item N is greater than \\(W_{max}\\)​, then it cannot be included so case 1 is the only possibility.\n\nTo better define this recursive solution, let \\(S_k =1,2,…,k\\) and \\(S_0 ​= ∅\\)\n\nLet B[k, w] be the maximum total benefit obtained using a subset of \\(S_{k}\\). Having total weight at most w.\n\nThen we define B[0, w] = 0 for each \\(w \\le W_{max}\\).\n\nOur desired solution is then B[n, \\(W_{max}\\)].\n\nOkay, pull out some pen and paper. No, really. Things are about to get confusing really fast. This memoisation table is 2-dimensional. We have these items:\n\nWhere the tuples are .\n\nWe have 2 variables, so our array is 2-dimensional. The first dimension is from 0 to 7. Our second dimension is the values.\n\nAnd we want a weight of 7 with maximum benefit.\n\nThe weight is 7. We start counting at 0. We put each tuple on the left-hand side. Ok. Now fill out the table!\n\nThe columns are weight. At weight 0, we have a total weight of 0. At weight 1, we have a total weight of 1. Obvious, I know. But this is an important distinction to make which will be useful later on.\n\nWhen our weight is 0, we can’t carry anything no matter what. The total weight of everything at 0 is 0.\n\nIf our total weight is 1, the best item we can take is (1, 1). As we go down through this array, we can take more items. At the row for (4, 3) we can either take (1, 1) or (4, 3). But for now, we can only take (1, 1). Our maximum benefit for this row then is 1.\n\nIf our total weight is 2, the best we can do is 1. We only have 1 of each item. We cannot duplicate items. So no matter where we are in row 1, the absolute best we can do is (1, 1).\n\nLet’s start using (4, 3) now. If the total weight is 1, but the weight of (4, 3) is 3 we cannot take the item yet until we have a weight of at least 3.\n\nNow we have a weight of 3. Let’s compare some things. We want to take the max of:\n\nIf we’re at 2, 3 we can either take the value from the last row or use the item on that row. We go up one row and count back 3 (since the weight of this item is 3).\n\nActually, the formula is whatever weight is remaining when we minus the weight of the item on that row. The weight of (4, 3) is 3 and we’re at weight 3. 3−3=03−3=0. Therefore, we’re at . .\n\nThe 1 is because of the previous item. The max here is 4.\n\n\n\nThe total weight is 4, the item weight is 3. 4 - 3 = 1. The previous row is 0. .\n\n\n\nI won’t bore you with the rest of this row, as nothing exciting happens. We have 2 items. And we’ve used both of them to make 5. Since there are no new items, the maximum value is 5.\n\nOnto our next row:\n\nHere’s a little secret. Our tuples are ordered by weight! That means that we can fill in the previous rows of data up to the next weight point. We know that 4 is already the maximum, so we can fill in the rest.. This is where memoisation comes into play! We already have the data, why bother re-calculating it?\n\nWe go up one row and head 4 steps back. That gives us:\n\nNow we calculate it for total weight 5.\n\nWe do the same thing again:\n\nNow we have total weight 7. We choose the max of:\n\nIf we had a total weight of 7 and we had the 3 items (1, 1), (4, 3), (5, 4) the best we can do is 9.\n\nSince our new item starts at weight 5, we can copy from the previous row until we get to weight 5.\n\nWe then do another max.\n\nTotal weight - new item’s weight. This is 5−5=0. We want the previous row at position 0.\n\nThe 6 comes from the best on the previous row for that total weight.\n\n9 is the maximum value we can get by picking items from the set of items such that the total weight is≤7≤7.\n\nFinding the Optimal Set for {0, 1} Knapsack Problem Using Dynamic Programming\n\nNow, what items do we actually pick for the optimal set? We start with this item:\n\nWe want to know where the 9 comes from. It's coming from the top because the number directly above 9 on the 4th row is 9. Since it's coming from the top, the item (7, 5) is not used in the optimal set.\n\nWhere does this 9 come from?\n\nThis 9 is not coming from the row above it. **Item (5, 4) must be in the optimal set.**\n\nWe now go up one row and go back 4 steps. 4 steps because the item, (5, 4), has weight 4.\n\n4 does not come from the row above. The item (4, 3) must be in the optimal set.\n\nThe weight of item (4, 3) is 3. We go up and we go back 3 steps and reach:\n\nAs soon as we reach a point where the weight is 0, we're done. Our two selected items are (5, 4) and (4, 3). The total weight is 7 and our total benefit is 9. We add the two tuples together to find this out.\n\nNow we know how it works, and we’ve derived the recurrence for it - it shouldn’t be too hard to code it. If our two-dimensional array is i (row) and j (column) then we have:\n\nIf our weight j is less than the weight of item i (i does not contribute to j) then:\n\nThis is what the core heart of the program does. I’ve copied some code from here to help explain this. I’m not going to explain this code much, as there isn’t much more to it than what I’ve already explained. If you’re confused by it, leave a comment below or email me 😁\n\nTime complexity is calculated in Dynamic Programming as:\n\n$$Number \\; of \\; unique \\; states * time \\; taken \\; per \\; state$$\n\nFor our original problem, the Weighted Interval Scheduling Problem, we had n piles of clothes. Each pile of clothes is solved in constant time. The time complexity is:\n\nI’ve written a post about Big O notation if you want to learn more about time complexities.\n\nWith our Knapsack problem, we had n number of items. The table grows depending on the total capacity of the knapsack, our time complexity is:\n\nWhere n is the number of items, and w is the capacity of the knapsack.\n\nI’m going to let you in on a little secret. It’s possible to work out the time complexity of an algorithm from its recurrence. You can use something called the Master Theorem to work it out. This is the theorem in a nutshell:\n\nNow, I’ll be honest. The master theorem deserves a blog post of its own. For now, I’ve found this video to be excellent:\n\nDynamic Programming & Divide and Conquer are similar. Dynamic Programming is based on Divide and Conquer, except we memoise the results.\n\nBut, Greedy is different. It aims to optimise by making the best choice at that moment. Sometimes, this doesn’t optimise the whole problem. Take this question as an example. We have 3 coins:\n\nAnd someone wants us to give a change of 30p. With Greedy, it would select 25, then 5 * 1 for a total of 6 coins. The optimal solution is 2 * 15. Greedy works from largest to smallest. At the point where it was at 25, the best choice would be to pick 25.\n\nThere are 2 types of dynamic programming. Tabulation and Memoisation.\n\nWe’ve computed all the subproblems but have no idea what the optimal evaluation order is. We would then perform a recursive call from the root and hope we get close to the optimal solution or obtain proof that we will arrive at the optimal solution. Memoisation ensures you never recompute a subproblem because we cache the results, thus duplicate sub-trees are not recomputed.\n\nFrom our Fibonacci sequence earlier, we start at the root node. The subtree F(2) isn’t calculated twice.\n\nThis starts at the top of the tree and evaluates the subproblems from the leaves/subtrees back up towards the root. Memoisation is a top-down approach.\n\nWe’ve also seen Dynamic Programming being used as a ‘table-filling’ algorithm. Usually, this table is multi-dimensional. This is like memoisation but with one major difference. We have to pick the exact order in which we will do our computations. The knapsack problem we saw, we filled in the table from left to right - top to bottom. We knew the exact order in which to fill the table.\n\nSometimes the ‘table’ is not like the tables we’ve seen. It can be a more complicated structure such as trees. Or specific to the problem domain, such as cities within flying distance on a map.\n\nGenerally speaking, memoisation is easier to code than tabulation. We can write a ‘memoriser’ wrapper function that automatically does it for us. With tabulation, we have to come up with an order.\n\nMemoisation has memory concerns. If we’re computing something large such as F(10^8), each computation will be delayed as we have to place them into the array. And the array will grow in size very quickly.\n\nEither approach may not be time-optimal if the order we happen to visit subproblems is not optimal. If there is more than one way to calculate a subproblem (normally caching would resolve this, but it’s theoretically possible that caching might not in some exotic cases). Memoisation will usually add on our time complexity to our space complexity. For example, with tabulation we have more liberty to throw away calculations, like using tabulation with Fib lets us use O(1) space, but memoisation with Fib uses O(N) stack space).\n\nMost of the problems you’ll encounter within Dynamic Programming already exist in one shape or another. Often, your problem will build on from the answers for previous problems. Here’s a list of common problems that use Dynamic Programming.\n\nI hope that whenever you encounter a problem, you think to yourself “can this problem be solved with ?” and try it."
    },
    {
        "link": "https://favtutor.com/blogs/dynamic-programming",
        "document": "We uphold a strict editorial policy that emphasizes factual accuracy, relevance, and impartiality. Our content is crafted by top technical writers with deep knowledge in the fields of computer science and data science, ensuring each piece is meticulously reviewed by a team of seasoned editors to guarantee compliance with the highest standards in educational content creation and publishing.\n\nIn this article, you will learn what Dynamic Programming is, the approach to solving problems using it, the principle of optimality, and how you can solve dynamic programming along with its characteristics and elements. We will also go through the 10 most important dynamic programming problems in Python. So, let's get started!\n\nJust like the divide and conquer algorithm, Dynamic Programming solves problems by combining the solutions with sub-problems.\n\nDivide and conquer algorithms partition the problem into independent sub-problems to solve the sub-problems recursively and then combine their solutions to solve the original problem. In contrast, dynamic programming is applicable when the sub-problem is not independent, that is when sub-problems share sub-problems.\n\nTherefore, a dynamic programming algorithm solves every sub-problem just once and then saves its answers in a table, thereby avoiding the work of recomputing the answer every time the subproblem is encountered.\n\nThe development of a dynamic programming algorithm can be broken into a sequence of four steps:\n• Characterize the structure of an optimal solution\n• Recursively define the value of the optimal solution\n• Compute the value of an optimal solution in a bottom-up fashion\n\nDynamic programming algorithm is designed in a way to optimize the given problem to get output by combining the solutions of sub-problems and appearing to the “principle of optimality”.\n\nWhat is the Principle of Optimality?\n\nThe dynamic programming algorithm obtains the solution using the principle of optimality. The principle of optimality states that “ in an optimal sequence of decisions or choices, each subsequence must also be optimal”. When it is not possible to apply the principle of optimality it is almost impossible to obtain the solution using the dynamic programming approach.\n\nThe principle of optimality: “If k is a node on the shortest path from i to j, then the part of the path from i to k, and the part from k to i, must also be optimal.”\n\nAfter knowing what dynamic programming is, it is important to learn the recipe for solving dynamic programming problems. When it comes to finding the solution to the problem using dynamic programming, below are the few steps you should consider to follow:\n\nIdentifying that the given problem statement can be solved by a dynamic programming algorithm is the most crucial step. You can solve this difficulty by asking yourself whether you can divide the given problem statements into smaller parts as a function and find its solution or not.\n\nAfter deciding that the problem can be solved using dynamic programming, the next thing you have to do is to find the recursive structure between the subproblems of the original problem. Here, you have to consider the changing parameters of the problem. This changing parameter can be anything like the array position or the speed of the problem-solving.\n\nAlso, it is important to identify the number of subproblems of the original problem.\n\nMany developers rush through the coding part of problem-solving and forget to define the recurrence relation. Expressing the recurrence relation clearly before coding the problem will strengthen your problem understanding and make the process efficient.\n\nThe case is a part of the subproblem which is independent of other subproblems. In order to define the base case of your subproblem, you have to identify the point at which your problem cannot be simplified further.\n\nDynamic programming problems can be solved using an iterative or recursive approach. By the discussion till now, you must assume that the recursive process is better. But it is important to know that all the above points we discussed are completely independent of the problem-solving approach.\n\nWhether you choose the iterative method or the recursive method, it is important for you to decide the recurrence relation and the base case of the problem.\n\nMemoization is the process of storing the result of the subproblem and calling them again when a similar subproblem is to be solved. This will reduce the time complexity of the problem. If we do not use memorization, similar subproblems are repeatedly solved which can lead to exponential time complexities.\n\nBefore applying the dynamic programming approach to a problem statement, it is important to know that when to apply a dynamic programming algorithm. Let us understand 2 characteristics of the dynamic problem which explain the working while solving the problem statement.\n\nThe problem gives the optimal substructure if the optimal solution contains optimal sub-solutions in it. We can recursively define the optimal solution if the problem has an optimal substructure. Also, there is no base to define a recursive algorithm if the problem doesn’t have an optimal solution.\n\nThe problem is called overlapping subproblems if the recursive algorithm repeatedly visits the same sub-problems. If any problem has overlapping subproblems then we can improve the repetitive implementation of sub-problems by computing it only once. If the problem doesn’t have overlapping subproblems, then it is not feasible to use a dynamic programming algorithm to solve the problem.\n\nAs you have understood, dynamic programming is the algorithm that divides the problem into various sub-problems to find out the optimal solution. While solving the problem statement using the dynamic programming approach, the problem is divided into 3 elements in total to get the final result. These elements are:\n• Substructure: Sub-Structuring is the process of dividing the given problem statement into smaller sub-problems. Here we manage to identify the solution of the original problem in terms of the solution of sub-problems.\n• Table Structure: It is necessary to store the solution of the sub-problem into a table after solving it. This is important because as we know, dynamic programming reuse the solutions of subproblems many times so that we don’t have to repeatedly solve the same problem, again and again,\n• Bottom-up approach: The process of combining the solutions of subproblems to achieve the final result using the table. The process starts with solving the smallest subproblem and later combining their solution with the subproblems of increasing size until you get the final solution of the original problem.\n\nThere are many problem statements that are solved using a dynamic programming approach to find the optimal solution. Some of the most commonly asked well-known problem statements are discussed below with a brief explanation and their corresponding Python code.\n\nHere, you are given the profits and weights of N items, and you have to put these items in a knapsack with the capacity ‘W’, and you have to find the number of items to be selected such that it is less than or equal to the knapsack capacity.\n\nThe knapsack problem is the perfect example of a dynamic programming algorithm and the most commonly asked question in a technical interview of product-based companies.\n\nProblem Statement: Given a bag with capacity W and a list of items along with their weights and profit associated with them. The task is to fill the bad efficiently such that max profit is achieved.\n\nSolution: Here, you will create a table dp[][] and consider all possible weights from 1 to W as columns and weights that you can choose as rows. The state /cell dp[i][j] in the table represents the maximum attainable profit if 'j' is the capacity of the knapsack and the first 'i' elements are included in the weight/ item array.\n\nThus the last cell will represent the answer state. Items can only be included if their weight is less than the capacity of the knapsack. There are two possibilities for the condition where you can fill all columns which have ‘weight>wt[i-1]’. Check out these two possibilities in detail as shown in the below problem logic:\n\nThe running time complexity of the 0/1 Knapsack problem is O(N*W) where N is the number of items given and W is the capacity of the Knapsack.\n\nYou are given a bag with the capacity K and a list of items with specified weight and profit that are to be inserted such that you get the maximum profit. Here we will try to solve the problem using memoization rather than tabulation.\n\nThe difference between both the 0/1 knapsack problem is that the above problem used the bottom-up approach to find the solution whereas this problem uses a top-down approach using memoization to get the output of the problem.\n\nThe reason to use memoization is that it helps to reduce the overlapping of subproblems in dynamic programming. Therefore, it reduces the problem of repeatedly solving the sub-problem and makes the process getting output faster and more effective.\n\nProblem Statement: Given a bag with capacity W and a list of items along with their weights and profit associated with them. The task is to fill the bag efficiently such that max profit is achieved.\n\nSolution: Firstly, you have to create a 2D array to store the results of all the subproblems which are solved. The columns of the table will display all possible weights from 1..W dividing it into W parts and rows displaying the weights you choose at any given moment.\n\nEvery time we solve a subproblem we store it in a dp array. Whenever we encounter the same subproblem we simply return the solution rather than solving it again.\n\nThe running time complexity of the problem is O(N*W) where N is the number of items present and W is the capacity of the knapsack.\n\nThe subset sum problem is the most frequently asked question in technical interviews with Microsoft and Infosys. The subset sum problem is the problem of finding the subset of the given set of numbers where the sum of the elements of the subset found is equal to the target number.\n\nProblem statement: You are given an array and target. You have to find if there exists any subset that will sum equal to the target.\n\nSolution: Here you will create a 2D array of size (arra.size()+1)*(target+1) of boolean type. Later, you will set the value of each state dp[i][j] true if a subset of elements arr[0...i] exists with the sum value to be 'j' where j is the target number.\n\nThe time complexity of the above problem is O(target sum*n), where n is the size of the array.\n\nThe equal subset problem uses dynamic programming to find the partition of the given set such that the sum of elements of both subsets is the same. The equal subset problem is also known as the partition problem and is a very good example of a dynamic programming algorithm.\n\nProblem Statement: Given an array arr. You have to divide the array into halves such that the sum of the two subsets is equal.\n\nSolution: You have to create a 2D array of size (sum/2+1)*(target+1). Here, you can store the output for every subset and every sum and then retrieve the output while partitioning the original array. The first dimension in the 2D array will represent the different possibilities of subset and the second dimension will represent the different possibilities of sum using the combinations of subsets.\n\nThe running time complexity of the above code is O(target*n) where the target is the ‘target sum’ and n is the length of the array\n\nThe longest common subsequence problem is the most commonly asked question in Google Interview. Here the problem involves finding the longest subsequence that is present in the two given strings in the same order. Therefore, the output should be the longest sequence that can be obtained by deleting some items from the first and second original strings.\n\nProblem Statement: You are given two strings s1 and s2, of length l1 and l2, respectively. You have to find the length of the longest common subsequence of s1 and s2.\n\nSolution: This problem differs from the Longest Common Substring problem as in substrings, sequences are not necessary to occupy consecutive positions within the original string. Solving this problem using a dynamic programming approach will reduce the number of function calls to find the common sequence.\n\nUsing dynamic programming, you have to generate a table dp(1..m, 1…n) where m is the length of string s1 and n is the length of string s2.\n\nAt any instance, if the characters of two strings match then you increment the value from the previous subproblem else you look for an answer by taking the maximum from two subproblems created by decrement either string by one i.e., looking for characters other than unmatched characters.\n\nProblem Logic to generate the table dp[i][j] as shown below where i and j represent the row and column of the table.\n\nThe time complexity of the above problem is O(m*n), where m is the length of s1 and n is the length of s2.\n\nThe longest common substring problem is the problem of finding the longest string which is also the substring of two different strings. Sounds confusing? Let's look forward and understand it in detail.\n\nProblem Statement: You are given the strings s1 and s2. You have to find the length of the longest common substring of s1 and s2.\n\nSolution: Here you can start checking all substrings from the first string s1 with the character of the second string s2 and keep a record of the maximum. You can solve this problem using dynamic programming by following the bottom-up manner.\n\nCreate a matrix of size len(s1)*len(s2) and store the value of the solutions of the substrings to use later to solve similar subproblems. The problem is similar to the Longest Common Subsequence problem with the only difference that if the characters do not match then the answer at that instance becomes 0.\n\nThe running time complexity of the above problem is O(m*n), where m is the length of s1 and n is the length of s2.\n\nThe largest palindromic sequence problem finds the characters of the sequence from the given string, which are palindromic in nature. It is the sequence of characters that are read and spelled in the same way from forward and backward. Unlike the longest palindromic substring problem, the sequences may or may not occupy consecutive positions within the original string.\n\nProblem Statement: Given a string ‘S’. The task is to find the length of the largest palindromic sequence.\n\nSolution: Here, the problem shows the characteristics of the dynamic programming approach i.e., optimal substructure and overlapping subproblems. The problem shows a direct resemblance with the Longest Common Substring problem. But How?? You are given only one string!\n\nEven though you are given only a string, by close observation we find that the Longest Palindromic Subsequence is actually the Longest Common Substring between the string and its reverse.\n\nThe time complexity of the above problem is O(2^n), where n is the length of the given string.\n\nThe longest Repeating subsequence serves as the best example of a dynamic programming problem. The problem gets the output of the longest sequence of characters from the given string which is repeated irrespective of the order of the string\n\nProblem Statement: Given a string s. Find the length of the largest repeating subsequence in it.\n\nSolution: The longest repeating subsequence problem is the modified version of the longest common subsequence problem. Therefore, in this problem, you have to find the longest common subsequence of the string where the given string will itself be s1 and s2 for the LCS problem. T\n\nherefore, you have to ignore the case where the indexes of both string are the same while comparing the characters as the repeated character hold a different index in the given string\n\nThis problem contains the characteristic of dynamic programming i.e. overlapping and optimal structure, you can divide the problem into several subproblems just like the LCS problem, and store the result of each problem in the table.\n\nThe running time complexity to find the longest repeating subsequence is O(n^2) where n is the length of the input string.\n\nThis is one of the famous dynamic programming problems which is mostly asked in technical interviews for getting into top companies. Here, the minimum coin change problem is to make a change of the given value of cents where you have an infinite supply of each of C = {c1, c2,….cm} valued coins.\n\nProblem Statement: Given an array of available denominations of coin and one target price. Find the minimum number of coins required to pay the same.\n\nSolution: Here, you can start the solution with sum = N cents. In each iteration, find the minimum coins required by dividing the original problem into subproblems.\n\nConsider a coin from { 1, c2,…cm} and reduce the sum repeatedly depending upon the coin of the denomination you choose. You have to repeat the same process until N becomes 0, and at this point, you found your solution.\n\nThe running time complexity of the coin change minimum problem is O(m*n), where m is the number of coins and n is the change required. \n\n\n\nCoin change ways is a similar problem to the coin change problem that you learned earlier. Here, you are given value N and you have to make a change of these N cents with an infinite supply of each c=(c1, c2, ..cn) valued coin. Unlike the coin change problem, in this problem, you have to find out the distinct number of ways to make change for N cents.\n\nRemember here the order of the coin doesn’t matter.\n\nProblem Statement: Given an array of available denominations of coin and one target price. In how many ways can you pay the price provided you can use any coin any number of times?\n\nSolution: Here you can see that the problem has characteristics of a dynamic programming approach i.e. optimal structure and overlapping subproblem nature and therefore, you can solve the above problem easily using dynamic programming. To solve the problem, you have to create a 2D array to store the subproblem solution.\n\nThe size of the table ‘dp’ will be (n+1)*(price+1). The rows of the table will display the denomination of coins and the column will display the total amount i.e. the sum of the cents. We will repeatedly store the value of each subproblem in the DP table and the value in the last row and the last column of the table is the final answer.\n\nCompare the denomination value and the sum value repeatedly and run the loop to find the result of each subproblem and solve it in the table. Check out the below problem logic for a better understanding of the solution to the problem.\n\nThe time complexity of the above problem is O(n*N) where n is the total number of denominations and N is the total change required.\n\nHouse Robber is another big problem that was asked about in coding interviews.\n\nHere is a complete table of differences between Dynamic and Greedy programming:\n\nThe biggest advantages of Dynamic Programming is that you can obtain the both local and total optimal solution, it reduces the lines of the code, & it is applicable to both linear and non-linear problem.\n\nHowever, DP makes unnecessary memory utilization. As you make use of the table while solving the problem, it needs a lot of memory space for storage purposes\n\nFollowing are some major practical applications of Dynamic Programming:\n• It is used in the 0/1 Knapsack Problem which is most commonly asked in technical interviews.\n• It is used in a time-sharing scheduling algorithm.\n• It is used widely while solving a mathematical optimization problem.\n• It is used in flight and robotics control.\n• It is used in routing algorithms.\n• It is mostly used in computer networks and graph problems.\n\nWhat are Sub Programs in Dynamic Programming?\n\nBy dividing a problem through smaller subproblems as well as storing the solutions for these smaller subproblems, dynamic programming provides a strategy for problem-solving. In dynamic programming, we resolve an issue by first resolving its sub-issues, then combining their resolutions to resolve the issue at hand.\n\nA subproblem is a scaled-down version of the main problem. We divide the main problem into smaller, similarly structured, but more manageable subproblems. Although each subproblem is easier to tackle, they all share the same structure as the main issue. Recursively addressing the subproblems, we find solutions and record them in a table.\n\nThe fundamental problem is then resolved using the subproblem solutions. Take the issue of locating the nth Fibonacci number as an illustration. This issue can be resolved via dynamic programming by dissecting it into smaller issues.\n\nThe sum of the (n-1)th and (n-2)th Fibonacci numbers is the nth Fibonacci number. As a result, we may get the (n-1)st and (n-2)st Fibonacci numbers and then add them to solve the issue recursively. To avoid having to compute the answers to the subproblems again, we can store them in a table and utilize them to calculate the answer to the main problem.\n\nWhat is Memorisation in Dynamic Programming?\n\nDynamic programming uses the memory approach to save the outcomes of subproblems in a table so they can be reused later. Memory is a type of caching that is employed to quicken the process of problem-solving.\n\nWhen a subproblem is encountered again, the outcome of the previous subproblem is stored in a table and can be retrieved using memory. As there is no need to solve the same subproblem more than once, this method can greatly reduce the algorithm's time complexity.\n\nTake the Fibonacci sequence, for instance. The formula F(n) = F(n-1) + F(n-2) defines the series, where F(0) = 0 and F(1) = 1. With the aid of dynamic programming and memoization, we can identify the nth phrase in the sequence. The solution to each subproblem can be kept in a table and used to determine the sequence's subsequent term.\n\nBy using this method, the algorithm's time complexity is reduced from exponential to linear. A table or an array can be used to implement memory by storing the outcomes of subproblems. As the algorithm resolves each subproblem, the values in the table can be changed. The table can be initialized with default values.\n\nIt is possible to use memorization for issues with overlapping subproblems, which means that the algorithm will run into the same subproblem more than once.\n\nWhen should it be used to solve a problem?\n\nThe powerful method of dynamic programming can be applied to a variety of issues. However, there are several requirements that must be satisfied before choosing to utilize dynamic programming to solve an issue, therefore it isn't always the best option.\n• Overlapping Subproblems: The existence of overlapping subproblems in the original problem is one of the essential conditions for dynamic programming. In other words, the issue can be divided into more manageable subproblems that are used repeatedly in the resolution.\n• Optimal substructure: The problem's optimal substructure is another prerequisite for dynamic programming. In other words, the problem's optimal solution can be created from the answers to its individual subproblems.\n• Memory work can enhance performance: By saving the outcomes of pricey function calls in memory, dynamic programming methods can run better. Memorization can drastically lower the number of function calls necessary if the same subproblem appears numerous times in the solution.\n• Complexity in polynomial time: Algorithms for dynamic programming should have polynomial time complexity. That is, the amount of time needed to solve the issue should be inversely correlated with some polynomial function of the size of the input.\n\nDynamic programming in Python is most important to optimize the solutions to the problem in comparison to the recursive approach. It helps to reduce the repeated function calls and hence proves to be faster and more effective than the recursive and divide-and-conquer approaches.\n\nThe idea of simply storing the results of subproblems and making use of them in computing the rest of the problem make dynamic programming algorithm a different and important topic in the domain of data structure and algorithm. Therefore, it is surely asked in every technical interview and highly recommended to learn and understand."
    },
    {
        "link": "https://reintech.io/blog/understanding-dynamic-programming-in-python",
        "document": "In this tutorial, we will dive deeply into Python's dynamic programming world. Understanding dynamic programming is an essential skill for any serious Python developer.\n\nDynamic Programming (DP) is a powerful technique used in programming and computer science to solve problems that can be divided into simpler, overlapping subproblems. It involves breaking down a problem into smaller components that can be solved independently and reused when needed.\n\nUnderstanding Dynamic Programming with an Example\n\nLet's understand the concept of dynamic programming with the help of a classic problem: the Fibonacci sequence.\n\nIn the above function, we use a dynamic programming approach to solve the Fibonacci sequence problem. We initialize a list with base conditions and then build up the solution to the problem iteratively.\n\nDynamic programming is used when the problem can be divided into overlapping subproblems, which are not independent. It is mainly used for optimization problems to find the best solution. It reduces the time complexity by avoiding the recomputation of the overlapping subproblems.\n\nPython, a high-level, interpreted programming language with a simple syntax, is great for implementing dynamic programming solutions.\n\nLet's consider the problem of calculating the nth Fibonacci number:\n\nIn this code, we create an array fib[0..n] where fib[i] will store the ith Fibonacci number. We initialize fib[0] and fib[1], and fill the remaining spots with 0. Then, we calculate each Fibonacci number from fib[2] to fib[n] and store it in the array. This way, we avoid recalculating the Fibonacci numbers. The final result will be stored in fib[n].\n\nNow, let's see how we can run this on a shell:\n\nThis way, we can solve complex problems efficiently using dynamic programming in Python.\n\nDynamic programming can significantly reduce the time complexity of algorithms that solve complex problems. It is a vital technique that every Python developer should master.\n\nPython has a lot more to offer. To explore more, consider hiring experts from Reintech. Their Python developers are proficient in dynamic programming and various other Python concepts."
    },
    {
        "link": "https://w3schools.com/dsa/dsa_ref_dynamic_programming.php",
        "document": "An algorithm designed with Dynamic Programming divides the problem into subproblems, finds solutions to the subproblems, and puts them together to form a complete solution to the problem we want to solve.\n\nWe have already seen Dynamic Programming in this tutorial, in the memoization and tabulation techniques, and for solving problems like the 0/1 Knapsack Problem, or to find the shortest path with the Bellman-Ford algorithm.\n\nUsing Dynamic Programming To Find The \\(n\\)th Fibonacci Number\n\nLet's say we want an algorithm that finds the \\(n\\)th Fibonacci number. We don't know how to find the \\(n\\)th Fibonacci number yet, except that we want to use Dynamic Programming to design the algorithm.\n\nThe Fibonacci numbers is a sequence of numbers starting with \\(0\\) and \\(1\\), and the next numbers are created by adding the two previous numbers. The 8 first Fibonacci numbers are: \\(0,\\; 1,\\; 1,\\; 2,\\; 3,\\; 5,\\; 8,\\; 13\\). And counting from 0, the \\(4\\)th Fibonacci number \\(F(4)\\) is \\(3\\). In general, this is how a Fibonacci number is created based on the two previous:\n\nSo how can we use Dynamic Programming to design an algorithm that finds the \\(n\\)th Fibonacci number?\n\nThere is no exact rule for how to design an algorithm using Dynamic Programming, but here is a suggestion that should work in most cases:\n• Check if the the problem has \"overlapping subproblems\" and an \"optimal substructure\".\n• Find a way to put the subproblem solutions together to form solutions to new subproblems.\n• Implement the algorithm (test if it works).\n\nStep 1: Check if the problem has \"overlapping subproblems\" and an \"optimal substructure\".\n\nBefore trying to find an algorithm using Dynimaic Programming, we must first check if the problem has the two properties \"overlapping subproblems\" and \"optimal substructure\".\n\nYes. The \\(6\\)th Fibonacci number is a combination of the \\(5\\)th and \\(4\\)th Fibonacci number: \\(8=5+3\\). And this rule holds for all other Fibonacci numbers as well. This shows that the problem of finding the \\(n\\)th Fibonacci number can be broken into subproblems.\n\nAlso, the subproblems overlap because \\(F(5)\\) is based on \\(F(4)\\) and \\(F(3)\\), and \\(F(6)\\) is based on \\(F(5)\\) and \\(F(4)\\).\n\nYou see? Both solutions to subproblems \\(F(5)\\) and \\(F(6)\\) are created using the solution to \\(F(4)\\), and there are many cases like that, so the subproblems overlap as well.\n\nYes, the Fibonacci number sequence has a very clear structure, because the two previous numbers are added to create the next Fibonacci number, and this holds for all Fibonacci numbers except for the two first. This means we know how to put together a solution by combining the solutions to the subproblems.\n\nWe can conclude that the problem of finding the \\(n\\)th Fibonacci number satisfies the two requirements, which means that we can use Dynamic Programming to find an algorithm that solves the problem.\n\nWe can now start trying to find an algorithm using Dynamic Programming.\n\nSolving the most basic subproblems first is a good place to start to get an idea of how the algorithm should run.\n\nIn our problem of finding the \\(n\\)th Fibonacci number, finding the most basic subproblems is not that hard, because we already know that\n\nStep 3: Find a way to put the subproblem solutions together to form solutions to new subproblems.\n\nIn this step, for our problem, how the subproblems are put together is quite straightforward, we just need to add the two previous Fibonacci numbers to find the next one.\n\nSo for example, the \\(2\\)nd Fibonacci number is created by adding the two previous numbers \\(F(2)=F(1)+F(0)\\), and that is the general rule as well, like mentioned earlier: \\(F(n)=F(n-1)+F(n-2)\\).\n\nInstead of writing the text for the algorithm straight away, it might be wise to try to write a procedure to solve a specific problem first, like finding the \\(6\\)th Fibonacci number.\n\nFor reference, the 8 first Fibonacci numbers are: \\(0,\\; 1,\\; 1,\\; 2,\\; 3,\\; 5,\\; \\underline{8},\\; 13\\).\n\nFinding the \\(6\\)th Fibonacci number, we could start with the two first numbers \\(0\\) and \\(1\\), which appear in place 0 and 1 in the sequence, and put them in an array, at index 0 and 1. Then we could add the two first numbers in the array to generate the next number, and push that new number as a new element to the array. If we continue like this until the array is 7 elements long we would stop and return . That would work, right?\n\nAfter solving the specific problem above, it is now easier to write the actual algorithm.\n\nThe algorithm for finding the \\(n\\)th Fibonacci number, using Dynamic Programming as a design method, can be described like this:\n\nStep 5: Implement the algorithm (test if it works).\n\nTo implement the algorithm above, we assume that the argument to the function is a positive number (the \\(n\\)th Fibonacci number), we use a loop to create new Fibonacci numbers, and we return the base cases and straight away if the function is called with or as an argument.\n\nImplementing the algorithm also means that we can check if it works.\n\nThere it is!\n\nWe have used Dynamic Programming as a design method to create an algorithm that finds the \\(n\\)th Fibonacci number.\n\nWe have also implemented the algorithm to demonstrate that it works, and in doing so we have unintentionally used a well established technique within Dynamic Programming called tabulation, where the solution is found by solving subproblems bottom-up, using some kind of table.\n\nFurthermore, we have avoided calculating the same overlapping subproblems many times, like for example, that we could potentially have ended up doing otherwise, with a brute force recursive approach for example.\n\nAnother technique used in Dynamic Programming is called memoization. In this case, using memoization essentially solves the problem recursively with brute force, but stores the subproblem solutions for later as the algorithm runs to avoid doing the same calculations more than once.\n\nIt might be difficult to design an algorithm using Dynamic Programming, but the concept of Dynamic Programming is actually not that hard: Solve the problem, but since the subproblems are overlapping, do it in a smart way so that a specific subproblem only needs to be solved once.\n\nTo be able to use solutions to previously solved subproblems in Dynamic Programming, the previously found solutions must be stored somehow, and that can be done using memoization or tabulation.\n\nMemoization is a technique used in Dynamic Programming, where the solution is found recursively. As the algorithm runs, solutions to subproblems are stored, and before trying to compute the solution to a subproblem, it checks first to see if that solution has already been computed, to avoid doing the same computation more than once.\n\nThe memoization technique is called \"top-down\" because the initial function call is for the main problem, and it results in new function calls for solving smaller and smaller subproblems.\n\nTabulation is a technique used in Dynamic Programming, where solutions to the overlapping subproblems are stored in a table (array), starting with the most basic subproblems.\n\nThe tabulation technique is not recursive, and it is called \"bottom-up\" because of the way the final solution is built up by solving the most basic subproblems first. Since the most basic subproblem solutions are stored in the table first, when solving a subproblem later that relies on previous subproblems, the algorithm can just pick these solutions right from the table, no need to compute them again.\n\nTo get a better sense of how memoization works, and is considered \"top-down\", and how tabulation works, and is \"bottom-up\", take a look at the two images below.\n\nThe bottom-up tabulation approach to finding the 10th Fibonacci number. The top-down memoization approach to finding the 10th Fibonacci number.\n\nAs you can see in the images above, the tabulation approach starts at the bottom by solving F(0) first, while the memoization approach start at the top with F(10) and breaking it into smaller and smaller subproblems from there."
    }
]