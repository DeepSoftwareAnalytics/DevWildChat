[
    {
        "link": "https://learn.microsoft.com/en-us/windows/win32/api/d3d9/nf-d3d9-idirect3ddevice9-gettexture",
        "document": "Stage identifier of the texture to retrieve. Stage identifiers are zero-based.\n\nAddress of a pointer to an IDirect3DBaseTexture9 interface, representing the returned texture.\n\nIf the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL.\n\nTypically, methods that return state will not work on a device that is created using D3DCREATE_PUREDEVICE. This method however, will work even on a pure device because it returns an interface.\n\nCalling this method will increase the internal reference count on the IDirect3DTexture9 interface. Failure to call IUnknown::Release when finished using this IDirect3DTexture9 interface results in a memory leak."
    },
    {
        "link": "https://learn.microsoft.com/en-us/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-gettexture",
        "document": "Stage identifier of the texture to retrieve. Stage identifiers are zero-based.\n\nAddress of a pointer to an IDirect3DBaseTexture9 interface, representing the returned texture.\n\nIf the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL.\n\nTypically, methods that return state will not work on a device that is created using D3DCREATE_PUREDEVICE. This method however, will work even on a pure device because it returns an interface.\n\nCalling this method will increase the internal reference count on the IDirect3DTexture9 interface. Failure to call IUnknown::Release when finished using this IDirect3DTexture9 interface results in a memory leak."
    },
    {
        "link": "https://github.com/MicrosoftDocs/sdk-api/blob/docs/sdk-api-src/content/d3d9/nf-d3d9-idirect3ddevice9-gettexture.md",
        "document": "Stage identifier of the texture to retrieve. Stage identifiers are zero-based.\n\nAddress of a pointer to an IDirect3DBaseTexture9 interface, representing the returned texture.\n\nIf the method succeeds, the return value is D3D_OK. If the method fails, the return value can be D3DERR_INVALIDCALL.\n\nTypically, methods that return state will not work on a device that is created using D3DCREATE_PUREDEVICE. This method however, will work even on a pure device because it returns an interface.\n\nCalling this method will increase the internal reference count on the IDirect3DTexture9 interface. Failure to call IUnknown::Release when finished using this IDirect3DTexture9 interface results in a memory leak."
    },
    {
        "link": "https://docs.nvidia.com/cuda/cuda-runtime-api/group__CUDART__D3D9.html",
        "document": "Gets the device number for an adapter. - Returns the device corresponding to pszAdapterName - D3D9 adapter to get device for Returns in the CUDA-compatible device corresponding to the adapter name obtained from EnumDisplayDevices or IDirect3D9::GetAdapterIdentifier(). If no device on the adapter with name is CUDA-compatible then the call will fail. Note that this function may also return error codes from previous, asynchronous launches.\n\nGets the CUDA devices corresponding to a Direct3D 9 device. - Returned number of CUDA devices corresponding to - The size of the output device array - The set of devices to return. This set may be cudaD3D9DeviceListAll for all devices, cudaD3D9DeviceListCurrentFrame for the devices used to render the current frame (in SLI), or cudaD3D9DeviceListNextFrame for the devices used to render the next frame (in SLI). Returns in the number of CUDA-compatible devices corresponding to the Direct3D 9 device . Also returns in at most of the the CUDA-compatible devices corresponding to the Direct3D 9 device . If any of the GPUs being used to render are not CUDA capable then the call will return cudaErrorNoDevice. Note that this function may also return error codes from previous, asynchronous launches.\n\nSets the Direct3D 9 device to use for interoperability with a CUDA device. - Direct3D device to use for this thread - The CUDA device to use. This device must be among the devices returned when querying cudaD3D9DeviceListAll from cudaD3D9GetDevices, may be set to -1 to automatically select an appropriate CUDA device. Records as the Direct3D 9 device to use for Direct3D 9 interoperability with the CUDA device and sets as the current device for the calling host thread. This function will immediately initialize the primary context on if needed. If has already been initialized then this call will fail with the error cudaErrorSetOnActiveProcess. In this case it is necessary to reset using cudaDeviceReset() before Direct3D 9 interoperability on may be enabled. Successfully initializing CUDA interoperability with will increase the internal reference count on . This reference count will be decremented when is reset using cudaDeviceReset(). Note that this function is never required for correct functionality. Use of this function will result in accelerated interoperability only when the operating system is Windows Vista or Windows 7, and the device is not an IDirect3DDevice9Ex. In all other cirumstances, this function is not necessary. Note that this function may also return error codes from previous, asynchronous launches.\n\nRegisters the Direct3D 9 resource for access by CUDA. If this call is successful then the application will be able to map and unmap this resource until it is unregistered through cudaGraphicsUnregisterResource(). Also on success, this call will increase the internal reference count on . This reference count will be decremented when this resource is unregistered through cudaGraphicsUnregisterResource(). This call potentially has a high-overhead and should not be called every frame in interactive applications. The type of must be one of the following.\n• IDirect3DVertexBuffer9: may be accessed through a device pointer\n• IDirect3DIndexBuffer9: may be accessed through a device pointer\n• IDirect3DSurface9: may be accessed through an array. Only stand-alone objects of type IDirect3DSurface9 may be explicitly shared. In particular, individual mipmap levels and faces of cube maps may not be registered directly. To access individual surfaces associated with a texture, one must register the base texture object.\n• IDirect3DBaseTexture9: individual surfaces on this texture may be accessed through an array. The argument may be used to specify additional parameters at register time. The valid values for this parameter are\n• cudaGraphicsRegisterFlagsNone: Specifies no hints about how this resource will be used.\n• cudaGraphicsRegisterFlagsSurfaceLoadStore: Specifies that CUDA will bind this resource to a surface reference.\n• cudaGraphicsRegisterFlagsTextureGather: Specifies that CUDA will perform texture gather operations on this resource. Not all Direct3D resources of the above types may be used for interoperability with CUDA. The following are some limitations.\n• The primary rendertarget may not be registered with CUDA.\n• Resources allocated as shared may not be registered with CUDA.\n• Textures which are not of a format which is 1, 2, or 4 channels of 8, 16, or 32-bit integer or floating-point data cannot be shared.\n• Surfaces of depth or stencil formats cannot be shared. A complete list of supported formats is as follows: If is of incorrect type or is already registered, then cudaErrorInvalidResourceHandle is returned. If cannot be registered, then cudaErrorUnknown is returned. Note that this function may also return error codes from previous, asynchronous launches."
    },
    {
        "link": "http://few.vu.nl/~eliens/pim/@archive/projects/jurgen/directx9.pdf",
        "document": ""
    },
    {
        "link": "https://stackoverflow.com/questions/9519195/is-it-possible-to-enumerate-textures-with-directx-9",
        "document": "I'm writing a plugin for an application that uses Direct3D (9.0c) as its renderer. Not many things are exposed to my plugin, however I do have access to the IDirect3DDevice9 interface. Using the pointer to this interface, is it possible to enumerate the textures that have been allocated?\n\nSpecifically, I'm needing to find the render targets that the application uses for a render to texture so that I can gain access to its depth buffer for use with my custom shader."
    },
    {
        "link": "https://learn.microsoft.com/en-us/windows/win32/direct3d9/automatic-texture-management",
        "document": "Texture management is the process of determining which textures are needed for rendering at a given time and ensuring that those textures are loaded into video memory. As with any algorithm, texture management schemes vary in complexity, but any approach to texture management involves the following key tasks.\n• Tracking the amount of available texture memory.\n• Calculating which textures are needed for rendering, and which are not.\n• Determining which existing texture resources can be reloaded with another texture image, and which surfaces should be destroyed and replaced with new texture resources.\n\nDirect3D implements system-supported texture management to ensure that textures are loaded for optimal performance. Texture resources that Direct3D manages are referred to as managed textures.\n\nThe texture manager tracks textures with a time-stamp that identifies when the texture was last used. It then uses a least-recently-used algorithm to determine which textures should be removed. Texture priorities are used as tie breakers when two textures are targeted for removal from memory. If two textures have the same priority value, the least-recently-used texture is removed. However, if two textures have the same time-stamp, the texture that has a lower priority is removed first.\n\nYou request automatic texture management for texture surfaces when you create them. To retrieve a managed texture in a C++ application, create a texture resource by calling IDirect3DDevice9::CreateTexture and specifying the D3DPOOL_MANAGED for the Pool parameter. You are not allowed to specify where you want the texture created. You cannot use the D3DPOOL_DEFAULT or D3DPOOL_SYSTEMMEM flags when creating a managed texture. After creating the managed texture, you can call the IDirect3DDevice9::SetTexture method to set it to a stage in the rendering device's texture cascade.\n\nYou can assign a priority to managed textures by calling the IDirect3DResource9::SetPriority method for the texture surface.\n\nDirect3D automatically downloads textures into video memory as needed. The system might cache managed textures in local or nonlocal video memory, depending on the availability of nonlocal video memory or other factors. The cache location of your managed textures is not communicated to your application, nor is this information required to use automatic texture management. If your application uses more textures than can fit in video memory, Direct3D removes older textures from video memory to make room for the new textures. If you use a removed texture again, the system uses the original system-memory texture surface to reload the texture in the video-memory cache. Although reloading the texture is necessary, it also decreases the application's performance.\n\nYou can dynamically modify the original system-memory copy of the texture by updating or locking the texture resource. When the system detects a dirty surface - after an update is completed, or when the surface is unlocked - the texture manager automatically updates the video-memory copy of the texture. The performance hit incurred is similar to reloading a removed texture.\n\nWhen entering a new level in a game, your application might need to flush all managed textures from video memory (by calling IDirect3DDevice9::EvictManagedResources).\n\nFor more information about resource management, see Managing Resources (Direct3D 9)."
    },
    {
        "link": "https://stackoverflow.com/questions/20204695/how-do-i-apply-different-textures-to-multiple-primitives-direct3d-9",
        "document": "I think using an UV atlas can solve your problem. An atlas is basically a large texture made up of smaller textures, like a photo collage. The UV coordinates of your vertices of course refer to the large texture, but if you know the position of your \"small\" textures, this is easy to calculate.\n\n Of course you have to create that atlas texture first."
    },
    {
        "link": "https://learn.microsoft.com/en-us/windows/win32/direct3d9/performance-optimizations",
        "document": "Every developer who creates real-time applications that use 3D graphics is concerned about performance optimization. This section provides guidelines for getting the best performance from your code.\n• Clear only when you must.\n• Minimize state changes and group the remaining state changes.\n• Use smaller textures, if you can do so.\n• Draw objects in your scene from front to back.\n• Use triangle strips instead of lists and fans. For optimal vertex cache performance, arrange strips to reuse triangle vertices sooner, rather than later.\n• Use static vertex buffers where possible.\n• Use one large static vertex buffer per FVF for static objects, rather than one per object.\n• If your application needs random access into the vertex buffer in AGP memory, choose a vertex format size that is a multiple of 32 bytes. Otherwise, select the smallest appropriate format.\n• Draw using indexed primitives. This can allow for more efficient vertex caching within hardware.\n• If the depth buffer format contains a stencil channel, always clear the depth and stencil channels at the same time.\n• Combine the shader instruction and the data output where possible. For example: // Rather than doing a multiply and add, and then output the data with // two instructions: mad r2, r1, v0, c0 mov oD0, r2 // Combine both in a single instruction, because this eliminates an // additional register copy. mad oD0, r1, v0, c0\n\nBuilding a reliable database of the objects in your world is key to excellent performance in Direct3D. It is more important than improvements to rasterization or hardware.\n\nYou should maintain the lowest polygon count you can possibly manage. Design for a low polygon count by building low-polygon models from the start. Add polygons if you can do so without sacrificing performance later in the development process. Remember, the fastest polygons are the ones you don't draw.\n\nTo get the best rendering performance during execution, try to work with primitives in batches and keep the number of render-state changes as low as possible. For example, if you have an object with two textures, group the triangles that use the first texture and follow them with the necessary render state to change the texture. Then group all the triangles that use the second texture. The simplest hardware support for Direct3D is called with batches of render states and batches of primitives through the hardware abstraction layer (HAL). The more effectively the instructions are batched, the fewer HAL calls are performed during execution.\n\nBecause lights add a per-vertex cost to each rendered frame, you can improve performance significantly by being careful about how you use them in your application. Most of the following tips derive from the maxim, \"the fastest code is code that is never called.\"\n• Use as few light sources as possible. To increase the overall lighting level, for example, use the ambient light instead of adding a new light source.\n• Directional lights are more efficient than point lights or spotlights. For directional lights, the direction to the light is fixed and doesn't need to be calculated on a per-vertex basis.\n• Spotlights can be more efficient than point lights, because the area outside the cone of light is calculated quickly. Whether spotlights are more efficient or not depends on how much of your scene is lit by the spotlight.\n• Use the range parameter to limit your lights to only the parts of the scene you need to illuminate. All the light types exit fairly early when they are out of range.\n• Specular highlights almost double the cost of a light. Use them only when you must. Set the D3DRS_SPECULARENABLE render state to 0, the default value, whenever possible. When defining materials, you must set the specular power value to zero to turn off specular highlights for that material; just setting the specular color to 0,0,0 is not enough.\n\nTexture-mapping performance is heavily dependent on the speed of memory. There are a number of ways to maximize the cache performance of your application's textures.\n• Keep the textures small. The smaller the textures are, the better chance they have of being maintained in the main CPU's secondary cache.\n• Do not change the textures on a per-primitive basis. Try to keep polygons grouped in order of the textures they use.\n• Use square textures whenever possible. Textures whose dimensions are 256x256 are the fastest. If your application uses four 128x128 textures, for example, try to ensure that they use the same palette and place them all into one 256x256 texture. This technique also reduces the amount of texture swapping. Of course, you should not use 256x256 textures unless your application requires that much texturing because, as mentioned, textures should be kept as small as possible.\n\nDirect3D uses the world and view matrices that you set to configure several internal data structures. Each time you set a new world or view matrix, the system recalculates the associated internal structures. Setting these matrices frequently - for example, thousands of times per frame - is computationally time-consuming. You can minimize the number of required calculations by concatenating your world and view matrices into a world-view matrix that you set as the world matrix, and then setting the view matrix to the identity. Keep cached copies of individual world and view matrices so that you can modify, concatenate, and reset the world matrix as needed. For clarity in this documentation, Direct3D samples rarely employ this optimization.\n\nTo find out if the driver supports dynamic textures, check the D3DCAPS2_DYNAMICTEXTURES flag of the D3DCAPS9 structure.\n\nKeep the following things in mind when working with dynamic textures.\n• They cannot be managed. For example, their pool cannot be D3DPOOL_MANAGED.\n• Dynamic textures can be locked, even if they are created in D3DPOOL_DEFAULT.\n\nIt is a good idea to create only one dynamic texture per format and possibly per size. Dynamic mipmaps, cubes, and volumes are not recommended because of the additional overhead in locking every level. For mipmaps, D3DLOCK_DISCARD is allowed only on the top level. All levels are discarded by locking just the top level. This behavior is the same for volumes and cubes. For cubes, the top level and face 0 are locked.\n\nThe following pseudocode shows an example of using a dynamic texture.\n\nLocking a static vertex buffer while the graphics processor is using the buffer can have a significant performance penalty. The lock call must wait until the graphics processor is finished reading vertex or index data from the buffer before it can return to the calling application, a significant delay. Locking and then rendering from a static buffer several times per frame also prevents the graphics processor from buffering rendering commands, since it must finish commands before returning the lock pointer. Without buffered commands, the graphics processor remains idle until after the application is finished filling the vertex buffer or index buffer and issues a rendering command.\n\nIdeally the vertex or index data would never change, however this is not always possible. There are many situations where the application needs to change vertex or index data every frame, perhaps even multiple times per frame. For these situations, the vertex or index buffer should be created with D3DUSAGE_DYNAMIC. This usage flag causes Direct3D to optimize for frequent lock operations. D3DUSAGE_DYNAMIC is only useful when the buffer is locked frequently; data that remains constant should be placed in a static vertex or index buffer.\n\nTo receive a performance improvement when using dynamic vertex buffers, the application must call IDirect3DVertexBuffer9::Lock or IDirect3DIndexBuffer9::Lock with the appropriate flags. D3DLOCK_DISCARD indicates that the application does not need to keep the old vertex or index data in the buffer. If the graphics processor is still using the buffer when lock is called with D3DLOCK_DISCARD, a pointer to a new region of memory is returned instead of the old buffer data. This allows the graphics processor to continue using the old data while the application places data in the new buffer. No additional memory management is required in the application; the old buffer is reused or destroyed automatically when the graphics processor is finished with it. Note that locking a buffer with D3DLOCK_DISCARD always discards the entire buffer, specifying a nonzero offset or limited size field does not preserve information in unlocked areas of the buffer.\n\nThere are cases where the amount of data the application needs to store per lock is small, such as adding four vertices to render a sprite. D3DLOCK_NOOVERWRITE indicates that the application will not overwrite data already in use in the dynamic buffer. The lock call will return a pointer to the old data, allowing the application to add new data in unused regions of the vertex or index buffer. The application should not modify vertices or indices used in a draw operation as they might still be in use by the graphics processor. The application should then use D3DLOCK_DISCARD after the dynamic buffer is full to receive a new region of memory, discarding the old vertex or index data after the graphics processor is finished.\n\nThe asynchronous query mechanism is useful to determine if vertices are still in use by the graphics processor. Issue a query of type D3DQUERYTYPE_EVENT after the last DrawPrimitive call that uses the vertices. The vertices are no longer in use when IDirect3DQuery9::GetData returns S_OK. Locking a buffer with D3DLOCK_DISCARD or no flags will always guarantee the vertices are synchronized properly with the graphics processor, however using lock without flags will incur the performance penalty described earlier. Other API calls such as IDirect3DDevice9::BeginScene, IDirect3DDevice9::EndScene, and IDirect3DDevice9::Present do not guarantee the graphics processor is finished using vertices.\n\nBelow are ways to use dynamic buffers and the proper lock flags.\n\nYou can optimize meshes by using Direct3D indexed triangles instead of indexed triangle strips. The hardware will discover that 95 percent of successive triangles actually form strips and adjust accordingly. Many drivers do this for older hardware also.\n\nD3DX mesh objects can have each triangle, or face, tagged with a DWORD, called the attribute of that face. The semantics of the DWORD are user-defined. They are used by D3DX to classify the mesh into subsets. The application sets per-face attributes using the ID3DXMesh::LockAttributeBuffer call. The ID3DXMesh::Optimize method has an option to group the mesh vertices and faces on attributes using the D3DXMESHOPT_ATTRSORT option. When this is done, the mesh object calculates an attribute table that can be obtained by the application by calling ID3DXBaseMesh::GetAttributeTable. This call returns 0 if the mesh is not sorted by attributes. There is no way for an application to set an attribute table because it is generated by the ID3DXMesh::Optimize method. The attribute sort is data sensitive, so if the application knows that a mesh is attribute sorted, it still needs to call ID3DXMesh::Optimize to generate the attribute table.\n\nThe following topics describe the different attributes of a mesh.\n\nAn attribute id is a value that associates a group of faces with an attribute group. This id describes which subset of faces ID3DXBaseMesh::DrawSubset should draw. Attribute ids are specified for the faces in the attribute buffer. The actual values of the attribute ids can be anything that fits in 32 bits, but it is common to use 0 to n where n is the number of attributes.\n\nThe attribute buffer is an array of DWORDs (one per face) that specifies which attribute group each face belongs in. This buffer is initialized to zero on creation of a mesh, but is either filled by the load routines or must be filled by the user if more than one attribute with id 0 is desired. This buffer contains the information that is used to sort the mesh based on attributes in ID3DXMesh::Optimize. If no attribute table is present, ID3DXBaseMesh::DrawSubset scans this buffer to select the faces of the given attribute to draw.\n\nThe attribute table is a structure owned and maintained by the mesh. The only way for one to be generated is by calling ID3DXMesh::Optimize with attribute sorting or stronger optimization enabled. The attribute table is used to quickly initiate a single draw primitive call to ID3DXBaseMesh::DrawSubset. The only other use is that progressing meshes also maintain this structure, so it is possible to see what faces and vertices are active at the current level of detail.\n\nApplications can increase performance when using z-buffering and texturing by ensuring that scenes are rendered from front to back. Textured z-buffered primitives are pretested against the z-buffer on a scan line basis. If a scan line is hidden by a previously rendered polygon, the system rejects it quickly and efficiently. Z-buffering can improve performance, but the technique is most useful when a scene draws the same pixels more than once. This is difficult to calculate exactly, but you can often make a close approximation. If the same pixels are drawn less than twice, you can achieve the best performance by turning z-buffering off and rendering the scene from back to front."
    },
    {
        "link": "https://github.com/MicrosoftDocs/win32/blob/docs/desktop-src/direct3d9/automatic-texture-management.md",
        "document": "Texture management is the process of determining which textures are needed for rendering at a given time and ensuring that those textures are loaded into video memory. As with any algorithm, texture management schemes vary in complexity, but any approach to texture management involves the following key tasks.\n• Tracking the amount of available texture memory.\n• Calculating which textures are needed for rendering, and which are not.\n• Determining which existing texture resources can be reloaded with another texture image, and which surfaces should be destroyed and replaced with new texture resources.\n\nDirect3D implements system-supported texture management to ensure that textures are loaded for optimal performance. Texture resources that Direct3D manages are referred to as managed textures.\n\nThe texture manager tracks textures with a time-stamp that identifies when the texture was last used. It then uses a least-recently-used algorithm to determine which textures should be removed. Texture priorities are used as tie breakers when two textures are targeted for removal from memory. If two textures have the same priority value, the least-recently-used texture is removed. However, if two textures have the same time-stamp, the texture that has a lower priority is removed first.\n\nYou request automatic texture management for texture surfaces when you create them. To retrieve a managed texture in a C++ application, create a texture resource by calling IDirect3DDevice9::CreateTexture and specifying the D3DPOOL_MANAGED for the Pool parameter. You are not allowed to specify where you want the texture created. You cannot use the D3DPOOL_DEFAULT or D3DPOOL_SYSTEMMEM flags when creating a managed texture. After creating the managed texture, you can call the IDirect3DDevice9::SetTexture method to set it to a stage in the rendering device's texture cascade.\n\nYou can assign a priority to managed textures by calling the IDirect3DResource9::SetPriority method for the texture surface.\n\nDirect3D automatically downloads textures into video memory as needed. The system might cache managed textures in local or nonlocal video memory, depending on the availability of nonlocal video memory or other factors. The cache location of your managed textures is not communicated to your application, nor is this information required to use automatic texture management. If your application uses more textures than can fit in video memory, Direct3D removes older textures from video memory to make room for the new textures. If you use a removed texture again, the system uses the original system-memory texture surface to reload the texture in the video-memory cache. Although reloading the texture is necessary, it also decreases the application's performance.\n\nYou can dynamically modify the original system-memory copy of the texture by updating or locking the texture resource. When the system detects a dirty surface - after an update is completed, or when the surface is unlocked - the texture manager automatically updates the video-memory copy of the texture. The performance hit incurred is similar to reloading a removed texture.\n\nWhen entering a new level in a game, your application might need to flush all managed textures from video memory (by calling IDirect3DDevice9::EvictManagedResources).\n\nFor more information about resource management, see Managing Resources (Direct3D 9)."
    }
]