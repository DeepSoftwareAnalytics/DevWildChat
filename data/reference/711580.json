[
    {
        "link": "https://fortran-lang.org",
        "document": "Fortran has been designed from the ground up for computationally intensive applications in science and engineering. Mature and battle-tested compilers and libraries allow you to write code that runs close to the metal, fast.\n\nFortran is statically and strongly typed, which allows the compiler to catch many programming errors early on for you. This also allows the compiler to generate efficient binary code.\n\nFortran is a relatively small language that is surprisingly easy to learn and use. Expressing most mathematical and arithmetic operations over large arrays is as simple as writing them as equations on a whiteboard.\n\nFortran allows you to write code in a style that best fits your problem: imperative, procedural, array-oriented, object-oriented, or functional.\n\nFortran is a natively parallel programming language with intuitive array-like syntax to communicate data between CPUs. You can run almost the same code on a single CPU, on a shared-memory multicore system, or on a distributed-memory HPC or cloud-based system. Coarrays, teams, events, and collective subroutines allow you to express different parallel programming patterns that best fit your problem at hand.\n\nFortran is mature and under active development. The latest revision of the language is Fortran 2023. There are over a dozen open source and proprietary Fortran compilers. Further, open source projects like the Standard Library and the Fortran Package Manager are under active development.\n\nFortran is mostly used in domains that adopted computation early–science and engineering. These include numerical weather and ocean prediction, computational fluid dynamics, applied math, statistics, and finance. Fortran is the dominant language of High Performance Computing and is used to benchmark the fastest supercomputers in the world.\n\nIf you’re writing a program or a library to perform fast arithmetic computation over large numeric arrays, Fortran is the optimal tool for the job."
    },
    {
        "link": "https://people.sc.fsu.edu/~jpeterson/Lecture_week1.pdf",
        "document": ""
    },
    {
        "link": "https://ourcodingclub.github.io/tutorials/fortran-intro",
        "document": "The basics of the Fortran programming language\n• Understand what the Fortran programming language is\n• Learn about a brief history of Fortran\n• Understand how Fortran differs to other programming languages\n• Learn some of the basic syntax of the Fortran language\n• Learn how to compile, configure, and run a larger Fortran program\n\nis a computer programming language that is extensively used in numerical, scientific computing. While outwith the scientific community, has declined in popularity over the years, it still has a strong user base with scientific programmers, and is also used in organisations such as weather forecasters, financial trading, and in engineering simulations. programs can be highly optimised to run on high performance computers, and in general the language is suited to producing code where performance is important.\n\nis a compiled language, or more specifically it is compiled ahead-of-time. In other words, you must perform a special step called compilation of your written code before you are able to run it on a computer. This is where differs to interpreted languages such as and which run through an interpreter which executes the instructions directly, but at the cost of compute speed.\n\nFortran was originally named after the contraction of Formula Translation, highlighting ’s origins as a language designed specifically for mathematical calculations. Fortran was developed in the early 1950s and the first ever program ran in 1954 - making fairly unusual among programming languages in that it predates the modern transistor computer - the first Fortran program ran on the IBM 704 vacuum tube computer! has outlived several nation states since its conception, and still is in wide use today in a number of specialised scientific communities. Unfortunately is often referred to as an ‘outdated’ or ‘legacy’ programming language. I disagree with this description, as although has a long history, the language continues to be updated, new features are developed and added to the Fortran language standard, and there is still a strong community behind Fortran. The latest Fortran standard was released in 2018, bringing many new features and keeping a relevant, highly performant language for contemporary scientific computing challenges.\n\nPerhaps you have previously used other programming languages, such as , , or , which have developed with easy to understand syntax in mind, and with a programming style that favours more rapid development time at the expense of computational performance. will seem different to these languages in many ways, but the principles of programming remain broadly the same, and some syntax is shared or similar to elements of other programming languages.\n\nWe are going to start with a ‘high-level’ view of a very simple Fortran program. Don’t worry about every piece of syntax and keyword at the minute - we’re just going to look at the overall general structure.\n\nThis program calculates the area of a triangle using Heron’s formula.\n\nThe first three lines are comment lines - you will hopefully find a lot of these in programs you are given, and in the ones you write yourself. Comment lines are just notes or explanations that help the programmer and the user. They are never executed by the computer and you can write whatever you like within any line marked as a comment. In this is the exclamation mark (!). Any line beginning with an exclamation mark will be ignored by the computer when the program runs. Comments help the user to understand more complicated bits of code by providing a more human-readable explanation, or perhaps giving an example of how to use the code.\n\nBegin the program! is quite a verbose language, in other words, we have to be quite explicit in telling it what we are about to do (Contrast with and which are said to be more dynamic or intuitive languages and meaning can often be inferred.)\n\nSo here we are just telling that we wish to begin our program, and we can optionally give it a name. Skip down to the last line: notice how we also have an statement. likes to keep things balanced and know exactly when you have ended sections of code. You will see the statement used often to demarcate sections of the code such as loops, functions, and so on.\n\nThe next section of the program is where we define the variables to be used in the program. In programs, you will almost always see these defined at the very top of the program, unlike in other languages where you can define them as you go along. likes to know at the start which variables it is dealing with. We will cover what the different types are in the next section. Note also how we have added comments to explain in more human-readable format what each variable does.\n\nThe remaining bit of the program is the actual bit where the area of the triangle is calculated. Our pre-declared variables have values assigned to them using common mathematical operators and functions. (*, /, +, -, SQRT, etc…) and we also write out the result to the screen using the function. We also terminate our program using the statement.\n\nThis program would be saved like a plain-text file, but we would give it the extension . (By convention). To run the program, we would first need to compile it, which is covered in a later section of the tutorial.\n\nhas a set of rules used to determine whether a program is valid and can be understood by the computer, a bit like a human language. The combination of keywords and characters that are used to form Fortran programs are usually referred to as the language’s syntax. Using the above triangle program as a starting point, we will cover the very basic syntax of the Fortran language.\n\nprograms begin with the keyword, followed, optionally, by a name for the program. The end of the program should also be marked by .\n\nWithin the statements, your program can define functions, declare variables to be used in these functions, just like in other programming languages such as or . Within these statements, this is where the calculations on data are performed in the program.\n\nVariables represent data or values used in your program. A variable can represent a single value, like the expression , or a variable can refer to a larger structure for holding data, such as a table or a list of values. Variables can also be used to store non-numeric values such as text, letters, and words, for example.\n\nWe refer to variables in Fortran as having certain Types. A type describes what kind of data the variable is expected to contain. For example, the expression we could say that x refers to a number, i.e. the number 3. If we had something like: , we might say that x refers to some characters or letters. These are examples of how we could describe our variables using keywords to keep track of what kind of data we are using.\n\nIn , we are required to be specific about what kind of data our variables are. has a set of keywords that are used to define the different types of variables. For example to define some variables for use in a later calculation, we would write in Fortran:\n\nWe are saying with these statements that we want to create two integers, and and that they will be assigned the values 3 and 6 respectively. (We can delay assigning values until later on in the program, if necessary.)\n\nhas different types for numeric values. For example, if our calculations required non-integer numbers, such as 3.141, we would use a type called REAL. I.e. a real number.\n\nOnce we have create variables in a program, we can manipulate them and change them.\n\nVariables in fortran are usually defined in the first few lines of the program or a function, like in our example program above. There is one more type that is introduced in the example program, the type. This type refers to variables that are used as or values.\n\nNote that we can can define multiple variables on the same line, separated by a comma. This saves space and typing, and would be the equivalent of writing:\n\nVariable names may be made up of standard latin-alphabet characters, underscores, and numbers. Note that Fortran is not case-sensitive. Keywords and variable names may be written in uppercase or lowercase. Fortran does not distinguish between uppercase and lowercase names, so be careful of using them in variable names. For example: is the same as .\n\nBy convention, you will often see Fortran keywords written in , though this is not a requirement. For example, , , , , , and so on. You can chose to use either uppercase or lowercase, but it is good practice to be consistent in their use, for readability.\n\nWhen you are running a program, the easiest way to see the results of the calculation or other outputs are to print them to the terminal, command line, or console. (These are all terms used interchangeably to refer to the same thing - the window where commands can be entered and text is printed out to screen.)\n\nYou also need a way of inputting data to the program. This can also be done (for this simple example program) by typing the values directly into the terminal from the keyboard. (In a later tutorial we may cover reading information in from text files).\n\nhas two useful functions that will get you started in reading-in and displaying data and messages to the screen: the function and the function.\n\nThe function tells the fortran program to record the values you enter via the keyboard and store them in variables that you define in your program. In our example triangle program we use like this:\n\nIn Fortran functions, any inputs needed for the function are placed inside a list within the two round-brackets (parentheses), as in . In , The first asterisk (*) means the input comes from the keyboard in a READ statement and goes to the screen in a WRITE statement. The second asterisk (*) means the computer decides how the I/O elements should look based on the TYPE of data in the list of variables that follow.\n\nThe list of variables that follow will be assigned the values that you type, one at a time. So in our program we have three variables (a, b, c) that we have already defined earlier on. When the program is running and gets to the READ statement, it will prompt you to enter a variable and press enter. This will happen three times, and each value you type will be assigned to , and respectively.\n\nThe function is very similar, but it just prints out the variables to the screen, in the order specified. So:\n\nWould print out the values assigned to a, b, and c.\n\nFortran is designed primarily for numerical calculations, and it has many built-in functions for mathematical operations. In the example triangle-area program, we use the basic functions: for addition, subtraction, multiplication, and division. There is one other function that we use in the above example, , which finds the square root of a number.\n\nLogical expressions are statements like “If A and B are , then do C”, or “If value X is less than 10, then divide X by Y”. They are ways of controlling the behaviour of a program based on comparisons or truth-values ( types in .)\n\nThe next part of the triangle-program, after the and statements, starts to calculate two conditions (tru/false values) for the last part of the calculation:\n\nRecall that and are types, i.e. they can either be or .\n\nThe true or false value assigned to these two variables will depend on the outcome of evaluating the expression on the right hand side of the equals sign.\n\nTwo logical operators are used in this example: the greater-than operator and the operator. Greater than behaves in the same way as its mathematical counterpart. E.g. would give the answer , because one is not greater than two.\n\nThe operator checks to see if both expressions on either side are true or false. E.g. would return because both expressions are . Notice that we can use brackets, similarly in a mathematical context, to state the order in which we want the expression to be evaluated. First the computer will evaluate the expression in the brackets, before proceeding to evaluating the expression(s) as a whole.\n\nThe outcome of these two lines ( / ) will depend on the inputs you give the program when it runs, which we will come to soon.\n\nAll but the most trivial programs will have to make decisions depending on the type of data input or the results of a calculation. We can refer to this as the program flow or program logic. It is a bit like the logical decisions we make in everyday life:\n\n“IF it is raining today, THEN I will take my umbrella with me, or ELSE I will take my sunhat.”\n\nThe words in uppercase also happen to be the same keywords Fortran uses to control the logical flow of a program depending on different conditions.\n\nLet’s look at the final section of the triangle-area program:\n\nFortran uses these two keywords to make logical decisions within a program. To do something based on a condition being met, the construct is used. The condition part that follows the IF statement may be a single LOGICAL variable, or a logical expression itself (such as in our example). The keyword marks the start of the code that will be executed if the condition is true.\n\nThe statement is optional, but useful if you have an action you want to perform if the condition is false. If this optional section is not provided, the program will simply move on to the next section of code without taking further action. We use an statement here to print an error message if our inputs indicate we are not dealing with a triangle.\n\nYou must remember to mark the end of the block with an statement.\n\nThat is the end of our triangle area program. There is a final statement to mark the end of the program, telling Fortran that we are done.\n\nBut how do we execute (run) the program? We will cover this in the next section.\n\nprograms have an extra step required before you can run or ‘execute’ them. Once the program has been written and saved as a plain-text file, we must convert it into a format that the computer hardware can understand and process. This stage is called compilation - we are compiling our program into a format suitable for the computer we wish to run it on.\n\nIf you have come from a background in using languages such as , , or , you may not have encountered this compilation stage before, as the usual method of running programs written in these languages hides away the compilation stage from the user. These types of languages ( , , etc.) are sometimes described as interpreted languages. The program is run through a special program called the interpreter, and this does all the compilation dynamically, or at run-time.\n\n, being optimised for fast, numerical computation, requires the user to perform the compilation step themselves, which allows fine tuning of the optimisation options of the program and many other customisations of the final program.\n\nWe are going to learn in this section how to compile our sample program.\n\nTo compile our program, make sure you have saved the sample triangle-area program from earlier in the tutorial. Save it as .\n\nYou will need to be running Linux for this particular example. (It is possible to compile Fortran on Windows and MacOS as well, but the command names may be slightly different). If you are on Windows but have access to a Linux server via your institution it is advised to use that for the next part.\n• Open a command-line/terminal session. In the prompt, check that you have the compiler program available by typing . Hopefully this will return the version number if it is installed. (If not, you will get an error message) ``` [dvalters@baltic01 Programming-tutorials]$ gfortran –version GNU Fortran (GCC) 4.8.5 20150623 (Red Hat 4.8.5-28) Copyright (C) 2015 Free Software Foundation, Inc.\n\nGNU Fortran comes with NO WARRANTY, to the extent permitted by law. You may redistribute copies of GNU Fortran under the terms of the GNU General Public License. For more information about these matters, see the file named COPYING ```\n• In the same directory as you saved the .f90 file, run the following command This tells gfortran (a fortran compiler, commonly found on Linux operating systems) to take the file and produce a program called for us to run. The flag lets us specify an output name for our program. When you have run this command, you should now find another item in the directory you ran the command from - the program executable.\n• To run this (in Linux), type . The program should start running. You can now enter your three values, each time pressing the ENTER key to enter the value. After pressing enter after the third value, the program will calculate the area of the triangle using Heron’s Formula.\n\nTry running the program a few times with different lengths of the triangle sides. What happens when the values are not correct for a triangle? Do you get the expected error message defined above?\n\nNow we know how to write, compile, and run a simple Fortran program, lets experiment with modifying and writing our own code.\n\nEvery time you modify the code, you will need to re-run the compilation step above.\n• Add a message to the screen when the program runs to remind users how to enter the data. (i.e. enter 3 values and press the return key.)\n• Add a test at the end of the code to check whether the triangle is right-angled. (Using the Pythagorean Theorem: a^2 = b^2 + c^2). If it is true, print out a message to the user confirming this after the area is calculated.\n• Write a program that converts the number of seconds (entered by the user) into hour, minutes, and seconds, and then prints these out to screen.\n• Write a program that will read in an integer value and check if it is less than, equal to, or greater than zero.\n• Using the previous program, extend it so it reads in five integers and checks each one of them in turn.\n• Write a program that will calculate the the third side of a triangle, given the two other sides. You could use the cosine rule: . Hint: The fortran function for cosine is COS(theta), where theta is the value stored as a variable.\n• Understand what the Fortran programming language is and a little bit about its history.\n• Learn some of the basic Fortran syntax\n• Modify and write your own simple programs"
    },
    {
        "link": "https://reddit.com/r/fortran/comments/ac8t37/im_curious_what_do_you_use_fortran_for_currently",
        "document": "As the wide majority of programmers I talk to considers Fortran to be a dead language, I'm curious of what you are all doing with it.\n\nI'll start by saying I learned it in University in 2009 and taught it from then on to new freshmen."
    },
    {
        "link": "https://docs.rc.fas.harvard.edu/kb/fortran",
        "document": "Currently, the supported Fortran compilers on the FASRC Cannon cluster are GNU gfortran, Intel ifx, and NVIDIA nvfortran.\n\nGNU , part of the GNU Compiler Collection (GCC), is an open-source compiler known for its adherence to Fortran standards and portability across different platforms. To compile a Fortran program named with GNU , you can use the following commands: This command compiles into an executable named . In the above example we also apply level 2 optimization with the compiler flag, improving the performance of the compiled code. Intel Fortran Compiler ( , formerly ) is renowned for its robust optimization capabilities and superior performance, particularly on Intel architectures. Developed by Intel, leverages advanced optimization techniques to generate highly efficient machine code tailored to Intel processors. When compiling Fortran code with , developers can take advantage of optimizations such as auto-vectorization, inter-procedural optimization, and CPU-specific tuning to achieve significant performance improvements. To compile the same Fortran program with Intel , you can use the following command: Similar to , this command compiles into an executable named . Intel ifx typically performs optimization by default, but you can explicitly specify optimization level using the flag.\n\nNVIDIA HPC SDK is a suite of compilers and tools designed for high-performance computing (HPC) applications, including Fortran. NVIDIA Fortran compiler provides extensive optimization capabilities tailored to both CPU and GPU architectures, making it a preferred choice for developers working in fields such as scientific computing, weather modeling, and computational fluid dynamics. When compiling Fortran code with NVIDIA , developers can harness advanced optimizations like GPU offloading, where computationally intensive portions of the code are executed on NVIDIA GPUs for accelerated performance. Additionally, it offers support for directives such as OpenACC, allowing developers to easily parallelize and optimize their code for heterogeneous computing environments. While excels in optimizing code for NVIDIA GPUs, it also delivers competitive performance on CPU architectures, making it a versatile choice for HPC development.\n\nFor compiling Fortran programs with NVIDIA , the process may involve targeting both CPU and GPU architectures. Here’s an example command to compile with for a CPU target:\n\nTo get started with Fortran on the Harvard University FAS cluster you can try the examples in our User Codes repository."
    },
    {
        "link": "https://en.wikipedia.org/wiki/Fortran",
        "document": "Fortran ( ; formerly FORTRAN) is a third-generation, compiled, imperative programming language that is especially suited to numeric computation and scientific computing.\n\nFortran was originally developed by IBM.[3] It first compiled correctly in 1958.[4] Fortran computer programs have been written to support scientific and engineering applications, such as numerical weather prediction, finite element analysis, computational fluid dynamics, plasma physics, geophysics, computational physics, crystallography and computational chemistry. It is a popular language for high-performance computing[5] and is used for programs that benchmark and rank the world's fastest supercomputers.[6][7]\n\nFortran has evolved through numerous versions and dialects. In 1966, the American National Standards Institute (ANSI) developed a standard for Fortran to limit proliferation of compilers using slightly different syntax.[8] Successive versions have added support for a character data type (Fortran 77), structured programming, array programming, modular programming, generic programming (Fortran 90), parallel computing (Fortran 95), object-oriented programming (Fortran 2003), and concurrent programming (Fortran 2008).\n\nSince April 2024, Fortran has ranked among the top ten languages in the TIOBE index, a measure of the popularity of programming languages.[9]\n\nThe first manual for FORTRAN describes it as a Formula Translating System, and printed the name with small caps, Fortran.[10]: p.2 [11] Other sources suggest the name stands for Formula Translator,[12] or Formula Translation.[13]\n\nEarly IBM computers did not support lowercase letters, and the names of versions of the language through FORTRAN 77 were usually spelled in all-uppercase.[14] FORTRAN 77 was the last version in which the Fortran character set included only uppercase letters.[15]\n\nThe official language standards for Fortran have referred to the language as \"Fortran\" with initial caps since Fortran 90.[citation needed]\n\nIn late 1953, John W. Backus submitted a proposal to his superiors at IBM to develop a more practical alternative to assembly language for programming their IBM 704 mainframe computer.[11]: 69 Backus' historic FORTRAN team consisted of programmers Richard Goldberg, Sheldon F. Best, Harlan Herrick, Peter Sheridan, Roy Nutt, Robert Nelson, Irving Ziller, Harold Stern, Lois Haibt, and David Sayre.[16] Its concepts included easier entry of equations into a computer, an idea developed by J. Halcombe Laning and demonstrated in the Laning and Zierler system of 1952.[17]\n\nA draft specification for The IBM Mathematical Formula Translating System was completed by November 1954.[11]: 71 The first manual for FORTRAN appeared in October 1956,[10][11]: 72 with the first FORTRAN compiler delivered in April 1957.[11]: 75 Fortran produced efficient enough code for assembly language programmers to accept a high-level programming language replacement.[18]\n\nJohn Backus said during a 1979 interview with Think, the IBM employee magazine, \"Much of my work has come from being lazy. I didn't like writing programs, and so, when I was working on the IBM 701, writing programs for computing missile trajectories, I started work on a programming system to make it easier to write programs.\"[19]\n\nThe language was widely adopted by scientists for writing numerically intensive programs, which encouraged compiler writers to produce compilers that could generate faster and more efficient code. The inclusion of a complex number data type in the language made Fortran especially suited to technical applications such as electrical engineering.[20]\n\nBy 1960, versions of FORTRAN were available for the IBM 709, 650, 1620, and 7090 computers. Significantly, the increasing popularity of FORTRAN spurred competing computer manufacturers to provide FORTRAN compilers for their machines, so that by 1963 over 40 FORTRAN compilers existed.\n\nFORTRAN was provided for the IBM 1401 computer by an innovative 63-phase compiler that ran entirely in its core memory of only 8000 (six-bit) characters. The compiler could be run from tape, or from a 2200-card deck; it used no further tape or disk storage. It kept the program in memory and loaded overlays that gradually transformed it, in place, into executable form, as described by Haines.[21] This article was reprinted, edited, in both editions of Anatomy of a Compiler[22] and in the IBM manual \"Fortran Specifications and Operating Procedures, IBM 1401\".[23] The executable form was not entirely machine language; rather, floating-point arithmetic, sub-scripting, input/output, and function references were interpreted, preceding UCSD Pascal P-code by two decades. GOTRAN, a simplified, interpreted version of FORTRAN I (with only 12 types of statements not 32) for \"load and go\" operation was available (at least for the early IBM 1620 computer).[24] Modern Fortran, and almost all later versions, are fully compiled, as done for other high-performance languages.\n\nThe development of Fortran paralleled the early evolution of compiler technology, and many advances in the theory and design of compilers were specifically motivated by the need to generate efficient code for Fortran programs.\n\nThe initial release of FORTRAN for the IBM 704[10] contained 32 types of statements, including:\n• Three-way arithmetic statement, which passed control to one of three locations in the program depending on whether the result of the arithmetic expression was negative, zero, or positive\n• Control statements for checking exceptions ( , , and ); and control statements for manipulating sense switches and sense lights ( , , and )\n• statement (for providing optimization hints to the compiler).\n\nThe arithmetic statement was reminiscent of (but not readily implementable by) a three-way comparison instruction (CAS—Compare Accumulator with Storage) available on the 704. The statement provided the only way to compare numbers—by testing their difference, with an attendant risk of overflow. This deficiency was later overcome by \"logical\" facilities introduced in FORTRAN IV.\n\nThe statement was used originally (and optionally) to give branch probabilities for the three branch cases of the arithmetic statement. It could also be used to suggest how many iterations a loop might run. The first FORTRAN compiler used this weighting to perform at compile time a Monte Carlo simulation of the generated code, the results of which were used to optimize the placement of basic blocks in memory—a very sophisticated optimization for its time. The Monte Carlo technique is documented in Backus et al.'s paper on this original implementation, The FORTRAN Automatic Coding System:\n\nThe first FORTRAN compiler reported diagnostic information by halting the program when an error was found and outputting an error code on its console. That code could be looked up by the programmer in an error messages table in the operator's manual, providing them with a brief description of the problem.[10]: p.19–20 [25] Later, an error-handling subroutine to handle user errors such as division by zero, developed by NASA,[26] was incorporated, informing users of which line of code contained the error.\n\nBefore the development of disk files, text editors and terminals, programs were most often entered on a keypunch keyboard onto 80-column punched cards, one line to a card. The resulting deck of cards would be fed into a card reader to be compiled. Punched card codes included no lower-case letters or many special characters, and special versions of the IBM 026 keypunch were offered that would correctly print the re-purposed special characters used in FORTRAN.\n\nReflecting punched card input practice, Fortran programs were originally written in a fixed-column format, with the first 72 columns read into twelve 36-bit words.\n\nA letter \"C\" in column 1 caused the entire card to be treated as a comment and ignored by the compiler. Otherwise, the columns of the card were divided into four fields:\n• 1 to 5 were the label field: a sequence of digits here was taken as a label for use in DO or control statements such as GO TO and IF, or to identify a FORMAT statement referred to in a WRITE or READ statement. Leading zeros are ignored and 0 is not a valid label number.\n• 6 was a continuation field: a character other than a blank or a zero here caused the card to be taken as a continuation of the statement on the prior card. The continuation cards were usually numbered 1, 2, etc. and the starting card might therefore have zero in its continuation column—which is not a continuation of its preceding card.\n• 7 to 72 served as the statement field.\n• 73 to 80 were ignored (the IBM 704's card reader only used 72 columns). 27\n\nColumns 73 to 80 could therefore be used for identification information, such as punching a sequence number or text, which could be used to re-order cards if a stack of cards was dropped; though in practice this was reserved for stable, production programs. An IBM 519 could be used to copy a program deck and add sequence numbers. Some early compilers, e.g., the IBM 650's, had additional restrictions due to limitations on their card readers.[28] Keypunches could be programmed to tab to column 7 and skip out after column 72. Later compilers relaxed most fixed-format restrictions, and the requirement was eliminated in the Fortran 90 standard.\n\nWithin the statement field, whitespace characters (blanks) were ignored outside a text literal. This allowed omitting spaces between tokens for brevity or including spaces within identifiers for clarity. For example, was a valid identifier, equivalent to , and was a valid statement, equivalent to because the zero in column 6 is treated as if it were a space (!), while was instead , the assignment of 1.101 to a variable called . Note the slight visual difference between a comma and a period.\n\nHollerith strings, originally allowed only in FORMAT and DATA statements, were prefixed by a character count and the letter H (e.g., ), allowing blanks to be retained within the character string. Miscounts were a problem.\n\nIBM's FORTRAN II appeared in 1958. The main enhancement was to support procedural programming by allowing user-written subroutines and functions which returned values with parameters passed by reference. The COMMON statement provided a way for subroutines to access common (or global) variables. Six new statements were introduced:[29]\n\nOver the next few years, FORTRAN II added support for the and data types.\n\nEarly FORTRAN compilers supported no recursion in subroutines. Early computer architectures supported no concept of a stack, and when they did directly support subroutine calls, the return location was often stored in one fixed location adjacent to the subroutine code (e.g. the IBM 1130) or a specific machine register (IBM 360 et seq), which only allows recursion if a stack is maintained by software and the return address is stored on the stack before the call is made and restored after the call returns. Although not specified in FORTRAN 77, many F77 compilers supported recursion as an option, and the Burroughs mainframes, designed with recursion built-in, did so by default. It became a standard in Fortran 90 via the new keyword RECURSIVE.[30]\n\nThis program, for Heron's formula, reads data on a tape reel containing three 5-digit integers A, B, and C as input. There are no \"type\" declarations available: variables whose name starts with I, J, K, L, M, or N are \"fixed-point\" (i.e. integers), otherwise floating-point. Since integers are to be processed in this example, the names of the variables start with the letter \"I\". The name of a variable must start with a letter and can continue with both letters and digits, up to a limit of six characters in FORTRAN II. If A, B, and C cannot represent the sides of a triangle in plane geometry, then the program's execution will end with an error code of \"STOP 1\". Otherwise, an output line will be printed showing the input values for A, B, and C, followed by the computed AREA of the triangle as a floating-point number occupying ten spaces along the line of output and showing 2 digits after the decimal point, the .2 in F10.2 of the FORMAT statement with label 601.\n\nIBM also developed a FORTRAN III in 1958 that allowed for inline assembly code among other features; however, this version was never released as a product. Like the 704 FORTRAN and FORTRAN II, FORTRAN III included machine-dependent features that made code written in it unportable from machine to machine, as well as boolean algebraic statements support.[11]: 76 Early versions of FORTRAN provided by other vendors suffered from the same disadvantage.\n\nIBM began development of FORTRAN IV in 1961 as a result of customer demands. FORTRAN IV removed the machine-dependent features of FORTRAN II (such as ), while adding new features such as a data type, logical Boolean expressions, and the logical IF statement as an alternative to the arithmetic IF statement. FORTRAN IV was eventually released in 1962, first for the IBM 7030 (\"Stretch\") computer, followed by versions for the IBM 7090, IBM 7094, and later for the IBM 1401 in 1966.[31]\n\nBy 1965, FORTRAN IV was supposed to be compliant with the standard being developed by the American Standards Association X3.4.3 FORTRAN Working Group.[32]\n\nBetween 1966 and 1968, IBM offered several FORTRAN IV compilers for its System/360, each named by letters that indicated the minimum amount of memory the compiler needed to run. [33] The letters (F, G, H) matched the codes used with System/360 model numbers to indicate memory size, each letter increment being a factor of two larger:[34]: p. 5\n\nDigital Equipment Corporation maintained DECSYSTEM-10 Fortran IV (F40) for PDP-10 from 1967 to 1975.[35] Compilers were also available for the UNIVAC 1100 series and the Control Data 6000 series and 7000 series systems.[36]\n\nAt about this time FORTRAN IV had started to become an important educational tool and implementations such as the University of Waterloo's WATFOR and WATFIV were created to simplify the complex compile and link processes of earlier compilers.\n\nIn the FORTRAN IV programming environment of the era, except for that used on Control Data Corporation (CDC) systems, only one instruction was placed per line. The CDC version allowed for multiple instructions per line if separated by a $ (dollar) character. The FORTRAN sheet was divided into four fields, as described above.\n\nTwo compilers of the time, IBM \"G\" and UNIVAC, allowed comments to be written on the same line as instructions, separated by a special character: \"master space\": V (perforations 7 and 8) for UNIVAC and perforations 12/11/0/7/8/9 (hexadecimal FF) for IBM. These comments were not to be inserted in the middle of continuation cards.[35][36]\n\nPerhaps the most significant development in the early history of FORTRAN was the decision by the American Standards Association (now American National Standards Institute (ANSI)) to form a committee sponsored by the Business Equipment Manufacturers Association (BEMA) to develop an American Standard Fortran. The resulting two standards, approved in March 1966, defined two languages, FORTRAN (based on FORTRAN IV, which had served as a de facto standard), and Basic FORTRAN (based on FORTRAN II, but stripped of its machine-dependent features). The FORTRAN defined by the first standard, officially denoted X3.9-1966, became known as FORTRAN 66 (although many continued to term it FORTRAN IV, the language on which the standard was largely based). FORTRAN 66 effectively became the first industry-standard version of FORTRAN. FORTRAN 66 included:\n• Hollerith constants in and statements, and as arguments to procedures\n• Identifiers of up to six characters in length\n\nThe above Fortran II version of the Heron program needs several modifications to compile as a Fortran 66 program. Modifications include using the more machine independent versions of the and statements, and removal of the unneeded type conversion functions. Though not required, the arithmetic statements can be re-written to use logical statements and expressions in a more structured fashion.\n\nAfter the release of the FORTRAN 66 standard, compiler vendors introduced several extensions to Standard Fortran, prompting ANSI committee X3J3 in 1969 to begin work on revising the 1966 standard, under sponsorship of CBEMA, the Computer Business Equipment Manufacturers Association (formerly BEMA). Final drafts of this revised standard circulated in 1977, leading to formal approval of the new FORTRAN standard in April 1978. The new standard, called FORTRAN 77 and officially denoted X3.9-1978, added a number of significant features to address many of the shortcomings of FORTRAN 66:\n• Block and statements, with optional and clauses, to provide improved language support for structured programming\n• statement, to override implicit conventions that undeclared variables are if their name begins with , , , , , or (and otherwise)\n• data type, replacing Hollerith strings with vastly expanded facilities for character input and output and processing of character-based data\n• Generic names for intrinsic functions (e.g. also accepts arguments of other types, such as or ).\n• A set of intrinsics ( , , , ) for lexical comparison of strings, based upon the ASCII collating sequence. (These ASCII functions were demanded by the U.S. Department of Defense, in their conditional approval vote.[ ])\n• A maximum of seven dimensions in arrays, rather than three. Allowed subscript expressions were also generalized.\n\nIn this revision of the standard, a number of features were removed or altered in a manner that might invalidate formerly standard-conforming programs. (Removal was the only allowable alternative to X3J3 at that time, since the concept of \"deprecation\" was not yet available for ANSI standards.) While most of the 24 items in the conflict list (see Appendix A2 of X3.9-1978) addressed loopholes or pathological cases permitted by the prior standard but rarely used, a small number of specific capabilities were deliberately removed, such as:\n• Hollerith constants and Hollerith data, such as\n• Reading into an H edit (Hollerith field) descriptor in a FORMAT specification\n• Transfer of control out of and back into the range of a DO loop (also known as \"Extended Range\")\n\nA Fortran 77 version of the Heron program requires no modifications to the Fortran 66 version. However this example demonstrates additional cleanup of the I/O statements, including using list-directed I/O, and replacing the Hollerith edit descriptors in the statements with quoted strings. It also uses structured and statements, rather than / .\n\nThe development of a revised standard to succeed FORTRAN 77 would be repeatedly delayed as the standardization process struggled to keep up with rapid changes in computing and programming practice. In the meantime, as the \"Standard FORTRAN\" for nearly fifteen years, FORTRAN 77 would become the historically most important dialect.\n\nAn important practical extension to FORTRAN 77 was the release of MIL-STD-1753 in 1978.[37] This specification, developed by the U.S. Department of Defense, standardized a number of features implemented by most FORTRAN 77 compilers but not included in the ANSI FORTRAN 77 standard. These features would eventually be incorporated into the Fortran 90 standard.\n\nThe IEEE 1003.9 POSIX Standard, released in 1991, provided a simple means for FORTRAN 77 programmers to issue POSIX system calls.[38] Over 100 calls were defined in the document – allowing access to POSIX-compatible process control, signal handling, file system control, device control, procedure pointing, and stream I/O in a portable manner.\n\nThe much-delayed successor to FORTRAN 77, informally known as Fortran 90 (and prior to that, Fortran 8X), was finally released as ISO/IEC standard 1539:1991 in 1991 and an ANSI Standard in 1992. In addition to changing the official spelling from FORTRAN to Fortran, this major revision added many new features to reflect the significant changes in programming practice that had evolved since the 1978 standard:\n• Free-form source input removed the need to skip the first six character positions before entering statements.\n• Identifiers up to 31 characters in length (In the previous standard, it was only six characters).\n• Ability to operate on arrays (or array sections) as a whole, thus greatly simplifying math and engineering computations.\n• whole, partial and masked array assignment statements and array expressions, such as\n• Modules, to group related procedures and data together, and make them available to other program units, including the capability to limit the accessibility to only specific parts of the module.\n• A vastly improved argument-passing mechanism, allowing interfaces to be checked at compile time\n• New data type declaration syntax, to specify the data type and other attributes of variables\n• Dynamic memory allocation by means of the attribute and the and statements\n• attribute, pointer assignment, and statement to facilitate the creation and manipulation of dynamic data structures\n• Structured looping constructs, with an statement for loop termination, and and statements for terminating normal loop iterations in an orderly way\n• Portable specification of numerical precision under the user's control\n\nUnlike the prior revision, Fortran 90 removed no features.[39] Any standard-conforming FORTRAN 77 program was also standard-conforming under Fortran 90, and either standard should have been usable to define its behavior.\n\nA small set of features were identified as \"obsolescent\" and were expected to be removed in a future standard. All of the functionalities of these early-version features can be performed by newer Fortran features. Some are kept to simplify porting of old programs but many were deleted in Fortran 95.\n\nFortran 95, published officially as ISO/IEC 1539-1:1997, was a minor revision, mostly to resolve some outstanding issues from the Fortran 90 standard. Nevertheless, Fortran 95 also added a number of extensions, notably from the High Performance Fortran specification:\n• Expanded the ability to use initialization expressions for data objects\n• Clearly defined that arrays are automatically deallocated when they go out of scope.\n\nA number of intrinsic functions were extended (for example a argument was added to the intrinsic).\n\nSeveral features noted in Fortran 90 to be \"obsolescent\" were removed from Fortran 95:\n• Branching to an statement from outside its block\n\nAn important supplement to Fortran 95 was the ISO technical report TR-15581: Enhanced Data Type Facilities, informally known as the Allocatable TR. This specification defined enhanced use of arrays, prior to the availability of fully Fortran 2003-compliant Fortran compilers. Such uses include arrays as derived type components, in procedure dummy argument lists, and as function return values. ( arrays are preferable to -based arrays because arrays are guaranteed by Fortran 95 to be deallocated automatically when they go out of scope, eliminating the possibility of memory leakage. In addition, elements of allocatable arrays are contiguous, and aliasing is not an issue for optimization of array references, allowing compilers to generate faster code than in the case of pointers.[40])\n\nAnother important supplement to Fortran 95 was the ISO technical report TR-15580: Floating-point exception handling, informally known as the IEEE TR. This specification defined support for IEEE floating-point arithmetic and floating-point exception handling.\n\nIn addition to the mandatory \"Base language\" (defined in ISO/IEC 1539-1 : 1997), the Fortran 95 language also included two optional modules:\n\nwhich, together, compose the multi-part International Standard (ISO/IEC 1539).\n\nAccording to the standards developers, \"the optional parts describe self-contained features which have been requested by a substantial body of users and/or implementors, but which are not deemed to be of sufficient generality for them to be required in all standard-conforming Fortran compilers.\" Nevertheless, if a standard-conforming Fortran does provide such options, then they \"must be provided in accordance with the description of those facilities in the appropriate Part of the Standard\".\n\nThe language defined by the twenty-first century standards, in particular because of its incorporation of object-oriented programming support and subsequently Coarray Fortran, is often referred to as 'Modern Fortran', and the term is increasingly used in the literature.[41]\n\nFortran 2003, officially published as ISO/IEC 1539-1:2004, was a major revision introducing many new features.[42] A comprehensive summary of the new features of Fortran 2003 is available at the Fortran Working Group (ISO/IEC JTC1/SC22/WG5) official Web site.[43]\n\nFrom that article, the major enhancements for this revision include:\n• Object-oriented programming support: type extension and inheritance, polymorphism, dynamic type allocation, and type-bound procedures, providing complete support for abstract data types\n• Data manipulation enhancements: allocatable components (incorporating TR 15581), deferred type parameters, attribute, explicit type specification in array constructors and allocate statements, pointer enhancements, extended initialization expressions, and enhanced intrinsic procedures\n• Input/output enhancements: asynchronous transfer, stream access, user specified transfer operations for derived types, user specified control of rounding during format conversions, named constants for preconnected units, the statement, regularization of keywords, and access to error messages\n• Interoperability with the C programming language\n• Support for international usage: access to ISO 10646 4-byte characters and choice of decimal or comma in numeric formatted input/output\n• Enhanced integration with the host operating system: access to command-line arguments, environment variables, and processor error messages\n\nAn important supplement to Fortran 2003 was the ISO technical report TR-19767: Enhanced module facilities in Fortran. This report provided sub-modules, which make Fortran modules more similar to Modula-2 modules. They are similar to Ada private child sub-units. This allows the specification and implementation of a module to be expressed in separate program units, which improves packaging of large libraries, allows preservation of trade secrets while publishing definitive interfaces, and prevents compilation cascades.\n\nISO/IEC 1539-1:2010, informally known as Fortran 2008, was approved in September 2010.[44][45] As with Fortran 95, this is a minor upgrade, incorporating clarifications and corrections to Fortran 2003, as well as introducing some new capabilities. The new capabilities include:\n• The DO CONCURRENT construct – for loop iterations with no interdependencies\n• The CONTIGUOUS attribute – to specify storage layout restrictions\n• The BLOCK construct – can contain declarations of objects with construct scope\n• Recursive allocatable components – as an alternative to recursive pointers in derived types\n\nThe Final Draft international Standard (FDIS) is available as document N1830.[46]\n\nA supplement to Fortran 2008 is the International Organization for Standardization (ISO) Technical Specification (TS) 29113 on Further Interoperability of Fortran with C,[47][48] which has been submitted to ISO in May 2012 for approval. The specification adds support for accessing the array descriptor from C and allows ignoring the type and rank of arguments.\n\nThe Fortran 2018 revision of the language was earlier referred to as Fortran 2015.[49] It was a significant revision and was released on November 28, 2018.[50]\n• ISO/IEC TS 29113:2012 Further Interoperability with C 51\n\nAdditional changes and new features include support for ISO/IEC/IEEE 60559:2011 (the version of the IEEE floating-point standard before the latest minor revision IEEE 754–2019), hexadecimal input/output, IMPLICIT NONE enhancements and other changes.[53][54][55][56]\n\nFortran 2018 deleted the arithmetic IF statement. It also deleted non-block DO constructs - loops which do not end with an END DO or CONTINUE statement. These had been an obsolescent part of the language since Fortran 90.\n\nNew obsolescences are: COMMON and EQUIVALENCE statements and the BLOCK DATA program unit, labelled DO loops, specific names for intrinsic functions, and the FORALL statement and construct.\n\nFortran 2023 (ISO/IEC 1539-1:2023) was published in November 2023, and can be purchased from the ISO.[57] Fortran 2023 is a minor extension of Fortran 2018 that focuses on correcting errors and omissions in Fortran 2018. It also adds some small features, including an enumerated type capability.\n\nA full description of the Fortran language features brought by Fortran 95 is covered in the related article, Fortran 95 language features. The language versions defined by later standards are often referred to collectively as 'Modern Fortran' and are described in the literature.\n\nAlthough a 1968 journal article by the authors of BASIC already described FORTRAN as \"old-fashioned\",[58] programs have been written in Fortran for many decades and there is a vast body of Fortran software in daily use throughout the scientific and engineering communities.[59] Jay Pasachoff wrote in 1984 that \"physics and astronomy students simply have to learn FORTRAN. So much exists in FORTRAN that it seems unlikely that scientists will change to Pascal, Modula-2, or whatever.\"[60] In 1993, Cecil E. Leith called FORTRAN the \"mother tongue of scientific computing\", adding that its replacement by any other possible language \"may remain a forlorn hope\".[61]\n\nIt is the primary language for some of the most intensive super-computing tasks, such as in astronomy, climate modeling, computational chemistry, computational economics, computational fluid dynamics, computational physics, data analysis,[62] hydrological modeling, numerical linear algebra and numerical libraries (LAPACK, IMSL and NAG), optimization, satellite simulation, structural engineering, and weather prediction.[63] Many of the floating-point benchmarks to gauge the performance of new computer processors, such as the floating-point components of the SPEC benchmarks (e.g., CFP2006, CFP2017) are written in Fortran. Math algorithms are well documented in Numerical Recipes.\n\nApart from this, more modern codes in computational science generally use large program libraries, such as METIS for graph partitioning, PETSc or Trilinos for linear algebra capabilities, deal.II or FEniCS for mesh and finite element support, and other generic libraries. Since the early 2000s, many of the widely used support libraries have also been implemented in C and more recently, in C++. On the other hand, high-level languages such as the Wolfram Language, MATLAB, Python, and R have become popular in particular areas of computational science. Consequently, a growing fraction of scientific programs are also written in such higher-level scripting languages. For this reason, facilities for inter-operation with C were added to Fortran 2003 and enhanced by the ISO/IEC technical specification 29113, which was incorporated into Fortran 2018 to allow more flexible interoperation with other programming languages.\n\nPortability was a problem in the early days because there was no agreed upon standard—not even IBM's reference manual—and computer companies vied to differentiate their offerings from others by providing incompatible features. Standards have improved portability. The 1966 standard provided a reference syntax and semantics, but vendors continued to provide incompatible extensions. Although careful programmers were coming to realize that use of incompatible extensions caused expensive portability problems, and were therefore using programs such as The PFORT Verifier,[64][65] it was not until after the 1977 standard, when the National Bureau of Standards (now NIST) published FIPS PUB 69, that processors purchased by the U.S. Government were required to diagnose extensions of the standard. Rather than offer two processors, essentially every compiler eventually had at least an option to diagnose extensions.[66][67]\n\nIncompatible extensions were not the only portability problem. For numerical calculations, it is important to take account of the characteristics of the arithmetic. This was addressed by Fox et al. in the context of the 1966 standard by the PORT library.[65] The ideas therein became widely used, and were eventually incorporated into the 1990 standard by way of intrinsic inquiry functions. The widespread (now almost universal) adoption of the IEEE 754 standard for binary floating-point arithmetic has essentially removed this problem.\n\nAccess to the computing environment (e.g., the program's command line, environment variables, textual explanation of error conditions) remained a problem until it was addressed by the 2003 standard.\n\nLarge collections of library software that could be described as being loosely related to engineering and scientific calculations, such as graphics libraries, have been written in C, and therefore access to them presented a portability problem. This has been addressed by incorporation of C interoperability into the 2003 standard.\n\nIt is now possible (and relatively easy) to write an entirely portable program in Fortran, even without recourse to a preprocessor.\n\nUntil the Fortran 66 standard was developed, each compiler supported its own variant of Fortran. Some were more divergent from the mainstream than others.\n\nThe first Fortran compiler set a high standard of efficiency for compiled code. This goal made it difficult to create a compiler so it was usually done by the computer manufacturers to support hardware sales. This left an important niche: compilers that were fast and provided good diagnostics for the programmer (often a student). Examples include Watfor, Watfiv, PUFFT, and on a smaller scale, FORGO, Wits Fortran, and Kingston Fortran 2.\n\nFortran 5 was marketed by Data General Corp from the early 1970s to the early 1980s, for the Nova, Eclipse, and MV line of computers. It had an optimizing compiler that was quite good for minicomputers of its time. The language most closely resembles FORTRAN 66.\n\nFORTRAN V was distributed by Control Data Corporation in 1968 for the CDC 6600 series. The language was based upon FORTRAN IV.[68]\n\nUnivac also offered a compiler for the 1100 series known as FORTRAN V. A spinoff of Univac Fortran V was Athena FORTRAN.\n\nSpecific variants produced by the vendors of high-performance scientific computers (e.g., Burroughs, Control Data Corporation (CDC), Cray, Honeywell, IBM, Texas Instruments, and UNIVAC) added extensions to Fortran to take advantage of special hardware features such as instruction cache, CPU pipelines, and vector arrays. For example, one of IBM's FORTRAN compilers (H Extended IUP) had a level of optimization which reordered the machine code instructions to keep multiple internal arithmetic units busy simultaneously. Another example is CFD, a special variant of FORTRAN designed specifically for the ILLIAC IV supercomputer, running at NASA's Ames Research Center. IBM Research Labs also developed an extended FORTRAN-based language called VECTRAN for processing vectors and matrices.\n\nObject-Oriented Fortran was an object-oriented extension of Fortran, in which data items can be grouped into objects, which can be instantiated and executed in parallel. It was available for Sun, Iris, iPSC, and nCUBE, but is no longer supported.\n\nSuch machine-specific extensions have either disappeared over time or have had elements incorporated into the main standards. The major remaining extension is OpenMP, which is a cross-platform extension for shared memory programming. One new extension, Coarray Fortran, is intended to support parallel programming.\n\nFOR TRANSIT was the name of a reduced version of the IBM 704 FORTRAN language, which was implemented for the IBM 650, using a translator program developed at Carnegie in the late 1950s.[69] The following comment appears in the IBM Reference Manual (FOR TRANSIT Automatic Coding System C28-4038, Copyright 1957, 1959 by IBM):\n\nUp to ten subroutines could be used in one program.\n\nFOR TRANSIT statements were limited to columns 7 through 56, only. Punched cards were used for input and output on the IBM 650. Three passes were required to translate source code to the \"IT\" language, then to compile the IT statements into SOAP assembly language, and finally to produce the object program, which could then be loaded into the machine to run the program (using punched cards for data input, and outputting results onto punched cards).\n\nTwo versions existed for the 650s with a 2000 word memory drum: FOR TRANSIT I (S) and FOR TRANSIT II, the latter for machines equipped with indexing registers and automatic floating-point decimal (bi-quinary) arithmetic. Appendix A of the manual included wiring diagrams for the IBM 533 card reader/punch control panel.\n\nPrior to FORTRAN 77, many preprocessors were commonly used to provide a friendlier language, with the advantage that the preprocessed code could be compiled on any machine with a standard FORTRAN compiler.[70] These preprocessors would typically support structured programming, variable names longer than six characters, additional data types, conditional compilation, and even macro capabilities. Popular preprocessors included EFL, FLECS, iftran, MORTRAN, SFtran, S-Fortran, Ratfor, and Ratfiv. EFL, Ratfor and Ratfiv, for example, implemented C-like languages, outputting preprocessed code in standard FORTRAN 66. The PFORT preprocessor was often used to verify that code conformed to a portable subset of the language. Despite advances in the Fortran language, preprocessors continue to be used for conditional compilation and macro substitution.\n\nOne of the earliest versions of FORTRAN, introduced in the '60s, was popularly used in colleges and universities. Developed, supported, and distributed by the University of Waterloo, WATFOR was based largely on FORTRAN IV. A student using WATFOR could submit their batch FORTRAN job and, if there were no syntax errors, the program would move straight to execution. This simplification allowed students to concentrate on their program's syntax and semantics, or execution logic flow, rather than dealing with submission Job Control Language (JCL), the compile/link-edit/execution successive process(es), or other complexities of the mainframe/minicomputer environment. A down side to this simplified environment was that WATFOR was not a good choice for programmers needing the expanded abilities of their host processor(s), e.g., WATFOR typically had very limited access to I/O devices. WATFOR was succeeded by WATFIV and its later versions.\n\nLRLTRAN was developed at the Lawrence Radiation Laboratory to provide support for vector arithmetic and dynamic storage, among other extensions to support systems programming. The distribution included the Livermore Time Sharing System (LTSS) operating system.\n\nThe Fortran-95 Standard includes an optional Part 3 which defines an optional conditional compilation capability. This capability is often referred to as \"CoCo\".\n\nMany Fortran compilers have integrated subsets of the C preprocessor into their systems.\n\nSIMSCRIPT is an application specific Fortran preprocessor for modeling and simulating large discrete systems.\n\nThe F programming language was designed to be a clean subset of Fortran 95 that attempted to remove the redundant, unstructured, and deprecated features of Fortran, such as the statement. F retains the array features added in Fortran 90, and removes control statements that were made obsolete by structured programming constructs added to both FORTRAN 77 and Fortran 90. F is described by its creators as \"a compiled, structured, array programming language especially well suited to education and scientific computing\".[71] Essential Lahey Fortran 90 (ELF90) was a similar subset.\n\nLahey and Fujitsu teamed up to create Fortran for the Microsoft .NET Framework.[72] Silverfrost FTN95 is also capable of creating .NET code.[73]\n\nThe following program illustrates dynamic memory allocation and array-based operations, two features introduced with Fortran 90. Particularly noteworthy is the absence of loops and / statements in manipulating the array; mathematical operations are applied to the array as a whole. Also apparent is the use of descriptive variable names and general code formatting that conform with contemporary programming style. This example computes an average over data entered interactively.\n\nDuring the same FORTRAN standards committee meeting at which the name \"FORTRAN 77\" was chosen, a satirical technical proposal was incorporated into the official distribution bearing the title \"Letter O Considered Harmful\". This proposal purported to address the confusion that sometimes arises between the letter \"O\" and the numeral zero, by eliminating the letter from allowable variable names. However, the method proposed was to eliminate the letter from the character set entirely (thereby retaining 48 as the number of lexical characters, which the colon had increased to 49). This was considered beneficial in that it would promote structured programming, by making it impossible to use the notorious statement as before. (Troublesome statements would also be eliminated.) It was noted that this \"might invalidate some existing programs\" but that most of these \"probably were non-conforming, anyway\".[74][unreliable source?][75]\n\nWhen X3J3 debated whether the minimum trip count for a DO loop should be zero or one in Fortran 77, Loren Meissner suggested a minimum trip count of two—reasoning (tongue-in-cheek) that if it were less than two, then there would be no reason for a loop.\n\nWhen assumed-length arrays were being added, there was a dispute as to the appropriate character to separate upper and lower bounds. In a comment examining these arguments, Walt Brainerd penned an article entitled \"Astronomy vs. Gastroenterology\" because some proponents had suggested using the star or asterisk (\"*\"), while others favored the colon (\":\").[citation needed]\n\nVariable names beginning with the letters I–N have a default type of integer, while variables starting with any other letters defaulted to real, although programmers could override the defaults with an explicit declaration.[76] This led to the joke: \"In FORTRAN, GOD is REAL (unless declared INTEGER).\"\n• f2c – program to convert Fortran 77 to C code\n• None ANSI x3.9-1966. USA Standard FORTRAN . American National Standards Institute. Archived from the original on May 15, 2011 . Informally known as FORTRAN 66.\n• None ANSI x3.9-1978. American National Standard – Programming Language FORTRAN. American National Standards Institute. Archived from the original on October 29, 2013 . Also known as ISO 1539–1980, informally known as FORTRAN 77.\n• None ANSI X3.198-1992 (R1997) / ISO/IEC 1539:1991. American National Standard – Programming Language Fortran Extended. American National Standards Institute / ISO/IEC. Archived from the original on May 1, 2002. Informally known as Fortran 90.\n• None ISO/IEC 1539-1:1997. Information technology – Programming languages – Fortran – Part 1: Base language . Archived from the original on August 18, 2011 . Informally known as Fortran 95. There are a further two parts to this standard. Part 1 has been formally adopted by ANSI.\n• None ISO/IEC 1539-1:2004. Information technology – Programming languages – Fortran – Part 1: Base language . Archived from the original on July 31, 2023. Informally known as Fortran 2003.\n• None ECMA Standard on FORTRAN . European Computer Manufacturers Association. April 1965. Archived from the original on May 10, 2008 .\n• None FORTRAN 77 4.0 Reference Manual . Sun Microsystems, Inc. 1995. Archived from the original on January 5, 2012 .\n• None \"FORTRAN Coding Form\" . IBM. Archived from the original on June 8, 2015 .\n• None IBM System/360 and System/370 Fortran IV Language . IBM. May 1974. Archived from the original on April 6, 2011 .\n• None Goerz, Michael (2014). \"Modern Fortran Reference Card\" . Archived from the original on December 14, 2014 .\n• None Chapman, Stephen J. (2018). Fortran for Scientists and Engineers (Fourth ed.). New York: McGraw-Hill Education. pp. xxiv + 1024. ISBN .\n• None Lorenzo, Mark Jones (2019). Abstracting Away the Machine: The History of the FORTRAN Programming Language (FORmula TRANslation). Independently published. ISBN .\n• None Nyhoff, Larry; Sanford Leestma (1995). FORTRAN 77 for Engineers and Scientists with an Introduction to Fortran 90 (4th ed.). Prentice Hall. ISBN .\n• None Press, William H. (1996). Numerical Recipes in Fortran 90: The Art of Parallel Scientific Computing. Cambridge, UK: Cambridge University Press. ISBN .\n• None Sleighthome, Jane; Chivers, Ian David (1990). Interactive Fortran 77: A Hands-On Approach. Computers and their applications (2nd ed.). Chichester: E. Horwood. ISBN . Archived from the original on March 12, 2014 .\n• None Allen, F.E. (September 1981). \"A History of Language Processor Technology in IBM\". IBM Journal of Research and Development. 25 (5): 548. doi:10.1147/rd.255.0535. S2CID 14149353.\n• None Pigott, Diarmuid (2006). \"FORTRAN – Backus et al high-level compiler (Computer Language)\". The Encyclopedia of Computer Languages. Murdoch University. Archived from the original on October 8, 2009 .\n• Valmer Norrod, et al.: A self-study course in FORTRAN programing—Volume I—textbook, Computer Science Corporation El Segundo, California (April 1970). NASA (N70-25287).\n• Valmer Norrod, Sheldom Blecher, and Martha Horton: A self-study course in FORTRAN programing—Volume II—workbook, NASA CR-1478 (April 1970), NASA (N70-25288).\n• An introduction to the Fortran programming language, by Reinhold Bader, Nisarg Patel, Leibniz Supercomputing Centre.\n• Victor Eijkhout : Introduction to Scientific Programming in C++17/Fortran2008, The Art of HPC, volume 3 (PDF) Archived February 5, 2023, at the Wayback Machine"
    },
    {
        "link": "https://medium.com/@lordNeic/the-evolution-of-programming-languages-af71f2d5dfce",
        "document": "Origins: Developed by an international committee, ALGOL (Algorithmic Language) sought to provide a universal language for describing algorithms.\n\nUnique Features: Introduced block structure and lexical scope, which became standard features in later languages.\n\nImpact: Though not widely used itself, ALGOL was incredibly influential in language development, shaping languages like Pascal and C.\n\nOrigins: Designed by IBM, PL/I (Programming Language One) intended to merge the best features of FORTRAN and COBOL, aiming for both scientific and business applications.\n\nUnique Features: PL/I supported a wide range of applications, from hardware-level programming to high-level business logic.\n\nImpact: PL/I influenced later languages like C and its structured constructs are considered landmarks in language design.\n\nOrigins: Created by John Kemeny and Thomas Kurtz at Dartmouth College, BASIC (Beginner’s All-purpose Symbolic Instruction Code) was designed to make programming accessible to students and beginners.\n\nUnique Features: Known for its simplicity, BASIC introduced many people to programming through personal computers.\n\nImpact: BASIC dialects, such as Visual Basic, have been extensively used for software development, especially in the enterprise sector.\n\nOrigins: Developed at Bell Labs by Dennis Ritchie and Ken Thompson, C was an evolution of the earlier B language. It was created for system programming and to rewrite the UNIX operating system.\n\nUnique Features: Known for its simplicity and flexibility, C introduced the concept of pointers and direct memory manipulation, making it powerful for system-level tasks.\n\nImpact: C has had a monumental impact on many other languages, including C++, Objective-C, and even languages like Java and Python to some extent. It’s still widely used in system and embedded programming.\n\nOrigins: Developed by Donald D. Chamberlin and Raymond F. Boyce at IBM, SQL (Structured Query Language) was designed for managing data stored in relational databases.\n\nUnique Features: SQL allows for the querying and manipulation of structured data. It supports a wide range of operations, including transactions, sub-selects, triggers, and stored procedures.\n\nImpact: Almost indispensable in today’s software landscape, SQL has become the standard for database manipulation and query formulation.\n\nOrigins: Created by Niklaus Wirth as an instructional tool, Pascal was designed to teach programming and to promote good programming practices.\n\nUnique Features: Known for its strong type checking, structured programming, and ease of reading, Pascal also introduced the notion of records and sets.\n\nImpact: Pascal was widely used in academia and has influenced languages like Modula and Ada. Its spirit lives on in Object Pascal and Delphi.\n\nOrigins: Developed by Bjarne Stroustrup at Bell Labs, C++ was an extension of C, introducing object-oriented features.\n\nUnique Features: C++ introduced classes, objects, and inheritance, making it easier to manage large codebases and implement complex data structures and algorithms.\n\nImpact: One of the most widely used languages, C++ found applications in system/software development, game development, real-time systems, and even web servers.\n\nOrigins: Created by Brad Cox and Tom Love, Objective-C extended C with features from Smalltalk, providing object-oriented capabilities and dynamic runtime.\n\nUnique Features: Objective-C brought in the message-passing paradigm from Smalltalk, allowing for more dynamic and flexible software architectures.\n\nImpact: It became the foundation for Apple’s OS X and iOS, and though it is being superseded by Swift, it still finds use in legacy systems.\n\nOrigins: Developed by Larry Wall, Perl was designed for text manipulation and report generation.\n\nUnique Features: Known for its flexibility and powerful text manipulation capabilities, Perl supports multiple programming paradigms.\n\nImpact: Widely used for web development, system administration, and automation, Perl paved the way for languages like Python and Ruby.\n\nThe Internet and Beyond: 1990s\n\nOrigins: Created by Guido van Rossum as a successor to the ABC language, Python was designed to be easy to understand and write. The language’s name comes from the British comedy group Monty Python — a favorite of van Rossum.\n\nUnique Features: Known for its clean syntax and readability, Python supports multiple programming paradigms, including procedural, object-oriented, and functional programming. It has a vast ecosystem of libraries.\n\nImpact: Python is widely used for web development, data analysis, artificial intelligence, scientific computing, and many other applications. It’s praised for its versatility and ease of learning.\n\nOrigins: Developed by James Gosling at Sun Microsystems, Java was initially designed for interactive television but gained fame as a general-purpose, object-oriented language.\n\nUnique Features: Java introduced the Write Once, Run Anywhere (WORA) philosophy, meaning compiled Java code could run on any platform that had a Java Virtual Machine (JVM).\n\nImpact: Java became one of the most popular languages for enterprise applications, web servers, and Android app development.\n\nOrigins: Created by Brendan Eich while at Netscape, JavaScript was originally intended to make web pages interactive and dynamic.\n\nUnique Features: Not to be confused with Java, JavaScript is an interpreted language that allows for client-side script execution. It’s an essential part of the web development trio: HTML, CSS, and JavaScript.\n\nImpact: JavaScript is a cornerstone of modern web development, with frameworks like Angular, React, and Vue.js making it more powerful and versatile than ever.\n\nOrigins: Created by Rasmus Lerdorf, PHP originally stood for ‘Personal Home Page,’ but now it stands for ‘PHP: Hypertext Preprocessor.’\n\nUnique Features: Particularly well-suited for web development, PHP can be embedded within HTML code. It supports various databases and web servers.\n\nImpact: PHP has been extensively used for server-side web development. With frameworks like Laravel, it has become more modern and robust.\n\nOrigins: Developed by Microsoft as part of the .NET initiative, C# was designed for modern, general-purpose software development.\n\nUnique Features: C# offers a blend of the high-performance capability of C++ and the ease-of-use of languages like Java. It supports multiple programming paradigms.\n\nImpact: C# is widely used in enterprise applications, game development via Unity, and Windows applications.\n\nOrigins: Developed by Apple as a modern replacement for Objective-C, Swift aimed to be safer, faster, and more expressive.\n\nUnique Features: Swift offers modern syntax, powerful error handling, and the performance benefits of compiled languages.\n\nImpact: Swift has become the preferred language for iOS and macOS development and is expanding into server-side and systems programming."
    },
    {
        "link": "https://en.wikipedia.org/wiki/History_of_programming_languages",
        "document": "The history of programming languages spans from documentation of early mechanical computers to modern tools for software development. Early programming languages were highly specialized, relying on mathematical notation and similarly obscure syntax.[1] Throughout the 20th century, research in compiler theory led to the creation of high-level programming languages, which use a more accessible syntax to communicate instructions.\n\nThe first high-level programming language was Plankalkül, created by Konrad Zuse between 1942 and 1945.[2] The first high-level language to have an associated compiler was created by Corrado Böhm in 1951, for his PhD thesis.[3] The first commercially available language was FORTRAN (FORmula TRANslation), developed in 1956 (first manual appeared in 1956, but first developed in 1954) by a team led by John Backus at IBM.\n\nDuring 1842–1849, Ada Lovelace translated the memoir of Italian mathematician Luigi Menabrea about Charles Babbage's newest proposed machine: the Analytical Engine; she supplemented the memoir with notes that specified in detail a method for calculating Bernoulli numbers with the engine, recognized by most of historians as the world's first published computer program.[4]\n\nJacquard Looms and Charles Babbage's Difference Engine both were designed to utilize punched cards,[5][6] which would describe the sequence of operations that their programmable machines should perform.\n\nThe first computer codes were specialized for their applications: e.g., Alonzo Church was able to express the lambda calculus in a formulaic way and the Turing machine was an abstraction of the operation of a tape-marking machine.\n\nIn the 1940s, the first recognizably modern electrically powered computers were created. The limited speed and memory capacity forced programmers to write hand-tuned assembly language programs. It was eventually realized that programming in assembly language required a great deal of intellectual effort.[citation needed]\n\nAn early proposal for a high-level programming language was Plankalkül, developed by Konrad Zuse for his Z1 computer between 1942 and 1945 but not implemented at the time.[7]\n\nThe first functioning programming languages designed to communicate instructions to a computer were written in the early 1950s. John Mauchly's Short Code, proposed in 1949, was one of the first high-level languages ever developed for an electronic computer.[8] Unlike machine code, Short Code statements represented mathematical expressions in understandable form. However, the program had to be interpreted into machine code every time it ran, making the process much slower than running the equivalent machine code.\n\nIn the early 1950s, Alick Glennie developed Autocode, possibly the first compiled programming language, at the University of Manchester. In 1954, a second iteration of the language, known as the \"Mark 1 Autocode\", was developed for the Mark 1 by R. A. Brooker. Brooker, with the University of Manchester, also developed an autocode for the Ferranti Mercury in the 1950s. The version for the EDSAC 2 was devised by Douglas Hartree of University of Cambridge Mathematical Laboratory in 1961. Known as EDSAC 2 Autocode, it was a straight development from Mercury Autocode adapted for local circumstances and was noted for its object code optimization and source-language diagnostics which were advanced for the time. A contemporary but separate thread of development, Atlas Autocode was developed for the University of Manchester Atlas 1 machine.\n\nIn 1954, FORTRAN was invented at IBM by a team led by John Backus; it was the first widely used high-level general purpose language to have a functional implementation, in contrast to only a design on paper.[9][10] When FORTRAN was first introduced, it was viewed with skepticism due to bugs, delays in development, and the comparative efficiency of \"hand-coded\" programs written in assembly.[11] However, in a hardware market that was rapidly evolving, the language eventually became known for its efficiency. It is still a popular language for high-performance computing[12] and is used for programs that benchmark and rank the world's TOP500 fastest supercomputers.[13]\n\nAnother early programming language was devised by Grace Hopper in the US, named FLOW-MATIC. It was developed for the UNIVAC I at Remington Rand during the period from 1955 until 1959. Hopper found that business data processing customers were uncomfortable with mathematical notation, and in early 1955, she and her team wrote a specification for an English language programming language and implemented a prototype.[14] The FLOW-MATIC compiler became publicly available in early 1958 and was substantially complete in 1959.[15] Flow-Matic was a major influence in the design of COBOL, since only it and its direct descendant AIMACO were in use at the time.[16]\n\nOther languages still in use today include LISP (1958), invented by John McCarthy and COBOL (1959), created by the Short Range Committee. Another milestone in the late 1950s was the publication, by a committee of American and European computer scientists, of \"a new language for algorithms\"; the ALGOL 60 Report (the \"ALGOrithmic Language\"). This report consolidated many ideas circulating at the time and featured three key language innovations:\n• nested block structure: code sequences and associated declarations could be grouped into blocks without having to be turned into separate, explicitly named procedures;\n• lexical scoping: a block could have its own private variables, procedures and functions, invisible to code outside that block, that is, information hiding.\n\nAnother innovation, related to this, was in how the language was described:\n• a mathematically exact notation, Backus–Naur form (BNF), was used to describe the language's syntax. Nearly all subsequent programming languages have used a variant of BNF to describe the context-free portion of their syntax.\n\nALGOL 60 was particularly influential in the design of later languages, some of which soon became more popular. The Burroughs large systems were designed to be programmed in an extended subset of ALGOL.\n• syntax and semantics became even more orthogonal, with anonymous routines, a recursive typing system with higher-order functions, etc.;\n• not only the context-free part, but the full language syntax and semantics were defined formally, in terms of Van Wijngaarden grammar, a formalism designed specifically for this purpose.\n\nALGOL 68's many little-used language features (for example, concurrent and parallel blocks) and its complex system of syntactic shortcuts and automatic type coercions made it unpopular with implementers and gained it a reputation of being difficult. Niklaus Wirth actually walked out of the design committee to create the simpler Pascal language.\n\nSome notable languages that were developed in this period include:\n\nThe period from the late 1960s to the late 1970s brought a major flowering of programming languages. Most of the major language paradigms now in use were invented in this period:[original research?]\n• Speakeasy, developed in 1964 at Argonne National Laboratory (ANL) by Stanley Cohen, is an object-oriented programming system (OOPS), much like the later MATLAB, IDL and Mathematica numerical package. Speakeasy has a clear Fortran foundation syntax. It first addressed efficient physics computing internally at ANL, was modified for research use (as \"Modeleasy\") for the Federal Reserve Board in the early 1970s and then was made available commercially; Speakeasy and Modeleasy are still in use.\n• Simula, invented in the late 1960s by Nygaard and Dahl as a superset of ALGOL 60, was the first language designed to support object-oriented programming.\n• FORTH, the earliest concatenative programming language was designed by Charles Moore in 1969 as a personal development system while at the National Radio Astronomy Observatory (NRAO).\n• C, an early systems programming language, was developed by Dennis Ritchie and Ken Thompson at Bell Labs between 1969 and 1973.\n• Prolog, designed in 1972 by Alain Colmerauer, Phillipe Roussel, and Robert Kowalski, was the first logic programming language.\n• ML built a polymorphic type system (invented by Robin Milner in 1973) on Lisp, 17 pioneering statically typed functional programming languages. Each of these languages spawned an entire family of descendants, and most modern languages count at least one of them in their ancestry.\n\nThe 1960s and 1970s also saw considerable debate over the merits of \"structured programming\", which essentially meant programming without the use of . A significant fraction of programmers believed that, even in languages that provide , it is bad programming style to use it except in rare circumstances. This debate was closely related to language design: some languages had no , which forced the use of structured programming.\n\nTo provide even faster compile times, some languages were structured for \"one-pass compilers\" which expect subordinate routines to be defined first, as with Pascal, where the main routine, or driver function, is the final section of the program listing.\n\nSome notable languages that were developed in this period include:\n\nThe 1980s were years of relative consolidation in imperative languages. Rather than inventing new paradigms, all of these movements elaborated upon the ideas invented in the prior decade. C++ combined object-oriented and systems programming. The United States government standardized Ada, a systems programming language intended for use by defense contractors. In Japan and elsewhere, vast sums were spent investigating so-called fifth-generation programming languages that incorporated logic programming constructs. The functional languages community moved to standardize ML and Lisp. Research in Miranda, a functional language with lazy evaluation, began to take hold in this decade.\n\nOne important new trend in language design was an increased focus on programming for large-scale systems through the use of modules, or large-scale organizational units of code. Modula, Ada, and ML all developed notable module systems in the 1980s. Module systems were often wedded to generic programming constructs: generics being, in essence, parametrized modules[citation needed] (see also Polymorphism (computer science)).\n\nAlthough major new paradigms for imperative programming languages did not appear, many researchers expanded on the ideas of prior languages and adapted them to new contexts. For example, the languages of the Argus and Emerald systems adapted object-oriented programming to distributed computing systems.\n\nThe 1980s also brought advances in programming language implementation. The reduced instruction set computer (RISC) movement in computer architecture postulated that hardware should be designed for compilers rather than for human assembly programmers. Aided by central processing unit (CPU) speed improvements that enabled increasingly aggressive compiling methods, the RISC movement sparked greater interest in compiler technology for high-level languages.\n\nLanguage technology continued along these lines well into the 1990s.\n\nSome notable languages that were developed in this period include:\n\nThe rapid growth of the Internet in the mid-1990s was the next major historic event in programming languages. By opening up a radically new platform for computer systems, the Internet created an opportunity for new languages to be adopted. In particular, the JavaScript programming language rose to popularity because of its early integration with the Netscape Navigator web browser. Various other scripting languages achieved widespread use in developing customized applications for web servers such as PHP. The 1990s saw no fundamental novelty in imperative languages, but much recombination and maturation of old ideas. This era began the spread of functional languages. A big driving philosophy was programmer productivity. Many rapid application development (RAD) languages emerged, which usually came with an integrated development environment (IDE), garbage collection, and were descendants of older languages. All such languages were object-oriented. These included Object Pascal, Objective Caml (renamed OCaml), Visual Basic, and Java. Java in particular received much attention.\n\nMore radical and innovative than the RAD languages were the new scripting languages. These did not directly descend from other languages and featured new syntaxes and more liberal incorporation of features. Many consider these scripting languages to be more productive than even the RAD languages, but often because of choices that make small programs simpler but large programs more difficult to write and maintain.[citation needed] Nevertheless, scripting languages came to be the most prominent ones used in connection with the Web.\n\nSome programming languages included other languages in their distribution to save the development time. for example both of Python and Ruby included Tcl to support GUI programming through libraries like Tkinter.\n\nSome notable languages that were developed in this period include:\n\nProgramming language evolution continues, and more programming paradigms are used in production.\n\nSome of the trends have included:\n• Increasing support for functional programming in mainstream languages used commercially, including purely functional programming for making code easier to reason about and to parallelize (at both micro- and macro- levels)\n• Mechanisms for adding security and reliability verification to the language: extended static checking, dependent typing, information flow control, static thread safety.\n• More interest in visual programming languages like Scratch, LabVIEW, and PWCT\n• Metaprogramming, reflective programming (reflection), or access to the abstract syntax tree\n• Aspect-oriented programming (AOP) allowing developers to insert code in another module or class at \"join points\"\n\nBig Tech companies introduced multiple new programming languages that are designed to serve their needs. for example:\n\nSome notable languages developed during this period include:\n\nProgramming language evolution continues with the rise of new programming domains.\n• Open source as a developmental philosophy for languages, including the GNU Compiler Collection and languages such as PHP, Python, Ruby, and Scala.\n• Early research in applying artificial intelligence (AI) methods to generate code using AI like using GPT-3 and Gemini. 18 19\n• Multiple new programming languages tried to provide a modern replacement for the C programming language.\n• Many new programming languages are influenced by the popular dynamic languages and promised adding type safety without decreasing the productivity.\n• Many new programming languages uses LLVM in their implementation.\n\nMany Big Tech companies continued introducing new programming languages that are designed to serve their needs and provides first-class support for their platforms. for example:\n\nSome notable languages developed during this period include:[20][21]\n\nThe development of new programming languages continues, and some new languages appears with focus on providing a replacement for current languages. These new languages try to provide the advantages of a known language like C++ (versatile and fast) while adding safety or reducing complexity. Other new languages try to bring ease of use as provided by Python while adding performance as a priority. Also, the growing of Machine Learning and AI tools still plays a big rule behind these languages' development, where some visual languages focus on integrating these AI tools while other textual languages focus on providing more suitable support for developing them. [22][23][24]\n• Alan Kay, pioneering work on object-oriented programming, and originator of Smalltalk.\n• Anders Hejlsberg, developer of Turbo Pascal, Delphi, C#, and TypeScript.\n• Brian Kernighan, co-author of the first book on the C programming language with Dennis Ritchie, coauthor of the AWK and AMPL programming languages.\n• Chuck Moore, inventor of Forth, the first concatenative programming language, and a prominent name in stack machine microprocessor design.\n• Douglas McIlroy, influenced and designed such languages as SNOBOL, TRAC, PL/I, ALTRAN, TMG and C++.\n• Grace Hopper, first to use the term compiler and developer of FLOW-MATIC, influenced development of COBOL. Popularized machine-independent programming languages and the term \"debugging\".\n• James Gosling, lead developer of Java and its precursor, Oak.\n• Jeff Bezanson, main designer, and one of the core developers of Julia.\n• John Backus, inventor of Fortran, cooperated in designing ALGOL 58 and ALGOL 60.\n• John C. Reynolds, co-inventor of the polymorphic lambda calculus (System F).\n• Ken Thompson, inventor of B and Go.\n• Kenneth E. Iverson, developer of APL, co-developer of J with Roger Hui.\n• Konrad Zuse, designed the first high-level programming language, Plankalkül (which influenced ALGOL 58 25 ).\n• Larry Wall, creator of the Perl programming language (see Perl and Raku).\n• Martin Odersky, creator of Scala, and previously a contributor to the design of Java.\n• Martin Richards developed the BCPL programming language, forerunner of the B and C languages.\n• Robin Milner, inventor of ML, and sharing credit for Hindley–Milner polymorphic type inference.\n• Rob Pike, co-creator of Go, Inferno (operating system) and Plan 9 (operating system) Operating System co-author.\n• Stanley Cohen, inventor of Speakeasy, which was created with an OOPS, object-oriented programming system, the first instance, in 1964.\n• None Sammet, Jean E. (July 1972). \"Programming Languages: History and Future\". Communications of the ACM. 15 (7): 610. doi: . S2CID 2003242."
    },
    {
        "link": "https://praxent.com/blog/history-of-programming-languages",
        "document": "As our society becomes increasingly technology-obsessed, programming languages are used by various people and businesses to accomplish particular tasks or functions. When computer users interact with services like social media or emails, they use a programming language’s code (specifically through commands) to complete these tasks.\n\nIn 1843, before the invention of computers, the first programming language was created by Ada Lovelace, one of the earliest female mathematicians. Since then, programming languages have made significant advancements, but this undoubtedly was a pivotal milestone in the development of programming languages.\n\nHistorical Milestones in the Evolution of Programming Languages\n\nProgramming languages have existed since before the invention of human-readable codes, which we now use to complete routine technological tasks. The following are some significant events in the development of programming languages that might interest you.\n\nThe first computer algorithm was invented in 1843 by Ada Lovelace. Quite interestingly, Charles Babbage designed a machine for which this algorithm was intended.\n\nKonrad Zuse established the company Plankalkul in the 1940s\n\nKonrad Zuse created the programming language Plankalkul in the 1940s. It was the first high-level computer programming language ever developed and contained many coding sequences that engineers commonly use to execute basic activities.\n\n1949 – Assembly language, the precursor to today’s coding, was created\n\nThe first computer to use assembly language was the Electronic Delay Storage Automatic Calculator in 1949. Assembly language is a low-level programming language designed to simplify the machine code for writing instructions for the processors. This indicates that modern computers are easier to program than those in 1949.\n\nJohn McCauley mentioned shortcode in 1949, but that wasn’t implemented until 1949 and 1950 by W. Schmitt to improve the operations of the BINAC and UNIVAC computers.\n\nIn 1952, Autocode was the first compiled programming language used\n\nIn 1952, Alick Glennie coined the word Autocode to refer to a set of programming languages. Glennie was an expert in computer science who used Autocode mainly for the Mark 1 computer. It was the first compiled programming language used to translate machine code via a special application known as the compiler.\n\nOne of the first programming languages ever created, FORTRAN, was developed in 1957 and is still used today. Developed to solve scientific and mathematical problems, the FORTRAN programming language has stood the test of time.\n\nIn 1958, ALGOL and LISP were both invented.\n\nIn 1958, two coding languages were created: Algorithmic language (ALGOL) and List Processor (LISP). American and European computer scientists came together to create ALGOL, which is believed to be the origin of popular programming languages such as C, C++, Java, and Pascal.\n\nMcCarthy created LISP to be used in his artificial intelligence applications, and it is one of the oldest computer programming languages still used today. Many individuals and companies continue to favor LISP over other programming languages, such as Ruby or Python.\n\nDr. Grace Murray Hopper created COBOL in 1959. It became the first third-generation programming language and was originally designed for business applications, but it is now used for many different tasks. In 1989, COBOL was estimated to be in use by over 100 million people and is still widely employed in today’s banking systems.\n\nIn 1964, BASIC was created as a computer programming language for beginners\n\nIn 1964, Dartmouth College students created the Beginner’s All-Purpose Symbolic Instruction Code (BASIC). It was developed for those with limited computer proficiency and is still used today. Paul Allen and Bill Gates furthered its development, making it Microsoft’s first commercially successful product.\n\n1970 saw the implementation of PASCAL by Niklaus Wirth\n\nNiklaus Wirth developed PASCAL, which he named after famed mathematician Blaise Pascal. Initially designed to help users learn programming languages, Apple was one of the leading firms to endorse it due to its streamlined and straightforward process.\n\nSmalltalk, SQL, and C were all born in 1972\n\nThe Smalltalk language was designed and created in order to help programmers modify programming languages, resulting in a variety of applications, including Java, Python, and Ruby.\n\nDennis Ritchie developed C and named it so because the language descended from B. Some well-known technology companies that continue to employ C include Apple, Google, and Facebook.\n\nDonald Chamberlain and Raymond Boyce created SQL, a structured query language that helps to modify and view important computer data. Today, many firms, such as Microsoft and Accenture, continue to use SQL.\n\nJean Ichbiah initiated the development of Ada in the early 1980s\n\nAda was created by Jean Ichbiah and was named after the first person to use computer languages. Ada is a specific programming language used to regulate air traffic in many different nations, including Belgium, Australia, and Germany.\n\nC++ and Objective-C were created in 1983 when C++ was born\n\nA C programmer, Bjarne Stroustrup, modified the programming language and released it as C++ in 1983. The changes he made to it introduced new features such as templates, classes, and virtual jobs. In 2003, C++ also won an award as one of the top programming languages. Microsoft Office, gaming platforms like PlayStation and Nintendo 64, Adobe Photoshop, and plenty of other programs use C++.\n\nObjective-C was created by Tom Love and Brad Cox in 1983 and has been the primary programming language for Apple platforms ever since. This includes iOS and macOS.\n\nLarry Wall first created Perl in 1987. Originally it was a text editor, but now Perl is used for a variety of functions across many different industries and sectors, including database applications, visual programs, network programs, and more.\n\nHaskell first established itself in 1990\n\nHaskell was created in 1990 and is named after eminent mathematician Haskell Brooks Curry. This programming language is most often used for mathematical operations but has also been used to create video games.\n\nVisual Basic and Python both came into existence in 1991\n\nMicrosoft created Visual Basic in 1991 to make it easier for users to drag and drop scripts simultaneously. Individuals and businesses can choose from a large number of drop-down menus and change different codes with Visual Basic.\n\nPython is one of the most widely used programming languages in the world today. Guido Van Rossum founded it in 1991 as an alternative for different programming styles. Yahoo, Spotify, and Google are just some of the successful companies that continue to use this software extensively.\n\nRuby was first created in 1993 by Yukihiro Matsumoto. Intended to be used for programming web apps, Ruby is based on numerous other languages, such as Perl, Smalltalk, and Lisp. Brands like Hulu, Groupon, and Twitter use Ruby frequently.\n\nJava, JavaScript, and PHP were first introduced in 1995\n\nOne of the best programming languages out there is Java. It was created in 1991 by James Gosling for a software project for interactive TV, and these days it’s still immensely popular on mobile devices and PCs. JavaScript is another great programming language that Brendan Eich created in 1995. It’s used primarily as a scripting language in websites, including Gmail and Adobe Photoshop, but it can also be used to create web pages or PDF files (among other things).\n\nPHP was originally introduced in 1995. Its purpose is to help people and companies create and maintain their websites, and this includes our own personal homepage, Facebook, Wikipedia, and many others.\n\nThe C# compiler was created in the year 2000\n\nMicrosoft created C# in 2000 with the goal of merging some of the benefits of C++ with the functionality of Visual Basic. Notably, it can be used more easily than Java while still retaining a lot of its power. The only Microsoft tools and products that are not written in C# are outdated.\n\nIn 2003, Scala was established, and Groovy followed 2003\n\nIn 2003, Martin Odersky created Scala, a programming language that is compatible with Java. This is beneficial for programmers who work with Android’s system, and developers from LinkedIn, Netflix, Foursquare, and Twitter are among those who still use it today.\n\nGroovy is a computer language that is derived from Java and designed to promote productivity and efficiency. Starbucks and Craft Business base are two well-known companies that use Groovy to execute daily tasks.\n\nGoogle rolled out Go in 2009\n\nGoogle introduced its Go programming language in 2009 to solve and manage any problems that may arise when dealing with large-scale software systems. Its modern and user-friendly structure has become popular among various organizations worldwide, and these include Uber, Google, Twitch, and many others.\n\nDeveloping new programming languages is not an easy task. In 2014, Apple replaced Objective-C, C++, and C with Swift to create a more streamlined language than their predecessors. More specifically, Swift allows users to create programs that work on both mobile devices and computers for improved functionality across the board.\n\nAre There Any Old Programming Languages That Are Still in Use?\n\nMultiple computer programming languages have been retired, yet many still exist today. One of these is FORTRAN, which was introduced in 1953 and has seen a recent update as recently as 2018. FORTRAN was developed by IBM and upgraded to be compatible with modern computers. COBOL, another popular computer programming language, was created in 1959 and remained the most relied-upon language for banks.\n\nWhat Programming Language Is Most Popular in the Contemporary Technological World?\n\nA lot of new programming languages have been developed over the years. The need to use technology has risen faster than anticipated, and this has created a demand for more programming languages. The following are some of the more popular computer programming languages that businesses use today: SQL, JavaScript, Java, .NET/C#, and HTML/CSS.\n\nAs you can see, the history of programming languages is quite interesting and continues to progress. It’s incredible to consider how a written method from 1840 led to the programming languages that are still used today. They’ve gone from academics employing machine codes to large corporations using high-level, readable code on supercomputers. And now, computer programming is expected to continue evolving and transforming into new languages-some of which will be regarded as some of the best in language history.\n• Coding From 1849 to 2022: A Guide to The Timeline of Programming Languages\n• A Quick Glance at the History of C Programming Languages\n• Top Programming Languages and Their Uses\n• What is the Fortran Programming Language?\n• What is JavaScript? A Definition of the JS Programming Language\n• Programming History: The Influence of Algol on Modern Programming Languages\n• The History of the BASIC Programming Language\n• What Is SQL? All You Need to Know\n• What are HTML and CSS? Are they Even Programming Languages?\n• 20th Anniversary of C# Programming Language. What the Future Holds."
    },
    {
        "link": "https://ibm.com/history/fortran",
        "document": "In the early 1950s, computer programming was the exclusive domain of a small group of specialists who wrote code in machine language, a complex and cumbersome set of instructions. Programming was for experts only — outsiders need not apply. Then came Fortran.\n\nFrom its creation in 1954 and its commercial release in 1957 as the progenitor of software, Fortran (short for formula translation) became the first computer language standard. It helped open the door to modern computing and ranks as one of the most influential software products in history. Fortran liberated computers from the exclusive realm of programmers and opened them to nearly everybody else. And it’s still in use decades after its release.\n\nFortran democratized computer programming by providing scientists, mathematicians and engineers the ability to input their problems directly into the computer without relying on a programmer to translate their needs into machine code. What was formerly a laborious task of manually keying as many as a thousand program instructions for a given problem could now be translated, automated and reduced to only 47 in Fortran.\n\nFortran instigated the process of abstracting software from the hardware on which it ran. Previous machine language programs had to be written for a specific computer, while a Fortran program could run on any system with a Fortran compiler."
    }
]