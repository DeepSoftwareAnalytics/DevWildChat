[
    {
        "link": "https://geeksforgeeks.org/cpp-arrays",
        "document": "In C++, an array is a derived data type that is used to store multiple values of similar data types in a contiguous memory location. Each element can be accessed using its index (position starting from 0).\n\nIn C++, we can create/declare an array by simply specifying the data type first and then the name of the array with its size inside [] square brackets (better known as array subscript operator).\n\nThis statement will create an array with name array_name the can store size elements of given data_type. Once the array is declared, its size cannot be changed.\n\nThis will create an array with name arr that can store 5 integers.\n\nWhen declared, the elements of array does not contain any valid value.\n\nInitialization means assigning initial values to array elements. We can initialize the array with values enclosed in curly braces ‘{}’ are assigned to the array. For example:\n\nThese values will be assigned sequentially. It means that the first element (index 0) will be 10, second will be 20, and so on. The number of values in the list cannot be more than the size of the array. But they can be less that the size. This is called partial initialization.\n\nThe size of the array can be skipped if the size should be same as the number of values.\n\nMoreover, all the elements can be easily initialized to 0 as shown below:\n\nThis method only works for 0,but not for any other value.\n\nElements of an array can be accessed by their position (called index) in the sequence. In C, indexes of an array starts from 0 instead of 1. We just have to pass this index inside the [] square brackets with the array name as shown:\n\nIt is important to note that index cannot be negative or greater than size of the array minus 1. (0 ≤ index ≤ size – 1). Also, it can also be any expression that results in valid index value.\n\nTo change the element at a particular index in an array, just use the = assignment operator with new value as right hand expression while accessing the array element.\n\nTraversing means visiting each element one by one. The advantage of array is that it can be easily traversed by using a loop with loop variable that runs from 0 to size – 1. We use this loop variable as index of the array and access each element one by one sequentially.\n\nThere are more methods to traverse array that are listed here – Traverse an Array in C\n\nIn C++, we do not have the length function as in Java to find array size, but it can be calculated using sizeof() operator trick. First find the size occupied by the whole array in the memory, then divide it by the size of the single element. As all the elements will have same size (due to being same type), this will give us the size/length of the array.\n\nTo know more methods, refer to the article – Length of Array in C\n\nIn C++, arrays and pointers are closely related to each other. The array name can be treated as a constant pointer that stored the memory address of the first element of the array.\n\nInternally, arrays operators are performed using pointer arithmetic. So, we can do almost any array operation using by using pointer to the first element. For example, we can access all the elements of an array using pointer to the first element.\n\nRefer to this article to know more – Relationship Between Pointer and Array\n\nJust like other datatypes in C, arrays can also be passed to functions as parameters for different tasks, but there is a catch. Arrays are always passed as pointers to the function. There are 3 different notations to pass arrays to functions:\n\nNo matter what notation we use, array will still be passed as pointer due to array decay. The direct consequence of this is that passed will lose the information about its size inside the function. It means that we cannot determine the size of the array using sizeof. The compiler will just treat the name arr as pointer and return the size accordingly. To resolve this, it is recommended to pass the size as additional parameter.\n\nIn the above examples, we saw 1D (one dimensional) array. This array’s size can only increase in a single direction (called dimension). C provides the feature to have as many dimensions as desired for an array. Arrays declared with more than one dimension are called multidimensional arrays.\n\nwhere size1, size2 … are the sizes of each dimension.\n\nThe complexity of the array operations increases exponentially with increase in dimensions. So, among multidimensional arrays, 2D arrays and 3D arrays are most widely used.\n\nIn C++, a two-dimensional array is an array that can grow in two directions. It can be visualized as a table arranged in rows and columns. Each element is accessed using two indices: one for the row and one for the column.\n\nExplanation: In the above code, we have declared a 2D array with 4 rows and 4 columns after that we initialized the array with the value of (i+j) in every iteration of the loop. Then we are printing the 2D array using a nested loop and we can see in the below output that there are 4 rows and 4 columns.\n\nThe 3D array uses three dimensions. A can be visualized as a collection of various two-dimensional arrays piled on top of one another can be used to represent it. Three indices: the row index, column index, and depth index are used to uniquely identify each element in a 3D array.\n\nExplanation: In the above code, we have declared a 3D array and then initialized it using three nested for loops. After that, we printed all layers of the 3D array again using three nested for loops as seen in the output.\n• None An array is a collection of data of the same data type, stored at a contiguous memory location.\n• None Indexing of an array starts from 0. It means the first element is stored at the 0 index, the second at 1 , and so on.\n• None Elements of an array can be accessed using their indices.\n• None Once an array is declared its size remains constant throughout the program.\n• None An array can have multiple dimensions.\n• None The size of the array in bytes can be determined by the sizeof operator using which we can also find the number of elements in the array.\n• None We can find the size of the type of elements stored in an array by subtracting adjacent addresses.\n\nThe below practice problems provide you some commonly used scenarios and exercises for practicing arrays in C++:"
    },
    {
        "link": "https://learn.microsoft.com/en-us/cpp/cpp/arrays-cpp?view=msvc-170",
        "document": "An array is a sequence of objects of the same type that occupy a contiguous area of memory. Traditional C-style arrays are the source of many bugs, but are still common, especially in older code bases. In modern C++, we strongly recommend using or instead of C-style arrays described in this section. Both of these standard library types store their elements as a contiguous block of memory. However, they provide greater type safety, and support iterators that are guaranteed to point to a valid location within the sequence. For more information, see Containers.\n\nIn a C++ array declaration, the array size is specified after the variable name, not after the type name as in some other languages. The following example declares an array of 1000 doubles to be allocated on the stack. The number of elements must be supplied as an integer literal or else as a constant expression. That's because the compiler has to know how much stack space to allocate; it can't use a value computed at run-time. Each element in the array is assigned a default value of 0. If you don't assign a default value, each element initially contains whatever random values happen to be at that memory location.\n\nThe first element in the array is the zeroth element. The last element is the (n-1) element, where n is the number of elements the array can contain. The number of elements in the declaration must be of an integral type and must be greater than 0. It is your responsibility to ensure that your program never passes a value to the subscript operator that is greater than .\n\nA zero-sized array is legal only when the array is the last field in a or and when the Microsoft extensions are enabled ( or isn't set).\n\nStack-based arrays are faster to allocate and access than heap-based arrays. However, stack space is limited. The number of array elements can't be so large that it uses up too much stack memory. How much is too much depends on your program. You can use profiling tools to determine whether an array is too large.\n\nYou may require an array that's too large to allocate on the stack, or whose size isn't known at compile time. It's possible to allocate this array on the heap by using a expression. The operator returns a pointer to the first element. The subscript operator works on the pointer variable the same way it does on a stack-based array. You can also use pointer arithmetic to move the pointer to any arbitrary elements in the array. It's your responsibility to ensure that:\n• you always keep a copy of the original pointer address so that you can delete the memory when you no longer need the array.\n• you don't increment or decrement the pointer address past the array bounds.\n\nThe following example shows how to define an array on the heap at run time. It shows how to access the array elements using the subscript operator and by using pointer arithmetic:\n\nYou can initialize an array in a loop, one element at a time, or in a single statement. The contents of the following two arrays are identical:\n\nWhen an array is passed to a function, it's passed as a pointer to the first element, whether it's a stack-based or heap-based array. The pointer contains no other size or type information. This behavior is called pointer decay. When you pass an array to a function, you must always specify the number of elements in a separate parameter. This behavior also implies that the array elements aren't copied when the array gets passed to a function. To prevent the function from modifying the elements, specify the parameter as a pointer to elements.\n\nThe following example shows a function that accepts an array and a length. The pointer points to the original array, not a copy. Because the parameter isn't , the function can modify the array elements.\n\nDeclare and define the array parameter as to make it read-only within the function block:\n\nThe same function can also be declared in these ways, with no change in behavior. The array is still passed as a pointer to the first element:\n\nArrays constructed from other arrays are multidimensional arrays. These multidimensional arrays are specified by placing multiple bracketed constant expressions in sequence. For example, consider this declaration:\n\nIt specifies an array of type , conceptually arranged in a two-dimensional matrix of five rows and seven columns, as shown in the following figure:\n\nThe image is a grid 7 cells wide and 5 cells high. Each cell contains the index of the cell. The first cell index is labeled 0,0. The next cell in that row is 0,1 and so on to the last cell in that row which is 0,6. The next row starts with the index 1,0. The cell after that has an index of 1,1. The last cell in that row is 1,6. This pattern repeats until the last row, which starts with the index 4,0. The last cell in the last row has an index of 4,6. :::image-end\n\nYou can declare multidimensioned arrays that have an initializer list (as described in Initializers). In these declarations, the constant expression that specifies the bounds for the first dimension can be omitted. For example:\n\nThe preceding declaration defines an array that is three rows by four columns. The rows represent factories and the columns represent markets to which the factories ship. The values are the transportation costs from the factories to the markets. The first dimension of the array is left out, but the compiler fills it in by examining the initializer.\n\nUse of the indirection operator (*) on an n-dimensional array type yields an n-1 dimensional array. If n is 1, a scalar (or array element) is yielded.\n\nC++ arrays are stored in row-major order. Row-major order means the last subscript varies the fastest.\n\nYou can also omit the bounds specification for the first dimension of a multidimensional array in function declarations, as shown here:\n\nThe function is written such that adding new factories doesn't require any code changes, just a recompilation.\n\nArrays of objects that have a class constructor are initialized by the constructor. When there are fewer items in the initializer list than elements in the array, the default constructor is used for the remaining elements. If no default constructor is defined for the class, the initializer list must be complete, that is, there must be one initializer for each element in the array.\n\nConsider the class that defines two constructors:\n\nThe first element of is constructed using the constructor ; the remaining two elements are constructed using the default constructor.\n\nStatic member arrays (whether or not) can be initialized in their definitions (outside the class declaration). For example:\n\nYou can access individual elements of an array by using the array subscript operator ( ). If you use the name of a one-dimensional array without a subscript, it gets evaluated as a pointer to the array's first element.\n\nWhen you use multidimensional arrays, you can use various combinations in expressions.\n\nIn the preceding code, is a three-dimensional array of type . The pointer points to an array of type of size three. In this example, the array is used with one, two, and three subscripts. Although it's more common to specify all subscripts, as in the statement, sometimes it's useful to select a specific subset of array elements, as shown in the statements that follow .\n\nLike other operators, the subscript operator ( ) can be redefined by the user. The default behavior of the subscript operator, if not overloaded, is to combine the array name and the subscript using the following method:\n\nAs in all addition that involves pointer types, scaling is done automatically to adjust for the size of the type. The resultant value isn't n bytes from the origin of ; instead, it's the nth element of the array. For more information about this conversion, see Additive operators.\n\nSimilarly, for multidimensional arrays, the address is derived using the following method:\n\nWhen an identifier of an array type appears in an expression other than , address-of ( ), or initialization of a reference, it's converted to a pointer to the first array element. For example:\n\nThe pointer points to the first element of the array . Arrays, unlike pointers, aren't modifiable l-values. That's why the following assignment is illegal:"
    },
    {
        "link": "https://stackoverflow.com/questions/57281686/interpreting-documentation-on-arrays-c",
        "document": "Am I misunderstanding something because as we all know http://www.cplusplus.com/doc/tutorial/arrays/\n\nBy default, regular arrays of local scope (for example, those declared within a function) are left uninitialized. This means that none of its elements are set to any particular value; their contents are undetermined at the point the array is declared. The initializer can even have no values, just the braces: This creates an array of five int values, each initialized with a value of zero\n\nHow is the first source accurate and where can I find more credible documentation that addresses this behavior of array default initialization?"
    },
    {
        "link": "https://stackoverflow.com/questions/10694689/how-to-initialize-an-array-in-c-objects",
        "document": "After reading How to initialize an array in C, in particular:\n\nI tried something like this:\n\nThe obvious in this case is not so obvious. I really would like the initiation of my array to be more dynamic as well.\n\nThis looked funky to me to, and so to the compiler:\n\nThis also did not work:\n\nI have been doing really good and learning what does not work, but not so good learning what does work.\n\nSo, how do I used initialization lists {value, value, value} for an array inside a class?\n\nI have been trying to figure out how to do this for some time now and am very stuck, I have a number of these kinds of lists I need to make for my app."
    },
    {
        "link": "https://cplusplus.com/doc/tutorial/arrays",
        "document": "foo[5]; foo[2] = 75; // access to an element of the array."
    },
    {
        "link": "https://w3schools.com/cpp/cpp_arrays_loop.asp",
        "document": "You can loop through the array elements with the loop.\n\nThe following example outputs all elements in the cars array:\n\n// Create an array of strings\n\nstring cars[5] = {\"Volvo\", \"BMW\", \"Ford\", \"Mazda\", \"Tesla\"};\n\n\n\n// Loop through strings\n\nfor (int i = 0; i < 5; i++) {\n\n cout << cars[i] << \"\n\n\";\n\n}\n\n Try it Yourself »\n\nThis example outputs the index of each element together with its value:\n\nAnd this example shows how to loop through an array of integers:\n\nThere is also a \"for-each loop\" (introduced in C++ version 11 (2011)), which is used exclusively to loop through elements in an array (and other data structures, like vectors and lists):\n\nThe following examples output all elements in an array using a \"for-each loop\":"
    },
    {
        "link": "https://stackoverflow.com/questions/20956672/nested-for-loop-filling-an-array",
        "document": "I am trying to create a nested for loop that fills in values in an array from 1 to 20.\n\nSupposedly, The array index should count up with \"i\", and should be equated to \"j\" which is also counting up. The array element is printed to the console as it is filled.\n\nI expected 1 -20 to be printed out once, but when I run the code, 1-20 prints out multiple times. Can someone tell me the problem? Thanks!"
    },
    {
        "link": "https://stackoverflow.com/questions/20234898/more-modern-way-of-looping-through-c-arrays",
        "document": "In C/C++ . always gives the number of bytes in the entire object, and arrays are treated as one object. Note: a pointer--to the first element of an array or to a single object--gives the size of the pointer, not the object(s) pointed to. Either way, does not give the number of elements in the array (its length). To get the length, you need to divide by the size of each element. eg.,\n\nAs for doing it the C++11 way, the best way to do it is probably\n\nThis lets the compiler figure out how many iterations you need.\n\nas others have pointed out, is preferred in C++11 over raw arrays; however, none of the other answers addressed why is failing the way it is, so I still think this is the better answer."
    },
    {
        "link": "https://cplusplus.com/forum/beginner/251674",
        "document": "Hey, I came across a problem that I can't think of how to solve. I have n = 3 which is how many arrays there are and then I have k = 5 which tells me how many elements there are in the array. So my text file is :3 54 7 3 5 88 9 7 8 65 4 6 7 6This is what I have so far. Not much. The only thing I know is I need to use 2 loops. Or maybe the second is supposed to be a while?"
    },
    {
        "link": "https://reddit.com/r/cpp_questions/comments/jn5z20/best_practice_for_for_loop_condition",
        "document": "I learn C++ on my own and applied it to mostly school projects. The for loop condition (2nd statement) usually comes like this:\n\nThis means i only goes until it reaches (n-1). I work with codes that deal with matrices so to make things clear, I do this\n\nI understand that it is simple to subtract 1 (when using ) and adjust your bounds; however, isnt using easier to understand?\n\nIs using considered bad practice? Almost all code editors or even IDE insert a For loop template with instead of . I'm not working in industry yet but I'd like some thoughts from industry folks as well."
    }
]