[
    {
        "link": "https://geeksforgeeks.org/linked-list-in-c",
        "document": "A linked list is a linear data structure where each element, known as a node, is connected to the next one using pointers. Unlike array, elements of linked list are stored in random memory locations.\n\nIn this article, we will learn about the linked list, its types, representation of the linked list in C, and discuss what link list offers as compared to the similar data structures.\n\nA linked list is a sequence of nodes where each node contains two parts:\n• Data : The value stored in the node.\n• Pointer : A reference to the next node in the sequence. \n\n(There can be multiple pointers for different kind of linked list.)\n\nUnlike arrays, linked lists do not store elements in contiguous memory locations. Instead, each node points to the next, forming a chain-like structure and to access any element (node), we need to first sequentially traverse all the nodes before it.\n\nIt is a recursive data structure in which any smaller part of it is also a linked list in itself.\n\nRepresentation of Linked List in C\n\nIn C, linked lists are represented as the pointer to the first node in the list. For that reason, the first node is generally called head of the linked list. Each node of the linked list is represented by a structure that contains a data field and a pointer of the same type as itself. Such structure is called self-referential structures.\n\nTypes of Linked List in C\n\nLinked list can be classified on the basis of the type of structure they form as a whole and the direction of access. Based on this classification, there are five types of linked lists:\n\nLet's discuss about each of them.\n\nA linked list or singly linked list is a linear data structure that is made up of a group of nodes in which each node has two parts: the data, and the pointer to the next node. The last node's (also known as tail) pointers point to NULL to indicate the end of the linked list.\n\nRepresentation of Singly Linked List in C\n\nA linked list is represented as a pointer to the first node where each node contains:\n• Data: Here the actual information is stored.\n• Next: Pointer that links to the next node.\n\nA doubly linked list is a bit more complex than singly linked list. In it, each node contains three parts: the data, a pointer to the next node, and one extra pointer which points to the previous node. This allows for traversal in both directions, making it more versatile than a singly linked list.\n\nRepresentation of Doubly Linked List in C\n\nA doubly linked list is represented as a pointer to the first node (head), where each node contains:\n• Data : The actual information stored in the node.\n• Next : A pointer that links to the next node in the sequence.\n• Previous : A pointer that links to the previous node in the sequence.\n\nA circular linked list is a variation of a singly linked list where the last node points back to the first node, forming a circle. This means there is no NULL at the end, and the list can be traversed in a circular manner.\n\nThe structure of the circular linked list node is same as that of singly linked list.\n\nRepresentation of Circular Linked List in C\n\nA circular linked list is represented as a pointer to the first node, where each node contains:\n• Data : The actual information stored in the node.\n• Next : A pointer that links to the next node, with the last node pointing back to the first node.\n\nIt is same as the structure for singly linked list node.\n\n\n\nApplications of Linked Lists in C\n\nThe following are some major applications of linked list:\n• None Dynamic memory allocation efficiently manages and allocates dynamic memory in systems and applications.\n• None Implementing other data structures such as stacks, queues, etc.\n• None Represents and manipulates polynomials, with each node storing terms.\n• None Used in file system management dynamically in operating systems.\n• None Linked lists can grow or shrink in size dynamically, as memory is allocated or deallocated as needed.\n• None Inserting or deleting nodes in a linked list is efficient and does not require shifting elements, unlike arrays.\n• None Memory is utilized more efficiently as linked lists do not require a pre-allocated size, reducing wasted space.\n• None They serve as the foundation for implementing more complex data structures like stacks, queues, and graphs.\n• None They can utilize non-contiguous memory blocks, making them suitable for applications where memory is fragmented.\n• None Linked lists do not allow direct access to elements by index. Accessing a specific node requires traversing from the head, leading to slower access times.\n• None Managing pointers can be tricky, increasing the complexity of coding.\n• None Searching for an element or accessing a node by index takes O(N) time, making linked lists slower for such operations compared to arrays.\n\nHow does a linked list differ from an array?\n\nWhat are the main types of linked lists?\n\nWhy use a linked list instead of an array?\n\nWhat are the limitations of linked lists?\n\nWhat are real-world applications of linked lists?"
    },
    {
        "link": "https://learn-c.org/en/Linked_lists",
        "document": "Linked lists are the best and simplest example of a dynamic data structure that uses pointers for its implementation. However, understanding pointers is crucial to understanding how linked lists work, so if you've skipped the pointers tutorial, you should go back and redo it. You must also be familiar with dynamic memory allocation and structures.\n\nEssentially, linked lists function as an array that can grow and shrink as needed, from any point in the array.\n\nLinked lists have a few advantages over arrays:\n• Items can be added or removed from the middle of the list\n• There is no need to define an initial size\n\nHowever, linked lists also have a few disadvantages:\n• There is no \"random\" access - it is impossible to reach the nth item in the array without first iterating over all items up until that item. This means we have to start from the beginning of the list and count how many times we advance in the list until we get to the desired item.\n• Dynamic memory allocation and pointers are required, which complicates the code and increases the risk of memory leaks and segment faults.\n• Linked lists have a much larger overhead over arrays, since linked list items are dynamically allocated (which is less efficient in memory usage) and each item in the list also must store an additional pointer.\n\nA linked list is a set of dynamically allocated nodes, arranged in such a way that each node contains one value and one pointer. The pointer always points to the next member of the list. If the pointer is NULL, then it is the last node in the list.\n\nA linked list is held using a local pointer variable which points to the first item of the list. If that pointer is also NULL, then the list is considered to be empty.\n\nNotice that we are defining the struct in a recursive manner, which is possible in C. Let's name our node type .\n\nNow we can use the nodes. Let's create a local variable which points to the first item of the list (called ).\n\nWe've just created the first variable in the list. We must set the value, and the next item to be empty, if we want to finish populating the list. Notice that we should always check if malloc returned a NULL value or not.\n\nTo add a variable to the end of the list, we can just continue advancing to the next pointer:\n\nThis can go on and on, but what we should actually do is advance to the last item of the list, until the variable will be .\n\nLet's build a function that prints out all the items of a list. To do this, we need to use a pointer that will keep track of the node we are currently printing. After printing the value of the node, we set the pointer to the next node, and print again, until we've reached the end of the list (the next node is NULL).\n\nAdding an item to the end of the list\n\nTo iterate over all the members of the linked list, we use a pointer called . We set it to start from the head and then in each step, we advance the pointer to the next item in the list, until we reach the last item.\n\nThe best use cases for linked lists are stacks and queues, which we will now implement:\n\nAdding an item to the beginning of the list (pushing to the list)\n\nTo add to the beginning of the list, we will need to do the following:\n• Create a new item and set its value\n• Link the new item to point to the head of the list\n• Set the head of the list to be our new item\n\nThis will effectively create a new head to the list with a new value, and keep the rest of the list linked to it.\n\nSince we use a function to do this operation, we want to be able to modify the head variable. To do this, we must pass a pointer to the pointer variable (a double pointer) so we will be able to modify the pointer itself.\n\nRemoving the first item (popping from the list)\n\nTo pop a variable, we will need to reverse this action:\n• Take the next item that the head points to and save it\n• Set the head to be the next item that we've stored on the side\n\nHere is the code:\n\nRemoving the last item of the list\n\nRemoving the last item from a list is very similar to adding it to the end of the list, but with one big exception - since we have to change one item before the last item, we actually have to look two items ahead and see if the next item is the last one in the list:\n\nTo remove a specific item from the list, either by its index from the beginning of the list or by its value, we will need to go over all the items, continuously looking ahead to find out if we've reached the node before the item we wish to remove. This is because we need to change the location to where the previous node points to as well.\n\nHere is the algorithm:\n• Iterate to the node before the node we wish to delete\n• Save the node we wish to delete in a temporary pointer\n• Set the previous node's next pointer to point to the node after the node we wish to delete\n• Delete the node using the temporary pointer\n\nThere are a few edge cases we need to take care of, so make sure you understand the code.\n\nYou must implement the function which receives a double pointer to the head and removes the first item in the list which has the value ."
    },
    {
        "link": "https://reddit.com/r/C_Programming/comments/9tyrc4/implementing_linked_lists_best_practices_and_best",
        "document": "Say I've implemented a queue as a linked list. There are a couple of ways you might do it.\n\nThis style, or something like it, is something I see a lot:\n\nThe advantages are mostly that everybody can tell right off the bat what it does.\n\nBut I like this style:\n\nI think this is more elegant, but now it involves a double de-reference of . Does anybody have any feel for whether or not this extra indirection will be a significant performance loss?\n\nConversely, there are no more conditionals in the \"append\" function, and only one in the \"remove\" function. That could very well be a serious win in any pipelined architecture."
    },
    {
        "link": "https://geeksforgeeks.org/c-program-to-implement-singly-linked-list",
        "document": "A linked list is a linear data structure used to store elements of the same data type but not in contiguous memory locations. It is a collection of nodes where each node contains a data field and a next pointer indicating the address of the next node. So only the current node in the list knows where the next element of the list is stored. In this article, we will learn how to implement a singly linked list in C.\n\nImplementation of Singly Linked List in C\n\nA singly linked list is a type of linked list where only the address of the next node is stored in the current node along with the data field and the last node in the list contains NULL pointer. This makes it impossible to find the address of the particular node in the list without accessing the node previous to it. So we can only access the data sequentially in the node.\n\nRepresentation of Singly Linked List in C\n\nTo represent a node of a singly linked list in C, we will use a that will have two data members data and next where:\n• data: indicates the value stored in the node.\n• next: is a pointer that will store the address of the next node in the sequence.\n\nThe following diagram represents the structure of a singly linked list:\n\nThe pointer to the first node of the list is called head.\n\nFollowing are some of the basic operations which are required to manipulate the nodes of a singly linked list:\n\nNote: Here N represents the number of nodes in the linked list.\n\nFollowing is the algorithm to insert a node at the start of the singly linked list:\n\nFollowing is the algorithm to insert a node at a specific position of the singly linked list:\n\nFollowing is the algorithm to insert a node at the end of the singly linked list:\n\nDeletion Operations in a Singly Liked List in C\n\nFollowing is the algorithm to delete the first node of the singly linked list:\n\nFollowing is the algorithm to delete a node from a specific position in a linked list:\n\nFollowing is the algorithm to delete the last node of the linked list:\n\nFollowing is the algorithm to iterate through the singly linked list and print the value of data present in each node:\n\nThe following program illustrates how we can implement a singly linked list in C:\n\n// // C Program for Implementation of Singly Linked List // Function to insert a new element at the beginning of the singly linked list // Function to insert a new element at the end of the singly linked list // Function to insert a new element at a specific position in the singly linked list // Function to delete the first node of the singly linked list // Function to delete the last node of the singly linked list // Function to delete a node at a specific position in the singly linked list \"Linked list after inserting the node:10 at the beginning \"Linked list after inserting the node:20 at the end \"Linked list after inserting the node:5 at the end \"Linked list after inserting the node:30 at the end \"Linked list after inserting the node:15 at position 2 \"Linked list after deleting the first node: \"Linked list after deleting the last node: \"Linked list after deleting the node at position 1:\n\nFollowing are some articles that you can also read to improve your knowledge about the linked list data structure:"
    },
    {
        "link": "https://stackoverflow.com/questions/982388/how-to-implement-a-linked-list-in-c",
        "document": "In your case the head and tail could simply point to the beginning and end of a linked-list. With a singly linked-list, only the head is really needed. At it's most basic, a linked-list can be made by using just a struct like:\n\nand as long as list is always pointing to the beginning of the list and the last item has next set to NULL, you're fine and can use current_node to traverse the list. But sometimes to make traversing the list easier and to store any other data about the list, a head and tail token are used, and wrapped into their own structure, like you have done. So then your add and initialize functions would be something like (minus error detection)\n\nIn this case, since it's a singly linked-list, the tail is only really useful for appending items to the list. To insert an item, you'll have to traverse the list starting at the head. Where the tail really comes in handy is with a doubly-linked list, it allows you to traverse the list starting at either end. You can traverse this list like\n\nOften times, the head and tail are fully constructed nodes themselves used as a sentinel to denote the beginning and end of a list. They don't store data themselves (well rather, their data represent a sentinel token), they are just place holders for the front and back. This can make it easier to code some algorithms dealing with linked lists at the expense of having to have two extra elements. Overall, linked lists are flexible data structures with several ways to implement them.\n\noh yeah, and nik is right, playing with linked-lists are a great way to get good with pointers and indirection. And they are also a great way to practice recursion too! After you have gotten good with linked-list, try building a tree next and use recursion to walk the tree."
    },
    {
        "link": "https://stackoverflow.com/questions/8477110/which-c-standard-library-functions-use-malloc-under-the-hood",
        "document": "Usually, the only routines in the C99 standard that might use are the standard I/O functions (in where the file structure and the buffer used by it is often allocated as if by . Some of the locale handling may use dynamic memory. All the other routines have no need for dynamic memory allocation in general.\n\nNow, is any of that formally documented? No, I don't think it is. There is no blanket restriction 'the functions in the library shall not use '. (There are, however, restrictions on other functions - such as and and ; they may not be used by the implementation, and the implementation may not use any of the other functions that may return a pointer to a static memory location.) However, one of the reasons why the extremely useful function is not in the standard C library is (reportedly) because it does memory allocation. It also isn't completely clear whether this was a factor in the routines such as and in TR 24731-2 not making it into C1x, but it could have been a factor."
    },
    {
        "link": "https://en.cppreference.com/w/c/memory/malloc",
        "document": "If allocation succeeds, returns a pointer that is suitably aligned for any object type with fundamental alignment.\n\nIf is zero, the behavior of is implementation-defined. For example, a null pointer may be returned. Alternatively, a non-null pointer may be returned; but such a pointer should not be dereferenced, and should be passed to free to avoid memory leaks.\n\nis thread-safe: it behaves as though only accessing the memory locations visible through its argument, and not any static storage. A previous call to free, free_sized, and free_aligned_sized(since C23) or realloc that deallocates a region of memory synchronizes-with a call to that allocates the same or a part of the same region of memory. This synchronization occurs after any access to the memory by the deallocating function and before any access to the memory by . There is a single total order of all allocation and deallocation functions operating on each particular region of memory.\n\nOn success, returns the pointer to the beginning of newly allocated memory. To avoid a memory leak, the returned pointer must be deallocated with free() or realloc()."
    },
    {
        "link": "https://geeksforgeeks.org/dynamic-memory-allocation-in-c-using-malloc-calloc-free-and-realloc",
        "document": "In C, a variable defined in a function is stored in the stack memory. The requirement of this memory is that it needs to know the size of the data to memory at compile time (before the program runs). Also, once defined, we can neither change the size nor completely delete the memory.\n\nTo resolve this, C provides a feature called Dynamic Memory Allocation. It allows you to allocate memory at runtime, giving your program the ability to handle data of varying sizes. Dynamic resources are stored in the heap memory instead of the stack.\n\nThis feature is useful in a variety of situations. For example, changing the size of an array according to our requirement.\n\nAs we know, the size of an array in C is fixed and should be known at compile time. There can be two problems:\n\nThe size of the array is not sufficient to store all the elements. To resolve this, one might set the size to store the maximum theoretically possible elements. This creates another problem.\n\nThis size of the array is much more than what is required to store the elements. This leads to the wastage of memory.\n\nThis is where the dynamic memory allocation comes in. The size of the array can be increased if more elements are to be inserted and decreased of less elements are inserted. Moreover, there is no need to estimate the max possible size. The size can be decided at runtime according to the requirement.\n\nDynamic memory allocation is possible in C by using 4 library functions provided by <stdlib.h> library:\n\nLet’s discuss each of them one by one.\n\nThe malloc() (stands for memory allocation) function is used to allocate a single block of contiguous memory on the heap at runtime. The memory allocated by malloc() is uninitialized, meaning it contains garbage values.\n\nwhere size is the number of bytes to allocate.\n\nThis function returns a void pointer to the allocated memory that needs to be converted to the pointer of required type to be usable. If allocation fails, it returns NULL pointer.\n\nAssume that we want to create an array to store 5 integers. Since the size of int is 4 bytes, we need 5 * 4 bytes = 20 bytes of memory. This can be done as shown:\n\nIn the above malloc call, we hardcoded the number of bytes we need to store 5 integers. But we know that the size of the integer in C depends on the architecture. So, it is better to use the sizeof operator to find the size of type you want to store.\n\nMoreover, if there is no memory available, the malloc will fail and return NULL. So, it is recommended to check for failure by comparing the ptr to NULL.\n\nThe calloc() (stands for contiguous allocation) function is similar to malloc(), but it initializes the allocated memory to zero. It is used when you need memory with default zero values.\n\nwhere n is the number of elements and size is the size of each element in bytes.\n\nThis function also returns a void pointer to the allocated memory that is converted to the pointer of required type to be usable. If allocation fails, it returns NULL pointer.\n\nWe can take the example of malloc() and try to do it with calloc() function.\n\nThe memory allocated using functions malloc() and calloc() is not de-allocated on their own. The free() function is used to release dynamically allocated memory back to the operating system. It is essential to free memory that is no longer needed to avoid memory leaks.\n\nwhere ptr is the pointer to the allocated memory.\n\nAfter freeing a memory block, the pointer becomes invalid, and it is no longer pointing to a valid memory location.\n\nAfter calling free(), it is a good practice to set the pointer to NULL to avoid using a “dangling pointer,” which points to a memory location that has been deallocated.\n\nrealloc() function is used to resize a previously allocated memory block. It allows you to change the size of an existing memory allocation without needing to free the old memory and allocate a new block.\n\nwhere, ptr is the pointer to the previously allocated memory block and new_size is the reallocated size that the memory block should have in bytes.\n\nThis function returns a pointer to the newly allocated memory, or NULL if the reallocation fails. If it fails, the original memory block remains unchanged.\n\nSuppose we initially allocate memory for 5 integers but later need to expand the array to hold 10 integers. We can use realloc() to resize the memory block:\n\nIt is important to note that if realloc() fails and returns NULL, the original memory block is not freed, so you should not overwrite the original pointer until you’ve successfully allocated a new block. To prevent memory leaks, it’s a good practice to handle the NULL return value carefully:\n\nConsider the first scenario where we were having issues with the fixes size array. Let’s see how we can resolve both of these issues using dynamic memory allocation.\n\nIn this program, we are managing the memory allocated to the pointer ptr according to our needs by changing the size using realloc(). It can be a fun exercise to implement an array which grows according to the elements inserted in it. This kind of arrays are called dynamically growing arrays.\n\nAs useful as dynamic memory allocation is, it is also prone to errors that requires careful handling to avoid the high memory usage or even system crashes. Few of the common errors are given below:\n• Dangling Pointers : Using a pointer after freeing its memory can cause undefined behavior or crashes.\n• Fragmentation : Repeated allocations and deallocations can fragment memory, causing inefficient use of heap space.\n• Allocation Failures : If memory allocation fails, the program may crash unless the error is handled properly.\n\nThe functions malloc() and calloc() works very similar to one another. So, why there was the need for two such similar functions.\n\nIt turns out that even though they are similar, they have different use cases due to the minor difference between them regarding the memory initialization. malloc() does not initialize memory while calloc() initializes the memory with zero.\n\nCan we only create arrays dynamically?\n\nWhat happens if memory allocation fails?\n\nWhat happens when you don’t free memory after allocating?\n\nWhat is the limit of memory that we can allocate using these functions?\n\nCan we set the new size of allocated memory to 0 with realloc()?"
    },
    {
        "link": "https://man7.org/linux/man-pages/man3/free.3.html",
        "document": "Pages that refer to this page: memusage(1), brk(2), clone(2), getrlimit(2), io_uring_register(2), mlock(2), mmap(2), mremap(2), alloca(3), argz_add(3), asprintf(3), ausearch_add_expression(3), avc_init(3), backtrace(3), basename(3), canonicalize_file_name(3), cfree(3), CPU_SET(3), dbopen(3), end(3), exec(3), fopen(3), fseek(3), fts(3), ftw(3), getcwd(3), getgrent(3), getgrnam(3), getifaddrs(3), getline(3), getpwent(3), getpwnam(3), glob(3), hsearch(3), if_nameindex(3), lber-memory(3), ldap_memory(3), mallinfo(3), malloc_get_state(3), malloc_hook(3), malloc_info(3), malloc_stats(3), malloc_trim(3), malloc_usable_size(3), mallopt(3), mcheck(3), mpool(3), mtrace(3), numa(3), open_memstream(3), pam_conv(3), pmaddderived(3), __pmaf(3), pmagetlog(3), pmapi(3), pmarewritedata(3), pmarewritemeta(3), pmdachildren(3), pmdafetch(3), pmdainstance(3), pmdalabel(3), pmdatext(3), pmdatrace(3), pmdiscoverservices(3), pmextractvalue(3), pmfault(3), pmfetch(3), pmfetcharchive(3), pmfetchgroup(3), pmfreelabelsets(3), pmfreeprofile(3), pmfreeresult(3), pmfstring(3), pmgetchildren(3), pmgetchildrenstatus(3), pmgetindom(3), pmgetindomarchive(3), pmhash(3), pmlookupindomtext(3), pmlookuptext(3), pmnameall(3), pmnameid(3), pmnameindom(3), pmnameindomarchive(3), pmnewcontextzone(3), pmnewzone(3), pmnomem(3), __pmparsectime(3), pmparsehostattrsspec(3), pmparsehostspec(3), pmparseinterval(3), pmparsemetricspec(3), __pmparsetime(3), pmparsetimewindow(3), pmparseunitsstr(3), pmregisterderived(3), posix_memalign(3), pthread_setcancelstate(3), random_r(3), readdir(3), readline(3), realpath(3), scandir(3), sd_bus_creds_get_pid(3), sd_bus_error(3), sd_bus_path_encode(3), sd_get_seats(3), sd_journal_get_catalog(3), sd_journal_get_cursor(3), sd-json(3), sd-login(3), sd_machine_get_class(3), sd_path_lookup(3), sd_pid_get_owner_uid(3), sd_seat_get_active(3), sd_session_is_active(3), sd_uid_get_state(3), seccomp_syscall_resolve_name(3), security_class_to_string(3), selabel_get_digests_all_partial_matches(3), selinux_boolean_sub(3), selinux_getpolicytype(3), selinux_raw_context_to_color(3), setbuf(3), sscanf(3), strdup(3), string(3), tempnam(3), tracefs_event_get_file(3), tracefs_instance_set_affinity(3), tracefs_tracers(3), void(3type), wcsdup(3), proc_meminfo(5), environ(7), feature_test_macros(7), signal-safety(7), string_copying(7)"
    },
    {
        "link": "https://en.cppreference.com/w/c/memory",
        "document": ""
    }
]