[
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring",
        "document": "The object and array literal expressions provide an easy way to create ad hoc packages of data. The destructuring uses similar syntax but uses it on the left-hand side of the assignment instead. It performs the reverse operation of an array declaration, by declaring each element in the collection as a separate variable. As for objects, compare the two pairs of lines below, and see how there's a direct correspondence within each pair. const obj = { a, b, c }; const { a, b, c } = obj; // Equivalent to: // const a = obj.a, b = obj.b, c = obj.c; const obj = { prop1: x, prop2: y, prop3: z }; const { prop1: x, prop2: y, prop3: z } = obj; // Equivalent to: // const x = obj.prop1, y = obj.prop2, z = obj.prop3; This capability is similar to features present in languages such as Perl and Python. For features specific to array or object destructuring, refer to the individual examples below.\n\nFor both object and array destructuring, there are two kinds of destructuring patterns: binding pattern and assignment pattern, with slightly different syntaxes. In binding patterns, the pattern starts with a declaration keyword ( , , or ). Then, each individual property must either be bound to a variable or further destructured. const obj = { a: 1, b: { c: 2 } }; const { a, b: { c: d }, } = obj; // Two variables are bound: `a` and `d` All variables share the same declaration, so if you want some variables to be re-assignable but others to be read-only, you may have to destructure twice — once with , once with . const obj = { a: 1, b: { c: 2 } }; const { a } = obj; // a is constant let { b: { c: d }, } = obj; // d is re-assignable In many other syntaxes where the language binds a variable for you, you can use a binding destructuring pattern. These include:\n• The looping variable of , and loops; In assignment patterns, the pattern does not start with a keyword. Each destructured property is assigned to a target of assignment — which may either be declared beforehand with or , or is a property of another object — in general, anything that can appear on the left-hand side of an assignment expression. const numbers = []; const obj = { a: 1, b: 2 }; ({ a: numbers[0], b: numbers[1] } = obj); // The properties `a` and `b` are assigned to properties of `numbers` Note: The parentheses around the assignment statement are required when using object literal destructuring without a declaration. is not valid stand-alone syntax, as the on the left-hand side is considered a block and not an object literal according to the rules of expression statements. However, is valid, as is . If your coding style does not include trailing semicolons, the expression needs to be preceded by a semicolon, or it may be used to execute a function on the previous line. Note that the equivalent binding pattern of the code above is not valid syntax: const numbers = []; const obj = { a: 1, b: 2 }; const { a: numbers[0], b: numbers[1] } = obj; // This is equivalent to: // const numbers[0] = obj.a; // const numbers[1] = obj.b; // Which definitely is not valid. You can only use assignment patterns as the left-hand side of the assignment operator. You cannot use them with compound assignment operators such as or .\n\nYou can end a destructuring pattern with a rest property . For array destructuring, it collects remaining elements of the iterable into a new array called (or any name you give it). For object destructuring, it copies all enumerable own properties of the object that are not already picked off by the destructuring pattern into a new object called . More formally, the syntax is called \"rest elements\" in array destructuring and \"rest properties\" in object destructuring, but we often just collectively call them \"rest property\". const { a, ...others } = { a: 1, b: 2, c: 3 }; console.log(others); // { b: 2, c: 3 } const [first, ...others2] = [1, 2, 3]; console.log(others2); // [2, 3] The rest property must be the last in the pattern, and must not have a trailing comma. const [a, ...b,] = [1, 2, 3]; // SyntaxError: rest element may not have a trailing comma // Always consider using rest operator as the last element\n\nconst foo = [\"one\", \"two\", \"three\"]; const [red, yellow, green] = foo; console.log(red); // \"one\" console.log(yellow); // \"two\" console.log(green); // \"three\" Destructuring with more elements than the source In an array destructuring from an array of length N specified on the right-hand side of the assignment, if the number of variables specified on the left-hand side of the assignment is greater than N, only the first N variables are assigned values. The values of the remaining variables will be undefined. const foo = [\"one\", \"two\"]; const [red, yellow, green, blue] = foo; console.log(red); // \"one\" console.log(yellow); // \"two\" console.log(green); // undefined console.log(blue); // undefined Two variables values can be swapped in one destructuring expression. Without destructuring, swapping two values requires a temporary variable (or, in some low-level languages, the XOR-swap trick). It's always been possible to return an array from a function. Destructuring can make working with an array return value more concise. In this example, returns the values as its output, which can be parsed in a single line with destructuring. You can ignore return values that you're not interested in: You can also ignore all returned values: Though in this case, it's probably clearer to just call the function and not use destructuring at all. You don't have to use the return value. Using a binding pattern as the rest property The rest property of array destructuring can be another array or object binding pattern. The inner destructuring destructures from the array created after collecting the rest elements, so you cannot access any properties present on the original iterable in this way. These binding patterns can even be nested, as long as each rest property is the last in the list. On the other hand, object destructuring can only have an identifier as the rest property. const { a, ...{ b } } = { a: 1, b: 2 }; // SyntaxError: `...` must be followed by an identifier in declaration contexts let a, b; ({ a, ...{ b } } = { a: 1, b: 2 }); // SyntaxError: `...` must be followed by an assignable reference in assignment contexts When the regular expression method finds a match, it returns an array containing first the entire matched portion of the string and then the portions of the string that matched each parenthesized group in the regular expression. Destructuring allows you to unpack the parts out of this array easily, ignoring the full match if it is not needed. Using array destructuring on any iterable Array destructuring calls the iterable protocol of the right-hand side. Therefore, any iterable, not necessarily arrays, can be destructured. Non-iterables cannot be destructured as arrays. Iterables are only iterated until all bindings are assigned. const obj = { *[Symbol.iterator]() { for (const v of [0, 1, 2, 3]) { console.log(v); yield v; } }, }; const [a, b] = obj; // Only logs 0 and 1 The rest binding is eagerly evaluated and creates a new array, instead of using the old iterable. const obj = { *[Symbol.iterator]() { for (const v of [0, 1, 2, 3]) { console.log(v); yield v; } }, }; const [a, b, ...rest] = obj; // Logs 0 1 2 3 console.log(rest); // [2, 3] (an array)\n\nA property can be unpacked from an object and assigned to a variable with a different name than the object property. Here, for example, takes from the object the property named and assigns it to a local variable named . Assigning to new variable names and providing default values\n• Unpacked from an object and assigned to a variable with a different name.\n• Assigned a default value in case the unpacked value is . Objects passed into function parameters can also be unpacked into variables, which may then be accessed within the function body. As for object assignment, the destructuring syntax allows for the new variable to have the same name or a different name than the original property, and to assign default values for the case when the original object does not define the property. Consider this object, which contains information about a user. Here we show how to unpack a property of the passed object into a variable with the same name. The parameter value indicates that the property of the object passed to the function should be unpacked into a variable with the same name, which can then be used within the function. You can define the name of the unpacked variable. Here we unpack the property named , and rename it to for use within the function body. Nested objects can also be unpacked. The example below shows the property being unpacked into a variable called . function whois({ displayName, fullName: { firstName: name } }) { return `${displayName} is ${name}`; } console.log(whois(user)); // \"jdoe is Jane\" Default values can be specified using , and will be used as variable values if a specified property does not exist in the passed object. Below we show a function where the default size is , default co-ordinates are and default radius is 25. In the function signature for above, the destructured left-hand side has a default value of an empty object . You could have also written the function without that default. However, if you leave out that default value, the function will look for at least one argument to be supplied when invoked, whereas in its current form, you can call without supplying any parameters. Otherwise, you need to at least supply an empty object literal. For more information, see Default parameters > Destructured parameter with default value assignment. For of iteration and destructuring const people = [ { name: \"Mike Smith\", family: { mother: \"Jane Smith\", father: \"Harry Smith\", sister: \"Samantha Smith\", }, age: 35, }, { name: \"Tom Jones\", family: { mother: \"Norah Jones\", father: \"Richard Jones\", brother: \"Howard Jones\", }, age: 25, }, ]; for (const { name: n, family: { father: f }, } of people) { console.log(`Name: ${n}, Father: ${f}`); } // \"Name: Mike Smith, Father: Harry Smith\" // \"Name: Tom Jones, Father: Richard Jones\" Computed property names, like on object literals, can be used with destructuring. Destructuring can be used with property names that are not valid JavaScript identifiers by providing an alternative identifier that is valid.\n\nObject destructuring is almost equivalent to property accessing. This means if you try to destruct a primitive value, the value will get wrapped into the corresponding wrapper object and the property is accessed on the wrapper object. Same as accessing properties, destructuring or throws a . const { a } = undefined; // TypeError: Cannot destructure property 'a' of 'undefined' as it is undefined. const { b } = null; // TypeError: Cannot destructure property 'b' of 'null' as it is null. This happens even when the pattern is empty. const {} = null; // TypeError: Cannot destructure 'null' as it is null. Array and object destructuring can be combined. Say you want the third element in the array below, and then you want the property in the object, you can do the following: const props = [ { id: 1, name: \"Fizz\" }, { id: 2, name: \"Buzz\" }, { id: 3, name: \"FizzBuzz\" }, ]; const [, , { name }] = props; console.log(name); // \"FizzBuzz\" The prototype chain is looked up when the object is deconstructed When deconstructing an object, if a property is not accessed in itself, it will continue to look up along the prototype chain."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment",
        "document": "The object and array literal expressions provide an easy way to create ad hoc packages of data. The destructuring uses similar syntax but uses it on the left-hand side of the assignment instead. It performs the reverse operation of an array declaration, by declaring each element in the collection as a separate variable. As for objects, compare the two pairs of lines below, and see how there's a direct correspondence within each pair. const obj = { a, b, c }; const { a, b, c } = obj; // Equivalent to: // const a = obj.a, b = obj.b, c = obj.c; const obj = { prop1: x, prop2: y, prop3: z }; const { prop1: x, prop2: y, prop3: z } = obj; // Equivalent to: // const x = obj.prop1, y = obj.prop2, z = obj.prop3; This capability is similar to features present in languages such as Perl and Python. For features specific to array or object destructuring, refer to the individual examples below.\n\nFor both object and array destructuring, there are two kinds of destructuring patterns: binding pattern and assignment pattern, with slightly different syntaxes. In binding patterns, the pattern starts with a declaration keyword ( , , or ). Then, each individual property must either be bound to a variable or further destructured. const obj = { a: 1, b: { c: 2 } }; const { a, b: { c: d }, } = obj; // Two variables are bound: `a` and `d` All variables share the same declaration, so if you want some variables to be re-assignable but others to be read-only, you may have to destructure twice — once with , once with . const obj = { a: 1, b: { c: 2 } }; const { a } = obj; // a is constant let { b: { c: d }, } = obj; // d is re-assignable In many other syntaxes where the language binds a variable for you, you can use a binding destructuring pattern. These include:\n• The looping variable of , and loops; In assignment patterns, the pattern does not start with a keyword. Each destructured property is assigned to a target of assignment — which may either be declared beforehand with or , or is a property of another object — in general, anything that can appear on the left-hand side of an assignment expression. const numbers = []; const obj = { a: 1, b: 2 }; ({ a: numbers[0], b: numbers[1] } = obj); // The properties `a` and `b` are assigned to properties of `numbers` Note: The parentheses around the assignment statement are required when using object literal destructuring without a declaration. is not valid stand-alone syntax, as the on the left-hand side is considered a block and not an object literal according to the rules of expression statements. However, is valid, as is . If your coding style does not include trailing semicolons, the expression needs to be preceded by a semicolon, or it may be used to execute a function on the previous line. Note that the equivalent binding pattern of the code above is not valid syntax: const numbers = []; const obj = { a: 1, b: 2 }; const { a: numbers[0], b: numbers[1] } = obj; // This is equivalent to: // const numbers[0] = obj.a; // const numbers[1] = obj.b; // Which definitely is not valid. You can only use assignment patterns as the left-hand side of the assignment operator. You cannot use them with compound assignment operators such as or .\n\nYou can end a destructuring pattern with a rest property . For array destructuring, it collects remaining elements of the iterable into a new array called (or any name you give it). For object destructuring, it copies all enumerable own properties of the object that are not already picked off by the destructuring pattern into a new object called . More formally, the syntax is called \"rest elements\" in array destructuring and \"rest properties\" in object destructuring, but we often just collectively call them \"rest property\". const { a, ...others } = { a: 1, b: 2, c: 3 }; console.log(others); // { b: 2, c: 3 } const [first, ...others2] = [1, 2, 3]; console.log(others2); // [2, 3] The rest property must be the last in the pattern, and must not have a trailing comma. const [a, ...b,] = [1, 2, 3]; // SyntaxError: rest element may not have a trailing comma // Always consider using rest operator as the last element\n\nconst foo = [\"one\", \"two\", \"three\"]; const [red, yellow, green] = foo; console.log(red); // \"one\" console.log(yellow); // \"two\" console.log(green); // \"three\" Destructuring with more elements than the source In an array destructuring from an array of length N specified on the right-hand side of the assignment, if the number of variables specified on the left-hand side of the assignment is greater than N, only the first N variables are assigned values. The values of the remaining variables will be undefined. const foo = [\"one\", \"two\"]; const [red, yellow, green, blue] = foo; console.log(red); // \"one\" console.log(yellow); // \"two\" console.log(green); // undefined console.log(blue); // undefined Two variables values can be swapped in one destructuring expression. Without destructuring, swapping two values requires a temporary variable (or, in some low-level languages, the XOR-swap trick). It's always been possible to return an array from a function. Destructuring can make working with an array return value more concise. In this example, returns the values as its output, which can be parsed in a single line with destructuring. You can ignore return values that you're not interested in: You can also ignore all returned values: Though in this case, it's probably clearer to just call the function and not use destructuring at all. You don't have to use the return value. Using a binding pattern as the rest property The rest property of array destructuring can be another array or object binding pattern. The inner destructuring destructures from the array created after collecting the rest elements, so you cannot access any properties present on the original iterable in this way. These binding patterns can even be nested, as long as each rest property is the last in the list. On the other hand, object destructuring can only have an identifier as the rest property. const { a, ...{ b } } = { a: 1, b: 2 }; // SyntaxError: `...` must be followed by an identifier in declaration contexts let a, b; ({ a, ...{ b } } = { a: 1, b: 2 }); // SyntaxError: `...` must be followed by an assignable reference in assignment contexts When the regular expression method finds a match, it returns an array containing first the entire matched portion of the string and then the portions of the string that matched each parenthesized group in the regular expression. Destructuring allows you to unpack the parts out of this array easily, ignoring the full match if it is not needed. Using array destructuring on any iterable Array destructuring calls the iterable protocol of the right-hand side. Therefore, any iterable, not necessarily arrays, can be destructured. Non-iterables cannot be destructured as arrays. Iterables are only iterated until all bindings are assigned. const obj = { *[Symbol.iterator]() { for (const v of [0, 1, 2, 3]) { console.log(v); yield v; } }, }; const [a, b] = obj; // Only logs 0 and 1 The rest binding is eagerly evaluated and creates a new array, instead of using the old iterable. const obj = { *[Symbol.iterator]() { for (const v of [0, 1, 2, 3]) { console.log(v); yield v; } }, }; const [a, b, ...rest] = obj; // Logs 0 1 2 3 console.log(rest); // [2, 3] (an array)\n\nA property can be unpacked from an object and assigned to a variable with a different name than the object property. Here, for example, takes from the object the property named and assigns it to a local variable named . Assigning to new variable names and providing default values\n• Unpacked from an object and assigned to a variable with a different name.\n• Assigned a default value in case the unpacked value is . Objects passed into function parameters can also be unpacked into variables, which may then be accessed within the function body. As for object assignment, the destructuring syntax allows for the new variable to have the same name or a different name than the original property, and to assign default values for the case when the original object does not define the property. Consider this object, which contains information about a user. Here we show how to unpack a property of the passed object into a variable with the same name. The parameter value indicates that the property of the object passed to the function should be unpacked into a variable with the same name, which can then be used within the function. You can define the name of the unpacked variable. Here we unpack the property named , and rename it to for use within the function body. Nested objects can also be unpacked. The example below shows the property being unpacked into a variable called . function whois({ displayName, fullName: { firstName: name } }) { return `${displayName} is ${name}`; } console.log(whois(user)); // \"jdoe is Jane\" Default values can be specified using , and will be used as variable values if a specified property does not exist in the passed object. Below we show a function where the default size is , default co-ordinates are and default radius is 25. In the function signature for above, the destructured left-hand side has a default value of an empty object . You could have also written the function without that default. However, if you leave out that default value, the function will look for at least one argument to be supplied when invoked, whereas in its current form, you can call without supplying any parameters. Otherwise, you need to at least supply an empty object literal. For more information, see Default parameters > Destructured parameter with default value assignment. For of iteration and destructuring const people = [ { name: \"Mike Smith\", family: { mother: \"Jane Smith\", father: \"Harry Smith\", sister: \"Samantha Smith\", }, age: 35, }, { name: \"Tom Jones\", family: { mother: \"Norah Jones\", father: \"Richard Jones\", brother: \"Howard Jones\", }, age: 25, }, ]; for (const { name: n, family: { father: f }, } of people) { console.log(`Name: ${n}, Father: ${f}`); } // \"Name: Mike Smith, Father: Harry Smith\" // \"Name: Tom Jones, Father: Richard Jones\" Computed property names, like on object literals, can be used with destructuring. Destructuring can be used with property names that are not valid JavaScript identifiers by providing an alternative identifier that is valid.\n\nObject destructuring is almost equivalent to property accessing. This means if you try to destruct a primitive value, the value will get wrapped into the corresponding wrapper object and the property is accessed on the wrapper object. Same as accessing properties, destructuring or throws a . const { a } = undefined; // TypeError: Cannot destructure property 'a' of 'undefined' as it is undefined. const { b } = null; // TypeError: Cannot destructure property 'b' of 'null' as it is null. This happens even when the pattern is empty. const {} = null; // TypeError: Cannot destructure 'null' as it is null. Array and object destructuring can be combined. Say you want the third element in the array below, and then you want the property in the object, you can do the following: const props = [ { id: 1, name: \"Fizz\" }, { id: 2, name: \"Buzz\" }, { id: 3, name: \"FizzBuzz\" }, ]; const [, , { name }] = props; console.log(name); // \"FizzBuzz\" The prototype chain is looked up when the object is deconstructed When deconstructing an object, if a property is not accessed in itself, it will continue to look up along the prototype chain."
    },
    {
        "link": "https://stackoverflow.com/questions/57025363/destructuring-array-and-accessing-the-first-element",
        "document": "I made and API call using fetch to get JSON data. That data is then passed to my function , which accepts a parameter that uses de-structuring to obtain results.\n\nIn , I want to de-structure the first item into the array, into a data variable. Next, use object de-structuring to obtain the and properties of the data.\n\nI have tried de-structuring the array, but is not working, also when i do on the data I receive, I get \"object\".\n\nHere is format of the JSON data\n\nI expect to de-structure the first item in the array into a data variable. And also to use object de-structuring to obtain the and properties of data."
    },
    {
        "link": "https://stackoverflow.com/questions/47383025/destructuring-arrays-of-arrays-and-getting-first-element-at-the-same-time",
        "document": "I have a question about array destructuring. I have a data shaped like this :\n\nAnd I was wondering if there was a \"one liner\" way to get to the first element of the first array, something a little bit like this :\n\nRight now I'm doing something like this but I find it less \"elegant\" (I know it's not a problem at all, just trying to expand my knowledge =)\n\nThank you in advance for your help !"
    },
    {
        "link": "https://javascript.info/destructuring-assignment",
        "document": "The two most used data structures in JavaScript are and .\n• Objects allow us to create a single entity that stores data items by key.\n• Arrays allow us to gather data items into an ordered list.\n\nHowever, when we pass these to a function, we may not need all of it. The function might only require certain elements or properties.\n\nDestructuring assignment is a special syntax that allows us to “unpack” arrays or objects into a bunch of variables, as sometimes that’s more convenient.\n\nDestructuring also works well with complex functions that have a lot of parameters, default values, and so on. Soon we’ll see that.\n\nHere’s an example of how an array is destructured into variables:\n\nNow we can work with variables instead of array members.\n\nIt looks great when combined with or other array-returning methods:\n\nAs you can see, the syntax is simple. There are several peculiar details though. Let’s see more examples to understand it better.\n\nUsually, if the array is longer than the list at the left, the “extra” items are omitted.\n\nFor example, here only two items are taken, and the rest is just ignored:\n\nIf we’d like also to gather all that follows – we can add one more parameter that gets “the rest” using three dots :\n\nThe value of is the array of the remaining array elements.\n\nWe can use any other variable name in place of , just make sure it has three dots before it and goes last in the destructuring assignment.\n\nIf the array is shorter than the list of variables on the left, there will be no errors. Absent values are considered undefined:\n\nIf we want a “default” value to replace the missing one, we can provide it using :\n\nDefault values can be more complex expressions or even function calls. They are evaluated only if the value is not provided.\n\nFor instance, here we use the function for two defaults:\n\nPlease note: the will run only for the missing value ( ).\n\nThe destructuring assignment also works with objects.\n\nWe should have an existing object on the right side, that we want to split into variables. The left side contains an object-like “pattern” for corresponding properties. In the simplest case, that’s a list of variable names in .\n\nProperties , and are assigned to the corresponding variables.\n\nThe order does not matter. This works too:\n\nThe pattern on the left side may be more complex and specify the mapping between properties and variables.\n\nIf we want to assign a property to a variable with another name, for instance, make go into the variable named , then we can set the variable name using a colon:\n\nThe colon shows “what : goes where”. In the example above the property goes to , property goes to , and is assigned to the same name.\n\nFor potentially missing properties we can set default values using , like this:\n\nJust like with arrays or function parameters, default values can be any expressions or even function calls. They will be evaluated if the value is not provided.\n\nIn the code below asks for , but not for :\n\nWe also can combine both the colon and equality:\n\nIf we have a complex object with many properties, we can extract only what we need:\n\nWhat if the object has more properties than we have variables? Can we take some and then assign the “rest” somewhere?\n\nWe can use the rest pattern, just like we did with arrays. It’s not supported by some older browsers (IE, use Babel to polyfill it), but works in modern ones.\n\nIt looks like this:\n\nIf an object or an array contains other nested objects and arrays, we can use more complex left-side patterns to extract deeper portions.\n\nIn the code below has another object in the property and an array in the property . The pattern on the left side of the assignment has the same structure to extract values from them:\n\nAll properties of object except which is absent in the left part, are assigned to corresponding variables:\n\nFinally, we have , , , and from the default value.\n\nNote that there are no variables for and , as we take their content instead.\n\nThere are times when a function has many parameters, most of which are optional. That’s especially true for user interfaces. Imagine a function that creates a menu. It may have a width, a height, a title, an item list and so on.\n\nHere’s a bad way to write such a function:\n\nIn real-life, the problem is how to remember the order of arguments. Usually, IDEs try to help us, especially if the code is well-documented, but still… Another problem is how to call a function when most parameters are ok by default.\n\nThat’s ugly. And becomes unreadable when we deal with more parameters.\n\nDestructuring comes to the rescue!\n\nWe can pass parameters as an object, and the function immediately destructurizes them into variables:\n\nWe can also use more complex destructuring with nested objects and colon mappings:\n\nThe full syntax is the same as for a destructuring assignment:\n\nThen, for an object of parameters, there will be a variable for the property , with by default.\n\nPlease note that such destructuring assumes that does have an argument. If we want all values by default, then we should specify an empty object:\n\nWe can fix this by making the default value for the whole object of parameters:\n\nIn the code above, the whole arguments object is by default, so there’s always something to destructurize.\n• Destructuring assignment allows for instantly mapping an object or array onto many variables.\n• This means that property should go into the variable and, if no such property exists, then the value should be used. Object properties that have no mapping are copied to the object.\n• The first item goes to ; the second goes into , and all the rest makes the array .\n• It’s possible to extract data from nested arrays/objects, for that the left side must have the same structure as the right one."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/shift",
        "document": "The method shifts all values to the left by 1 and decrements the length by 1, resulting in the first element being removed. If the property is 0, is returned.\n\nThe method has similar behavior to , but applied to the last element in an array.\n\nThe method is a mutating method. It changes the length and the content of . In case you want the value of to be the same, but return a new array with the first element removed, you can use instead.\n\nThe method is generic. It only expects the value to have a property and integer-keyed properties. Although strings are also array-like, this method is not suitable to be applied on them, as strings are immutable."
    },
    {
        "link": "https://w3schools.com/jsref/jsref_shift.asp",
        "document": "W3Schools offers a wide range of services and products for beginners and professionals, helping millions of people everyday to learn and master new skills."
    },
    {
        "link": "https://stackoverflow.com/questions/38096687/how-can-i-remove-the-first-element-of-an-array-and-return-the-rest",
        "document": "The method removes the first element of an array. Then you can return the remaining:\n\nAs others have suggested, you could also use :"
    },
    {
        "link": "https://geeksforgeeks.org/javascript-array-shift-method",
        "document": "The shift() method in JavaScript is used to remove the first element of an array, reducing the array’s length by one. This method is particularly useful for scenarios where elements need to be processed in the order they were added, such as in queue-like structures.\n• None This method does not accept any parameter.\n• None This function returns the removed first element of the array. If the array is empty then this function returns undefined.\n• None It can be used with other JavaScript objects that behave like arrays (e.g., array-like objects).\n• None Indices of the remaining elements are adjusted, decrementing by one to fill the gap left by the removed element.\n\nExample 1: Removing the First Element from the Array\n\nThe function removes the first element from using the method. The removed element is stored in the variable, , which is then logged to the console along with the modified array.\n\nThe function attempts to remove the first element from an empty array using the method. Since the array is empty, returns , which is logged to the console along with the unchanged array.\n\nExample 3: Removing the First Element from the Nested Array\n\nThe function func() removes the first element from the nested array using the shift() method. The removed element is stored in the variable value, which is then logged to the console along with the modified array.\n\nWhat does the\n\nWhat happens to the indices of the remaining elements after using\n\nWhat happens if you use\n\nWhat are common use cases for the\n\nWe have a complete list of Javascript Array methods, to check those please go through this Javascript Array Complete reference article.\n\nWe have a Cheat Sheet on Javascript where we covered all the important topics of Javascript to check those please go through Javascript Cheat Sheet-A Basic guide to JavaScript."
    },
    {
        "link": "https://w3schools.com/js/js_array_methods.asp",
        "document": "The property returns the length (size) of an array:\n\nThe JavaScript method converts an array to a string of (comma separated) array values.\n\nGet the third element of fruits using at(): Try it Yourself » Get the third element of fruits using []: Try it Yourself »\n\nThe method returns an indexed element from an array.\n\nThe method returns the same as .\n\nThe method is supported in all modern browsers since March 2022:\n\nMany languages allow like [-1] to access elements from the end of an object / array / string. This is not possible in JavaScript, because [] is used for accessing both arrays and objects. obj[-1] refers to the value of key -1, not to the last property of the object. The method was introduced in ES2022 to solve this problem.\n\nThe method also joins all array elements into a string.\n\nIt behaves just like , but in addition you can specify the separator:\n\nWhen you work with arrays, it is easy to remove elements and add new elements.\n\nThis is what popping and pushing is:\n\nPopping items out of an array, or pushing items into an array.\n\nThe method removes the last element from an array:\n\nThe method returns the value that was \"popped out\":\n\nThe method adds a new element to an array (at the end):\n\nThe method returns the new array length:\n\nShifting is equivalent to popping, but working on the first element instead of the last.\n\nThe method removes the first array element and \"shifts\" all other elements to a lower index.\n\nThe method returns the value that was \"shifted out\":\n\nThe method adds a new element to an array (at the beginning), and \"unshifts\" older elements:\n\nThe method returns the new array length:\n\nArray elements are accessed using their index number:\n\nThe property provides an easy way to append a new element to an array:\n\nThe method creates a new array by merging (concatenating) existing arrays:\n\nThe method can also take strings as arguments:\n\nThe method copies array elements to another position in an array:\n\nFlattening an array is the process of reducing the dimensionality of an array.\n\nFlattening is useful when you want to convert a multi-dimensional array into a one-dimensional array.\n\nThe method creates a new array with sub-array elements concatenated to a specified depth.\n\nJavaScript Array is supported in all modern browsers since January 2020:\n\nThe method first maps all elements of an array and then creates a new array by flattening the array.\n\nJavaScript Array is supported in all modern browsers since January 2020:\n\nThe method adds new items to an array.\n\nThe method slices out a piece of an array.\n\nThe method can be used to add new items to an array:\n\nThe first parameter (2) defines the position where new elements should be added (spliced in).\n\nThe second parameter (0) defines how many elements should be removed.\n\nThe rest of the parameters (\"Lemon\" , \"Kiwi\") define the new elements to be added.\n\nThe method returns an array with the deleted items:\n\nWith clever parameter setting, you can use to remove elements without leaving \"holes\" in the array:\n\nThe first parameter (0) defines the position where new elements should be added (spliced in).\n\nThe second parameter (1) defines how many elements should be removed.\n\nThe rest of the parameters are omitted. No new elements will be added.\n\nES2023 added the Array toSpliced() method as a safe way to splice an array without altering the original array.\n\nThe difference between the new toSpliced() method and the old splice() method is that the new method creates a new array, keeping the original array unchanged, while the old method altered the original array.\n\nThe method slices out a piece of an array into a new array:\n\nThe method can take two arguments like .\n\nThe method then selects elements from the start argument, and up to (but not including) the end argument.\n\nIf the end argument is omitted, like in the first examples, the method slices out the rest of the array.\n\nJavaScript automatically converts an array to a comma separated string when a primitive value is expected.\n\nThis is always the case when you try to output an array.\n\nThese two examples will produce the same result:\n\nSearching arrays are covered in the next chapter of this tutorial.\n\nSorting arrays covers the methods used to sort arraysg.\n\nIterating arrays covers methods that operate on all array elements."
    }
]