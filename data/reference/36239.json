[
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API",
        "document": "The WebSocket API makes it possible to open a two-way interactive communication session between the user's browser and a server. With this API, you can send messages to a server and receive responses without having to poll the server for a reply.\n\nThe WebSocket API provides two alternative mechanisms for creating and using web socket connections: the interface and the interface.\n• The interface is stable and has good browser and server support. However it doesn't support backpressure. As a result, when messages arrive faster than the application can process them it will either fill up the device's memory by buffering those messages, become unresponsive due to 100% CPU usage, or both.\n• The interface is a -based alternative to . It uses the Streams API to handle receiving and sending messages, meaning that socket connections can take advantage of stream backpressure automatically, regulating the speed of reading or writing to avoid bottlenecks in the application. However, is non-standard and currently only supported in one rendering engine.\n\nAdditionally, the WebTransport API is expected to replace the WebSocket API for many applications. WebTransport is a versatile, low-level API that provides backpressure and many other features not supported by either or , such as unidirectional streams, out-of-order delivery, and unreliable data transmission via datagrams. WebTransport is more complex to use than WebSockets and its cross-browser support is not as wide, but it enables the implementation of sophisticated solutions. If standard WebSocket connections are a good fit for your use case and you need wide browser compatibility, you should employ the WebSockets API to get up and running quickly. However, if your application requires a non-standard custom solution, then you should use the WebTransport API."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/API/WebSocket",
        "document": "This feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015 .\n\n* Some parts of this feature may have varying levels of support."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/API",
        "document": "When writing code for the Web, there are a large number of Web APIs available. Below is a list of all the APIs and interfaces (object types) that you may be able to use while developing your Web app or site.\n\nWeb APIs are typically used with JavaScript, although this doesn't always have to be the case."
    },
    {
        "link": "https://caniuse.com?search=websocket",
        "document": "Protocol framework to send and receive data from servers using [HTTP3](/http3). Similar to [WebSockets](/websockets) but with support for multiple streams, unidirectional streams, out-of-order delivery, and reliable as well as unreliable transport."
    },
    {
        "link": "https://lambdatest.com/web-technologies/websockets",
        "document": "Web Sockets on IE is fully supported on 10-11, and not supported on 5.5-9 IE versions.\n\nWeb Sockets on Edge is fully supported on all Edge versions.\n\nWeb Sockets on Firefox is fully supported on 11-138, partially supported on 4-10, and not supported on 2-3 Firefox versions.\n\nWeb Sockets on Chrome is fully supported on 16-136 and partially supported on 4-15 Chrome versions.\n\nWeb Sockets on Safari is fully supported on 7.1-18.4, partially supported on 5.1-6, and not supported on 3.2-4 Safari versions.\n\nWeb Sockets on Opera is fully supported on 12.1-114, partially supported on 11.6-12, and not supported on 9.5-10 Opera versions.\n\nWeb Sockets on Safari on iOS is fully supported on 6-18.4, partially supported on 4.2-5, and not supported on 3.2-4 Safari on iOS versions.\n\nWeb Sockets on Android Browser is fully supported on 4.4-133, and not supported on 2.3-4 Android Browser versions.\n\nWeb Sockets on Opera Mobile is fully supported on 12.1-80, partially supported on 11.5-12, and not supported on 10-10 Opera Mobile versions.\n\nWeb Sockets on Chrome for Android is fully supported on all Chrome for Android versions.\n\nWeb Sockets on Firefox for Android is fully supported on all Firefox for Android versions.\n\nWeb Sockets on Samsung Internet is fully supported on all Samsung Internet versions."
    },
    {
        "link": "https://github.com/websockets/ws",
        "document": "ws is a simple to use, blazing fast, and thoroughly tested WebSocket client and server implementation.\n\nNote: This module does not work in the browser. The client in the docs is a reference to a backend with the role of a client in the WebSocket communication. Browser clients must use the native object. To make the same code work seamlessly on Node.js and the browser, you can use one of the many wrappers available on npm, like isomorphic-ws.\n• FAQ\n• How to get the IP address of the client?\n• How to detect and close broken connections?\n• How to connect via a proxy?\n\nbufferutil is an optional module that can be installed alongside the ws module:\n\nThis is a binary addon that improves the performance of certain operations such as masking and unmasking the data payload of the WebSocket frames. Prebuilt binaries are available for the most popular platforms, so you don't necessarily need to have a C++ compiler installed on your machine.\n\nTo force ws to not use bufferutil, use the environment variable. This can be useful to enhance security in systems where a user can put a package in the package search path of an application of another user, due to how the Node.js resolver algorithm works.\n\nIf you are running on an old version of Node.js (prior to v18.14.0), ws also supports the utf-8-validate module:\n\nThis contains a binary polyfill for .\n\nTo force ws not to use utf-8-validate, use the environment variable.\n\nSee for Node.js-like documentation of ws classes and utility functions.\n\nws supports the permessage-deflate extension which enables the client and server to negotiate a compression algorithm and its parameters, and then selectively apply it to the data payloads of each WebSocket message.\n\nThe extension is disabled by default on the server and enabled by default on the client. It adds a significant overhead in terms of performance and memory consumption so we suggest to enable it only if it is really needed.\n\nNote that Node.js has a variety of issues with high-performance compression, where increased concurrency, especially on Linux, can lead to catastrophic memory fragmentation and slow performance. If you intend to use permessage-deflate in production, it is worthwhile to set up a test representative of your workload and ensure Node.js/zlib will handle it with acceptable performance and memory usage.\n\nTuning of permessage-deflate can be done via the options defined below. You can also use and , which is passed directly into the creation of raw deflate/inflate streams.\n\nSee the docs for more options.\n\nThe client will only use the extension if it is supported and enabled on the server. To always disable the extension on the client, set the option to .\n\nAlso see the provided example using .\n\nA client WebSocket broadcasting to all connected WebSocket clients, including itself.\n\nA client WebSocket broadcasting to every other connected WebSocket clients, excluding itself.\n\nFor a full example with a browser client communicating with a ws server, see the examples folder.\n\nOtherwise, see the test cases.\n\nThe remote IP address can be obtained from the raw socket.\n\nWhen the server runs behind a proxy like NGINX, the de-facto standard is to use the header.\n\nSometimes, the link between the server and the client can be interrupted in a way that keeps both the server and the client unaware of the broken state of the connection (e.g. when pulling the cord).\n\nIn these cases, ping messages can be used as a means to verify that the remote endpoint is still responsive.\n\nPong messages are automatically sent in response to ping messages as required by the spec.\n\nJust like the server example above, your clients might as well lose connection without knowing it. You might want to add a ping listener on your clients to prevent that. A simple implementation would be:\n\nUse a custom implementation like https-proxy-agent or socks-proxy-agent.\n\nWe're using the GitHub releases for changelog entries."
    },
    {
        "link": "https://npmjs.com/package/ws",
        "document": "ws is a simple to use, blazing fast, and thoroughly tested WebSocket client and server implementation.\n\nNote: This module does not work in the browser. The client in the docs is a reference to a backend with the role of a client in the WebSocket communication. Browser clients must use the native object. To make the same code work seamlessly on Node.js and the browser, you can use one of the many wrappers available on npm, like isomorphic-ws.\n• FAQ\n• How to get the IP address of the client?\n• How to detect and close broken connections?\n• How to connect via a proxy?\n\nbufferutil is an optional module that can be installed alongside the ws module:\n\nThis is a binary addon that improves the performance of certain operations such as masking and unmasking the data payload of the WebSocket frames. Prebuilt binaries are available for the most popular platforms, so you don't necessarily need to have a C++ compiler installed on your machine.\n\nTo force ws to not use bufferutil, use the environment variable. This can be useful to enhance security in systems where a user can put a package in the package search path of an application of another user, due to how the Node.js resolver algorithm works.\n\nIf you are running on an old version of Node.js (prior to v18.14.0), ws also supports the utf-8-validate module:\n\nThis contains a binary polyfill for .\n\nTo force ws not to use utf-8-validate, use the environment variable.\n\nSee for Node.js-like documentation of ws classes and utility functions.\n\nws supports the permessage-deflate extension which enables the client and server to negotiate a compression algorithm and its parameters, and then selectively apply it to the data payloads of each WebSocket message.\n\nThe extension is disabled by default on the server and enabled by default on the client. It adds a significant overhead in terms of performance and memory consumption so we suggest to enable it only if it is really needed.\n\nNote that Node.js has a variety of issues with high-performance compression, where increased concurrency, especially on Linux, can lead to catastrophic memory fragmentation and slow performance. If you intend to use permessage-deflate in production, it is worthwhile to set up a test representative of your workload and ensure Node.js/zlib will handle it with acceptable performance and memory usage.\n\nTuning of permessage-deflate can be done via the options defined below. You can also use and , which is passed directly into the creation of raw deflate/inflate streams.\n\nSee the docs for more options.\n\nThe client will only use the extension if it is supported and enabled on the server. To always disable the extension on the client, set the option to .\n\nAlso see the provided example using .\n\nA client WebSocket broadcasting to all connected WebSocket clients, including itself.\n\nA client WebSocket broadcasting to every other connected WebSocket clients, excluding itself.\n\nFor a full example with a browser client communicating with a ws server, see the examples folder.\n\nOtherwise, see the test cases.\n\nThe remote IP address can be obtained from the raw socket.\n\nWhen the server runs behind a proxy like NGINX, the de-facto standard is to use the header.\n\nSometimes, the link between the server and the client can be interrupted in a way that keeps both the server and the client unaware of the broken state of the connection (e.g. when pulling the cord).\n\nIn these cases, ping messages can be used as a means to verify that the remote endpoint is still responsive.\n\nPong messages are automatically sent in response to ping messages as required by the spec.\n\nJust like the server example above, your clients might as well lose connection without knowing it. You might want to add a ping listener on your clients to prevent that. A simple implementation would be:\n\nUse a custom implementation like https-proxy-agent or socks-proxy-agent.\n\nWe're using the GitHub releases for changelog entries."
    },
    {
        "link": "https://medium.com/voodoo-engineering/websockets-on-production-with-node-js-bdc82d07bb9f",
        "document": "In this article, we will use the ”ws” module to illustrate some points but the principles remain the same regardless of the library used. I wrote this article to create a kind of checklist about what to keep in mind before release a project using Websocket and Node.js.\n\nMost of the time you will find a lot of great articles to learn how to implement and use Websockets. It shows you examples of very basic applications using real-time communication.\n\nBut what happens in real life? When you release an API on your production you must take into account more than just if your code works. You monitor your production, you use CI, a logging system (I really hope you do!), etc.\n\nThis is the same thing for Websockets. You should be careful about some important points.\n\nJWT is a powerful tool to manage security on API but it works for Websocket based system too. It’s as simple as :\n• Server-side: before each connection, check the token inside headers.\n\nLike HTTP, WS protocol has its secure version, called WSS. On your server, you should configure SSL and a different port as you do for HTTPS. On the client-side just use wss:// instead of ws://.\n\nMost of the time, a WS connection will stay idle after the connection is established. Except when you use it for business logic, and for the keep-alive protocol (ping/pong requests), a Websocket doesn’t use a lot of resources.\n\nSetting up an autoscaling system based on memory and/or CPU is not always the best idea and this is why automatically scaling a WebSocket application is not really easy.\n\nEven the number of requests per server is not a good indicator because your connections are stateful, and every user will not reconnect very often. The best way to do it is to scale on open connections per server. You can have access to this value with CloudWatch if you use AWS for example.\n\nAnother thing to keep in mind is the tuning of your instances. The best way to handle a lot of persistent connections is to increase some values of your operating system and/or your application. For Node.js under a Linux based OS, you can refer to this great article: https://blog.jayway.com/2015/04/13/600k-concurrent-websocket-connections-on-aws-using-node-js/\n\nWhen working with Websockets, you build an event-based system. The best solution to scale your backend with such a system is to use a message broker. It will allow you to work with a powerful messaging pattern called Pub/Sub. A lot of technologies support this kind of pattern like Redis, RabbitMQ or Kafka. The good news is most of them are managed by Cloud providers and can scale automatically.\n\nA common issue when you work with WebSocket is broken connections. It appears when one of the endpoints (client or server) does not respond, or when it’s not reachable anymore. To manage this we need a logic on both server-side and client-side to gracefully close the connection. The idea is very simple: create a kind of heartbeat function to check periodically if a connection is still alive. Otherwise, close the connection.\n\nSome libraries, like WS, do not always provide a mechanism to automatically reconnect to the server. You will probably need this feature if your backend unexpectedly restarts (which can happen after each deployment ;)). Here we just need to automatically reconnect the client after it catches a close event.\n\nIf your connections have a long life, which is probably the case if you use Websocket, then you should refresh them (basically close them and open a new one). This is useful when you do some stuff when the connection is established and if you want the client to be up to date with the server. Or if you want to use another token if it expires soon.\n\nThere is no advice here on how to do it because it highly depends on your business logic. Anyway, a good recommendation is to refresh the connection every hour then you can change this interval if necessary.\n\nMost APM solutions don’t support WebSocket monitoring, they are mainly focused on classical request/response through HTTP protocol. They are well designed for API and web servers.\n\nAnyway, even if your APM doesn’t support Websocket instrumentation, you can use custom transactions and/or custom attributes to do it.\n\nSee how with elastic APM or with NewRelic agent.\n\nNow you can see your events in Kibana:"
    },
    {
        "link": "https://ably.com/blog/web-app-websockets-nodejs",
        "document": "WebSockets let developers build realtime functionality into their apps by enabling the sending off small chunks of data over a single persistent connection, in both directions. Using WebSockets in the front end is fairly straightforward, as there is a WebSocket API built into all modern browsers. To use them on the server, a backend application is required.\n\nThis is where Node.js comes in. Node.js can maintain many hundreds of WebSockets connections simultaneously. Unlike JavaScript in the browser, Node.js does not have a WebSocket solution as-is to handle connection upgrades, fallbacks, header settings, and everything else required to establish and maintain a WebSocket connection. This is why developers commonly use libraries to manage this for them. There are a few common WebSocket server libraries that make managing WebSockets easier – notably WS, SockJS and Socket.IO.\n\nIn this post, we will look at implementing both the WS and SockJS libraries with Node.js as the WebSocket server. We'll look at how each library is used, and why you might choose it for your project. We will then talk about the reasons one might choose a third-party service to manage their WebSockets connections.\n\nWS is a library for creating WebSocket servers for Node.js. It's quite low level: you listen to incoming connection requests and respond to raw messages as either strings or byte buffers. Since WebSockets are natively supported in all modern browsers, it is possible to work with WS on the server and then the browser's WebSocket API on the client.\n\nIn order to demonstrate how to set up WebSockets with Node and WS, we have built a demo app that shares users' cursor positions in realtime.\n\nThis is a demo to create a colored cursor icon for every connected user. When they move their mouse around, their cursor icon moves on the screen and is also shown as moving on the screen of every connected user. This happens in realtime, as the mouse is being moved.\n\nFirst, we’ll need to initialize a Node.js project. In the command line in the folder you want your project to exist, run the following:\n\nFor this you can go with the defaults, but set the to be .\n\nYou will also need the ‘ws’ npm module added as a dependency:\n\nNext, you’ll need to create ‘server.js’ to hold our server code. You will need to require the WS npm library and use the method to create a new WebSocket server on port 7071 (no significance, any port is fine!).\n\nNote: For brevity’s sake we call it in our code. Any resemblance to WebSocket Secure (often referred to as WSS) is a coincidence.\n\nNext, create a Map to store a client's metadata (any data we wish to associate with a WebSocket client):\n\nWhenever a new WebSocket client connects to the server, there will be an event emitted called connection. Subscribe to the WSS event using the function, providing the below callback function.\n\nEvery time a client connects, we generate a new unique ID, which is used to identify them. Clients are also assigned a cursor color by using ; this generates a number between 0 and 360, which corresponds to the hue value of an HSV color. The ID and cursor color are then added to an object that we'll call and we're using the Map to associate them with our WebSocket instance.\n\nThe map is a dictionary – we can retrieve this metadata by calling and providing a WebSocket connection instance later on.\n\nUsing the newly connected WebSocket connection instance, we subscribe to that instance's event, and provide a callback function that will be triggered whenever this specific client sends a message to the server.\n\nNote: This event is on the WebSocket connection instance ( ) itself, and not on the WebSocketServer instance ( ).\n\nThe message will be a String, however, we want to interpret messages between our server and clients as JSON objects. Whenever our server receives a message, we use JSON.parse to get the message contents and load our client metadata for this socket from our Map using .\n\nWe're going to add our two metadata properties to the message as and keys respectively:\n\nThen we our message again, and send it out to every connected client, so that every client can receive the message from the sending client.\n\nFinally, when a client closes its connection, we remove its from our .\n\nAt the bottom we have a function to generate a unique ID, which we used earlier.\n\nThis server implementation , sending any message it has received to all connected clients.\n\nWe now need to write some client-side code to connect to the WebSocket server, and transmit the user’s cursor position as it moves.\n\nWe're going to start with some standard HTML5 boilerplate in a new HTML file, which you can call :\n\nNext we add a reference to a style sheet, and an file that we're adding as an ES Module (using ). You can find the contents of ‘style.css’ in this demo’s GitHub repo.\n\nThe body contains a single which contains an of a cursor. We're going to use JavaScript to clone this template whenever a new user connects to our server.\n\nNext, we need to use JavaScript to connect to the . Create a new file, , to hold our JavaScript code, and add the following:\n\nWe call the function, which resolves a promise containing the connected . We will define this function later.\n\nOnce connected, we add a handler for to the . The is very simple: it consists of the current and properties from the mouse movement event (the horizontal and vertical coordinates of the cursor within the application's viewport).\n\nWe stringify this object, and send it through our now connected connection instance:\n\nNow we need to add another handler, this time for an event to the WebSocket instance . Remember that every time the receives a message, it'll forward it to all connected clients.\n\nYou might notice that the syntax here is slightly different from the server-side code. That's because we're using the browser’s native class, rather than the library .\n\nWhen we receive a message over the , we parse the property of the message, which contains the stringified data that the handler sent to the , along with the additional and properties that the server side code adds to the message.\n\nUsing the parsed , we call . This function returns an HTML element that is part of the DOM, and we'll look at how it works later.\n\nWe then use the x and y values from the to adjust the cursor position using a .\n\nOur code relies on two utility functions. The first is which opens a connection to our and then returns a that resolves when the property is .\n\nThis means that we can just this function, and we'll know that we have a connected and working connection.\n\nWe also use our function.\n\nThis function first attempts to find any existing element with the HTML data attribute where the value is the same as the property in our message. If it finds one, we know that we've already created a cursor for this user, and we just need to return it so the calling code can adjust its position.\n\nIf we can't find an existing element, we our , add the data-attribute with the current ID to it, and append it to the before returning it.\n\nNow when you run the web application, each user viewing the page will have a cursor that appears on everyone's screens because we are sending the data to all the clients using .\n\nIf you’ve been following along with the tutorial, then you can run:\n\nIf not, you can clone a working version of the demo\n\nThis demo includes two applications: a web app that we serve through Snowpack, and a Node.js web server. The NPM start task will spin up both the API and the web server.\n\nThis should look as follows:\n\nHowever, if you are running the demo in a browser that does not support WebSockets (eg IE9 or below), or if you are restricted by particularly tight corporate proxies, you will get an error saying that the browser can’t establish a connection:\n\nThis is because the WS library offers no fallback transfer protocols if WebSockets are unavailable. If this is a requirement for your project, or you want to have a higher level of reliability of delivery for your messages, then you will need a library that offers multiple transfer protocols, such as SockJS.\n\nSockJS is a library that mimics the native WebSockets API. Additionally, it will fall back to HTTP whenever a WebSocket fails to connect, or if the browser being used doesn’t support WebSockets. Like WS, SockJS requires a server counterpart; its maintainers provide both a JavaScript client library and a Node.js server library.\n\nUsing SockJS in the client is similar to the native WebSockets API, with only a few minor differences. We can swap out WS in the demo built previously and use SockJS instead to include fallback support.\n\nUpdating the Interactive Cursor Position Sharing Demo to use SockJS\n\nTo use SockJS in the client, we first need to load the SockJS JavaScript library from their CDN. In the head of the index.html document we built earlier, add the following line above the script include of index.js:\n\nIn the index.js file, we then update the JavaScript to use SockJS. Instead of the object, we’ll now use a object. Inside the function, we’ll establish the connection with the SockJS server:\n\nNote: SockJS requires a prefix path on the server URL. The rest of the index.js file requires no change.\n\nNow to update the server.js file (or if you’re using the snowpack version on GitHub, api/index.js file) to make our server use SockJS. This means changing the names of a few event hooks, but the API is very similar to WS.\n\nFirst, we need to install In your terminal run:\n\nThen we need to require the module and the built-in HTTP module from Node. Delete the line that requires ws and replace it with the following:\n\nWe then change the declaration of to become:\n\nAt the very bottom of this file, we’ll create the HTTPS server and add the SockJS HTTP handlers:\n\nWe map the handlers to a prefix supplied in a configuration object ( . We tell the HTTP server to listen on port 7071 (arbitrarily chosen) on all the network interfaces on the machine.\n\nThe final job is to update the event names to work with SockJS:\n\nAnd that’s it, the demo will now run with WebSockets where they are supported; and where they aren’t, it will degrade to use comet long polling over HTTP. This latter fallback option will show a slightly less smooth cursor movement, but it is more functional than no connection at all!\n\nIf you’ve been following along with the tutorial, then you can run:\n\nIf not, you can clone a working version of the demo:\n\nThis demo includes two applications: a web app that we serve through Snowpack, and a Node.js web server. The NPM start task spins up both the API and the web server.\n\nScaling up the number of connections\n\nYou might notice that in both examples we're storing the state in the Node.js – there is a Map that keeps track of connected WebSockets and their associated metadata. This means that for the solution to work, and for every user to see one another, they have to be connected to the exact same .\n\nThe number of active users you can support is thus directly related to how much hardware your server has. Node.js is pretty good at managing concurrency, but once you reach a few hundred to a few thousand users, you're going to need to scale your hardware vertically to keep all the users in sync.\n\nScaling vertically is often an expensive proposition, and you'll always be faced with a performance ceiling of the most powerful piece of hardware you can procure. (It’s also not elastic and you have to do it ahead of time.) Once you've run out of vertical scaling options, you'll be forced to consider horizontal scaling – and horizontally scaling WebSockets is significantly more difficult.\n\nTo scale regular application servers that don't require persistent connections, the standard approach is to introduce a load balancer in front of them. Load balancers route traffic to whichever node is currently available (either by measuring node performance, or using a round-robin system).\n\nWebSockets are fundamentally harder to scale, because connections to your need to be persistent. And even once you've scaled out your nodes both vertically and horizontally, you also need to provide a solution for sharing data between the nodes. Any state needs to be stored out-of-process – this usually involves using something like Redis, or a traditional database, to ensure that all the nodes have the same view of state.\n\nThis is just the tip of the iceberg, so if you’re interested in what additional issues you need to be aware of as you scale up your realtime applications, you can read more on the challenges of scaling WebSockets here.\n\nAbly is a realtime PaaS that gives you the tools and infrastructure to build your own live experiences. on top of Ably saves you time and resources as your engineering team won’t need to architect, build, and maintain the complex global realtime infrastructure that live experiences require. Ably handles the complexities of sustaining up to millions of connections, with plenty more useful tooling and functionality.\n\nSpecifically, working with Ably will give you:\n• Predictable low latencies: Ably’s global edge network delivers video and other realtime data efficiently and with a median latency of less than 50 ms, enabling the predictability and stability live commerce demands.\n• Highly scalable, highly available infrastructure: Global brands such as Toyota, BlueJeans, and Hubspot have proven that Ably’s infrastructure scale effortlessly and reliably to millions of concurrent users.\n• Integrations with common languages and frameworks: With client libraries and tailored documentation for more than 25 languages and frameworks, Ably is ready to integrate with your tech stack.\n• Reduced build and maintenance costs: The savings of using Ably are significant, with a typical 21% lower cost and up to $1 million saved in year one.\n\nYou can try Ably free to see how our realtime PaaS makes it easier and more cost-effective to build your live commerce platform.\n• Building realtime apps with Node.js and WebSockets: client-side considerationsThe Ably async/await post we promised\n• Common WebSocket security vulnerabilities and how to prevent them"
    },
    {
        "link": "https://stackoverflow.com/questions/16392260/which-websocket-library-to-use-with-node-js",
        "document": "Currently there is a plethora of websocket libraries for node.js, the most popular seem to be:\n\nHowever I can't find any solid concrete comparisons between any of them... Apparently Socket.io was awesome, but has become quite dated and has failing builds. Both ws and websocket-node claim they are the fastest. And engine.io seems new, but a lot heavier than the lighter aletarntives.\n\nIt would be amazing if we or someone could put together an answer that serves as a guide on which socket library to use and when, as well as a comparison between them."
    }
]