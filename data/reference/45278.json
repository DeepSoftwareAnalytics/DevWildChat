[
    {
        "link": "https://reddit.com/r/csharp/comments/1d9eise/what_is_best_practice_regarding_namespaces",
        "document": "I come from a Node.js background where you just import files directly, so I'm not quite sure how to organise my C# namespaces.\n\nShould it broadly be folder-based i.e. each file in a particular folder has the same namespace? Do you have one namespace per \"feature\"? Do you give a each file it's own unique namespace?\n\nI've really struggled to find information about this online, so thought I'd reach out here."
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/types/namespaces",
        "document": "Namespaces are heavily used in C# programming in two ways. First, .NET uses namespaces to organize its many classes, as follows:\n\nSystem is a namespace and Console is a class in that namespace. The keyword can be used so that the complete name isn't required, as in the following example:\n\nFor more information, see the using Directive.\n\nThe C# templates for .NET 6 use top level statements. Your application may not match the code in this article, if you've already upgraded to the .NET 6. For more information see the article on New C# templates generate top level statements The .NET 6 SDK also adds a set of implicit directives for projects that use the following SDKs: These implicit directives include the most common namespaces for the project type. For more information, see the article on Implicit using directives\n\nSecond, declaring your own namespaces can help you control the scope of class and method names in larger programming projects. Use the namespace keyword to declare a namespace, as in the following example:\n\nThe name of the namespace must be a valid C# identifier name.\n\nYou can declare a namespace for all types defined in that file, as shown in the following example:\n\nThe advantage of this new syntax is that it's simpler, saving horizontal space and braces. That makes your code easier to read.\n\nNamespaces have the following properties:\n• They're delimited by using the operator.\n• The directive obviates the requirement to specify the name of the namespace for every class.\n• The namespace is the \"root\" namespace: always refers to the .NET System namespace.\n\nFor more information, see the Namespaces section of the C# language specification."
    },
    {
        "link": "https://stackoverflow.com/questions/8934570/c-sharp-namespaces-and-assemblies-best-practice",
        "document": "To follow up on what Eric Lippert said:\n\nIt is traditional for nearly all code in a assembly to live in a single namespace and sub-namespaces, with the assembly named after the namespace.\n\nFor example, if I was given an assembly with the file name Contoso.PartnerPortal.Services.dll, the assembly's short name would traditionally be , and I would expect the bulk of the code to live in the namespace (and sub-namespaces).\n\nHowever not all classes in the namespace will necessarily live in the Contoso.PartnerPortal.Services.dll assembly. If a Contoso.PartnerPortal.dll assembly exists it may well have some classes in the namespace too.\n\nOne common use of this is with interfaces. If the interfaces live in Contoso.PartnerPortal.dll then code in that assembly can use the interface without referencing the Contoso.PartnerPortal.Services.dll. This is important, since Contoso.PartnerPortal.Services.dll (which will implement the interfaces) will likely need to reference Contoso.PartnerPortal.dll and circular assembly references are best avoided.\n\nAssemblies that are excessively large may make compilation take longer than necessary. This is because the compilers have not had support for incremental compilation in quite a long time. Thus an entire module must be compiled as a unit. Since multi-module assemblies are not frequently used this basically implies that you must compile a whole assembly at once.\n\nIf you split a large assembly into several smaller ones, only the changed assembly and those that reference will get recompiled. That saves some time.\n\nOn the other extreme having over 600 assemblies in one application (I work on such a monster in my day job) has its own set of problems. For example, the shadow copy feature of ASP.net has had performance issues working with that many assemblies (keep in mind that this is in addition to the large number of assemblies created when ASP.net compiles the aspx and ascx files)."
    },
    {
        "link": "https://stackoverflow.com/questions/28686989/organizing-namespaces-and-classes-in-directories",
        "document": "When I put a class file inside a folder, Resharper suggest me to update the namespace. So if I have the file (Class), it will suggest the namespace .\n\nThe problem is that I have a subfolder called too, that have components for the class. And it is confliting with namespaces. For instance:\n\nWhat is the best method to turn around that?\n\nCurrently I'm organizing like that:\n\nSo note that I rename the \"main\" class to to avoid conflict, but I keep a more accurate name in the filename. But it is ugly, not?"
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/standard/design-guidelines/names-of-namespaces",
        "document": "As with other naming guidelines, the goal when naming namespaces is creating sufficient clarity for the programmer using the framework to immediately know what the content of the namespace is likely to be. The following template specifies the general rule for naming namespaces:\n\nThe following are examples:\n\n✔️ DO prefix namespace names with a company name to prevent namespaces from different companies from having the same name.\n\n✔️ DO use a stable, version-independent product name at the second level of a namespace name.\n\n❌ DO NOT use organizational hierarchies as the basis for names in namespace hierarchies, because group names within corporations tend to be short-lived. Organize the hierarchy of namespaces around groups of related technologies.\n\n✔️ DO use PascalCasing, and separate namespace components with periods (e.g., ). If your brand employs nontraditional casing, you should follow the casing defined by your brand, even if it deviates from normal namespace casing.\n\n✔️ CONSIDER using plural namespace names where appropriate.\n\nFor example, use instead of . Brand names and acronyms are exceptions to this rule, however. For example, use instead of .\n\n❌ DO NOT use the same name for a namespace and a type in that namespace.\n\nFor example, do not use as a namespace name and then also provide a class named in the same namespace. Several compilers require such types to be fully qualified.\n\n❌ DO NOT introduce generic type names such as , , , and .\n\nThere is a very high probability that doing so will lead to type name conflicts in common scenarios. You should qualify the generic type names ( , , , ).\n\nThere are specific guidelines for avoiding type name conflicts for different categories of namespaces.\n• Namespaces belonging to a single application model are very often used together, but they are almost never used with namespaces of other application models. For example, the System.Windows.Forms namespace is very rarely used together with the System.Web.UI namespace. The following is a list of well-known application model namespace groups: ❌ DO NOT give the same name to types in namespaces within a single application model. For example, do not add a type named to the System.Web.UI.Adapters namespace, because the System.Web.UI namespace already contains a type named .\n• This group contains namespaces that are rarely imported during development of common applications. For example, namespaces are mainly used when developing programming tools. Avoiding conflicts with types in these namespaces is not critical.\n• Core namespaces include all namespaces, excluding namespaces of the application models and the Infrastructure namespaces. Core namespaces include, among others, , , , and . ❌ DO NOT give types names that would conflict with any type in the Core namespaces. For example, never use as a type name. It would conflict with System.IO.Stream, a very commonly used type.\n• This category includes all namespaces with the same first two namespace nodes ), such as and . It is important that types belonging to a single technology do not conflict with each other. ❌ DO NOT assign type names that would conflict with other types within a single technology. ❌ DO NOT introduce type name conflicts between types in technology namespaces and an application model namespace (unless the technology is not intended to be used with the application model).\n\nReprinted by permission of Pearson Education, Inc. from Framework Design Guidelines: Conventions, Idioms, and Patterns for Reusable .NET Libraries, 2nd Edition by Krzysztof Cwalina and Brad Abrams, published Oct 22, 2008 by Addison-Wesley Professional as part of the Microsoft Windows Development Series."
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/namespaces",
        "document": "C# programs are organized using namespaces. Namespaces are used both as an “internal” organization system for a program, and as an “external” organization system—a way of presenting program elements that are exposed to other programs.\n\nUsing directives (§14.5) are provided to facilitate the use of namespaces.\n\nA compilation_unit consists of zero or more extern_alias_directives followed by zero or more using_directives followed by zero or one global_attributes followed by zero or more namespace_member_declarations. The compilation_unit defines the overall structure of the input.\n\nA C# program consists of one or more compilation units. When a C# program is compiled, all of the compilation units are processed together. Thus, compilation units can depend on each other, possibly in a circular fashion.\n\nThe extern_alias_directives of a compilation unit affect the using_directives, global_attributes and namespace_member_declarations of that compilation unit, but have no effect on other compilation units.\n\nThe using_directives of a compilation unit affect the global_attributes and namespace_member_declarations of that compilation unit, but have no effect on other compilation units.\n\nThe global_attributes (§22.3) of a compilation unit permit the specification of attributes for the target assembly and module. Assemblies and modules act as physical containers for types. An assembly may consist of several physically separate modules.\n\nThe namespace_member_declarations of each compilation unit of a program contribute members to a single declaration space called the global namespace.\n\nA namespace_declaration consists of the keyword namespace, followed by a namespace name and body, optionally followed by a semicolon.\n\nA namespace_declaration may occur as a top-level declaration in a compilation_unit or as a member declaration within another namespace_declaration. When a namespace_declaration occurs as a top-level declaration in a compilation_unit, the namespace becomes a member of the global namespace. When a namespace_declaration occurs within another namespace_declaration, the inner namespace becomes a member of the outer namespace. In either case, the name of a namespace shall be unique within the containing namespace.\n\nNamespaces are implicitly and the declaration of a namespace cannot include any access modifiers.\n\nWithin a namespace_body, the optional using_directives import the names of other namespaces, types and members, allowing them to be referenced directly instead of through qualified names. The optional namespace_member_declarations contribute members to the declaration space of the namespace. Note that all using_directives shall appear before any member declarations.\n\nThe qualified_identifier of a namespace_declaration may be a single identifier or a sequence of identifiers separated by “ ” tokens. The latter form permits a program to define a nested namespace without lexically nesting several namespace declarations.\n\nNamespaces are open-ended, and two namespace declarations with the same fully qualified name (§7.8.2) contribute to the same declaration space (§7.3).\n\nAn extern_alias_directive introduces an identifier that serves as an alias for a namespace. The specification of the aliased namespace is external to the source code of the program and applies also to nested namespaces of the aliased namespace.\n\nThe scope of an extern_alias_directive extends over the using_directives, global_attributes and namespace_member_declarations of its immediately containing compilation_unit or namespace_body.\n\nWithin a compilation unit or namespace body that contains an extern_alias_directive, the identifier introduced by the extern_alias_directive can be used to reference the aliased namespace. It is a compile-time error for the identifier to be the word .\n\nThe alias introduced by an extern_alias_directive is very similar to the alias introduced by a using_alias_directive. See §14.5.2 for more detailed discussion of extern_alias_directives and using_alias_directives.\n\nis a contextual keyword (§6.4.4) and only has special meaning when it immediately follows the keyword in an extern_alias_directive.\n\nAn error occurs if a program declares an extern alias for which no external definition is provided.\n\nUsing directives facilitate the use of namespaces and types defined in other namespaces. Using directives impact the name resolution process of namespace_or_type_names (§7.8) and simple_names (§12.8.4), but unlike declarations, using_directives do not contribute new members to the underlying declaration spaces of the compilation units or namespaces within which they are used.\n\nA using_alias_directive (§14.5.2) introduces an alias for a namespace or type.\n\nA using_static_directive (§14.5.4) imports the nested types and static members of a type.\n\nThe scope of a using_directive extends over the namespace_member_declarations of its immediately containing compilation unit or namespace body. The scope of a using_directive specifically does not include its peer using_directives. Thus, peer using_directives do not affect each other, and the order in which they are written is insignificant. In contrast, the scope of an extern_alias_directive includes the using_directives defined in the same compilation unit or namespace body.\n\nA using_alias_directive introduces an identifier that serves as an alias for a namespace or type within the immediately enclosing compilation unit or namespace body.\n\nWithin global attributes and member declarations in a compilation unit or namespace body that contains a using_alias_directive, the identifier introduced by the using_alias_directive can be used to reference the given namespace or type.\n\nWithin using directives, global attributes and member declarations in a compilation unit or namespace body that contains an extern_alias_directive, the identifier introduced by the extern_alias_directive can be used to reference the associated namespace.\n\nAn extern_alias_directive or using_alias_directive makes an alias available within a particular compilation unit or namespace body, but it does not contribute any new members to the underlying declaration space. In other words, an alias directive is not transitive, but, rather, affects only the compilation unit or namespace body in which it occurs.\n\nEach extern_alias_directive or using_alias_directive in a compilation_unit or namespace_body contributes a name to the alias declaration space (§7.3) of the immediately enclosing compilation_unit or namespace_body. The identifier of the alias directive shall be unique within the corresponding alias declaration space. The alias identifier need not be unique within the global declaration space or the declaration space of the corresponding namespace.\n\nJust like regular members, names introduced by alias_directives are hidden by similarly named members in nested scopes.\n\nThe order in which extern_alias_directives are written has no significance. Likewise, the order in which using_alias_directives are written has no significance, but all using_alias_directives shall come after all extern_alias_directives in the same compilation unit or namespace body. Resolution of the namespace_or_type_name referenced by a using_alias_directive is not affected by the using_alias_directive itself or by other using_directives in the immediately containing compilation unit or namespace body, but may be affected by extern_alias_directives in the immediately containing compilation unit or namespace body. In other words, the namespace_or_type_name of a using_alias_directive is resolved as if the immediately containing compilation unit or namespace body had no using_directives but has the correct set of extern_alias_directives.\n\nA using_alias_directive can create an alias for any namespace or type, including the namespace within which it appears and any namespace or type nested within that namespace.\n\nAccessing a namespace or type through an alias yields exactly the same result as accessing that namespace or type through its declared name.\n\nAlthough each part of a partial type (§15.2.7) is declared within the same namespace, the parts are typically written within different namespace declarations. Thus, different extern_alias_directives and using_directives can be present for each part. When interpreting simple names (§12.8.4) within one part, only the extern_alias_directives and using_directives of the namespace bodies and compilation unit enclosing that part are considered. This may result in the same identifier having different meanings in different parts.\n\nUsing aliases can name a closed constructed type, but cannot name an unbound generic type declaration without supplying type arguments.\n\nA using_namespace_directive imports the types contained in a namespace into the immediately enclosing compilation unit or namespace body, enabling the identifier of each type to be used without qualification.\n\nWithin member declarations in a compilation unit or namespace body that contains a using_namespace_directive, the types contained in the given namespace can be referenced directly.\n\nA using_namespace_directive imports the types contained in the given namespace, but specifically does not import nested namespaces.\n\nUnlike a using_alias_directive, a using_namespace_directive may import types whose identifiers are already defined within the enclosing compilation unit or namespace body. In effect, names imported by a using_namespace_directive are hidden by similarly named members in the enclosing compilation unit or namespace body.\n\nBecause names may be ambiguous when more than one imported namespace introduces the same type name, a using_alias_directive is useful to disambiguate the reference.\n\nFurthermore, when more than one namespace or type imported by using_namespace_directives or using_static_directives in the same compilation unit or namespace body contain types or members by the same name, references to that name as a simple_name are considered ambiguous.\n\nLike a using_alias_directive, a using_namespace_directive does not contribute any new members to the underlying declaration space of the compilation unit or namespace, but, rather, affects only the compilation unit or namespace body in which it appears.\n\nThe namespace_name referenced by a using_namespace_directive is resolved in the same way as the namespace_or_type_name referenced by a using_alias_directive. Thus, using_namespace_directives in the same compilation unit or namespace body do not affect each other and can be written in any order.\n\nA using_static_directive imports the nested types and static members contained directly in a type declaration into the immediately enclosing compilation unit or namespace body, enabling the identifier of each member and type to be used without qualification.\n\nWithin member declarations in a compilation unit or namespace body that contains a using_static_directive, the accessible nested types and static members (except extension methods) contained directly in the declaration of the given type can be referenced directly.\n\nA using_static_directive specifically does not import extension methods directly as static methods, but makes them available for extension method invocation (§12.8.10.3).\n\nA using_static_directive only imports members and types declared directly in the given type, not members and types declared in base classes.\n\nAmbiguities between multiple using_namespace_directives and using_static_directives are discussed in §14.5.3.\n\nA namespace_member_declaration is either a namespace_declaration (§14.3) or a type_declaration (§14.7).\n\nA compilation unit or a namespace body can contain namespace_member_declarations, and such declarations contribute new members to the underlying declaration space of the containing compilation unit or namespace body.\n\nA type_declaration is a class_declaration (§15.2), a struct_declaration (§16.2), an interface_declaration (§18.2), an enum_declaration (§19.2), or a delegate_declaration (§20.2).\n\nA type_declaration can occur as a top-level declaration in a compilation unit or as a member declaration within a namespace, class, or struct.\n\nWhen a type declaration for a type occurs as a top-level declaration in a compilation unit, the fully qualified name (§7.8.2) of the type declaration is the same as the unqualified name of the declaration (§7.8.2). When a type declaration for a type occurs within a namespace, class, or struct declaration, the fully qualified name (§7.8.3) of the type declarationis , where is the fully qualified name of the containing namespace, class, or struct declaration, and is the unqualified name of the declaration.\n\nA type declared within a class or struct is called a nested type (§15.3.9).\n\nThe permitted access modifiers and the default access for a type declaration depend on the context in which the declaration takes place (§7.5.2):\n• Types declared in compilation units or namespaces can have or access. The default is access.\n• Types declared in classes can have , , , , , or access. The default is access.\n• Types declared in structs can have , , or access. The default is access.\n\nThe namespace alias qualifier makes it possible to guarantee that type name lookups are unaffected by the introduction of new types and members. The namespace alias qualifier always appears between two identifiers referred to as the left-hand and right-hand identifiers. Unlike the regular qualifier, the left-hand identifier of the qualifier is looked up only as an extern or using alias.\n\nA qualified_alias_member provides explicit access to the global namespace and to extern or using aliases that are potentially hidden by other entities.\n\nA qualified_alias_member can be used as a namespace_or_type_name (§7.8) or as the left operand in a member_access (§12.8.7).\n\nA qualified_alias_member consists of two identifiers, referred to as the left-hand and right-hand identifiers, seperated by the token and optionally followed by a type_argument_list. When the left-hand identifier is global then the global namespace is searched for the right-hand identifier. For any other left-hand identifier, that identifier is looked up as an extern or using alias (§14.4 and §14.5.2). A compile-time error occurs if there is no such alias or the alias references a type. If the alias references a namespace then that namespace is searched for the right-hand identifier.\n\nA qualified_alias_member has one of two forms:\n• , where and represent identifiers, and is a type argument list. ( is always at least one.)\n• , where and represent identifiers. (In this case, is considered to be zero.)\n\nUsing this notation, the meaning of a qualified_alias_member is determined as follows:\n• If is the identifier , then the global namespace is searched for :\n• If the global namespace contains a namespace named and is zero, then the qualified_alias_member refers to that namespace.\n• Otherwise, if the global namespace contains a non-generic type named and is zero, then the qualified_alias_member refers to that type.\n• Otherwise, if the global namespace contains a type named that has type parameters, then the qualified_alias_member refers to that type constructed with the given type arguments.\n• Otherwise, the qualified_alias_member is undefined and a compile-time error occurs.\n• Otherwise, starting with the namespace declaration (§14.3) immediately containing the qualified_alias_member (if any), continuing with each enclosing namespace declaration (if any), and ending with the compilation unit containing the qualified_alias_member, the following steps are evaluated until an entity is located:\n• If the namespace declaration or compilation unit contains a using_alias_directive that associates N with a type, then the qualified_alias_member is undefined and a compile-time error occurs.\n• Otherwise, if the namespace declaration or compilation unit contains an extern_alias_directive or using_alias_directive that associates with a namespace, then:\n• If the namespace associated with contains a namespace named and is zero, then the qualified_alias_member refers to that namespace.\n• Otherwise, if the namespace associated with contains a non-generic type named and is zero, then the qualified_alias_member refers to that type.\n• Otherwise, if the namespace associated with contains a type named that has type parameters, then the qualified_alias_member refers to that type constructed with the given type arguments.\n• Otherwise, the qualified_alias_member is undefined and a compile-time error occurs.\n• Otherwise, the qualified_alias_member is undefined and a compile-time error occurs.\n\nEach compilation unit and namespace body has a separate declaration space for extern aliases and using aliases. Thus, while the name of an extern alias or using alias shall be unique within the set of extern aliases and using aliases declared in the immediately containing compilation unit or namespace body, an alias is permitted to have the same name as a type or namespace as long as it is used only with the qualifier."
    },
    {
        "link": "https://softwareengineering.stackexchange.com/questions/118989/using-static-classes-as-namespaces",
        "document": "Stack Exchange network consists of 183 Q&A communities including Stack Overflow, the largest, most trusted online community for developers to learn, share their knowledge, and build their careers."
    },
    {
        "link": "https://reddit.com/r/csharp/comments/1d9eise/what_is_best_practice_regarding_namespaces",
        "document": "I come from a Node.js background where you just import files directly, so I'm not quite sure how to organise my C# namespaces.\n\nShould it broadly be folder-based i.e. each file in a particular folder has the same namespace? Do you have one namespace per \"feature\"? Do you give a each file it's own unique namespace?\n\nI've really struggled to find information about this online, so thought I'd reach out here."
    },
    {
        "link": "https://stackoverflow.com/questions/28686989/organizing-namespaces-and-classes-in-directories",
        "document": "When I put a class file inside a folder, Resharper suggest me to update the namespace. So if I have the file (Class), it will suggest the namespace .\n\nThe problem is that I have a subfolder called too, that have components for the class. And it is confliting with namespaces. For instance:\n\nWhat is the best method to turn around that?\n\nCurrently I'm organizing like that:\n\nSo note that I rename the \"main\" class to to avoid conflict, but I keep a more accurate name in the filename. But it is ugly, not?"
    },
    {
        "link": "https://stackoverflow.com/questions/241339/when-to-use-static-classes-in-c-sharp",
        "document": "I wrote my thoughts of static classes in an earlier Stack Overflow answer: Class with single method -- best approach?\n\nI used to love utility classes filled up with static methods. They made a great consolidation of helper methods that would otherwise lie around causing redundancy and maintenance hell. They're very easy to use, no instantiation, no disposal, just fire'n'forget. I guess this was my first unwitting attempt at creating a service-oriented architecture - lots of stateless services that just did their job and nothing else. As a system grows however, dragons be coming.\n\nSay we have the method UtilityClass.SomeMethod that happily buzzes along. Suddenly we need to change the functionality slightly. Most of the functionality is the same, but we have to change a couple of parts nonetheless. Had it not been a static method, we could make a derivate class and change the method contents as needed. As it's a static method, we can't. Sure, if we just need to add functionality either before or after the old method, we can create a new class and call the old one inside of it - but that's just gross.\n\nStatic methods cannot be defined through interfaces for logic reasons. And since we can't override static methods, static classes are useless when we need to pass them around by their interface. This renders us unable to use static classes as part of a strategy pattern. We might patch some issues up by passing delegates instead of interfaces.\n\nThis basically goes hand in hand with the interface woes mentioned above. As our ability of interchanging implementations is very limited, we'll also have trouble replacing production code with test code. Again, we can wrap them up, but it'll require us to change large parts of our code just to be able to accept wrappers instead of the actual objects.\n\nAs static methods are usually used as utility methods and utility methods usually will have different purposes, we'll quickly end up with a large class filled up with non-coherent functionality - ideally, each class should have a single purpose within the system. I'd much rather have a five times the classes as long as their purposes are well defined.\n\nTo begin with, that little cute and innocent static method might take a single parameter. As functionality grows, a couple of new parameters are added. Soon further parameters are added that are optional, so we create overloads of the method (or just add default values, in languages that support them). Before long, we have a method that takes 10 parameters. Only the first three are really required, parameters 4-7 are optional. But if parameter 6 is specified, 7-9 are required to be filled in as well... Had we created a class with the single purpose of doing what this static method did, we could solve this by taking in the required parameters in the constructor, and allowing the user to set optional values through properties, or methods to set multiple interdependent values at the same time. Also, if a method has grown to this amount of complexity, it most likely needs to be in its own class anyway.\n\nDemanding consumers to create an instance of classes for no reason\n\nOne of the most common arguments is: Why demand that consumers of our class create an instance for invoking this single method, while having no use for the instance afterwards? Creating an instance of a class is a very very cheap operation in most languages, so speed is not an issue. Adding an extra line of code to the consumer is a low cost for laying the foundation of a much more maintainable solution in the future. And finally, if you want to avoid creating instances, simply create a singleton wrapper of your class that allows for easy reuse - although this does make the requirement that your class is stateless. If it's not stateless, you can still create static wrapper methods that handle everything, while still giving you all the benefits in the long run. Finally, you could also make a class that hides the instantiation as if it was a singleton: MyWrapper.Instance is a property that just returns\n\nOf course, there are exceptions to my dislike of static methods. True utility classes that do not pose any risk to bloat are excellent cases for static methods - System.Convert as an example. If your project is a one-off with no requirements for future maintenance, the overall architecture really isn't very important - static or non static, doesn't really matter - development speed does, however.\n\nUsing instance methods does not inhibit you from also using static methods, and vice versa. As long as there's reasoning behind the differentiation and it's standardised. There's nothing worse than looking over a business layer sprawling with different implementation methods."
    }
]