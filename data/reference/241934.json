[
    {
        "link": "https://developer.mozilla.org/en-US/docs/Learn_web_development/Extensions/Server-side/Express_Nodejs/forms",
        "document": "An HTML Form is a group of one or more fields/widgets on a web page that can be used to collect information from users for submission to a server. Forms are a flexible mechanism for collecting user input because there are suitable form inputs available for entering many different types of data—text boxes, checkboxes, radio buttons, date pickers, etc. Forms are also a relatively secure way of sharing data with the server, as they allow us to send data in requests with cross-site request forgery protection. Working with forms can be complicated! Developers need to write HTML for the form, validate and properly sanitize entered data on the server (and possibly also in the browser), repost the form with error messages to inform users of any invalid fields, handle the data when it has successfully been submitted, and finally respond to the user in some way to indicate success. In this tutorial, we're going to show you how the above operations may be performed in Express. Along the way, we'll extend the LocalLibrary website to allow users to create, edit and delete items from the library. Note: We haven't looked at how to restrict particular routes to authenticated or authorized users, so at this point, any user will be able to make changes to the database.\n\nFirst a brief overview of HTML Forms. Consider a simple HTML form, with a single text field for entering the name of some \"team\", and its associated label: The form is defined in HTML as a collection of elements inside tags, containing at least one element of . <form action=\"/team_name_url/\" method=\"post\"> <label for=\"team_name\">Enter name: </label> <input id=\"team_name\" type=\"text\" name=\"name_field\" value=\"Default name for team.\" /> <input type=\"submit\" value=\"OK\" /> </form> While here we have included just one (text) field for entering the team name, a form may contain any number of other input elements and their associated labels. The field's attribute defines what sort of widget will be displayed. The and of the field are used to identify the field in JavaScript/CSS/HTML, while defines the initial value for the field when it is first displayed. The matching team label is specified using the tag (see \"Enter name\" above), with a field containing the value of the associated . The input will be displayed as a button (by default)—this can be pressed by the user to upload the data contained by the other input elements to the server (in this case, just the ). The form attributes define the HTTP used to send the data and the destination of the data on the server ( ):\n• : The resource/URL where data is to be sent for processing when the form is submitted. If this is not set (or set to an empty string), then the form will be submitted back to the current page URL.\n• : The HTTP method used to send the data: or .\n• The method should always be used if the data is going to result in a change to the server's database, because this can be made more resistant to cross-site forgery request attacks.\n• The method should only be used for forms that don't change user data (e.g. a search form). It is recommended for when you want to be able to bookmark or share the URL.\n\nForm handling uses all of the same techniques that we learned for displaying information about our models: the route sends our request to a controller function which performs any database actions required, including reading data from the models, then generates and returns an HTML page. What makes things more complicated is that the server also needs to be able to process the data provided by the user, and redisplay the form with error information if there are any problems. A process flowchart for processing form requests is shown below, starting with a request for a page containing a form (shown in green): As shown in the diagram above, the main things that form handling code needs to do are:\n• Display the default form the first time it is requested by the user.\n• The form may contain blank fields (e.g. if you're creating a new record), or it may be pre-populated with initial values (e.g. if you are changing a record, or have useful default initial values).\n• Receive data submitted by the user, usually in an HTTP request.\n• If any data is invalid, re-display the form—this time with any user populated values and error messages for the problem fields.\n• If all data is valid, perform required actions (e.g. save the data in the database, send a notification email, return the result of a search, upload a file, etc.)\n• Once all actions are complete, redirect the user to another page. Often form handling code is implemented using a route for the initial display of the form and a route to the same path for handling validation and processing of form data. This is the approach that will be used in this tutorial. Express itself doesn't provide any specific support for form handling operations, but it can use middleware to process and parameters from the form, and to validate/sanitize their values.\n\nBefore the data from a form is stored it must be validated and sanitized:\n• Validation checks that entered values are appropriate for each field (are in the right range, format, etc.) and that values have been supplied for all required fields.\n• Sanitization removes/replaces characters in the data that might potentially be used to send malicious content to the server. For this tutorial, we'll be using the popular express-validator module to perform both validation and sanitization of our form data. Install the module by running the following command in the root of the project. Note: The express-validator guide on GitHub provides a good overview of the API. We recommend you read that to get an idea of all its capabilities (including using schema validation and creating custom validators). Below we cover just a subset that is useful for the LocalLibrary. To use the validator in our controllers, we specify the particular functions we want to import from the express-validator module, as shown below: There are many functions available, allowing you to check and sanitize data from request parameters, body, headers, cookies, etc., or all of them at once. For this tutorial, we'll primarily be using and (as \"required\" above). The functions are defined as below:\n• : Specifies a set of fields in the request body (a parameter) to validate and/or sanitize along with an optional error message that can be displayed if it fails the tests. The validation and sanitize criteria are daisy-chained to the method. For example, the line below first defines that we're checking the \"name\" field and that a validation error will set an error message \"Empty name\". We then call the sanitization method to remove whitespace from the start and end of the string, and then to check the resulting string isn't empty. Finally, we call to remove HTML characters from the variable that might be used in JavaScript cross-site scripting attacks. This test checks that the age field is a valid date and uses to specify that null and empty strings will not fail validation. You can also daisy chain different validators, and add messages that are displayed if the preceding validators are false.\n• : Runs the validation, making errors available in the form of a result object. This is invoked in a separate callback, as shown below: asyncHandler(async (req, res, next) => { // Extract the validation errors from a request. const errors = validationResult(req); if (!errors.isEmpty()) { // There are errors. Render form again with sanitized values/errors messages. // Error messages can be returned in an array using `errors.array()`. } else { // Data from form is valid. } }); We use the validation result's method to check if there were errors, and its method to get the set of error messages. See the Handling validation section for more information. The validation and sanitization chains are middleware that should be passed to the Express route handler (we do this indirectly, via the controller). When the middleware runs, each validator/sanitizer is run in the order specified. We'll cover some real examples when we implement the LocalLibrary forms below.\n\nIn order to implement our form handling code, we will need two routes that have the same URL pattern. The first ( ) route is used to display a new empty form for creating the object. The second route ( ) is used for validating data entered by the user, and then saving the information and redirecting to the detail page (if the data is valid) or redisplaying the form with errors (if the data is invalid). We have already created the routes for all our model's create pages in /routes/catalog.js (in a previous tutorial). For example, the genre routes are shown below: // GET request for creating a Genre. NOTE This must come before route that displays Genre (uses id). router.get(\"/genre/create\", genre_controller.genre_create_get); // POST request for creating Genre. router.post(\"/genre/create\", genre_controller.genre_create_post);"
    },
    {
        "link": "https://scaler.com/topics/expressjs-tutorial/handling-form-submission",
        "document": "In this article, we are going to discuss Handling form submission expressjs. Before getting started with the topic, let us get a short overview of the topic. Handling Form Submission ExpressJS: Handling form submissions in ExpressJS refers to the process of receiving data from an HTML form submitted by a user, processing and validating the data on the server side using the ExpressJS framework, and storing the data in a database or sending it as an email. This involves defining a route in the ExpressJS application to handle the form submission, accessing the form data using the req.body object, handling errors, and providing feedback to the user. The process requires a combination of front-end and back-end development skills and knowledge of HTTP requests and responses, routing, and data processing. So let us now begin with the main agenda of our article, Handling form submission in expressjs.\n\nExpressJS is a popular Node.js web application framework that allows developers to easily handle HTTP requests and responses. When it comes to handling form submissions in ExpressJS, there are a few key steps that need to be taken.\n• First, the HTML form needs to be created on the front end with the appropriate form fields and an action attribute that points to the server-side route where the form data will be submitted.\n• Next, on the server side, the route needs to be defined in the ExpressJS application to handle the form submission. This can be done using the method and specifying the URL endpoint for the route.\n• Within the route handler function, the form data can be accessed using the object, which contains key-value pairs of the form fields and their values. This data can then be processed, validated, and stored in a database or sent as an email, depending on the specific requirements of the application. It is important to properly handle errors and provide appropriate feedback to the user if the form submission fails or contains invalid data. This can be achieved by sending an error message as a response or by redirecting the user back to the form with pre-filled values and error messages. Overall, handling form submissions in ExpressJS requires a combination of front-end and back-end development skills, as well as knowledge of HTTP requests and responses, routing, and data processing. Here's an example of handling form submission in ExpressJS: Let's say we have an HTML form with two fields - name and email - and an action attribute that points to /submit-form on the server side. On the server side, we define a route to handle the form submission using the app.post() method: Within the route handler function, we access the form data using the req.body object and store it in variables. We can then do some processing and validation on the data, such as checking if the email is valid or if the name contains only letters. Finally, we can store the data in a database or send it as an email. In this example, we simply send a response to the user indicating that the form was submitted successfully. It is important to note that we need to use middleware such as body-parser to parse the form data before accessing it using req.body. Here's an example of how we can use body-parser: This will parse the form data and make it available in the req.body object.\n\nHow to Handle Forms in Express To handle forms in Express, you need to follow a few steps: Step 1. Create an HTML form on the front end with the appropriate form fields and an action attribute that points to the server-side route where the form data will be submitted. Step 2. Install and use a middleware such as body-parser to parse the form data before accessing it on the server side using req.body. Step 3. Define a route in the Express application to handle the form submission using the app.post() method and specify the URL endpoint for the route. Step 4. Within the route handler function, access the form data using the req.body object, process and validate the data, and then store it in a database or send it as an email. Finally, return a response to the user indicating whether the form was submitted successfully or if there were any errors. Step 5. Handle errors and provide appropriate feedback to the user if the form submission fails or contains invalid data. This can be achieved by sending an error message as a response or by redirecting the user back to the form with pre-filled values and error messages.\n\nHandling GET forms in Express involves processing data submitted through the query string in the URL. The query string is a part of the URL that contains key-value pairs of data. There are two common ways to pass data through the query string: using GET parameters and using named placeholders. Let us discuss them in detail. When a user submits a GET form, the form data is included in the URL as a query string. The query string consists of key-value pairs separated by the ampersand (&) symbol and preceded by a question mark (?). For example, a search form that submits the query expressjs might generate the following URL: To access the query parameter in Express, we can use the req.query object, which contains an object with key-value pairs of all the parameters and their values. In the above example, we can access the query parameter using req.query.query. We can then process and use the data as needed. Named placeholders allow us to define dynamic segments in the URL that can be used to pass data to the server. Named placeholders are defined by prefixing a parameter name with a colon (:). For example, a user profile page might have a URL like this: The :id segment represents a dynamic parameter that can be used to identify the user. To access the id parameter in Express, we can use the req.params object, which contains an object with key-value pairs of all the named placeholders and their values. In the above example, we can access the id parameter using req.params.id. We can then process and use the data as needed. Named placeholders are useful for handling dynamic data, such as user profiles, blog posts, or product pages. They can also be used to define custom URL patterns and handle complex routing scenarios. Overall, handling GET forms in Express involves accessing data submitted through the query string in the URL, either through GET parameters or named placeholders. Express provides a simple and flexible API for accessing this data and processing it as needed. It's important to note that named placeholders are more flexible than GET parameters, as they allow us to define custom URL patterns and handle dynamic data more easily. However, they are less intuitive for users and can be more difficult to implement and test.\n\nHandling POST forms in Express involves processing data submitted through HTTP POST requests. Several types of data can be submitted through a POST form, including text-only data, JSON data, and file uploads. To handle text-only data in a POST form, we can use the body-parser middleware to parse the request body. The body-parser middleware can parse data in a variety of formats, including JSON, urlencoded, and raw. Here's an example of how to handle text-only data in a POST form using the body-parser middleware and the app.post method: In this example, the body-parser middleware is used to parse both application/x-www-form-urlencoded and application/json data. The app.post method is used to handle POST requests to the /submit endpoint. The data submitted in the POST form can be accessed using the req.body object, which contains key-value pairs of the data. To handle JSON data in a POST form, we can use the body-parser middleware to parse the request body. The body-parser middleware can parse JSON data automatically, so no special configuration is required. Here's an example of how to handle JSON data in a POST form using the body-parser middleware and the app.post method: In this example, the body-parser middleware is used to parse JSON data. The app.post method is used to handle POST requests to the /submit endpoint. The JSON data submitted in the POST form can be accessed using the req.body object. To handle file uploads in a POST form, we can use the multer middleware. Multer is a node.js middleware that handles multipart/form-data which is primarily used for uploading files. It's easy to use and supports many configuration options. Here's an example of how to handle file uploads in a POST form using the multer middleware and the app.post method: In this example, the multer middleware is used to handle file uploads. The app.post method is used to handle POST requests to the /upload endpoint. The uploaded file can be accessed using the req.file object, which contains information about the uploaded file, such as its filename, mimetype, and path. To handle multiple file uploads, we can use the upload.array method instead of upload.single. We can also specify a maximum number of files and a maximum file size using the limits option. In summary, handling POST forms in Express requires parsing the request body and accessing the form data using the req.body object. The body-parser middleware can handle text-only and JSON data, while the multer middleware can handle file uploads. By understanding how to handle different types of data in a POST form, we can build robust and powerful web applications in Express."
    },
    {
        "link": "https://stackoverflow.com/questions/59740057/how-to-submit-form-data-to-express-server",
        "document": "The problem is just the order of your routes. The first path you specify:\n\nIs acting as a catch-all, since every path on the server includes '/'\n\nIf you switch the order and make the catch-all last, this should work just fine for you."
    },
    {
        "link": "https://expressjs.com/en/api.html",
        "document": "Creates an Express application. The function is a top-level function exported by the module.\n\nThe object conventionally denotes the Express application. Create it by calling the top-level function exported by the Express module:\n\nThe object has methods for\n• Routing HTTP requests; see for example, app.METHOD and app.param.\n\nIt also has settings (properties) that affect how the application behaves; for more information, see Application settings.\n\nAdd callback triggers to route parameters, where is the name of the parameter or an array of them, and is the callback function. The parameters of the callback function are the request object, the response object, the next middleware, the value of the parameter and the name of the parameter, in that order. If is an array, the trigger is registered for each parameter declared in it, in the order in which they are declared. Furthermore, for each declared parameter except the last one, a call to inside the callback will call the callback for the next declared parameter. For the last parameter, a call to will call the next middleware in place for the route currently being processed, just like it would if were just a string. For example, when is present in a route path, you may map user loading logic to automatically provide to the route, or perform validations on the parameter input. // try to get the user details from the User model and attach it to the request object Param callback functions are local to the router on which they are defined. They are not inherited by mounted apps or routers, nor are they triggered for route parameters inherited from parent routers. Hence, param callbacks defined on will be triggered only by route parameters defined on routes. All param callbacks will be called before any handler of any route in which the param occurs, and they will each be called only once in a request-response cycle, even if the parameter is matched in multiple routes, as shown in the following examples. On , the following is printed: CALLED ONLY ONCE although this matches and this matches too On , the following is printed: CALLED ONLY ONCE with 42 CALLED ONLY ONCE with 3 although this matches and this matches too The following section describes , which is deprecated as of v4.11.0. The behavior of the method can be altered entirely by passing only a function to . This function is a custom implementation of how should behave - it accepts two parameters and must return a middleware. The first parameter of this function is the name of the URL parameter that should be captured, the second parameter can be any JavaScript object which might be used for returning the middleware implementation. The middleware returned by the function decides the behavior of what happens when a URL parameter is captured. In this example, the signature is modified to . Instead of accepting a name and a callback, will now accept a name and a number. In this example, the signature remains the same, but instead of a middleware callback, a custom data type checking function has been defined to validate the data type of the user id. The ‘ ’ character can’t be used to capture a character in your capturing regexp. For example you can’t use to capture , use or instead (as in . // captures '1-a_6' and '543-az(ser\"-sder' but not '5-a s'\n\nThe object represents the HTTP request and has properties for the request query string, parameters, body, HTTP headers, and so on. In this documentation and by convention, the object is always referred to as (and the HTTP response is ) but its actual name is determined by the parameters to the callback function in which you’re working.\n\nBut you could just as well have:\n\nThe object is an enhanced version of Node’s own request object and supports all built-in fields and methods.\n\nThe object represents the HTTP response that an Express app sends when it gets an HTTP request.\n\nIn this documentation and by convention, the object is always referred to as (and the HTTP request is ) but its actual name is determined by the parameters to the callback function in which you’re working.\n\nBut you could just as well have:\n\nThe object is an enhanced version of Node’s own response object and supports all built-in fields and methods."
    },
    {
        "link": "https://geeksforgeeks.org/how-to-handle-form-data-in-express",
        "document": "How to handle form data in Express ?\n\nHandling form data in Express involves setting up a route to manage incoming form submissions and using the body-parser middleware to extract the form data from the request body.\n\nStep 1: Install the necessary package in your application using the following command.\n\nExample: Below is the example to show how you handle form data in ExpressJS."
    },
    {
        "link": "https://geeksforgeeks.org/how-to-implement-search-and-filtering-in-a-rest-api-with-node-js-and-express-js",
        "document": "How to Implement Search and Filtering in a REST API with Node.js and Express.js ?\n\nSearch and filtering are very basic features that an API must possess to serve data to the client application efficiently. By handling these operations on the server-side, we can reduce the amount of processing that has to be done on the client application, thereby increasing its performance.\n\nIn this article, we’ll see how we can build a Node.js REST API that can accept these query strings, filter a list of users based on these provided parameters, and then return the matching results.\n\nAn extremely popular way of implementing this is with the help of query strings. A query string is a part of the URL that allows us to pass data from client to server and vice-versa in the form of parameters and their values.\n\nHere, the portion following the question mark (?) is the query string. These are basically key-value pairs that we can use for various purposes.\n\nThen we will filter user data based on query parameters received in the request. We can iterate through the dataset, check if each user matches the specified filters, and return the filtered results as the response.\n\nFirst, we’ve to initialize a new project using Node Package Manager. We can complete the setup by selecting all the default options.\n\nNext, we’ve to install the express package.\n\nThe entry point of this application is going to be the app.js file. All of our business logic will go here. The REST API will contain only a single route which will return a list of users, with support for searching and filtering using query strings.\n\nExample: Initially, the app.js file will look something like this, with the route returning only a basic message.\n\nAdding Mock Data: For carrying out searching and filtering, we need some mock data i.e. a list of users upon which we can carry out these operations. For this, we can create a separate file data.js\n• None Let’s consider this URL. Here, we want to fetch all the users who live in Metropolis and are 21 years old.\n• None We can access the query string by using the query res\n\nWe can see that it contains all the parameters passed through the URL in form of key-value pairs. To apply these parameters on our list of users, we can use the Array.filter() method and check for each user, if it satisfies all the provided parameters, and if it does, then add it to the filteredUsers list.\n\nThe filteredUsers list is our final result and can be returned as the response. The final code is provided below\n\nExample 1: URL to Fetch the user whose id is 2\n\nExample 2: URL to Fetch all users who live in Metropolis\n\nExample 3: URL to Fetch all users who live in Metropolis and are 21 years old\n\nWe can easy implement search and filter in REST API using node and express with the help to query string in the url. By handling query parameters and applying conditions to your database queries, you can create a flexible and powerful search and filtering system."
    },
    {
        "link": "https://stackoverflow.com/questions/52875501/most-efficient-way-to-implement-search-and-form-submit-with-express-js",
        "document": "I've got an express app that looks up information from a database for a few topics based on \"Job Number\". For example, if you want to see the hours logged to a job, the route is\n\nTo get general job infoemation and details, the route is\n\nIf a user navigates to just I want to show them a really basic form with a single input for Job Number and a Submit button. All that the form needs to do is essentially append to the url. I've done this a couple different ways, namely:\n\nMake it a form that posts to own URL and do something like\n\nI could use JS to listen for the form submit/button press and do a JS redirect to\n\nThey both work... but is there a way that makes the most sense, is more faster, a \"best practice\" for this type of routing?"
    },
    {
        "link": "https://expressjs.com/en/advanced/best-practice-performance.html",
        "document": "This article discusses performance and reliability best practices for Express applications deployed to production.\n\nThis topic clearly falls into the “devops” world, spanning both traditional development and operations. Accordingly, the information is divided into two parts:\n• Things to do in your code (the dev part):\n• Things to do in your environment / setup (the ops part):\n\nThings to do in your code\n\nHere are some things you can do in your code to improve your application’s performance:\n\nGzip compressing can greatly decrease the size of the response body and hence increase the speed of a web app. Use the compression middleware for gzip compression in your Express app. For example:\n\nFor a high-traffic website in production, the best way to put compression in place is to implement it at a reverse proxy level (see Use a reverse proxy). In that case, you do not need to use compression middleware. For details on enabling gzip compression in Nginx, see Module ngx_http_gzip_module in the Nginx documentation.\n\nSynchronous functions and methods tie up the executing process until they return. A single call to a synchronous function might return in a few microseconds or milliseconds, however in high-traffic websites, these calls add up and reduce the performance of the app. Avoid their use in production.\n\nAlthough Node and many modules provide synchronous and asynchronous versions of their functions, always use the asynchronous version in production. The only time when a synchronous function can be justified is upon initial startup.\n\nYou can use the command-line flag to print a warning and a stack trace whenever your application uses a synchronous API. Of course, you wouldn’t want to use this in production, but rather to ensure that your code is ready for production. See the node command-line options documentation for more information.\n\nIn general, there are two reasons for logging from your app: For debugging and for logging app activity (essentially, everything else). Using or to print log messages to the terminal is common practice in development. But these functions are synchronous when the destination is a terminal or a file, so they are not suitable for production, unless you pipe the output to another program.\n\nIf you’re logging for purposes of debugging, then instead of using , use a special debugging module like debug. This module enables you to use the DEBUG environment variable to control what debug messages are sent to , if any. To keep your app purely asynchronous, you’d still want to pipe to another program. But then, you’re not really going to debug in production, are you?\n\nIf you’re logging app activity (for example, tracking traffic or API calls), instead of using , use a logging library like Pino, which is the fastest and most efficient option available.\n\nNode apps crash when they encounter an uncaught exception. Not handling exceptions and taking appropriate actions will make your Express app crash and go offline. If you follow the advice in Ensure your app automatically restarts below, then your app will recover from a crash. Fortunately, Express apps typically have a short startup time. Nevertheless, you want to avoid crashing in the first place, and to do that, you need to handle exceptions properly.\n\nTo ensure you handle all exceptions, use the following techniques:\n\nBefore diving into these topics, you should have a basic understanding of Node/Express error handling: using error-first callbacks, and propagating errors in middleware. Node uses an “error-first callback” convention for returning errors from asynchronous functions, where the first parameter to the callback function is the error object, followed by result data in succeeding parameters. To indicate no error, pass null as the first parameter. The callback function must correspondingly follow the error-first callback convention to meaningfully handle the error. And in Express, the best practice is to use the next() function to propagate errors through the middleware chain.\n\nFor more on the fundamentals of error handling, see:\n\nTry-catch is a JavaScript language construct that you can use to catch exceptions in synchronous code. Use try-catch, for example, to handle JSON parsing errors as shown below.\n\nHere is an example of using try-catch to handle a potential process-crashing exception. This middleware function accepts a query field parameter named “params” that is a JSON object.\n\nHowever, try-catch works only for synchronous code. Because the Node platform is primarily asynchronous (particularly in a production environment), try-catch won’t catch a lot of exceptions.\n\nWhen an error is thrown in an function or a rejected promise is awaited inside an function, those errors will be passed to the error handler as if calling\n\nAlso, you can use asynchronous functions for your middleware, and the router will handle errors if the promise fails, for example:\n\nBest practice is to handle errors as close to the site as possible. So while this is now handled in the router, it’s best to catch the error in the middleware and handle it without relying on separate error-handling middleware.\n\nWhat not to do\n\nOne thing you should not do is to listen for the event, emitted when an exception bubbles all the way back to the event loop. Adding an event listener for will change the default behavior of the process that is encountering an exception; the process will continue to run despite the exception. This might sound like a good way of preventing your app from crashing, but continuing to run the app after an uncaught exception is a dangerous practice and is not recommended, because the state of the process becomes unreliable and unpredictable.\n\nAdditionally, using is officially recognized as crude. So listening for is just a bad idea. This is why we recommend things like multiple processes and supervisors: crashing and restarting is often the most reliable way to recover from an error.\n\nWe also don’t recommend using domains. It generally doesn’t solve the problem and is a deprecated module.\n\nThings to do in your environment / setup\n\nHere are some things you can do in your system environment to improve your app’s performance:\n\nThe NODE_ENV environment variable specifies the environment in which an application is running (usually, development or production). One of the simplest things you can do to improve performance is to set NODE_ENV to .\n\nTests indicate that just doing this can improve app performance by a factor of three!\n\nIf you need to write environment-specific code, you can check the value of NODE_ENV with . Be aware that checking the value of any environment variable incurs a performance penalty, and so should be done sparingly.\n\nIn development, you typically set environment variables in your interactive shell, for example by using or your file. But in general, you shouldn’t do that on a production server; instead, use your OS’s init system (systemd). The next section provides more details about using your init system in general, but setting is so important for performance (and easy to do), that it’s highlighted here.\n\nWith systemd, use the directive in your unit file. For example:\n\nFor more information, see Using Environment Variables In systemd Units.\n\nIn production, you don’t want your application to be offline, ever. This means you need to make sure it restarts both if the app crashes and if the server itself crashes. Although you hope that neither of those events occurs, realistically you must account for both eventualities by:\n• Using a process manager to restart the app (and Node) when it crashes.\n• Using the init system provided by your OS to restart the process manager when the OS crashes. It’s also possible to use the init system without a process manager.\n\nNode applications crash if they encounter an uncaught exception. The foremost thing you need to do is to ensure your app is well-tested and handles all exceptions (see handle exceptions properly for details). But as a fail-safe, put a mechanism in place to ensure that if and when your app crashes, it will automatically restart.\n\nIn development, you started your app simply from the command line with or something similar. But doing this in production is a recipe for disaster. If the app crashes, it will be offline until you restart it. To ensure your app restarts if it crashes, use a process manager. A process manager is a “container” for applications that facilitates deployment, provides high availability, and enables you to manage the application at runtime.\n\nIn addition to restarting your app when it crashes, a process manager can enable you to:\n\nHistorically, it was popular to use a Node.js process manager like PM2. See their documentation if you wish to do this. However, we recommend using your init system for process management.\n\nThe next layer of reliability is to ensure that your app restarts when the server restarts. Systems can still go down for a variety of reasons. To ensure that your app restarts if the server crashes, use the init system built into your OS. The main init system in use today is systemd.\n\nThere are two ways to use init systems with your Express app:\n• Run your app in a process manager, and install the process manager as a service with the init system. The process manager will restart your app when the app crashes, and the init system will restart the process manager when the OS restarts. This is the recommended approach.\n• Run your app (and Node) directly with the init system. This is somewhat simpler, but you don’t get the additional advantages of using a process manager.\n\nSystemd is a Linux system and service manager. Most major Linux distributions have adopted systemd as their default init system.\n\nA systemd service configuration file is called a unit file, with a filename ending in . Here’s an example unit file to manage a Node app directly. Replace the values enclosed in for your system and app:\n\nFor more information on systemd, see the systemd reference (man page).\n\nIn a multi-core system, you can increase the performance of a Node app by many times by launching a cluster of processes. A cluster runs multiple instances of the app, ideally one instance on each CPU core, thereby distributing the load and tasks among the instances.\n\nIMPORTANT: Since the app instances run as separate processes, they do not share the same memory space. That is, objects are local to each instance of the app. Therefore, you cannot maintain state in the application code. However, you can use an in-memory datastore like Redis to store session-related data and state. This caveat applies to essentially all forms of horizontal scaling, whether clustering with multiple processes or multiple physical servers.\n\nIn clustered apps, worker processes can crash individually without affecting the rest of the processes. Apart from performance advantages, failure isolation is another reason to run a cluster of app processes. Whenever a worker process crashes, always make sure to log the event and spawn a new process using cluster.fork().\n\nClustering is made possible with Node’s cluster module. This enables a master process to spawn worker processes and distribute incoming connections among the workers.\n\nIf you deploy your application with PM2, then you can take advantage of clustering without modifying your application code. You should ensure your application is stateless first, meaning no local data is stored in the process (such as sessions, websocket connections and the like).\n\nWhen running an application with PM2, you can enable cluster mode to run it in a cluster with a number of instances of your choosing, such as the matching the number of available CPUs on the machine. You can manually change the number of processes in the cluster using the command line tool without stopping the app.\n\nTo enable cluster mode, start your application like so:\n\nThis can also be configured within a PM2 process file ( or similar) by setting to and to the number of workers to start.\n\nOnce running, the application can be scaled like so:\n\nFor more information on clustering with PM2, see Cluster Mode in the PM2 documentation.\n\nAnother strategy to improve the performance in production is to cache the result of requests, so that your app does not repeat the operation to serve the same request repeatedly.\n\nUse a caching server like Varnish or Nginx (see also Nginx Caching) to greatly improve the speed and performance of your app.\n\nNo matter how optimized an app is, a single instance can handle only a limited amount of load and traffic. One way to scale an app is to run multiple instances of it and distribute the traffic via a load balancer. Setting up a load balancer can improve your app’s performance and speed, and enable it to scale more than is possible with a single instance.\n\nA load balancer is usually a reverse proxy that orchestrates traffic to and from multiple application instances and servers. You can easily set up a load balancer for your app by using Nginx or HAProxy.\n\nWith load balancing, you might have to ensure that requests that are associated with a particular session ID connect to the process that originated them. This is known as session affinity, or sticky sessions, and may be addressed by the suggestion above to use a data store such as Redis for session data (depending on your application). For a discussion, see Using multiple nodes.\n\nA reverse proxy sits in front of a web app and performs supporting operations on the requests, apart from directing requests to the app. It can handle error pages, compression, caching, serving files, and load balancing among other things.\n\nHanding over tasks that do not require knowledge of application state to a reverse proxy frees up Express to perform specialized application tasks. For this reason, it is recommended to run Express behind a reverse proxy like Nginx or HAProxy in production."
    },
    {
        "link": "https://stackoverflow.com/questions/43222805/how-to-do-search-functionality",
        "document": "Please help me out. I'm making a search functionality. Below is My Code and User stories. I'm able to pass only the first User Story but not with the other stories. Can someone please help me out.\n• None As an User if I search with Skills and location I should get the results which matched with the query.\n• None As an User if I search with only Skills still I should get the results which matched with the query.\n• None As an User if I search with only Location still I should get the results which matched with the query.\n• None As an User if I search with invalid skills (J, A, B) or location I shouldn't get the results which does matched the query.. var search = { get: function (req, res) { var locationQuery = req.params.locationQuery, skillsQuery = req.params.skillsQuery; Jobs.find({state: { \"$regex\": locationQuery, \"$options\": \"i\" }, Skills: { \"$regex\": skillsQuery, \"$options\": \"i\" }}, function(err, result) { if (err) { console.log('Not a Valid Search'); res.status(500).send(err, 'Not a Valid Search'); }else { res.json(result); } }); } };"
    },
    {
        "link": "https://geeksforgeeks.org/how-to-make-a-search-function-using-node-express-and-mysql",
        "document": "How to Make a search function using Node Express and MYSQL\n\nIn this article, we will learn how to create a search function using Node with Express framework to search terms inside MYSQL tables.\n\nWe will discuss the following methods to search:\n\nWe're making a web application using Express.js and connecting it to a MySQL database. When users visit the '/search' route and provide a search term as a parameter, the app looks for that term in the database. If there's an error, we log it and send a 500 error. If not, we send back the search results in JSON format. We're using Node.js with Express for all this.\n\nStep 1: Initialize npm (node package manager) using the following command\n\nStep 2: Install mysql2 package using the following npm install command.\n\nStep 3: Create a new JavaScript file with .js extension (Example: app.js ) and write the code.\n\nStep 4: For testing, create a new database and sample records using the following SQL query. Run the query in the MySQL workspace.\n\nThe updated dependencies in package.json file will look like:\n\nStep 5: Run the application using following command:\n\nStep 6: Navigate to 'http://localhost:3000/search' and pass search term in the query using '?term= <search term>' .\n\nIt performs a partial match on 'name' column using LIKE and % wildcard in SQL query. Search the term with partial match in 'name' column using the following query. The LIKE operator with search term surrounded by % allows for a partial match ( const searchValue = `%${searchTerm}%`; ).\n\nReplace it with following SQL query:\n\nExample: Below is the code example of Searching term with partial match:"
    },
    {
        "link": "https://digitalocean.com/community/tutorials/how-to-use-ejs-to-template-your-node-application",
        "document": "When quickly creating Node applications, a fast way to template your application is sometimes necessary.\n\nJade comes as the default template engine for Express but Jade syntax can be overly complex for many use cases.\n\nEmbedded JavaScript templates (EJS) can be used as an alternative template engine.\n\nIn this article, you will learn how to apply EJS to an Express application, include repeatable parts of your site, and pass data to the views.\n\nIf you would like to follow along with this article, you will need:\n• A local development environment for Node.js. Follow How to Install Node.js and Create a Local Development Environment.\n\nThis tutorial was originally written for v4.17.1 and v3.1.5. It has been verified with Node v16.0.0, v7.11.1, v4.17.1, and v3.1.6.\n\nFirst, open your terminal window and create a new project directory:\n\nThen, navigate to the newly created directory:\n\nAt this point, you can initialize a new npm project:\n\nNext, you will need to install the package:\n\nAt this point, you have a new project ready to use Express and EJS.\n\nWith all of the dependencies installed, let’s configure the application to use EJS and set up the routes for the Index page and the About page.\n\nCreate a new file and open it with your code editor and add the following lines of code:\n\nThis code defines the application and listens on port .\n\nThis code also sets EJS as the view engine for the Express application using:\n\nNotice how the code sends a view to the user by using . It is important to note that will look in a folder for the view. So you only have to define since the full path is .\n\nNext, you will create the views using EJS.\n\nLike a lot of the applications you build, there will be a lot of code that is reused. These are considered partials. In this example, there will be three partials that will be reused on the Index page and About page: , , and . Let’s make those files now.\n\nIn this directory, create a new file and open it with your code editor. Add the following lines of code:\n\nThis code contains metadata for the for an HTML document. It also includes Bootstrap styles.\n\nNext, create a new file and open it with your code editor. Add the following lines of code:\n\nThis code contains navigation for an HTML document and uses several classes from Bootstrap for styling.\n\nNext, create a new file and open it with your code editor. Add the following lines of code:\n\nThis code contains copyright information and uses several classes from Bootstrap for styling.\n\nNext, you will use these partials in and .\n\nYou have three partials defined. Now you can them in your views.\n\nUse to embed an EJS partial in another file.\n• The hyphen instead of just to tell EJS to render raw HTML.\n• The path to the partial is relative to the current file.\n\nIn this directory, create a new file and open it with your code editor. Add the following lines of code:\n\nSave the changes to this file and then run the application:\n\nIf you visit in a web browser, you can observe the Index page:\n\nNext, create a new file and open it with your code editor. Add the following lines of code:\n\nThis code adds a Bootstrap sidebar to demonstrate how partials can be structured to reuse across different templates and pages.\n\nSave the changes to this file and then run the application:\n\nIf you visit in a web browser, you can observe the About page with a sidebar:\n\nNow you can start using EJS for passing data from the Node application to the views.\n\nLet’s define some basic variables and a list to pass to the Index page.\n\nRevisit in your code editor and add the following lines of code inside the route:\n\nThis code defines an array called and a string called . Next, let’s use them in .\n\nTo echo a single variable, you can use .\n\nRevisit in your code editor and add the following lines of code:\n\nThis code will display the value on the Index page.\n\nTo loop over data, you can use .\n\nRevisit in your code editor and add the following lines of code:\n\nSave the changes to this file and then run the application:\n\nIf you visit in a web browser, you can observe the Index page with the :\n\nThe EJS partial has access to all the same data as the parent view. But be careful. If you are referencing a variable in a partial, it needs to be defined in every view that uses the partial or it will throw an error.\n\nYou can also define and pass variables to an EJS partial in the include syntax like this:\n\nBut you need to again be careful about assuming a variable has been defined.\n\nIf you want to reference a variable in a partial that may not always be defined, and give it a default value, you can do so like this:\n\nIn the line above, the EJS code is rendering the value of if it’s defined, and if not.\n\nIn this article, you learned how to apply EJS to an Express application, include repeatable parts of your site, and pass data to the views.\n\nEJS lets you build applications when you do not require additional complexity. By using partials and having the ability to easily pass variables to your views, you can build some great applications quickly.\n\nConsult the EJS documentation for additional information on features and syntax. Consult Comparing JavaScript Templating Engines: Jade, Mustache, Dust and More for understanding the pros and cons of different view engines."
    },
    {
        "link": "https://expressjs.com/en/guide/using-template-engines.html",
        "document": "A template engine enables you to use static template files in your application. At runtime, the template engine replaces variables in a template file with actual values, and transforms the template into an HTML file sent to the client. This approach makes it easier to design an HTML page.\n\nThe Express application generator uses Pug as its default, but it also supports Handlebars, and EJS, among others.\n\nTo render template files, set the following application setting properties, in the default created by the generator:\n• , the directory where the template files are located. Eg: . This defaults to the directory in the application root directory.\n• , the template engine to use. For example, to use the Pug template engine: .\n\nThen install the corresponding template engine npm package; for example to install Pug:\n\nAfter the view engine is set, you don’t have to specify the engine or load the template engine module in your app; Express loads the module internally, for example:\n\nThen, create a Pug template file named in the directory, with the following content:\n\nCreate a route to render the file. If the property is not set, you must specify the extension of the file. Otherwise, you can omit it.\n\nWhen you make a request to the home page, the file will be rendered as HTML.\n\nThe view engine cache does not cache the contents of the template’s output, only the underlying template itself. The view is still re-rendered with every request even when the cache is on."
    },
    {
        "link": "https://medium.com/@adarshahelvar/using-ejs-embedded-javascript-as-a-template-engine-in-node-j-8b54ac30539b",
        "document": "Template engines are crucial for rendering dynamic content in web applications. EJS (Embedded JavaScript) is a popular and simple-to-use template engine for Node.js that allows embedding JavaScript logic into HTML files. This blog will guide you through integrating and using EJS in your Node.js application.\n\nBy the end of this module, you’ll learn:\n• What EJS is and why it’s useful.\n• How to set up EJS in a Node.js application.\n• How to render dynamic content using EJS.\n• How to pass data from the server to the frontend.\n\nEJS stands for Embedded JavaScript. It enables the use of JavaScript to generate dynamic HTML on the server. Key features include:\n• Partial Support: Ability to reuse components like headers and footers.\n\nCreate an file and configure EJS as the template engine.\n\nIn the root directory, create a folder named . Inside it, create an file with the following content:\n\nUpdate to send data to the EJS template:\n\nModify the file to pass more complex data:\n\nCreate a new file in the folder:\n\nInclude it in your templates using :\n• What is the purpose of setting the in Express?\n• How can you reuse a component (e.g., a footer) across multiple templates in EJS?\n• What is the difference between and in EJS?\n\nEJS is a powerful and lightweight template engine that allows you to embed JavaScript logic directly into your HTML. Its simplicity and flexibility make it an excellent choice for rendering dynamic content in Node.js applications. By mastering EJS, you can efficiently manage templates, pass dynamic data, and enhance the user experience in your web applications."
    },
    {
        "link": "https://topcoder.com/thrive/articles/using-ejs-template-engine-with-express-js",
        "document": "Template engine is a part of Express that enables us to use static files in our applications.Template engine converts variables to values and changes the template to HTML files to send to the client.\n\nThe default template engine of Express is Jade, but EJS is the most commonly used engine. In this article we will be discussing EJS only.\n\nIn this article we will cover\n\nIf you don’t have nodeJS installed see How to install and configure nodeJS.\n\nOpen up the terminal and create the project directory.\n\nThen, navigate to the directory.\n\nNow, initialize npm in it.\n\nLet’s install the npm modules we will need to build the application.\n\nLet’s install another module that will rerun our application automatically every time we make changes to it.\n\nWhen we have all the required modules, create a server.js file and configure it to use EJS.\n\nAlso, set routes for the index page and magic page.\n\nCreate a server.js file, open your editor, and write down the following code:\n\nLet’s understand what this code does.\n\nWe are importing the Express module and declaring its instance as an app.\n\nWe are setting up a server to listen at port 8080 by using app.listen().\n\nWe are telling our server to use EJS template engine in line,\n\napp.set(“view engine”, “ejs”).\n\nWe also set up routes / and /magic to render index and magic EJS pages respectively.\n\nYou can notice that our server shows user HTML content by using res.render(). Note that this res.render method will look for EJS files in the views directory so we only have to give the file name overall path will be interpreted as /views/index .\n\nStart the server by running the following command in the terminal.\n\nNow we will create view using EJS.\n\nBefore we start implementing partials, let’s understand what partials are. Partials are code blocks that are reused many times in an application. For example, in this tutorial we are going to create two view pages, index and magic, and in both of these files we will need to write a header and footer. We can create a separate one for each and reuse it in both view pages. Let’s create the files header.ejs and footer.ejs now.\n\nNow create header.ejs in partials directory, open that file in your editor, and write down the following code.\n\nThis EJS code is similar to HTML, there are no EJS variables. It is simple HTML containing a header component which also loads CDN to semantic UI (a CSS library). Then, in the body section we have navbar created using Simatic UI classes in HTML under tags.\n\nCreate the footer.js file inside partials and write down the given code.\n\nNow we will use these partials in our view files index and magic.\n\nWe have two partials defined. We will use them in index.ejs view page.\n\nWe can include any partial by writing the following syntax where we want to import a partial.\n\nNote: we have replaced all occurances of with due to syntax highlighter issues.\n\nNow create an index.ejs file in views directory and write down the given code.\n\nSave file, open browser, and enter url localhost:8080. You should see this web page.\n\nNow create magic.ejs and write down the code as given.\n\nAnd now visit localhost:8080/magic in the browser.\n\n\n\nNow let’s see how we can pass data to view pages.\n\nLet’s set up some variables and lists to pass to index.js.\n\nOpen server.js and modify the index route as given.\n\nLet’s use the variables we just defined in index.ejs.\n\nA single variable can be represented by using syntax <%= variable_name %>.\n\nWe can use subheading in index.ejs that we passed as given.\n\nAnd now you should see the webpage in your browser as:\n\nNow we know how to render a single variable. Let’s see how we can loop over a list to display each element of the list.\n\nWe can iterate over an array using .forEach function of Javascript.\n\nOpen index.js and modify it as:\n\nYou can notice that for each character in the characters array we passed we are displaying a list point with name and designation associated with each. If you open the browser, the webpage will now look like:\n\nIn this article you learned how to render templates using EJS and how to pass variables between files. Hence, EJS helps to develop simple applications very easily."
    },
    {
        "link": "https://geeksforgeeks.org/use-ejs-as-template-engine-in-node-js",
        "document": "EJS (Embedded JavaScript) is a popular templating engine for Node.js that allows you to generate HTML markup with plain JavaScript. It is particularly useful for creating dynamic web pages, as it enables you to embed JavaScript logic directly within your HTML.\n\nEJS or Embedded Javascript Templating is a templating engine used by Node.js. Template engine helps to create an HTML template with minimal code. Also, it can inject data into an HTML template on the client side and produce the final HTML. EJS is a simple templating language that is used to generate HTML markup with plain JavaScript. It also helps to embed JavaScript into HTML pages.\n\nSteps to Use EJS as Template Engine\n\nTo begin with, using EJS as templating engine we need to install EJS using the given command:\n\nIt will install exxpress and ejs as dependency in the node.js project.\n\nThe default behavior of EJS is that it looks into the ‘views’ folder for the templates to render. So, let’s make a ‘views’ folder in our main node project folder and make a file named “home.ejs” which is to be served on some desired requests in our node project. The content of this page is:\n\nNow, we will render this page on a certain request by the user:\n\nNow, the page home.ejs will be displayed on requesting localhost. To add dynamic content this render method takes a second parameter which is an object. This is done as:\n\nNow, We will embed the name to the HTML page as:\n\nIt is used to embed dynamic content to the page and is used to embed normal JavaScript. Now embedding normal JavaScript:\n\nSteps to run the program: After creating all the files go to the root directory of your project folder and run the below command\n\nType the node file_name.js command to run your program and see the output as displayed.\n• Embedded JavaScript: Allows you to embed JavaScript logic directly within your HTML.\n• Partial Templates: Supports partials, enabling you to reuse common template fragments (like headers and footers) across different pages.\n• Layout Support: EJS can be used with layout managers to create consistent layouts across multiple views.\n\nEJS is a powerful and flexible templating engine that enhances your Node.js applications by allowing you to generate dynamic HTML content with ease. Its simplicity and integration with Express make it an ideal choice for developers looking to build server-rendered web applications quickly. Whether you’re developing a simple site or a complex web application, EJS provides the tools you need to create dynamic and interactive user interfaces."
    }
]