[
    {
        "link": "https://developer.android.com/develop/ui/views/layout/recyclerview",
        "document": "Save and categorize content based on your preferences.\n\nRecyclerView makes it easy to efficiently display large sets of data. You supply the data and define how each item looks, and the RecyclerView library dynamically creates the elements when they're needed.\n\nAs the name implies, RecyclerView recycles those individual elements. When an item scrolls off the screen, RecyclerView doesn't destroy its view. Instead, RecyclerView reuses the view for new items that have scrolled onscreen. RecyclerView improves performance and your app's responsiveness, and it reduces power consumption.\n\nSeveral classes work together to build your dynamic list.\n• None is the that contains the views corresponding to your data. It's a view itself, so you add to your layout the way you would add any other UI element.\n• None Each individual element in the list is defined by a view holder object. When the view holder is created, it doesn't have any data associated with it. After the view holder is created, the binds it to its data. You define the view holder by extending .\n• None The requests views, and binds the views to their data, by calling methods in the adapter. You define the adapter by extending .\n• None The layout manager arranges the individual elements in your list. You can use one of the layout managers provided by the RecyclerView library, or you can define your own. Layout managers are all based on the library's abstract class.\n\nYou can see how all the pieces fit together in the RecyclerView sample app (Kotlin) or RecyclerView sample app (Java).\n\nIf you're going to use RecyclerView, there are a few things you need to do. They are explained in detail in the following sections.\n• None Decide how the list or grid looks. Ordinarily, you can use one of the RecyclerView library's standard layout managers.\n• None Design how each element in the list looks and behaves. Based on this design, extend the class. Your version of provides all the functionality for your list items. Your view holder is a wrapper around a , and that view is managed by .\n• None Define the that associates your data with the views.\n\nThere are also advanced customization options that let you tailor your RecyclerView to your exact needs.\n\nThe items in your RecyclerView are arranged by a class. The RecyclerView library provides three layout managers, which handle the most common layout situations:\n• arranges the items in a two-dimensional grid:\n• If the grid is arranged vertically, tries to make all the elements in each row have the same width and height, but different rows can have different heights.\n• If the grid is arranged horizontally, tries to make all the elements in each column have the same width and height, but different columns can have different widths.\n• is similar to , but it does not require that items in a row have the same height (for vertical grids) or items in the same column have the same width (for horizontal grids). The result is that the items in a row or column can end up offset from each other.\n\nYou also need to design the layout of the individual items. You need this layout when you design the view holder, as described in the next section.\n\nOnce you determine your layout, you need to implement your and . These two classes work together to define how your data is displayed. The is a wrapper around a that contains the layout for an individual item in the list. The creates objects as needed and also sets the data for those views. The process of associating views to their data is called binding.\n\nWhen you define your adapter, you override three key methods:\n• None : calls this method whenever it needs to create a new . The method creates and initializes the and its associated , but does not fill in the view's contents—the has not yet been bound to specific data.\n• None : calls this method to associate a with data. The method fetches the appropriate data and uses the data to fill in the view holder's layout. For example, if the displays a list of names, the method might find the appropriate name in the list and fill in the view holder's widget.\n• None : calls this method to get the size of the dataset. For example, in an address book app, this might be the total number of addresses. RecyclerView uses this to determine when there are no more items that can be displayed.\n\nHere's a typical example of a simple adapter with a nested that displays a list of data. In this case, the RecyclerView displays a simple list of text elements. The adapter is passed an array of strings containing the text for the elements.\n\n> * Provide a reference to the type of views that you are using // Create new views (invoked by the layout manager) // Create a new view, which defines the UI of the list item // Replace the contents of a view (invoked by the layout manager) // Get element from your dataset at this position and replace the // contents of the view with that element // Return the size of your dataset (invoked by the layout manager) > * Provide a reference to the type of views that you are using * Initialize the dataset of the Adapter * @param dataSet String[] containing the data to populate views to be used // Create new views (invoked by the layout manager) // Create a new view, which defines the UI of the list item // Replace the contents of a view (invoked by the layout manager) // Get element from your dataset at this position and replace the // contents of the view with that element // Return the size of your dataset (invoked by the layout manager)\n\nThe layout for the each view item is defined in an XML layout file, as usual. In this case, the app has a file like this:\n\nThe following code snippet shows how you can use the .\n\nThe library also offers many ways to customize your implementation. For more information, see Advanced RecyclerView customization.\n\nFollow these steps to enable an edge-to-edge display for a :\n• If the list items initially overlap the system bars, apply insets on the . You can do this by setting to or by using .\n• Allow the list items to draw under the system bars while scrolling by setting to on the .\n\nThe following video shows a with edge-to-edge display disabled (left) and enabled (right):\n\nFor more information about testing on Android, consult the following resources."
    },
    {
        "link": "https://developer.android.com/develop/ui/views/layout/declaring-layout",
        "document": "Save and categorize content based on your preferences.\n\nA layout defines the structure for a user interface in your app, such as in an activity. All elements in the layout are built using a hierarchy of and objects. A usually draws something the user can see and interact with. A is an invisible container that defines the layout structure for and other objects, as shown in figure 1.\n\nobjects are often called widgets and can be one of many subclasses, such as or . The objects are usually called layouts and can be one of many types that provide a different layout structure, such as or .\n\nYou can declare a layout in two ways:\n• Declare UI elements in XML. Android provides a straightforward XML vocabulary that corresponds to the classes and subclasses, such as those for widgets and layouts. You can also use Android Studio's Layout Editor to build your XML layout using a drag-and-drop interface.\n• Instantiate layout elements at runtime. Your app can create and objects and manipulate their properties programmatically.\n\nDeclaring your UI in XML lets you separate the presentation of your app from the code that controls its behavior. Using XML files also makes it easier to provide different layouts for different screen sizes and orientations. This is discussed further in Support different screen sizes.\n\nThe Android framework gives you the flexibility to use either or both of these methods to build your app's UI. For example, you can declare your app's default layouts in XML, and then modify the layout at runtime.\n\nUsing Android's XML vocabulary, you can quickly design UI layouts and the screen elements they contain, in the same way that you create web pages in HTML with a series of nested elements.\n\nEach layout file must contain exactly one root element, which must be a or object. After you define the root element, you can add additional layout objects or widgets as child elements to gradually build a hierarchy that defines your layout. For example, here's an XML layout that uses a vertical to hold a and a :\n\nAfter you declare your layout in XML, save the file with the extension in your Android project's directory so it properly compiles.\n\nFor more information about the syntax for a layout XML file, see Layout resource.\n\nWhen you compile your app, each XML layout file is compiled into a resource. Load the layout resource in your app's callback implementation. Do so by calling , passing it the reference to your layout resource in the form: . For example, if your XML layout is saved as , load it for your as follows:\n\nThe Android framework calls the callback method in your when the launches. For more information about activity lifecycles, see Introduction to activities.\n\nEvery and object supports its own variety of XML attributes. Some attributes are specific to a object. For example, supports the attribute. However, these attributes are also inherited by any objects that extend this class. Some are common to all objects, because they are inherited from the root class, like the attribute. Other attributes are considered layout parameters, which are attributes that describe certain layout orientations of the object, as defined by that object's parent object.\n\nAny object can have an integer ID associated with it to uniquely identify the within the tree. When the app is compiled, this ID is referenced as an integer, but the ID is typically assigned in the layout XML file as a string in the attribute. This is an XML attribute common to all objects, and it is defined by the class. You use it very often. The syntax for an ID inside an XML tag is the following:\n\nThe at symbol (@) at the beginning of the string indicates that the XML parser parses and expands the rest of the ID string and identifies it as an ID resource. The plus symbol (+) means this is a new resource name that must be created and added to your resources in the file.\n\nThe Android framework offers many other ID resources. When referencing an Android resource ID, you don't need the plus symbol, but you must add the package namespace as follows:\n\nThe package namespace indicates that you're referencing an ID from the resources class, rather than the local resources class.\n\nTo create views and reference them from your app, you can use a common pattern as follows:\n• Define a view in the layout file and assign it a unique ID, as in the following example:\n• Create an instance of the view object and capture it from the layout, typically in the method, as shown in the following example:\n\nDefining IDs for view objects is important when creating a . In a relative layout, sibling views can define their layout relative to another sibling view, which is referenced by the unique ID.\n\nAn ID doesn't need to be unique throughout the entire tree, but it must be unique within the part of the tree you search. It might often be the entire tree, so it's best to make it unique when possible.\n\nXML layout attributes named define layout parameters for the that are appropriate for the it resides in.\n\nEvery class implements a nested class that extends . This subclass contains property types that define the size and position of each child view, as appropriate for the view group. As shown in figure 2, the parent view group defines layout parameters for each child view, including the child view group.\n\nEvery subclass has its own syntax for setting values. Each child element must define a that is appropriate for its parent, though it might also define a different for its own children.\n\nAll view groups include a width and height, using and , and each view is required to define them. Many include optional margins and borders.\n\nYou can specify width and height with exact measurements, but you might not want to do this often. More often, you use one of these constants to set the width or height:\n• : tells your view to size itself to the dimensions required by its content.\n• : tells your view to become as big as its parent view group allows.\n\nIn general, we don't recommend specifying a layout width and height using absolute units such as pixels. A better approach is using relative measurements, such as density-independent pixel units (dp), , or , because it helps your app display properly across a variety of device screen sizes. The accepted measurement types are defined in Layout resource.\n\nA view has rectangular geometry. It has a location, expressed as a pair of left and top coordinates, and two dimensions, expressed as a width and height. The unit for location and dimensions is the pixel.\n\nYou can retrieve the location of a view by invoking the methods and . The former returns the left (x) coordinate of the rectangle representing the view. The latter returns the top (y) coordinate of the rectangle representing the view. These methods return the location of the view relative to its parent. For example, when returns 20, this means the view is located 20 pixels to the right of the left edge of its direct parent.\n\nIn addition, there are convenience methods to avoid unnecessary computations: namely and . These methods return the coordinates of the right and bottom edges of the rectangle representing the view. For example, calling is similar to the following computation: .\n\nThe size of a view is expressed with a width and height. A view has two pairs of width and height values.\n\nThe first pair is known as measured width and measured height. These dimensions define how big a view wants to be within its parent. You can obtain the measured dimensions by calling and .\n\nThe second pair is known as width and height, or sometimes drawing width and drawing height. These dimensions define the actual size of the view on screen, at drawing time and after layout. These values might, but don't have to, differ from the measured width and height. You can obtain the width and height by calling and .\n\nTo measure its dimensions, a view takes into account its padding. The padding is expressed in pixels for the left, top, right and bottom parts of the view. You can use padding to offset the content of the view by a specific number of pixels. For instance, a left padding of two pushes the view's content two pixels to the right of the left edge. You can set padding using the method and query it by calling , , , and .\n\nAlthough a view can define a padding, it doesn't support margins. However, view groups do support margins. See and for more information.\n\nFor more information about dimensions, see Dimension.\n\nBesides setting margins and padding programmatically, you can also set them in your XML layouts, as shown in the following example:\n\nThe preceding example shows margin and padding being applied. The has uniform margins and padding applied all around, and the shows how you can apply them independently to different edges.\n\nEach subclass of the class provides a unique way to display the views you nest within it. The most flexible layout type, and the one that provides the best tools for keeping your layout hierarchy shallow, is .\n\nThe following are some of the common layout types built into the Android platform.\n\nWhen the content for your layout is dynamic or not pre-determined, you can use or a subclass of . is generally the better option, because it uses memory more efficiently than .\n\nCommon layouts possible with and include the following:\n\noffers more possibilities and the option to create a custom layout manager.\n\nYou can populate an such as or by binding the instance to an , which retrieves data from an external source and creates a that represents each data entry.\n\nAndroid provides several subclasses of that are useful for retrieving different kinds of data and building views for an . The two most common adapters are:\n\nIf during the course of your app's life you change the underlying data that is read by your adapter, call . This notifies the attached view that the data has been changed and it refreshes itself.\n\nYou can respond to click events on each item in an by implementing the interface. For example:\n\nSee how layouts are used in the Sunflower demo app on GitHub."
    },
    {
        "link": "https://stackoverflow.com/questions/46757499/how-do-you-specify-attributes-for-a-layoutmanager-assigned-via-recyclerviews-l",
        "document": "According to Google's RecyclerView documentation, you can set a specific from within a layout file by specifying its class name in the 's 'layoutManager' attribute. It also specifically mentions has a constructor which accepts an .\n\nMy question is since you're specifying the via an attribute on the 's element, and not as its own element, where/how do you set the attributes targeted for the itself?\n\nMy guess is you add them directly to the element as well. This would make sense as inside the 's constructor, when it instantiates the specified in the 'layoutManager' attribute, it could simply pass through the same that was passed in to it. However, this is only a guess.\n\nHere's an example of what I'm thinking is the correct way:\n\nNote how all three attributes are technically set on the element, but the thinking is the third attribute is ignored by, and passed through from 's constructor into 's constructor.\n\nI'm trying to build a demo app to test that theory out now, but in the meantime, can anyone clarify for sure, or at least point me in the right direction if this is incorrect?"
    },
    {
        "link": "https://geeksforgeeks.org/android-recyclerview",
        "document": "RecyclerView is a ViewGroup added to the android studio as a successor of the GridView and ListView. It is an improvement on both of them and can be found in the latest v-7 support packages. It has been created to make possible construction of any lists with XML layouts as an item which can be customized vastly while improving on the efficiency of ListViews and GridViews. This improvement is achieved by recycling the views which are out of the visibility of the user.\n\nLet us check, Android RecyclerView with a simple example.\n\nExample: An Android Application showing the Exam Schedule\n\nTo implement a basic RecyclerView three sub-parts are needed to be constructed which offer the users the degree of control they require in making varying designs of their choice.\n• The Card Layout: The card layout is an XML layout which will be treated as an item for the list created by the RecyclerView.\n• The ViewHolder: The ViewHolder is a java class that stores the reference to the card layout views that have to be dynamically modified during the execution of the program by a list of data obtained either by online databases or added in some other way.\n• The Data Class: The Data class is a custom java class that acts as a structure for holding the information for every item of the RecyclerView.\n• None Click on File, then New => New Project.\n• None Select the minimum SDK(According to the application needs).\n\nLayouts are important part of the Android Applications. This Application will need two main layouts as mentioned below:\n\nexam_card.xml: (This is the Layout of the element to be inserted in RecyclerView)\n\nStep 2: Defining the Elements to be Inserted in Card\n\nWe have two layouts now, but the elements to be placed in the exam_card.xml needs to be defined. So, create a new file named ExamItem file. Properties like name, date, message, image1 and image2.\n\nThe Adapter: The adapter is the main code responsible for RecyclerView. It holds all the important methods dealing with the implementation of RecylcerView. The basic methods for a successful implementation are:\n• onCreateViewHolder: which deals with the inflation of the card layout as an item for the RecyclerView.\n• onBindViewHolder: which deals with the setting of different data and methods related to clicks on particular items of the RecyclerView.\n• getItemCount: which Returns the length of the RecyclerView.\n• onAttachedToRecyclerView: which attaches the adapter to the RecyclerView.\n\nAfter, defining the whole application properties and providing the functionality to the layouts, we will wrap all of them into MainActivity file. OnCreate Method is defined in this file.\n\nKeep in mind, that the drawable mentioned in the XML layouts have to be added to the drawable folder under res of the Android Studio Project and support package v7 should be added as an implementation in the Gradle file of the project for the code to run. The above code uses ScrollView as a parent to RecyclerView and disables the scrolling of the RecyclerView hence making the whole page scroll instead of just the RecyclerView contents."
    },
    {
        "link": "https://stackoverflow.com/questions/35679776/how-to-set-recyclerview-applayoutmanager-from-xml",
        "document": "As you can check in the doc:\n\nClass name of the to be used.\n\nThe class must extend and have either a default constructor or constructor with the signature\n\nIf the name starts with a , application package is prefixed. Else, if the name contains a , the classname is assumed to be a full class name. Else, the recycler view package ( ) is prefixed"
    },
    {
        "link": "https://developer.android.com/develop/ui/views/layout/recyclerview",
        "document": "Save and categorize content based on your preferences.\n\nRecyclerView makes it easy to efficiently display large sets of data. You supply the data and define how each item looks, and the RecyclerView library dynamically creates the elements when they're needed.\n\nAs the name implies, RecyclerView recycles those individual elements. When an item scrolls off the screen, RecyclerView doesn't destroy its view. Instead, RecyclerView reuses the view for new items that have scrolled onscreen. RecyclerView improves performance and your app's responsiveness, and it reduces power consumption.\n\nSeveral classes work together to build your dynamic list.\n• None is the that contains the views corresponding to your data. It's a view itself, so you add to your layout the way you would add any other UI element.\n• None Each individual element in the list is defined by a view holder object. When the view holder is created, it doesn't have any data associated with it. After the view holder is created, the binds it to its data. You define the view holder by extending .\n• None The requests views, and binds the views to their data, by calling methods in the adapter. You define the adapter by extending .\n• None The layout manager arranges the individual elements in your list. You can use one of the layout managers provided by the RecyclerView library, or you can define your own. Layout managers are all based on the library's abstract class.\n\nYou can see how all the pieces fit together in the RecyclerView sample app (Kotlin) or RecyclerView sample app (Java).\n\nIf you're going to use RecyclerView, there are a few things you need to do. They are explained in detail in the following sections.\n• None Decide how the list or grid looks. Ordinarily, you can use one of the RecyclerView library's standard layout managers.\n• None Design how each element in the list looks and behaves. Based on this design, extend the class. Your version of provides all the functionality for your list items. Your view holder is a wrapper around a , and that view is managed by .\n• None Define the that associates your data with the views.\n\nThere are also advanced customization options that let you tailor your RecyclerView to your exact needs.\n\nThe items in your RecyclerView are arranged by a class. The RecyclerView library provides three layout managers, which handle the most common layout situations:\n• arranges the items in a two-dimensional grid:\n• If the grid is arranged vertically, tries to make all the elements in each row have the same width and height, but different rows can have different heights.\n• If the grid is arranged horizontally, tries to make all the elements in each column have the same width and height, but different columns can have different widths.\n• is similar to , but it does not require that items in a row have the same height (for vertical grids) or items in the same column have the same width (for horizontal grids). The result is that the items in a row or column can end up offset from each other.\n\nYou also need to design the layout of the individual items. You need this layout when you design the view holder, as described in the next section.\n\nOnce you determine your layout, you need to implement your and . These two classes work together to define how your data is displayed. The is a wrapper around a that contains the layout for an individual item in the list. The creates objects as needed and also sets the data for those views. The process of associating views to their data is called binding.\n\nWhen you define your adapter, you override three key methods:\n• None : calls this method whenever it needs to create a new . The method creates and initializes the and its associated , but does not fill in the view's contents—the has not yet been bound to specific data.\n• None : calls this method to associate a with data. The method fetches the appropriate data and uses the data to fill in the view holder's layout. For example, if the displays a list of names, the method might find the appropriate name in the list and fill in the view holder's widget.\n• None : calls this method to get the size of the dataset. For example, in an address book app, this might be the total number of addresses. RecyclerView uses this to determine when there are no more items that can be displayed.\n\nHere's a typical example of a simple adapter with a nested that displays a list of data. In this case, the RecyclerView displays a simple list of text elements. The adapter is passed an array of strings containing the text for the elements.\n\n> * Provide a reference to the type of views that you are using // Create new views (invoked by the layout manager) // Create a new view, which defines the UI of the list item // Replace the contents of a view (invoked by the layout manager) // Get element from your dataset at this position and replace the // contents of the view with that element // Return the size of your dataset (invoked by the layout manager) > * Provide a reference to the type of views that you are using * Initialize the dataset of the Adapter * @param dataSet String[] containing the data to populate views to be used // Create new views (invoked by the layout manager) // Create a new view, which defines the UI of the list item // Replace the contents of a view (invoked by the layout manager) // Get element from your dataset at this position and replace the // contents of the view with that element // Return the size of your dataset (invoked by the layout manager)\n\nThe layout for the each view item is defined in an XML layout file, as usual. In this case, the app has a file like this:\n\nThe following code snippet shows how you can use the .\n\nThe library also offers many ways to customize your implementation. For more information, see Advanced RecyclerView customization.\n\nFollow these steps to enable an edge-to-edge display for a :\n• If the list items initially overlap the system bars, apply insets on the . You can do this by setting to or by using .\n• Allow the list items to draw under the system bars while scrolling by setting to on the .\n\nThe following video shows a with edge-to-edge display disabled (left) and enabled (right):\n\nFor more information about testing on Android, consult the following resources."
    },
    {
        "link": "https://stackoverflow.com/questions/35679776/how-to-set-recyclerview-applayoutmanager-from-xml",
        "document": "As you can check in the doc:\n\nClass name of the to be used.\n\nThe class must extend and have either a default constructor or constructor with the signature\n\nIf the name starts with a , application package is prefixed. Else, if the name contains a , the classname is assumed to be a full class name. Else, the recycler view package ( ) is prefixed"
    },
    {
        "link": "https://developer.android.com/reference/androidx/recyclerview/widget/LinearLayoutManager",
        "document": "Save and categorize content based on your preferences.\n\nA implementation which provides similar functionality to .\n\nChecks if RecyclerView is in the middle of a layout or scroll and throws an if it is. Gather all positions from the LayoutManager to be prefetched, given specified momentum. Gather all positions from the LayoutManager to be prefetched in preperation for its RecyclerView to come on screen, due to the movement of another, containing RecyclerView. Override this method if you want to support scroll bars. Override this method if you want to support scroll bars. Override this method if you want to support scroll bars. Should calculate the vector that points to the direction where the target position can be found. Override this method if you want to support scroll bars. Override this method if you want to support scroll bars. Override this method if you want to support scroll bars. Returns the adapter position of the first fully visible view. Returns the adapter position of the first visible view. Returns the adapter position of the last fully visible view. Returns the adapter position of the last visible view. Finds the view which represents the given adapter position. Create a default object for a child of the RecyclerView. Gets the number of items to prefetch in , which defines how many inner items should be prefetched when this LayoutManager's RecyclerView is nested inside another RecyclerView. Returns the current orientation of the layout. Returns whether LayoutManager will recycle its children when it is detached from RecyclerView. Returns if views are laid out from the opposite direction of the layout. Returns whether the measuring pass of layout should use the AutoMeasure mechanism of or if it should be done by the LayoutManager's implementation of . Query if the layout is in reverse order. Returns the current state of the smooth scrollbar feature. Called when this LayoutManager is detached from its parent RecyclerView or when its parent RecyclerView is detached from its window. Called when searching for a focusable view in the given direction has failed for the current content of the RecyclerView. Called by the AccessibilityDelegate when the information about the current layout should be populated. Lay out all relevant child views from the given adapter. Called when the RecyclerView is ready to restore the state based on a previous RecyclerView. Called when the LayoutManager should save its state. Called by the after a View is dropped over another View. Scroll horizontally by dx pixels in screen coordinates and return the distance traveled. Scroll the RecyclerView to make the position visible. Scroll to the specified adapter position with the given offset from resolved layout start. Scroll vertically by dy pixels in screen coordinates and return the distance traveled. Sets the number of items to prefetch in , which defines how many inner items should be prefetched when this LayoutManager's RecyclerView is nested inside another RecyclerView. Sets the orientation of the layout. Set whether LayoutManager will recycle its children when it is detached from RecyclerView. Used to reverse item traversal and layout order. When smooth scrollbar is enabled, the position and size of the scrollbar thumb is computed based on the number of visible pixels in the visible items. Smooth scroll to the specified adapter position.\n\nTo be called only during to add a view to the layout that is known to be going away, either because it has been or because it is actually not in the visible portion of the container but is being laid out in order to inform RecyclerView in how to animate the item out of view. To be called only during to add a view to the layout that is known to be going away, either because it has been or because it is actually not in the visible portion of the container but is being laid out in order to inform RecyclerView in how to animate the item out of view. Add a view to the currently attached RecyclerView if needed. Add a view to the currently attached RecyclerView if needed. Checks if RecyclerView is in the middle of a layout or scroll and throws an if it is not. Calculates the item decor insets applied to the given child and updates the provided Rect instance with the inset values. Determines the validity of the supplied LayoutParams object. Chooses a size from the given specs and parameters that is closest to the desired size and also complies with the spec. Temporarily detach and scrap all currently attached child views. Detach a child view and add it to a scrap heap. Detach a child view and add it to a scrap heap. Ends all animations on the view created by the . Traverses the ancestors of the given view and returns the item view that contains it and also a direct child of the LayoutManager. Create a LayoutParams object suitable for this LayoutManager, copying relevant values from the supplied LayoutParams object if possible. Create a LayoutParams object suitable for this LayoutManager from an inflated layout resource. Returns offset of the RecyclerView's text baseline from the its top boundary. Returns the total height of item decorations applied to child's bottom. Return the child view at the given index Return the current number of child views attached to the parent RecyclerView. Calculate a MeasureSpec value for measuring a child view in one dimension. Check if the RecyclerView is configured to clip child views to its padding. Returns the number of columns for accessibility. Returns the bottom edge of the given child view within its parent, offset by any applied . Returns the bounds of the view including its decoration and margins. Returns the left edge of the given child view within its parent, offset by any applied . Returns the measured height of the given child, plus the additional size of any insets applied by . Returns the measured width of the given child, plus the additional size of any insets applied by . Returns the right edge of the given child view within its parent, offset by any applied . Returns the top edge of the given child view within its parent, offset by any applied . Returns the item View which has or contains focus. Returns the height that is currently relevant to the LayoutManager. Return the height measurement spec mode that is currently relevant to the LayoutManager. Returns the number of items in the adapter bound to the parent RecyclerView. Returns the View type defined by the adapter. Returns the resolved layout direction for this RecyclerView. Returns the total width of item decorations applied to child's left. Return the bottom padding of the parent RecyclerView Return the end padding of the parent RecyclerView Return the left padding of the parent RecyclerView Return the right padding of the parent RecyclerView Return the start padding of the parent RecyclerView Return the top padding of the parent RecyclerView Returns the adapter position of the item represented by the given View. Parse the xml attributes to get the most common properties used by layout managers. Returns the total width of item decorations applied to child's right. Returns the number of rows for accessibility. Returns the total height of item decorations applied to child's top. Calculates the bounding box of the View while taking into account its matrix changes (translation, scale etc) with respect to the RecyclerView. Returns the width that is currently relevant to the LayoutManager. Return the width measurement spec mode that is currently relevant to the LayoutManager. Returns true if the RecyclerView this LayoutManager is bound to has or contains focus. Flags a view so that it will not be scrapped or recycled. Returns whether LayoutManager is currently attached to a RecyclerView which is attached to a window. Returns true if the RecyclerView this LayoutManager is bound to has focus. Sets whether the LayoutManager should be queried for views outside of its viewport while the UI thread is idle between frames. Returns whether layout is hierarchical or not to be used for accessibility. In addition to the View Framework's measurement cache, RecyclerView uses its own additional measurement cache for its children to avoid re-measuring them when not necessary. Returns whether the given child view is partially or fully visible within the padded bounded area of RecyclerView, depending on the input parameters. Lay out the given child view within the RecyclerView using coordinates that include any current . Lay out the given child view within the RecyclerView using coordinates that include any current and margins. Measure a child view using standard measurement policy, taking the padding of the parent RecyclerView and any added item decorations into account. Measure a child view using standard measurement policy, taking the padding of the parent RecyclerView, any added item decorations and the child margins into account. Moves a View from one position to another. Offset all child views attached to the parent RecyclerView by dx pixels along the horizontal axis. Offset all child views attached to the parent RecyclerView by dy pixels along the vertical axis. Called if the RecyclerView this LayoutManager is bound to has a different adapter set via or . Called to populate focusable views within the RecyclerView. Called when this LayoutManager is both attached to a RecyclerView and that RecyclerView is attached to a window. Called by the accessibility delegate to initialize an accessibility event. Called by the AccessibilityDelegate when the accessibility information for a specific item should be populated. This method gives a LayoutManager an opportunity to intercept the initial focus search before the default behavior of is used. Called when items have been added to the adapter. Called in response to a call to or ()} and signals that the the entire data set has changed. Called when an item is moved withing the adapter. Called when items have been removed from the adapter. Called when items have been changed in the adapter. Called when items have been changed in the adapter and with optional payload. Called when a descendant view of the RecyclerView requests focus. RecyclerView calls this method to notify LayoutManager that scroll state has changed. Called by AccessibilityDelegate when an action is requested from the RecyclerView. Called by AccessibilityDelegate when an accessibility action is requested on one of the children of LayoutManager. Causes the Runnable to execute on the next animation time step. Remove all views from the currently attached RecyclerView. Removes all views and recycles them using the given recycler. Remove a child view and recycle it using the given Recycler. Remove a child view and recycle it using the given Recycler. Removes the specified Runnable from the message queue. Remove a view from the currently attached RecyclerView if needed. Remove a view from the currently attached RecyclerView if needed. Called when a child of the RecyclerView wants a particular rectangle to be positioned onto the screen. Requests that the given child of the RecyclerView be positioned onto the screen. A LayoutManager can call this method to force RecyclerView to run simple animations in the next layout pass, even if there is not any trigger to do so. Implementors of LayoutManager should define whether or not it uses AutoMeasure by overriding . Sets whether the LayoutManager should be queried for views outside of its viewport while the UI thread is idle between frames. Sets the measured dimensions from the given bounding box of the children and the measurement specs that were passed into . Sets whether RecyclerView should use its own measurement cache for the children. View can be scrapped and recycled again.\n\nChecks if RecyclerView is in the middle of a layout or scroll and throws an if it is. The message for the exception. Can be null. Gather all positions from the LayoutManager to be prefetched, given specified momentum. If item prefetch is enabled, this method is called in between traversals to gather which positions the LayoutManager will soon need, given upcoming movement in subsequent traversals. The LayoutManager should call for each item to be prepared, and these positions will have their ViewHolders created and bound, if there is sufficient time available, in advance of being needed by a scroll or layout. Gather all positions from the LayoutManager to be prefetched in preperation for its RecyclerView to come on screen, due to the movement of another, containing RecyclerView. This method is only called when a RecyclerView is nested in another RecyclerView. If item prefetch is enabled for this LayoutManager, as well in another containing LayoutManager, this method is called in between draw traversals to gather which positions this LayoutManager will first need, once it appears on the screen. For example, if this LayoutManager represents a horizontally scrolling list within a vertically scrolling LayoutManager, this method would be called when the horizontal list is about to come onscreen. The LayoutManager should call for each item to be prepared, and these positions will have their ViewHolders created and bound, if there is sufficient time available, in advance of being needed by a scroll or layout. number of items in the associated adapter. Override this method if you want to support scroll bars. The horizontal extent of the scrollbar's thumb Override this method if you want to support scroll bars. Current State of RecyclerView where you can find total item count The horizontal offset of the scrollbar's thumb Override this method if you want to support scroll bars. Current State of RecyclerView where you can find total item count The total horizontal range represented by the horizontal scrollbar Should calculate the vector that points to the direction where the target position can be found. This method is used by the to initiate a scroll towards the target position. The magnitude of the vector is not important. It is always normalized before being used by the . LayoutManager should not check whether the position exists in the adapter or not. the target position to which the returned vector should point the scroll vector for a given position. Override this method if you want to support scroll bars. The vertical extent of the scrollbar's thumb Override this method if you want to support scroll bars. Current State of RecyclerView where you can find total item count The vertical offset of the scrollbar's thumb Override this method if you want to support scroll bars. Current State of RecyclerView where you can find total item count The total vertical range represented by the vertical scrollbar Returns the adapter position of the first fully visible view. This position does not include adapter changes that were dispatched after the last layout pass. Note that bounds check is only performed in the current orientation. That means, if LayoutManager is horizontal, it will only check the view's left and right edges. The adapter position of the first fully visible item or if there aren't any visible items. Returns the adapter position of the first visible view. This position does not include adapter changes that were dispatched after the last layout pass. Note that, this value is not affected by layout orientation or item order traversal. ( ). Views are sorted by their positions in the adapter, not in the layout. If RecyclerView has item decorators, they will be considered in calculations as well. LayoutManager may pre-cache some views that are not necessarily visible. Those views are ignored in this method. The adapter position of the first visible item or if there aren't any visible items. Returns the adapter position of the last fully visible view. This position does not include adapter changes that were dispatched after the last layout pass. Note that bounds check is only performed in the current orientation. That means, if LayoutManager is horizontal, it will only check the view's left and right edges. The adapter position of the last fully visible view or if there aren't any visible items. Returns the adapter position of the last visible view. This position does not include adapter changes that were dispatched after the last layout pass. Note that, this value is not affected by layout orientation or item order traversal. ( ). Views are sorted by their positions in the adapter, not in the layout. If RecyclerView has item decorators, they will be considered in calculations as well. LayoutManager may pre-cache some views that are not necessarily visible. Those views are ignored in this method. The adapter position of the last visible view or if there aren't any visible items. Finds the view which represents the given adapter position. This method traverses each child since it has no information about child order. Override this method to improve performance if your LayoutManager keeps data about child views. If a view is ignored via #ignoreView(View), it is also ignored by this method. Create a default object for a child of the RecyclerView. LayoutManagers will often want to use a custom type to store extra information specific to the layout. Client code should subclass for this purpose. Important: if you use your own custom type you must also override #checkLayoutParams(LayoutParams), #generateLayoutParams(android.view.ViewGroup.LayoutParams) and #generateLayoutParams(android.content.Context, android.util.AttributeSet). Gets the number of items to prefetch in , which defines how many inner items should be prefetched when this LayoutManager's RecyclerView is nested inside another RecyclerView. Returns the current orientation of the layout. Returns whether LayoutManager will recycle its children when it is detached from RecyclerView. true if LayoutManager will recycle its children when it is detached from RecyclerView. Returns if views are laid out from the opposite direction of the layout. If layout is reversed or not. Returns whether the measuring pass of layout should use the AutoMeasure mechanism of or if it should be done by the LayoutManager's implementation of . This method returns false by default (it actually returns the value passed to the deprecated ) and should be overridden to return true if a LayoutManager wants to be auto measured by the RecyclerView. If this method is overridden to return true, should not be overridden. AutoMeasure is a RecyclerView mechanism that handles the measuring pass of layout in a simple and contract satisfying way, including the wrapping of children laid out by LayoutManager. Simply put, it handles wrapping children by calling during a call to , and then calculating desired dimensions based on children's dimensions and positions. It does this while supporting all existing animation capabilities of the RecyclerView.\n• When is called, if the provided measure specs both have a mode of , RecyclerView will set its measured dimensions accordingly and return, allowing layout to continue as normal (Actually, RecyclerView will call for backwards compatibility reasons but it should not be overridden if AutoMeasure is being used).\n• If one of the layout specs is not , the RecyclerView will start the layout process. It will first process all pending Adapter updates and then decide whether to run a predictive layout. If it decides to do so, it will first call with set to . At this stage, and will still return the width and height of the RecyclerView as of the last layout calculation. After handling the predictive case, RecyclerView will call with set to and set to . The LayoutManager can access the measurement specs via , , and .\n• After the layout calculation, RecyclerView sets the measured width &height by calculating the bounding box for the children (+ RecyclerView's padding). The LayoutManagers can override to choose different values. For instance, GridLayoutManager overrides this value to handle the case where if it is vertical and has 3 columns but only 2 items, it should still measure its width to fit 3 items, not 2.\n• Any following calls to will run with set to and set to . RecyclerView will take care of which views are actually added / removed / moved / changed for animations so that the LayoutManager should not worry about them and handle each call as if it is the last one.\n• When measure is complete and RecyclerView's onLayout method is called, RecyclerView checks whether it already did layout calculations during the measure pass and if so, it re-uses that information. It may still decide to call if the last measure spec was different from the final dimensions or adapter contents have changed between the measure call and the layout call.\n• Finally, animations are calculated and run as usual. if the measuring pass of layout should use the AutoMeasure mechanism of or if it should be done by the LayoutManager's implementation of . Query if the layout is in reverse order. This will affect, for example, keyboard navigation via page up/page down. The default implementation returns false. true if this LayoutManager is currently in reverse order. Returns the current state of the smooth scrollbar feature. It is enabled by default. True if smooth scrollbar is enabled, false otherwise. Called when this LayoutManager is detached from its parent RecyclerView or when its parent RecyclerView is detached from its window. LayoutManager should clear all of its View references as another LayoutManager might be assigned to the RecyclerView. If the RecyclerView is re-attached with the same LayoutManager and Adapter, it may not call if nothing has changed and a layout was not requested on the RecyclerView while it was detached. If your LayoutManager has View references that it cleans in on-detach, it should also call to ensure that it is re-laid out when RecyclerView is re-attached. Subclass implementations should always call through to the superclass implementation. The RecyclerView this LayoutManager is bound to The recycler to use if you prefer to recycle your children instead of keeping them around. Called when searching for a focusable view in the given direction has failed for the current content of the RecyclerView. This is the LayoutManager's opportunity to populate views in the given direction to fulfill the request if it can. The LayoutManager should attach and return the view to be focused, if a focusable view in the given direction is found. Otherwise, if all the existing (or the newly populated views) are unfocusable, it returns the next unfocusable view to become visible on the screen. This unfocusable view is typically the first view that's either partially or fully out of RV's padded bounded area in the given direction. The default implementation returns null. One of , , , , , or 0 for not applicable The recycler to use for obtaining views for currently offscreen items The chosen view to be focused if a focusable view is found, otherwise an unfocusable view to become visible onto the screen, else null. Called by the AccessibilityDelegate when the information about the current layout should be populated. You should override , , and for more accurate accessibility information. The Recycler that can be used to convert view positions into adapter positions The info that should be filled by the LayoutManager Lay out all relevant child views from the given adapter. The LayoutManager is in charge of the behavior of item animations. By default, RecyclerView has a non-null #getItemAnimator() ItemAnimator, and simple item animations are enabled. This means that add/remove operations on the adapter will result in animations to add new or appearing items, removed or disappearing items, and moved items. If a LayoutManager returns false from #supportsPredictiveItemAnimations(), which is the default, and runs a normal layout operation during #onLayoutChildren(Recycler, State), the RecyclerView will have enough information to run those animations in a simple way. For example, the default ItemAnimator, , will simply fade views in and out, whether they are actually added/removed or whether they are moved on or off the screen due to other add/remove operations. A LayoutManager wanting a better item animation experience, where items can be animated onto and off of the screen according to where the items exist when they are not on screen, then the LayoutManager should return true from #supportsPredictiveItemAnimations() and add additional logic to #onLayoutChildren(Recycler, State). Supporting predictive animations means that #onLayoutChildren(Recycler, State) will be called twice; once as a \"pre\" layout step to determine where items would have been prior to a real layout, and again to do the \"real\" layout. In the pre-layout phase, items will remember their pre-layout positions to allow them to be laid out appropriately. Also, LayoutParams#isItemRemoved() removed items will be returned from the scrap to help determine correct placement of other items. These removed items should not be added to the child list, but should be used to help calculate correct positioning of other views, including views that were not previously onscreen (referred to as APPEARING views), but whose pre-layout offscreen position can be determined given the extra information about the pre-layout removed views. The second layout pass is the real layout in which only non-removed views will be used. The only additional requirement during this pass is, if #supportsPredictiveItemAnimations() returns true, to note which views exist in the child list prior to layout and which are not there after layout (referred to as DISAPPEARING views), and to position/layout those views appropriately, without regard to the actual bounds of the RecyclerView. This allows the animation system to know the location to which to animate these disappearing views. The default LayoutManager implementations for RecyclerView handle all of these requirements for animations already. Clients of RecyclerView can either use one of these layout managers directly or look at their implementations of onLayoutChildren() to see how they account for the APPEARING and DISAPPEARING views. Called after a full layout calculation is finished. The layout calculation may include multiple calls due to animations or layout measurement but it will include only one call. This method will be called at the end of call. This is a good place for the LayoutManager to do some cleanup like pending scroll position, saved state etc. Called when the RecyclerView is ready to restore the state based on a previous RecyclerView. Notice that this might happen after an actual layout, based on how Adapter prefers to restore State. See for more information. The parcelable that was returned by the previous LayoutManager's method. Called when the LayoutManager should save its state. This is a good time to save your scroll position, configuration and anything else that may be required to restore the same layout state if the LayoutManager is recreated. RecyclerView does NOT verify if the LayoutManager has changed between state save and restore. This will let you share information between your LayoutManagers but it is also your responsibility to make sure they use the same parcelable class. Necessary information for LayoutManager to be able to restore its state Called by the after a View is dropped over another View. A LayoutManager should implement this interface to get ready for the upcoming move operation. For example, LinearLayoutManager sets up a \"scrollToPositionWithOffset\" calls so that the View under drag will be used as an anchor View while calculating the next layout, making layout stay consistent. Scroll horizontally by dx pixels in screen coordinates and return the distance traveled. The default implementation does nothing and returns 0. Scroll the RecyclerView to make the position visible. RecyclerView will scroll the minimum amount that is necessary to make the target position visible. If you are looking for a similar behavior to or , use . Note that scroll position change will not be reflected until the next layout call. Scroll to the specified adapter position with the given offset from resolved layout start. Resolved layout start depends on , and . For example, if layout is and is true, calling will layout such that 's bottom is 20 pixels above the RecyclerView's bottom. Note that scroll position change will not be reflected until the next layout call. If you are just trying to make a position visible, use . Index (starting at 0) of the reference item. The distance (in pixels) between the start edge of the item view and start edge of the RecyclerView. Scroll vertically by dy pixels in screen coordinates and return the distance traveled. The default implementation does nothing and returns 0. Sets the number of items to prefetch in , which defines how many inner items should be prefetched when this LayoutManager's RecyclerView is nested inside another RecyclerView. Set this value to the number of items this inner LayoutManager will display when it is first scrolled into the viewport. RecyclerView will attempt to prefetch that number of items so they are ready, avoiding jank as the inner RecyclerView is scrolled into the viewport. For example, take a vertically scrolling RecyclerView with horizontally scrolling inner RecyclerViews. The rows always have 4 items visible in them (or 5 if not aligned). Passing to this method for each inner RecyclerView's LinearLayoutManager will enable RecyclerView's prefetching feature to do create/bind work for 4 views within a row early, before it is scrolled on screen, instead of just the default 2. Calling this method does nothing unless the LayoutManager is in a RecyclerView nested in another RecyclerView. Note: Setting this value to be larger than the number of views that will be visible in this view can incur unnecessary bind work, and an increase to the number of Views created and in active use. Sets the orientation of the layout. will do its best to keep scroll position. Set whether LayoutManager will recycle its children when it is detached from RecyclerView. If you are using a , it might be a good idea to set this flag to so that views will be available to other RecyclerViews immediately. Note that, setting this flag will result in a performance drop if RecyclerView is restored. Whether children should be recycled in detach or not. Used to reverse item traversal and layout order. This behaves similar to the layout change for RTL views. When set to true, first item is laid out at the end of the UI, second item is laid out before it etc. For horizontal layouts, it depends on the layout direction. When set to true, If is LTR, than it will layout from RTL, if } is RTL, it will layout from LTR. If you are looking for the exact same behavior of , use When smooth scrollbar is enabled, the position and size of the scrollbar thumb is computed based on the number of visible pixels in the visible items. This however assumes that all list items have similar or equal widths or heights (depending on list orientation). If you use a list in which items have different dimensions, the scrollbar will change appearance as the user scrolls through the list. To avoid this issue, you need to disable this property. When smooth scrollbar is disabled, the position and size of the scrollbar thumb is based solely on the number of items in the adapter and the position of the visible items inside the adapter. This provides a stable scrollbar as the user navigates through a list of items with varying widths / heights. Whether or not to enable smooth scrollbar. Smooth scroll to the specified adapter position. To support smooth scrolling, override this method, create your instance and call . The RecyclerView to which this layout manager is attached \"Predictive item animations\" are automatically created animations that show where items came from, and where they are going to, as items are added, removed, or moved within a layout. A LayoutManager wishing to support predictive item animations must override this method to return true (the default implementation returns false) and must obey certain behavioral contracts outlined in . Whether item animations actually occur in a RecyclerView is actually determined by both the return value from this method and the set on the RecyclerView itself. If the RecyclerView has a non-null ItemAnimator but this method returns false, then only \"simple item animations\" will be enabled in the RecyclerView, in which views whose position are changing are simply faded in/out. If the RecyclerView has a non-null ItemAnimator and this method returns true, then predictive item animations will be enabled in the RecyclerView. true if this LayoutManager supports predictive item animations, false otherwise.\n\nCalculates the amount of extra space (in pixels) that should be laid out by and stores the result in . should be used for the extra space at the top/left, and should be used for the extra space at the bottom/right (depending on the orientation). Thus, the side where it is applied is unaffected by (LTR vs RTL), and . Negative values are ignored. By default, lays out 1 extra page of items while smooth scrolling, in the direction of the scroll, and no extra space is laid out in all other situations. You can override this method to implement your own custom pre-cache logic. Use to find out if a smooth scroll to a position is in progress, and to find out which item it is scrolling to. Note:Laying out extra items generally comes with significant performance cost. It's typically only desirable in places like smooth scrolling to an unknown location, where 1) the extra content helps LinearLayoutManager know in advance when its target is approaching, so it can decelerate early and smoothly and 2) while motion is continuous. Extending the extra layout space is especially expensive if done while the user may change scrolling direction. In the default implementation, changing direction will cause the extra layout space to swap to the opposite side of the viewport, incurring many rebinds/recycles, unless the cache is large enough to handle it. Returns the amount of extra space that should be laid out by LayoutManager. By default, lays out 1 extra page of items while smooth scrolling and 0 otherwise. You can override this method to implement your custom layout pre-cache logic. Note:Laying out invisible elements generally comes with significant performance cost. It's typically only desirable in places like smooth scrolling to an unknown location, where 1) the extra content helps LinearLayoutManager know in advance when its target is approaching, so it can decelerate early and smoothly and 2) while motion is continuous. Extending the extra layout space is especially expensive if done while the user may change scrolling direction. Changing direction will cause the extra layout space to swap to the opposite side of the viewport, incurring many rebinds/recycles, unless the cache is large enough to handle it. The extra space that should be laid out (in pixels)."
    },
    {
        "link": "https://guides.codepath.com/android/using-the-recyclerview",
        "document": "The is a that renders any adapter-based view in a similar way. It is supposed to be the successor of ListView and GridView. One of the reasons is that has a more extensible framework, especially since it provides the ability to implement both horizontal and vertical layouts. Use the widget when you have data collections whose elements change at runtime based on user action or network events.\n\nIf you want to use a , you will need to work with the following:\n• - To handle the data collection and bind it to the view\n• - Helps with animating the items for common operations such as Addition or Removal of item\n\nFurthermore, it provides animation support for items whenever they are added or removed, which had been extremely difficult to do with . also begins to enforce the ViewHolder pattern too, which was already a recommended practice but now deeply integrated with this new framework.\n\nFor more details, see this detailed overview.\n\ndiffers from its predecessor primarily because of the following features:\n• Required ViewHolder in Adapters - adapters do not require the use of the ViewHolder pattern to improve performance. In contrast, implementing an adapter for requires the use of the ViewHolder pattern for which it uses .\n• Customizable Item Layouts - can only layout items in a vertical linear arrangement and this cannot be customized. In contrast, the has a that allows any item layouts including horizontal lists or staggered grids.\n• Easy Item Animations - contains no special provisions through which one can animate the addition or deletion of items. In contrast, the has the class for handling item animations.\n• Manual Data Source - had adapters for different sources such as and for arrays and database results respectively. In contrast, the requires a custom implementation to supply the data to the adapter.\n• Manual Item Decoration - has the property for easy dividers between items in the list. In contrast, requires the use of a object to setup much more manual divider decorations.\n• Manual Click Detection - has a interface for binding to the click events for individual items in the list. In contrast, only has support for which manages individual touch events but has no built-in click handling.\n\nA needs to have a layout manager and an adapter to be instantiated. A layout manager positions item views inside a and determines when to reuse item views that are no longer visible to the user.\n\nHere is Dave Smith's talk on the custom layout manager\n\nincludes a new kind of adapter. It’s a similar approach to the ones you already used, but with some peculiarities, such as a required . You will have to override two main methods: one to inflate the view and its view holder, and another one to bind data to the view. The good thing about this is that the first method is called only when we really need to create a new view. No need to check if it’s being recycled.\n\nwill animate modifications such as add/delete/select that are notified to the adapter. can be used for basic default animations and works quite well. See the section of this guide for more information.\n\nUsing a has the following key steps:\n• Define a model class to use as the data source\n• Add a to your activity to display the items\n• Create a and to render the item\n• Bind the adapter to the data source to populate the\n\nThe steps are explained in more detail below.\n\nEvery RecyclerView is backed by a source for data. In this case, we will define a class which represents the data model being displayed by the RecyclerView:\n\nInside the desired activity layout XML file in , let's add the from the support library:\n\nIn the layout, preview we can see the within the activity:\n\nNow the is embedded within our activity layout file. Next, we can define the layout for each item within our list.\n\nBefore we create the adapter, let's define the XML layout file that will be used for each row within the list. This item layout for now should contain a horizontal linear layout with a textview for the name and a button to message the person:\n\nThis layout file can be created in and will be rendered for each item row. Note that you should be using for the . See this link for more context.\n\nWith the custom item layout complete, let's create the adapter to populate the data into the recycler view.\n\nHere we need to create the adapter which will actually populate the data into the RecyclerView. The adapter's role is to convert an object at a position into a list row item to be inserted.\n\nHowever, with a the adapter requires the existence of a \"ViewHolder\" object which describes and provides access to all the views within each item row. We can create the basic empty adapter and holder together in as follows:\n\nNow that we've defined the basic adapter and , we need to begin filling in our adapter. First, let's store a member variable for the list of contacts and pass the list in through our constructor:\n\nEvery adapter has three primary methods: to inflate the item layout and create the holder, to set the view attributes based on the data and to determine the number of items. We need to implement all three to finish the adapter:\n\nWith the adapter completed, all that is remaining is to bind the data from the adapter into the RecyclerView.\n\nBinding the Adapter to the RecyclerView\n\nIn our activity, we will populate a set of sample users which should be displayed in the .\n\nFinally, compile and run the app and you should see something like the screenshot below. If you create enough items and scroll through the list, the views will be recycled and far smoother by default than the widget:\n\nUnlike ListView, there is no way to add or remove items directly through the adapter. You need to make changes to the data source directly and notify the adapter of any changes. Also, whenever adding or removing elements, always make changes to the existing list. For instance, reinitializing the list of Contacts such as the following will not affect the adapter, since it has a memory reference to the old list:\n\nInstead, you need to act directly on the existing reference:\n\nThere are many methods available to use when notifying the adapter of different changes:\n\nWe can use these from the activity or fragment:\n\nEvery time we want to add or remove items from the RecyclerView, we will need to explicitly inform the adapter of the event. Unlike the ListView adapter, a RecyclerView adapter should not rely on since the more granular actions should be used. See the API documentation for more details.\n\nAlso, if you are intending to update an existing list, make sure to get the current count of items before making any changes. For instance, a on the adapter should be called to record the first index that will be changed.\n\nOften times there are cases when changes to your list are more complex (i.e. sorting an existing list) and it cannot be easily determined whether each row changed. In this cases, you would normally have to call on the entire adapter to update the entire screen, which eliminates the ability to perform animation sequences to showcase what changed.\n\nThe ListAdapter class simplifies detecting whether an item was inserted, updated, or deleted. You can find more details in this blog post. Note the blog post refers to Support Library v23 that was replaced with AndroidX library. Use this Migration guide to ensure compatibility with the rest of the examples.\n\nFirst, change your adapter to inherit from a to a .\n\nNote that a requires an extra generic parameter, which is the type of data managed by this adapter. We also need to declare an item callback:\n\nYou may notice an error that says \"There is no default constructor available in \". The reason is that you will declare an empty constructor and your adapter will also need to invoke this callback method:\n\nInstead of overriding , remove it since the size of the list will be managed by the class:\n\nWe will also add a helper function to add more contacts. Anytime we wish to add more contacts, will use this method instead. A function provided by the ListAdapter will trigger the comparison.\n\nFinally, we need to modify the to use the method instead.\n\nThe is built on top of the class but requires less boilerplate code. You can see below what the steps are needed to in order to accomplish the same goal. You do not need to follow the steps below if you already using .\n\nThe class, which was added in the v24.2.0 of the support library, helps compute the difference between the old and new list. This class uses the same algorithm used for computing line changes in source code (the diff utility program), so it usually fairly fast. It is recommended however for larger lists that you execute this computation in a background thread.\n\nTo use the class, you need to first implement a class that implements the that accepts the old and new list:\n\nNext, you would implement a method on your adapter to perform the diff and then invoke to notify the adapter whether the element was inserted, removed, moved, or changed:\n\nFor a working example, see this sample code.\n\nIf we are inserting elements to the front of the list and wish to maintain the position at the top, we can set the scroll position to the 1st element:\n\nIf we are adding items to the end and wish to scroll to the bottom as items are added, we can notify the adapter that an additional element has been added and can call on the RecyclerView:\n\nTo implement fetching more data and appending to the end of the list as the user scrolls towards the bottom, use the from the and add an method leveraging the EndlessScrollViewScrollListener document in the guide.\n\nThe is quite flexible and customizable. Several of the options available are shown below.\n\nWe can also enable optimizations if the items are static and will not change for significantly smoother scrolling:\n\nThe positioning of the items is configured using the layout manager. By default, we can choose between , , and . Linear displays items either vertically or horizontally:\n\nFor example, a staggered grid might look like:\n\nWe can build our own custom layout managers as outlined there.\n\nWe can decorate the items using various decorators attached to the recyclerview such as the DividerItemDecoration:\n\nThis decorator displays dividers between each item within the list as illustrated below:\n\nDecorators can also be used for adding consistent spacing around items displayed in a grid layout or staggered grid. Copy over this SpacesItemDecoration.java decorator into your project and apply to a using the method. Refer to this staggered grid tutorial for a more detailed outline.\n\nRecyclerView supports custom animations for items as they enter, move, or get deleted using ItemAnimator. The default animation effects is defined by DefaultItemAnimator, and the complex implementation (see source code) shows that the logic necessary to ensure that animation effects are performed in a specific sequence (remove, move, and add).\n\nCurrently, the fastest way to implement animations with RecyclerView is to use third-party libraries. The third-party recyclerview-animators library contains a lot of animations that you can use without needing to build your own. Simply edit your :\n\nNext, we can use any of the defined animators to change the behavior of our RecyclerView:\n\nFor example, here's scrolling through a list after customizing the animation:\n\nFor a further look into defining custom item animators, check out this custom RecyclerView item animation post.\n\nThere is also a new interface for the ItemAnimator interface. The old interface has now been deprecated to . This library adds a ItemHolderInfo class, which appears to be similar to the MoveInfo class defined by but used more generically to pass state information between animation transition states. It is likely that the next version of will be simplified to use this new class and revised interface.\n\nSee this guide if you want to inflate multiple types of rows inside a single :\n\nThis is useful for feeds which contain various different types of items within a single list.\n\nRecyclerView allows us to handle touch events with:\n\nIn certain cases, we might want a horizontal that allows the user to scroll through a list of items. As the user scrolls, we might want items to \"snap to center\" as they are revealed. Such as in this example:\n\nTo achieve this snapping to center effect as the user scrolls we can use the built-in LinearSnapHelper as follows:\n\nFor more sophisticated snapping behavior, read more about customizing these helpers and review related sample code here.\n\nFor a more manual approach, we can create a custom extension to called which will snap items to center as the user scrolls:\n• Copy over the code from SnappyRecyclerView.java to your project.\n• Configure your new with a horizontal :\n• Attach your adapter to the to populate the data into the horizontal list as normal.\n• You can access the currently \"snapped\" item position with .\n\nThat's all, you should be set for a snap-to-center horizontal scrolling list!\n\nIf you'd like to perform an action whenever a user clicks on any item in your RecyclerView, you'll need to perform that action within a handler.\n\nBelow are three ways you can attach a handler to listen to clicks on a RecyclerView. Note that this can be used to recognize clicks on items, but not for recognizing clicks on individual buttons or other elements within your items...\n\nThe easiest solution for handling a click on an item in a RecyclerView is to add a decorator class such as this clever decorator and then implement the following code in your Activity or Fragment code:\n\nThis technique was originally outlined in this article. Under the covers, this is wrapping the interface pattern described in detail below.\n\nSo, if you apply this code above, you do not need the Simple Click Handler within ViewHolder described below.\n\nAnother solution for setting up item click handlers within a is to add code to your Adapter instead...\n\nUnlike which has the method, does not have special provisions for attaching click handlers to items. So, to achieve a similar effect manually (instead of using the decorator utility above), we can attach click events within the inside our adapter:\n\nIf we want the item to show a \"selected\" effect when pressed, we can set the of the root layout for the row to :\n\nThis creates the following effect:\n\nIn certain cases, you'd want to setup click handlers for views within the but define the click logic within the containing or (i.e bubble up events from the adapter). To achieve this, create a custom listener within the adapter and then fire the events upwards to an interface implementation defined within the parent:\n\nThen we can attach a click handler to the adapter with:\n\nSee this detailed stackoverflow post which describes how to setup item-level click handlers when using .\n\nThe should be used to refresh the contents of a via a vertical swipe gesture. See our detailed RecyclerView with SwipeRefreshLayout guide for a step-by-step tutorial on implementing pull to refresh.\n\nRecyclerView has an method that can be used to implement custom fling behavior. Download this RecyclerViewSwipeListener and you can handle custom swipe detection by adding this class to your RecyclerView:"
    },
    {
        "link": "https://medium.com/android-news/android-dtt-13-how-to-set-recyclerviews-layoutmanager-in-xml-and-why-you-shouldn-t-350da048a801",
        "document": "If we look at most of the tutorial about , particularly on setting the it will show something like this:\n\nIn fact, if I google “RecyclerView tutorial”, the first five results use the same way, including the one from developers.android.com. It creates an impression, at least for me, that setting the in Java code is the only way to do it. It turns out that there is an XML attribute for that: . Here’s the description from the documentation:\n\nClass name of the Layout Manager to be used. The class must extend android.support.v7.widget.RecyclerView$LayoutManager and have either a default constructor or constructor with the signature (android.content.Context, android.util.AttributeSet, int, int). If the name starts with a ‘.’, application package is prefixed. Else, if the name contains a ‘.’, the classname is assumed to be a full class name. Else, the recycler view package name (android.support.v7.widget) is prefixed.\n\nWe can use the by specifying the full qualified class name (fqcn, yes that’s a thing) to the XML:\n\nThis is equivalent with the java code above. A vertical with is false.\n\nIf we want to change the orientation, we could simply use there are also , , attribute that we can use.\n\nYou can also use and in the XML. If you’re using a custom , make sure to provide the required constructor in your class.\n\nWhy is the Java code is more popular?\n\nI was thinking that it’s just a new feature in the support library. Maybe no one is using it right now but it’ll be famous in a couple of days. But no, the reason is Reflection.\n\nI was wondering how it works. Since attribute is supposed to only able to give simple values such as integer, string, etc. But how it can provides an object? After digging up a bit to the source code, I found that it uses reflection to instantiate the based on the fqcn given. You can see it in the function inside the class.\n\nReflection is bad for a system that has limited resource. It is very slow and it’s suggested that we should avoid it as much as we can.\n\nIt’s nice to know that there is another way to set other than setting it up in the java code. But it’s also nice to know not to use that other way since it comes with a great price."
    }
]