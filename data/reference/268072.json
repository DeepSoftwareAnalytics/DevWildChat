[
    {
        "link": "https://geeksforgeeks.org/access-modifiers-in-c",
        "document": "Access modifiers are used to implement an important aspect of Object-Oriented Programming known as Data Hiding. Consider a real-life example: \n\nThe Research and Analysis Wing (R&AW), having 10 core members, has come into possession of sensitive confidential information regarding national security. Now we can correlate these core members to data members or member functions of a class, which in turn can be correlated to the R&A Wing. These 10 members can directly access the confidential information from their wing (the class), but anyone apart from these 10 members can’t access this information directly, i.e., outside functions other than those prevalent in the class itself can’t access the information (that is not entitled to them) without having either assigned privileges (such as those possessed by a friend class or an inherited class, as will be seen in this article ahead) or access to one of these 10 members who is allowed direct access to the confidential information (similar to how private members of a class can be accessed in the outside world through public member functions of the class that have direct access to private members). This is what data hiding is in practice. \n\nAccess Modifiers or Access Specifiers in a class are used to assign the accessibility to the class members, i.e., they set some restrictions on the class members so that they can’t be directly accessed by the outside functions.\n\nThere are 3 types of access modifiers available in C++:\n\nNote: If we do not specify any access modifiers for the members inside the class, then by default the access modifier for the members will be Private. Understanding how to use public, private, and protected access modifiers is essential.\n\nLet us now look at each one of these access modifiers in detail:\n\n 1. Public: All the class members declared under the public specifier will be available to everyone. The data members and member functions declared as public can be accessed by other classes and functions too. The public members of a class can be accessed from anywhere in the program using the direct member access operator (.) with the object of that class.\n\nIn the above program, the data member radius is declared as public so it could be accessed outside the class and thus was allowed access from inside main(). \n\n 2. Private: The class members declared as private can be accessed only by the member functions inside the class. They are not allowed to be accessed directly by any object or function outside the class. Only the member functions or the friend functions/ friend class are allowed to access the private data members of the class.\n\nThe output of the above program is a compile time error because we are not allowed to access the private data members of a class directly from outside the class. Yet an access to obj.radius is attempted, but radius being a private data member, we obtained the above compilation error.\n\nHowever, we can access the private data members of a class indirectly using the public member functions of the class.\n\n3. Protected: The protected access modifier is similar to the private access modifier in the sense that it can’t be accessed outside of its class unless with the help of a friend class. The difference is that the class members declared as Protected can be accessed by any subclass (derived class) of that class as well.\n\nNote: This access through inheritance can alter the access modifier of the elements of base class in derived class depending on the mode of Inheritance."
    },
    {
        "link": "https://stackoverflow.com/questions/4018464/best-practices-for-a-class-with-many-members",
        "document": "Any opinions on best way to organize members of a class (esp. when there are many) in C++. In particular, a class has lots of user parameters, e.g. a class that optimizes some function and has number of parameters such as # of iterations, size of optimization step, specific method to use, optimization function weights etc etc. I've tried several general approaches and seem to always find something non-ideal with it. Just curious others experiences. To be more concrete, the code I'm working on tracks objects in a sequence of images. So one important aspect is that it needs to preserve state between frames (why I didn't just make a bunch of functions). Significant member functions include initTrack(), trackFromLastFrame(), isTrackValid(). And there are a bunch of user parameters (e.g. how many points to track per object tracked, how much a point can move between frames, tracking method used etc etc)"
    },
    {
        "link": "https://w3schools.com/cpp/cpp_access_specifiers.asp",
        "document": "By now, you are quite familiar with the keyword that appears in all of our class examples:\n\nThe keyword is an access specifier. Access specifiers define how the members (attributes and methods) of a class can be accessed. In the example above, the members are - which means that they can be accessed and modified from outside the code.\n\nHowever, what if we want members to be private and hidden from the outside world?\n\nIn C++, there are three access specifiers:\n• - members are accessible from outside the class\n• - members cannot be accessed (or viewed) from outside the class\n• - members cannot be accessed from outside the class, however, they can be accessed in inherited classes. You will learn more about Inheritance later.\n\nIn the following example, we demonstrate the differences between and members:\n\nNote: By default, all members of a class are if you don't specify an access specifier:"
    },
    {
        "link": "https://learn.microsoft.com/en-us/cpp/cpp/member-access-control-cpp?view=msvc-170",
        "document": "Access controls enable you to separate the interface of a class from the implementation details and the members that are only for use by derived classes. The access specifier applies to all members declared after it until the next access specifier is encountered.\n\nThe default access is in a class, and in a struct or union. Access specifiers in a class can be used any number of times in any order. The allocation of storage for objects of class types is implementation-dependent. However, compilers must guarantee assignment of members to successively higher memory addresses between access specifiers.\n\nAccess control helps prevent you from using objects in ways they weren't intended to be used. This protection is lost when you make explicit type conversions (casts).\n\nTwo factors control which members of a base class are accessible in a derived class; these same factors control access to the inherited members in the derived class:\n• None Whether the derived class declares the base class using the access specifier.\n• None What the access to the member is in the base class.\n\nThe following table shows the interaction between these factors and how to determine base-class member access.\n\nThe following example illustrates access derivation:\n\nIn , the member function is a member and is a member because is a base class. is to , and it's inaccessible to any derived classes.\n\nIn , the functions and are considered members because is a base class. Again, is to , and it's inaccessible to any derived classes.\n\nYou can declare a derived class without a base-class access specifier. In such a case, the derivation is considered if the derived class declaration uses the keyword. The derivation is considered if the derived class declaration uses the keyword. For example, the following code:\n\nMembers declared as having access aren't accessible to functions or derived classes unless those functions or classes are declared using the declaration in the base class.\n\nWhen you specify a base class as , it affects only nonstatic members. Public static members are still accessible in the derived classes. However, accessing members of the base class using pointers, references, or objects can require a conversion, which applies access control again. Consider the following example:\n\nIn the preceding code, access control prohibits conversion from a pointer to to a pointer to . The pointer is implicitly of type . To select the function, must be converted to type . Such a conversion isn't permitted because is a private indirect base class to . Conversion to a private base class type is acceptable only for pointers to immediate derived classes. That's why pointers of type can be converted to type .\n\nAn explicit call to the function, without using a pointer, reference, or object to select it, implies no conversion. That's why the call is allowed.\n\nMembers and friends of a derived class, , can convert a pointer to to a pointer to a private direct base class of .\n\nThe access control applied to functions is determined by the type used to make the function call. Overriding declarations of the function don't affect the access control for a given type. For example:\n\nIn the preceding example, calling the virtual function using a pointer to type calls , and is treated as . However, calling using a pointer to type is an access-control violation because is declared in class .\n\nIn multiple-inheritance lattices involving virtual base classes, a given name can be reached through more than one path. Because different access control can be applied along these different paths, the compiler chooses the path that gives the most access. See the following figure:\n\nAccess along paths of an inheritance graph\n\nIn the figure, a name declared in class is always reached through class . The right path is more accessible because declares as a base class, while declares as ."
    },
    {
        "link": "https://geeksforgeeks.org/c-classes-and-objects",
        "document": "In C++, classes and objects are the basic building block that leads to Object-Oriented programming in C++. We will learn about C++ classes, objects, look at how they work and how to implement them in our C++ program.\n\nA class is a user-defined data type, which holds its own data members and member functions that can be accessed and used by creating an instance of that class. A C++ class is like a blueprint for an object.\n\nFor Example: Consider the Class of Cars. There may be many cars with different names and brands but all of them will share some common properties like all of them will have 4 wheels, Speed Limit, Mileage range, etc. The car can also accelerate, turn, apply brakes, etc. So here, the Car is the class, wheels, speed limits, and mileage are its attributes (data members) and accelerate, turn, apply brakes are its methods (member functions).\n\nA class must be defined before its use. In C++, it is defined using the keyword class keyword as shown:\n• Data Members: These are the variables that are defined inside the class.\n• Member Functions: Functions declared inside a class. Also referred to as a member method.\n\nIn the above, GfG class is created with a data member val and member function show(). Here, member function is defined inside the class, but they can also be just declared in the class and then defined outside using scope resolution operator ::\n\nIn C++ classes, we can control the access to the members of the class using Access Specifiers. Also known as access modifier, they are the keywords that are specified in the class and all the members of the class under that access specifier will have particular access level.\n\nIn C++, there are 3 access specifiers that are as follows:\n• Public: Members declared as public can be accessed from outside the class.\n• Private: Members declared as private can only be accessed within the class itself.\n• Protected: Members declared as protected can be accessed within the class and by derived classes.\n\nIf we do not specify the access specifier, the private specifier is applied to every member by default.\n\nWhat is an Object\n\nWhen a class is defined, only the specification (attributes and behaviour) for the object is defined. No memory is allocated to the class definition. To use the data and access functions defined in the class, we need to create its objects.\n\nObjects are the actual entities that are created as an instance of a class. There can be as many objects of a class as desired.\n\nOnce the class is defined, we can create its object in the same way we declare the variables of any other inbuilt data type.\n\nThis statement creates an object of className class.\n\nMembers of the class can be accessed inside the class itself simply by using their assigned name.\n\nTo access them outside, the (.) dot operator is used with the object of the class.\n\nThere obj is the name of the object of the given class, member1 is data member and member2 is member function.\n\nWhether we can access a member of a class depends on the access specifier in which it is declared. In the above example, if the val variable was declared as private, then we would not have been able to access it in the main function.\n\nIn C++ classes, there are some special member functions that are essential to manage objects and provide some basic functionalities. ]\n\nConstructors are special class members which are called by the compiler every time an object of that class is instantiated. They are used to construct the objects and making them ready for use. Constructors have the same name as the class.\n\nDestructor is another special member function that is called by the compiler when the scope of the object ends. It deallocates all the memory previously used by the object of the class so that there will be no memory leaks. The destructor also has the same name as the class but with tilde (~) as prefix.\n\nMembers of the class can be declared as static. These static members of a class are not associated with the objects of the class but with the class itself. The main feature of these members is that they are accessible directly through the class without creating any objects. Both data members and member methods can be static:\n\nStatic data members shared by all objects of the class, meaning only one copy exists for all objects of the class and they are declared with the static keyword.\n\nStatic member functions are associated with the class itself rather than any specific object. They can only access static data members and cannot access instance data members. Static member functions are called using the class name, not the object.\n\nWe defined the member function inside the class, but we can also define the member function outside the class. To define a member function outside the class definition, we use scop resolution (::) operator.\n\nIn C++, friend classes and functions allow access to the private and protected members of other classes:\n\nA friend class has the ability to access the private and protected members of other classes where it is declared as a friend. This feature can be useful when it is necessary for one class to access the private and protected members of another class.\n\nA friend function in C++ is similar to a friend class. It can be given special permission to access the private and protected members of a class. Although it is not a member function of the class, it can still access and modify those private and protected members because it is declared as a friend.\n\nClasses are generally declared in global scope and are accessible to every function or other classes once they are defined. But C++ also provides facility to define a class within a function. It is called local class in C++ and is only accessible in that function.\n\nA nested class is a class defined within another enclosing class. As a member of the enclosing class, it has the same access rights as any other member. The members of the enclosing class do not have special access to the members of the nested class; the standard access rules apply.\n\nEnum classes in C++ are a safer and more organized way of using enums. They help to group related constants together while avoiding naming problems and ensuring better type safety.\n\nIn C++, this pointer is a pointer that points to the current instance of a class. It is used within the member functions of a class to refer to the object of that class. This pointer allows access to the calling object’s data and methods within its own member functions.\n\nThe following table lists the primary differences between the classes and objects in C++:\n\nCan we create an object without a class in C++?\n\nCan we have more than one constructor in a class?\n\nCan we create an object of a class inside another class?\n\nWhy do we give semicolons at the end of class?"
    },
    {
        "link": "https://geeksforgeeks.org/basic-input-output-c",
        "document": "In C++, input and output are performed in the form of a sequence of bytes or more commonly known as streams.\n• Input Stream: If the direction of flow of bytes is from the device (for example, Keyboard) to the main memory then this process is called input.\n• Output Stream: If the direction of flow of bytes is opposite, i.e. from main memory to device (display screen) then this process is called output.\n\nAll of these streams are defined inside the <iostream> header file which contains all the standard input and output tools of C++. The two instances cout and cin of iostream class are used very often for printing outputs and taking inputs respectively. These two are the most basic methods of taking input and printing output in C++.\n\nThe C++ cout is the instance of the ostream class used to produce output on the standard output device which is usually the display screen. The data needed to be displayed on the screen is inserted in the standard output stream (cout) using the insertion operator(<<).\n\nFor example, if we want to print text “GeeksforGeeks” on the display, we can use the cout as shown:\n\nExplanation: In the above program, cout is used to output the text “GeeksforGeeks” to the standard output stream. It works in conjunction with the insertion operator (<<) to send the specified data to the output stream.\n\nWe can also print the variable values using cout.\n\nUnderstanding input and output operations is essential for any C++ programmer. The C++ Course includes comprehensive lessons on basic I/O operations, ensuring you can manage user interaction in your programs.\n\nThe C++ cin statement is the instance of the class istream and is used to read input from the standard input device which is usually a keyboard. The extraction operator (>>) is used along with the object cin for extracting the data from the input stream and store it in some variable in the program.\n\nFor example, if we want to ask user for his/her age, then we can use cin as shown:\n\nExplanation: The above program asks the user to input the age. The object cin is connected to the input device (keyboard). The age entered by the user is extracted from cin using the extraction operator(>>) and the extracted data is then stored in the variable age present on the right side of the extraction operator.\n\nAlso, while taking text as input using cin, we need to remember that cin stops reading input as soon as it encounters a whitespace (space, tab, or newline). This means it only captures the first word or characters until the first whitespace. It is shown in the below example:\n\nThe C++ cerr is the standard error stream that is used to output the errors. This is also an instance of the iostream class. As cerr in C++ is un-buffered so it is used when one needs to display the error message immediately. It does not have any buffer to store the error message and display it later.\n\nThe main difference between cerr and cout comes when you would like to redirect output using “cout” that gets redirected to file if you use “cerr” the error doesn’t get stored in file.(This is what un-buffered means ..It cant store the message)\n\nThis is also an instance of ostream class and used to display errors but unlike cerr the error is first inserted into a buffer and is stored in the buffer until it is not fully filled. or the buffer is not explicitly flushed (using flush()). The error message will be displayed on the screen too."
    },
    {
        "link": "https://geeksforgeeks.org/redirect-cin-and-cout-to-files-in-cpp",
        "document": "How to Redirect cin and cout to Files in C++?\n\nIn C++, we often ask for user input and read that input using the cin command and for displaying output on the screen we use the cout command. But we can also redirect the input and output of the cin and cout to the file stream of our choice.\n\nIn this article, we will look at how to redirect the cin and cout to files in C++.\n\nRedirecting cin and cout to a File in C++\n\nFor redirecting cin and cout to a file, we first create the input file stream and output file stream to our desired file. Then using rdbuf() function of stream objects, we redirect the input for cin to the file and output for cout to the file.\n\nC++ Program to Redirect cin and cout"
    },
    {
        "link": "https://reddit.com/r/cpp_questions/comments/15cyxcr/can_someone_explain_to_a_c_newbie_what_cin_and",
        "document": "Create your account and connect with a world of communities.\n\nBy continuing, you agree to our\n\nand acknowledge that you understand the"
    },
    {
        "link": "https://simplilearn.com/tutorials/cpp-tutorial/cpp-cin",
        "document": ""
    },
    {
        "link": "https://stackoverflow.com/questions/44047792/declaring-basic-data-types-in-c-using-cin-and-cout",
        "document": "You get output like this:\n\nYou need to do 2 changes to get same (but not exact equal) output. Firstly, replace to space. Secondly, set precision for .\n\nAnd you will get output like this:\n\nIt is because default precision is lower than your input.\n\nBut there is exist some number that give different output because precision of is finite and last zeroes after floating point do not showed by default (and don't saved). If you need get EXACT same output, than you should save strings, not integer or float values. And you can try to output with option \"fixed\":"
    }
]