[
    {
        "link": "https://sapui5.hana.ondemand.com/sdk#api/sap.m.Tree",
        "document": ""
    },
    {
        "link": "https://sapui5.hana.ondemand.com/sdk#/api/sap.m.Tree",
        "document": ""
    },
    {
        "link": "https://stackoverflow.com/questions/49298202/sapui5-selection-change-event-issue-in-multi-select-list",
        "document": "I've a popover component and I added a multi-select list inside of it. I would like to set checked property to true for all items in case of the first item of list is selected. But selectionChange event works for every item's selection event. So, index value of the for loop always starts with zero. What should I do in this situation? Thanks for your suggestions.\n\nHere is my part of a code and screenshot of image; image url"
    },
    {
        "link": "https://experience.sap.com/fiori-design-web/tree",
        "document": "Within SAP Fiori, we distinguish between tree tables and trees. Both usually allow the user to display and work with a hierarchical set of items. While tree tables are usually used for more complex data, trees are generally used for rather basic data. Trees are mostly used in the main list for a list-detail scenario using the flexible column layout and in popovers or dialogs. In certain use cases, they can also be used in the dynamic page layout. In the case of tree tables and trees, items that contain additional items are called nodes, while items that do not contain any other items are called leaves. If available, a single topmost node is called a root node. Apart from the hierarchical structure of its nodes and leaves, a tree is quite similar to a list.\n\nThe height of the tree is defined by the number of items it contains. It does not have its own scroll container, but is scrolled together with the app. Same tree, with different expand state When the user scrolls, the title and the filter infobar can stick to the top of the surrounding layout container (sap.m.Tree, property: sticky).\n• It is not available on all browsers. In non-supporting browsers, the corresponding areas are not fixed on top of the surrounding layout container while scrolling.\n• Certain layout containers suppress the sticky behavior, such as the grid layout. The same happens if the table is placed within the object page.\n• If focus is set to a sticky area, the tree is automatically scrolled to top. The “sticky” feature comes with some limitations: A tree can have one of the following selection modes (sap.m.Tree / sap.m.ListBase, property: mode): None: Items cannot be selected (sap.m.ListMode.None).\n\n Beware: Items can, nevertheless, use the sap.m.ListType “navigation” which allows click-handling on specific items. This should only be used when the click triggers a navigation to a corresponding item details page. Single select master: One item of the tree can be selected. To select an item, click anywhere on the item. Single select master does not add any visual indication to the tree and therefore cannot be differentiated from trees without selection if no item is selected. Therefore, always keep one item selected. For single selection, this is the preferred mode. (sap.m.ListMode.SingleSelectMaster) Single selection: Only one item is selected. Single select left: One item of the tree can be selected. For this, the tree provides radio buttons on the left side of each line item. Use this selection mode only if clicking on the item triggers something else, such as a navigation. Ideally, always keep one item selected, even in initial state (sap.m.ListMode.SingleSelectLeft). Single selection with radio buttons. Use only if row clicks are used for something else, for example navigation. Multiple selection: Allows the selection of one or more items. For this, the tree provides checkboxes on the left side of each line item. Each item is selected independently of the others. The Shift key can be used to select a range. Users can (de)select all items using Ctrl+A. Select All should (de)select all items that the user can reach by scrolling. (sap.m.ListMode.MultiSelect). Ctrl+A. This only affects items that have already been loaded to the front-end server. All other items are not (de)selected before they are loaded (for example, items added via lazy loading with growingScrollToLoad). This conflicts with the guideline that all items the user can reach by scrolling must be (de)selected. In multiple selection mode, users can (de)select all items using the shortcut. This only affects items that have already been loaded to the front-end server. All other items are(de)selected before they are loaded (for example, items added via lazy loading with growingScrollToLoad). This conflicts with the guideline that all items the user can reach by scrolling must be (de)selected. Also note that Ctrl+A only (de)selects items within expanded nodes. To process all items, listen to the selectionChange event and to its flag selectAll. This indicates whether Ctrl+A was triggered. As soon as an action is triggered, process the items accordingly. Depending on the number of items, consider processing them in the back end.\n• Never disable the selection checkbox. If an action can’t be performed on a specific item, inform the user after the corresponding action has been triggered. For more information, see Enabling/Disabling Actions.\n• For single-selection list-detail scenarios within the flexible column layout, use the mode “single select master”. Do not show an additional “navigated” indicator.\n• Avoid the mode “single select left”. It removes the possibility of clicking somewhere on the item to select it. Use it only if it is really necessary to have two different click areas; a small one for a selection, and the rest of the item for something else.\n• If selecting / deselecting all items is important for your app, add a button Select All to the toolbar. Change the button text to Deselect All if all items are selected. To delete single items, use the tree in “delete” mode (sap.m.Tree / sap.m.ListBase, property: mode, value: sap.m.ListMode.Delete). This adds a Delete button to each item. Clicking this button triggers the deletion of the corresponding item. Do not use this mode if deleting multiple items at once is the preferred use case. Delete is a mode of the tree and therefore cannot be used together with single selection or multi selection.\n\nAn Expand/Collapse button is provided automatically for each node. To highlight an item, use the “highlight” indicator (sap.m.TreeItemBase, properties: highlight). To allow navigation from an item, set type to “navigation” within the corresponding item (sap.m.StandardTreeItem / sap.m.ListItemBase, property: type, value: sap.m.ListType.Navigation). This will create an indicator at the end of the line (“>”) and the entire item will become selectable. Clicking the line triggers the navigation event. However, clicking a selectable area or an expandable/collapse node does not. Use the navigation event to navigate to a new page containing item details.\n\n If no navigation is possible, set type to “inactive”.\n\n Navigation is an item type and therefore cannot be used together with “edit” or in combination with click events for the entire item (“active”). Navigation indicators can be set per item When multi-selection is used in a list-detail scenario, it is not clear which item was last opened (for example, which item is currently shown in the second column of a flexible column layout). In this case only (multi-selection tree with navigable items), you can display a “navigated” indicator to mark the item that is currently open (sap.m.TreeItemBase, property: navigated). To allow the user to edit an item, set type to “detail” within the corresponding item (sap.m.StandardTreeItem / sap.m.ListItemBase, property: type, value: sap.m.ListType.Detail or sap.m.ListType.DetailAndActive). This will create an edit button at the end of the line. Clicking the button triggers the edit event. Use this event to either open a dialog or a details page where the item can be edited.\n\n Edit is an item type and therefore cannot be used together with “navigation” or in combination with click events for the entire item (“active”). Items as a whole can be clickable. An event is fired by clicking on the item (anywhere except when triggering a selection or when expanding/collapsing a node). Apps can react to the event, such as by opening a dialog (sap.m.StandardTreeItem / sap.m.ListItemBase, property: type, value: sap.m.ListType.Active or sap.m.ListType.DetailAndActive).\n\n Active elements do not have a visual indication and therefore cannot be differentiated from non-active elements.\n\n “Active” is an item type and therefore cannot be used together with “navigation” or “edit”. In addition, “active” uses the entire item as a clickable area and thus cannot be used together with the “single select master” mode. You can attach a context menu (sap.m.Menu) to a tree. The context menu gives users an alternative way to modify the focused elements by giving them access to context-specific functions. The context menu can be triggered for the tree or per item. Context menus are opened by right-clicking (desktop), long press (mobile), the context menu key, or Shift+F10. Be aware that using the context menu overrides the browser context menu, which can no longer be opened. If a control inside a tree is the “click target”, and the control also provides a context menu, the control context menu “wins”. One or several items can be repositioned within a tree or moved to other UI elements using drag and drop operations (sap.m.ListBase, aggregation: dragDropConfig). While being dragged, the items are shown as ghost elements on the mouse cursor. Drop targets can be on items, between items, or both (sap.ui.core.dnd.DropPosition). On a drop target, the mouse cursor changes to either a “copy”, “link”, “move”, or “none” cursor. “None” indicates that the dragged item cannot be dropped in the current position (sap.ui.core.dnd.DropEffect). Drag and drop is only available on supporting browsers.\n\nTrees are more complex than lists due to their hierarchical view. Users tend to have more problems finding items in hierarchical views than in flat lists, except where the hierarchical view is natural. By natural we mean that every child node should be part of only one parent, and this relationship between the child and parent is clear and well known. Example of an acceptable use of trees When you use trees, you should choose broad hierarchies over deep hierarchies. Deep hierarchies make finding items more complicated. So try to reduce hierarchical levels where possible, especially if the hierarchy is not natural. Ideally, a tree should have a maximum of four levels, the first two of which should contain the most important items. You can use the following methods to reduce hierarchy levels:\n• Avoid a single root node. It is usually not needed.\n• Container nodes at the top level can usually be replaced by tabs or value pickers.\n• Eliminate unnecessary mid-level containers, for example, by combining redundant ones.\n• Exercise care when using a tree due to its overall complexity. The hierarchical structure of the data does not necessarily mean that a tree control is required. The tree can be used to display hierarchical data. Unfortunately, trees convey an immediate feeling of complexity. Ideally, show trees only if there is no other option. You should instead try the following:\n• Flatten the data. A list is still complex, but less so than a tree. A combo box might also fit in some use cases.\n• When only two levels are needed, a grouped list control can be used. This works well, where group nodes are used for categorizing their children and where the group nodes themselves do not need to be selectable.\n• Break down the data into manageable chunks. Allow the user to navigate or drill down between them.\n• Use charts with drilldown functionality until the amount of data is more manageable. To optimize performance, we recommend showing no more than 200 items at once in the tree. For larger datasets (up to 1,000 items), use the “growing” mechanism to limit the number of displayed items, and make sure that users can filter the data. The limits above are only recommendations. For a specific app context, the number of manageable items might be far higher or lower. The actual limits depend on your concrete scenario, including:\n• The number of rows in the table\n• The complexity of the cell content (for example, simple text vs. complex charts)\n• Other elements on the page (for example, multiple pages in a flexible column layout, or several tables/elements with more complex rendering on one page)\n• The browser being used\n\nTo trigger actions on items, show the actions on a toolbar above the tree. Do not offer action triggering on multiple items if the tree is expected to have fewer than 10 items in most cases.\n\n The following actions on single items must always be in-line: Delete: Use “Delete” mode (sap.m.Tree / sap.m.ListBase, property: mode, value: sap.m.ListMode.Delete). This places a Delete button at the end of each item. Navigation: Use the “Navigation” item type (sap.m.StandardTreeItem / sap.m.ListItemBase, property: type, value: sap.m.ListType.Navigation). This places a navigation indicator at the end of the corresponding items. Use this to navigate to a new page containing item details. Edit: Use the “Detail” item type (sap.m.TreeItem / sap.m.ListItemBase, property: type, value: sap.m.ListType.Detail). This places an Edit icon at the end of the corresponding items. From these three actions (delete, navigation, and edit), you can combine delete and edit, or delete and navigation. Edit and navigation cannot be combined. To trigger actions that are independent of the selection, show the actions on a toolbar above the tree. For example: Add, Collapse All, Expand All, … To trigger a default action on the entire item, use the “Active” or “DetailAndActive” item type (sap.m.TreeItem / sap.m.ListItemBase, property: type, value: sap.m.ListType.Active). Active items trigger an event when clicked, which can be handled by apps, for example, to open a dialog. Selection and expanding/collapsing a node does not trigger the event, but are handled by the tree. Do not use this for navigation, to switch the line item to an edit state, or to delete the item.\n\n Active can be combined with edit and delete, but not with navigation. Do not combine active with single selection master. For adding items, place an Add or Create text button on the tree toolbar.\n• Use Create if the button adds a brand new item that doesn’t yet exist on the database.\n• Use Add if the item already exists and is merely added or assigned to the current object. Enable the shortcut Ctrl+Enter (and ideally Enter in addition) to trigger the Add or Create button. Show new items as the first item of the tree or node:\n• If nothing is selected, add the new item to the root.\n• If a single node is selected, add the new item to the selected node.\n• If a single leaf is selected, add the new item as a child of this leaf. The original selected item becomes a node. If your tree doesn’t support adding items to the root, selected node, or selected leaf, disable Create or Add for the corresponding levels. Disable Create or Add if more than one item is selected. There are three options for adding an item. In order of priority (most recommended first), these are:\n• Add the item inline. Create an empty, editable item as the first item of the selected node. Show the Save button on the tree toolbar. This option is recommended for simple scenarios where just a few input fields have to be filled.\n• Open a dialog for items where up to 8 input fields need to be filled. Save the new item at dialog level.\n• Navigate to a new page. This behavior should only be used for very complex scenarios that cannot be handled by a dialog (for example, creating complex objects). When the user presses Save in the footer toolbar of the create page, navigate back to the tree. Depending on the flow, an item can be in one of three different states:\n• New: The item was just created inline and is in edit mode (for example, after pressing the Create button). It is highlighted with a visual indicator (information state).\n• Recent: The item was just created and is in read-only mode (for example, if Create leads to a dialog, and Save was triggered within the dialog). In this case, keep the item highlighted and display it as the first item of the corresponding node. Ignore current sort, filter, and grouping criteria to keep the item visible.\n• Added: The item has been fully added. It follows the sort, filter, and grouping settings and also loses the visual highlight. This state is used after:\n• Inline creation: After Save was triggered on the tree toolbar or at page level.\n• Create with dialog: A tree showing one or several items with the state “Recent” gets updated (for example, after sorting, filtering, or grouping, or when the browser is refreshed). In the context of draft handling, new items are not saved at tree level, but rather with the entire draft. For more details, see the guidelines for managing objects (including subarticles). To edit items, add an Edit button either in-line on the toolbar above the tree. Triggering the button either opens a dialog or navigates to an editable details page.\n• Provide an Edit button on the toolbar above the tree.\n• If several items are selected, triggering the Edit button opens a dialog in which the user edits the corresponding fields for all selected items. For more details, see mass editing. Use the context menu only to give users a quick way of accessing functions that are already available elsewhere (for example, as buttons in the toolbar). Don’t just offer actions in the context menu itself, as users might not realize that these actions are available at all. To comply with the new WCAG 2.2 standard, the control must offer an alternative to the drag and drop feature. See the visible alternatives described below. Drag and drop is “invisible” on the UI: users can’t see where dragging is available and where it isn’t. In addition, there is no generic keyboard interaction. Drag and drop is also not available on all browsers. For these reasons, provide it only in addition to existing (and visible) UI elements that fulfill the same purpose. For example, offer (toolbar) buttons for moving or for copying and pasting items. These are keyboard operable and available on all browsers. Use drag and drop only in addition to existing visible UI elements If you offer drag and drop for rearranging items within a tree, use the following options:\n• For dropping items as a child, use whole nodes as drop targets (sap.ui.core.dnd.DropPosition.On).\n• For dropping items on the same level, use the space between items as drop targets (sap.ui.core.dnd.DropPosition.Between).\n• If you want to allow users to drop items as a child or sibling, offer both drop targets (sap.ui.core.dnd.DropPosition.OnOrBetween). This provides better feedback on where the item will be inserted. Show the “move” mouse cursor (sap.ui.core.dnd.DropEffect.Move). Do not combine rearranging items within one level and sorting. If you really need to do so, make sure there is a dedicated sort criterion for the user-defined sort order, and only offer options for rearranging items if this sort order is set. Moving items from one node to another can be combined with sorting without any issues. Depending on the functionality you need, use one or more of the following alternatives:\n• To move items up or down within a node:\n\n Use the Move Up and Move Down buttons on the toolbar. These buttons move the selected items until the first selected item can’t be moved up or the last selected item can’t be moved down any further.\n\n Depending on your tree, this can make sense for both leaves and nodes, only for leaves, or only for nodes. When moving a node, move the whole node and (if applicable) all its children up or down to the next position within the parent node.\n\n Always make sure that when the user moves an item in one direction and then moves it back, the order is the same as it was before.\n\n Do not combine the option to move items up and down with sorting.\n• To move items to another node:\n\n Use Copy and Paste buttons on the toolbar.\n\n Alternatively, offer a Move To button. Clicking Move To opens a dialog that shows all the nodes of the tree, but no leaves. Selecting an item in this dialog closes the dialog and moves the corresponding items to the selected node.\n• To change the level of an item:\n\n In some trees, such as document structures, users can change the level of an item without affecting the level of parent or child items. In this case, use left and right arrow buttons ( ).\n\nWhat exactly needs to stay or be removed is highly dependent on the kind of structure and data your tree displays. For many trees, the following approach works well if you want to apply filters only to the leaves of a tree:\n• Remove all leaves that don’t fit the filter criteria If you also apply filters to nodes, keep the following in mind:\n• A node may or may not fit the filter criteria.\n• A node can contain items (nodes and/or leaves) that fit the filter criteria. Because of this, the results might contain more nodes than those that are relevant for the filter criteria. The tree control itself has no influence on the filter result. It sends a filter request and displays whatever comes back. Make sure that the result set is meaningful. Before you start, ask yourself if sorting is meaningful in your tree. If so, decide on a meaningful default sort order. If sorting is meaningful, is it meaningful on all levels? Or does the tree structure need to be stable? In the latter case, sort only leaves, but not nodes. Always sort the tree in a meaningful way when it first loads. The descending sort order must always be the exact reverse of the ascending sort order. Use a meaningful sort order. For example:\n• Sort numbers by their value\n• Sort status information by the severity of the status:\n• Ascending: Sort status information from positive to negative, with neutral last.\n• Descending: Sort status information from negative to positive, with neutral first.\n• \n• Ascending with different values per severity level: Sort status information from positive to negative, with neutral last. Sort different values within a severity level (semantic color) alphabetically.\n• Descending with different values per severity level: Sort status information from negative to positive, with neutral first. Sort different values within a severity level (semantic color) alphabetically. On the table toolbar, apps can provide a menu button for exporting the tree data to a spreadsheet. For the export, use the export to spreadsheet function. Want to dive deeper? Follow the links below to find out more about related controls, the SAPUI5 implementation, and the visual design."
    },
    {
        "link": "https://sapui5.hana.ondemand.com/sdk#/api/sap.ui.commons.Tree/events/selectionChange",
        "document": ""
    },
    {
        "link": "https://community.sap.com/t5/technology-q-a/iterate-child-nodes/qaq-p/761730",
        "document": "As suggested by Armin, it shd definitely work. Otherwise really something strange is happening. I want to know a couple of things:\n\n1)Have you created the childnodes declaratively or programatically???\n\n2)If you have created the childnodes programatically, then have you made sure that you iterate only after the child nodes are created???(I know u would definitely made sure of this... But just want to verify... 'coz sometimes one does such silly mistakes and then simple things dont work.).\n\n3) if u have created the child nodes programatically, where have you created it and where are you iterating this??\n\nOtherwise, its really strange...I think the code that u have written shd work!"
    },
    {
        "link": "https://stackoverflow.com/questions/24775725/loop-through-childnodes",
        "document": "The variable is a instance and s are not true and therefore they do not inherit the method.\n\nYou can use from to convert the into a proper .\n\nYou could also simply use to invoke and pass it the as context.\n\nYou can use the method to convert your into an .\n\nOr you can also use the spread syntax like so\n\nA hack that can be used is and you can then use with any without having to convert them each time.\n\nSee A comprehensive dive into NodeLists, Arrays, converting NodeLists and understanding the DOM for a good explanation and other ways to do it."
    },
    {
        "link": "https://stackoverflow.com/questions/33455550/how-to-iterate-through-nodelist-and-update-only-for-child-nodes-in-java",
        "document": "A bit new to xml parsing in java, so I am trying to update certain elements within xml document but I am having some issues updating the correct ones.\n\nGiven above xml, let's say I want to modify for each transaction. I want to update id, time and date with some other values. Each transaction I will update with different data.\n\nSo I've been trying something like below:\n\nAbove modify method does work and it does update after I do some Transforming and all, but it is updating all the transactions with same id,time,date values. I want to iterate through each \"Transaction\" and update its child nodes (id, time, date) separately, so they each will be different. How can this be done?"
    },
    {
        "link": "https://community.sap.com/t5/technology-q-a/treetable-iterate-through-nodes-and-select-a-node-programmatically/qaq-p/437015",
        "document": "Hello,\n\n\n\nI use an TreeTable with a Binding to a OData Entity. It works, but now i want to search an specific node, and select this node.\n\n\n\ni can get the root, and then via \"children\" the childs of this node\n\nSo i can iterate through the nodes, and find my node. \n\n\n\nBut when i found the node, i doesn't habe the index to select this node in the tree.\n\ni can select a node. But how can i find out an index of a node?"
    },
    {
        "link": "https://reddit.com/r/godot/comments/16kkpo2/finding_child_node_by_type",
        "document": "I'm trying to find method similar to Unity's GetComponentInChildren<T>, that go through all the children of the node trying to find first node that suits T type\n\nBut closest thing I found is manually iterating through all children nodes and checking their type or getting some child node by index/name\n\nIs there a good alternative that I don't see? It's possible to write extension method like that myself, but I think it's better to use something that engine provides"
    }
]