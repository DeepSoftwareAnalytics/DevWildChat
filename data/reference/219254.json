[
    {
        "link": "https://pythonguis.com/tutorials/pyqt-layouts",
        "document": "So far we've successfully created a window, and we've added a widget to it. However we normally want to add more than one widget to a window, and have some control over where it ends up. To do this in Qt we use layouts.\n\nThere are 4 basic layouts available in Qt, which are listed in the following table.\n\nYou can also design and lay out your interface graphically using the Qt designer. Here we're using code, so you can understand the underlying system.\n\nAs you can see, there are three positional layouts available in Qt. The , and . In addition there is also which allows you to place widgets one on top of the other within the same space, yet showing only one layout at a time.\n\nBefore we start we need a simple application outline. Save the following code in a file named -- we'll modify this application to experiment with different layouts.\n\nTo make it easier to visualize the layouts, we'll first create a simple custom widget that displays a solid color of our choosing. This will help to distinguish widgets that we add to the layout. Add the following code to your file as a new class at the top level --\n\nIn this code we subclass to create our own custom widget . We accept a single parameter when creating the widget — (a ). We first set to to tell the widget to automatically fill its background with the window cooler. Next we get the current palette (which is the global desktop palette by default) and change the current color to a new described by the value we passed in. Finally we apply this palette back to the widget. The end result is a widget that is filled with a solid color, that we specified when we created it.\n\nIf you find the above confusing, don't worry too much. We'll cover custom widgets in more detail later. For now it's sufficient that you understand that calling you can create a solid-filled red widget by doing the following:\n\nFirst let's test our new widget by using it to fill the entire window in a single color. Once it’s complete we can add it to the using and we get a solid red window.\n\nRun it! The window will appear, filled completely with the color red. Notice how the widget expands to fill all the available space.\n\nNext we'll look at each of the available Qt layouts in turn. Note that to add our layouts to the window we will need a dummy to hold the layout.\n\nWith you arrange widgets one above the other linearly. Adding a widget adds it to the bottom of the column.\n\nLet’s add our widget to a layout. Note that in order to add a layout to the we need to apply it to a dummy . This allows us to then use to apply the widget (and the layout) to the window. Our colored widgets will arrange themselves in the layout, contained within the in the window. First we just add the red widget as before.\n\nRun it! Notice the border now visible around the red widget. This is the layout spacing — we'll see how to adjust that later.\n\nIf you add a few more colored widgets to the layout you’ll notice that they line themselves up vertical in the order they are added.\n\nis the same, except moving horizontally. Adding a widget adds it to the right hand side.\n\nA QHBoxLayout, filled from left to right.\n\nTo use it we can simply change the to a . The boxes now flow left to right.\n\nFor more complex layouts you can nest layouts inside one another using on a layout. Below we add a into the main . If we add some widgets to the , they’ll be arranged vertically in the first slot of the parent layout.\n\nRun it! The widgets should arrange themselves in 3 columns horizontally, with the first column also containing 3 widgets stacked vertically. Experiment!\n\nYou can set the spacing around the layout using or set the spacing between elements using .\n\nThe following code shows the combination of nested widgets and layout margins and spacing. Experiment with the numbers til you get a feel for them.\n\nAs useful as they are, if you try and using and for laying out multiple elements, e.g. for a form, you’ll find it very difficult to ensure differently sized widgets line up. The solution to this is .\n\nA QGridLayout showing the grid positions for each location.\n\nallows you to position items specifically in a grid. You specify row and column positions for each widget. You can skip elements, and they will be left empty.\n\nUsefully, for you don't need to fill all the positions in the grid.\n\nmultiple widgets in the same space\n\nThe final layout we’ll cover is the . As described, this layout allows you to position elements directly in front of one another. You can then select which widget you want to show. You could use this for drawing layers in a graphics application, or for imitating a tab-like interface. Note there is also which is a container widget that works in exactly the same way. This is useful if you want to add a stack directly to a with .\n\nQStackedLayout — in use only the uppermost widget is visible, which is by default the first widget added to the layout.\n\nQStackedLayout, with the 2nd (1) widget selected and brought to the front.\n\nis exactly how tabbed views in applications work. Only one view ('tab') is visible at any one time. You can control which widget to show at any time by using or to set the item by either the index (in order the widgets were added) or by the widget itself.\n\nBelow is a short demo using in combination with to to provide a tab-like interface to an application:\n\nHelpfully. Qt actually provide a built-in TabWidget that provides this kind of layout out of the box - albeit in widget form. Below the tab demo is recreated using :\n\nAs you can see, it's a little more straightforward — and a bit more attractive! You can set the position of the tabs using the cardinal directions, toggle whether tabs are moveable with . You'll notice that the macOS tab bar looks quite different to the others -- by default on macOS tabs take on a pill or bubble style. On macOS this is typically used for tabbed configuration panels. For documents, you can turn on document mode to give slimline tabs similar to what you see on other platforms. This option has no effect on other platforms.\n\nWe'll encounter more of these advanced widgets later."
    },
    {
        "link": "https://doc.qt.io/qt-6/layout.html",
        "document": "The Qt layout system provides a simple and powerful way of automatically arranging child widgets within a widget to ensure that they make good use of the available space.\n\nQt includes a set of layout management classes that are used to describe how widgets are laid out in an application's user interface. These layouts automatically position and resize widgets when the amount of space available for them changes, ensuring that they are consistently arranged and that the user interface as a whole remains usable.\n\nAll QWidget subclasses can use layouts to manage their children. The QWidget::setLayout() function applies a layout to a widget. When a layout is set on a widget in this way, it takes charge of the following tasks:\n• Automatic updates when contents change:\n• Font size, text or other contents of child widgets\n\nQt's layout classes were designed for hand-written C++ code, allowing measurements to be specified in pixels for simplicity, so they are easy to understand and use. The code generated for forms created using Qt Widgets Designer also uses the layout classes. Qt Widgets Designer is useful to use when experimenting with the design of a form since it avoids the compile, link and run cycle usually involved in user interface development.\n\nThe easiest way to give your widgets a good layout is to use the built-in layout managers: QHBoxLayout, QVBoxLayout, QGridLayout, and QFormLayout. These classes inherit from QLayout, which in turn derives from QObject (not QWidget). They take care of geometry management for a set of widgets. To create more complex layouts, you can nest layout managers inside each other.\n• A QHBoxLayout lays out widgets in a horizontal row, from left to right (or right to left for right-to-left languages).\n• A QVBoxLayout lays out widgets in a vertical column, from top to bottom.\n• A QGridLayout lays out widgets in a two-dimensional grid. Widgets can occupy multiple cells.\n\nThe following code creates a QHBoxLayout that manages the geometry of five QPushButtons, as shown on the first screenshot above:\n\nThe code for QVBoxLayout is identical, except the line where the layout is created. The code for QGridLayout is a bit different, because we need to specify the row and column position of the child widget:\n\nThe third QPushButton spans 2 columns. This is possible by specifying 2 as the fifth argument to QGridLayout::addWidget().\n\nQFormLayout will add two widgets on a row, commonly a QLabel and a QLineEdit to create forms. Adding a QLabel and a QLineEdit on the same row will set the QLineEdit as the QLabel's buddy. The following code will use the QFormLayout to place three QPushButtons and a corresponding QLineEdit on a row.\n\nWhen you use a layout, you do not need to pass a parent when constructing the child widgets. The layout will automatically reparent the widgets (using QWidget::setParent()) so that they are children of the widget on which the layout is installed.\n\nYou can nest layouts using on a layout; the inner layout then becomes a child of the layout it is inserted into.\n\nWhen you add widgets to a layout, the layout process works as follows:\n• All the widgets will initially be allocated an amount of space in accordance with their QWidget::sizePolicy() and QWidget::sizeHint().\n• If any of the widgets have stretch factors set, with a value greater than zero, then they are allocated space in proportion to their stretch factor (explained below).\n• If any of the widgets have stretch factors set to zero they will only get more space if no other widgets want the space. Of these, space is allocated to widgets with an Expanding size policy first.\n• Any widgets that are allocated less space than their minimum size (or minimum size hint if no minimum size is specified) are allocated this minimum size they require. (Widgets don't have to have a minimum size or minimum size hint in which case the stretch factor is their determining factor.)\n• Any widgets that are allocated more space than their maximum size are allocated the maximum size space they require. (Widgets do not have to have a maximum size in which case the stretch factor is their determining factor.)\n\nWidgets are normally created without any stretch factor set. When they are laid out in a layout the widgets are given a share of space in accordance with their QWidget::sizePolicy() or their minimum size hint whichever is the greater. Stretch factors are used to change how much space widgets are given in proportion to one another.\n\nIf we have three widgets laid out using a QHBoxLayout with no stretch factors set we will get a layout like this:\n\nIf we apply stretch factors to each widget, they will be laid out in proportion (but never less than their minimum size hint), e.g.\n\nWhen you make your own widget class, you should also communicate its layout properties. If the widget uses one of Qt's layouts, this is already taken care of. If the widget does not have any child widgets, or uses a manual layout, you can change the behavior of the widget using any or all of the following mechanisms:\n• Reimplement QWidget::sizeHint() to return the preferred size of the widget.\n• Reimplement QWidget::minimumSizeHint() to return the smallest size the widget can have.\n• Call QWidget::setSizePolicy() to specify the space requirements of the widget.\n\nCall QWidget::updateGeometry() whenever the size hint, minimum size hint or size policy changes. This will cause a layout recalculation. Multiple consecutive calls to QWidget::updateGeometry() will only cause one layout recalculation.\n\nIf the preferred height of your widget depends on its actual width (e.g., a label with automatic word-breaking), set the height-for-width flag in the widget's size policy and reimplement QWidget::heightForWidth().\n\nEven if you implement QWidget::heightForWidth(), it is still a good idea to provide a reasonable sizeHint().\n\nFor further guidance when implementing these functions, see the Qt Quarterly article Trading Height for Width.\n\nThe use of rich text in a label widget can introduce some problems to the layout of its parent widget. Problems occur due to the way rich text is handled by Qt's layout managers when the label is word wrapped.\n\nIn certain cases the parent layout is put into QLayout::FreeResize mode, meaning that it will not adapt the layout of its contents to fit inside small sized windows, or even prevent the user from making the window too small to be usable. This can be overcome by subclassing the problematic widgets, and implementing suitable sizeHint() and minimumSizeHint() functions.\n\nIn some cases, it is relevant when a layout is added to a widget. When you set the widget of a QDockWidget or a QScrollArea (with QDockWidget::setWidget() and QScrollArea::setWidget()), the layout must already have been set on the widget. If not, the widget will not be visible.\n\nIf you are making a one-of-a-kind special layout, you can also make a custom widget as described above. Reimplement QWidget::resizeEvent() to calculate the required distribution of sizes and call setGeometry() on each child.\n\nThe widget will get an event of type QEvent::LayoutRequest when the layout needs to be recalculated. Reimplement QWidget::event() to handle QEvent::LayoutRequest events.\n\nAn alternative to manual layout is to write your own layout manager by subclassing QLayout. The Flow Layout example shows how to do this.\n\nHere we present an example in detail. The class is inspired by the Java layout manager of the same name. It lays out the items (widgets or nested layouts) on top of each other, each item offset by QLayout::spacing().\n\nTo write your own layout class, you must define the following:\n• A data structure to store the items handled by the layout. Each item is a QLayoutItem. We will use a QList in this example.\n• addItem(), how to add items to the layout.\n• setGeometry(), how to perform the layout.\n• sizeHint(), the preferred size of the layout.\n• itemAt(), how to iterate over the layout.\n• takeAt(), how to remove items from the layout.\n\nIn most cases, you will also implement minimumSize().\n\nFirst we define to fetch the number of items in the list.\n\nThen we define two functions that iterate over the layout: and . These functions are used internally by the layout system to handle deletion of widgets. They are also available for application programmers.\n\nreturns the item at the given index. removes the item at the given index, and returns it. In this case we use the list index as the layout index. In other cases where we have a more complex data structure, we may have to spend more effort defining a linear order for the items.\n\nimplements the default placement strategy for layout items. This function must be implemented. It is used by QLayout::add(), by the QLayout constructor that takes a layout as parent. If your layout has advanced placement options that require parameters, you must provide extra access functions such as the row and column spanning overloads of QGridLayout::addItem(), QGridLayout::addWidget(), and QGridLayout::addLayout().\n\nThe layout takes over responsibility of the items added. Since QLayoutItem does not inherit QObject, we must delete the items manually. In the destructor, we remove each item from the list using , and then delete it.\n\nThe function actually performs the layout. The rectangle supplied as an argument does not include . If relevant, use as the distance between items.\n\nand are normally very similar in implementation. The sizes returned by both functions should include , but not .\n• This custom layout does not handle height for width.\n• We ignore QLayoutItem::isEmpty(); this means that the layout will treat hidden widgets as visible.\n• For complex layouts, speed can be greatly increased by caching calculated values. In that case, implement QLayoutItem::invalidate() to mark the cached data is dirty.\n• Calling QLayoutItem::sizeHint(), etc. may be expensive. So, you should store the value in a local variable if you need it again later within in the same function.\n• You should not call QLayoutItem::setGeometry() twice on the same item in the same function. This call can be very expensive if the item has several child widgets, because the layout manager must do a complete layout every time. Instead, calculate the geometry and then set it. (This does not only apply to layouts, you should do the same if you implement your own resizeEvent(), for example.)\n\nMany Qt Widgets examples already use layouts, however, several examples exist to showcase various layouts."
    },
    {
        "link": "https://doc.qt.io/qtforpython-5/PySide2/QtWidgets/QVBoxLayout.html",
        "document": "This class is used to construct vertical box layout objects. See for details.\n\nThe simplest use of the class is like this:\n\nFirst, we create the widgets we want to add to the layout. Then, we create the object, setting as parent by passing it in the constructor; next we add the widgets to the layout. will be the parent of the widgets that are added to the layout.\n\nIf you don’t pass a parent to the constructor, you can at a later point use to install the object onto . At that point, the widgets in the layout are reparented to have as their parent."
    },
    {
        "link": "https://realpython.com/python-pyqt-layout",
        "document": "PyQt’s layout managers provide a user-friendly and productive way of arranging graphical components, or widgets, on a GUI. Laying out widgets properly will make your GUI applications look polished and professional. Learning to do so efficiently and effectively is a fundamental skill for you to get up and running with GUI application development using Python and PyQt.\n• What the benefits are of using PyQt’s layout managers\n• How to programmatically lay out widgets on a GUI using PyQt’s layout managers\n• How to select the right layout manager for your GUI application\n• How to lay out widgets in main window–based and dialog-based applications\n\nWith this knowledge and skillset, you’ll be able to use Python and PyQt to create professional-looking GUI applications.\n\nFor a better understanding of how to use layout managers, some previous knowledge of how to create PyQt GUI applications and how to work with PyQt widgets would be helpful.\n\nWhen you’re creating graphical user interface (GUI) applications, a common issue is how to get your graphical components—buttons, menus, toolbars, labels, and so on—laid out coherently on your forms and windows. This process is known as GUI layout, and it’s an important step in creating GUI applications. In the past, if you wanted to lay out graphical components, or widgets, on a window, then you would follow one of the following approaches:\n• Decide on and manually set a static size and position for each widget on the window.\n• Calculate and set the size and position of each widget dynamically. The first approach is fairly direct, but it has at least the following drawbacks:\n• Your windows will be non-resizable, which might cause problems when displaying them on different screen resolutions.\n• Your labels might not support localization properly because the length of a given text changes between languages.\n• Your widgets will display differently on different platforms, which makes it difficult to write multiplatform applications that look good. The second approach is more flexible. However, it also has drawbacks:\n• You have to do a lot of manual calculations to determine the right size and position of each widget.\n• You have to do some extra calculations to respond correctly to window resizing.\n• You have to redo all the calculations any time you modify the layout of your window. Even though you can still use either of these two approaches to lay out your GUIs, most of the time you’ll want to use a third and more convenient approach implemented by most modern GUI frameworks or toolkits: layout managers. Note: In some GUI frameworks, such as Tkinter, layout managers are also referred to as geometry managers. Layout managers automatically arrange widgets on a GUI according to your specific needs. They avoid the compatibility drawbacks of the first approach as well as the annoying and complicated calculations of the second approach. In the following sections, you’ll learn about PyQt’s built-in layout managers and how to use them to effectively lay out the graphical components of your GUI applications.\n\nGetting Stocked With a Gallery of PyQt Layouts In PyQt, widgets are graphical components that you use as building blocks for your GUI applications. When you place a bunch of widgets on a window to create a GUI, you need to give them some order. You need to set the widgets’ size and position on the window, and you also need to define their behavior for when the user resizes the underlying window. Note: Unfortunately, PyQt5’s official documentation has some incomplete sections. To work around this, you can check out the PyQt4 documentation, the Qt for Python documentation, or the original Qt documentation. In this tutorial, you’ll find that most links will take you to the original Qt documentation, which is a better source of information in most cases. To arrange the widgets on windows or forms in PyQt, you can use the following techniques:\n• Use and on your widgets to provide an absolute size and position.\n• Reimplement and calculate your widgets’ size and position dynamically.\n• Use layout managers and let them do all the calculations and hard work for you. These techniques generally correspond to the three different approaches for laying out a GUI that you saw in the previous section. Again, calculating the size and position dynamically might be a good approach, but most of the time you’ll be better off using layout managers. In PyQt, layout managers are classes that provide the required functionality to automatically manage the size, position, and resizing behavior of the widgets in the layout. With layout managers, you can automatically arrange child widgets within any parent, or container, widget. Using layout managers will ensure that you make good use of the available space on your GUI and also that your application remains usable when the user resizes the window. Layout managers work as containers for both widgets and other layouts. To add widgets to a layout manager, you call on the layout at hand. To add a layout to another layout, you call on the layout at hand. You’ll dive deeper into nesting layouts in the section Nesting Layouts to Build Complex GUIs. Once you’ve added all the required widgets to a layout manager, you set the layout manager on a given widget using . You can set a layout manager on any subclasses of , including windows or forms. Note: is a PyQt class that you can use to create main window–style applications. This class has its own built-in layout manager. So, if you’re using , then you commonly won’t need to set a layout manager on your main window objects. All the widgets in a layout are automatically set as children of the widget on which you install the layout, not of the layout itself. That’s because widgets can have only other widgets, not layouts, as their parent. PyQt’s layout managers provide some cool features that make your life a lot easier when it comes to creating good-looking GUI applications:\n• Handling the size and position of widgets without the need for any calculation\n• Handling the resizing and repositioning of widget when the user resizes the underlying window Using layout managers will also dramatically increase your productivity and improve your code’s maintainability in the long term. In the next few sections, you’ll learn the basics of how to use these general-purpose layout managers.\n\nWhen creating GUI applications with PyQt, you’ll often use one or more of the four general-purpose layouts that you saw at the end of the previous section to get your widget laid out on your windows and forms. In the next few sections, you’ll learn how to create and use the four general-purpose layout managers with the help of some examples. Box layout managers take the space they get from their parent layout or widget, divide it up into a number of boxes, or cells, and make each widget in the layout fill one box. is one of the two available box layouts in PyQt. This layout manager allows you to arrange widgets horizontally, one next to the other. The widgets are added to the layout from left to right. This means that the widget that you add first in your code will be the left-most widget in the layout. To add widgets to a object, you call on the layout object. This method takes one required argument and two optional arguments:\n• is a required argument that holds the specific widget that you want to add to the layout.\n• is an optional argument that holds an integer number representing the stretch factor to apply to . Widgets with higher stretch factors grow more on window resizing. It defaults to , which means that the widget has no stretch factor assigned.\n• is an optional argument that holds horizontal and vertical flags. You can combine these flags to produce the desired alignment of the widget inside its containing cell. It defaults to , which means that the widget will fill the entire cell. Here’s a small application that shows how to create a horizontal layout using . In this example, you’ll use objects to better visualize where each widget will be placed in the layout according to the order in which you add the widgets to your code: # Set the layout on the application's window On line 15, you create a object called . On lines 17 to 19, you add three buttons to using . Note that you pass and to the parameter in the Center and Right-Most buttons, respectively. On line 21, you set as your window’s top-level layout using . Note: If you’re new to GUI programming with PyQt, then you can take a look at Python and PyQt: Building a GUI Desktop Calculator to get a better idea of how to create a GUI application with PyQt. If you run this application, then you’ll get the following window on your screen: This window contains three buttons arranged in a horizontal fashion. Note that the Left-Most button corresponds to the first button that you add in your code. So, buttons are shown in the same order (from left to right) that you add them in your code (from top to bottom). The Center and Right-Most buttons have different stretch factors, so they expand in proportion to those factors when you resize the window. Additionally, all the buttons in and the layout itself are set as children of . This is automatically done by the layout object, which internally calls on each widget. The call to on line 22 prints a list of the children of on your terminal as evidence of this behavior. arranges widgets vertically, one below the other. You can use this class to create vertical layouts and arrange your widgets from top to bottom. Since is another box layout, its method works the same as in . Here’s a PyQt application that shows how to create and use a object for creating vertical arrangements of widgets in your GUIs: # Set the layout on the application's window On line 16, you create an instance of . On lines 18 to 20, you add three buttons to . Finally, you set as your window’s top-level layout. If you run this application, then you’ll get the following window: Your window shows three buttons in a vertical arrangement, one below the other. The buttons appear in the same order (from top to bottom) as you add them in your code (from top to bottom). You can use to arrange widgets in a grid of rows and columns. Each widget will have a relative position in the grid. To define a widget’s position, or cell in the grid, you use a pair of coordinates of the form . These coordinates should be zero-based integer numbers. takes the available space on its parent, divides it into rows and columns, and places each widget into its own cell or box. automatically figures out how many rows and columns the final layout will have depending on the number of widgets and their coordinates. If you don’t add a widget to a given cell, then will leave that cell empty. To add widgets to a grid layout, you call on the layout. This method has two different overloaded implementations:\n• adds to the cell at ( , ).\n• adds to the cell, spanning multiple rows, columns, or both. The first implementation takes the following arguments:\n• is a required argument that holds the specific widget that you need to add to the layout.\n• is a required argument that holds an integer representing the coordinate of a row in the grid.\n• is a required argument that holds an integer representing the coordinate of a column in the grid.\n• is an optional argument that holds the alignment of the widget inside its containing cell. It defaults to , which means that the widget will fill the entire cell. Here’s an example of how to use to create a grid of widgets: # Set the layout on the application's window On line 15, you create the object. Then, on lines 17 to 25, you add widgets to the layout using . To see how grid layouts manage cells without an assigned widget, comment out one or more of these lines and run the application again. If you run this code from your command line, then you’ll get a window like this: Each widget in the object occupies the cell defined by the pair of coordinates that you provide in . The text on each button reflects those coordinates. The coordinates are zero-based, so the first cell is at . In the second implementation of , the arguments and stay the same, and you have four additional arguments that allow you to place the widget across several rows or columns:\n• takes an integer number that represents the row in which the widget will start.\n• takes an integer number that represents the column in which the widget will start.\n• takes an integer number that represents the number of rows that the widget will occupy in the grid.\n• takes an integer number that represents the number of columns that the widget will occupy in the grid. Here’s an application that shows how this variation of works: # Set the layout on the application's window On line 19, you use the second implementation of to add a button that occupies two columns in the grid. The button starts at the second row ( ) and at the first column ( ). Finally, the button occupies one row ( ) and two columns ( ). Note: Since PyQt is a Python binding for Qt, which is a set of C++ libraries, sometimes you can’t use keyword arguments when calling PyQt methods. The keyword arguments used in the above paragraph have the sole purpose of showing what value is assigned to each argument. Here’s the window that you’ll see on your screen if you run this application: In this kind of layout, you can make a widget occupy more than one cell, just as you did with the Button Spans two Cols button. If you’re constantly creating forms to perform actions like inputting data into a database, then is for you. This class arranges widgets in a two-column layout. The first column usually displays a label describing the intended input, and the second column generally contains input widgets such as , , or that allow the user to enter or edit data. To add widgets to a form layout, you use . This method has several variations but, most of the time, you’ll choose from the following two:\n• adds a new row to the bottom of a form layout. The row should contain a object ( ) and an input widget ( ).\n• automatically creates and adds a new object with as its text. holds an input widget. Here’s a sample application that uses a object to arrange widgets: # Set the layout on the application's window On line 17, you create a object. Then, on lines 19 to 22, you add some rows to the layout. Note that on lines 19 and 20, you use the second variation of the method, and on line 22, you use the first variation, passing a object as the first argument to . If you run this code, then you’ll get the following window on your screen: With a , you can organize your widgets in a two-column arrangement. The first column contains labels that ask the user for some information. The second column shows widgets that allow the user to input or edit that information.\n\nYou can use nested layouts to create complex GUIs that would be difficult to create using one of the general-purpose PyQt’s layout managers. To do that, you need to call on an outer layout. This way, the inner layout becomes a child of the outer layout. Suppose you need to create a dialog that shows a label and a line edit in a form layout, and below those widgets you want to place several checkboxes in a vertical layout. Here’s a mock-up of what your dialog should look like: The blue rectangle represents your outer layout. The green rectangle is the form layout that will hold the label and line edit. The red rectangle is the vertical layout to hold the option checkboxes. Both the green layout and the red layout are nested into the blue one, which is a vertical layout. Here’s an example of how to build this layout using PyQt: # Create a form layout for the label and line edit # Add a label and a line edit to the form layout # Add some checkboxes to the layout # Nest the inner layouts into the outer layout Here’s what you’re doing in this code:\n• On line 17, you create the outer, or top-level, layout, which you’ll use as a parent layout and as the main layout of your window. In this case, you use because you want your widgets to be arranged vertically on your form. In your mock-up, this is the blue layout.\n• On line 19, you create a form layout to hold a label and a line edit.\n• On line 21, you add the required widgets to the layout. This is equivalent to your green layout.\n• On line 23, you create a vertical layout to hold the checkboxes.\n• On lines 25 to 27, you add the required checkboxes. This is your red layout.\n• On lines 29 and 30, you nest and under the . That’s it! If you run the application, then you’ll see a window like the following: In this application, you nest two different layouts under an outer layout to create a general layout for your window. At the top of the window, you use a horizontal layout to place a label and a line edit. Then you place some checkboxes below that using a vertical layout.\n\nSo far, you’ve seen how to use traditional or general-purpose layout managers to arrange the widgets in your application’s windows. These layout managers will arrange widgets on a single-page layout. In other words, your GUI will always show the same set of widgets to the user. Sometimes you need to create a layout that shows a different set of widgets in response to certain user actions on the GUI. For example, if you’re creating a preferences dialog for a given application, then you might want to present the user with a tab-based, or multipage, layout in which each tab or page contains a different set of closely related options. Every time the user clicks on a tab or page, the application shows a different set of widgets. PyQt provides a built-in layout called and some convenient widgets like that will allow you to create this kind of multipage layout. The next few sections will walk you through some of these tools. provides a layout manager that will allow you to arrange your widgets on a stack, one on top of the other. In this kind of layout, only one widget is visible at a given time. To populate a stacked layout with widgets, you need to call on the layout object. This will add each widget to the end of the layout’s internal list of widgets. You can also insert or remove a widget at a given position in the list of widgets using or , respectively. Each widget in the list of widgets is displayed as an independent page. If you want to show several widgets on a page, then use a object for each page and set an appropriate layout of widgets to the page widget. If you need to get the total number of widgets (pages) in the layout, then you can call . An important point to keep in mind when working with objects is that you need to explicitly provide a mechanism to switch between pages. Otherwise, your layout will always show the same page to the user. To switch between pages, you need to call on the layout object. Here’s an example that shows how to use a stacked layout with a combo box for switching between pages: # Create and connect the combo box to switch between pages # Add the combo box and the stacked layout to the top-level layout On lines 21 to 23, you create a object that will allow you to switch between the pages in the layout. Then you add two options to the combo box in a list and connect it to , which is intended to handle page switching. Inside , you call on the layout object, passing the current index of the combo box as an argument. This way, when the user changes the option in the combo box, the page on the stacked layout will change accordingly. On line 25, you create the object. On lines 27 to 32, you add the first page to the layout, and on lines 34 to 39, you add the second page. Each page is represented by a object that contains several widgets in a convenient layout. The final step to get everything working is to add the combo box and the layout to the application’s main layout. Here’s how your application behaves now: In this case, you have two pages in your application’s layout. Each page is represented by a object. When you select a new page in the combo box on the top of the window, the layout changes to show the selected page. Note: PyQt provides a convenient class called , which is built on top of . You can also use this class to create multipage layouts. This class provides a stack of widgets in which only one widget is visible at a time. Just like stacked layouts, doesn’t provide an intrinsic mechanism for switching between pages. Besides stacked layout and stacked widget, you can use to create a multipage user interface. You’ll learn how in the next section. Another popular way of creating multipage arrangements in PyQt is by using a class called . This class provides a tab bar and a page area. You use the tab bar to switch between pages and the page area to display the page associated with the selected tab. The tab bar is located at the top of the page area by default. However, you can change this behavior using and one of four possible tab positions: Right of the pages To add tabs to a tab widget, you use . This method has two variations, or overloaded implementations: In both cases, the method adds a new tab, with as the tab’s title. needs to be a widget representing the page associated with the tab at hand. In the second variation of the method, needs to be a object. If you pass an icon to , then that icon will be shown to the left of the tab’s title. A common practice when creating tab widgets is to use a object for each page. This way, you’ll be able to add extra widgets to the page using a layout containing the required widgets. Most of the time, you’ll use tab widgets to create dialogs for your GUI applications. This kind of layout allows you to present the user with several options in a relatively small space. You can also take advantage of the tab system to organize your options according to some classification criteria. Here’s a sample application that shows the basics of how to create and use a object: # Create the tab widget with two tabs In this example, you use a tab widget to present the user with a concise dialog that shows options related to the General and Network sections of a hypothetical preferences menu. On line 20, you create the object. Then you add two tabs to the tab widget using . In and , you create the specific GUI for each tab. To do this, you use a object, a object, and some checkboxes to hold the options. If you run the application now, then you’ll get the following dialog on your screen: That’s it! You have a fully functional tab-based GUI. Note that to switch between pages, you just need to click the corresponding tab.\n\nGUI applications are commonly built using a main window and one or more dialogs. Dialogs are small windows that allow you to communicate with your users. PyQt provides to handle the creation of dialogs. Unlike , doesn’t have a predefined or default top-level layout. That’s because dialogs can be quite varied and include a wide range of widget arrangements and combinations. Once you place all the widgets on a dialog’s GUI, you need to set a top-level layout on that dialog. To do this, you have to call on the dialog object just like you’d do with any other widget. Here’s a dialog-style application that shows how to set a top-level layout to a object: # Set the layout on the dialog In this case, the application’s window inherits from , so you have a dialog-style application. On line 16, you create the layout that you’ll use as the dialog’s top-level layout. On lines 18 to 21, you create a form layout to arrange some widgets in a form. On line 24, you add a object. You’ll often use to handle the buttons on a dialog. In this example, you use two buttons, an Ok button and a Cancel button. These buttons won’t have any functionality—they’re just intended to make the dialog more realistic. Once you have all the widgets and layouts in place, you can add them to the top-level layout. That’s what you do on lines 28 and 29. The final step, on line 30, is to set the top-level layout as your dialog’s layout using . If you run this application, then you’ll see the following window on your screen: It’s a best practice to set a top-level layout for all your dialogs. This ensures that the dialog’s GUI will behave coherently when the user resizes the underlying window. Otherwise, your dialogs could appear disorganized and unpolished in the user’s eyes.\n\nWhen it comes to using PyQt’s layout managers to arrange the widgets on a window or form, managing space—empty space, space between widgets, and so on—is a common issue. Being able to manage this space is an important skill to have. Internally, layouts manage the available space on a window using some of the following widget properties:\n• contains the smallest size the widget can have while remaining usable\n• holds the default behavior of a widget in a layout Layouts use these properties to automatically position and resize widgets, assigning a given amount of space to each widget according to the available space. This ensures that widgets are consistently arranged and remain usable. In the next three sections, you’ll learn how the different types of layouts manage space in PyQt. Box layouts do a great job when it comes to distributing available space between widgets. However, sometime their default behavior isn’t enough, and you need to manually handle the available space. To help you out in this situation, PyQt provides . This class allows you to add blank space (or empty boxes) to a box layout. Normally, you don’t need to use directly. Instead, you call some of the following methods on your box layout objects:\n• adds a non-stretchable space (or empty box) of fixed size to the layout. must be an integer representing the size of the space in pixels.\n• adds a stretchable space with a minimum size of and a stretch factor to a box layout. must be an integer.\n• inserts a non-stretchable space at position , with size . If is negative, then the space is added at the end of the box layout.\n• inserts a stretchable space at position , with a minimum size of and a stretch factor of . If is negative, then the space is added at the end of the box layout. Stretchable spacers will expand or shrink to fill empty space when the user resizes the underlying window. Non-stretchable spacers will remain the same size regardless of the changes in the size of the underlying window. Go back to the example of how to use vertical layouts and run that application again. If you pull down the border of the window, then you’ll notice that more space appears between the buttons the further down you pull: This happens because the layout handles the newly available space by automatically expanding its boxes. You can change this behavior by adding a stretchable object to the end of the layout. In your example’s code, update the initializer of as follows: # Set the layout on the application's window In the highlighted line, you add a stretchable object to the end of the layout by calling on the layout. If you run the application again, then you’ll get the following behavior: Now all the extra space is automatically assigned to the stretchable object at the bottom of the layout without affecting the position or size of the rest of the widgets. You can use this and other space management techniques to make your GUI applications look good and polished. Grid and form layouts handle available space in a different way. In these types of layouts, you can handle only the vertical and horizontal space between widgets. These layouts provide three methods to manage these spaces:\n• sets both the vertical and the horizontal spacing between widgets to .\n• sets only the vertical spacing between widgets in the layout to .\n• sets only the horizontal spacing between widgets in the layout to . In all cases, is an integer representing pixels. Now go back to the example on how to create a form layout and update the initializer of like this: # Set the layout on the application's window In the highlighted line, you set the vertical space between widgets to pixels. If you run the application again, then you’ll see the following window: Now there’s more space between the rows of widgets. You can also try modifying the example of how to use a grid layout by adding some vertical or horizontal space just to see how all these spacing mechanisms work."
    },
    {
        "link": "https://stackoverflow.com/questions/3077192/get-a-layouts-widgets-in-pyqt",
        "document": "That's odd. My understanding is that adding widgets via transfers ownership to the layout so calling ought to work.\n\nHowever, as an alternative you could loop over the layout items by using and to supply a to .\n\nI've just tried with a straight C++ test app. and it doesn't transfer ownership to the layout so is indeed an empty list. The docs clearly say that ownership is transferred though...\n\nOkay, it looks as though it transfers ownership to the widget that has that layout (which is not what the docs said). That makes the items in the layout siblings of the layout itself in the hierarchy! It's therefore easier to stick with and .\n\nMy interpretation of the docs was wrong. I was getting the layout item confused with the widget. The following clarifies what has always been the case.\n\nWidgets in a layout are children of the widget on which the layout is installed, not of the layout itself. Widgets can only have other widgets as parent, not layouts."
    },
    {
        "link": "https://stackoverflow.com/questions/70471933/python-pyqt5-pushbutton-not-working-properly-in-certain-areas",
        "document": "I created something similar to a library management system GUI using PyQt5. I created a QScrollArea where my QGroupBoxes are placed using a for loop. Somehow some of the pushbuttons inside my groupboxes are not working properly though in certain areas it works perfectly fine. It seems like the pushbuttons work properly when inside the first half of the scroll area. Ad when its in the second half if doesn't work at all (I must say, it works just like an image label instead of a pushbutton)\n\nThis is the video of my whole code running. Please focus on my cursor and where is is pointed/clicking to better understand what I am talking about. Thank you in advanced!\n\nP.S. : I tried using this code to my real python file and the all the QPushButtons (top and bottom half of the scroll area) are now completely unclickable (not working as a button). It is not doing anything like showing the PointingHandCursor whenever I hover over it not is it clickable. I don't think I did anything to it though except adding it to my real Library Management System Python file"
    },
    {
        "link": "https://forum.qt.io/topic/122417/layout-is-changing-when-using-qscrollarea-in-pyqt5",
        "document": "Hello. I am having a problem when using QScrollArea in PyQt5.\n\nI have attached two widgets to a QStackedWidget in a QScrollArea. I am adding labels to the layouts of the two individual widgets that I am attaching to this QStackedWidget.\n\nHowever, when I switch back and forth between the two widgets in my Scroll Area, the layout changes for both widgets. If you continue to press back and forth, the labels continue to \"slide\" down the second widget.\n\nI would like the layouts to stay the exact same for each individual layout, for each individual widget in the Scroll Area, and not be modified with each click.\n\nThe following is my code:"
    },
    {
        "link": "https://stackoverflow.com/questions/17645319/make-qpushbutton-invisible-yet-still-work",
        "document": "In my project, I have some pushbuttons that change between visible and invisible using this:\n\nHowever, it seems that when they are invisible, they also do not work? How can I get around this?\n\nI have already tried this:\n\nfor all of them but nothing changes."
    },
    {
        "link": "https://realpython.com/python-pyqt-layout",
        "document": "PyQt’s layout managers provide a user-friendly and productive way of arranging graphical components, or widgets, on a GUI. Laying out widgets properly will make your GUI applications look polished and professional. Learning to do so efficiently and effectively is a fundamental skill for you to get up and running with GUI application development using Python and PyQt.\n• What the benefits are of using PyQt’s layout managers\n• How to programmatically lay out widgets on a GUI using PyQt’s layout managers\n• How to select the right layout manager for your GUI application\n• How to lay out widgets in main window–based and dialog-based applications\n\nWith this knowledge and skillset, you’ll be able to use Python and PyQt to create professional-looking GUI applications.\n\nFor a better understanding of how to use layout managers, some previous knowledge of how to create PyQt GUI applications and how to work with PyQt widgets would be helpful.\n\nWhen you’re creating graphical user interface (GUI) applications, a common issue is how to get your graphical components—buttons, menus, toolbars, labels, and so on—laid out coherently on your forms and windows. This process is known as GUI layout, and it’s an important step in creating GUI applications. In the past, if you wanted to lay out graphical components, or widgets, on a window, then you would follow one of the following approaches:\n• Decide on and manually set a static size and position for each widget on the window.\n• Calculate and set the size and position of each widget dynamically. The first approach is fairly direct, but it has at least the following drawbacks:\n• Your windows will be non-resizable, which might cause problems when displaying them on different screen resolutions.\n• Your labels might not support localization properly because the length of a given text changes between languages.\n• Your widgets will display differently on different platforms, which makes it difficult to write multiplatform applications that look good. The second approach is more flexible. However, it also has drawbacks:\n• You have to do a lot of manual calculations to determine the right size and position of each widget.\n• You have to do some extra calculations to respond correctly to window resizing.\n• You have to redo all the calculations any time you modify the layout of your window. Even though you can still use either of these two approaches to lay out your GUIs, most of the time you’ll want to use a third and more convenient approach implemented by most modern GUI frameworks or toolkits: layout managers. Note: In some GUI frameworks, such as Tkinter, layout managers are also referred to as geometry managers. Layout managers automatically arrange widgets on a GUI according to your specific needs. They avoid the compatibility drawbacks of the first approach as well as the annoying and complicated calculations of the second approach. In the following sections, you’ll learn about PyQt’s built-in layout managers and how to use them to effectively lay out the graphical components of your GUI applications.\n\nGetting Stocked With a Gallery of PyQt Layouts In PyQt, widgets are graphical components that you use as building blocks for your GUI applications. When you place a bunch of widgets on a window to create a GUI, you need to give them some order. You need to set the widgets’ size and position on the window, and you also need to define their behavior for when the user resizes the underlying window. Note: Unfortunately, PyQt5’s official documentation has some incomplete sections. To work around this, you can check out the PyQt4 documentation, the Qt for Python documentation, or the original Qt documentation. In this tutorial, you’ll find that most links will take you to the original Qt documentation, which is a better source of information in most cases. To arrange the widgets on windows or forms in PyQt, you can use the following techniques:\n• Use and on your widgets to provide an absolute size and position.\n• Reimplement and calculate your widgets’ size and position dynamically.\n• Use layout managers and let them do all the calculations and hard work for you. These techniques generally correspond to the three different approaches for laying out a GUI that you saw in the previous section. Again, calculating the size and position dynamically might be a good approach, but most of the time you’ll be better off using layout managers. In PyQt, layout managers are classes that provide the required functionality to automatically manage the size, position, and resizing behavior of the widgets in the layout. With layout managers, you can automatically arrange child widgets within any parent, or container, widget. Using layout managers will ensure that you make good use of the available space on your GUI and also that your application remains usable when the user resizes the window. Layout managers work as containers for both widgets and other layouts. To add widgets to a layout manager, you call on the layout at hand. To add a layout to another layout, you call on the layout at hand. You’ll dive deeper into nesting layouts in the section Nesting Layouts to Build Complex GUIs. Once you’ve added all the required widgets to a layout manager, you set the layout manager on a given widget using . You can set a layout manager on any subclasses of , including windows or forms. Note: is a PyQt class that you can use to create main window–style applications. This class has its own built-in layout manager. So, if you’re using , then you commonly won’t need to set a layout manager on your main window objects. All the widgets in a layout are automatically set as children of the widget on which you install the layout, not of the layout itself. That’s because widgets can have only other widgets, not layouts, as their parent. PyQt’s layout managers provide some cool features that make your life a lot easier when it comes to creating good-looking GUI applications:\n• Handling the size and position of widgets without the need for any calculation\n• Handling the resizing and repositioning of widget when the user resizes the underlying window Using layout managers will also dramatically increase your productivity and improve your code’s maintainability in the long term. In the next few sections, you’ll learn the basics of how to use these general-purpose layout managers.\n\nWhen creating GUI applications with PyQt, you’ll often use one or more of the four general-purpose layouts that you saw at the end of the previous section to get your widget laid out on your windows and forms. In the next few sections, you’ll learn how to create and use the four general-purpose layout managers with the help of some examples. Box layout managers take the space they get from their parent layout or widget, divide it up into a number of boxes, or cells, and make each widget in the layout fill one box. is one of the two available box layouts in PyQt. This layout manager allows you to arrange widgets horizontally, one next to the other. The widgets are added to the layout from left to right. This means that the widget that you add first in your code will be the left-most widget in the layout. To add widgets to a object, you call on the layout object. This method takes one required argument and two optional arguments:\n• is a required argument that holds the specific widget that you want to add to the layout.\n• is an optional argument that holds an integer number representing the stretch factor to apply to . Widgets with higher stretch factors grow more on window resizing. It defaults to , which means that the widget has no stretch factor assigned.\n• is an optional argument that holds horizontal and vertical flags. You can combine these flags to produce the desired alignment of the widget inside its containing cell. It defaults to , which means that the widget will fill the entire cell. Here’s a small application that shows how to create a horizontal layout using . In this example, you’ll use objects to better visualize where each widget will be placed in the layout according to the order in which you add the widgets to your code: # Set the layout on the application's window On line 15, you create a object called . On lines 17 to 19, you add three buttons to using . Note that you pass and to the parameter in the Center and Right-Most buttons, respectively. On line 21, you set as your window’s top-level layout using . Note: If you’re new to GUI programming with PyQt, then you can take a look at Python and PyQt: Building a GUI Desktop Calculator to get a better idea of how to create a GUI application with PyQt. If you run this application, then you’ll get the following window on your screen: This window contains three buttons arranged in a horizontal fashion. Note that the Left-Most button corresponds to the first button that you add in your code. So, buttons are shown in the same order (from left to right) that you add them in your code (from top to bottom). The Center and Right-Most buttons have different stretch factors, so they expand in proportion to those factors when you resize the window. Additionally, all the buttons in and the layout itself are set as children of . This is automatically done by the layout object, which internally calls on each widget. The call to on line 22 prints a list of the children of on your terminal as evidence of this behavior. arranges widgets vertically, one below the other. You can use this class to create vertical layouts and arrange your widgets from top to bottom. Since is another box layout, its method works the same as in . Here’s a PyQt application that shows how to create and use a object for creating vertical arrangements of widgets in your GUIs: # Set the layout on the application's window On line 16, you create an instance of . On lines 18 to 20, you add three buttons to . Finally, you set as your window’s top-level layout. If you run this application, then you’ll get the following window: Your window shows three buttons in a vertical arrangement, one below the other. The buttons appear in the same order (from top to bottom) as you add them in your code (from top to bottom). You can use to arrange widgets in a grid of rows and columns. Each widget will have a relative position in the grid. To define a widget’s position, or cell in the grid, you use a pair of coordinates of the form . These coordinates should be zero-based integer numbers. takes the available space on its parent, divides it into rows and columns, and places each widget into its own cell or box. automatically figures out how many rows and columns the final layout will have depending on the number of widgets and their coordinates. If you don’t add a widget to a given cell, then will leave that cell empty. To add widgets to a grid layout, you call on the layout. This method has two different overloaded implementations:\n• adds to the cell at ( , ).\n• adds to the cell, spanning multiple rows, columns, or both. The first implementation takes the following arguments:\n• is a required argument that holds the specific widget that you need to add to the layout.\n• is a required argument that holds an integer representing the coordinate of a row in the grid.\n• is a required argument that holds an integer representing the coordinate of a column in the grid.\n• is an optional argument that holds the alignment of the widget inside its containing cell. It defaults to , which means that the widget will fill the entire cell. Here’s an example of how to use to create a grid of widgets: # Set the layout on the application's window On line 15, you create the object. Then, on lines 17 to 25, you add widgets to the layout using . To see how grid layouts manage cells without an assigned widget, comment out one or more of these lines and run the application again. If you run this code from your command line, then you’ll get a window like this: Each widget in the object occupies the cell defined by the pair of coordinates that you provide in . The text on each button reflects those coordinates. The coordinates are zero-based, so the first cell is at . In the second implementation of , the arguments and stay the same, and you have four additional arguments that allow you to place the widget across several rows or columns:\n• takes an integer number that represents the row in which the widget will start.\n• takes an integer number that represents the column in which the widget will start.\n• takes an integer number that represents the number of rows that the widget will occupy in the grid.\n• takes an integer number that represents the number of columns that the widget will occupy in the grid. Here’s an application that shows how this variation of works: # Set the layout on the application's window On line 19, you use the second implementation of to add a button that occupies two columns in the grid. The button starts at the second row ( ) and at the first column ( ). Finally, the button occupies one row ( ) and two columns ( ). Note: Since PyQt is a Python binding for Qt, which is a set of C++ libraries, sometimes you can’t use keyword arguments when calling PyQt methods. The keyword arguments used in the above paragraph have the sole purpose of showing what value is assigned to each argument. Here’s the window that you’ll see on your screen if you run this application: In this kind of layout, you can make a widget occupy more than one cell, just as you did with the Button Spans two Cols button. If you’re constantly creating forms to perform actions like inputting data into a database, then is for you. This class arranges widgets in a two-column layout. The first column usually displays a label describing the intended input, and the second column generally contains input widgets such as , , or that allow the user to enter or edit data. To add widgets to a form layout, you use . This method has several variations but, most of the time, you’ll choose from the following two:\n• adds a new row to the bottom of a form layout. The row should contain a object ( ) and an input widget ( ).\n• automatically creates and adds a new object with as its text. holds an input widget. Here’s a sample application that uses a object to arrange widgets: # Set the layout on the application's window On line 17, you create a object. Then, on lines 19 to 22, you add some rows to the layout. Note that on lines 19 and 20, you use the second variation of the method, and on line 22, you use the first variation, passing a object as the first argument to . If you run this code, then you’ll get the following window on your screen: With a , you can organize your widgets in a two-column arrangement. The first column contains labels that ask the user for some information. The second column shows widgets that allow the user to input or edit that information.\n\nYou can use nested layouts to create complex GUIs that would be difficult to create using one of the general-purpose PyQt’s layout managers. To do that, you need to call on an outer layout. This way, the inner layout becomes a child of the outer layout. Suppose you need to create a dialog that shows a label and a line edit in a form layout, and below those widgets you want to place several checkboxes in a vertical layout. Here’s a mock-up of what your dialog should look like: The blue rectangle represents your outer layout. The green rectangle is the form layout that will hold the label and line edit. The red rectangle is the vertical layout to hold the option checkboxes. Both the green layout and the red layout are nested into the blue one, which is a vertical layout. Here’s an example of how to build this layout using PyQt: # Create a form layout for the label and line edit # Add a label and a line edit to the form layout # Add some checkboxes to the layout # Nest the inner layouts into the outer layout Here’s what you’re doing in this code:\n• On line 17, you create the outer, or top-level, layout, which you’ll use as a parent layout and as the main layout of your window. In this case, you use because you want your widgets to be arranged vertically on your form. In your mock-up, this is the blue layout.\n• On line 19, you create a form layout to hold a label and a line edit.\n• On line 21, you add the required widgets to the layout. This is equivalent to your green layout.\n• On line 23, you create a vertical layout to hold the checkboxes.\n• On lines 25 to 27, you add the required checkboxes. This is your red layout.\n• On lines 29 and 30, you nest and under the . That’s it! If you run the application, then you’ll see a window like the following: In this application, you nest two different layouts under an outer layout to create a general layout for your window. At the top of the window, you use a horizontal layout to place a label and a line edit. Then you place some checkboxes below that using a vertical layout.\n\nSo far, you’ve seen how to use traditional or general-purpose layout managers to arrange the widgets in your application’s windows. These layout managers will arrange widgets on a single-page layout. In other words, your GUI will always show the same set of widgets to the user. Sometimes you need to create a layout that shows a different set of widgets in response to certain user actions on the GUI. For example, if you’re creating a preferences dialog for a given application, then you might want to present the user with a tab-based, or multipage, layout in which each tab or page contains a different set of closely related options. Every time the user clicks on a tab or page, the application shows a different set of widgets. PyQt provides a built-in layout called and some convenient widgets like that will allow you to create this kind of multipage layout. The next few sections will walk you through some of these tools. provides a layout manager that will allow you to arrange your widgets on a stack, one on top of the other. In this kind of layout, only one widget is visible at a given time. To populate a stacked layout with widgets, you need to call on the layout object. This will add each widget to the end of the layout’s internal list of widgets. You can also insert or remove a widget at a given position in the list of widgets using or , respectively. Each widget in the list of widgets is displayed as an independent page. If you want to show several widgets on a page, then use a object for each page and set an appropriate layout of widgets to the page widget. If you need to get the total number of widgets (pages) in the layout, then you can call . An important point to keep in mind when working with objects is that you need to explicitly provide a mechanism to switch between pages. Otherwise, your layout will always show the same page to the user. To switch between pages, you need to call on the layout object. Here’s an example that shows how to use a stacked layout with a combo box for switching between pages: # Create and connect the combo box to switch between pages # Add the combo box and the stacked layout to the top-level layout On lines 21 to 23, you create a object that will allow you to switch between the pages in the layout. Then you add two options to the combo box in a list and connect it to , which is intended to handle page switching. Inside , you call on the layout object, passing the current index of the combo box as an argument. This way, when the user changes the option in the combo box, the page on the stacked layout will change accordingly. On line 25, you create the object. On lines 27 to 32, you add the first page to the layout, and on lines 34 to 39, you add the second page. Each page is represented by a object that contains several widgets in a convenient layout. The final step to get everything working is to add the combo box and the layout to the application’s main layout. Here’s how your application behaves now: In this case, you have two pages in your application’s layout. Each page is represented by a object. When you select a new page in the combo box on the top of the window, the layout changes to show the selected page. Note: PyQt provides a convenient class called , which is built on top of . You can also use this class to create multipage layouts. This class provides a stack of widgets in which only one widget is visible at a time. Just like stacked layouts, doesn’t provide an intrinsic mechanism for switching between pages. Besides stacked layout and stacked widget, you can use to create a multipage user interface. You’ll learn how in the next section. Another popular way of creating multipage arrangements in PyQt is by using a class called . This class provides a tab bar and a page area. You use the tab bar to switch between pages and the page area to display the page associated with the selected tab. The tab bar is located at the top of the page area by default. However, you can change this behavior using and one of four possible tab positions: Right of the pages To add tabs to a tab widget, you use . This method has two variations, or overloaded implementations: In both cases, the method adds a new tab, with as the tab’s title. needs to be a widget representing the page associated with the tab at hand. In the second variation of the method, needs to be a object. If you pass an icon to , then that icon will be shown to the left of the tab’s title. A common practice when creating tab widgets is to use a object for each page. This way, you’ll be able to add extra widgets to the page using a layout containing the required widgets. Most of the time, you’ll use tab widgets to create dialogs for your GUI applications. This kind of layout allows you to present the user with several options in a relatively small space. You can also take advantage of the tab system to organize your options according to some classification criteria. Here’s a sample application that shows the basics of how to create and use a object: # Create the tab widget with two tabs In this example, you use a tab widget to present the user with a concise dialog that shows options related to the General and Network sections of a hypothetical preferences menu. On line 20, you create the object. Then you add two tabs to the tab widget using . In and , you create the specific GUI for each tab. To do this, you use a object, a object, and some checkboxes to hold the options. If you run the application now, then you’ll get the following dialog on your screen: That’s it! You have a fully functional tab-based GUI. Note that to switch between pages, you just need to click the corresponding tab.\n\nGUI applications are commonly built using a main window and one or more dialogs. Dialogs are small windows that allow you to communicate with your users. PyQt provides to handle the creation of dialogs. Unlike , doesn’t have a predefined or default top-level layout. That’s because dialogs can be quite varied and include a wide range of widget arrangements and combinations. Once you place all the widgets on a dialog’s GUI, you need to set a top-level layout on that dialog. To do this, you have to call on the dialog object just like you’d do with any other widget. Here’s a dialog-style application that shows how to set a top-level layout to a object: # Set the layout on the dialog In this case, the application’s window inherits from , so you have a dialog-style application. On line 16, you create the layout that you’ll use as the dialog’s top-level layout. On lines 18 to 21, you create a form layout to arrange some widgets in a form. On line 24, you add a object. You’ll often use to handle the buttons on a dialog. In this example, you use two buttons, an Ok button and a Cancel button. These buttons won’t have any functionality—they’re just intended to make the dialog more realistic. Once you have all the widgets and layouts in place, you can add them to the top-level layout. That’s what you do on lines 28 and 29. The final step, on line 30, is to set the top-level layout as your dialog’s layout using . If you run this application, then you’ll see the following window on your screen: It’s a best practice to set a top-level layout for all your dialogs. This ensures that the dialog’s GUI will behave coherently when the user resizes the underlying window. Otherwise, your dialogs could appear disorganized and unpolished in the user’s eyes.\n\nWhen it comes to using PyQt’s layout managers to arrange the widgets on a window or form, managing space—empty space, space between widgets, and so on—is a common issue. Being able to manage this space is an important skill to have. Internally, layouts manage the available space on a window using some of the following widget properties:\n• contains the smallest size the widget can have while remaining usable\n• holds the default behavior of a widget in a layout Layouts use these properties to automatically position and resize widgets, assigning a given amount of space to each widget according to the available space. This ensures that widgets are consistently arranged and remain usable. In the next three sections, you’ll learn how the different types of layouts manage space in PyQt. Box layouts do a great job when it comes to distributing available space between widgets. However, sometime their default behavior isn’t enough, and you need to manually handle the available space. To help you out in this situation, PyQt provides . This class allows you to add blank space (or empty boxes) to a box layout. Normally, you don’t need to use directly. Instead, you call some of the following methods on your box layout objects:\n• adds a non-stretchable space (or empty box) of fixed size to the layout. must be an integer representing the size of the space in pixels.\n• adds a stretchable space with a minimum size of and a stretch factor to a box layout. must be an integer.\n• inserts a non-stretchable space at position , with size . If is negative, then the space is added at the end of the box layout.\n• inserts a stretchable space at position , with a minimum size of and a stretch factor of . If is negative, then the space is added at the end of the box layout. Stretchable spacers will expand or shrink to fill empty space when the user resizes the underlying window. Non-stretchable spacers will remain the same size regardless of the changes in the size of the underlying window. Go back to the example of how to use vertical layouts and run that application again. If you pull down the border of the window, then you’ll notice that more space appears between the buttons the further down you pull: This happens because the layout handles the newly available space by automatically expanding its boxes. You can change this behavior by adding a stretchable object to the end of the layout. In your example’s code, update the initializer of as follows: # Set the layout on the application's window In the highlighted line, you add a stretchable object to the end of the layout by calling on the layout. If you run the application again, then you’ll get the following behavior: Now all the extra space is automatically assigned to the stretchable object at the bottom of the layout without affecting the position or size of the rest of the widgets. You can use this and other space management techniques to make your GUI applications look good and polished. Grid and form layouts handle available space in a different way. In these types of layouts, you can handle only the vertical and horizontal space between widgets. These layouts provide three methods to manage these spaces:\n• sets both the vertical and the horizontal spacing between widgets to .\n• sets only the vertical spacing between widgets in the layout to .\n• sets only the horizontal spacing between widgets in the layout to . In all cases, is an integer representing pixels. Now go back to the example on how to create a form layout and update the initializer of like this: # Set the layout on the application's window In the highlighted line, you set the vertical space between widgets to pixels. If you run the application again, then you’ll see the following window: Now there’s more space between the rows of widgets. You can also try modifying the example of how to use a grid layout by adding some vertical or horizontal space just to see how all these spacing mechanisms work."
    },
    {
        "link": "https://forum.pythonguis.com/t/i-need-help-with-pyqt5-problem-with-qpushbutton-signal-and-slot/1392",
        "document": "I just starting out with PyQt5, and I am stuck trying to get a button to call a function. I have been learning Python for a couple months and wanted to build a basic GUI app. I followed some tutorials online, but for some reason, clicking the button doesn’t seem to run the function I made.\n\nHere is a stripped-down version of my code, in case it helps:\n\nWhen I run the code, the window appears with the button, but clicking the button does not print “Button clicked!” in the console.\n\nCould someone please help me understand what I am doing wrong? Is there something I am missing about the way signals and slots work in PyQt5?\n\nI also check this: https://forum.pythonguis.com/t/help-with-pyqt5-bitmap-graphics-tutorialqlikview But I have not found any solution. Could anyone guide me about this. And your suggestion will be really grateful."
    }
]