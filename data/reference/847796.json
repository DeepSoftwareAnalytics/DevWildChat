[
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Regular_expressions",
        "document": "A regular expression (regex for short) allow developers to match strings against a pattern, extract submatch information, or simply test if the string conforms to that pattern. Regular expressions are used in many programming languages, and JavaScript's syntax is inspired by Perl. You are encouraged to read the regular expressions guide to get an overview of the available regex syntaxes and how they work.\n\nRegular expressions are a important concept in formal language theory. They are a way to describe a possibly infinite set of character strings (called a language). A regular expression, at its core, needs the following features:\n• A set of characters that can be used in the language, called the alphabet.\n• Concatenation: means \"the character followed by the character \".\n• Kleene star: means \"zero or more characters\". Assuming a finite alphabet (such as the 26 letters of the English alphabet, or the entire Unicode character set), all regular languages can be generated by the features above. Of course, many patterns are very tedious to express this way (such as \"10 digits\" or \"a character that's not a space\"), so JavaScript regular expressions include many shorthands, introduced below. Note: JavaScript regular expressions are in fact not regular, due to the existence of backreferences (regular expressions must have finite states). However, they are still a very useful feature.\n\nFlags are special parameters that can change the way a regular expression is interpreted or the way it interacts with the input text. Each flag corresponds to one accessor property on the object. Makes and match the start and end of each line instead of those of the entire string. An upgrade to the mode with more Unicode features. Perform a \"sticky\" search that matches starting at the current position in the target string. The , , and flags can be enabled or disabled for specific parts of a regex using the modifier syntax. The sections below list all available regex syntaxes, grouped by their syntactic nature."
    },
    {
        "link": "https://w3schools.com/js/js_regexp.asp",
        "document": "A regular expression is a sequence of characters that forms a search pattern.\n\nThe search pattern can be used for text search and text replace operations.\n\nA regular expression is a sequence of characters that forms a search pattern.\n\nWhen you search for data in a text, you can use this search pattern to describe what you are searching for.\n\nA regular expression can be a single character, or a more complicated pattern.\n\nRegular expressions can be used to perform all types of text search and text replace operations.\n\nw3schools is a pattern (to be used in a search).\n\ni is a modifier (modifies the search to be case-insensitive).\n\nIn JavaScript, regular expressions are often used with the two string methods: and .\n\nThe method uses an expression to search for a match, and returns the position of the match.\n\nThe method returns a modified string where the pattern is replaced.\n\nThe method searches a string for a specified value and returns the position of the match:\n\nThe method replaces a specified value with another value in a string:\n\nModifiers can be used to perform case-insensitive more global searches:\n\nBrackets are used to find a range of characters:\n\nIn JavaScript, the RegExp object is a regular expression object with predefined properties and methods.\n\nIt searches a string for a pattern, and returns true or false, depending on the result.\n\nThe following example searches a string for the character \"e\":\n\nIt searches a string for a specified pattern, and returns the found text as an object.\n\nIf no match is found, it returns an empty (null) object.\n\nThe following example searches a string for the character \"e\":\n\nFor a complete reference, go to our Complete JavaScript RegExp Reference.\n\nThe reference contains descriptions and examples of all RegExp properties and methods."
    },
    {
        "link": "https://pdfscripting.com/public/Pattern-Matching-with-Regular-Expressions.cfm",
        "document": "Regular expressions are an ancient and powerful technique for finding patterns in text. They have been tested by the ages and been found to be so useful that practically every computer language in use today provides support for using regular expressions. Of course this includes the Core JavaScript model. In Core JavaScript, regular expressions are a built-in data type and are employed in several of the standard string operations.\n\nWhile regular expressions seem complex (and sometimes are very complex), they can actually be quite simple to build and easy use. Its just a matter of easing in to learning the syntax.\n\nA regular expression is simply a string of characters that represent a text pattern. It is a mixture of both regular text characters and characters with special meaning, enclosed in forward slashes,. These forward slashes are the syntax that indicates (delimits) a Regular Expression. Here's a simple example:\n\nThis regular expression matches the word \"dog.\" The expression does not contain any special characters (only standard-text characters). It is case sensitive and it matches the specified characters verbatim, nothing more and nothing less. It matches them in the order and case in which they are written. It will not match \"Dog\" or \"DOG\" or \"doog.\" Also, it will only match the first occurrence of \"dog\" in the text to which it is applied. For example, the following sentence includes two occurrences of \"dog.\" The regular expression above will find only the first one.\n\n\"My dog smells worse than your dog\"\n\nThe original Regular Expression can be easily modified to be case insensitive and to match all occurrences through the addition of some special characters.\n\nIn the following text, we'll discuss the details of this and many other simple variations that can be made to tailor the base expression to match nearly any criteria that is necessary. The great power of regular expressions is that they are flexible, i.e., they have the ability to match a wide range of strings, from specific words to general patterns. To understand how this is done, we first we need to see how regular expressions are used in JavaScript.\n\nRegular expressions don't have anything to do specifically with Acrobat. They are a feature of Core JavaScript, which means the examples shown here will work in all JavaScript environments.\n\nThere are two ways to create a new regular expression variable: literal notation andobject creation. The two lines of code below create exactly the same object:\n\nnotice that the regular expression variable begins with \"rg\". It can be very helpful to prefix variables with a couple of lower case letters to indicate the data type, so you can quickly identify them. These prefix help to make the code readable.\n\nI find the literal notation much easier and intuitive than the object notation, so all the examples in this article will use the literal notation. Also, the examples are intended to be run in the Acrobat JavaScript Console. This is a vital tool for script development and debugging in Acrobat.\n\nOne of the most common uses of regular expressions in JavaScript is testing a string for the existence of a pattern with thefunction.\n\nTry this code in the JavaScript Console. It will display a popup-alert box because the regular expression finds a match in the text. Keep this script displayed in the console window. It's a useful piece of code for experimenting with expressions. We'll run through several variations on this script using different modifications of both the regular expression and the text.\n\nFor the first variation, change the string to:\n\nEven though both occurrences of \"dog\" have changed, the test will still return true. That's because the first regular expression we defined doesn't care what's in front or behind the pattern. It's just looking for the three letters, exactly how they are written in the expression. To find the individual word \"dog,\" the expression needs to be modified to look for word boundaries.\n\nNow things are starting to look cryptic. That's one of the main characteristics of regular expressions, they can look scary. Remember, regular expressions date to the stone age of computing, but they are not as bad as they look. With a little knowledge writing these expressions will seem easy in just a short time. For example, the \"\\\" character in the expression above is called an escape, and it tells us the next character has a special meaning. The Escape is used a lot. It gives regular characters special meaning and turns special characters into regular characters. The special meaning of the \"\\b\" is to match any non-word character. Things like spaces, new lines, and punctuation.\n\nThe current string and regular expression, as we've just modified them, will fail the test because the word \"dog\" does not exist by itself anywhere in the text. Now let's change the text to:\n\nThis text will pass the test and display the alert because the word \"dog\" is preceded by a space, and followed by a period. The period is a non-word character.\n\nLet's make this more complex. Change the text to capitalize \"Dog.\"\n\nThe test will now fail, because the upper case \"D\" in \"Dog\" does not match the lower case \"d\" used in the regular expression. To make the expression match both \"dog\" and \"Dog\" change it like this:\n\nThis square brackets \"[ ]\" enclose a list of acceptable variations in a single-character match. As many characters can be put in square brackets as needed to cover all variations needed for the match. For example:\n\nBut to get back on track, let's say the match must be completely case insensitive. We don't care which, if any, letters are capitalized. In this case, use:\n\nThe \"i\" following the end of the expression is called an attribute. There are only a few attributes and they are generally for more advanced features. But this one is easy, it makes the match case insensitive. Try it with this text:\n\nFor the next example, we'll change the expression to match an arbitrary number of characters.\n\nThe \"+\" symbol means match one or more occurrences of the preceding thing. In this case, the \"+\" is preceded with the single \"o\" character so it will match \"dog,\" \"doog,\" \"dooog\" or any number of \"o\"s in the word \"dog.\" Try it with this sentence:\n\nRegular Expressions are used in many different ways within the Core JavaScript model, but one of the most useful applications is text replacement. In the following example, the expression replaces the word \"dog\" with the word \"pooch\".\n\nThe replace() function is a member of the String Object, not the Regular Expression Object. The regular expression is the first argument to this function. When this code is run, the resulting string is placed in the variable myNewText. The original string remains unchanged. Try it, and you'll see that only the first occurrence of \"dog\" is replaced. To replace all occurrences the regular expression will need to be modified like this.\n\nNotice the \"g\" attribute added to the expression. It means global, so the pattern is applied globally to the text string.\n\nIt would be impossible to provide a complete reference for using regular expressions here. They are just too rich for one article. Table 1 and 2 below show a short list of commonly used special pattern-matching characters.\n\nThe special characters in Table 2 and the last three in Table 1, as well as other special characters-- like the square brackets and parentheses (which weren't discussed)-- can't be used to match their respective characters in a text string. Because, of course, they are themselves special characters. The way to get around this limitation is to prefix them with the escape character, \"\\.\" Here's an example that matches dollar amounts:\n\nThe dollar sign and the period are both special characters, but in this expression they are Escaped to remove the special meaning so they can be matched. This regular expression matches the dollar sign, followed by one or two digits, followed by the decimal point (i.e., period), followed by two digits. From Table 2 you can see the \"?\" character means match 0 or 1 of the preceding item. In this expression, it means match zero or one digits.\n\nHere are some of regular expressions I use most often in Acrobat and PDF scripts.This RegExp detects a string that contains no text, but may contain some spaces. This is very useful for detecting empty form fields, because a form field that has a couple of spaces in it still looks empty to the user. But if you're script is expecting to detect an empty string, then it will fail. So I always use the following when the script needs to detect an empty field.\n\nThis RegExp looks very cryptic because it is composed entirely of special characters, but it is much simpler than it first appears. The caret symbol, \"^\" matches the beginning of the text and the dollar sign \"$\" matches the end of the text. Using these special characters means the rest of the pattern must match the entire line of text verbatim, i.e. from the beginning to the end. The rest of the pattern is composed of two elements, the \"\\s\" special character and the asterisk \"*\" special character. The \"\\s\" matches any white space. White space is anything you can't actually see but has an effect on the text, such as spaces, tabs, and new lines. The \"*\" symbol means match zero or more occurrences of the preceding thing. So this pattern matches either nothing (an empty string) or a string of blanks.\n\nAgain, users often ignore leading and trailing spaces when they enter data, and scripts will often need a clean string. As such, trimming strings is common feature of many programming languages. It's so common it's surprising that this feature doesn't already exist in Core JavaScript. And in fact, it was added into the latest version, but it's not yet in Acrobat. So if your script needs a clean string with no leading and trailing space, use this RegExp to remove it.\n\nThis is another very cryptic looking RegExp. It is quite similar to the rgEmpty, but with a couple of features we haven't seen yet, the parentheses and the vertical bar. As you might have already guessed, the parentheses are used for grouping a sub-pattern. The vertical bar is an OR symbol. It matches either of the pattern elements. So this pattern can be read as \"Match either white space at the beginning of the string, or white space at the end of the string\". The recplace() function replaces these matches with an empty string.\n\nThere are many scenarios in advanced scripting where it is necessary to extract a sub-string out of some text. The scenario I run into most often is writing table calculation scripts. For example, an order form with many item lines, where the total on each line is calculated exactly the same way, but with different form fields.\n\nTo create an efficient and robust solution I name the fields using a pattern, and then write a document level function that will work for any line where the fields use that pattern. An example field naming pattern is \"Price_Row1\", \"Quantity_Row1\", \"Total_Row1\". The calculation script is in the total field, so the script needs to extract the row number from the total field name and then use it to built the field names used in the calculation. A quick way to do this is with a regular expression.\n\nThis RegExp doesn't use any features you haven't seen so far, but it does use the parentheses in a new way. Parentheses don't just group sub-patterns, they also mark the sub-pattern for extraction. The extracted pattern is then temporarily available in the RegExp object. RegExp.$1 is the first sub-pattern, RegExp.$2 is the second sub-pattern, etc. The sub-pattern here matches \"one or two digits\".\n\nThere are several ways to go about extracting data from a string. Developers who don't understand regular expressions will often use various string operators such as split, indexOf, substr and other basic string functions. There are situations where this approach is the right one, but there are a couple of huge benefits to using regular expressions. The first is that a complex data pattern can be identified and extracted in one line of code. But the second is instant validation that the string contains the desired pattern, providing an easy way to show an error message, switch to an alternate process, or just ignore anything that doesn't fit. It the code here, the \"if\" block allows us to safely ignore the misuse of this function in a field that does not follow the pattern.\n\nI often write automation scripts where the current document is modified and then stored with a modified name in the same location, or some variation on this theme. An easy way to create the new name is with a regular expression string replacement.\n\nThis is the most complex expression yet and introduces a couple of new items. The goal of this regular expression is to identify the complete file name for replacement. It does this by looking for all text in between the last \"/\" file path separator and \".pdf\".\n\nThe regular expression starts with \"\\/\", the escaped forward slash. To ensure it is the last slash in the file path that is matched, the next pattern is \"[^\\/]\", which matches anything that is not a forward slash. Remember the square brackets group a set of characters for matching. The \"^\" (carrot) symbol inverts the meaning of the square brackets and matches anything that is not in the brackets. The expression ends with \"\\.pdf$\", which anchors the match at the end of the file path. Notice that \"\\.pdf$\" is inside of a special type of grouping we haven't seen yet.\n\nThe \"(?= ...)\" structure is called a positive lookahead. The pattern in the lookahead grouping is required for the match, but it is not part of the match, so it also isn't part of the replacement. This can be a big help in crafting complex replacement strategies. It's not really necessary here because we know the file ends with \".pdf\", which is easy to just include in the replacement text. Unfortunately, there is no equivalent lookbehind in Acrobat JavaScript, so the slash does have to be included in the replacement text.\n\nWhat is shown in this article represents the simplest and most common usage of the regular expression. There is much, much more. For instance, thefunction can be used to find and extract multiple substrings from a piece of text. Theandfunctions use regular expressions as input to do advanced searches and string splitting. You'll find more information on these functions in any JavaScript reference.\n\nThe official Core JavaScript web reference is here: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions\n\nThere are entire books covering the subject of regular expressions and there's a vast library of information available on the web. Just do a search for \"Regular Expression.\" One of the best sites is this one:\n\nBoth of these sites have a library of cut-and-paste regular expressions for all kinds of common tasks (such as validating a telephone or social security number), as well as tools for building and testing regular expressions."
    },
    {
        "link": "https://freecodecamp.org/news/regex-in-javascript",
        "document": "Regular expressions, also known as regex, are powerful tools for pattern matching and text manipulation. Whether you're validating user input, extracting data from strings, or performing advanced text processing tasks, understanding regex is essential for developers.\n\nThis comprehensive guide will walk you through the fundamentals of regular expressions in JavaScript, including how to create and use them, their special characters, flags, and practical examples.\n\nWhile this tutorial is designed to be beginner-friendly, having a basic understanding of JavaScript fundamentals will be beneficial. Familiarity with variables, data types, functions, and string manipulation in JavaScript will help you grasp the concepts covered.\n• What are Regex?\n\n– How to Write Regular Expression Patterns\n• How to Use Regular Expressions in JavaScript\n\n– RegEx Methods in JavaScript\n\n– Advanced Searching with Flags\n• Practical Examples and Use Cases of Regex\n\n– Password Strength Checking\n\n– Email Validation\n\n– Phone Number Formatting\n\nA regular expression, often abbreviated as \"regex,\" is a sequence of characters that define a search pattern. This pattern is used to find matches within strings, helping you identify specific text or patterns of characters, providing a powerful way to search, replace, and manipulate text.\n\nIn JavaScript, you can create regular expressions using either a literal notation or the constructor:\n• Using a Regular Expression Literal: This involves enclosing the pattern between slashes (\"/\").\n• Using the Constructor Function: constructor. This allows runtime compilation of the regular expression and is useful when the pattern may change.\n\nBoth methods produce the same result – it's a matter of preference which one you choose.\n\nA regular expression pattern can consist of simple characters or a combination of simple and special characters.\n• Simple Pattern: They match exact character sequences. For example, the pattern matches the sequence \"abc\" in a string.\n• Special Characters: They enhance pattern matching with capabilities like repetition or matching specific types of characters, allowing for more flexible and powerful pattern matching. For example, matches zero or more occurrences of the preceding item. matches \"ac\", \"abc\", \"abbc\", and so on.\n\nHow to Use Regular Expressions in JavaScript\n\nYou can use regular expressions with various methods available for both the and objects in JavaScript. Some methods like , , and others have this syntax:\n\nWhile some methods like , , and so on have this syntax:\n\nHere, is the string and is a regular expression pattern.\n\nLet's explore how these methods are used in practice.\n\nThe Method: checks whether a particular string matches a specified pattern or regular expression. It returns if the pattern is found in the string, otherwise, it returns .\n\nThe Method: searches for a match of a pattern within a string. It returns an array containing details like the matched text, index of the match within the string, and the input string itself. Example:\n\nThe Method: Searches for occurrences of a pattern within a string. It returns the first element matched. If has the global flag ( ), it returns an array containing all matches found, or if no matches are found.\n\nThe Method: Returns an iterator of all results matching a regular expression against a string. Each element of the iterator is an array containing details about the match, including captured groups.\n\nThis method is useful when you need detailed information about all matches found in a string.\n\nThe Method: Searches for a specified pattern within a string. It returns the index of the first occurrence of the pattern within the string, or if the pattern is not found.\n\nThe Method: Replaces the first occurrence of a specified pattern in a string with another substring or value. To replace all occurrences, you can use the global flag ( ) in the regular expression.\n\nThe Method: Replaces all occurrences of a specified substring or pattern with a replacement string. It differs from in that it replaces all occurrences by default, without the need for a global flag ( ).\n\nThis method simplifies the process of replacing all occurrences of a substring within a string.\n\nThe Method: Though not exclusively a RegEx method, can accept a RegEx pattern as its argument to split a string into an array of substrings based on the specified patterns or delimiters. For instance:\n\nThese methods offer different functionalities based on your needs. For example, if you only need to know whether a pattern is found in a string, or methods are efficient. If you require more information about matches, the or methods are suitable.\n\nIn JavaScript, regular expressions support pattern flags, which are optional parameters that modify the behavior of the pattern matching.\n\nLet's delve into two common flags: the ignore flag ( ) and the global flag ( ).\n\nThe ignore flag ( ) instructs the regular expression to ignore case sensitivity when searching for matches. For example:\n\nIn this case, the regular expression matches the string despite differences in case because we used the ignore flag.\n\nThe global flag ( ) allows the regular expression to find all matches within a string, rather than stopping after the first match. For example:\n\nIn this example, the regular expression finds both occurrences of in the string \"hi there, hi again!\" .\n\nYou can combine flags to achieve specific matching behavior. For instance, using both the ignore flag ( ) and the global flag ( ) together allows for case-insensitive matching while finding all occurrences of the pattern.\n\nHere, the regular expression matches both and in the string \"Hi there, HI again!\" .\n\nThough not commonly used, the flag handles Unicode characters, especially surrogate pairs, correctly. Surrogate pairs are used to represent characters outside the Basic Multilingual Plane (BMP) in UTF-16 encoding.\n\nExample: Let's consider a string containing emoji characters and try to match them using a regular expression without and with the flag.\n\nWithout the flag, the regex fails to match the emoji correctly because they are represented as surrogate pairs in UTF-16 encoding. However, with the flag, it correctly matches the emoji .\n\nAnchors are special characters in regex that do not represent actual characters but instead indicate positions within a string. There are two main anchors: and .\n\nThe Anchor: The anchor matches the beginning of the text. Basically, it checks if a string starts with a specific character or pattern.\n\nThe Anchor: The anchor matches the end of the text. It checks if a string ends with a specific character or pattern.\n\nYou may often use and together to check if a string fully matches a pattern.\n• In the code above, ensures that the string contains exactly two digits, followed by a colon, and then exactly two more digits.\n\nBy default, the and anchors in regular expressions operate in single-line mode, meaning they match the beginning and end of the entire string. But in some cases, you might want to match the beginning and end of individual lines within a multiline string. This is where the multiline mode, indicated by the flag, comes into play.\n\nSince single-line mode is the default, it only matches the first digit \"1\" at the beginning of the string.\n• multiline mode(m): is the regex pattern with the flag enabled. By utilizing the flag, you can ensure that and match the beginning and end of individual lines within a multiline string, rather than just the entire string itself.\n\nAs a result, it matches \"1\" from the first line, \"2\" from the second line, and \"3\" from the third line:\n\nThis is particularly useful when working with text that contains multiple lines or line breaks.\n\nThe is a special character in regular expressions called an anchor, just like and . It's used to match a position in the string where a word character (such as a letter, digit, or underscore) is not followed or preceded by another word character. For instance:\n• matches the word \"word\" in the string, but not substrings like \"wording\" or \"swordfish\".\n\nmatches the substring \"word\" anywhere within the string. It matches \"word\" in \"This is wording.\" because it doesn't include any word boundary assertions.\n\nOther examples can be:\n• matches whole numbers in the string, but doesn't include non-numeric characters adjacent to the numbers.\n• matches a string that consists solely of the word \"word\".\n\nIn regex, quantifiers enable you to specify the quantity of characters or character classes you want to match within a string. They are symbols or characters that define how many instances of a character or group you're looking for.\n\nThe simplest quantifier is , which specifies an exact count of characters or character classes you want to match. Let's say we have a string \"Year: 2022\" and we want to extract the year from it:\n\nThe range quantifier matches a character or character class from n to m times, inclusively. Example:\n\nThe quantifier matches a character or character class at least n times. Additionally, there are shorthand notations for common quantifiers. Example:\n\nThe quantifiers , , and are shorthand notations for common use cases. Let's use the shorthand to match one or more digits in a phone number:\n\nQuantifiers: Zero or One ( ):\n\nThe quantifier in regular expressions means zero or one occurrence of the preceding character or group. It's equivalent to {0,1}. Example:\n\nIn this example, the regular expression matches both \"color\" and \"colour\" in the given string, allowing for zero or one occurrence of the letter \"u\".\n\nQuantifiers: Zero or More ( ):\n\nThe quantifier in regular expressions means zero or more occurrences of the preceding character or group. It's equivalent to {0,}. Example:\n\nIn regular expressions, quantifiers determine how many times a particular element can occur in a match.\n\nBy default, quantifiers operate in what's called a \"greedy\" mode. This means they try to match as much of the preceding element as possible. For instance:\n\nInstead of finding two separate matches (\"Boy\" and \"Friends\"), it finds one match encompassing both (\"Boy\" and his \"Friends\").\n\nTo understand why the initial attempt failed, let's delve into how the regular expression engine conducts its search.\n• The engine starts from the beginning of the string and finds the opening quote.\n• It proceeds to match characters following the opening quote. Since the pattern is , where matches any character and quantifies it to match one or more times, the engine continues matching characters until it reaches the end of the string.\n• The engine then backtracks to find the end quote that would complete the match. It starts by assuming the maximum possible characters matched by and gradually reduces the number of characters until it finds a valid match.\n• Eventually, the engine finds a match encompassing the entire substring \"Boy\" and his \"Friends\".\n\nThis behavior of greedily matching as many characters as possible is the default mode of quantifiers in regular expressions and doesn't always yield the desired results. You can see this in the example where it results in a single match instead of multiple separate matches for quoted strings.\n\nTo address the limitations of greedy mode, regular expressions also support a lazy mode for quantifiers. In lazy mode, quantified characters are repeated the minimal number of times necessary to satisfy the pattern.\n\nWe can enable the lazy mode by appending a question mark after the quantifier. For example, or denotes lazy repetition.\n\nIn this example, the lazy quantifier ensures that each quoted string is matched separately by minimizing the number of characters matched between the opening and closing quotes.\n\nLet's trace the search process step by step to understand how the lazy quantifier works:\n• The engine starts from the beginning of string and finds the opening quote.\n• Instead of greedily matching all characters until the end of the string, the lazy quantifier matches only the characters necessary to satisfy the pattern. It stops as soon as it encounters the closing quote .\n• The engine repeats this process for each quoted string in the text, resulting in separate matches for \"Boy\" and \"Friends\".\n\nIn regular expressions, you use sets and ranges to match specific characters or a range of characters within a given pattern.\n\nA set is defined using square brackets . It allows you to match any character within the set. For example, matches any of the vowels 'a', 'e', 'i', 'o', or 'u'.\n\nExample: Suppose we have a string 'The quick brown fox jumps over the lazy dog.' . To match all vowels in this string, we can use the regular expression .\n\nHere, the RegEx matches words that start with either 'c', or 'r' and are followed by 'at'.\n\nRanges allow you to specify a range of characters within a set. For example, matches any lowercase letter from 'a' to 'z', and matches any digit from '0' to '9'. Example:\n\nTo exclude certain characters from a set, you can use the symbol inside the square brackets. Example:\n\nSimilarly will match any character that is not a lowercase letter:\n\nSome character classes have predefined shorthand notations for common ranges of characters.\n\nclass: It matches any digit character, equivalent to the range . Example:\n\nWe used the and methods to format the phone number. This approach simplifies the process of formatting and cleaning up data, making it suitable for various text processing applications.\n\nSimilarly, matches a single whitespace character, including spaces, tabs, and newline characters, and matches any word character (alphanumeric character or underscore), equivalent to the range .\n\nCombining these classes allows for more flexible and precise pattern matching, enabling a wide range of text processing tasks. Example:\n\nThese predefined character classes provide convenient shortcuts for commonly used character ranges.\n\nInverse classes, denoted by uppercase letters (for example, ), match any character not included in the corresponding lowercase class. This provides a convenient way to match characters outside specific sets, such as non-digit characters, non-whitespace characters, or non-word characters. Example:\n\nMetacharacters are characters that have special meanings in Regular Expressions and are used to construct patterns for matching text.\n\nAnchors ( and ), Alternation( ), quantifiers ( , , ), and predefined character classes ( , , ) are all considered metacharacters, each serving distinct purposes in pattern definition. We also have a few more, which we'll cover now.\n\nDot ( ) is a metacharacter with a special meaning. It's used to match any single character except newline characters ( ). It serves as a wildcard, allowing for flexible pattern matching when the exact character is unknown or irrelevant.\n\nIf you need the dot to match newline characters as well, you can use the flag in JavaScript, which enables the \"single line\" mode, making the dot match any character including newline characters. Example:\n\nThe dot ( ) can be combined with other regex elements to form more complex patterns. For example, matches any three-character sequence ending with 'at', such as 'cat', 'bat', or 'hat'.\n\nEscaping special characters is essential when you want to search for or match these characters in input strings without invoking their special regex meanings.\n\nTo match a special character literally in a regex pattern, you need to escape it by preceding it with a backslash (). This tells the regex engine to treat the special character as a regular character. Example:\n\nFun fact: the we use to escape metacharacters is itself a metacharacter and can be escaped with another backslash as .\n\nIn JavaScript regular expressions, capturing groups are used to extract specific parts of a matched string. Imagine you have a path like \"resource/id\", for instance, \"posts/123\". To match this path, you can use a regular expression like .\n• matches one or more word characters.\n• matches one or more digits.\n\nLet's say you have a path like \"posts/123\" and you want to capture the part (123). We can use capturing groups for this.\n\nTo create a capturing group, you enclose the part of the regex pattern you want to capture in parentheses. For example, captures one or more digits.\n\nHere, is captured by the capturing group .\n\nUsing Multiple Capturing Groups: You can have multiple capturing groups in a regex pattern. For example, to capture both the resource (like \"posts\") and the id (like \"123\") from the path \"posts/123\", you can use .\n\nHere, and 123 are captured by the two capturing groups and respectively.\n\nNamed Capturing Groups allow you to assign names to capturing groups, which makes it easier to reference them later in your code.\n\nThe syntax for named capturing groups is , where:\n• specifies the name of the capturing group.\n• is a rule in the pattern.\n\nFor example, suppose we want to capture the resource (like \"posts\") and the id (like \"123\") from the path \"posts/123\" using named capturing groups.\n\nHere, and are the names assigned to the capturing groups. We can access them using .\n\nAnother Example: Let's say we have a path like \"posts/2022/02/18\" and we want to capture the resource (like \"posts\"), year (like \"2022\"), month (like \"02\"), and day (like \"18\") using named capturing groups.\n\nThe regex pattern for this would be:\n\nHere, each part of the path is captured using named capturing groups, making it easy to access them by their respective names.\n\nIn regular expressions, non-capturing groups are used to group parts of a pattern together for applying quantifiers or alternation, without capturing the matched substring.\n\nTo create a non-capturing group, you add at the beginning of the parentheses. So, is the non-capturing version of the previous example. The tells the regex engine not to capture the matched substring.\n\nLet's see the difference between capturing and non-capturing groups with an example:\n\nIn summary, non-capturing groups behave like regular capturing groups in terms of matching patterns, but they don't store the matched text in memory for later retrieval. This makes them useful when you don't need to extract specific parts of the matched text.\n\nBackreferences enable you to refer to previously captured groups within a regular expression. Think of them as variables that store matched patterns.\n\nIn JavaScript, the syntax for a backreference is , where is an integer representing the capturing group number.\n\nFor instance, consider a string with a duplicate word \"Lion\" and we want to remove the duplicate word to get :\n• First, we match a word using .\n• Then, we create a capturing group to capture the word using .\n• Next, we use a backreference ( ) to reference the first capturing group.\n• Finally, we replace the entire match with the first capturing group using .\n\nRegex alternation is a feature that allows you to match different patterns within a single regular expression. It works similarly to the logical OR operator. In regex, you use the pipe symbol to denote alternation, where you can match either A or B.\n\nNow, let's explore some practical applications of regex alternation:\n\nMatching Time String in the hh:mm Format: Suppose we want to match time strings in the format hh:mm, where hh represents hours and mm represents minutes. A basic regular expression to match this format would be .\n\nHowever, this basic pattern matches invalid times like \"99:99\". To ensure we match valid times (hours ranging from 00 to 23 and minutes ranging from 00 to 59), we need to refine our regex using alternation.\n\nTo match valid hours (00 to 23), we can use the following pattern:\n\nSo, the pattern for hours becomes .\n\nTo match valid minutes (00 to 59), we can use the pattern .\n\nNow, we can combine the hour and minute patterns using alternation to get the final regex pattern:\n\nThis regex pattern ensures that we only match valid time strings in the format. Example:\n\nLookahead in regular expressions allows matching a pattern (X) only if it's followed by another specific pattern (Y). The syntax is , where:\n• X is the pattern you want to match.\n• (?=Y) is the lookahead assertion indicating that should be followed by .\n\nExample: Let's say we have a string describing various distances, and we want to identify numbers followed by the units \"miles\" but not \"kilometers\". We can use lookahead in a regex pattern:\n\nMultiple Lookaheads: It's possible to have multiple lookaheads in a regular expression using the syntax . This allows us to impose multiple conditions for matching.\n\nExample: Let's say we want to match strings that contain both \"foo\" and \"bar\", but in any order:\n\nTo negate a lookahead, use a negative lookahead with the syntax , where the regex engine matches X only if it is not followed by Y.\n\nExample: Suppose we want to match numbers but not if they are followed by \"miles\":\n\nLookbehinds provide a way to match patterns based on what precedes them, essentially matching an element if there is another specific element before it.\n\nExample: Suppose we have a string containing prices, and we want to match numbers preceded by the currency symbol \"$\" but not preceded by \"€\". We can use a lookbehind in a regex pattern\n\nExplaination: matches an element if there is a literal string \"$\" before it. The backslash is used to escape the special character \"$\", treating it as a literal character.\n\nNegative lookbehinds allow you to match a pattern only if it is not preceded by a specific pattern. This is useful for excluding certain patterns from matches based on what precedes them.\n\nExample: Suppose we have a string containing various prices in different currencies, and we want to match the numbers not preceded by the currency symbol \"$\". We can use a negative lookbehind in a regex pattern:\n\nExplanation: is the negative lookbehind syntax, which matches the following pattern only if it is not preceded by the literal string \"$\".\n\nPractical Examples and Use Cases of Regex\n\nNow, Let's explore some practical examples of using regular expressions in JavaScript applications to solve common problems and perform text manipulation tasks.\n\nYou can use regular expressions to enforce password strength requirements, such as minimum length and the presence of special characters.\n\nHere's what this pattern does:\n• : Requires at least one digit.\n• : Requires at least one lowercase letter.\n• : Requires at least one uppercase letter.\n• : Requires at least one special character.\n\nEmail validation is crucial for ensuring data integrity and security in web applications. With regex methods, we can easily implement robust email validation mechanisms.\n\nHere's what this pattern does:\n• : Asserts the start of the string.\n• : Matches one or more characters that are not whitespace or '@'.\n• : Matches one or more characters that are not whitespace or '@'.\n• : Matches the '.' symbol (escaped because '.' has a special meaning in RegEx).\n• : Matches one or more characters that are not whitespace or '@'.\n• : Asserts the end of the string.\n\nPhone number formatting enhances user experience and readability in applications that involve phone number input and display.\n\nBy defining a regex pattern that matches phone number components, we can easily format phone numbers into a desired pattern using the method.\n\nIn the method, , , and represent the captured groups in the RegEx pattern, corresponding to the three sets of digits in the phone number.\n\nTips and Best Practices for Using Regular Expressions\n\nUnderstand the syntax and metacharacters of regular expressions for effective usage.\n\nRegular expressions can sometimes behave unexpectedly due to complex patterns or special characters. Always test your regular expressions with different input strings to ensure they behave as expected in various scenarios.\n\nConsider optimizing your regular expressions for performance by simplifying patterns or using more efficient alternatives where possible.\n\nJavaScript provides built-in methods like , , and for common string manipulation tasks. Evaluate whether these methods can accomplish your task without the need for regular expressions.\n\nAdd comments within your regex using syntax to explain explain parts of complex patterns. Example:\n\nIf your regular expression becomes too complex to understand or maintain, consider breaking it down into smaller, more manageable parts. Use variables to store individual components of the pattern and combine them as needed.\n\n7. Use Online Resources and Keep on Practicing:\n\nThere are several online resources and tools available for testing and learning regular expressions. Websites like Regex101 and RegExr provide interactive platforms to test and debug regular expressions. Also leverage online tutorials and documentation to learn regex concepts.\n\nThe MDN Web Docs have a helpful guide to Regular Expressions here. And here's a quick start guide to regular expressions in JavaScript: RegExp Tutorial.\n\nRegular expressions are versatile tools for pattern matching and manipulation in JavaScript.\n\nBy understanding their methods, advanced features, and usage with flags, leveraging online resources and debugging tools, you can effectively learn and apply them in various scenarios, from simple pattern matching to complex text processing tasks."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp",
        "document": "This feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015 . * Some parts of this feature may have varying levels of support.\n\nThere are two ways to create a object: a literal notation and a constructor.\n• The literal notation takes a pattern between two slashes, followed by optional flags, after the second slash.\n• The constructor function takes either a string or a object as its first parameter and a string of optional flags as its second parameter. The following three expressions create the same regular expression object: const re = /ab+c/i; // literal notation // OR const re = new RegExp(\"ab+c\", \"i\"); // constructor with string pattern as first argument // OR const re = new RegExp(/ab+c/, \"i\"); // constructor with regular expression literal as first argument Before regular expressions can be used, they have to be compiled. This process allows them to perform matches more efficiently. More about the process can be found in dotnet docs. The literal notation results in compilation of the regular expression when the expression is evaluated. On the other hand, the constructor of the object, , results in runtime compilation of the regular expression. Use a string as the first argument to the constructor when you want to build the regular expression from dynamic input.\n\nThe expression will create a new using the source of the first parameter and the flags provided by the second. When using the constructor function, the normal string escape rules (preceding special characters with when included in a string) are necessary. For example, the following are equivalent:\n\nNote: Whether something is a \"regex\" can be duck-typed. It doesn't have to be a ! Some built-in methods would treat regexes specially. They decide whether is a regex through multiple steps:\n• must be an object (not a primitive).\n• If is not , check if it's truthy.\n• Otherwise, if is , check if had been created with the constructor. (This step should rarely happen, since if is a object that have not been tampered with, it should have a property.) Note that in most cases, it would go through the check, which means:\n• An actual object whose property's value is falsy but not (even with everything else intact, like and ) can be used as if it's not a regex.\n• A non- object with a property will be treated as if it's a regex. This choice was made because is the most indicative property that something is intended to be used for matching. ( could also be used, but because it's not a symbol property, there would be too many false positives.) The places that treat regexes specially include:\n• , , and throw a if the first argument is a regex.\n• and check whether the global flag is set if the first argument is a regex before invoking its or method.\n• The constructor directly returns the argument only if is a regex (among a few other conditions). If is a regex, it would also interrogate 's and properties instead of coercing to a string. For example, would coerce all inputs to strings, but it would throw if the argument is a regex, because it's only designed to match strings, and using a regex is likely a developer mistake. \"foobar\".endsWith({ toString: () => \"bar\" }); // true \"foobar\".endsWith(/bar/); // TypeError: First argument to String.prototype.endsWith must not be a regular expression You can get around the check by setting to a falsy value that's not . This would mean that the regex cannot be used for (since without , would construct a new object with the two enclosing slashes added by ), but it can be used for virtually everything else.\n\nThese properties are defined on and shared by all instances. The constructor function that created the instance object. For instances, the initial value is the constructor. Whether matches newlines or not. A string that contains the flags of the object. Whether to test the regular expression against all possible matches in a string, or only against the first. Whether the regular expression result exposes the start and end indices of captured substrings. Whether to ignore case while attempting a match in a string. Whether or not to search in strings across multiple lines. Whether or not the search is sticky. Whether or not Unicode features are enabled. Whether or not the flag, an upgrade to the mode, is enabled. These properties are own properties of each instance. The index at which to start the next match."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_expressions",
        "document": "You construct a regular expression in one of two ways:\n• Using a regular expression literal, which consists of a pattern enclosed between slashes, as follows: Regular expression literals provide compilation of the regular expression when the script is loaded. If the regular expression remains constant, using this can improve performance.\n• Or calling the constructor function of the object, as follows: Using the constructor function provides runtime compilation of the regular expression. Use the constructor function when you know the regular expression pattern will be changing, or you don't know the pattern and are getting it from another source, such as user input.\n\nWhen the search for a match requires something more than a direct match, such as finding one or more b's, or finding white space, you can include special characters in the pattern. For example, to match a single followed by zero or more s followed by , you'd use the pattern : the after means \"0 or more occurrences of the preceding item.\" In the string , this pattern will match the substring . The following pages provide lists of the different special characters that fit into each category, along with descriptions and examples. Assertions include boundaries, which indicate the beginnings and endings of lines and words, and other patterns indicating in some way that a match is possible (including look-ahead, look-behind, and conditional expressions). Distinguish different types of characters. For example, distinguishing between letters and digits. Groups group multiple patterns as a whole, and capturing groups provide extra submatch information when using a regular expression pattern to match against a string. Backreferences refer to a previously captured group in the same regular expression. Indicate numbers of characters or expressions to match. If you want to look at all the special characters that can be used in regular expressions in a single table, see the following: Note: A larger cheat sheet is also available (only aggregating parts of those individual articles).\n\nIf you need to use any of the special characters literally (actually searching for a , for instance), you must escape it by putting a backslash in front of it. For instance, to search for followed by followed by , you'd use — the backslash \"escapes\" the , making it literal instead of special. Similarly, if you're writing a regular expression literal and need to match a slash (\"/\"), you need to escape that (otherwise, it terminates the pattern). For instance, to search for the string \"/example/\" followed by one or more alphabetic characters, you'd use —the backslashes before each slash make them literal. To match a literal backslash, you need to escape the backslash. For instance, to match the string \"C:\\\" where \"C\" can be any letter, you'd use — the first backslash escapes the one after it, so the expression searches for a single literal backslash. If using the constructor with a string literal, remember that the backslash is an escape in string literals, so to use it in the regular expression, you need to escape it at the string literal level. and create the same expression, which searches for \"a\" followed by a literal \"*\" followed by \"b\". The function returns a new string where all special characters in regex syntax are escaped. This allows you to do to create a regular expression that matches only the string .\n\nRegular expressions are used with the methods and and with the methods , , , , , and . Executes a search for a match in a string. It returns an array of information or on a mismatch. Tests for a match in a string. It returns or . Returns an array containing all of the matches, including capturing groups, or if no match is found. Returns an iterator containing all of the matches, including capturing groups. Tests for a match in a string. It returns the index of the match, or if the search fails. Executes a search for a match in a string, and replaces the matched substring with a replacement substring. Executes a search for all matches in a string, and replaces the matched substrings with a replacement substring. Uses a regular expression or a fixed string to break a string into an array of substrings. When you want to know whether a pattern is found in a string, use the or methods; for more information (but slower execution) use the or methods. If you use or and if the match succeeds, these methods return an array and update properties of the associated regular expression object and also of the predefined regular expression object, . If the match fails, the method returns (which coerces to ). In the following example, the script uses the method to find a match in a string. If you do not need to access the properties of the regular expression, an alternative way of creating is with this script: const myArray = /d(b+)d/g.exec(\"cdbbdbsbz\"); // similar to 'cdbbdbsbz'.match(/d(b+)d/g); however, // 'cdbbdbsbz'.match(/d(b+)d/g) outputs [ \"dbbd\" ] // while /d(b+)d/g.exec('cdbbdbsbz') outputs [ 'dbbd', 'bb', index: 1, input: 'cdbbdbsbz' ] If you want to construct the regular expression from a string, yet another alternative is this script: With these scripts, the match succeeds and returns the array and updates the properties shown in the following table. In this example The matched string and all remembered substrings. The 0-based index of the match in the input string. The index at which to start the next match. (This property is set only if the regular expression uses the g option, described in Advanced Searching With Flags.) The text of the pattern. Updated at the time that the regular expression is created, not executed. As shown in the second form of this example, you can use a regular expression created with an object initializer without assigning it to a variable. If you do, however, every occurrence is a new regular expression. For this reason, if you use this form without assigning it to a variable, you cannot subsequently access the properties of that regular expression. For example, assume you have this script: const myRe = /d(b+)d/g; const myArray = myRe.exec(\"cdbbdbsbz\"); console.log(`The value of lastIndex is ${myRe.lastIndex}`); // \"The value of lastIndex is 5\" However, if you have this script: const myArray = /d(b+)d/g.exec(\"cdbbdbsbz\"); console.log(`The value of lastIndex is ${/d(b+)d/g.lastIndex}`); // \"The value of lastIndex is 0\" The occurrences of in the two statements are different regular expression objects and hence have different values for their property. If you need to access the properties of a regular expression created with an object initializer, you should first assign it to a variable.\n\nRegular expressions have optional flags that allow for functionality like global searching and case-insensitive searching. These flags can be used separately or together in any order, and are included as part of the regular expression. Makes and match the start and end of each line instead of those of the entire string. An upgrade to the mode with more Unicode features. Perform a \"sticky\" search that matches starting at the current position in the target string. To include a flag with the regular expression, use this syntax: Note that the flags are an integral part of a regular expression. They cannot be added or removed later. For example, creates a regular expression that looks for one or more characters followed by a space, and it looks for this combination throughout the string. You could replace the line: The flag is used to specify that a multiline input string should be treated as multiple lines. If the flag is used, and match at the start or end of any line within the input string instead of the start or end of the entire string. The , , and flags can be enabled or disabled for specific parts of a regex using the modifier syntax. Using the global search flag with exec() method with the flag returns each match and its position iteratively. In contrast, method returns all matches at once, but without their position. The flag is used to create \"unicode\" regular expressions; that is, regular expressions which support matching against unicode text. An important feature that's enabled in unicode mode is Unicode property escapes. For example, the following regular expression might be used to match against an arbitrary unicode \"word\": Unicode regular expressions have different execution behavior as well. contains more explanation about this."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/search",
        "document": "The implementation of doesn't do much other than calling the method of the argument with the string as the first parameter. The actual implementation comes from .\n\nThe flag of has no effect on the result, and the search always happens as if the regex's is 0. For more information on the behavior of , see .\n\nWhen you want to know whether a pattern is found, and also know its index within a string, use .\n• If you only want to know if it exists, use the method, which returns a boolean.\n• If you need the content of the matched text, use or ."
    },
    {
        "link": "https://w3schools.com/js/js_regexp.asp",
        "document": "A regular expression is a sequence of characters that forms a search pattern.\n\nThe search pattern can be used for text search and text replace operations.\n\nA regular expression is a sequence of characters that forms a search pattern.\n\nWhen you search for data in a text, you can use this search pattern to describe what you are searching for.\n\nA regular expression can be a single character, or a more complicated pattern.\n\nRegular expressions can be used to perform all types of text search and text replace operations.\n\nw3schools is a pattern (to be used in a search).\n\ni is a modifier (modifies the search to be case-insensitive).\n\nIn JavaScript, regular expressions are often used with the two string methods: and .\n\nThe method uses an expression to search for a match, and returns the position of the match.\n\nThe method returns a modified string where the pattern is replaced.\n\nThe method searches a string for a specified value and returns the position of the match:\n\nThe method replaces a specified value with another value in a string:\n\nModifiers can be used to perform case-insensitive more global searches:\n\nBrackets are used to find a range of characters:\n\nIn JavaScript, the RegExp object is a regular expression object with predefined properties and methods.\n\nIt searches a string for a pattern, and returns true or false, depending on the result.\n\nThe following example searches a string for the character \"e\":\n\nIt searches a string for a specified pattern, and returns the found text as an object.\n\nIf no match is found, it returns an empty (null) object.\n\nThe following example searches a string for the character \"e\":\n\nFor a complete reference, go to our Complete JavaScript RegExp Reference.\n\nThe reference contains descriptions and examples of all RegExp properties and methods."
    },
    {
        "link": "https://javascript.info/regexp-methods",
        "document": "In this article we’ll cover various methods that work with regexps in-depth.\n\nThe method finds matches for in the string .\n• If the doesn’t have flag , then it returns the first match as an array with capturing groups and properties (position of the match), (input string, equals ): let str = \"I love JavaScript\"; let result = str.match(/Java(Script)/); alert( result[0] ); // JavaScript (full match) alert( result[1] ); // Script (first capturing group) alert( result.length ); // 2 // Additional information: alert( result.index ); // 7 (match position) alert( result.input ); // I love JavaScript (source string)\n• If the has flag , then it returns an array of all matches as strings, without capturing groups and other details.\n• If there are no matches, no matter if there’s flag or not, is returned. That’s an important nuance. If there are no matches, we don’t get an empty array, but . It’s easy to make a mistake forgetting about it, e.g.: let str = \"I love JavaScript\"; let result = str.match(/HTML/); alert(result); // null alert(result.length); // Error: Cannot read property 'length' of null If we want the result to be an array, we can write like this:\n\nThe method is a “newer, improved” variant of .\n\nIt’s used mainly to search for all matches with all groups.\n\nThere are 3 differences from :\n• It returns an iterable object with matches instead of an array. We can make a regular array from it using .\n• Every match is returned as an array with capturing groups (the same format as without flag ).\n• If there are no results, it returns an empty iterable object instead of .\n\nIf we use to loop over matches, then we don’t need any more.\n\nSplits the string using the regexp (or a substring) as a delimiter.\n\nWe can use with strings, like this:\n\nBut we can split by a regular expression, the same way:\n\nThe method returns the position of the first match or if none found:\n\nThe important limitation: only finds the first match.\n\nIf we need positions of further matches, we should use other means, such as finding them all with .\n\nThis is a generic method for searching and replacing, one of most useful ones. The swiss army knife for searching and replacing.\n\nWe can use it without regexps, to search and replace a substring:\n\nWhen the first argument of is a string, it only replaces the first match.\n\nYou can see that in the example above: only the first is replaced by .\n\nTo find all hyphens, we need to use not the string , but a regexp , with the obligatory flag:\n\nThe second argument is a replacement string. We can use special characters in it:\n\nFor situations that require “smart” replacements, the second argument can be a function.\n\nIt will be called for each match, and the returned value will be inserted as a replacement.\n\nThe function is called with arguments :\n• – contents of capturing groups (if there are any),\n\nIf there are no parentheses in the regexp, then there are only 3 arguments: .\n\nFor example, let’s uppercase all matches:\n\nReplace each match by its position in the string:\n\nIn the example below there are two parentheses, so the replacement function is called with 5 arguments: the first is the full match, then 2 parentheses, and after it (not used in the example) the match position and the source string:\n\nIf there are many groups, it’s convenient to use rest parameters to access them:\n\nOr, if we’re using named groups, then object with them is always the last, so we can obtain it like this:\n\nUsing a function gives us the ultimate replacement power, because it gets all the information about the match, has access to outer variables and can do everything.\n\nThis method is essentially the same as , with two major differences:\n• If the first argument is a string, it replaces all occurrences of the string, while replaces only the first occurrence.\n• If the first argument is a regular expression without the flag, there’ll be an error. With flag, it works the same as .\n\nThe main use case for is replacing all occurrences of a string.\n\nThe method returns a match for in the string . Unlike previous methods, it’s called on a regexp, not on a string.\n\nIt behaves differently depending on whether the regexp has flag .\n\nIf there’s no , then returns the first match exactly as . This behavior doesn’t bring anything new.\n\nBut if there’s flag , then:\n• A call to returns the first match and saves the position immediately after it in the property .\n• The next such call starts the search from position , returns the next match and saves the position after it in .\n• If there are no matches, returns and resets to .\n\nSo, repeated calls return all matches one after another, using property to keep track of the current search position.\n\nIn the past, before the method was added to JavaScript, calls of were used in the loop to get all matches with groups:\n\nThis works now as well, although for newer browsers is usually more convenient.\n\nWe can use to search from a given position by manually setting .\n\nIf the regexp has flag , then the search will be performed exactly at the position , not any further.\n\nLet’s replace flag with in the example above. There will be no matches, as there’s no word at position :\n\nThat’s convenient for situations when we need to “read” something from the string by a regexp at the exact position, not somewhere further.\n\nThe method looks for a match and returns whether it exists.\n\nAn example with the negative answer:\n\nIf the regexp has flag , then looks from property and updates this property, just like .\n\nSo we can use it to search from a given position:"
    },
    {
        "link": "https://w3schools.com/jsref/jsref_search.asp",
        "document": "W3Schools offers a wide range of services and products for beginners and professionals, helping millions of people everyday to learn and master new skills."
    }
]