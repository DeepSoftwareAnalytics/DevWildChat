[
    {
        "link": "https://geeksforgeeks.org/operator-overloading-in-python",
        "document": "Operator Overloading means giving extended meaning beyond their predefined operational meaning. For example operator + is used to add two integers as well as join two strings and merge two lists. It is achievable because ‘+’ operator is overloaded by int class and str class. You might have noticed that the same built-in operator or function shows different behavior for objects of different classes, this is called Operator Overloading.\n\nHow to overload the operators in Python?\n\nConsider that we have two objects which are a physical representation of a class (user-defined data type) and we have to add two objects with binary ‘+’ operator it throws an error, because compiler don’t know how to add two objects. So we define a method for an operator and that process is called operator overloading. We can overload all existing operators but we can’t create a new operator. To perform operator overloading, Python provides some special function or magic function that is automatically invoked when it is associated with that particular operator. For example, when we use + operator, the magic method __add__ is automatically invoked in which the operation for + operator is defined.\n\nWhen we use an operator on user-defined data types then automatically a special function or magic function associated with that operator is invoked. Changing the behavior of operator is as simple as changing the behavior of a method or function. You define methods in your class and operators work according to that behavior defined in methods. When we use + operator, the magic method __add__ is automatically invoked in which the operation for + operator is defined. Thereby changing this magic method’s code, we can give extra meaning to the + operator.\n\nHow Does the Operator Overloading Actually work?\n\nWhenever you change the behavior of the existing operator through operator overloading, you have to redefine the special function that is invoked automatically when the operator is used with the objects.\n\nHere, We defined the special function “__add__( )” and when the objects are coded as “ob1 + ob2“, the special function is automatically called as ob1.__add__(ob2) which simply means that ob1 calls the __add__( ) function with ob2 as an Argument and It actually means A .__add__(ob1, ob2). Hence, when the Binary operator is overloaded, the object before the operator calls the respective function with object after operator as parameter.\n\nOverloading equality and less than operators:\n\nNote: It is not possible to change the number of operands of an operator. For example: If we can not overload a unary operator as a binary operator. The following code will throw a syntax error.\n\nIn Python, you can overload the Boolean operators and, or, and not by defining the __and__, __or__, and __not__ special methods in your class.\n\nHere’s an example of how to overload the and operator for a custom class:\n\nIn this example, we define a MyClass that has a single attribute value, which is a boolean. We then overload the & operator by defining the __and__ method to perform a logical and operation on the value attribute of two MyClass instances.\n\nWhen we call a & b, the __and__ method is called with a as the first argument and b as the second argument. The method returns a new instance of MyClass with a value attribute that is the logical and of a.value and b.value.\n\nNote that Python also provides built-in boolean operators that can be used with any object. For example, you can use the bool() function to convert any object to a boolean value, and the all() and any() functions to perform logical and and or operations on a sequence of boolean values. Overloading the boolean operators in a custom class can be useful to provide a more natural syntax and semantics for your class.\n\nOverloading boolean operators in a custom class can provide several advantages, including:\n• None Improved readability: By overloading boolean operators, you can provide a more natural syntax and semantics for your class that makes it easier to read and understand.\n• None Consistency with built-in types: Overloading boolean operators can make your class behave more like built-in types in Python, which can make it easier to use and integrate with other code.\n• None Operator overloading: Overloading boolean operators is an example of operator overloading in Python, which can make your code more concise and expressive by allowing you to use familiar operators to perform custom operations on your objects.\n• None Custom behavior: Overloading boolean operators can allow you to define custom behavior for your class that is not available in built-in types or other classes.\n• None Enhanced functionality: By overloading boolean operators, you can add new functionality to your class that was not available before, such as the ability to perform logical and or or operations on instances of your class.\n\nOverall, overloading boolean operators in a custom class can make your code more readable, consistent, concise, expressive, and functional. However, it’s important to use operator overloading judiciously and only when it makes sense for the semantics of your class.\n\nWhat is the Plus Operator in Python?\n\nWhat is Operator Overloading in Python?\n\nWhat Are the Different Types of Overloading in Python?\n\nWhat Are the 7 Operators in Python?"
    },
    {
        "link": "https://programiz.com/python-programming/operator-overloading",
        "document": "As we know, the operator can perform addition on two numbers, merge two lists, or concatenate two strings.\n\nWith some tweaks, we can use the operator to work with user-defined objects as well. This feature in Python, which allows the same operator to have different meanings depending on the context is called operator overloading.\n\nIn Python, methods that have two underscores, , before and after their names have a special meaning. For example, , etc.\n\nThese special methods can be used to implement certain features or behaviors.\n\nLet's use the method to add two numbers instead of using the operator.\n\nIt is possible to use the method on integers because:\n• Everything in Python is an object, including integers.\n• Integers have the method defined that we can use.\n\nIn fact, the operator internally calls the method to add integers and floats.\n\nHere are some of the special functions available in Python:\n\nHow to Use Operator Overloading?\n\nSuppose we want to use the operator to add two user-defined objects.\n\nSince the operator internally calls the method, if we implement this method in a class, we can make objects of that class work with the operator.\n\nExample: Add Two Coordinates (Without Overloading)\n\nLet's first write a program to add two co-ordinates (without using operator overloading).\n\nIn the above example, we created the method to add two points. To call this method, we have used .\n\nLet's write the same code using the operator to add two points.\n\nExample: Add Two Coordinates (With Overloading)\n\nHere, this code calls the method. The parameter takes , and the parameter takes as arguments.\n\nIn the above program, we could have easily used the operator for subtraction like this:\n\nNow the operator in the above code performs subtraction of points. Even though the program works without errors, you should absolutley avoid this. We should always use oeprators appropriately during operator overloading.\n\nSimilarly, we can overload other operators as well. The special function that we need to implement is tabulated below.\n\nPython does not limit operator overloading to arithmetic operators. We can overload comparison operators as well.\n\nHere's an example of how we can overload the operator to compare two objects of the class based on their :\n\nHere, overloads the operator to compare the attribute of two objects.\n• - if the first object's is less than the second object's\n• - if the first object's is greater than the second object's\n\nSimilarly, the special functions that we need to implement to overload other comparison operators are tabulated below.\n\nHere are some advantages of operator overloading:\n• Improves code readability by allowing the use of familiar operators.\n• Ensures that objects of a class behave consistently with built-in types and other user-defined types.\n• Makes it simpler to write code, especially for complex data types.\n• Allows for code reuse by implementing one operator method and using it for other operators.\n• Precedence and Associativity of Operators in Python"
    },
    {
        "link": "https://stackoverflow.com/questions/46885618/using-add-operator-with-multiple-arguments-in-python",
        "document": "I am trying to add a class object with a number, but I'm confused on how to go about adding a class object with two numbers. For example, this is my hypothetical add class method:\n\nI know how to add this so far:\n\nBut, what if I want to add it like this?\n\nShould I use *args for the add class method?"
    },
    {
        "link": "https://wscubetech.com/resources/python/operator-overloading",
        "document": ""
    },
    {
        "link": "https://stackoverflow.com/questions/62115060/python-how-to-use-add-special-method-to-add-instances-of-the-same-class-tha",
        "document": "Writing a program for a card game is what motivated the question. Currently, the way I defined the special method, I can in fact do something like this:\n\nThe challenge is that is a list, and I'm curious if there exists a way to add such that would instead also become type Deck?\n\nOne reason I'm trying to do this, is if I wanted a game to include multiple decks, it would be neat to have the ability to add them all together, and pass them into which would 'hold' some n number of decks.\n\nBelow is a snippet of my code. I could be completely off here, but would play any type of role in this? is what actually gets referred to in later methods. from what I understand, returns it's representation (and as a sideq; I believe would return the samething if not defined (though please correct me If im wrong), but my understanding is that if I were to only include one, its generally better practice to pick , unless both should be included? In anycase:"
    },
    {
        "link": "https://docs.python.org/3/library/operator.html",
        "document": "The module exports a set of efficient functions corresponding to the intrinsic operators of Python. For example, is equivalent to the expression . Many function names are those used for special methods, without the double underscores. For backward compatibility, many of these have a variant with the double underscores kept. The variants without the double underscores are preferred for clarity.\n\nThe functions fall into categories that perform object comparisons, logical operations, mathematical operations and sequence operations.\n\nThe object comparison functions are useful for all objects, and are named after the rich comparison operators they support:\n\nThe logical operations are also generally applicable to all objects, and support truth tests, identity tests, and boolean operations:\n\nThe mathematical and bitwise operations are the most numerous:\n\nOperations which work with sequences (some of them with mappings too) include:\n\nThe following operation works with callables:\n\nThe module also defines tools for generalized attribute and item lookups. These are useful for making fast field extractors as arguments for , , , or other functions that expect a function argument.\n\nReturn a callable object that fetches item from its operand using the operand’s method. If multiple items are specified, returns a tuple of lookup values. For example: The items can be any type accepted by the operand’s method. Dictionaries accept any hashable value. Lists, tuples, and strings accept an index or a slice: Example of using to retrieve specific fields from a tuple record:"
    },
    {
        "link": "https://geeksforgeeks.org/operator-overloading-in-python",
        "document": "Operator Overloading means giving extended meaning beyond their predefined operational meaning. For example operator + is used to add two integers as well as join two strings and merge two lists. It is achievable because ‘+’ operator is overloaded by int class and str class. You might have noticed that the same built-in operator or function shows different behavior for objects of different classes, this is called Operator Overloading.\n\nHow to overload the operators in Python?\n\nConsider that we have two objects which are a physical representation of a class (user-defined data type) and we have to add two objects with binary ‘+’ operator it throws an error, because compiler don’t know how to add two objects. So we define a method for an operator and that process is called operator overloading. We can overload all existing operators but we can’t create a new operator. To perform operator overloading, Python provides some special function or magic function that is automatically invoked when it is associated with that particular operator. For example, when we use + operator, the magic method __add__ is automatically invoked in which the operation for + operator is defined.\n\nWhen we use an operator on user-defined data types then automatically a special function or magic function associated with that operator is invoked. Changing the behavior of operator is as simple as changing the behavior of a method or function. You define methods in your class and operators work according to that behavior defined in methods. When we use + operator, the magic method __add__ is automatically invoked in which the operation for + operator is defined. Thereby changing this magic method’s code, we can give extra meaning to the + operator.\n\nHow Does the Operator Overloading Actually work?\n\nWhenever you change the behavior of the existing operator through operator overloading, you have to redefine the special function that is invoked automatically when the operator is used with the objects.\n\nHere, We defined the special function “__add__( )” and when the objects are coded as “ob1 + ob2“, the special function is automatically called as ob1.__add__(ob2) which simply means that ob1 calls the __add__( ) function with ob2 as an Argument and It actually means A .__add__(ob1, ob2). Hence, when the Binary operator is overloaded, the object before the operator calls the respective function with object after operator as parameter.\n\nOverloading equality and less than operators:\n\nNote: It is not possible to change the number of operands of an operator. For example: If we can not overload a unary operator as a binary operator. The following code will throw a syntax error.\n\nIn Python, you can overload the Boolean operators and, or, and not by defining the __and__, __or__, and __not__ special methods in your class.\n\nHere’s an example of how to overload the and operator for a custom class:\n\nIn this example, we define a MyClass that has a single attribute value, which is a boolean. We then overload the & operator by defining the __and__ method to perform a logical and operation on the value attribute of two MyClass instances.\n\nWhen we call a & b, the __and__ method is called with a as the first argument and b as the second argument. The method returns a new instance of MyClass with a value attribute that is the logical and of a.value and b.value.\n\nNote that Python also provides built-in boolean operators that can be used with any object. For example, you can use the bool() function to convert any object to a boolean value, and the all() and any() functions to perform logical and and or operations on a sequence of boolean values. Overloading the boolean operators in a custom class can be useful to provide a more natural syntax and semantics for your class.\n\nOverloading boolean operators in a custom class can provide several advantages, including:\n• None Improved readability: By overloading boolean operators, you can provide a more natural syntax and semantics for your class that makes it easier to read and understand.\n• None Consistency with built-in types: Overloading boolean operators can make your class behave more like built-in types in Python, which can make it easier to use and integrate with other code.\n• None Operator overloading: Overloading boolean operators is an example of operator overloading in Python, which can make your code more concise and expressive by allowing you to use familiar operators to perform custom operations on your objects.\n• None Custom behavior: Overloading boolean operators can allow you to define custom behavior for your class that is not available in built-in types or other classes.\n• None Enhanced functionality: By overloading boolean operators, you can add new functionality to your class that was not available before, such as the ability to perform logical and or or operations on instances of your class.\n\nOverall, overloading boolean operators in a custom class can make your code more readable, consistent, concise, expressive, and functional. However, it’s important to use operator overloading judiciously and only when it makes sense for the semantics of your class.\n\nWhat is the Plus Operator in Python?\n\nWhat is Operator Overloading in Python?\n\nWhat Are the Different Types of Overloading in Python?\n\nWhat Are the 7 Operators in Python?"
    },
    {
        "link": "https://docs.python.org/3/reference/datamodel.html",
        "document": "Objects are Python’s abstraction for data. All data in a Python program is represented by objects or by relations between objects. (In a sense, and in conformance to Von Neumann’s model of a “stored program computer”, code is also represented by objects.) Every object has an identity, a type and a value. An object’s identity never changes once it has been created; you may think of it as the object’s address in memory. The operator compares the identity of two objects; the function returns an integer representing its identity. CPython implementation detail: For CPython, is the memory address where is stored. An object’s type determines the operations that the object supports (e.g., “does it have a length?”) and also defines the possible values for objects of that type. The function returns an object’s type (which is an object itself). Like its identity, an object’s type is also unchangeable. The value of some objects can change. Objects whose value can change are said to be mutable; objects whose value is unchangeable once they are created are called immutable. (The value of an immutable container object that contains a reference to a mutable object can change when the latter’s value is changed; however the container is still considered immutable, because the collection of objects it contains cannot be changed. So, immutability is not strictly the same as having an unchangeable value, it is more subtle.) An object’s mutability is determined by its type; for instance, numbers, strings and tuples are immutable, while dictionaries and lists are mutable. Objects are never explicitly destroyed; however, when they become unreachable they may be garbage-collected. An implementation is allowed to postpone garbage collection or omit it altogether — it is a matter of implementation quality how garbage collection is implemented, as long as no objects are collected that are still reachable. CPython implementation detail: CPython currently uses a reference-counting scheme with (optional) delayed detection of cyclically linked garbage, which collects most objects as soon as they become unreachable, but is not guaranteed to collect garbage containing circular references. See the documentation of the module for information on controlling the collection of cyclic garbage. Other implementations act differently and CPython may change. Do not depend on immediate finalization of objects when they become unreachable (so you should always close files explicitly). Note that the use of the implementation’s tracing or debugging facilities may keep objects alive that would normally be collectable. Also note that catching an exception with a … statement may keep objects alive. Some objects contain references to “external” resources such as open files or windows. It is understood that these resources are freed when the object is garbage-collected, but since garbage collection is not guaranteed to happen, such objects also provide an explicit way to release the external resource, usually a method. Programs are strongly recommended to explicitly close such objects. The … statement and the statement provide convenient ways to do this. Some objects contain references to other objects; these are called containers. Examples of containers are tuples, lists and dictionaries. The references are part of a container’s value. In most cases, when we talk about the value of a container, we imply the values, not the identities of the contained objects; however, when we talk about the mutability of a container, only the identities of the immediately contained objects are implied. So, if an immutable container (like a tuple) contains a reference to a mutable object, its value changes if that mutable object is changed. Types affect almost all aspects of object behavior. Even the importance of object identity is affected in some sense: for immutable types, operations that compute new values may actually return a reference to any existing object with the same type and value, while for mutable objects this is not allowed. For example, after , a and b may or may not refer to the same object with the value one, depending on the implementation. This is because is an immutable type, so the reference to can be reused. This behaviour depends on the implementation used, so should not be relied upon, but is something to be aware of when making use of object identity tests. However, after , c and d are guaranteed to refer to two different, unique, newly created empty lists. (Note that assigns the same object to both e and f.)"
    },
    {
        "link": "https://pythonlikeyoumeanit.com/Module4_OOP/Special_Methods.html",
        "document": "In this section, we will learn about a variety of instance methods that are reserved by Python, which affect an object’s high level behavior and its interactions with operators. These are known as special methods. is an example of a special method; recall that it controls the process of creating instances of a class. Similarly, we will see that controls the behavior of an object when it is operated on by the symbol, for example. In general, the names of special methods take the form of , where the two underscores preceed and succeed the name. Accordingly, special methods can also be referred to as “dunder” (double-underscore) methods. Learning to leverage special methods will enable us to design elegant and powerful classes of objects.\n\nThese methods give us complete control over the various high-level interfaces that we use to interact with objects. Let’s make a simple class with nonsensical behavior to demonstrate our ability to shape how our class behaves:\n\nThis section is not meant to be a comprehensive treatment of special methods, which would require us to reach beyond our desired level of sophistication. The official Python documentation provides a rigorous but somewhat inaccessible treatment of special methods. Dive into Python 3 has an excellent appendix on special methods. It is strongly recommended that readers consult this resource.\n\nThe following methods determines how an object should be represented as a string in various contexts. For example, this text consistently utilizes the fact that passing an object to the Python console will prompt the console to print out a representation of that object as a string. That is, Under the hood, the special method is being called to obtain this string representation whenever an object is displayed in a console/notebook like this. The method returns the string , which is then printed out to the console. This is an extremely useful for creating classes whose objects can be inspected conveniently in a Python console or in a Jupyter notebook. Similarly returns the string that will be produced when is called on the object. invokes , this is also invoked when an object is returned by a console A well-implemented method can greatly improve the convenience of working with a class. For example, let’s add this method to our class that we wrote in the preceding section; the will create a string with our shopping items on a bulleted list with purchased items crossed out: \"\"\" Renders string with strike-through characters through it. is not unique to Python.\"\"\" # You wont find the\n• character on your keyboard. I simply # googled \"unicode bullet point\" and copied/pasted it here. See that this simple method makes it much easier for us to inspect the state of our shopping list when we are working in a console/notebook environment.\n\nThe following special methods control how an object interacts with , , , and other mathematical operators. A full listing of all the special methods used to emulate numeric types can be found here You may be wondering why division has the peculiar name , whereas the other operators have more sensible names. This is an artifact of the transition from Python 2 to Python 3; the default integer-division was replaced by float-division, and thus was replaced by for the sake of 2-3 compatibility. Let’s give an method so that we can merge shopping lists using the operator. Rather than redefine the entire class, we can simply define this as a function and use to set it as a method to our existing class. \"\"\" Add the unpurchased and purchased items from another shopping The shopping list whose items we will add to the present one. The present shopping list, with items added to it.\"\"\" # populate new_list with items from `self` and `other` # add purchased items to list, then mark as purchased Now let’s create a few shopping lists and combine them: Overloading the operator provides us with a sleek interface for merging multiple shopping lists in a sleek, readable way. is equivalent to calling . It is obvious that the former expression is far superior.\n\nThe following special methods allow us to give our class a container interface, like that of a dictionary, set, or list. An exhaustive listing and discussion of these methods can be found here To get a feel for these methods, let’s create class that implements most aspects of a list’s interface. We will store a list as an attribute of our class to keep track of the contents, but will implement special methods that “echo” the interface of the list. # otherwise, the individual element should be returned as-is \"\"\" Use the character | as the delimiter for our list\"\"\" # thus we can slice to get the contents of the string # and exclude the square-brackets, and add our own Let’s appreciate the rich behavior that we get out of this simple class: # MyList can accept any iterable as its # first (and only) input argument"
    },
    {
        "link": "https://realpython.com/operator-function-overloading",
        "document": "If you’ve used the or operator on a object in Python, you must have noticed its different behavior when compared to or objects:\n\nYou might have wondered how the same built-in operator or function shows different behavior for objects of different classes. This is called operator overloading or function overloading respectively. This article will help you understand this mechanism, so that you can do the same in your own Python classes and make your objects more Pythonic.\n• The API that handles operators and built-ins in Python\n• The “secret” behind and other built-ins\n• How to make your classes capable of using operators\n• How to make your classes compatible with Python’s built-in functions\n\nAs a bonus, you’ll also see an example class, objects of which will be compatible with many of these operators and functions. Let’s get started!\n\nSay you have a class representing an online order having a cart (a ) and a customer (a or instance of another class which represents a customer). Note: If you need a refresher on OOP in Python, check out this tutorial on Real Python: Object-Oriented Programming (OOP) in Python In such a case, it is quite natural to want to obtain the length of the cart list. Someone new to Python might decide to implement a method called in their class to do this. But you can configure the built-in in such a way that it returns the length of the cart list when given our object. In another case, we might want to append something to the cart. Again, someone new to Python would think of implementing a method called that takes an item and appends it to the cart list. But you can configure the operator in such a way that it appends a new item to the cart. Python does all this using special methods. These special methods have a naming convention, where the name starts with two underscores, followed by an identifier and ends with another pair of underscores. Essentially, each built-in function or operator has a special method corresponding to it. For example, there’s corresponding to , and , corresponding to the operator. By default, most of the built-ins and operators will not work with objects of your classes. You must add the corresponding special methods in your class definition to make your object compatible with built-ins and operators. When you do this, the behavior of the function or operator associated with it changes according to that defined in the method. This is exactly what the Data Model (Section 3 of the Python documentation) helps you accomplish. It lists all the special methods available and provides you with the means of overloading built-in functions and operators so that you can use them on your own objects. Let’s see what this means. Fun fact: Due to the naming convention used for these methods, they are also called dunder methods which is a shorthand for double underscore methods. Sometimes they’re also referred to as special methods or magic methods. We prefer dunder methods though!\n\nThe Internals of Operations Like and Every class in Python defines its own behavior for built-in functions and methods. When you pass an instance of some class to a built-in function or use an operator on the instance, it is actually equivalent to calling a special method with relevant arguments. If there is a built-in function, , and the corresponding special method for the function is , Python interprets a call to the function as , where is the object. In the case of operators, if you have an operator and the corresponding special method for it is , Python interprets something like as . So, when you’re calling on an object, Python handles the call as . When you use the operator on an iterable to obtain the value at an index, Python handles it as , where is the iterable object and is the index you want to obtain. Therefore, when you define these special methods in your own class, you override the behavior of the function or operator associated with them because, behind the scenes, Python is calling your method. Let’s get a better understanding of this: As you can see, when you use the function or its corresponding special method, you get the same result. In fact, when you obtain the list of attributes and methods of a object using , you’ll see these special methods in the list in addition to the usual methods available on objects: If the behavior of a built-in function or operator is not defined in the class by the special method, then you will get a . So, how can you use special methods in your classes?\n\nMany of the special methods defined in the Data Model can be used to change the behavior of functions such as , , , , and so on. To do this, you only need to define the corresponding special method in your class. Let’s look at a few examples: Giving a Length to Your Objects Using To change the behavior of , you need to define the special method in your class. Whenever you pass an object of your class to , your custom definition of will be used to obtain the result. Let’s implement for the order class we talked about in the beginning: As you can see, you can now use to directly obtain the length of the cart. Moreover, it makes more intuitive sense to say “length of order” rather than calling something like . Your call is both Pythonic and more intuitive. When you don’t have the method defined but still call on your object, you get a : File , line , in : object of type 'Order' has no len() But, when overloading , you should keep in mind that Python requires the function to return an integer. If your method were to return anything other than an integer, you would get a . This, most probably, is to keep it consistent with the fact that is generally used to obtain the length of a sequence, which can only be an integer: File , line , in : 'float' object cannot be interpreted as an integer You can dictate the behavior of the built-in for instances of your class by defining the special method in the class. There are no restrictions on the return value of , and you get a when the special method is absent in your class definition. In a class representing a vector in a two-dimensional space, can be used to get the length of the vector. Let’s see it in action: It makes more intuitive sense to say “absolute value of vector” rather than calling something like . The built-in is used to cast an instance of a class to a object, or more appropriately, to obtain a user-friendly string representation of the object which can be read by a normal user rather than the programmer. You can define the string format your object should be displayed in when passed to by defining the method in your class. Moreover, is the method that is used by Python when you call on your object. Let’s implement this in the class to format objects as . A negative y-component will be handled using the format mini-language: # By default, sign of +ve number is not displayed # Using `+`, sign is always displayed It is necessary that returns a object, and we get a if the return type is non-string. The built-in is used to obtain the parsable string representation of an object. If an object is parsable, that means that Python should be able to recreate the object from the representation when is used in conjunction with functions like . To define the behavior of , you can use the special method. This is also the method Python uses to display the object in a REPL session. If the method is not defined, you will get something like trying to look at the object in the REPL session. Let’s see it in action in the class: # Looking at object; __repr__ used Note: In cases where the method is not defined, Python uses the method to print the object, as well as to represent the object when is called on it. If both the methods are missing, it defaults to . But is the only method that is used to display the object in an interactive session. Absence of it in the class yields . Also, while this distinction between and is the recommended behavior, many of the popular libraries ignore this distinction and use the two methods interchangeably. Here’s a recommended article on and by our very own Dan Bader: Python String Conversion 101: Why Every Class Needs a “repr”. Making Your Objects Truthy or Falsey Using The built-in can be used to obtain the truth value of an object. To define its behavior, you can use the ( in Python 2.x) special method. The behavior defined here will determine the truth value of an instance in all contexts that require obtaining a truth value such as in statements. As an example, for the class that was defined above, an instance can be considered to be truthy if the length of the cart list is non-zero. This can be used to check whether an order should be processed or not: Note: When the special method is not implemented in a class, the value returned by is used as the truth value, where a non-zero value indicates and a zero value indicates . In case both the methods are not implemented, all instances of the class are considered to be . There are many more special methods that overload built-in functions. You can find them in the documentation. Having discussed some of them, let’s move to operators.\n\nChanging the behavior of operators is just as simple as changing the behavior of functions. You define their corresponding special methods in your class, and the operators work according to the behavior defined in these methods. These are different from the above special methods in the sense that they need to accept another argument in the definition other than , generally referred to by the name . Let’s look at a few examples. Making Your Objects Capable of Being Added Using The special method corresponding to the operator is the method. Adding a custom definition of changes the behavior of the operator. It is recommended that returns a new instance of the class instead of modifying the calling instance itself. You’ll see this behavior quite commonly in Python: # Creates new instance and assigns a to it You can see above that using the operator on a object actually returns a new instance, keeping the value of the calling instance ( ) unmodified. To change it, we need to explicitly assign the new instance to . Let’s implement the ability to append new items to our cart in the class using the operator. We’ll follow the recommended practice and make the operator return a new instance that has our required changes instead of making the changes directly to our instance: Similarly, you have the , , and other special methods which define the behavior of , , and so on. These methods should return a new instance of the class as well. The operator stands as a shortcut to the expression . The special method corresponding to it is . The method should make changes directly to the argument and return the result, which may or may not be . This behavior is quite different from since the latter creates a new object and returns that, as you saw above. Roughly, any use on two objects is equivalent to this: Here, is the value returned by . The second assignment is taken care of automatically by Python, meaning that you do not need to explicitly assign to the result as in the case of . Let’s make this possible for the class so that new items can be appended to the cart using : As can be seen, any change is made directly to and it is then returned. What happens when you return some random value, like a string or an integer? Even though the relevant item was appended to the cart, the value of changed to what was returned by . Python implicitly handled the assignment for you. This can lead to surprising behavior if you forget to return something in your implementation: Since all Python functions (or methods) return implicitly, is reassigned to and the REPL session doesn’t show any output when is inspected. Looking at the type of , you see that it is now . Therefore, always make sure that you’re returning something in your implementation of and that it is the result of the operation and not anything else. Similar to , you have , , and other special methods which define the behavior of , , , and others alike. Note: When or its friends are missing from your class definition but you still use their operators on your objects, Python uses and its friends to get the result of the operation and assigns that to the calling instance. Generally speaking, it is safe to not implement and its friends in your classes as long as and its friends work properly (return something which is the result of the operation). The Python documentation has a good explanation of these methods. Also, take a look at this example which shows the caveats involved with and the others when working with immutable types. Indexing and Slicing Your Objects Using The operator is called the indexing operator and is used in various contexts in Python such as getting the value at an index in sequences, getting the value associated with a key in dictionaries, or obtaining a part of a sequence through slicing. You can change its behavior using the special method. Let’s configure our class so that we can directly use the object and obtain an item from the cart: You’ll notice that above, the name of the argument to is not but . This is because the argument can be of mainly three forms: an integer value, in which case it is either an index or a dictionary key, a string value, in which case it is a dictionary key, and a slice object, in which case it will slice the sequence used by the class. While there are other possibilities, these are the ones most commonly encountered. Since our internal data structure is a list, we can use the operator to slice the list, as in this case, the argument will be a slice object. This is one of the biggest advantages of having a definition in your class. As long as you’re using data structures that support slicing (lists, tuples, strings, and so on), you can configure your objects to directly slice the structure: Note: There is a similar special method that is used to define the behavior of . This method takes two arguments in addition to , generally called and , and can be used to change the value at to . While defining the , , , and similar special methods allows you to use the operators when your class instance is the left-hand side operand, the operator will not work if the class instance is the right-hand side operand: If your class represents a mathematical entity like a vector, a coordinate, or a complex number, applying the operators should work in both the cases since it is a valid mathematical operation. Moreover, if the operators work only when the instance is the left operand, we are violating the fundamental principle of commutativity in many cases. Therefore, to help you make your classes mathematically correct, Python provides you with reverse special methods such as , , , and so on. These handle calls such as , , and , where is not an instance of the concerned class. Just like and the others, these reverse special methods should return a new instance of class with the changes of the operation rather than modifying the calling instance itself. Let’s configure in the class in such a way that it will append something at the front of the cart. This can be used in cases where the cart is organized in terms of the priority of the orders:\n\nTo drive all these points home, it’s better to look at an example class which implements these operators together. Let’s reinvent the wheel and implement our own class to represent complex numbers, . Objects of our class will support a variety of built-in functions and operators, making them behave very similar to the built-in complex numbers class: The constructor handles only one kind of call, . It takes positional arguments, representing the real and imaginary parts of the complex number. Let’s define two methods inside the class, and , which will give us the complex conjugate and the argument of a complex number respectively: Note: is not a special method but a class attribute which is present by default. It has a reference to the class. By using it here, we are obtaining that and then calling the constructor in the usual manner. In other words, this is equivalent to . This is done here to avoid refactoring the code if the name of the class changes someday. Next, we configure to return the modulus of a complex number: We will follow the recommended distinction between and and use the first for the parsable string representation and the second for a “pretty” representation. The method will simply return in a string so that we can call to recreate the object, while the method will return the complex number in brackets, as : Mathematically, it is possible to add any two complex numbers or add a real number to a complex number. Let’s configure the operator in such a way that it works for both cases. The method will check the type of the right-hand side operator. In case it is an or a , it will increment only the real part (since any real number, , is equivalent to ), while in the case of another complex number, it will change both the parts: Similarly, we define the behavior for and : Since both addition and multiplication are commutative, we can define their reverse operators by calling and in and respectively. On the other hand, the behavior of needs to be defined since subtraction is not commutative: Note: You might have noticed that we didn’t add a construct to handle a instance here. This is because, in such a case, both the operands are instances of our class, and won’t be responsible for handling the operation. Instead, will be called. This is a subtle but important detail. Now, we take care of the two operators, and . The special methods used for them are and , respectively. Two complex numbers are said to be equal if their corresponding real and imaginary parts are both equal. They are said to be unequal when either one of these are unequal: # Note: generally, floats should not be compared directly Note: The Floating-Point Guide is an article that talks about comparing floats and floating-point precision. It highlights the caveats involved in comparing floats directly, which is something we’re doing here. It is also possible to raise a complex number to any power using a simple formula. We configure the behavior for both the built-in and the operator using the special method: Note: Take a close look at the definition of the method. We are calling to obtain the modulus of the complex number. So, once you’ve defined the special method for a particular function or operator in your class, it can be used in other methods of the same class. Let’s create two instances of this class, one having a positive imaginary part and one having a negative imaginary part: Recreating the object using with : As you can see, objects of our custom class behave and look like those of a built-in class and are very Pythonic. The full example code for this class is embedded below. * Addition with a complex number or a real number using `+` * Multiplication with a complex number or a real number using `*` * Subtraction of a complex number or a real number using `-` * Calculation of absolute value using `abs` * The constructor has been intentionally kept simple * It is configured to support one kind of call: * Error handling was avoided to keep things simple The argument is given by: Returns str representation of an instance of the class. Can be used with eval() to get another Returns the addition of a complex number with Returns the subtration from a complex number of Returns the multiplication of a complex number with Same as __add__; allows 1 + CustomComplex('x+yj') Same as __mul__; allows 2 * CustomComplex('x+yj') Returns the subtraction of a complex number from Subtration of another complex number is not handled by __rsub__ Instead, __sub__ handles it since both sides are instances of Two complex numbers are equal when: * Their real parts are equal AND # note: comparing floats directly is not a good idea in general Two complex numbers are unequal when: * Their real parts are unequal OR"
    }
]