[
    {
        "link": "https://developer.android.com/guide/fragments/lifecycle",
        "document": "Each instance has its own lifecycle. When a user navigates and interacts with your app, your fragments transition through various states in their lifecycle as they are added, removed, and enter or exit the screen.\n\nTo manage lifecycle, implements , exposing a object that you can access through the method.\n\nEach possible state is represented in the enum.\n\nBy building on top of , you can use the techniques and classes available for Handling Lifecycles with Lifecycle-Aware Components. For example, you might display the device's location on the screen using a lifecycle-aware component. This component could automatically start listening when the fragment becomes active and stop when the fragment moves to an inactive state.\n\nAs an alternative to using a , the class includes callback methods that correspond to each of the changes in a fragment's lifecycle. These include , , , , , and .\n\nA fragment's view has a separate that is managed independently from that of the fragment's . Fragments maintain a for their view, which can be accessed using or . Having access to the view's is useful for situations where a Lifecycle-aware component should only perform work while a fragment's view exists, such as observing that is only meant to be displayed on the screen.\n\nThis topic discusses the lifecycle in detail, explaining some of the rules that determine a fragment's lifecycle state and showing the relationship between the states and the fragment lifecycle callbacks.\n\nWhen a fragment is instantiated, it begins in the state. For a fragment to transition through the rest of its lifecycle, it must be added to a . The is responsible for determining what state its fragment should be in and then moving them into that state.\n\nBeyond the fragment lifecycle, is also responsible for attaching fragments to their host activity and detaching them when the fragment is no longer in use. The class has two callback methods, and , that you can override to perform work when either of these events occur.\n\nThe callback is invoked when the fragment has been added to a and is attached to its host activity. At this point, the fragment is active, and the is managing its lifecycle state. At this point, methods such as return this fragment.\n\nis always called before any Lifecycle state changes.\n\nThe callback is invoked when the fragment has been removed from a and is detached from its host activity. The fragment is no longer active and can no longer be retrieved using .\n\nis always called after any Lifecycle state changes.\n\nNote that these callbacks are unrelated to the methods and . For more information on these methods, see Fragment transactions.\n\nWhen determining a fragment's lifecycle state, considers the following:\n• A fragment's maximum state is determined by its . A fragment cannot progress beyond the state of its .\n• As part of a , you can set a maximum lifecycle state on a fragment using .\n• A fragment's lifecycle state can never be greater than its parent. For example, a parent fragment or activity must be started before its child fragments. Likewise, child fragments must be stopped before their parent fragment or activity.\n\nFigure 1 shows each of the fragment's states and how they relate to both the fragment's lifecycle callbacks and the fragment's view .\n\nAs a fragment progresses through its lifecycle, it moves upward and downward through its states. For example, a fragment that is added to the top of the back stack moves upward from to to . Conversely, when a fragment is popped off of the back stack, it moves downward through those states, going from to to and finally .\n\nWhen moving upward through its lifecycle states, a fragment first calls the associated lifecycle callback for its new state. Once this callback is finished, the relevant is emitted to observers by the fragment's , followed by the fragment's view , if it has been instantiated.\n\nWhen your fragment reaches the state, it has been added to a and the method has already been called.\n\nThis would be the appropriate place to restore any saved state associated with the fragment itself through the fragment's . Note that the fragment's view has not been created at this time, and any state associated with the fragment's view should be restored only after the view has been created.\n\nThis transition invokes the callback. The callback also receives a argument containing any state previously saved by . Note that has a value the first time the fragment is created, but it is always non-null for subsequent recreations, even if you do not override . See Saving state with fragments for more details.\n\nThe fragment's view is created only when your provides a valid instance. In most cases, you can use the fragment constructors that take a , which automatically inflates the view at the appropriate time. You can also override to programmatically inflate or create your fragment's view.\n\nIf and only if your fragment's view is instantiated with a non-null , that is set on the fragment and can be retrieved using . The is then updated with the newly corresponding with the fragment's view. The lifecycle callback is also called at this time.\n\nThis is the appropriate place to set up the initial state of your view, to start observing instances whose callbacks update the fragment's view, and to set up adapters on any or instances in your fragment's view.\n\nAfter the fragment's view has been created, the previous view state, if any, is restored, and the view's is then moved into the state. The view lifecycle owner also emits the event to its observers. Here you should restore any additional state associated with the fragment's view.\n\nThis transition also invokes the callback.\n\nIt is strongly recommended to tie Lifecycle-aware components to the state of a fragment, as this state guarantees that the fragment's view is available, if one was created, and that it is safe to perform a on the child of the fragment. If the fragment's view is non-null, the fragment's view is moved to immediately after the fragment's is moved to .\n\nWhen the fragment becomes , the callback is invoked.\n\nWhen the fragment is visible, all and effects have finished, and the fragment is ready for user interaction. The fragment's moves to the state, and the callback is invoked.\n\nThe transition to is the appropriate signal to indicate that the user is now able to interact with your fragment. Fragments that are not should not manually set focus on their views or attempt to handle input method visibility.\n\nWhen a fragment moves downward to a lower lifecycle state, the relevant is emitted to observers by the fragment's view , if instantiated, followed by the fragment's . After a fragment's lifecycle event is emitted, the fragment calls the associated lifecycle callback.\n\nAs the user begins to leave the fragment, and while the fragment is still visible, the s for the fragment and for its view are moved back to the state and emit the event to their observers. The fragment then invokes its callback.\n\nOnce the fragment is no longer visible, the s for the fragment and for its view are moved into the state and emit the event to their observers. This state transition is triggered not only by the parent activity or fragment being stopped, but also by the saving of state by the parent activity or fragment. This behavior guarantees that the event is invoked before the fragment's state is saved. This makes the event the last point where it is safe to perform a on the child .\n\nAs shown in figure 2, the ordering of the callback and the saving of the state with differs based on API level. For all API levels prior to API 28, is invoked before . For API levels 28 and higher, the calling order is reversed.\n\nAfter all of the exit animations and transitions have completed, and the fragment's view has been detached from the window, the fragment's view is moved into the state and emits the event to its observers. The fragment then invokes its callback. At this point, the fragment's view has reached the end of its lifecycle and returns a value.\n\nAt this point, all references to the fragment's view should be removed, allowing the fragment's view to be garbage collected.\n\nIf the fragment is removed, or if the is destroyed, the fragment's is moved into the state and sends the event to its observers. The fragment then invokes its callback. At this point, the fragment has reached the end of its lifecycle.\n\nFor more information related to the fragment lifecycle, see the following additional resources."
    },
    {
        "link": "https://developer.android.com/guide/fragments",
        "document": "A represents a reusable portion of your app's UI. A fragment defines and manages its own layout, has its own lifecycle, and can handle its own input events. Fragments can't live on their own. They must be hosted by an activity or another fragment. The fragment’s view hierarchy becomes part of, or attaches to, the host’s view hierarchy.\n\nFragments introduce modularity and reusability into your activity’s UI by letting you divide the UI into discrete chunks. Activities are an ideal place to put global elements around your app's user interface, such as a navigation drawer. Conversely, fragments are better suited to define and manage the UI of a single screen or portion of a screen.\n\nConsider an app that responds to various screen sizes. On larger screens, you might want the app to display a static navigation drawer and a list in a grid layout. On smaller screens, you might want the app to display a bottom navigation bar and a list in a linear layout.\n\nManaging these variations in the activity is unwieldy. Separating the navigation elements from the content can make this process more manageable. The activity is then responsible for displaying the correct navigation UI, while the fragment displays the list with the proper layout.\n\nDividing your UI into fragments makes it easier to modify your activity's appearance at runtime. While your activity is in the lifecycle state or higher, fragments can be added, replaced, or removed. And you can keep a record of these changes in a back stack that is managed by the activity, so that the changes can be reversed.\n\nYou can use multiple instances of the same fragment class within the same activity, in multiple activities, or even as a child of another fragment. With this in mind, only provide a fragment with the logic necessary to manage its own UI. Avoid depending on or manipulating one fragment from another.\n\nFor more documentation and resources related to fragments, see the following.\n• Single Activity: Why, when, and how (Android Dev Summit '18)"
    },
    {
        "link": "https://developer.android.com/guide/fragments/transactions",
        "document": "At runtime, a can add, remove, replace, and perform other actions with fragments in response to user interaction. Each set of fragment changes that you commit is called a transaction, and you can specify what to do inside the transaction using the APIs provided by the class. You can group multiple actions into a single transaction—for example, a transaction can add or replace multiple fragments. This grouping can be useful for when you have multiple sibling fragments displayed on the same screen, such as with split views.\n\nYou can save each transaction to a back stack managed by the , allowing the user to navigate backward through the fragment changes—similar to navigating backward through activities.\n\nYou can get an instance of from the by calling , as shown in the following example:\n\nThe final call on each must commit the transaction. The call signals to the that all operations have been added to the transaction.\n\nAllow reordering of fragment state changes\n\nEach should use :\n\nFor behavior compatibility, the reordering flag is not enabled by default. It is required, however, to allow to properly execute your , particularly when it operates on the back stack and runs animations and transitions. Enabling the flag ensures that if multiple transactions are executed together, any intermediate fragments (i.e. ones that are added and then immediately replaced) do not go through lifecycle changes or have their animations or transitions executed. Note that this flag affects both the initial execution of the transaction and reversing the transaction with .\n\nTo add a fragment to a , call on the transaction. This method receives the ID of the container for the fragment, as well as the class name of the fragment you wish to add. The added fragment is moved to the state. It is strongly recommended that the container is a that is part of the view hierarchy.\n\nTo remove a fragment from the host, call , passing in a fragment instance that was retrieved from the fragment manager through or . If the fragment's view was previously added to a container, the view is removed from the container at this point. The removed fragment is moved to the state.\n\nUse to replace an existing fragment in a container with an instance of a new fragment class that you provide. Calling is equivalent to calling with a fragment in a container and adding a new fragment to that same container.\n\nThe following code snippet shows how you can replace one fragment with another:\n\nIn this example, a new instance of replaces the fragment, if any, that is currently in the layout container identified by .\n\nBy default, the changes made in a are not added to the back stack. To save those changes, you can call on the . For more information, see Fragment manager.\n\nCalling doesn't perform the transaction immediately. Rather, the transaction is scheduled to run on the main UI thread as soon as it is able to do so. If necessary, however, you can call to run the fragment transaction on your UI thread immediately.\n\nNote that is incompatible with . Alternatively, you can execute all pending submitted by calls that have not yet run by calling . This approach is compatible with .\n\nFor the vast majority of use cases, is all you need.\n\nThe order in which you perform operations within a is significant, particularly when using . This method applies the given animations to all fragment operations that follow it.\n\ncan affect the lifecycle state of individual fragments added within the scope of the transaction. When creating a , sets a maximum state for the given fragment. For example, uses to limit the off-screen fragments to the state.\n\nUse the methods and to show and hide the view of fragments that have been added to a container. These methods set the visibility of the fragment's views without affecting the lifecycle of the fragment.\n\nWhile you don't need to use a fragment transaction to toggle the visibility of the views within a fragment, these methods are useful for cases where you want changes to the visibility state to be associated with transactions on the back stack.\n\nThe method detaches the fragment from the UI, destroying its view hierarchy. The fragment remains in the same state ( ) as when it is put on the back stack. This means that the fragment was removed from the UI but is still managed by the fragment manager.\n\nThe method reattaches a fragment from which it was previously detached. This causes its view hierarchy to be recreated, attached to the UI, and displayed.\n\nAs a is treated as a single atomic set of operations, calls to both and on the same fragment instance in the same transaction effectively cancel each other out, thus avoiding the destruction and immediate recreation of the fragment's UI. Use separate transactions, separated by if using , if you want to detach and then immediately re-attach a fragment."
    },
    {
        "link": "https://developer.android.com/topic/libraries/architecture/lifecycle",
        "document": "Save and categorize content based on your preferences.\n\nLifecycle-aware components perform actions in response to a change in the lifecycle status of another component, such as activities and fragments. These components help you produce better-organized, and often lighter-weight code, that is easier to maintain.\n\nA common pattern is to implement the actions of the dependent components in the lifecycle methods of activities and fragments. However, this pattern leads to a poor organization of the code and to the proliferation of errors. By using lifecycle-aware components, you can move the code of dependent components out of the lifecycle methods and into the components themselves.\n\nThe package provides classes and interfaces that let you build lifecycle-aware components—which are components that can automatically adjust their behavior based on the current lifecycle state of an activity or fragment.\n\nMost of the app components that are defined in the Android Framework have lifecycles attached to them. Lifecycles are managed by the operating system or the framework code running in your process. They are core to how Android works and your application must respect them. Not doing so may trigger memory leaks or even application crashes.\n\nImagine we have an activity that shows the device location on the screen. A common implementation might be like the following:\n\nEven though this sample looks fine, in a real app, you end up having too many calls that manage the UI and other components in response to the current state of the lifecycle. Managing multiple components places a considerable amount of code in lifecycle methods, such as and , which makes them difficult to maintain.\n\nMoreover, there's no guarantee that the component starts before the activity or fragment is stopped. This is especially true if we need to perform a long-running operation, such as some configuration check in . This can cause a race condition where the method finishes before the , keeping the component alive longer than it's needed.\n\nThe package provides classes and interfaces that help you tackle these problems in a resilient and isolated way.\n\nis a class that holds the information about the lifecycle state of a component (like an activity or a fragment) and allows other objects to observe this state.\n\nuses two main enumerations to track the lifecycle status for its associated component:\n\nThink of the states as nodes of a graph and events as the edges between these nodes.\n\nA class can monitor the component's lifecycle status by implementing and overriding corresponding methods such as , , etc. Then you can add an observer by calling the method of the class and passing an instance of your observer, as shown in the following example:\n\nIn the example above, the object implements the interface, which is explained in the following section.\n\nis a single method interface that denotes that the class has a . It has one method, , which must be implemented by the class. If you're trying to manage the lifecycle of a whole application process instead, see .\n\nThis interface abstracts the ownership of a from individual classes, such as and , and allows writing components that work with them. Any custom application class can implement the interface.\n\nComponents that implement work seamlessly with components that implement because an owner can provide a lifecycle, which an observer can register to watch.\n\nFor the location tracking example, we can make the class implement and then initialize it with the activity's in the method. This allows the class to be self-sufficient, meaning that the logic to react to changes in lifecycle status is declared in instead of the activity. Having the individual components store their own logic makes the activities and fragments logic easier to manage.\n\nA common use case is to avoid invoking certain callbacks if the isn't in a good state right now. For example, if the callback runs a fragment transaction after the activity state is saved, it would trigger a crash, so we would never want to invoke that callback.\n\nTo make this use case easy, the class allows other objects to query the current state.\n\nWith this implementation, our class is completely lifecycle-aware. If we need to use our from another activity or fragment, we just need to initialize it. All of the setup and teardown operations are managed by the class itself.\n\nIf a library provides classes that need to work with the Android lifecycle, we recommend that you use lifecycle-aware components. Your library clients can easily integrate those components without manual lifecycle management on the client side.\n\nFragments and Activities in Support Library 26.1.0 and later already implement the interface.\n\nIf you have a custom class that you would like to make a , you can use the LifecycleRegistry class, but you need to forward events into that class, as shown in the following code example:\n• Keep your UI controllers (activities and fragments) as lean as possible. They should not try to acquire their own data; instead, use a to do that, and observe a object to reflect the changes back to the views.\n• Try to write data-driven UIs where your UI controller’s responsibility is to update the views as data changes, or notify user actions back to the .\n• Put your data logic in your class. should serve as the connector between your UI controller and the rest of your app. Be careful though, it isn't 's responsibility to fetch data (for example, from a network). Instead, should call the appropriate component to fetch the data, then provide the result back to the UI controller.\n• Use Data Binding to maintain a clean interface between your views and the UI controller. This allows you to make your views more declarative and minimize the update code you need to write in your activities and fragments. If you prefer to do this in the Java programming language, use a library like Butter Knife to avoid boilerplate code and have a better abstraction.\n• If your UI is complex, consider creating a presenter class to handle UI modifications. This might be a laborious task, but it can make your UI components easier to test.\n• Avoid referencing a or context in your . If the outlives the activity (in case of configuration changes), your activity leaks and isn't properly disposed by the garbage collector.\n• Use Kotlin coroutines to manage long-running tasks and other operations that can run asynchronously.\n\nLifecycle-aware components can make it much easier for you to manage lifecycles in a variety of cases. A few examples are:\n• Switching between coarse and fine-grained location updates. Use lifecycle-aware components to enable fine-grained location updates while your location app is visible and switch to coarse-grained updates when the app is in the background. , a lifecycle-aware component, allows your app to automatically update the UI when your user changes locations.\n• Stopping and starting video buffering. Use lifecycle-aware components to start video buffering as soon as possible, but defer playback until app is fully started. You can also use lifecycle-aware components to terminate buffering when your app is destroyed.\n• Starting and stopping network connectivity. Use lifecycle-aware components to enable live updating (streaming) of network data while an app is in the foreground and also to automatically pause when the app goes into the background.\n• Pausing and resuming animated drawables. Use lifecycle-aware components to handle pausing animated drawables when the app is in the background and resume drawables after the app is in the foreground.\n\nWhen a belongs to an or , the 's state changes to and the event is dispatched when the or 's is called.\n\nWhen a or 's state is saved via , it's UI is considered immutable until is called. Trying to modify the UI after the state is saved is likely to cause inconsistencies in the navigation state of your application which is why throws an exception if the app runs a after state is saved. See for details.\n\nprevents this edge case out of the box by refraining from calling its observer if the observer's associated isn't at least . Behind the scenes, it calls before deciding to invoke its observer.\n\nUnfortunately, 's method is called after , which leaves a gap where UI state changes are not allowed but the has not yet been moved to the state.\n\nTo prevent this issue, the class in version and lower mark the state as without dispatching the event so that any code that checks the current state gets the real value even though the event isn't dispatched until is called by the system.\n\nUnfortunately, this solution has two major problems:\n• On API level 23 and lower, the Android system actually saves the state of an activity even if it is partially covered by another activity. In other words, the Android system calls but it doesn't necessarily call . This creates a potentially long interval where the observer still thinks that the lifecycle is active even though its UI state can't be modified.\n• Any class that wants to expose a similar behavior to the class has to implement the workaround provided by version and lower.\n\nTo learn more about handling lifecycles with lifecycle-aware components, consult the following additional resources."
    },
    {
        "link": "https://stackoverflow.com/questions/70892236/android-12-api-31-fragment-not-being-destroyed-when-going-in-background",
        "document": "I'm having this issue with my fragment only in API 31. In the host I use to add my fragment:\n\nEverything runs as expected. But when I send the app in background in API 31 the fragment's lifecycle doesn't evolve as I was thinking. It doesn't call . It only goes till . Meanwhile, in previous versions of Android the fragment gets completely destroyed when I send the app to background.\n\nAnyone else experiencing this problem?"
    },
    {
        "link": "https://developer.android.com/training/data-storage/sqlite",
        "document": "Stay organized with collections Save and categorize content based on your preferences.\n\nSaving data to a database is ideal for repeating or structured data, such as contact information. This page assumes that you are familiar with SQL databases in general and helps you get started with SQLite databases on Android. The APIs you'll need to use a database on Android are available in the package.\n\nCaution: Although these APIs are powerful, they are fairly low-level and require a great deal of time and effort to use:\n• There is no compile-time verification of raw SQL queries. As your data graph changes, you need to update the affected SQL queries manually. This process can be time consuming and error prone.\n• You need to use lots of boilerplate code to convert between SQL queries and data objects. For these reasons, we highly recommended using the Room Persistence Library as an abstraction layer for accessing information in your app's SQLite databases.\n\nOne of the main principles of SQL databases is the schema: a formal declaration of how the database is organized. The schema is reflected in the SQL statements that you use to create your database. You may find it helpful to create a companion class, known as a contract class, which explicitly specifies the layout of your schema in a systematic and self-documenting way.\n\nA contract class is a container for constants that define names for URIs, tables, and columns. The contract class allows you to use the same constants across all the other classes in the same package. This lets you change a column name in one place and have it propagate throughout your code.\n\nA good way to organize a contract class is to put definitions that are global to your whole database in the root level of the class. Then create an inner class for each table. Each inner class enumerates the corresponding table's columns.\n\nNote: By implementing the interface, your inner class can inherit a primary key field called that some Android classes such as expect it to have. It's not required, but this can help your database work harmoniously with the Android framework.\n\nFor example, the following contract defines the table name and column names for a single table representing an RSS feed:\n\nOnce you have defined how your database looks, you should implement methods that create and maintain the database and tables. Here are some typical statements that create and delete a table:\n\nJust like files that you save on the device's internal storage, Android stores your database in your app's private folder. Your data is secure, because by default this area is not accessible to other apps or the user.\n\nThe class contains a useful set of APIs for managing your database. When you use this class to obtain references to your database, the system performs the potentially long-running operations of creating and updating the database only when needed and not during app startup. All you need to do is call or .\n\nNote: Because they can be long-running, be sure that you call or in a background thread. See Threading on Android for more information.\n\nTo use , create a subclass that overrides the and callback methods. You may also want to implement the or methods, but they are not required.\n\nFor example, here's an implementation of that uses some of the commands shown above:\n\nTo access your database, instantiate your subclass of :\n\nInsert data into the database by passing a object to the method:\n\nThe first argument for is simply the table name.\n\nThe second argument tells the framework what to do in the event that the is empty (i.e., you did not any values). If you specify the name of a column, the framework inserts a row and sets the value of that column to null. If you specify , like in this code sample, the framework does not insert a row when there are no values.\n\nThe methods returns the ID for the newly created row, or it will return -1 if there was an error inserting the data. This can happen if you have a conflict with pre-existing data in the database.\n\nTo read from a database, use the method, passing it your selection criteria and desired columns. The method combines elements of and , except the column list defines the data you want to fetch (the \"projection\"), rather than the data to insert. The results of the query are returned to you in a object.\n\nThe third and fourth arguments ( and ) are combined to create a WHERE clause. Because the arguments are provided separately from the selection query, they are escaped before being combined. This makes your selection statements immune to SQL injection. For more detail about all arguments, see the reference.\n\nTo look at a row in the cursor, use one of the move methods, which you must always call before you begin reading values. Since the cursor starts at position -1, calling places the \"read position\" on the first entry in the results and returns whether or not the cursor is already past the last entry in the result set. For each row, you can read a column's value by calling one of the get methods, such as or . For each of the get methods, you must pass the index position of the column you desire, which you can get by calling or . When finished iterating through results, call on the cursor to release its resources. For example, the following shows how to get all the item IDs stored in a cursor and add them to a list:\n\nTo delete rows from a table, you need to provide selection criteria that identify the rows to the method. The mechanism works the same as the selection arguments to the method. It divides the selection specification into a selection clause and selection arguments. The clause defines the columns to look at, and also allows you to combine column tests. The arguments are values to test against that are bound into the clause. Because the result isn't handled the same as a regular SQL statement, it is immune to SQL injection.\n\nThe return value for the method indicates the number of rows that were deleted from the database.\n\nWhen you need to modify a subset of your database values, use the method.\n\nUpdating the table combines the syntax of with the syntax of .\n\nThe return value of the method is the number of rows affected in the database.\n\nSince and are expensive to call when the database is closed, you should leave your database connection open for as long as you possibly need to access it. Typically, it is optimal to close the database in the of the calling Activity.\n\nThe Android SDK includes a shell tool that allows you to browse table contents, run SQL commands, and perform other useful functions on SQLite databases. For more information, see how to how to issue shell commands."
    },
    {
        "link": "https://developer.android.com/topic/performance/sqlite-performance-best-practices",
        "document": "Stay organized with collections Save and categorize content based on your preferences.\n\nAndroid offers built-in support for SQLite, an efficient SQL database. Follow these best practices to optimize your app's performance, ensuring it remains fast and predictably fast as your data grows. By using these best practices, you also reduce the possibility of encountering performance issues that are difficult to reproduce and troubleshoot.\n• None Read fewer rows and columns: Optimize your queries to retrieve only the necessary data. Minimize the amount of data read from the database, because excess data retrieval can impact performance.\n• None Push work to SQLite engine: Perform computations, filtering, and sorting operations within the SQL queries. Using SQLite's query engine can significantly improve performance.\n• None Modify the database schema: Design your database schema to help SQLite construct efficient query plans and data representations. Properly index tables and optimize table structures to enhance performance.\n\nAdditionally, you can use the available troubleshooting tools to measure the performance of your SQLite database to help identify areas that require optimization.\n\nWe recommend using the Jetpack Room library.\n\nFollow the steps in this section to configure your database for optimal performance in SQLite.\n\nSQLite implements mutations by appending them to a log, which it occasionally compacts into the database. This is called Write-Ahead Logging (WAL).\n\nEnable WAL unless you are using .\n\nWhen using WAL, by default every commit issues an to help ensure that the data reaches the disk. This improves data durability but slows down your commits.\n\nSQLite has an option to control synchronous mode. If you enable WAL, set synchronous mode to :\n\nIn this setting, a commit can return before the data is stored in a disk. If a device shutdown occurs, such as on loss of power or a kernel panic, the committed data might be lost. However, because of logging, your database isn't corrupted.\n\nIf only your app crashes, your data still reaches the disk. For most apps, this setting yields performance improvements at no material cost.\n\nTo optimize performance and minimize data consumption, define an efficient table schema. SQLite constructs efficient query plans and data, leading to faster data retrieval. This section provides best practices for creating table schemas.\n\nFor this example, define and populate a table as follows:\n\nThe table output is as follows:\n\nThe column is an index that preserves insertion order. Queries that filter by are implemented as a fast B-tree search, but queries that filter by are a slow table scan.\n\nIf you plan on doing lookups by , you can avoid storing the column for less data in storage and an overall faster database:\n\nYour table now looks as follows:\n\nSince you don't need to store the column, queries are fast. Note that the table is now sorted based on instead of insertion order.\n\nSQLite uses indexes to accelerate queries. When filtering ( ), sorting ( ), or aggregating ( ) a column, if the table has an index for the column, the query is accelerated.\n\nIn the previous example, filtering by requires scanning the entire table:\n\nFor an app with a lot of city queries, you can accelerate those queries with an index:\n\nAn index is implemented as an additional table, sorted by the index column and mapped to :\n\nNote that the storage cost of the column is now double, because it's now present in both the original table and the index. Since you are using the index, the cost of added storage is worth the benefit of faster queries. However, don't maintain an index that you're not using to avoid paying the storage cost for no query performance gain.\n\nIf your queries combine multiple columns, you can create multi-column indexes to fully accelerate the query. You can also use an index on an outside column and let the inside search be done as a linear scan.\n\nFor instance, given the following query:\n\nYou can accelerate the query with a multi-column index in the same order as specified in the query:\n\nHowever, if you only have an index on , the outside ordering is still accelerated, while the inside ordering requires a linear scan.\n\nThis also works with prefix inquiries. For example, an index also accelerates filtering, ordering, and grouping by , since the index table for a multi-column index is ordered by the given indexes in the given order.\n\nBy default, SQLite creates a column for your table, where is an implicit . If you already have a column that is , then this column becomes an alias of .\n\nFor tables that have a primary key other than or a composite of columns, consider .\n\nStore small data as a and large data as a file\n\nIf you want to associate large data with a row, such as a thumbnail of an image or a photo for a contact, you can store the data either in a column or in a file, and then store the file path in the column.\n\nFiles are generally rounded up to 4 KB increments. For very small files, where the rounding error is significant, it's more efficient to store them in the database as a . SQLite minimizes filesystem calls and is faster than the underlying filesystem in some cases.\n\nFollow these best practices to improve query performance in SQLite by minimizing response times and maximizing processing efficiency.\n\nRead only the rows you need\n\nFilters let you narrow down your results by specifying certain criteria, such as date range, location, or name. Limits let you control the number of results you see:\n\nRead only the columns you need\n\nAvoid selecting unneeded columns, which can slow down your queries and waste resources. Instead, only select columns that are used.\n\nIn the following example, you select , , and :\n\nHowever, you only need the column:\n\nParameterize queries with SQL Cards, not with String concatenation\n\nYour query string might include a parameter that is only known at runtime, such as the following:\n\nIn the preceding code, every query constructs a different string, and thus doesn't benefit from the statement cache. Each call requires SQLite to compile it before it can execute. Instead, you can replace the argument with a parameter and bind the value with :\n\nNow the query can be compiled once and cached. The compiled query is reused between different invocations of .\n\nIterate in SQL, not in code\n\nUse a single query that returns all targeted results, instead of a programmatic loop iterating on SQL queries to return individual results. The programmatic loop is about 1000 times slower than a single SQL query.\n\nUsing the keyword can improve the performance of your queries by reducing the amount of data that needs to be processed. For example, if you want to return only the unique values from a column, use :\n\nUse aggregate functions whenever possible\n\nUse aggregate functions for aggregate results without row data. For example, the following code checks whether there is at least one matching row:\n\nTo only fetch the first row, you can use to return if a matching row does not exist and if one or more rows match:\n\nUse SQLite aggregate functions in your app code:\n• : counts how many rows are in a column.\n• or : determines the lowest or highest value. Works for numeric columns, types, and text types.\n\nUse instead of\n\nIn the following example, the function reads all the rows from the database and returns all the row values:\n\nHowever, by using , the database returns only the count:\n\nSQL is composable and supports subqueries, joins, and foreign key constraints. You can use the result of one query in another query without going through app code. This reduces the need to copy data from SQLite and lets the database engine optimize your query.\n\nIn the following example, you can run a query to find which city has the most customers, then use the result in another query to find all the customers from that city:\n\nTo get the result in half the time of the previous example, use a single SQL query with nested statements:\n\nIf a row must not be inserted unless a particular column value is unique in the table, then it might be more efficient to enforce that uniqueness as a column constraint.\n\nIn the following example, one query is run to validate the row to be inserted and another to actually insert:\n\nInstead of checking the unique constraint in Kotlin or Java, you can check it in SQL when you define the table:\n\nSQLite does the same as the following:\n\nNow you can insert a row and let SQLite check the constraint:\n\nSQLite validates constraints faster and with less overhead than Kotlin or Java code. It is a best practice to use SQLite rather than app code.\n\nA transaction commits multiple operations, which improves not only efficiency but also correctness. To improve data consistency and accelerate performance, you can batch insertions:\n\nSQLite provides the following troubleshooting tools to help measure performance.\n\nRun SQLite on your machine to run queries and learn. Different Android platform versions use different revisions of SQLite. To use the same engine that's on an Android-powered device, use and run on your target device.\n\nYou can ask SQLite to time queries:\n\nYou can ask SQLite to explain how it intends to answer a query by using :\n\nThe previous example requires a full table scan without an index to find all customers from Paris. This is called linear complexity. SQLite needs to read all the rows and only keep the rows that match customers from Paris. To fix this, you can add an index:\n\nIf you're using the interactive shell, you can ask SQLite to always explain query plans:\n\nFor more information, see Query Planning.\n\nSQLite offers the command-line interface (CLI) to dump additional information that can be used to troubleshoot performance. To install, visit the SQLite Download Page.\n\nYou can use to download a database file from a target device to your workstation for analysis:\n\nYou can also install the GUI tool SQLite Browser on the SQLite Downloads page.\n\nAndroid times SQLite queries and logs them for you:\n\nWhen configuring Perfetto, you may add the following to include tracks for individual queries:"
    },
    {
        "link": "https://medium.com/@shivani.patel18/a-comprehensive-guide-to-sqlite-databases-in-android-development-df74f01df6c3",
        "document": "In the world of Mobile app development, data persistence is a fundamental aspect. Whether you are building a to-do list app, a note-taking app, or a complex e-commerce platform, the need to store and manage data efficiently arises in almost every application. SQLite, a lightweight and efficient relational database, is the go-to choice for many Android developers due to its simplicity and robustness.\n\nSQLite is an open-source relational database i.e. used to perform database operations on android devices such as storing, manipulating or retrieving persistent data from the database. It is embedded in android by default. So, there is no need to perform any database setup or administration task.\n\nThis article helps to provide a comprehensive guide to working with SQLite databases in Android development. We will cover the following topics:\n• Why Use SQLite in Android?\n\nSQLite is a self-contained, serverless, and transactional SQL database engine. It is embedded into the Android operating system, making it an ideal choice for local data storage in Android applications. SQLite databases are lightweight, efficient, and easy to use, making them a popular choice for developers.\n\n2. Why Use SQLite in Android?\n\nThere are several reasons why SQLite is a preferred choice for data storage in Android applications:\n• Lightweight: SQLite is designed to be lightweight and has a small footprint, making it suitable for mobile devices with limited resources.\n• Reliability: It is ACID compliant (Atomicity, Consistency, Isolation, Durability), ensuring data integrity and reliability.\n• Speed: SQLite operations are fast, and it provides efficient indexing mechanisms for quick data retrieval.\n• Compatibility: SQLite is built into the Android OS, so you don’t need to include additional libraries in your app.\n• No Network Dependency: Unlike client-server databases, SQLite doesn’t require a network connection, making it ideal for offline applications.\n\nTo start using SQLite in your Android project, follow these steps:\n• Create a Database Helper Class: Create a subclass of to manage database creation, version management, and connection.\n\n2. Initialize the Database: Open or create the database in your app’s method.\n\nTo create a SQLite database, you need to define its structure using SQL statements. Use the method of your subclass to execute these statements. Here's a simple example:\n\nSQLiteOpenHelper class provides the functionality to use the SQLite database.\n\nSQLite supports all the standard CRUD (Create, Read, Update, Delete) operations. Here’s a brief overview:\n• Create: Use the statement to add new records to the database.\n• Read: Use the statement to retrieve data from the database.\n• Update: Use the statement to modify existing records.\n• Delete: Use the statement to remove records.\n\nThe class is used for database creation and version management. It helps you handle upgrades and downgrades of your database schema. For performing any database operation, you have to provide the implementation of onCreate() and onUpgrade() methods of SQLiteOpenHelper class.\n\nThere are two constructors of SQLiteOpenHelper class.\n\n→ SQLiteOpenHelper(Context context, String name, SQLiteDatabase.CursorFactory factory, int version) :- creates an object for creating, opening and managing the database.\n\n→ SQLiteOpenHelper(Context context, String name, SQLiteDatabase.CursorFactory factory, int version, DatabaseErrorHandler errorHandler) :- creates an object for creating, opening and managing the database. It specifies the error handler.\n• public abstract void onCreate(SQLiteDatabase db) :- called only once when database is created for the first time.\n• public abstract void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) :- called when database needs to be upgraded.\n• public void onDowngrade(SQLiteDatabase db, int oldVersion, int newVersion) :- called when database needs to be downgraded.\n• Always use parameterized queries to prevent SQL injection.\n• Avoid opening and closing the database frequently; instead, use a singleton pattern for database access.\n• Handle database operations on a background thread to avoid blocking the UI thread.\n• Monitor and optimize database queries for performance using tools like Android Profiler.\n\nLet’s see the simple example of android sqlite database.\n\nNow, let’s create the database handler class that extends SQLiteOpenHelper class and provides the implementation of its methods.\n\npublic class DatabaseHandler extends SQLiteOpenHelper {\n\n private static final int DATABASE_VERSION = 1;\n\n private static final String DATABASE_NAME = \"studentlist\";\n\n private static final String TABLE_STUDENTS = \"students\";\n\n private static final String KEY_ID = \"id\";\n\n private static final String KEY_NAME = \"name\";\n\n\n\n public DatabaseHandler(Context context) {\n\n super(context, DATABASE_NAME, null, DATABASE_VERSION);\n\n //3rd argument to be passed is CursorFactory instance\n\n }\n\n\n\n // Creating Tables\n\n @Override\n\n public void onCreate(SQLiteDatabase db) {\n\n String CREATE_STUDENTS_TABLE = \"CREATE TABLE \" + TABLE_STUDENTS + \"(\"\n\n + KEY_ID + \" INTEGER PRIMARY KEY,\" \n\n + KEY_NAME + \" TEXT\"\n\n + \")\";\n\n db.execSQL(CREATE_STUDENTS_TABLE);\n\n }\n\n \n\n // Upgrading database\n\n @Override\n\n public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {\n\n // Drop older table if existed\n\n db.execSQL(\"DROP TABLE IF EXISTS \" + TABLE_STUDENTS);\n\n\n\n // Create tables again\n\n onCreate(db);\n\n }\n\n\n\n // code to add the new student\n\n void addStudent(StudentList student) {\n\n SQLiteDatabase db = this.getWritableDatabase();\n\n\n\n ContentValues values = new ContentValues();\n\n values.put(KEY_NAME, student.getName()); // studentName\n\n\n\n // Inserting Row\n\n db.insert(TABLE_STUDENTS, null, values);\n\n //2nd argument is String containing nullColumnHack\n\n db.close(); // Closing database connection\n\n }\n\n\n\n // code to get the single student\n\n StudentList getStudent(int id) {\n\n SQLiteDatabase db = this.getReadableDatabase();\n\n\n\n Cursor cursor = db.query(TABLE_STUDENTS, \n\n new String[] { KEY_ID, KEY_NAME}, KEY_ID + \"=?\",\n\n new String[] { String.valueOf(id) }, \n\n null, null, null, null);\n\n if (cursor != null)\n\n cursor.moveToFirst();\n\n\n\n StudentList studentList = new StudentList(Integer.parseInt(cursor.getString(0)),\n\n cursor.getString(1), \n\n cursor.getString(2));\n\n // return studentList\n\n return studentList;\n\n }\n\n\n\n\n\n // code to get all student in a list view\n\n public List<StudentList> getAllStudentList() {\n\n List<StudentList> studentList = new ArrayList<StudentList>();\n\n // Select All Query\n\n String selectQuery = \"SELECT * FROM \" + TABLE_STUDENTS;\n\n\n\n SQLiteDatabase db = this.getWritableDatabase();\n\n Cursor cursor = db.rawQuery(selectQuery, null);\n\n\n\n // looping through all rows and adding to list\n\n if (cursor.moveToFirst()) {\n\n do {\n\n StudentList student = new StudentList();\n\n student.setID(Integer.parseInt(cursor.getString(0)));\n\n student.setName(cursor.getString(1));\n\n // Adding student to list\n\n studentList.add(student);\n\n } while (cursor.moveToNext());\n\n }\n\n\n\n // return student list\n\n return studentList;\n\n }\n\n\n\n // code to update the single student\n\n public int updateStudent(StudentList student) {\n\n SQLiteDatabase db = this.getWritableDatabase();\n\n\n\n ContentValues values = new ContentValues();\n\n values.put(KEY_NAME, student.getName());\n\n\n\n // updating row\n\n return db.update(TABLE_STUDENTS, values, KEY_ID + \" = ?\",\n\n new String[] { String.valueOf(student.getID()) });\n\n }\n\n\n\n\n\n // Deleting single student\n\n public void deleteStudent(StudentList student) {\n\n SQLiteDatabase db = this.getWritableDatabase();\n\n db.delete(TABLE_STUDENTS, KEY_ID + \" = ?\",\n\n new String[] { String.valueOf(student.getID()) });\n\n db.close();\n\n }\n\n\n\n\n\n // Getting student Count\n\n public int getStudentListCount() {\n\n String countQuery = \"SELECT * FROM \" + TABLE_STUDENTS;\n\n SQLiteDatabase db = this.getReadableDatabase();\n\n Cursor cursor = db.rawQuery(countQuery, null);\n\n cursor.close();\n\n\n\n // return count\n\n return cursor.getCount();\n\n }\n\n\n\n}\n\nIn the main activity of the app, call the function to initialize the DB\n\nSQLite is a powerful and reliable choice for managing local data storage in Android applications. Understanding how to create and manipulate SQLite databases is a valuable skill for any Android developer. By following the best practices outlined in this guide, you can ensure your Android apps perform efficiently and provide a seamless user experience.\n\nIncorporate SQLite into your Android projects, experiment with different database structures, and leverage the flexibility it offers to create data-driven applications that meet your users’ needs. Happy coding!"
    },
    {
        "link": "https://stackoverflow.com/questions/56674777/how-to-store-and-retrieve-data-for-a-particular-user-using-sqlite-in-android",
        "document": "You appear to need a relationship between a Note (child) and it's user (parent). Assuming that a Note will have just one user (who owns the note). Then you could add a column to the table where you store the Notes.\n\nAs the User table has the id column defined using this column is an ideal candidate for the relationship (it is indexed and also unique (implicitly)). It will be an integer value (potentially long in java).\n\nTo be consistent you'd want to define a constant for the column name so add :-\n\nYou could then define change the CREATE_TABLE_NOTE constant to include\n\nOr, if you may want to introduce FOREIGN KEY constraints and use\n• refer to SQLite Foreign Key Support for more about foreign keys\n\nYou would make a complimentary change to the Notes class/object to store the id of the user (the map/relationship) (preferably as a long) of the owning user in the class and add a getter and a setter for the id of the user. You should also have a constructor that includes the id of the user for use when retrieving a Note from the database.\n\nYou would then need to make changes to the DBHelper's methods to cater for the extra column. e.g.\n\nThe insertNote method could become :-\n\nThe getNotes method could become :-\n• Note the above assumes the constructor has the value for the user mapping as the last.\n• Note checking a Cursor for null is useless, it will never be null when returned from an SQliteDatabase method. Hence the above uses the result from the moveToFirst method to determing if a row exists or not.\n• Note the above will return null (rather than failing) should the Note not be found.\n\nAfter the above then you can write a query that includes a WHERE clause based upon the usermap column.\n• Note the simpler while loop i.e. as the moveToNext method returns false when the move cannot be made (i.e. when at after last row) then there is no need to moveToFirst as it will do that for the first row.\n\nNote the above is in-principle code. It has not been tested nor has it been run, it may therefore contain some errors. It has been provided as a guide.\n\nThe following is a basic working example based upon your code and the above answer. Additionally an additional column has been added to the name table for the name of the user.\n\nThe App adds two users (Fred and Mary) and then adds 2 notes for each user. It then extracts all notes and then all notes for Fred and then for Mary. The 3 sets of extracted output are then output to the log.\n\nFor All Notes for All users:-\n• Note the addition that overides the onConfigure method, this turns ForeignKey support on (otherwise the Foreign Key definitions are ignored).\n• Note AUTOINCREMENT has been removed, it is not necessary and has overheads.\n• Note the addition of the name column for the name table and that it has a unqiue constraint.\n\nThis brings it all together\n• Note that the above is only intended to be run once. If subsequently run both the id's for Fred and Mary will be -1 as the rows will not be added due to the duplicate name and hence there will be no notes extracted into fredsnotes and marynotes."
    },
    {
        "link": "https://nutshellapp.com/publicsummaries/utilizing-sqlite-for-local-data-storage-in-android-applications",
        "document": "In a detailed tutorial presented by Chad Slutter, a distinguished professor at Grand Canyon University, the intricacies of utilizing SQLite for local data storage in Android applications are explored. The tutorial sheds light on the significance of preserving data locally, the myriad advantages of employing SQLite over online services, and the diverse range of data that can be housed within SQLite databases. Chad delves into the process of creating tables, harnessing cursors, and manipulating content values within SQLite, offering a comprehensive guide for developers. The tutorial further extends to the creation of an Android application that seamlessly integrates SQLite for local data storage. \n\n\n\nThe tutorial commences by elucidating the steps involved in crafting a layout for an Android app, encompassing the addition of essential components such as text fields, buttons, and a list view. Emphasizing the utilization of string resources over hardcoded text values, Chad underscores the importance of maintaining a scalable and adaptable approach to app development. Furthermore, the tutorial showcases the creation of a model class tailored for storing customer data, complete with properties like name, age, and activity status. Chad meticulously outlines the process of establishing constructors, getters, setters, and a toString method for the class, ensuring a robust foundation for data management. \n\n\n\nThe discussion progresses to elucidate the generation of a string using the toString method, the implementation of listeners for button clicks, the instantiation of a customer object, error handling strategies, and the preparation for data storage in a SQLite database within an Android application. Chad meticulously guides developers through the creation of a SQLite database within an Android app, focusing on key components such as the SQLite library, SQLiteOpenHelper class, and essential CRUD operations. The tutorial elucidates the process of database creation and updates, the integration of onCreate and onUpgrade methods, and the seamless management of database schema alterations. \n\n\n\nMoreover, the tutorial delves into the creation of tables using SQL statements, leveraging the DatabaseHelper class to streamline database operations within Android Studio. Chad emphasizes the importance of defining constants for column names in a database table, facilitating efficient data insertion processes. By creating static variables for column names and leveraging a database helper class, developers can seamlessly add data to the database and handle insertion outcomes effectively. The tutorial further explores the process of inserting data into a SQLite database within an Android app, verifying its success, and navigating database files using tools like DB Browser for SQLite. \n\n\n\nThe article also touches upon the creation of a list view to showcase database entries within the app, enhancing user interaction and data visibility. Chad elucidates the use of ternary operators in programming, particularly in Java, to streamline if-else statements and enhance code readability. By providing insightful examples and practical applications, developers can grasp the utility of ternary operators in optimizing code efficiency. Additionally, the tutorial covers essential aspects such as SQLite database operations, error handling mechanisms, and the creation of a list adapter in Android for a more user-friendly data display. \n\n\n\nThe tutorial culminates in a discussion on code refactoring to enhance efficiency and functionality within an Android application leveraging SQLite. Chad guides developers through the creation of methods for adding, displaying, and deleting data from a SQLite database, fostering a structured and organized approach to data management. By refactoring code to consolidate functions and implementing a unified method for updating a list view, developers can streamline app performance. The tutorial also highlights the significance of implementing a delete function to remove database entries, ensuring data integrity and user experience. Lastly, Chad mentions the utility of Object Relational Mappers (ORMs) like Room to simplify database operations in Android, offering a glimpse into advanced database management techniques.\n\nChad Slutter, a professor of computer science and software development at Grand Canyon University in Phoenix, is conducting a tutorial on how to use SQLite, Android's database system for local storage. He emphasizes the importance of Free Code Camp as a valuable resource for learning. The tutorial aims to create an application demonstrating the use of SQLite for storing various types of data locally. It prompts developers to consider where to save data when designing an app, highlighting the option of using SQLite for local storage. Developers have multiple options for saving data, including local storage, online services, or a hybrid approach. They can work with API services, set up SQL servers online, or use instant service databases like Google's Firebase or Microsoft's services. Saving data to a local database offers fast performance, offline access, and efficient autocomplete functionality. It ensures that users can access certain data even without cell phone service and enables quick database lookups for autocomplete suggestions. SQLite is a single-file, embedded database similar to Microsoft Access, designed for individual users. It is part of the Android system, requires no installation, and follows ACID compliance to prevent data corruption during transactions. SQLite databases are lightweight, ensuring quick performance. All methods must close connections to avoid locking up the database. Read-only queries can be performed without worrying about simultaneous access. Tables and databases can be created within the application itself, eliminating the need for third-party tools like MySQL Workbench. SQLite databases support limited data types: null, integers, real numbers, text (including long and short text), and blobs. It is recommended to avoid using blobs for large files like images or movies; instead, store them in a directory and link to them in the database to keep the database size small. Specific SQLite library methods include creating instances of the SQLite database, using SQL helper to automatically create databases when required, opening or creating databases, creating tables with specified properties, executing queries, working with cursors to iterate through result sets, and using content values for key-value pairs insertion. Content values in SQLite function like an associative array or hash map, allowing key-value pairs to be inserted into the database. This feature simplifies the insertion process by automatically associating column names with their respective values. The application allows viewing all entries, adding new entries (e.g., Jeff, age 7, active customer), and deleting entries. The demonstration showcases the functionality of SQLite databases within the application, providing a step-by-step guide for users interested in implementing SQLite databases. The tutorial focuses on setting up Android Studio with a SQLite database to save data locally on a device. The app demonstration shows adding a name and age, which then gets listed. It highlights the background SQL database operation. The tutorial will cover setting up the layout, buttons, and list view in the first video. Subsequent videos will focus on managing data classes and working with the database. The tutorial begins with adding the layout to the application, showcasing the components like edit texts, switches, buttons, and list views. The speaker launches Android Studio version 3.5.3, starts a new project named 'sql demo' in Java with a minimum API level of 14, and opts not to use AndroidX artifacts. The speaker removes the default 'hello world' content, adds text fields, sets constraints, and arranges components like buttons on the screen. The speaker emphasizes using descriptive IDs like 'et_name' for components and utilizing string resources for text values to avoid hardcoding. A new field named 'customer name' has been added under the resources values and strings section. Selecting a number attribute for the customer's age, setting constraints from top to bottom, anchoring to the front and back, adjusting width to match constraints, and labeling it as 'age'. Planning to use multiple data types for the database - string for one field, integer for age, and a boolean field. Adding a switch for 'active customer' and standard buttons for actions. Aligning and spacing buttons on the screen, ensuring equidistance between them by manually adjusting constraints in the XML code. Changing IDs for elements like edit text, switch, and buttons to have consistent prefixes and meaningful names for better organization and clarity. Using a legacy list view for simplicity in the tutorial, noting that a more efficient option is the recycler view for faster performance. Adding constraints to the layout by positioning elements to the bottom, left, and right sides of the screen, ensuring proper alignment and structure. Choosing constraint end to the end of the parent element to establish proper layout constraints for the controls on the screen. Assigning an ID 'l view' to the customer list view element to uniquely identify it within the layout. Transitioning from layout creation to model creation in the Android app development process, focusing on creating a data model for the application. Generating a Java class named 'CustomerModel' to hold data for customer objects, including properties like name, age, is active status, and an ID number. Implementing constructors in the 'CustomerModel' class to initialize customer objects with parameters for ID, name, age, and active status, along with a non-parameterized constructor for flexibility. Generating getters and setters for the properties of the 'CustomerModel' class to access and modify the object's attributes as needed. Creating a 'toString' method in the 'CustomerModel' class to generate a string representation of the object's properties for logging, messaging, or display purposes. The speaker mentions setting up a layout and a class in the application development process. The speaker introduces the continuation of an application demonstrating SQLite database in Android Studio. The speaker discusses creating listeners for button clicks in the application. The speaker explains the process of defining member variables for buttons, edit text, switch, and list view in the class. The speaker corrects the placement of member variables from inside the onCreate method to the class level for accessibility. The speaker demonstrates assigning values to variables using findViewById method in the onCreate method. The speaker explains the process of setting click listeners for buttons in the application, preferring a self-contained method. The speaker tests the functionality of button click listeners by displaying toast messages for each button click. The speaker encounters issues with the 'View All' button on the layout, initially not functioning correctly. After making adjustments and saving, the button starts working as intended. Instead of just displaying a toast message, the speaker decides to create a customer object. They proceed to instantiate a new customer using the constructor, setting values for properties like ID, name, age, and active status. While setting the age property for the customer object, the speaker encounters a data type mismatch error. They resolve this by converting the age value from a string to an integer using the 'parseInt' method. The speaker demonstrates how leaving the age field blank causes the application to crash due to a data conversion error. They identify the issue in the code and consider implementing error handling techniques like 'try and catch' to prevent future crashes. The speaker discusses the try and catch blocks in Java, explaining that the try block is used to test a block of code for errors. If an error occurs, it jumps to the catch block. In this case, the speaker is trying to create a customer and handle any exceptions that may arise. The speaker emphasizes the importance of preventing users from damaging the application. They highlight the need to implement error handling mechanisms to safeguard the app from crashing and ensure a smooth user experience. The speaker introduces the topic of setting up a SQLite database in an Android application. They explain that in Android, database creation and management are done within the code itself, using classes like SQLiteDatabase and SQLiteOpenHelper. The speaker delves into the process of managing a SQLite database in Android. They mention that most database operations are performed through code, including creating and updating the database. Tools like SQL Workbench are available but not necessary for Android development. The speaker explains the concept of CRUD operations (Create, Read, Update, Delete) in SQLite databases. They mention that these operations are essential for interacting with the database, such as retrieving customer data, searching, deleting, and inserting records. The speaker demonstrates how to implement database operations in Android Studio. They show the process of creating a database helper class, defining table structures, and executing SQL statements to perform operations like creating tables and managing database interactions. To implement inheritance in Android development, the keyword 'extends' is used. In this case, a new class named 'SQLiteOpenHelper' is being created. Android suggests implementing methods in 'SQLiteOpenHelper' due to inheritance, which requires the implementation of methods like 'onCreate' and 'onUpgrade'. The 'onCreate' method is called when accessing a database object for the first time, where it should contain code to generate a new table using SQL statements. On the other hand, the 'onUpgrade' method is triggered when the database version changes, allowing for schema modifications without crashing the application. In Android development, when extending a class, like 'SQLiteOpenHelper', a constructor must be implemented to satisfy the parent class's parameters. The 'SQLiteOpenHelper' class requires at least one constructor with parameters such as a context, database name, and version number. The file name for the factory is set to be null, and the version number can be one. The constructor for the new class is created by passing four parameters to the parent or super constructor. The application is required to provide the context for the constructor. In the upcoming videos, the database creation process will involve implementing the on create and on upgrade parts. These methods will be crucial for setting up the database. The ongoing demo focuses on creating a SQLite database in an Android app. The next step involves using SQL statements to create tables for storing data. The goal is to create a table that aligns with the values of the user model, which includes columns for name, age, and an active customer boolean. The Database Helper class has been implemented with a constructor specifying the database name. The next step involves using the on create method to define SQL statements for table creation. The process of creating a table begins by defining a string for the create table statement. This statement will be used to generate tables in the SQLite system. The SQL statement for creating a table includes defining the table name as 'customer_table' with columns like 'id' as the primary key with auto-increment. Static variables are used to simplify repetitive table name references. Additional columns like 'customer name', 'customer age', and 'active state' are defined for the table. Static variables are created to streamline column name references. The speaker discusses the process of setting up constants such as age, active status, and an ID column in the database helper. By defining these constants, they aim to have a list of five different constants at the top of the page for easier reference. The speaker highlights the advantage of using constants instead of variable names repeatedly. They mention that while it may seem tedious initially, having constants becomes beneficial when generating more methods below. The speaker emphasizes the importance of correctly typing and invoking the database helper in the main application. They stress the need for accuracy to avoid potential problems in the application. The speaker explains the concept of context in Java and the significance of providing the correct context, especially when dealing with constructors that require parameters. They demonstrate the use of 'mainactivity.this' as the appropriate context reference. The speaker outlines the process of adding data to the database by creating a method named 'add1' that expects a new customer model as a parameter. They mention the use of 'sqlite database db' to get a writable database and 'content values' to facilitate data insertion. In Android Studio, values are associated with column names when passing data. For example, the customer column name is associated with the customer model value, the customer's age is linked to the column customer age, and the is active property is connected to the appropriate column. Auto increment columns in databases automatically generate unique values. In the context of the discussion, an ID column was not specified because it was an auto increment column. If a column is not auto increment, the specific value needs to be provided. The insert command in database operations requires parameters such as the table name, null column hack, and content values. The null column hack is optional and can be used to prevent inserting an empty row without specifying at least one column name. The null column hack is a concept in SQLite databases that allows for the insertion of data without naming a column. It is used to prevent inserting completely empty rows by requiring at least one column name or using null as a placeholder. In database operations, checking the success of an insertion is done by examining the return value of the insert command. A positive number indicates a successful insertion, while a negative number signifies a failure. To create a successful customer model, an assignment statement should be separate from the definition statement. If the creation of a customer fails, default values can be provided such as an id of -1, a name as 'error', an age of 0, and an active member status as false. To insert data into the database, the insert method can be called on the database helper class by using the add one method and providing the customer model as a parameter. A success indicator variable can be used to determine if the insertion was successful. After inserting data, the success indicator can be checked to see if the data was successfully inserted into the database. The database location can be accessed in Android Studio through the device file explorer to verify the database entry. Database files can be viewed using tools like 'db browser for sqlite' or 'sqlite studio'. These tools allow for the visualization of database structure, data manipulation, and creation of new records. The speaker introduces a SQL Lite demo for creating an Android app that saves data to a local database. The app allows viewing data on a list view. The speaker discusses creating a list view in the demo to display data from the database. The goal is to update the list every time a new record is added. The speaker explains the process of creating a method in the database helper to pull all items from the database. They emphasize defining the return type as a list of a specific model. The speaker demonstrates creating a SQL statement to select all items from the users and customers tables. They highlight the use of defined constants for table names. The speaker explains the importance of choosing a readable database over a writable one for selecting data. They discuss the implications of database locking and process efficiency. The speaker introduces the concept of a cursor in SQLite as the result set of a query. They explain how a cursor represents rows of data returned from a database query. The move to first function at 01:03:23 signifies moving to the first result in the result set. If the result is a boolean true value, indicating the presence of results, the query can continue. Otherwise, the else statement will execute. Before coding, the plan involves looping through results, creating a new customer object for each row, inserting it into the return list, and ensuring the function's success. A do while loop is introduced to iterate through lines until there are no new lines, ensuring the method's completion. The process involves retrieving data from the database, such as an ID number (integer), customer name, age, and converting an integer (0 or 1) to a boolean for 'is active' status. In SQL light, boolean values are stored as integers (0 or 1). To handle boolean data retrieval, a ternary operator is used to convert the integer to a boolean value for 'is active' status. The ternary operator is a compact form of an if-then-else statement, assigning values based on a true or false condition. It provides a concise way to handle conditional operations in programming. To create a user object, the required data objects are utilized, and a new user object is instantiated, ensuring the necessary information is captured for further processing. The constructor for a customer class includes four parameters: id, name, age, and is active. To add a new customer to the list, a function called add should be provided. In SQLite, it's essential to clean up after using a database by closing the cursor and database connections to allow others to use it. When encountering errors in a raw query, check the documentation for missing parameters and ensure correct usage of selection args. Selection args in a raw query can be set as null or empty when not working with prepared statements. An infinite loop issue in the application was caused by incorrectly using moveToFirst instead of moveToNext in the database loop. The speaker introduces the plan to enhance the database display in the app. They mention the current state of the app showing an 'ugly toast message' when clicking on the 'view all' button, and express the intention to make the display more user-friendly by turning it into a scrollable list on the main activity. The speaker discusses adding a new feature to the app related to displaying all people in the list when clicking the 'view all' button. They aim to replace the current toast message with a more visually appealing list display for better user interaction. The speaker explains the process of creating an ArrayAdapter for the app's display. They mention the use of a predefined adapter 'simple list item one' to show a string per line, and associate the ArrayAdapter with the 'customer list' control on the screen to display selected people from the database. The speaker addresses the need to enhance the ArrayAdapter functionality to automatically update the list without requiring the user to click 'view all' every time a new customer is added. They suggest defining the ArrayAdapter as a class member variable and initializing it in the onCreate method to display the customer list when the app is opened. The speaker discusses refactoring the database helper class by defining and moving variables to the top, making them class members, and creating a method to show customers on a list view. This refactoring process involves extracting code into a function named 'show customers on list view.' After refactoring the code, the speaker runs the application to test the functionality. Upon launching the program, all users in the database are displayed. Adding a new user, such as 'k,' results in successful addition and automatic updating of the list view. The speaker demonstrates the functionality by adding multiple users and verifying the list view updates accordingly. The speaker introduces the concept of creating a delete function in the SQLite application. The delete function is designed to remove a selected customer from the database, updating the list view automatically. The speaker outlines the process of defining the delete function as a boolean return type, where the function deletes the customer model if found and returns true, otherwise returning false. To start, the main activity involves designing SQLite to work efficiently. Best practices suggest having a Data Access Object (DAO) with all methods. The initial step is to obtain a writable database instance to delete data. A query is written to delete a record based on a parameter, such as a customer model's ID. A raw query is used to delete a record from the database. The query string is executed with null parameters. The result is a cursor type, indicating success if the cursor can move to the first item in the results. This approach ensures efficient deletion of specific data. In the main activity, the delete function is implemented. A method is needed to listen for a click event, specifically using setOnItemClickListener. This method distinguishes between different items clicked in a list view, enabling the deletion of a selected customer. While testing the application, an error occurred indicating that the database helper needed to be sent along as a parameter. After making the necessary adjustment, the app was successfully up and running. The user tested the deletion functionality by removing certain users from the database. Upon deletion, only the odd-numbered users remained, indicating that the delete function was working correctly. After successfully testing the delete function, the user proceeded to add a user named Beth back into the database. Beth was assigned the ID 632 and was marked as a non-customer. The user confirmed that the delete function for Beth was also working as expected. The user summarized the current state of the application, noting that it could add, display, and delete users. However, the user identified a missing feature: a search function to filter and display specific users based on search criteria. The user introduced the Room library, an object relational mapper (ORM) in Android that simplifies database management by generating SQL statements and handling various database details automatically. The user emphasized the importance of understanding SQL fundamentals before delving into Room. The user encouraged viewers to explore the Room library for Android development, highlighting its benefits in simplifying database operations. The user also mentioned having a tutorial on using Room with Android for further learning."
    }
]