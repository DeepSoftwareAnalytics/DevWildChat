[
    {
        "link": "https://realpython.com/fibonacci-sequence-python",
        "document": "The Fibonacci sequence is a pretty famous sequence of integer numbers. The sequence comes up naturally in many problems and has a nice recursive definition. Learning how to generate it is an essential step in the pragmatic programmer’s journey toward mastering recursion. In this tutorial, you’ll focus on learning what the Fibonacci sequence is and how to generate it using Python.\n\nIn this tutorial, you’ll learn how to:\n• Generate the Fibonacci sequence using an iterative algorithm\n\nTo get the most out of this tutorial, you should know the basics of Big O notation, object-oriented programming, Python’s special methods, conditional statements, functions, and basic data structures like lists, queues, and stacks. Having some familiarity with these concepts will greatly help you understand the new ones you’ll be exploring in this tutorial.\n\nGetting Started With the Fibonacci Sequence Leonardo Fibonacci was an Italian mathematician who was able to quickly produce an answer to this question asked by Emperor Frederick II of Swabia: “How many pairs of rabbits are obtained in a year, excluding cases of death, supposing that each couple gives birth to another couple every month and that the youngest couples are able to reproduce already at the second month of life?” The answer was the following sequence: The pattern begins after the first two numbers, 0 and 1, where each number in the sequence is always the sum of the two numbers before it. Indian mathematicians had known about this sequence since the sixth century, and Fibonacci leveraged it to calculate the growth of rabbit populations. F(n) is used to indicate the number of pairs of rabbits present in month n, so the sequence can be expressed like this: In mathematical terminology, you’d call this a recurrence relation, meaning that each term of the sequence (beyond 0 and 1) is a function of the preceding terms. There’s also a version of the sequence where the first two numbers are both 1, like so: In this alternative version, F(0) is still implicitly 0, but you start from F(1) and F(2) instead. The algorithm remains the same because you’re always summing the previous two numbers to get the next number in the sequence. For the purposes of this tutorial, you’ll use the version of the sequence that starts with 0.\n\nExamining the Recursion Behind the Fibonacci Sequence Generating the Fibonacci sequence is a classic recursive problem. Recursion is when a function refers to itself to break down the problem it’s trying to solve. In every function call, the problem becomes smaller until it reaches a base case, after which it will then return the result to each intermediate caller until it returns the final result back to the original caller. If you wanted to calculate the F(5) Fibonacci number, you’d need to calculate its predecessors, F(4) and F(3), first. And in order to calculate F(4) and F(3), you would need to calculate their predecessors. The breakdown of F(5) into smaller subproblems would look like this: Each time the Fibonacci function is called, it gets broken down into two smaller subproblems because that’s how you defined the recurrence relation. When it reaches the base case of either F(0) or F(1), it can finally return a result back to its caller. In order to calculate the fifth number in the Fibonacci sequence, you solve smaller but identical problems until you reach the base cases, where you can start returning a result: The colored subproblems on this diagram represent repetitive solutions to the same problem. If you go further up the tree, you’ll find more of these repetitive solutions. This means that to generate a Fibonacci sequence recursively, you have to calculate many intermediate numbers over and over. This is one of the fundamental issues in the recursive approach to the Fibonacci sequence.\n\nThe most common and minimal algorithm to generate the Fibonacci sequence requires you to code a recursive function that calls itself as many times as needed until it computes the desired Fibonacci number: Inside , you first check the base case. You then return the sum of the values that results from calling the function with the two preceding values of . The list comprehension at the end of the example generates a Fibonacci sequence with the first fifteen numbers. This function quickly falls into the repetition issue you saw in the above section. The computation gets more and more expensive as gets bigger. The required time grows exponentially because the function calculates many identical subproblems over and over again. Note: Do not try this function at home with a number greater than 50. Depending on your hardware, you might be waiting for a long time before seeing the result—if you make it to the end. To calculate F(5), has to call itself fifteen times. To calculate F(n), the maximum depth of the call tree is n, and since each function call produces two additional function calls, the time complexity of this recursive function is O(2n). Most of those calls are redundant because you’ve already calculated their results. F(3) appears twice, and F(2) appears three times. F(1) and F(0) are base cases, so it’s fine to call them multiple times. You may want to avoid this wasteful repetition, which is the topic of the following sections.\n\nOptimizing the Recursive Algorithm for the Fibonacci Sequence There are at least two techniques you can use to make the algorithm to generate the Fibonacci sequence more efficient—in other words, to make it take less time to compute. These techniques ensure that you don’t keep computing the same values over and over again, which is what made the original algorithm so inefficient. They’re called memoization and iteration. As you saw in the code above, the Fibonacci function calls itself several times with the same input. Instead of a new call every time, you can store the results of previous calls in something like a memory cache. You can use a Python list to store the results of previous computations. This technique is called memoization. Memoization speeds up the execution of expensive recursive functions by storing previously calculated results in a cache. This way, when the same input occurs again, the function just has to look up the corresponding result and return it without having to run the computation again. You can refer to these results as cached or memoized: With memoization, you just have to traverse up the call tree of depth n once after returning from the base case, as you retrieve all the previously calculated values highlighted in yellow, F(2) and F(3), from the cache earlier. The orange path shows that no input to the Fibonacci function is called more than once. This significantly reduces the time complexity of the algorithm from exponential O(2n) to linear O(n). Even for the base cases, you can replace calling F(0) and F(1) with just retrieving the values directly from the cache at indices 0 and 1, so you end up calling the function just six times instead of fifteen! Here’s a possible translation of this optimization into Python code: In this example, you use a Python dictionary to cache the computed Fibonacci numbers. Initially, contains the starting values of the Fibonacci sequence, 0 and 1. Inside the function, you first check if the Fibonacci number for the current input value of is already in . If so, then you return the number at hand. If there is no Fibonacci number for the current value of , then you compute it by calling recursively and updating . The final step is to return the requested Fibonacci number. What if you don’t even have to call the recursive Fibonacci function at all? You can actually use an iterative algorithm to compute the number at position in the Fibonacci sequence. You know that the first two numbers in the sequence are 0 and 1 and that each subsequent number in the sequence is the sum of its previous two predecessors. So, you can just create a loop that adds the previous two numbers, and , together to find the number at position in the sequence. The bolded purple numbers in the diagram below represent the new numbers that need to be calculated and added to in each iterative step: To calculate the Fibonacci number at position , you store the first two numbers of the sequence, 0 and 1, in . Then, calculate the next numbers consecutively until you can return .\n\nNow that you know the basics of how to generate the Fibonacci sequence, it’s time to go deeper and further explore the different ways to implement the underlying algorithm in Python. In the following sections, you’ll explore how to implement different algorithms to generate the Fibonacci sequence using recursion, Python object-oriented programming, and also iteration. Your first approach to generating the Fibonacci sequence will use a Python class and recursion. An advantage of using the class over the memoized recursive function you saw before is that a class keeps state and behavior (encapsulation) together within the same object. In the function example, however, is a completely separate object, so you don’t have control over it. Below is the code that implements your class-based solution: # Validate the value of n Here’s a breakdown of what’s happening in the code:\n• Line 4 defines the class initializer, . It’s a special method that you can use to initialize your class instances. Special methods are sometimes referred to as dunder methods, short for double underscore methods.\n• Line 5 creates the instance attribute, which means that whenever you create a object, there will be a cache for it. This attribute initially contains the first numbers in the Fibonacci sequence.\n• Line 7 defines another special method, . This method turns the instances of into callable objects.\n• Lines 9 and 10 validate the value of by using a conditional statement. If is not a positive integer number, then the method raises a .\n• Line 13 defines a conditional statement to check for those Fibonacci numbers that were already calculated and are available in . If the number at index is already in , then line 14 returns it. Otherwise, line 17 computes the number, and line 18 appends it to so you don’t have to compute it again. To try this code, go ahead and save it into . Then run this code in your interactive shell: Here, you create and then call an instance of the class named . The first call uses as an argument and returns , which is the sixth Fibonacci number because you’re using zero-based indices. This implementation of the Fibonacci sequence algorithm is quite efficient. Once you have an instance of the class, the attribute holds the already computed numbers from call to call. You can effectively understand how each call to a recursive Fibonacci function is handled using a call stack representation. The way each call is pushed onto the stack and popped off reflects exactly how the program runs. It clearly demonstrates how calculating large numbers will take a long time if you don’t optimize the algorithm. In a call stack, whenever a function returns a result, a stack frame representing the function call is popped off the stack. Whenever you call a function, you add a new stack frame to the top of the stack. In general, this operation has a space complexity of O(n) because there are no more than n stack frames on the call stack at a single time. Note: There’s a beginner-friendly code editor called Thonny that allows you to visualize the call stack of a recursive function in a graphical way. You can check out Thonny: The Beginner-Friendly Python Editor to learn more. To visualize the memoized recursive Fibonacci algorithm, you’ll use a set of diagrams representing the call stack. The step number is indicated by the blue label below each call stack. Say you want to compute F(5). To do this, you push the first call to the function onto the call stack: To compute F(5), you must compute F(4) as outlined by the Fibonacci recurrence relation, so you add that new function call to the stack: To compute F(4), you must compute F(3), so you add another function call to the stack: To compute F(3), you must compute F(2), so you add yet another function call to the call stack: To compute F(2), you must compute F(1), so you add that to the stack. As F(1) is a base case, it returns immediately with 1, and you remove this call from the stack: Now you start to unwind the results recursively. F(1) returns the result back to its calling function, F(2). To compute F(2), you also need to compute F(0): You add F(0) to the stack. Since F(0) is a base case, it returns immediately, giving you 0. Now you can remove it from the call stack: This result of calling F(0) is returned to F(2). Now you have what you need to compute F(2) and remove it from the stack: The result of F(2) is returned to its caller, F(3). F(3) also needs the results of F(1) to complete its calculation, so you add it back to the stack: F(1) is a base case and its value is available in the cache, so you can return the result immediately and remove F(1) from the stack: You can complete the calculation for F(3), which is 2: You remove F(3) from the stack after completing its calculation and return the result to its caller, F(4). F(4) also needs the result of F(2) to compute its value: You push the call to F(2) onto the stack. This is where the nifty cache comes in. You have calculated it before, so you can just retrieve the value from the cache, avoiding a recursive call to compute the result of F(2) again. The cache returns 1, and you remove F(2) from the stack: F(2) is returned to its caller, and now F(4) has all it needs to compute its value, which is 3: Next, you remove F(4) from the stack and return its result to the final and original caller, F(5): F(5) now has the result of F(4) and also the result of F(3). You push an F(3) call onto the stack, and the nifty cache comes into play again. You previously calculated F(3), so all you need to do is retrieve it from the cache. There’s no recursive process to compute F(3). It returns 2, and you remove F(3) from the stack: Now F(5) has all the values it needs to calculate its own value. You get 5 by adding 3 and 2, and that’s the final step before you pop the F(5) call off the stack. This action ends your sequence of recursive function calls: The call stack is empty now. You’ve completed the final step to compute F(5): Representing recursive function calls using a call stack diagram helps you understand all the work that takes place behind the scenes. It also allows you to see how many resources a recursive function can take up. Putting all these diagrams together allows you to visualize how the whole process looks: You can click the image above to zoom in on individual steps. If you don’t cache previously computed Fibonacci numbers, some of the stack stages in this diagram would be way taller, which means that they would take longer to return a result to their respective callers. The example in the previous sections implements a recursive solution that uses memoization as an optimization strategy. In this section, you’ll code a function that uses iteration. The code below implements an iterative version of your Fibonacci sequence algorithm: # Validate the value of n # Compute the next Fibonacci number, remember the previous one Now, instead of using recursion in , you’re using iteration. This implementation of the Fibonacci sequence algorithm runs in O(n) linear time. Here’s a breakdown of the code:\n• Line 3 defines , which takes a positive integer, , as an argument.\n• Lines 5 and 6 perform the usual validation of .\n• Lines 9 and 10 handle the base cases where is either 0 or 1.\n• Line 12 defines two local variables, and , and initializes them with the first two numbers in the Fibonacci sequence.\n• Line 13 starts a loop that iterates from to . The loop uses an underscore ( ) for the loop variable because it’s a throwaway variable and you won’t be using this value in the code.\n• Line 15 computes the next Fibonacci number in the sequence and remembers the previous one. To give this code a try, get back to your interactive session and run the following code: This implementation of is quite minimal. It uses iterable unpacking to compute the Fibonacci numbers during the loops, which is quite efficient memory-wise. However, every time you call the function with a different value of , it has to recompute the sequence over again. To fix this, you can use closures and make your function remember the already computed values between calls. Go ahead and give it a try!"
    },
    {
        "link": "https://docs.vultr.com/python/examples/display-fibonacci-sequence-using-recursion",
        "document": "The Fibonacci sequence is a series of numbers where each number is the sum of the two preceding ones, usually starting with 0 and 1. This sequence has broad applications in mathematics, computer science, and even in nature. Recursion, a method in which a function calls itself as a subroutine, offers an elegant way to generate these sequences.\n\nIn this article, you will learn how to implement the Fibonacci sequence using recursion in Python. You will explore detailed examples that demonstrate how to create a function to produce the sequence and how to handle common issues like recursion depth.\n• None Define a recursive function that takes an integer as its parameter. This function should call itself to calculate the previous two Fibonacci numbers until it reaches the base cases of or . The function checks if the input is or , which are the base cases, returning directly. For other values, it recursively calls itself for the two preceding values.\n• None Request a number of terms to display from the user.\n• None Iterate through each number up to the specified term and use the recursive function to compute each Fibonacci number. \"How many terms to include in Fibonacci sequence: \" This code snippet prompts the user to specify how many terms of the Fibonacci sequence they wish to see. It then iterates up to that number, calling the function for each index and printing each Fibonacci number.\n• None Understand that Python's default recursion limit might be reached with larger values due to deep recursion stacks.\n• None Use Python's module to increase the recursion limit if you need to calculate large terms in the Fibonacci sequence. This example first increases the recursion limit to 3000 using . It then calculates the Fibonacci number using the recursive function. For very large numbers, consider using iterative methods or memoization to optimize performance.\n\nImplementing the Fibonacci sequence using recursion in Python illustrates both the beauty and challenges of recursive programming. While the recursive approach provides a straightforward and intuitive method to generate the sequence, it can lead to high computational costs and stack overflow errors for large numbers. For practical applications, especially involving large numbers, enhancing the recursive algorithm with techniques like memoization or adopting an iterative approach is beneficial. Use the concepts demonstrated here to further explore and implement efficient recursive functions."
    },
    {
        "link": "https://simplilearn.com/tutorials/python-tutorial/fibonacci-series",
        "document": ""
    },
    {
        "link": "https://programiz.com/python-programming/examples/fibonacci-recursion",
        "document": "A Fibonacci sequence is the integer sequence of 0, 1, 1, 2, 3, 5, 8....\n\nThe first two terms are 0 and 1. All other terms are obtained by adding the preceding two terms.This means to say the nth term is the sum of (n-1)th and (n-2)th term.\n\nNote: To test the program, change the value of nterms.\n\nIn this program, we store the number of terms to be displayed in .\n\nA recursive function is used to calculate the nth term of the sequence. We use a loop to iterate and calculate each term recursively."
    },
    {
        "link": "https://stackoverflow.com/questions/42552897/fibonacci-sequence-calculator-python",
        "document": "Hi I'm fairly new to python and trying to create a Fibonacci calculator function that prints all values up to a given number, if the number entered is not in the sequence then it adds the next Fibonacci number to the list. For example, if 10 is entered it should return . The function has to be recursive. Here is my current code:\n\nI've managed to get it to work but it is incredibly slow (I assume due to the recursion) is there anyway I can speed it up without massively changing the program?"
    },
    {
        "link": "https://stackoverflow.com/questions/38896939/python-how-to-improve-efficiency-of-complex-recursive-function",
        "document": "You can store the results of the , and functions in arrays to prevent them from being recalculated every time, since in your example, calls , which calls and , which in turn call , , (again) and , and so on.\n\nYou can see that is being called evaluated twice, and this only gets worse as the number increases; if we count the number of times each function is called, those are the results:\n\nThis is actually a variant of a Pascal triangle, and you could probably figure out the results mathematically; but since here you asked for a non mathematical optimization, just notice how the number of calls increases exponentially; it doubles at each iteration. This is even worse since each call will generate thousands of subsequent calls with higher values, which is what you want to avoid.\n\nTherefore what you want to do is store the value of each call, so that the function does not need to be called a thousand times (and itself make thousands more calls) to always get the same result. This is called memoization.\n\nHere is an example solution in pseudo code:\n\nHere I use -1 since your functions seem to only generate positive numbers, and -1 is an easy placeholder for the empty cells. In other cases you might have to use an object as Cabu below me did. I however think this would be slower due to the cost of retrieving properties in an object versus reading an array, but I might be wrong about that. Either way, your code should be much, much faster with it is now, with a cost of O(n) instead of O(2^n).\n\nThis would technically allow your code to run forever at a constant speed, but the recursion will actually cause an early stack overflow. You might still be able to get to a depth of several thousands before that happens though.\n\nEdit: As ShadowRanger added in the comments, you can keep your original code and simply add before each of your , and functions, where n is one of the first powers of two above DEPTH (for example, 32 if depth is 25). This might require an import directive to work."
    },
    {
        "link": "https://labex.io/tutorials/python-how-to-speed-up-recursive-algorithms-420744",
        "document": "In the world of Python programming, recursive algorithms offer elegant solutions to complex problems. However, they can often suffer from performance bottlenecks. This tutorial explores comprehensive strategies to speed up recursive algorithms, helping developers write more efficient and performant code by understanding optimization techniques and computational complexity.\n\n%%%%{init: {'theme':'neutral'}}%%%% flowchart RL python((\"Python\")) -.-> python/FunctionsGroup([\"Functions\"]) python/FunctionsGroup -.-> python/function_definition(\"Function Definition\") python/FunctionsGroup -.-> python/arguments_return(\"Arguments and Return Values\") python/FunctionsGroup -.-> python/lambda_functions(\"Lambda Functions\") python/FunctionsGroup -.-> python/scope(\"Scope\") python/FunctionsGroup -.-> python/recursion(\"Recursion\") python/FunctionsGroup -.-> python/build_in_functions(\"Build-in Functions\") subgraph Lab Skills python/function_definition -.-> lab-420744{{\"How to speed up recursive algorithms\"}} python/arguments_return -.-> lab-420744{{\"How to speed up recursive algorithms\"}} python/lambda_functions -.-> lab-420744{{\"How to speed up recursive algorithms\"}} python/scope -.-> lab-420744{{\"How to speed up recursive algorithms\"}} python/recursion -.-> lab-420744{{\"How to speed up recursive algorithms\"}} python/build_in_functions -.-> lab-420744{{\"How to speed up recursive algorithms\"}} end"
    },
    {
        "link": "https://medium.com/pythons-gurus/mastering-recursion-in-python-130a1895df16",
        "document": "Recursion is a fundamental concept in programming, where a function calls itself in order to solve a problem. It is an important tool for data professionals and developers, especially when dealing with problems that have a repetitive or hierarchical structure. Recursion helps in simplifying complex problems by breaking them down into smaller, more manageable sub-problems.\n\nIn Python, recursion is a powerful technique that allows a function to call itself either directly or indirectly. This approach can be particularly useful for tasks like traversing trees, implementing search algorithms, or solving mathematical problems like calculating factorials and Fibonacci sequences.\n\nHi all, my name is CyCoderX and in this article I will provide a detailed explanation of recursion, along with examples and best practices for implementing recursive functions in Python.\n\nRecursion is a method where a function solves a problem by breaking it down into smaller instances of the same problem, which are then solved individually. To ensure that a recursive function doesn’t run infinitely, each recursive call works towards reaching a base case — a condition that stops the recursion from continuing.\n\nWhen a recursive function is called, it keeps breaking down the problem into smaller sub-problems. Each function call is placed on something called the call stack, and the function waits for the smaller sub-problem to return a result before proceeding.\n\nThe key to writing a recursive function is to:\n• Identify the base case: This is the condition where the problem is simple enough to be solved directly, without further recursive calls. The base case stops the recursion.\n• Define the recursive case: This is where the function calls itself to solve smaller sub-problems.\n\nOnce the base case is reached, the results are returned back up the call stack, with each function call completing its task and returning the final result.\n\nA classic example of recursion is calculating the factorial of a number. The factorial of a non-negative integer is the product of all integers less than or equal to . Using recursion, we can break this problem into a smaller one by calculating the factorial of until we reach the base case (when is 1 or 0).\n\nHere’s an example in Python:\n\nIn this example, the recursive case is , and the base case is when is 0 or 1, where the recursion stops.\n\nKeep in mind, there are various ways to write a factorial function in Python. This example is just to illustrate the concept. You can also simply import the factorial function from the math module.\n\nRecursion offers several advantages, especially in scenarios where the problem can naturally be divided into smaller sub-problems. Let’s explore some of the key benefits of using recursion:\n\nRecursion can simplify the implementation of complex problems by allowing you to break them down into smaller, more manageable parts. For example, problems like traversing trees or graphs can be implemented more elegantly using recursion, as it closely resembles the natural structure of these problems.\n\nConsider a problem where you need to traverse a directory structure (which resembles a tree). Each directory can contain files or subdirectories. Recursively visiting each subdirectory makes this problem much simpler:\n\nIn this example, the function recursively visits all subdirectories and prints the full path of each file. The problem becomes much easier to solve because recursion aligns naturally with the structure of the directory tree.\n\nRecursive solutions are often more concise and cleaner than their iterative counterparts. While an iterative approach might require managing a loop and keeping track of additional variables, recursion allows the problem to be solved in a more straightforward and elegant manner. This results in code that is often easier to read and maintain.\n\nMany algorithms, such as merge sort, quicksort, and binary search, follow the divide-and-conquer strategy, where a problem is divided into smaller sub-problems that are solved independently and then combined. Recursion is a natural fit for these algorithms, as it allows you to repeatedly break down the problem until it is simple enough to solve directly.\n\nFor example, consider the merge sort algorithm, which recursively divides the list into smaller sub-lists, sorts each sub-list, and then merges them back together:\n\nIn this example, the function divides the list into two halves, recursively sorts each half, and then merges them back together. Recursion makes it easy to break the problem down until the base case (when the list has one or no elements) is reached.\n\nWhile recursion is a powerful tool, it does come with certain trade-offs. In some cases, an iterative solution might be more efficient and practical than a recursive one. Here are some of the common disadvantages of recursion:\n\nEvery time a recursive function is called, a new frame is added to the call stack. This means that recursion can consume more memory and time than an iterative solution, particularly when the recursion depth becomes significant. Each recursive call involves overhead for maintaining the call stack, which can result in slower performance compared to an iterative loop.\n\nIn Python, this is particularly important to consider because Python’s default recursion depth is limited (usually to around 1000 calls). If the recursion depth exceeds this limit, you may encounter a .\n\nHere’s an example of recursion exceeding the depth limit:\n\nThe Python interpreter limits the depth of recursion to avoid running out of memory. For large problems, recursion may not always be the best approach due to this performance limitation.\n\nIf the recursion depth becomes too deep, you might run into a stack overflow error. This happens when the program exhausts the memory allocated for the call stack due to too many recursive calls. As mentioned earlier, Python raises a when this happens, but in other programming environments, this could crash the program entirely.\n\nFor example, consider calculating the Fibonacci sequence recursively. If we calculate the nth Fibonacci number using recursion without any optimization, the number of recursive calls grows exponentially, leading to performance degradation or a potential stack overflow:\n\nIn this case, for larger values of , the number of function calls becomes excessively large. This is because each call to makes two additional recursive calls to and . Without any form of optimization, this can cause performance issues.\n\nRecursive functions can be harder to debug than iterative functions, especially for beginners. It can be challenging to keep track of how many recursive calls have been made and what the state of each call is at any given point. This is especially true for problems where recursion depth is deep, or the base case is not clearly defined. Errors like missing a base case or making incorrect recursive calls can be difficult to trace.\n\nConsider the following recursive implementation of a function to calculate the sum of integers in a list:\n\nIf a mistake is made (for example, if the base case is incorrect or omitted), the program can end up in an infinite loop of recursive calls, which might be difficult to debug, particularly in complex problems.\n\nWhen to Use Recursion\n\nRecursion is best used when a problem can naturally be divided into smaller, similar sub-problems. Here are some scenarios where recursion is often the preferred approach:\n• Tree Traversals: Recursion is often the easiest way to traverse data structures like trees. For example, in-order, pre-order, and post-order tree traversal algorithms are naturally recursive.\n• Divide-and-Conquer Algorithms: Algorithms like quicksort and merge sort use recursion to divide the problem into smaller sub-problems.\n• Solving Puzzles: Problems like the Tower of Hanoi or generating permutations and combinations are often best solved using recursion.\n• Graphs: Recursion is commonly used in graph traversal algorithms, such as depth-first search (DFS).\n\nOn the other hand, when performance is a major concern, or when dealing with a problem that requires many repetitive recursive calls, an iterative solution might be more efficient.\n\nBest Practices for Using Recursion in Python\n\nWhen working with recursion in Python, it’s essential to follow best practices to write efficient, readable, and maintainable code. Here are some guidelines to help you effectively utilize recursion:\n\nEnsure that your base cases are well-defined and easily reachable. A clear base case is crucial for preventing infinite recursion and ensuring that the function eventually terminates. Take time to think through your base case and how your recursive calls will lead to it.\n\nIn this example, the base case is when is less than or equal to 0, ensuring that the recursion terminates.\n\nTail recursion is a form of recursion where the recursive call is the last operation in the function. Although Python does not optimize tail recursion like some other languages (such as Scheme), being aware of this can help you write clearer recursive functions.\n\nWhile Python won’t optimize tail calls, writing functions this way can help you think about how to manage state across recursive calls.\n\nFor problems that involve repeated calculations (like the Fibonacci sequence), consider using memoization. This technique involves caching the results of expensive function calls and returning the cached result when the same inputs occur again. This can greatly improve performance for recursive functions.\n\nIn this example, we use a dictionary to cache results, significantly reducing the time complexity.\n\nBe aware of the recursion depth in Python. You can use the module to check and set the maximum recursion depth. If you expect deep recursion, consider refactoring to an iterative solution or increasing the recursion limit using . However, use this with caution, as it can lead to stack overflow.\n\nTesting and debugging recursive functions can be more complex than iterative ones. Use print statements or a debugger to track the flow of function calls and variable values. Write unit tests to ensure that your base cases and recursive cases work as expected.\n\nRecursion is a powerful tool in Python that allows developers to solve complex problems through elegant and straightforward code. While it has its advantages, such as simplifying problem-solving and providing clear solutions, it’s essential to be mindful of its limitations, including performance overhead and stack depth.\n\nBy understanding when to use recursion and following best practices, data professionals can leverage recursion effectively in their projects. Whether traversing data structures, implementing algorithms, or solving mathematical problems, recursion remains an indispensable technique in a developer’s toolkit.\n\nThank you for reading, and happy coding!"
    },
    {
        "link": "https://diveintopython.org/learn/functions/recursion",
        "document": "Recursive programming is a technique in programming where a function calls itself repeatedly until it reaches a base or terminal case. It is a powerful tool when dealing with certain types of problems that can be naturally defined in a recursive manner. In Python, we can implement this technique through recursive functions.\n\nRecursive functions are functions that call themselves during execution to solve a problem by breaking it down into smaller sub-problems. Recursion in Python involves two main steps: defining the base case(s) and the recursive case(s).\n\nIn this example, the function takes an integer as input and recursively calculates the factorial of by multiplying it with the factorial of . The base case is when is equal to , in which case the function returns .\n\nIn this example, the function takes an integer as input and recursively calculates the term of the Fibonacci series by adding the previous two terms. The base case is when is or , in which case the function returns . The driver code prints the first of the Fibonacci series, where is a user-inputted value.\n\nTips and Best Practices for Python Recursive Programming\n• Clearly define the base case: The base case is the condition under which the function should stop calling itself recursively and return a value. Make sure that the base case is clearly defined and that the function eventually reaches it to avoid infinite recursion.\n• Watch out for recursion depth: Recursion depth refers to the number of times a function calls itself recursively. Python has a default recursion depth limit of 1000, so make sure to keep your recursive functions within the limit or adjust the recursion depth limit using the sys module.\n• Consider using memoization: Memoization is a technique used to cache the results of expensive function calls and reuse them when the same inputs occur again. This can significantly improve the performance of recursive functions in Python by avoiding duplicate computations.\n• Test and debug carefully: Recursive functions can be difficult to debug due to their complex nature. Make sure to test your function with various input values and take time to understand how it works before deploying it to production.\n\nThis recursive function performs binary search on a sorted array by calling itself with smaller subarrays until it finds the target or reaches the base case where the low index is greater than the high index.\n\nPython recursive functions can be a powerful tool in solving complex problems, but they can also be prone to common mistakes and pitfalls. Here are some common mistakes to avoid when using Python recursion:\n• Infinite loops: It is easy to create infinite loops in recursive functions if you don't have a base case that ultimately breaks the recursion. Be sure to define a base case that will stop the recursion.\n• Stack overflow: Recursion can create a lot of memory overhead, which can lead to stack overflow errors. Be careful when using recursion with large datasets.\n\nRecursive enhancing refers to the process of optimizing a Python recursive function for better efficiency and performance. This involves identifying areas that can be fine-tuned, such as reducing space complexity or using memoization to reduce the number of recursive calls.\n\nBelow are two examples of how to enhance Python recursive functions for greater efficiency:\n\nMemoization is the process of storing previously computed results to avoid repeated calculation. This can significantly reduce the runtime of a recursive function.\n\nIn the above code, the dictionary is used to store previously computed Fibonacci numbers. When the function is called with a previously calculated , the value is returned instead of the function making another recursive call.\n\nTail recursion optimization is a way to optimize recursive functions so that they use less space on the call stack.\n\nIn the above code, is a recursive function that calculates the sum of all numbers from to . The acc argument is an accumulator that stores the intermediate results of the computation.\n\nIn each recursive call, the function adds the current value of to the accumulator and passes the result to the next recursive call, without keeping the previous call's stack frame in memory. This way, the function uses a constant amount of memory on the call stack, and avoids the risk of stack overflow for large values of ."
    },
    {
        "link": "https://stackoverflow.com/questions/3220433/how-to-optimize-a-recursive-algorithm-to-not-repeat-itself",
        "document": "After finding the class in Python's standard library to be unsuitable for my needs, a generic \"diff\"-ing module was written to solve a problem space. After having several months to think more about what it is doing, the recursive algorithm appears to be searching more than in needs to by re-searching the same areas in a sequence that a separate \"search thread\" may have also examined.\n\nThe purpose of the module is to compute the difference and similarities between a pair of sequences (list, tuple, string, bytes, bytearray, et cetera). The initial version was much slower than the code's current form, having seen a speed increase by a factor of ten. Does anyone have a suggestion for implementing a method of pruning search spaces in recursive algorithms to improve performance?"
    },
    {
        "link": "https://geeksforgeeks.org/fibonacci-series-program-in-python-using-iterative-method",
        "document": "Fibonacci series is a series where each number is the sum of its two previous numbers. In this article, we are going to generate Fibonacci series in Python using Iterative methods. We will be covering both the loops i.e. for loop and while loop.\n\nIn this article, we will be covering all the concepts related to the topic with clear and concise examples with their respective explanations.\n\nTo get the nth element of the Fibonacci Series:\n\nBelow are some of the ways by which we can find fibonacci series using iterative method in Python:\n\nIn this case, we are going to store elements of our Fibonacci series inside a Python list. We are also using negative indexing of the list to get the last and second last element.\n\nTime Complexity: O(n), where n is the number of elements.\n\nSpace Complexity: O(n), where n is the number of elements.\n\nIn this case, we are going to implement two variables approach. In this approach, we are going to store first two elements of Fibonacci series (lets say a, b) and then add those elements and yield to the main function. After this we will swap 'a' with 'b' and 'b' with 'sum'.\n\nTime Complexity: O(n), where n is the number of elements.\n\nSpace Complexity: O(1)\n\nIn this case, just like we did it in for loop part, we will be using list to store the Fibonacci series element. We have to define a list with first two elements of Fibonacci Series.\n\nTime Complexity: O(n), where n is the number of elements.\n\nSpace Complexity: O(n), where n is the number of elements.\n\nIn this approach, we will use the same method that we have used it in the for loop part. We will just define first two elements of the series in the variable a and b. Then we will pass the first two elements to the main function and then add theses two variables and pass to the main function. After this we will swap 'a' with 'b' and 'b' with 'sum', likewise we have done in the previous approach.\n\nTime Complexity: O(n), where n is the number of elements.\n\nSpace Complexity: O(1)"
    },
    {
        "link": "https://stackoverflow.com/questions/15047116/an-iterative-algorithm-for-fibonacci-numbers",
        "document": "The problem is that your is within the loop of your function. So after the first iteration, it will already stop and return the first value: 1. Except when is 0, in which case the function is made to return itself, and in case is 1, when the for loop will not iterate even once, and no is being execute (hence the return value).\n\nTo fix this, just move the outside of the loop.\n\nFollowing KebertX’s example, here is a solution I would personally make in Python. Of course, if you were to process many Fibonacci values, you might even want to combine those two solutions and create a cache for the numbers."
    },
    {
        "link": "https://pythonistaplanet.com/fibonacci-sequence-iterative",
        "document": "Fibonacci series is an important problem in the field of computer science. Also, it is one of the most frequently asked problems in programming interviews and exams.\n\nFibonacci is a special kind of series in which the current term is the sum of the previous two terms. It’s like 0, 1, 1, 2, 3, 5, 8, 13,…. and so on.\n\nThere are many ways to solve this problem.\n\nThe primitive recursive solution takes a huge amount of time because for each number calculated, it needs to calculate all the previous numbers more than once.\n\nThis gets worse and worse the higher the number you want to compute.\n\nThe major problem of this approach is that with each Fibonacci number we calculate in our list, we don’t use the previous numbers we have knowledge of to make the computation faster.\n\nInstead, we compute each number from scratch.\n\nIn python, you can write the solution to this problem very easily, to avoid all these complexities.\n\nLet’s look at how can we write the fastest solution to the Fibonacci sequence.\n\nIn Python, we can solve the Fibonacci sequence in both recursive as well as iterative ways, but the iterative way is the best and easiest way to do it.\n\nThe source code of the Python Program to find the Fibonacci series without using recursion is given below.\n\nThe user must enter the number of terms to be printed in the Fibonacci sequence. We use a while loop to find the sum of the first two terms and proceed with the series by interchanging the variables.\n\nWe decrement the value of n and print the Fibonacci series till n-2 is greater than 0. Note that the program uses assignment and swapping of values in a single line.\n\nPython language has the built-in capability to do this to reduce your coding efforts. This is why we love Python. It is so easy to code when you compare it with any other programming language.\n\nYou can just copy and paste this code and run it on your python IDLE. You will get an output like the one that is given below.\n\nIterative Solution to find the nth term in Fibonacci Sequence\n\nSo, if you want to find the nth term in this series, you can do this in a few lines of code as follows.\n\nYou can see how simple and beautiful the code is written in this method.\n\nThe main part of the code is at line no.4. Here, the program uses assignments and swapping of values in just a single line.\n\nPlease note that this method is efficient in predicting the nth term of the Fibonacci sequence.\n\nIf your goal is to create a list of Fibonacci numbers, then this method is not recommended.\n\nThat’s it. This code is going to give back 8 which is exactly the 6th term in the series. You can put any position instead of 6. The code will generate the corresponding value as the output.\n\nThis is a very simple solution and this is the right way you should write the solution when you are at a job interview or test.\n\nIf you could not understand the logic, just go through the code once again. I’m sure that once you get that kick in your brain, this supercool Python trick will be helpful in your programming journey.\n\nIf you have any doubts or suggestions, feel free to let me know in the comments section.\n\nAlso, do share this article if it was helpful for you."
    },
    {
        "link": "https://freecodecamp.org/news/python-program-to-print-the-fibonacci-sequence",
        "document": "Questions about the Fibonacci Series are some of the most commonly asked in Python interviews.\n\nIn this article, I'll explain a step-by-step approach on how to print the Fibonacci sequence using two different techniques, iteration and recursion.\n\nBefore we begin, let's first understand some basic terminology.\n\nWhat is the Fibonacci Sequence?\n\nThe Fibonacci Sequence is a sequence of numbers in which a given number is the result of adding the 2 numbers that come before it. And adding the previous 2 numbers some number of times forms a series that we call the Fibonacci Series.\n\nThe Fibonacci sequence starts with two numbers, that is 0 and 1. Then every following number is made up of adding the previous two numbers together.\n\nFor example, take 0 and 1. They're the first two numbers in the sequence. If you add them together, you get 1. So the sequence starts 0, 1, 1,...\n\nThen, to find the next number, you add the last number you have and the number before it. So 1+1 = 2. So the sequence so far is 0, 1, 1, 2, ... Make sense?\n\nWe can represent this more mathematically like 0, 1, (1) - [0 + 1]. Similarly, the next Fibonacci number is - 0, 1, 1, (2) - [1 + 1]. And so on. Here's a diagram showing the first 10 Fibonacci numbers:\n\nThis is an example of a Fibonacci series – 0, 1, 1, 2, 3, 5, 8, 13, 21, 34. Within this continuous sequence, every individual number is a Fibonacci number.\n\nMathematically, the Fibonacci Sequence is represented by this formula:\n\nWe can use this sequence to find any nth Fibonacci number.\n\nThis fascinating sequence is widely associated with the mathematician Leonardo Pisano, also known as Fibonacci. He was from the Republic of Pisa, which is why he is also known as Leonardo of Pisa.\n\nLeonardo was known as one of the most talented mathematicians of the middle ages.\n\nHow to Print the Fibonacci Sequence in Python\n\nYou can write a computer program for printing the Fibonacci sequence in 2 different ways:\n\nIteration means repeating the work until the specified condition is met. Recursion, on the other hand, means performing a single task and proceeding to the next for performing the remaining task.\n\nHere's an iterative algorithm for printing the Fibonacci sequence:\n• Create 2 variables and initialize them with 0 and 1 (first = 0, second = 1)\n• Create another variable to keep track of the length of the Fibonacci sequence to be printed (length)\n• Loop (length is less than series length)\n• Update first and second variable (first will point to the second, and the second will point to first + second)\n• Decrement the length variable and repeat from step 3\n• Once the loop terminates, terminate the program\n\nConsider that we need to print a Fibonacci sequence of length 7. Then the flow of the algorithm will be like this:\n\nSo the final Fibonacci sequence for length 7 will be [0, 1, 1, 2, 3, 5, 8].\n\nIn the above code, first we have defined a function that will print the Fibonacci series. It accepts a parameter for the length, and the function needs to print the Fibonacci series.\n\nNext, we have created 2 variables that contain the initial 2 Fibonacci values, that is 0 and 1.\n\nThen we printed the first 2 values [0, 1] and decremented the length by 2, because 2 values were already been printed.\n\nWe will run a loop for the remaining length time, and each time print the next Fibonacci value by adding the previous 2 terms that are stored in the first and second variables (that we created initially to keep track of the previous 2 values).\n\nUpdate the first and second values that will point to the previous 2 values [first = second, and second = previous first + second].\n\nThe loop will run until the length becomes 0, which states that the required length of the Fibonacci sequence is printed.\n\nThen we call the function defined for printing Fibonacci from the main function by passing the argument of the required length to be printed. And there you have it!\n\nThere is another approach for printing the Fibonacci sequence using the help of recursion. So let’s understand that approach, too.\n• Accept the value of the previous first and second Fibonacci number as the length to be printed.\n• Check if the length is 0 then terminate the function call.\n• Print the Fibonacci value by adding the previous 2 values received in the parameter of the function (first and second).\n• Recursively call the function for the updated value of the first and second, as well as the decreased value of length.\n\nFor this recursive function call, we need to pass the initial value of Fibonacci, that is (0 and 1), in the first and second variables.\n\nTo help you understand this algorithm better, let’s see the Python implementation of the algorithms. Then we'll look at an example so you can see how this recursive algorithm works.\n\nFirst, we created a function and perform recursion on it. In that function, we accepted the value of the previous 2 Fibonacci numbers to calculate the current Fibonacci number. And we have a length that keeps track of the base case.\n\nFor the base case of recursion, we are checking if the length reaches 0. If it does, then we will terminate the recursive call.\n\nIn other cases, we are printing the Fibonacci number by adding the previous 2 Fibonacci numbers.\n\nAnd then we recursively call the function to print the next Fibonacci value by updating the previous 2 values and decrementing the length.\n\nNow let’s visualize the recursive calls of this function with the help of a recursion tree. The length we want printed is 7.\n\nBefore the recursive call is made, the main function prints the initial 2 values, 0 and 1. And then it passes these values to the recursive function.\n\nThe Recursive function is printing the value (0 + 1) and recursively calls with the next updated value.\n\nThen the recursive function is printing the value (1 + 1) and recursively calls with the next updated value.\n\nNow the recursive function is printing the value (1 + 2) and recursively calls with the next updated value.\n\nAnd then the recursive function is printing the value (2 + 3) and recursively calls with the next updated value.\n\nNow the recursive function is printing the value (3 + 5) and recursively calls with the next updated value.\n\nFinally, the last call is made. And the length is 0, so it will terminate the recursive call again and the series is printed on the console.\n\nIn the Iterative algorithm, we are looping until the length becomes 0. In the loop, we are performing a constant time operation of printing the value and updating the variables.\n\nIf we consider that length to be n, then the time complexity will be O(n).\n\nIn the recursive approach, we are calling recursive functions up to the given length number of times. We are also doing a simple constant operation of printing.\n\nSo in this also if we consider the length to be n numbers, then the time complexity will be O(n).\n\nIn the iterative approach we haven't taken the extra memory to accept the two variables that keeps track of the previous two Fibonacci numbers and the constant to any number of the series length. So the space complexity will be constant O(1).\n\nIn the recursive approach, we are calling the functions of the length number of times. We know that the recursion internally uses a call stack.\n\nSo if we consider that to be memory taken by the program, then the recursive call is made the length number of times. Then the space complexity will be O(n).\n\nThe Fibonacci sequence is the series of numbers in which every number is the addition of its previous two numbers.\n\nFibonacci sequences are found not only in mathematics but all over the natural world – like in the petals of flowers, leaves or spines of a cactus, and so on.\n\nIt's also a commonly asked interview question – so it's good to know how it works.\n\nI took inspiration from this post from InterviewBit."
    },
    {
        "link": "https://medium.com/geekculture/fibonacci-sequence-in-python-e772808c71e6",
        "document": "In the last section of this Python Tutorial Series, we talked about Recursive Approach To Solve A Problem In Python and understood them with some examples. In this article, we will go a step further. We are going to deal with the Fibonacci Sequence in the Python programming language. It’s a very famous problem in the programming world. If you are an absolute beginner then it’s okay. We are going to understand the Fibonacci Sequence from a very beginner level. If you are following this Python Tutorial Series then it will be easy for you to understand.\n\nAttention all developers seeking to make social connections and establish themselves while earning passive income — look no further! I highly recommend ‘From Code to Connections’, a book that will guide you through the process. Don’t miss out, grab your copy now on Amazon worldwide or Amazon India! You can also go for Gumroad\n\nFibonacci Sequence is a sequence of integers. The first and second numbers in the sequence are 0 and 1. A subsequent term in the sequence is computed as the sum of immediately preceding two terms. It looks something like this:\n\nIterative Approach To Find the nth Term Of Fibonacci Sequence\n\nThe output of the code is:\n\nIn the function Fibonacci, we take n as a parameter. This n should be greater than 0. We all know that the last term of the Fibonacci sequence is the sum of two preceding terms. Keeping that in mind, we assign two variables, secondLast and Last. The Fibonacci sequence starts with 0 then 1, and so on. So We are using this logic in the if-elif-else control structure used above in the code. For the first two numbers of the sequence, we have 0 and 1. Next, from 3 to n+1, the else condition is going to take care of our input. Let suppose, we want to know the 8th term of the Fibonacci series. The for loop will iterate from 3 to 9(9 is excluded) times. The variable result is the summation value of the secondLast and Last variable’s values. Next, the value of the Last variable is assigned to the secondLast variable. Next, the value of the result is stored in the Last variable. And after successfully iterating over the for loop. We will print the result.\n\nRecursive Approach To Find the nth Term Of Fibonacci Sequence\n\nThe output of the above code is the same as the output of the previous code:\n\nIn this Fibonacci function, we take n as a parameter. n should be greater than 0. If the input value of n is 1 and 2 then the output of the code is 0 and 1 respectively. Now in the else condition we just return the summation of the function itself with different parameter values. Understand this by letting a value of n. Let suppose the value of n is 4. Then the else condition returns the summation of fibonacci(3) and fibonacci(2). Again the value of fibonacci(3) is divided into two parts: fibonacci(2) and function(1). The value of fibonacci(1) is 1. And in this way, the whole problem breaks itself down into a simpler problem and then computes itself. After you run your code. You will get the same output. The best part of the recursive approach is that we have used fewer lines of codes as compared to the iterative approach to solving the same problem.\n\nThat’s it for this article. If I missed something then let me know in the comment section.\n\nIf this article sounds informative to you then make sure to follow and clap. Share it with your geek community."
    }
]