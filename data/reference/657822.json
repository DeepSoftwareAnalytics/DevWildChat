[
    {
        "link": "https://stackoverflow.com/questions/24255051/concatenate-char-arrays-in-c",
        "document": "I have the following code and would like to end up with a char such as: \"Hello, how are you?\" (this is just an example of what I'm trying to achieve)\n\nHow can I concatenate the 2 char arrays plus adding the \",\" in the middle and the \"you?\" at the end?\n\nSo far this concatenates the 2 arrays but not sure how to add the additional characters to my final char variable I want to come up with.\n\nThis is what I came up with after all your replies. I'd like to know if this is the best approach?"
    },
    {
        "link": "https://stackoverflow.com/questions/611263/efficient-string-concatenation-in-c",
        "document": "I would not worry about it. If you do it in a loop, strings will always preallocate memory to minimize reallocations - just use in that case. And if you do it manually, something like this or longer\n\nThen it's creating temporaries - even if the compiler could eliminate some return value copies. That is because in a successively called it does not know whether the reference parameter references a named object or a temporary returned from a sub invocation. I would rather not worry about it before not having profiled first. But let's take an example for showing that. We first introduce parentheses to make the binding clear. I put the arguments directly after the function declaration that's used for clarity. Below that, i show what the resulting expression then is:\n\nNow, in that addition, is what was returned by the first call to operator+ with the shown arguments. We assume the compiler is really clever and optimizes out the return value copy. So we end up with one new string that contains the concatenation of and . Now, this happens:\n\nCompare that to the following:\n\nIt's using the same function for a temporary and for a named string! So the compiler has to copy the argument into a new string and append to that and return it from the body of . It cannot take the memory of a temporary and append to that. The bigger the expression is, the more copies of strings have to be done.\n\nNext Visual Studio and GCC will support c++1x's move semantics (complementing copy semantics) and rvalue references as an experimental addition. That allows figuring out whether the parameter references a temporary or not. This will make such additions amazingly fast, as all the above will end up in one \"add-pipeline\" without copies.\n\nIf it turns out to be a bottleneck, you can still do\n\nThe calls append the argument to and then return a reference to themselves. So no copying of temporaries is done there. Or alternatively, the can be used, but you would need ugly parentheses to fix precedence."
    },
    {
        "link": "https://digitalocean.com/community/tutorials/string-concatenation-in-c-plus-plus",
        "document": "In this article, we will unveil the various ways of performing string concatenation in the C++ language. This method can be used for various purposes while programming. But in general, the concept is the same as combining two strings from different locations and placing them together.\n\nTechniques of String Concatenation in C++\n\nThe following techniques can be taken into consideration while concatenating strings in C++:\n• Using C++ for loop for concatenation\n\nC++ can be used to concatenate two strings easily.\n\nThe ‘+’ operator adds the two input strings and returns a new string that contains the concatenated string.\n\nC++ has a built-in method to concatenate strings. The method is used to concatenate strings in C++.\n\nThe strcat() function takes char array as input and then concatenates the input values passed to the function.\n\nIn the above example, we have declared two char arrays mainly str1 and str2 of size 100 characters. Then, we have passed the char array str1 and str2 to the strcat() function to get the concatenated string as a result.\n\nIn the above example, we accept string input values from the user using the function of C++ which fetches the input from the terminal character by character.\n\n3. The append() Method for String Concatenation in C++\n\nC++ has another built-in method: append() to concatenate strings. The method can be used to add strings together. It takes a string as a parameter and adds it to the end of the other string object.\n\nIn the above example, we have passed str2 as a parameter to the append() function. Further, the append() functions add the contents of the string object str2 to the end of the contents of string object str1. Thus, serving the purpose of string concatenation.\n\n4. Using C++ for loop\n\nIn order to concatenate strings, we can use C++ for loops to serve the purpose without the need of any in-built function.\n\nIn the above snippet of code, we have accepted two char array inputs mainly: x and y, respectively.\n\nFurther, we have traversed through the string of x char array till the pointer variable p points to the index of the last character of x.\n\nThen, we traverse through the character input of char array y and concatenate each character of y to x.\n\nIn the end, we add a to the end of the char array x which now contains the concatenated string as a result.\n\nThus, in this article, we have understood the various techniques to concatenate strings in the C++ language."
    },
    {
        "link": "https://geeksforgeeks.org/string-concatenation-in-cpp",
        "document": "String concatenation refers to the process of combining two or more strings into a single string. Generally, one string is appended at the end of the other string. In this article, we will learn how to concatenate two strings in C++.\n\nThe simplest method to concatenate two strings in C++ is by using + operator. Let’s take a look at an example:\n\nExplanation: The ‘+’ operator combines two string objects and returns the resulting concatenated string. However, this method only works for C++ style strings (std::string) and is not applicable to C-style character arrays.\n\nThere are also many other different ways to concatenate two strings in C++:\n\nThe string function is a member of the class that is used to concatenate two objects in C++. It provides an efficient way to concatenate two strings.\n\nWhen to use?\n\nUse this method when you need an efficient, in-place concatenation of std::string objects.\n\nThe function is a standard library function in C that is also available in C++. It is used to concatenate (append) one C-style string (character array) to another and adds a null terminator at the end. It is defined inside the <cstring> header file.\n\nWhen to use?\n\nUse this method when concatenating C-style strings (character arrays). Also suitable for legacy code that may run in C compilers.\n\nIn this method, characters from one string are appended manually one by one to another while iterating through both strings using loops. The final result is a concatenated string that combines both original string.\n\nWhen to use?\n\nUse this method for manual control over concatenation, such as with custom string structures or some processing before concatenation. It is also suitable when direct library functions aren’t available or for specific logic during concatenation."
    },
    {
        "link": "https://reddit.com/r/cpp_questions/comments/wxiyg1/most_efficient_way_to_concatenate_strings",
        "document": "Whats the most effective way to concatenate strings to avoid fragmentation and alloc/dealloc during resizing?\n\nI know, I can use reserve but I wouldn’t know the worst case scenario of the total length of this concatenation.\n\nIs std::stringstream any better for this purpose? Why isnt there a type that just takes the pointer to the const char* components of the string and only does a final allocation when all the components are fed in?"
    },
    {
        "link": "https://developer.lsst.io/cpp/api-docs.html",
        "document": "We document C++ code in two ways:\n• None By writing documentation blocks for all public or protected C++ components (namespaces, types, methods, functions, and constants). The LSST Stack uses Doxygen to build C++ API reference documentation from comment blocks. This documentation is exposed to users in a variety of contexts, from developers reading the code to readers of the Stack Doxygen Documentation. Doxygen comment blocks are the public specification of our C++ API. Our Doxygen configuration file is located in the base package. For Science Pipelines packages, it is automatically included in all documentation builds.\n• None By commenting our code internally with C++ comments ( or ). These comments are meant to be read only by developers reading and editing the source code.\n\nThis page focuses on public code documentation using Doxygen, while internal comments are discussed in our DM C++ Style Guide.\n\nTreat the guidelines on this page as an extension of the DM C++ Style Guide.\n\nThis guide will evolve as a mechanism to document C++ APIs wrapped in Python is developed.\n\nThe beginning of both header and source code files should include\n• None A copyright and license block (note: NOT a Doxygen comment block) using the standard text. * This product includes software developed by the LSST Project * See the COPYRIGHT file at the top-level directory of this distribution * This program is free software: you can redistribute it and/or modify * it under the terms of the GNU General Public License as published by * the Free Software Foundation, either version 3 of the License, or * (at your option) any later version. * This program is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the * You should have received a copy of the GNU General Public License * along with this program. If not, see <https://www.gnu.org/licenses/>. Replace with the package’s name. Some older code contains file-level Doxygen blocks (i.e., comments with a command). Such blocks should not be used in new code, as they rarely provide useful information about API elements defined by the file, and do not integrate well with pipelines.lsst.io. Ordinary C++ comments may still be used to document files for developers reading the source code.\n\nThis page covers the most important concepts in writing Doxygen-friendly C++ comments for the LSST Stack, though Doxygen’s manual is the most comprehensive reference. Documentation MUST be delimited in Javadoc style¶ Multi-line documentation blocks must begin with and end in . Single-line documentation blocks must begin with . For consistency, do not begin documentation blocks with or . Under certain circumstances, single-line documentation blocks may begin with instead of . These cases are indicated below. Multi-line documentation delimiters SHOULD be on their own lines¶ A multi-line documentation block’s summary sentence should occur on the line after the opening , and the terminating should be on its own line. An example: * This sum is the arithmetic sum, not some other kind of sum that only * @return sum of `values`, or 0.0 if `values` is empty. Documentation SHOULD use Markdown for formatting¶ LSST uses Markdown-formatted Doxygen comment blocks. If a particular format cannot be expressed using Markdown, you MAY use Doxygen’s built-in formatting or, if necessary, HTML markup. Documentation MUST appear where a component is first declared¶ In general, this means documentation blocks will appear in header ( ) files rather than source ( ) files. This keeps all the documentation with the API and avoids certain false alarms when Doxygen parses C++11 code. Documentation MUST appear before the declaration it describes, and with the same indentation¶ * @return sum of `values`, or 0.0 if `values` is empty. * @return sum of `values`, or 0.0 if `values` is empty.\n\nWe organize Doxygen comment blocks into sections that appear in a common order. This format is analogous to the one adopted for the Python documentation. The sections and their relative order are:\n• None Template Parameters (if applicable; for classes, methods, and functions)\n• None Function/Method Parameters (if applicable; for methods and functions)\n• None Returns (if applicable; for methods and functions)\n• None Throws (if applicable; for methods and functions) For summaries of how these sections are composed in specific contexts, see: A one-line summary that does not use variable names or the function’s name. This summary will appear in lists of class/namespace members. By default, brief summaries will end at a period followed by whitespace, or at a new line, whichever comes first. You can ignore periods that shouldn’t end the description by following them with a backslash and a space (as in ). Brief summaries should be short enough to fit on one line. If you must have a summary that extends over multiple lines, you must prefix the summary by , which will cause the summary to end at the next blank line rather than the next line break. For functions and methods, the summary should be written in the imperative voice (i.e., as a command that the API consumer is giving). Getters and other methods that are more naturally described as values rather than actions may ignore this rule. The extended summary is an optional sentence or short paragraph that clarifies and supports the summary sentence. Taken together with the summary sentence, the summary content in general exists to help users quickly understand the role and scope of the API. Leave detailed discussions of the API’s features, usage patterns, background theory, and implementation details to the Notes and Examples sections. The Parameters and Returns sections are ideal places to discuss in detail individual parameters and returned values, respectively. This section’s brevity is critical. The extended summary is proximate to the summary sentence so that the two pieces of content support each other. However, the extended summary also separates the API signature from the Parameters section, which users expect to see close together. As a general guideline, the extended summary should be three sentences or fewer. A series of tags, usually one for each template parameter. Each tag should have a description following the parameter name. You do not usually need to document default values; Doxygen will provide the default automatically. If the description extends over multiple lines, each line after the first must be indented. Parameters should be listed in the same order as they appear in the class, function, or method signature. * @tparam T the type of data stored in the table * of type `T`. Its `operator()` must accept two `T` and return `true` * if and only if the first argument comes before the second. It must When two or more consecutive template parameters have exactly the same description, they can be combined: * @tparam T, U the types of the pair components Doxygen will not properly parse parameter descriptions that have multiple paragraphs. If your template parameters require a lengthy explanation, put the explanation in the Extended Summary and refer to it from the parameter descriptions. When a partial template specialization reuses parameters from the full template, there is no need to redocument each parameter. If you are omitting the parameters, the documentation must include a cross-reference to the full template, possibly as part of the See Also section. You must redocument the parameters if the template specialization redefines any parameters (e.g., if the generic parameter becomes in the specialization) or if it places additional restrictions on their values. A series of tags, usually one for each parameter. Each tag should have a description following the parameter name. You do not usually need to document default arguments; Doxygen will provide the default automatically. If the description extends over multiple lines, each line after the first must be indented. Parameters should be listed in the same order as they appear in the function or method signature. Make sure to keep the parameter list in sync with the actual parameters; Doxygen will issue a warning if they don’t match. should be given with the , , or tag if the function method contains any output parameters. The tag is optional if all parameters are input, even if other functions or methods in the same class or package use output parameters. * Compute mean and standard deviation for a collection of data. * @param[out] mean the mean of `data`, or `NaN` if `data` is empty * if `data` contains fewer than 2 elements When two or more consecutive parameters have exactly the same description, they can be combined: * @param x, y the coordinates where the function is evaluated Doxygen will not properly parse parameter descriptions that have multiple paragraphs. If your function’s input requires a lengthy explanation, put the explanation in the Notes and refer to it from the parameter descriptions. A tag, followed by a description similar to the one for Function/Method Parameters. If the returned value is a map, ensure that the key-value pairs are documented in the description. For consistency with Python documentation, always use and not the synonymous . A series of tags, one for each type of exception (see the style guide). Each tag should have a description following the exception type. If the description extends over multiple lines, each line after the first must be indented. * @throws lsst::pex::exceptions::IoError Thrown if `fileName` could not be Exception classes must be namespace-qualified using the same rules as @see. Doxygen will render one or more tags as a table of exceptions and descriptions, so do not treat as the first word of the description. For consistency with Python documentation, always use and not the synonymous or . Whether or not there are any tags for specific exceptions, a function or method should have an tag. The description following the tag should describe the level of exception safety provided by the function or method. The following terms may be used for brevity: The function is guaranteed to always return without throwing an exception. If the function throws an exception, the program will be in the same state as before the call; i.e., failed calls have no side effects. If the function throws an exception, the program will be in a valid state, but not necessarily a predictable one. No memory, file descriptors, locks, or other resources will be leaked. If the function throws an exception, objects may be corrupted and unsafe to use, or resources may be leaked. * Image associated with this map. * @exceptsafe If `transform` provides basic exception safety, then this * method shall provide strong exception safety. Otherwise, it provides Some operations on a class, particularly arithmetic operators, must be implemented as standalone functions even though they are conceptually part of the class. These functions should have the tag, followed by the name of the appropriate class. They will appear on the class’s documentation page under the heading “Related Functions”. Use this tag sparingly. For internal consistency, always use and not the synonymous . By default, Doxygen shows the values of constants unless they are very long. The and tags override this behavior. // Value is implementation detail and subject to change ‘See Also’ is an optional section used to refer to related code. This section can be very useful, but should be used judiciously. The goal is to direct users to other functions they may not be aware of, or have easy means of discovering (by looking at the class or package documentation, for example). Functions whose documentation further explains parameters used by this function are good candidates. This section can also refer to arbitrary pages using a URL or a Markdown-style link. List each class, function, method, or link using a tag: Prefix objects from other namespaces appropriately by their greatest common namespace. For example, while documenting an module, refer to a class in by . When referring to an entirely different module or package, use the full namespace. Do not use namespace abbreviations, as Doxygen has trouble resolving them. For internal consistency, always use and not the synonymous . Notes is an optional section that provides additional conceptual information about the API. The notes must be prefixed by a or command. For internal consistency, always use and not the synonymous or . Some things to include in a Notes section:\n• None Discussions of features, going beyond the level of the summary sentence and extended summary.\n• None Usage patterns, like how code is expected to use this API, or how this API is intended to be used in relation to other APIs.\n• None Background theory. For example, if the API implements an algorithm, you can fully document the algorithm here.\n• None Implementation details and limitations, if those details affect the user’s experience. Purely internal details should be written as regular code comments. Specific how-tos, tutorials, and examples go in the Examples section instead of Notes. The Notes section is dedicated to conceptual documentation. The Function/Method Parameters and Returns sections are the best places to describe specific input and output variables. The Notes section can still reference these variables by name (see Marking up parameter names), and discuss how they work at a big-picture level. Since the content in the Function/Method Parameters needs to be brief, you can write additional content as part of the Notes section. This section may include mathematical equations to document the algorithm implemented by the function or class. Equations may be written in LaTeX format: * The FFT is a fast implementation of the discrete Fourier transform: LaTeX environments can also be used: Math can also be used inline: * Fit a model of the form @f$y = a x + b@f$ to the data. Note that LaTeX is not particularly easy to read, so use equations judiciously. In particular, do not use inline LaTeX just to add Greek or other special symbols; prefer HTML character entities or Unicode instead. Doxygen recovers poorly from typos in formulas; you may need to manually delete if it contains a bad formula. Images are allowed, but should not be central to the explanation; users viewing the documentation as text must be able to comprehend its meaning without resorting to an image viewer. These additional illustrations are included using the command: is a path relative to the project root directory. Equations or images may be used as described in Extended Summary. References can be included either in the ‘Notes’ section or in a separate list below them. A reference consists of the tag, followed by a BibTeX label. Bibfiles must be listed in the configuration tag in . Note that Web pages should be referenced with regular inline links. References are meant to augment the documentation, but should not be required to understand it. ‘Examples’ is an optional section for examples. This section is very strongly encouraged. Examples should use Markdown formatting for code blocks (i.e., indented by four extra spaces): * This is an amazing function! For example: * Comment explaining the second example.\n\nAll public or protected methods and all functions must be preceded by a documentation block. Method or function documentation blocks contain the following sections:\n• None Helper Functions (if applicable; for functions only) * @param fileName the file to read. Must be either absolute or relative to * @return the image stored in `fileName`. If the image on disk does not * have `double` pixels, they will be cast to `double`. * @throws IoError Thrown if `fileName` does not exist or is not readable. may be used when two methods/functions are effectively the same but have different parameter lists for reasons of convenience. Use this tag only when the specification of the abbreviated overload can be easily inferred from the fully documented one. The text generated by the tag tells readers to see the method “above”. Because Doxygen sorts the detailed documentation of namespace and class members, you should check the generated documentation to make sure the fully documented overload appears before any that use the tag. * @return sum of `values`, or 0.0 if `values` is empty. * @exceptsafe This function does not throw exceptions."
    },
    {
        "link": "https://scholarhat.com/tutorial/cpp/strings-in-cpp",
        "document": "Strings in C++ language are an arranged order of characters having a null character in the end '\\0'. Strings are utilized in almost any programming language, and anyone interested in programming needs to understand them. In this C++ tutorial, we will see the various C++ string functions, their types, string classes, etc. To get a little deeper, consider our Free C++ Course With Certificate\n\nWhat is a C++ String?\n\nA string is an object that represents a group or a sequence of characters. The string is represented as a one-dimensional array of characters and ends with a \\0 (null character). Strings in C++ can be defined either using the std::string class or the C-style character arrays.\n\nC-style type of strings in C++ are inherited from strings inC language. These strings are stored as an array of characters terminated by a null character ‘\\0’. The first step will be to declare a string variable and then assign a value to the variable.\n\nHere’s an example of a string declaration in C++ :\n\nSimilar to arrays, you can also define strings as shown below :\n\nIn this case, the array will hold the values “Welcome” and a null character ‘\\0’ that is added to the string at the end automatically by the compiler.\n\nHere’s a sample program in C++ Compiler for understanding the string declaration and definition.\n\nRead More - Advanced C++ Interview Interview Questions and Answers\n\nC++ does not support any built-in string types. In the previous example, we used the array of characters terminated by a \\0 to store the string value and perform operations on it (e.g., print the string value). This type of string is called the C String as it's taken from strings in c programming.\n\nC++ offers a new string class similar to the C Strings but with efficient programming capabilities. Internally, the working of the string class is the same as C Strings (by using a character array to store the characters), while the memory definition, allocation, and addition of null characters at the end are all handled by the String class itself. In this section, we will take a detailed look into the different functions that are available as a part of the String class in C++.\n\nWhile the character arrays as we have discussed above it is a statically allocated during the compile-time, while the strings are objects and hence can be dynamically allocated, Character arrays have few functions operating on them that can manipulate them. The string class has got set of various functions including the iterator functions that we will discuss in this article later on.\n\nWays to Define a String in C++\n\nMainly, there are two ways to do so:\n\nExample in C++ Online Editor\n\nDifference between String and Character Array in C++\n\nIn C++, there are different ways to take string inputs from the users. The way depends on the type of the string. We will look at three methods to take a string as input:\n\nThis is the most common and the easiest way to take a string-type user input\n\nThe getline() function in C++ is used to read a string from an input stream. It is defined in the\n\nIf you want to take multiple strings as input at once use the stringstream class in C++.\n\nThe different string functions in the String class are :\n\nThis string function is a standard function of C++ that is used to copy the string s2 into string s1. We need to pass two different string values to the function strcpy() to copy the string values described below.\n\nThe result of this program will be that the value of string2 (Morning) will be copied to string1 (Good) and string2 value will be printed (Morning).\n\nThis string function is used to append the string value or concatenate the string s2 at the end of string s1. Below is a simple example where the two string values have been passed to the function strcat().\n\nThe result of this program will be that the value of string2 (Morning) will be concatenated to string1 (Good) and string2 value will be printed (GoodMorning).\n\nThis string function calculates and returns the length of the string s1.\n\nThe result of this program will be the length of string1 which will be 12.\n\nThis string function compares the two string values and returns 0 if the two strings are the same, -1 if the value of string1<string2, and 1 when string1>string2.\n\nThe result of this program for the following input will be -1.\n\nThe result of this program for the following input will be 1.\n\nThe result of this program for the following input will be 0.\n\nThis string function searches for the character in the string and returns the pointer to the first occurrence of the character.\n\nExample of a program illustrating strchr() in C++ Editor\n\nThe output of this program will check to see if the character ‘a’ is present in the string ‘Good Morning’. The result will be printed as :\n\nIf we change the character as ‘o’, it will return the pointer value of the first occurrence of the character o in the string Good Morning.\n\nThis string function returns a pointer to the first occurrence of the string s2 in the string s1. Otherwise, the function returns a null pointer if s2 is not a part of s1.\n\nThe result of this program will be :\n\nIn C++ inbuilt string iterator functions allow the programmer to modify and traverse string elements. These functions are:\n\nThe C++ string capacity functions help to work with the size and capacity of the string. The primary functions of the capacity type are:\n\nExample illustrating C++ String Capacity Functions in C++ Online Compiler\n\nIn this detailed article, we have learned about the character array which is also called a C-style string along with the basics of the string class. String class comes with more utilities like iterator class as it’s a container class and also has discussed the variety of the string function to play with the string values. For practicals and hands-on experience, you can consider our C++ Certification program."
    },
    {
        "link": "https://joellaity.com/2020/01/31/string.html",
        "document": "libc++ is the LLVM project’s implementation of the C++ standard library. libc++’s implementation of is a fascinating case study of how to optimize container classes. Unfortunately, the source code is very hard to read because it is extremely:\n• Optimized. Even for relatively niche use-cases.\n• General. The class is a specialization of . can accept a custom character type and custom allocator.\n• Portable. This leads to macros everywhere.\n• Resilient. Every non-public identifier is prefixed with underscores to prevent name clashes with other code. This is necessary even for local variables since macros defined by the user of the library could modify the library’s header file.\n• Undocumented. There are very few comments in the header. I assume this is because library vendors would prefer it if users did not rely on internal implementation details of their classes, and not documenting internal helper functions is a desperate effort to mitigate Hyrum’s law.\n\nThis post examines the implementation of libc++’s . To keep it simple I will assume you are using a modern compiler and a modern x86 processor1. Keep in mind that the way objects are laid out in memory is very specific to the compiler, CPU archictecture and standard library used; everything I describe below is an implementation detail and not defined by the C++ standard.\n\nhas two modes: long string and short string. It uses a union to reuse the same bytes for both modes. Short string mode is an optimization which makes it possible to store up to 22 characters without heap allocation.\n\nThe long string mode is a pretty standard string implementation. There are three members:\n• - The amount of space in the underlying character buffer. If the string grows enough that length of the string (including the null-terminator) exceeds then the buffer must be reallocated. is an unsigned 64 bit integer. The least significant bit of is used as a flag, see the discussion below.\n• - The size of the current string, not including the null terminator. This is also an unsigned 64 bit integer.\n• - A pointer to the underlying buffer where the characters of the string are stored. This is 64 bits wide.\n\nSince each member is 8 bytes, .\n\nuses the least significant bit of to distinguish whether it is in long string mode or short string mode. If the least significant bit is set to 1, then it is in long string mode. If it is set to zero, then it is in short string mode. It is possible to use the least significant bit in this way because the size of the buffer is guaranteed by the implementation to always be an even number - so the true value for the capacity always has a 0 in the least significant bit. The method has an implementation that is equivalent to this (the real code looks quite different):\n\nThe short string mode uses the same 24 bytes to mean something completely different. There are two members:\n• - The size of the string, left-shifted by one ( ). The true size of the string is left-shifted by one because the least significant bit of the first byte is used as a flag. The least significant bit must be set to 0 in short string mode.\n• - A buffer to hold the characters of the string.\n\nstores the size of the string left shifted by 1, so the method has an implementation equivalent to this:\n\nBecause we are assuming the target architecture is little-endian, the least significant bit of is in the same position as the least significant bit of .\n\nTo see how the libc++ implementation achieves the data layout described above, I’m going to copy and paste real code snippets from libc++ and add comments.\n\nLong mode is reasonably straightforward, it’s implemented like this:\n\nShort mode looks like this:\n\nAccording to this Reddit comment, is needed to ensure any padding goes after , but has no other purpose (I don’t fully understand why this forces the padding to go after 🤷‍♂). is 23 on the platforms we are considering (64-bit).\n\nSo the first byte of is occupied by , and the next 23 are occupied the array.\n\nThe string is then represented like this:\n\nThe struct represents the string. It is a union of and as expected.\n\nThe struct is just an array of size 24 which allows some of the methods to consider the string as a sequence of bytes without having to care about whether the string is in long or short mode. For example, after a string is moved-from it is zeroed out, and the method is implemented like this:\n\nFinally, the only member variable in is declared like this:\n\nbehaves like , except it has an optimization where if one of the templates in the pair is an empty class then that class will not contribute to the size of the pair. is larger than it needs to be, for example:\n\nThe reason uses any space in the example above is for language-technical reasons: every object must have a unique memory address. (This will change in C++20, see here and here.) stores the objects next to each other in memory, and padding means that the struct in the example above contributes 4 bytes to the pair.\n\nwill not use any extra space if is empty.\n\nAnd that’s all there is to it! The implementation of looks like this (with s removed):\n\nHere is the full source on GitHub if you want to take a look.\n\n1 In particular, I will assume that (1) you are using the standard ABI layout, (2) your computer is 64-bit and little endian and (3) the type is signed and is 8. (There may be something else I missed. In practice I’m just assuming the layout on your machine is the same as on my machine.) ↩"
    },
    {
        "link": "https://en.cppreference.com/w/cpp/string/basic_string",
        "document": "The class template stores and manipulates sequences of character-like objects, which are non-array objects of TrivialType and StandardLayoutType. The class is dependent neither on the character type nor on the nature of operations on that type. The definitions of the operations are supplied via the template parameter - a specialization of std::char_traits or a compatible traits class.\n\nThe elements of a are stored contiguously, that is, for a s, &*(s.begin() + n) == &*s.begin() + n for any n in ​0​ s.size() , and *(s.begin() + s.size()) has value CharT() (a null terminator)(since C++11); or, equivalently, a pointer to s[0] can be passed to functions that expect a pointer to the first element of an array(until C++11)a null-terminated array(since C++11) of .\n\nsatisfies the requirements of AllocatorAwareContainer (except that customized / are not used for construction/destruction of elements), SequenceContainer and ContiguousContainer(since C++17).\n\nIf any of and is different from , the program is ill-formed.\n\nAll member functions of are constexpr: it is possible to create and use objects in the evaluation of a constant expression. However, objects generally cannot be constexpr, because any dynamically allocated storage must be released in the same evaluation of constant expression.\n\nSeveral typedefs for common character types are provided:\n\nReferences, pointers, and iterators referring to the elements of a may be invalidated by any standard library function taking a reference to non-const as an argument, such as std::getline, std::swap, or , and by calling non-const member functions, except , , , , , , , , and .\n\nAlthough it is required that customized or is used when constructing or destroying elements of until C++23, all implementations only used the default mechanism. The requirement is corrected by P1072R10 to match existing practice.\n\nThe following behavior-changing defect reports were applied retroactively to previously published C++ standards."
    },
    {
        "link": "https://geeksforgeeks.org/cpp-string-functions",
        "document": "A string is referred to as an array of characters. In C++, a stream/sequence of characters is stored in a char array. C++ includes the std::string class that is used to represent strings. It is one of the most fundamental datatypes in C++ and it comes with a huge set of inbuilt functions. In this article, will look at the functions of string computations.\n\nCommonly Used String Functions in C++\n\nThe std::string class contains functions to provide some common string operations. The below table contains some of the most commonly used functions in C++:\n\nWe can find the length of the string (number of characters) using either length() or size() function of the std::string class.\n• This function does not take any parameter.\n• This function returns the number of characters in the string object.\n\nIt will return the length of the string text which is 13.\n\nGenerally, we can access the character of a string using the [] array subscript operator and indexing. But std::string also has a function named at() which can be used to access the characters of the string.\n• index: It represents the position of the character in the string.\n• This function returns the character present at the index.\n\nThe std::cout will print K on the console as it is the character present at index 3.\n\nWe can concatenate string in C++ using two methods:\n\nThe + operator is overloaded in the std::string class to perform string concatenation.\n\n+ operator is used to concatenate two strings. The string fullName will be \"GeeksforGeeks\".\n\nThe append() function is another member function to concatenate two strings.\n• string2: This function takes the string to be appended as a parameter. It can be both C or C++ Style string.\n\nThe append() function adds one string to the end of another.\n\nJust like the concatenation, we can do the string comparison using two methods:\n\nThe equality operator can be used to compare the two strings as it is overloaded for this operation in the std::string class.\n\nThis will return true if both the strings are equal, otherwise returns false.\n\nHere, \"Strings are not equal\" will be printed as the == operator will return false.\n\nThe compare() function is a member function of std::string class which can be used to compare two strings.\n• str2: It is the string to be compared. It can be both C or C++ style string.\n• If the strings are equal, return zero.\n• If str1 is greater than str2, return value >0\n• If str2 is greater than str1, return value <0\n\nThe result will contain a value less than zero as str2 is greater than str1.\n\nWe can also compare the substring of str2 using the compare function():\n• position: position of the first character substring.\n\nWe can use the find() function of the std::string class to check whether a given character or a substring is present in the string or a part of string.\n• var: It can be a C style string, C++ style string, or a character that is to be searched in the string.\n• It returns the pointer to the first occurrence of the character or a substring in the string.\n\nThe position variable will contain 4 which is the start of the first occurrence of the string \"Programming\" in string text.\n\nWe can use the substr() function to generate a part of the string as a new string object. It is a member function of the std::string class.\n\nSyntax of substr() in C\n• start: Starting position of the substring to be generated.\n• end: Ending of the substring to be generated.\n\nIn the above example. the sub string will contain the \"World\".\n\nThe following function allows us to modify the current string.\n\nThe insert() function not only allows us to add a string but also allows us to add it at the specified position. It is also a member function of the std::string class.\n• index: position of where to insert the new string\n\nThe replace() function replaces the part of the string with the given other string. Unlike insert, the characters in the part where the new string is to be inserted are removed.\n• index: Index of where to start replacing the new string.\n• size: length of the part of the string that is to be replaced.\n• str2: new string that is to be inserted.\n\nThe erase() function is a member function of std::string class that is used to remove a character or a part of the string.\n\nThe c_str() function is a member function that is used to convert the C++ style string i.e. std::string objects to C style string i.e. array of characters.\n• This function does not take any parameter.\n• Pointer to the equivalent array of characters.\n\nExample of String Functions in C++\n\nThe below code demonstrate the use of the above specified string functions:"
    }
]