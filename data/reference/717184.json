[
    {
        "link": "https://e2e.ti.com/support/interface-group/interface/f/interface-forum/1161040/ds90ub941as-q1-access-to-port1-registers-when-use-in-independent-2-2-mode",
        "document": "I think I understand the issue going on here.\n\n1) Since you are using the WriteI2C (0x1E,0x04) this means that access to Serializer port 1 registers require you to use the secondary I2C address (this is your 7bit serializer id +1). I believe since you are not using the secondary address to access the port 1 registers, and are changing the port_sel register, you may be running into connection difficulty.\n\nHowever, in your case, I do not see that you would need to enable the secondary I2C address. We can get rid of that variable.\n\n2) Are your deserializers HW set to different deserializer addresses? Such that the DesID_0 = 0x10 and DesID_1 = 0x20 on the hardware?\n\nIf so, you do not need to use the software overide to define 0x06 register. The deserializer will load in this register itself.\n\nPlease see if the updated code below solves your issue. This should allow you to access port 1 registers and see the slave devices attached to both port 1 and port 0."
    },
    {
        "link": "https://ti.com/lit/pdf/sbaa565",
        "document": ""
    },
    {
        "link": "https://robot-electronics.co.uk/i2c-tutorial",
        "document": "Judging from my emails, it is quite clear that the I2C bus can be very confusing for the newcomer. I have lots of examples on using the I2C bus on the website, but many of these are using high level controllers and do not show the detail of what is actually happening on the bus. This short article therefore tries to de-mystify the I2C bus, I hope it doesn't have the opposite effect! The physical I2C bus\n\nThis is just two wires, called SCL and SDA. SCL is the clock line. It is used to synchronize all data transfers over the I2C bus. SDA is the data line. The SCL & SDA lines are connected to all devices on the I2C bus. There needs to be a third wire which is just the ground or 0 volts. There may also be a 5volt wire is power is being distributed to the devices. Both SCL and SDA lines are \"open drain\" drivers. What this means is that the chip can drive its output low, but it cannot drive it high. For the line to be able to go high you must provide pull-up resistors to the 5v supply. There should be a resistor from the SCL line to the 5v line and another from the SDA line to the 5v line. You only need one set of pull-up resistors for the whole I2C bus, not for each device, as illustrated below: The value of the resistors is not critical. I have seen anything from 1k8 (1800 ohms) to 47k (47000 ohms) used. 1k8, 4k7 and 10k are common values, but anything in this range should work OK. I recommend 1k8 as this gives you the best performance. If the resistors are missing, the SCL and SDA lines will always be low - nearly 0 volts - and the I2C bus will not work. Masters and Slaves\n\nThe devices on the I2C bus are either masters or slaves. The master is always the device that drives the SCL clock line. The slaves are the devices that respond to the master. A slave cannot initiate a transfer over the I2C bus, only a master can do that. There can be, and usually are, multiple slaves on the I2C bus, however there is normally only one master. It is possible to have multiple masters, but it is unusual and not covered here. On your robot, the master will be your controller and the slaves will be our modules such as the SRF08 or CMPS03. Slaves will never initiate a transfer. Both master and slave can transfer data over the I2C bus, but that transfer is always controlled by the master. The I2C Physical Protocol\n\nWhen the master (your controller) wishes to talk to a slave (our CMPS03 for example) it begins by issuing a start sequence on the I2C bus. A start sequence is one of two special sequences defined for the I2C bus, the other being the stop sequence. The start sequence and stop sequence are special in that these are the only places where the SDA (data line) is allowed to change while the SCL (clock line) is high. When data is being transferred, SDA must remain stable and not change whilst SCL is high. The start and stop sequences mark the beginning and end of a transaction with the slave device. Data is transferred in sequences of 8 bits. The bits are placed on the SDA line starting with the MSB (Most Significant Bit). The SCL line is then pulsed high, then low. Remember that the chip cannot really drive the line high, it simply \"lets go\" of it and the resistor actually pulls it high. For every 8 bits transferred, the device receiving the data sends back an acknowledge bit, so there are actually 9 SCL clock pulses to transfer each 8 bit byte of data. If the receiving device sends back a low ACK bit, then it has received the data and is ready to accept another byte. If it sends back a high then it is indicating it cannot accept any further data and the master should terminate the transfer by sending a stop sequence. How fast?\n\nThe standard clock (SCL) speed for I2C up to 100KHz. Philips do define faster speeds: Fast mode, which is up to 400KHz and High Speed mode which is up to 3.4MHz. All of our modules are designed to work at up to 100KHz. We have tested our modules up to 1MHz but this needs a small delay of a few uS between each byte transferred. In practical robots, we have never had any need to use high SCL speeds. Keep SCL at or below 100KHz and then forget about it. I2C Device Addressing\n\nAll I2C addresses are either 7 bits or 10 bits. The use of 10 bit addresses is rare and is not covered here. All of our modules and the common chips you will use will have 7 bit addresses. This means that you can have up to 128 devices on the I2C bus, since a 7bit number can be from 0 to 127. When sending out the 7 bit address, we still always send 8 bits. The extra bit is used to inform the slave if the master is writing to it or reading from it. If the bit is zero the master is writing to the slave. If the bit is 1 the master is reading from the slave. The 7 bit address is placed in the upper 7 bits of the byte and the Read/Write (R/W) bit is in the LSB (Least Significant Bit). The placement of the 7 bit address in the upper 7 bits of the byte is a source of confusion for the newcomer. It means that to write to address 21, you must actually send out 42 which is 21 moved over by 1 bit. It is probably easier to think of the I2C bus addresses as 8 bit addresses, with even addresses as write only, and the odd addresses as the read address for the same device. To take our CMPS03 for example, this is at address 0xC0 ($C0). You would uses 0xC0 to write to the CMPS03 and 0xC1 to read from it. So the read/write bit just makes it an odd/even address. The I2C Software Protocol\n\nThe first thing that will happen is that the master will send out a start sequence. This will alert all the slave devices on the bus that a transaction is starting and they should listen in incase it is for them. Next the master will send out the device address. The slave that matches this address will continue with the transaction, any others will ignore the rest of this transaction and wait for the next. Having addressed the slave device the master must now send out the internal location or register number inside the slave that it wishes to write to or read from. This number is obviously dependant on what the slave actually is and how many internal registers it has. Some very simple devices do not have any, but most do, including all of our modules. Our CMPS03 has 16 locations numbered 0-15. The SRF08 has 36. Having sent the I2C address and the internal register address the master can now send the data byte (or bytes, it doesn't have to be just one). The master can continue to send data bytes to the slave and these will normally be placed in the following registers because the slave will automatically increment the internal register address after each byte. When the master has finished writing all data to the slave, it sends a stop sequence which completes the transaction. So to write to a slave device: \n\n1. Send a start sequence\n\n2. Send the I2C address of the slave with the R/W bit low (even address)\n\n3. Send the internal register number you want to write to\n\n4. Send the data byte\n\n5. [Optionally, send any further data bytes]\n\n6. Send the stop sequence. As an example, you have an SRF08 at the factory default address of 0xE0. To start the SRF08 ranging you would write 0x51 to the command register at 0x00 like this:\n\n1. Send a start sequence\n\n2. Send 0xE0 ( I2C address of the SRF08 with the R/W bit low (even address)\n\n3. Send 0x00 (Internal address of the command register)\n\n4. Send 0x51 (The command to start the SRF08 ranging)\n\n5. Send the stop sequence. Reading from the Slave\n\nThis is a little more complicated - but not too much more. Before reading data from the slave device, you must tell it which of its internal addresses you want to read. So a read of the slave actually starts off by writing to it. This is the same as when you want to write to it: You send the start sequence, the I2C address of the slave with the R/W bit low (even address) and the internal register number you want to write to. Now you send another start sequence (sometimes called a restart) and the I2C address again - this time with the read bit set. You then read as many data bytes as you wish and terminate the transaction with a stop sequence. So to read the compass bearing as a byte from the CMPS03 module:\n\n1. Send a start sequence\n\n2. Send 0xC0 ( I2C address of the CMPS03 with the R/W bit low (even address)\n\n3. Send 0x01 (Internal address of the bearing register)\n\n4. Send a start sequence again (repeated start)\n\n5. Send 0xC1 ( I2C address of the CMPS03 with the R/W bit high (odd address)\n\n6. Read data byte from CMPS03\n\n7. Send the stop sequence. The bit sequence will look like this: Wait a moment\n\nThat's almost it for simple I2C communications, but there is one more complication. When the master is reading from the slave, its the slave that places the data on the SDA line, but its the master that controls the clock. What if the slave is not ready to send the data! With devices such as EEPROMs this is not a problem, but when the slave device is actually a microprocessor with other things to do, it can be a problem. The microprocessor on the slave device will need to go to an interrupt routine, save its working registers, find out what address the master wants to read from, get the data and place it in its transmission register. This can take many uS to happen, meanwhile the master is blissfully sending out clock pulses on the SCL line that the slave cannot respond to. The I2C protocol provides a solution to this: the slave is allowed to hold the SCL line low! This is called clock stretching. When the slave gets the read command from the master it holds the clock line low. The microprocessor then gets the requested data, places it in the transmission register and releases the clock line allowing the pull-up resistor to finally pull it high. From the masters point of view, it will issue the first clock pulse of the read by making SCL high and then check to see if it really has gone high. If its still low then its the slave that holding it low and the master should wait until it goes high before continuing. Luckily the hardware I2C ports on most microprocessors will handle this automatically. Sometimes however, the master I2C is just a collection of subroutines and there are a few implementations out there that completely ignore clock stretching. They work with things like EEPROM's but not with microprocessor slaves that use clock stretching. The result is that erroneous data is read from the slave. Beware! Example Master Code\n\nThis example shows how to implement a software I2C master, including clock stretching. It is written in C for the PIC processor, but should be applicable to most processors with minor changes to the I/O pin definitions. It is suitable for controlling all of our I2C based robot modules. Since the SCL and SDA lines are open drain type, we use the tristate control register to control the output, keeping the output register low. The port pins still need to be read though, so they're defined as SCL_IN and SDA_IN. This definition and the initialization is probably all you'll need to change for a different processor. To initialize the ports set the output resisters to 0 and the tristate registers to 1 which disables the outputs and allows them to be pulled high by the resistors.\n\nSDA = SCL = 1;\n\nSCL_IN = SDA_IN = 0;\n\n\n\nWe use a small delay routine between SDA and SCL changes to give a clear sequence on the I2C bus. This is nothing more than a subroutine call and return.\n\nvoid i2c_dly(void)\n\n{\n\n} The following 4 functions provide the primitive start, stop, read and write sequences. All I2C transactions can be built up from these.\n\nvoid i2c_start(void)\n\n{\n\n SDA = 1; // i2c start bit sequence\n\n i2c_dly();\n\n SCL = 1;\n\n i2c_dly();\n\n SDA = 0;\n\n i2c_dly();\n\n SCL = 0;\n\n i2c_dly();\n\n}\n\n\n\nvoid i2c_stop(void)\n\n{\n\n SDA = 0; // i2c stop bit sequence\n\n i2c_dly();\n\n SCL = 1;\n\n i2c_dly();\n\n SDA = 1;\n\n i2c_dly();\n\n} unsigned char i2c_rx(char ack)\n\n{\n\nchar x, d=0;\n\n SDA = 1; \n\n for(x=0; x<8; x++) {\n\n d <<= 1;\n\n do {\n\n SCL = 1;\n\n }\n\n while(SCL_IN==0); // wait for any SCL clock stretching\n\n i2c_dly();\n\n if(SDA_IN) d |= 1;\n\n SCL = 0;\n\n } \n\n if(ack) SDA = 0;\n\n else SDA = 1;\n\n SCL = 1;\n\n i2c_dly(); // send (N)ACK bit\n\n SCL = 0;\n\n SDA = 1;\n\n return d;\n\n} bit i2c_tx(unsigned char d)\n\n{\n\nchar x;\n\nstatic bit b;\n\n for(x=8; x; x--) {\n\n if(d&0x80) SDA = 1;\n\n else SDA = 0;\n\n SCL = 1;\n\n d <<= 1;\n\n SCL = 0;\n\n }\n\n SDA = 1;\n\n SCL = 1;\n\n i2c_dly();\n\n b = SDA_IN; // possible ACK bit\n\n SCL = 0;\n\n return b;\n\n}\n\n\n\nThe 4 primitive functions above can easily be put together to form complete I2C transactions. Here's and example to start an SRF08 ranging in cm: i2c_start(); // send start sequence\n\ni2c_tx(0xE0); // SRF08 I2C address with R/W bit clear\n\ni2c_tx(0x00); // SRF08 command register address\n\ni2c_tx(0x51); // command to start ranging in cm\n\ni2c_stop(); // send stop sequence Now after waiting 65mS for the ranging to complete (I've left that to you) the following example shows how to read the light sensor value from register 1 and the range result from registers 2 & 3. i2c_start(); // send start sequence\n\ni2c_tx(0xE0); // SRF08 I2C address with R/W bit clear\n\ni2c_tx(0x01); // SRF08 light sensor register address\n\ni2c_start(); // send a restart sequence\n\ni2c_tx(0xE1); // SRF08 I2C address with R/W bit set\n\nlightsensor = i2c_rx(1); // get light sensor and send acknowledge. Internal register address will increment automatically.\n\nrangehigh = i2c_rx(1); // get the high byte of the range and send acknowledge.\n\nrangelow = i2c_rx(0); // get low byte of the range - note we don't acknowledge the last byte.\n\ni2c_stop(); // send stop sequence The definitive specs on the I2C bus can be found on the Philips website. It currently here but if its moved you'll find it easily be googleing on \"i2c bus specification\"."
    },
    {
        "link": "https://forum.arduino.cc/t/help-understanding-i2c-register-addresses/1188910",
        "document": "I'm stuck in this situation: I have this chip (https://www.mouser.com/datasheet/2/302/mc44cc373-1188207.pdf) and I have to change bits SFD1 and SFD0 (to 0 and 1 respectively) using I2C, but I have little experience with this kind of operation (and I only have access to one of this chips, so I really can't screw up!). I know that I need the address of the device itself (according to the datasheet, it should be 0xCA, correct me if I'm wrong, and in that case, if you can tell me why, it would be really helpful for learning), but I think I also need an address for the register itself, as to not erroneously write over a different set of bits.\n\n Is this address not provided on the datasheet or am I missing something? Thanks in advance for your time!\n\nit should be 0xCA, correct me if I'm wrong, I make it that it should be using the address 0x65 or 0x67 depending on the single address line A1 being high or low when you communicate with it. You see there are two ways of specifying an I2C address, as an 8 bit address which includes the read/write line as the least significant bit or as a 7 bit address which has separate read/write instructions. The Arduino uses this latter convention, and the data sheet uses the former convention. However there is not an address select pin on the actual device so as page 9 of the data sheet says:- Since the I2C bus is a two-wire bus that does not have a separate chip-select line, each IC on the bus has a unique address. This address must be sent each time an IC is communicated with. The address is the first seven bits that are sent to the IC as shown in Table 9. The eighth bit sent is the R/W bit, it determines whether the master will read from or write to the IC. So that address is used each time you talk to the chip, so it becomes the preamble to any communications with any of the internal register. That is you start with that address defining value and follow it up with the register you want to communicate with. This is the STA value that is mentioned in the examples. Page 11 of the data sheet clearly shows what each of the internal registers do. However, there is a lot more you need to do with the hardware. First off you need to set the I2C to a high speed mode which is 800KHz. Then what sort of Arduino are you using? Is it 3V3 or 5V? What are you doing with pin 3? What I2C pull up resistor values do you have, and what voltage are they pulling to? Edit:- I started answering this before there were any replies. When I posted I saw the other 8 posts.\n\nI'm using an Arduino Uno, 5V. I still haven't connected anything yet, as I thought it would be better for me to understand the code part better before even going to the physical wiring. I would be connecting the chip to the Arduino just to change those bits (so all the other pins are free, there's nothing connected, except for the 5V power and GND). #include <Wire.h> byte deviceAddress = 0x65; //Is this ok? byte size = 16; void setup() { Wire.begin(); Wire.setClock(800000); //Set clock to 800KHz Wire.requestFrom(deviceAddress, size); Serial.begin(9600); // Initialize the serial communication } void loop() { // Check if data is available from the I2C device if (Wire.available()) { while (Wire.available()) { // Read and print each byte received char receivedByte = Wire.read(); Serial.print(receivedByte, HEX); // Print in hexadecimal format Serial.print(\" \"); // Add a space between bytes } Serial.println(); // Print a newline after all bytes are printed } } This code should allow me to read the bits and show them on the Serial monitor, as to give me an idea of what I'm going to do next, right?\n\nI tried to write the code for just changing those two bits (SFD1 to 0 and SFD0 to 1), but I just don't know how to keep bits that are already there intact. How would the actual code be? #include <Wire.h> byte deviceAddress = 0x65; void setup() { byte data[4]; //Do I need to write all the bytes up to the one that includes the \"SFD\" bits? data[0] = 0xXX; //How do I keep the data that was already there? data[1] = 0xXX; //How do I keep the data that was already there? data[2] = 0xXX; //How do I keep the data that was already there? data[3] = 0x68; //If I'm not mistaken, this should set both SFD bits as expected (but it would be nice to don't even touch the other bits here) Wire.beginTransmission(deviceAddress); Wire.write(val, sizeof val); //This should be \"data\"? Wire.endTransmission(true); // Stop transmitting }\n\nYou can't keep or read the values that were already there. You have to program all the bits in both C1 and C0. So you have to figure out what they need to be. Repeat that to yourself as many times as you need to. That's the situation you're stuck with. Go back and read what @Delta_G wrote. They're not registers, so don't think of them like that. They're commands. The MSb of the first byte, and the number of bytes, determine which command format is used. You have 2 byte commands, and 4 byte commands. And you have to set or reset each data bit in each byte of the command appropriately. On the bright side, since you're only really interested in setting/resetting SFD1 and SFD0, you really only have to figure out 4 more bits, assuming you want what the datasheet calls \"normal operation\": PS, SYSL, PWC and SREF. Everything else will be 0, with the exception of the MSb of C1, which will be 1.\n\nThe status byte could be considered a register. But since it's the only thing you can read, you could just as easily call it a status byte. One thing that may not be obvious at a first glance to Table 11 is that STA, CA and STO are not bytes to be sent. STA is the start condition, and is handled by the hardware. STO is the stop condition, also handled by the hardware. CA is the chip address, which is taken care of in the beginTransmission call. The only data you need to send are the two bytes for C1 and C0. And you can dig in your heels as much as you like, but it's not going to change the facts on the ground. This is the situation you're stuck with. So, I've said what I've had to say, and now I'm done. Good luck!\n\nBut he later said that they are registers, so I thought there was a way of reading them They are write only registers, this is not common, but not totally unheard of. To read back the status data, the read address shown in Table 10 is sent by the master. The modulator then responds with an ACK followed by a byte containing status information on the RF oscillator out-of-frequency range. This code should allow me to read the bits and show them on the Serial monitor, as to give me an idea of what I'm going to do next, right // Check if data is available from the I2C device if (Wire.available()) { while (Wire.available()) { Data is only sent from an I2C device after you have written to it. So there is no need to read anything from it, because it will not send you data spontaneously. Your Arduino is the Master device, your chip is the slave device. A slave device will only send data when a master has commanded it. Look at the I2C examples in the IDE. but I should be able to at least overwrite them with new ones. So look at table 11 and it gives you examples of the chain of writes needed to change your controlling registers. Have you used I2C before? It seems a lot of confusion is being caused by you not knowing how to communicate with an I2C device."
    },
    {
        "link": "https://st.com/resource/en/product_training/STM32F7_Peripheral_I2C.pdf",
        "document": ""
    },
    {
        "link": "https://ti.com/lit/pdf/slva704",
        "document": ""
    },
    {
        "link": "https://ti.com/lit/pdf/sbaa565",
        "document": ""
    },
    {
        "link": "https://nxp.com/docs/en/user-guide/UM10204.pdf",
        "document": ""
    },
    {
        "link": "https://robot-electronics.co.uk/i2c-tutorial",
        "document": "Judging from my emails, it is quite clear that the I2C bus can be very confusing for the newcomer. I have lots of examples on using the I2C bus on the website, but many of these are using high level controllers and do not show the detail of what is actually happening on the bus. This short article therefore tries to de-mystify the I2C bus, I hope it doesn't have the opposite effect! The physical I2C bus\n\nThis is just two wires, called SCL and SDA. SCL is the clock line. It is used to synchronize all data transfers over the I2C bus. SDA is the data line. The SCL & SDA lines are connected to all devices on the I2C bus. There needs to be a third wire which is just the ground or 0 volts. There may also be a 5volt wire is power is being distributed to the devices. Both SCL and SDA lines are \"open drain\" drivers. What this means is that the chip can drive its output low, but it cannot drive it high. For the line to be able to go high you must provide pull-up resistors to the 5v supply. There should be a resistor from the SCL line to the 5v line and another from the SDA line to the 5v line. You only need one set of pull-up resistors for the whole I2C bus, not for each device, as illustrated below: The value of the resistors is not critical. I have seen anything from 1k8 (1800 ohms) to 47k (47000 ohms) used. 1k8, 4k7 and 10k are common values, but anything in this range should work OK. I recommend 1k8 as this gives you the best performance. If the resistors are missing, the SCL and SDA lines will always be low - nearly 0 volts - and the I2C bus will not work. Masters and Slaves\n\nThe devices on the I2C bus are either masters or slaves. The master is always the device that drives the SCL clock line. The slaves are the devices that respond to the master. A slave cannot initiate a transfer over the I2C bus, only a master can do that. There can be, and usually are, multiple slaves on the I2C bus, however there is normally only one master. It is possible to have multiple masters, but it is unusual and not covered here. On your robot, the master will be your controller and the slaves will be our modules such as the SRF08 or CMPS03. Slaves will never initiate a transfer. Both master and slave can transfer data over the I2C bus, but that transfer is always controlled by the master. The I2C Physical Protocol\n\nWhen the master (your controller) wishes to talk to a slave (our CMPS03 for example) it begins by issuing a start sequence on the I2C bus. A start sequence is one of two special sequences defined for the I2C bus, the other being the stop sequence. The start sequence and stop sequence are special in that these are the only places where the SDA (data line) is allowed to change while the SCL (clock line) is high. When data is being transferred, SDA must remain stable and not change whilst SCL is high. The start and stop sequences mark the beginning and end of a transaction with the slave device. Data is transferred in sequences of 8 bits. The bits are placed on the SDA line starting with the MSB (Most Significant Bit). The SCL line is then pulsed high, then low. Remember that the chip cannot really drive the line high, it simply \"lets go\" of it and the resistor actually pulls it high. For every 8 bits transferred, the device receiving the data sends back an acknowledge bit, so there are actually 9 SCL clock pulses to transfer each 8 bit byte of data. If the receiving device sends back a low ACK bit, then it has received the data and is ready to accept another byte. If it sends back a high then it is indicating it cannot accept any further data and the master should terminate the transfer by sending a stop sequence. How fast?\n\nThe standard clock (SCL) speed for I2C up to 100KHz. Philips do define faster speeds: Fast mode, which is up to 400KHz and High Speed mode which is up to 3.4MHz. All of our modules are designed to work at up to 100KHz. We have tested our modules up to 1MHz but this needs a small delay of a few uS between each byte transferred. In practical robots, we have never had any need to use high SCL speeds. Keep SCL at or below 100KHz and then forget about it. I2C Device Addressing\n\nAll I2C addresses are either 7 bits or 10 bits. The use of 10 bit addresses is rare and is not covered here. All of our modules and the common chips you will use will have 7 bit addresses. This means that you can have up to 128 devices on the I2C bus, since a 7bit number can be from 0 to 127. When sending out the 7 bit address, we still always send 8 bits. The extra bit is used to inform the slave if the master is writing to it or reading from it. If the bit is zero the master is writing to the slave. If the bit is 1 the master is reading from the slave. The 7 bit address is placed in the upper 7 bits of the byte and the Read/Write (R/W) bit is in the LSB (Least Significant Bit). The placement of the 7 bit address in the upper 7 bits of the byte is a source of confusion for the newcomer. It means that to write to address 21, you must actually send out 42 which is 21 moved over by 1 bit. It is probably easier to think of the I2C bus addresses as 8 bit addresses, with even addresses as write only, and the odd addresses as the read address for the same device. To take our CMPS03 for example, this is at address 0xC0 ($C0). You would uses 0xC0 to write to the CMPS03 and 0xC1 to read from it. So the read/write bit just makes it an odd/even address. The I2C Software Protocol\n\nThe first thing that will happen is that the master will send out a start sequence. This will alert all the slave devices on the bus that a transaction is starting and they should listen in incase it is for them. Next the master will send out the device address. The slave that matches this address will continue with the transaction, any others will ignore the rest of this transaction and wait for the next. Having addressed the slave device the master must now send out the internal location or register number inside the slave that it wishes to write to or read from. This number is obviously dependant on what the slave actually is and how many internal registers it has. Some very simple devices do not have any, but most do, including all of our modules. Our CMPS03 has 16 locations numbered 0-15. The SRF08 has 36. Having sent the I2C address and the internal register address the master can now send the data byte (or bytes, it doesn't have to be just one). The master can continue to send data bytes to the slave and these will normally be placed in the following registers because the slave will automatically increment the internal register address after each byte. When the master has finished writing all data to the slave, it sends a stop sequence which completes the transaction. So to write to a slave device: \n\n1. Send a start sequence\n\n2. Send the I2C address of the slave with the R/W bit low (even address)\n\n3. Send the internal register number you want to write to\n\n4. Send the data byte\n\n5. [Optionally, send any further data bytes]\n\n6. Send the stop sequence. As an example, you have an SRF08 at the factory default address of 0xE0. To start the SRF08 ranging you would write 0x51 to the command register at 0x00 like this:\n\n1. Send a start sequence\n\n2. Send 0xE0 ( I2C address of the SRF08 with the R/W bit low (even address)\n\n3. Send 0x00 (Internal address of the command register)\n\n4. Send 0x51 (The command to start the SRF08 ranging)\n\n5. Send the stop sequence. Reading from the Slave\n\nThis is a little more complicated - but not too much more. Before reading data from the slave device, you must tell it which of its internal addresses you want to read. So a read of the slave actually starts off by writing to it. This is the same as when you want to write to it: You send the start sequence, the I2C address of the slave with the R/W bit low (even address) and the internal register number you want to write to. Now you send another start sequence (sometimes called a restart) and the I2C address again - this time with the read bit set. You then read as many data bytes as you wish and terminate the transaction with a stop sequence. So to read the compass bearing as a byte from the CMPS03 module:\n\n1. Send a start sequence\n\n2. Send 0xC0 ( I2C address of the CMPS03 with the R/W bit low (even address)\n\n3. Send 0x01 (Internal address of the bearing register)\n\n4. Send a start sequence again (repeated start)\n\n5. Send 0xC1 ( I2C address of the CMPS03 with the R/W bit high (odd address)\n\n6. Read data byte from CMPS03\n\n7. Send the stop sequence. The bit sequence will look like this: Wait a moment\n\nThat's almost it for simple I2C communications, but there is one more complication. When the master is reading from the slave, its the slave that places the data on the SDA line, but its the master that controls the clock. What if the slave is not ready to send the data! With devices such as EEPROMs this is not a problem, but when the slave device is actually a microprocessor with other things to do, it can be a problem. The microprocessor on the slave device will need to go to an interrupt routine, save its working registers, find out what address the master wants to read from, get the data and place it in its transmission register. This can take many uS to happen, meanwhile the master is blissfully sending out clock pulses on the SCL line that the slave cannot respond to. The I2C protocol provides a solution to this: the slave is allowed to hold the SCL line low! This is called clock stretching. When the slave gets the read command from the master it holds the clock line low. The microprocessor then gets the requested data, places it in the transmission register and releases the clock line allowing the pull-up resistor to finally pull it high. From the masters point of view, it will issue the first clock pulse of the read by making SCL high and then check to see if it really has gone high. If its still low then its the slave that holding it low and the master should wait until it goes high before continuing. Luckily the hardware I2C ports on most microprocessors will handle this automatically. Sometimes however, the master I2C is just a collection of subroutines and there are a few implementations out there that completely ignore clock stretching. They work with things like EEPROM's but not with microprocessor slaves that use clock stretching. The result is that erroneous data is read from the slave. Beware! Example Master Code\n\nThis example shows how to implement a software I2C master, including clock stretching. It is written in C for the PIC processor, but should be applicable to most processors with minor changes to the I/O pin definitions. It is suitable for controlling all of our I2C based robot modules. Since the SCL and SDA lines are open drain type, we use the tristate control register to control the output, keeping the output register low. The port pins still need to be read though, so they're defined as SCL_IN and SDA_IN. This definition and the initialization is probably all you'll need to change for a different processor. To initialize the ports set the output resisters to 0 and the tristate registers to 1 which disables the outputs and allows them to be pulled high by the resistors.\n\nSDA = SCL = 1;\n\nSCL_IN = SDA_IN = 0;\n\n\n\nWe use a small delay routine between SDA and SCL changes to give a clear sequence on the I2C bus. This is nothing more than a subroutine call and return.\n\nvoid i2c_dly(void)\n\n{\n\n} The following 4 functions provide the primitive start, stop, read and write sequences. All I2C transactions can be built up from these.\n\nvoid i2c_start(void)\n\n{\n\n SDA = 1; // i2c start bit sequence\n\n i2c_dly();\n\n SCL = 1;\n\n i2c_dly();\n\n SDA = 0;\n\n i2c_dly();\n\n SCL = 0;\n\n i2c_dly();\n\n}\n\n\n\nvoid i2c_stop(void)\n\n{\n\n SDA = 0; // i2c stop bit sequence\n\n i2c_dly();\n\n SCL = 1;\n\n i2c_dly();\n\n SDA = 1;\n\n i2c_dly();\n\n} unsigned char i2c_rx(char ack)\n\n{\n\nchar x, d=0;\n\n SDA = 1; \n\n for(x=0; x<8; x++) {\n\n d <<= 1;\n\n do {\n\n SCL = 1;\n\n }\n\n while(SCL_IN==0); // wait for any SCL clock stretching\n\n i2c_dly();\n\n if(SDA_IN) d |= 1;\n\n SCL = 0;\n\n } \n\n if(ack) SDA = 0;\n\n else SDA = 1;\n\n SCL = 1;\n\n i2c_dly(); // send (N)ACK bit\n\n SCL = 0;\n\n SDA = 1;\n\n return d;\n\n} bit i2c_tx(unsigned char d)\n\n{\n\nchar x;\n\nstatic bit b;\n\n for(x=8; x; x--) {\n\n if(d&0x80) SDA = 1;\n\n else SDA = 0;\n\n SCL = 1;\n\n d <<= 1;\n\n SCL = 0;\n\n }\n\n SDA = 1;\n\n SCL = 1;\n\n i2c_dly();\n\n b = SDA_IN; // possible ACK bit\n\n SCL = 0;\n\n return b;\n\n}\n\n\n\nThe 4 primitive functions above can easily be put together to form complete I2C transactions. Here's and example to start an SRF08 ranging in cm: i2c_start(); // send start sequence\n\ni2c_tx(0xE0); // SRF08 I2C address with R/W bit clear\n\ni2c_tx(0x00); // SRF08 command register address\n\ni2c_tx(0x51); // command to start ranging in cm\n\ni2c_stop(); // send stop sequence Now after waiting 65mS for the ranging to complete (I've left that to you) the following example shows how to read the light sensor value from register 1 and the range result from registers 2 & 3. i2c_start(); // send start sequence\n\ni2c_tx(0xE0); // SRF08 I2C address with R/W bit clear\n\ni2c_tx(0x01); // SRF08 light sensor register address\n\ni2c_start(); // send a restart sequence\n\ni2c_tx(0xE1); // SRF08 I2C address with R/W bit set\n\nlightsensor = i2c_rx(1); // get light sensor and send acknowledge. Internal register address will increment automatically.\n\nrangehigh = i2c_rx(1); // get the high byte of the range and send acknowledge.\n\nrangelow = i2c_rx(0); // get low byte of the range - note we don't acknowledge the last byte.\n\ni2c_stop(); // send stop sequence The definitive specs on the I2C bus can be found on the Philips website. It currently here but if its moved you'll find it easily be googleing on \"i2c bus specification\"."
    },
    {
        "link": "https://docs.onion.io/omega2-docs/communicating-with-i2c-devices.html",
        "document": "For the latest firmware based on OpenWRT 23.05, visit our new documentation site\n\nI2C (Inter-Integrated Circuit), sometimes called Two-Wire Interface, is a serial interface used to quickly and easily connect multiple devices to controllers and processors such as the Omega2. Examples of I2C devices include:\n\nCommunication is performed over 2 data lanes, each given their own pin on the Omega2:\n• Clock (SCL) - Signals when data is being transferred\n• Data (SDA) - Carries the data to be transferred\n\nThe I2C bus uses a master-slave architecture, which means the following:\n• Bus masters are devices that are in control of when and to whom they send and receive data.\n• Masters send commands which include the address of the slave who should receive it.\n• When using I2C with the Omega2, the Omega2 is configured to be the only bus master.\n• Bus slaves are devices that respond to masters when they receive a command addressed to them.\n• Each slave is identified with a hexadecimal address (eg. ).\n• Slaves will safely ignore commands not addressed to them.\n• Masters and slaves operate in either of two modes:\n\nIf you’re interested in the full details, see the Wikipedia article on I2C for more.\n\nAll I2C interactions on the Omega2 are done using the virtual device file . This is made possible with , a pseudo-file system that holds information about the Omega’s hardware in files, and lets the user control the hardware by editing the files. The I2C pins (SCL and SDA) on the Omega2 and Expansion Dock are highlighted below. Note: On some older Expansion Dock units, is labelled as pin , and is labelled as pin .\n\nWe’ll be using three command line utilities, , and , to work with I2C devices. These tools work by using the Omega’s I2C bus to communicate with any connected I2C devices. The command is used to find the addresses of every device connected to your Omega’s I2C bus. The command is used as follows: It will then output a table outlining the device addresses of each slave device connected to the bus: Your Omega will need to be on firmware or later to support the command. We’ll be using the and utilities to read data from and write data to I2C devices. These tools work by using the Omega’s I2C bus to access data stored in registers on the device. A register is a location in a device’s memory. When reading from/writing to an I2C device, you need to specify the register on the device that you want to access. The command is used to read a value of a specific register on an I2C device. A typical command reads as follows: The options are explained below:\n• - skip the prompt for confirmation from the command\n• - the I2C bus to use. The Omega2 has one I2C bus, denoted as bus .\n• - the address of the slave device, eg.\n• - the register on the slave to read from, eg. For example, let’s say we have an I2C temperature sensor at address acting as a slave with the following registers: Let’s say we’re interested in reading the temperature in degrees Fahrenheit. We do this using the following command: And it returns , which is 72 in decimal (22 degrees Celsius). That’s some nice weather outside! is used to set the value of a register on a target I2C device. A typical command looks like this: The options are explained below:\n• - skip the prompt for confirmation from the command\n• - the I2C bus to use. The Omega2 has one I2C bus, denoted as bus .\n• - the address of the slave device, eg.\n• - the register on the slave to write to, eg.\n• - the value to write, eg. Let’s say we have an I2C room light controller at address acting as a slave with the following registers:\n• - living room, for OFF, for ON For example, to turn the living room lights ON and the dining room lights OFF, we would run these commands: Some of our Expansions use I2C to communicate with the Omega. To learn more about how to work with them, take a look at the guides below:"
    },
    {
        "link": "https://docs.kernel.org/i2c/dev-interface.html",
        "document": "Usually, I2C devices are controlled by a kernel driver. But it is also possible to access all devices on an adapter from userspace, through the /dev interface. You need to load module i2c-dev for this.\n\nEach registered I2C adapter gets a number, counting from 0. You can examine /sys/class/i2c-dev/ to see what number corresponds to which adapter. Alternatively, you can run “i2cdetect -l” to obtain a formatted list of all I2C adapters present on your system at a given time. i2cdetect is part of the i2c-tools package.\n\nI2C device files are character device files with major device number 89 and a minor device number corresponding to the number assigned as explained above. They should be called “i2c-%d” (i2c-0, i2c-1, ..., i2c-10, ...). All 256 minor device numbers are reserved for I2C.\n\nSo let’s say you want to access an I2C adapter from a C program. First, you need to include these two headers: Now, you have to decide which adapter you want to access. You should inspect /sys/class/i2c-dev/ or run “i2cdetect -l” to decide this. Adapter numbers are assigned somewhat dynamically, so you can not assume much about them. They can even change from one boot to the next. Next thing, open the device file, as follows: int file; int adapter_nr = 2; /* probably dynamically determined */ char filename[20]; snprintf(filename, 19, \"/dev/i2c-%d\", adapter_nr); file = open(filename, O_RDWR); if (file < 0) { /* ERROR HANDLING; you can check errno to see what went wrong */ exit(1); } When you have opened the device, you must specify with what device address you want to communicate: int addr = 0x40; /* The I2C address */ if (ioctl(file, I2C_SLAVE, addr) < 0) { /* ERROR HANDLING; you can check errno to see what went wrong */ exit(1); } Well, you are all set up now. You can now use SMBus commands or plain I2C to communicate with your device. SMBus commands are preferred if the device supports them. Both are illustrated below: __u8 reg = 0x10; /* Device register to access */ __s32 res; char buf[10]; /* Using SMBus commands */ res = i2c_smbus_read_word_data(file, reg); if (res < 0) { /* ERROR HANDLING: I2C transaction failed */ } else { /* res contains the read word */ } /* * Using I2C Write, equivalent of * i2c_smbus_write_word_data(file, reg, 0x6543) */ buf[0] = reg; buf[1] = 0x43; buf[2] = 0x65; if (write(file, buf, 3) != 3) { /* ERROR HANDLING: I2C transaction failed */ } /* Using I2C Read, equivalent of i2c_smbus_read_byte(file) */ if (read(file, buf, 1) != 1) { /* ERROR HANDLING: I2C transaction failed */ } else { /* buf[0] contains the read byte */ } Note that only a subset of the I2C and SMBus protocols can be achieved by the means of read() and write() calls. In particular, so-called combined transactions (mixing read and write messages in the same transaction) aren’t supported. For this reason, this interface is almost never used by user-space programs. IMPORTANT: because of the use of inline functions, you have to use ‘-O’ or some variation when you compile your program!\n\nThe following IOCTLs are defined: Change slave address. The address is passed in the 7 lower bits of the argument (except for 10 bit addresses, passed in the 10 lower bits in this case). Selects ten bit addresses if select not equals 0, selects normal 7 bit addresses if select equals 0. Default 0. This request is only valid if the adapter has I2C_FUNC_10BIT_ADDR. Selects SMBus PEC (packet error checking) generation and verification if select not equals 0, disables if select equals 0. Default 0. Used only for SMBus transactions. This request only has an effect if the the adapter has I2C_FUNC_SMBUS_PEC; it is still safe if not, it just doesn’t have any effect. Gets the adapter functionality and puts it in . Do combined read/write transaction without stop in between. Only valid if the adapter has I2C_FUNC_I2C. The argument is a pointer to a: struct i2c_rdwr_ioctl_data { struct i2c_msg *msgs; /* ptr to array of simple messages */ int nmsgs; /* number of messages to exchange */ } The msgs[] themselves contain further pointers into data buffers. The function will write or read data to or from that buffers depending on whether the I2C_M_RD flag is set in a particular message or not. The slave address and whether to use ten bit address mode has to be set in each message, overriding the values set with the above ioctl’s. If possible, use the provided methods described below instead of issuing direct ioctls. You can do plain I2C transactions by using read(2) and write(2) calls. You do not need to pass the address byte; instead, set it through ioctl I2C_SLAVE before you try to access the device. You can do SMBus level transactions (see documentation file The SMBus Protocol for details) through the following functions: __s32 i2c_smbus_write_quick(int file, __u8 value); __s32 i2c_smbus_read_byte(int file); __s32 i2c_smbus_write_byte(int file, __u8 value); __s32 i2c_smbus_read_byte_data(int file, __u8 command); __s32 i2c_smbus_write_byte_data(int file, __u8 command, __u8 value); __s32 i2c_smbus_read_word_data(int file, __u8 command); __s32 i2c_smbus_write_word_data(int file, __u8 command, __u16 value); __s32 i2c_smbus_process_call(int file, __u8 command, __u16 value); __s32 i2c_smbus_block_process_call(int file, __u8 command, __u8 length, __u8 *values); __s32 i2c_smbus_read_block_data(int file, __u8 command, __u8 *values); __s32 i2c_smbus_write_block_data(int file, __u8 command, __u8 length, __u8 *values); All these transactions return -1 on failure; you can read errno to see what happened. The ‘write’ transactions return 0 on success; the ‘read’ transactions return the read value, except for read_block, which returns the number of values read. The block buffers need not be longer than 32 bytes. The above functions are made available by linking against the libi2c library, which is provided by the i2c-tools project. See: https://git.kernel.org/pub/scm/utils/i2c-tools/i2c-tools.git/.\n\nFor the interested, here’s the code flow which happens inside the kernel when you use the /dev interface to I2C:\n• None Your program opens /dev/i2c-N and calls ioctl() on it, as described in section “C example” above.\n• None These open() and ioctl() calls are handled by the i2c-dev kernel driver: see i2c-dev.c:i2cdev_open() and i2c-dev.c:i2cdev_ioctl(), respectively. You can think of i2c-dev as a generic I2C chip driver that can be programmed from user-space.\n• None Some ioctl() calls are for administrative tasks and are handled by i2c-dev directly. Examples include I2C_SLAVE (set the address of the device you want to access) and I2C_PEC (enable or disable SMBus error checking on future transactions.)\n• None Other ioctl() calls are converted to in-kernel function calls by i2c-dev. Examples include I2C_FUNCS, which queries the I2C adapter functionality using i2c.h:i2c_get_functionality(), and I2C_SMBUS, which performs an SMBus transaction using i2c-core-smbus.c: . The i2c-dev driver is responsible for checking all the parameters that come from user-space for validity. After this point, there is no difference between these calls that came from user-space through i2c-dev and calls that would have been performed by kernel I2C chip drivers directly. This means that I2C bus drivers don’t need to implement anything special to support access from user-space.\n• None These i2c.h functions are wrappers to the actual implementation of your I2C bus driver. Each adapter must declare callback functions implementing these standard calls. i2c.h:i2c_get_functionality() calls i2c_adapter.algo->functionality(), while i2c-core-smbus.c: calls either adapter.algo->smbus_xfer() if it is implemented, or if not, i2c-core-smbus.c:i2c_smbus_xfer_emulated() which in turn calls i2c_adapter.algo->master_xfer(). After your I2C bus driver has processed these requests, execution runs up the call chain, with almost no processing done, except by i2c-dev to package the returned data, if any, in suitable format for the ioctl."
    },
    {
        "link": "https://abelectronics.co.uk/kb/article/1092/i2c-part-3-i2c-tools-in-linux?srsltid=AfmBOorPCPqOdul2HQmUbtrVS9CfLVszyMoW17rO6HLV8jigrVKTSzUv",
        "document": "This tutorial is the third in a four-part series on the communication protocol I²C, explaining what it is, how it works and how you can use it on your Raspberry Pi.\n\n For the other tutorials in this series, click on the links below.\n\nEach tool below takes a parameter for the ID of the target I2C bus on the Raspberry Pi. In each example, the ID 1 is used, for example, \"sudo i2cdetect -y 1\".\n\nThe original Raspberry Pi models A and B with a 26-pin GPIO header had a bus ID of 0 and used the following GPIO pins:\n\nThe Raspberry Pi A+, B+, 2, 3, and later models with a 40-pin GPIO header use a default I2C bus on ID 1, which is accessible via the following GPIO pins:\n\nOn the 40-pin GPIO header models, a secondary I2C bus is available for HAT EEPROM configuration data on pins:\n\nI2C Tools should be installed by default on current distributions of Raspbian Linux. To install I2C Tools on older distributions, enter the following in a terminal on your Raspberry Pi.\n\nYou can test if i2ctools works by listing all the I2C devices connected to your Raspberry Pi.\n\ni2cdetect is a program to scan an I2C bus for connected devices. The output is a table listing the detected devices on the specified bus. The optional parameters first and last restrict the scanning range to the specified value. (default: from 0x03 to 0x77).\n• -y Disable interactive mode and perform operation directly. This is useful in scripts or when detecting devices.\n• -F List the functionality of the adapter.\n\nEach cell in the output table will contain one of the following symbols:\n\n\"UU\" Probing of the address was skipped because the address is currently in use by a driver.\n\n\"--\" The address was probed, but no response from a chip.\n\nThe examples below can be used on your Raspberry Pi with i2cdetect.\n\nList all detected devices on I2C bus 1 (default on Raspberry Pi) without user interaction.\n\ni2cdump is a helper program to read and examine registers on devices connected through the I2C bus.\n• -y Disable interactive mode and perform operation directly. This is useful in scripts.\n• -f Force access to the device even if it is used by another application or driver. Using this flag can cause unexpected results and can confuse the kernel driver using the device.\n\nA minimum of two options must be provided with i2cdump. i2cbus is the number of the I2C bus to be scanned. Address selects the I2C device address to be scanned on the bus and is an integer between 0x03 and 0x77.\n\ni2cdump can be dangerous if misused. Most notably, the c mode starts with WRITING a byte to the chip. Do not use i2cdump on random addresses.\n\nThe examples below can be used on your Raspberry Pi with i2cdump.\n\nDump the content of an I2C device at 7-bit address 0x68 on bus 1 using the default read byte mode with a user confirmation:\n\nDump the content of an I2C device at 7-bit address 0x68 on bus 1 using I2C block read transactions without user confirmation:\n\ni2cget is a helper program to read registers on devices connected through the I2C bus.\n• -y Disable interactive mode and perform operation directly. This is useful in scripts.\n• -f Force access to the device even if it is used by another application or driver. Using this flag can cause unexpected results and can confuse the kernel driver using the device.\n\nA minimum of two options must be provided with i2cget. i2cbus is the number of the I2C bus to be scanned. Address selects the I2C device address to be scanned on the bus and is an integer between 0x03 and 0x77.\n\nThe data-address parameter specifies the address on the chip to read from and is an integer between 0x00 and 0xFF.\n\nThe optional mode parameter is one of the letters b, w or c, corresponding to a read byte data, a read word data, or a write byte/read byte transaction.\n\ni2cget can be dangerous if misused. Some chips can process an I2C read command as a write command and write incorrect data to a register.\n\nThe examples below can be used on your Raspberry Pi with i2cget.\n\nRead the content of an I2C device at 7-bit address 0x68 on bus 1 from an 8-bit register at 0x20 after user confirmation:\n\nRead the content of an I2C device at 7-bit address 0x68 on bus 1 from a 16-bit register at 0x20 after user confirmation:\n\ni2cset is a helper program to set registers on devices connected through the I2C bus.\n• -y Disable interactive mode and perform operation directly. This is useful in scripts.\n• -f Force access to the device even if it is used by another application or driver. Using this flag can cause unexpected results and can confuse the kernel driver using the device.\n• -m mask The mask parameter, if specified, describes which bits of value will be written to the data address. Bits set to 1 in the mask are taken from value, while bits set to 0 will be read from data-address and thus preserved by the operation.\n• -r Read the value back after writing and compare it with the value written.\n\nA minimum of three options must be provided with i2cset. i2cbus is the number of the I2C bus to be scanned.\n\nThe data-address parameter selects the I2C device address to be scanned on the bus and is an integer between 0x03 and 0x77.\n\nThe data-address parameter specifies the address on the chip to read from and is an integer between 0x00 and 0xFF.\n\nThe value parameter, if specified, is the value to write to that location on the chip. If this parameter is omitted, then a short write is issued.\n\nThe optional mode parameter, if specified, is one of the letters b, w, s, or i, corresponding to a write size of a single byte, a 16-bit word, an SMBus block write, or an I2C block write.\n\nFor SMBus and I2C block writes, the write size is determined by the number of value parameters. Except for I2C block writes, a p can also be appended to the mode parameter to enable PEC. If the mode parameter is omitted, i2cset defaults to byte mode without PEC.\n\ni2cset can be dangerous if misused. It can confuse your I2C bus, cause data loss, or have more severe side effects.\n\nThe examples below can be used on your Raspberry Pi with i2cset.\n\nWrite the value 0x50 to an 8-bit register 0x20 to a device on at 7-bit I2C address 0x68 on bus 1 after user confirmation:\n\nWrite the value 0x5000 to a 16-bit register 0x20 to a device on at 7-bit I2C address 0x68 on bus 1 with no user confirmation:\n\ni2ctransfer is a program to create I2C messages and send them combined as one transfer to devices connected through the I2C bus.\n\nFor read messages, the contents of the received buffers are printed to stdout, one line per read message.\n• -y Disable interactive mode and perform operation directly. This is useful in scripts.\n• -f Force access to the device even if it is used by another application or driver. Using this flag can cause unexpected results and can confuse the kernel driver using the device.\n• -v Enable verbose output. This will print information about all messages sent for reading and writing.\n\nThe first parameter, i2cbus, contains the number of the I2C bus used. On a Raspberry Pi, this should be 1.\n\nThe following parameter is one or multiple desc blocks. The number of blocks is limited by the Linux Kernel and defined by I2C_RDWR_IOCTL_MAX_MSGS (42 as of v4.10).\n\nThe desc blocks are composed like this:\n\n{r|w} specifies if the message is read or write\n\nlength_of_message specifies the number of bytes read or written in this message. It is parsed as an unsigned 16-bit integer.\n\n[@address] specifies the 7-bit address of the chip to be accessed for this message and is an integer.\n\ni2ctransfer can be dangerous if misused. Some chips can process an I2C read command as a write command and write incorrect data to a register.\n\nThe examples below can be used on your Raspberry Pi with i2ctransfer.\n\nOn bus 0, from an EEPROM at address 0x50, read 8 bytes from offset 0x64 (the first message writes one byte to set the memory pointer to 0x64, and the second message reads from the same chip):\n\nAll examples on this page are based on MAN pages from Mankier."
    },
    {
        "link": "https://ncd.io/blog/i2c-communications-quick-start-guide",
        "document": ""
    }
]