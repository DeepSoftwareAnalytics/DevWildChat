[
    {
        "link": "https://docs.oracle.com/cd/B13789_01/appdev.101/b10807/13_elems017.htm",
        "document": "The statement executes a dynamic SQL statement or anonymous PL/SQL block. You can use it to issue SQL statements that cannot be represented directly in PL/SQL, or to build up statements where you do not know all the table names, WHERE clauses, and so on in advance. For more information, see Chapter 7.\n\nAn expression whose value is passed to the dynamic SQL statement, or a variable that stores a value returned by the dynamic SQL statement.\n\nA string literal, variable, or expression that represents a single SQL statement or a PL/SQL block. It must be of type or , not or .\n\nUsed only for single-row queries, this clause specifies the variables or record into which column values are retrieved. For each value retrieved by the query, there must be a corresponding, type-compatible variable or field in the clause.\n\nUsed only for DML statements that have a clause (without a clause), this clause specifies the bind variables into which column values are returned. For each value returned by the DML statement, there must be a corresponding, type-compatible variable in the clause.\n\nSpecifies a list of input and/or output bind arguments. The parameter mode defaults to .\n\nExcept for multi-row queries, the dynamic string can contain any SQL statement (without the final semicolon) or any PL/SQL block (with the final semicolon). The string can also contain placeholders for bind arguments. You cannot use bind arguments to pass the names of schema objects to a dynamic SQL statement.\n\nYou can place all bind arguments in the clause. The default parameter mode is . For DML statements that have a clause, you can place arguments in the clause without specifying the parameter mode, which, by definition, is . If you use both the clause and the clause, the clause can contain only arguments.\n\nAt run time, bind arguments replace corresponding placeholders in the dynamic string. Every placeholder must be associated with a bind argument in the clause and/or clause. You can use numeric, character, and string literals as bind arguments, but you cannot use Boolean literals ( , , and ). To pass nulls to the dynamic string, you must use a workaround. See \"Passing Nulls to Dynamic SQL\".\n\nDynamic SQL supports all the SQL datatypes. For example, define variables and bind arguments can be collections, s, instances of an object type, and refs. Dynamic SQL does not support PL/SQL-specific types. For example, define variables and bind arguments cannot be Booleans or index-by tables. The only exception is that a PL/SQL record can appear in the clause.\n\nYou can execute a dynamic SQL statement repeatedly using new values for the bind arguments. You still incur some overhead, because re-prepares the dynamic string before every execution.\n\nThe string argument to the command cannot be one of the national character types, such as or .\n\nThe following PL/SQL block contains several examples of dynamic SQL:"
    },
    {
        "link": "https://asktom.oracle.com/ords/asktom.search?tag=dynamic-dynamic-sql",
        "document": ""
    },
    {
        "link": "https://stackoverflow.com/questions/30033060/best-practice-for-formatting-building-queries-to-execute-in-a-pl-sql-stored-proc",
        "document": "Each method has advantages and disadvantages.\n\nThe following link will be very useful for you. This chapter address how coding dynamic SQL in Oracle database."
    },
    {
        "link": "https://dev.to/mrcaption49/execute-immediate-in-plsql-1681",
        "document": "EXECUTE IMMEDIATE is a PL/SQL command used to execute a dynamically constructed SQL statement. This allows for greater flexibility when the exact SQL statement may not be known until runtime. Here's a more detailed explanation, including syntax, examples, and best practices.\n\nEXECUTE IMMEDIATE sql_string [INTO into_variable_list] [USING bind_variable_list];\n\nsql_string: A string containing the SQL statement to be executed. This can be a SELECT, INSERT, UPDATE, DELETE, or any other SQL command.\n\nINTO: (Optional) Specifies variables that will receive the results of the query. This is typically used with SELECT statements.\n\nUSING: (Optional) Specifies bind variables to pass values into the SQL statement.\n\nExecuting a dynamic SQL command that does not return any results:\n\nBEGIN\n\n EXECUTE IMMEDIATE 'DELETE FROM employees WHERE employee_id = 101';\n\n DBMS_OUTPUT.PUT_LINE('Employee deleted successfully.');\n\n END;\n\nUsing EXECUTE IMMEDIATE to execute a SELECT statement and retrieve results into variables:\n\nDECLARE\n\n v_emp_name VARCHAR2(100);\n\n BEGIN\n\n EXECUTE IMMEDIATE 'SELECT name FROM employees WHERE employee_id = 101' INTO v_emp_name;\n\n DBMS_OUTPUT.PUT_LINE('Employee Name: ' || v_emp_name);\n\n END;\n\nUsing bind variables for safer and more efficient execution:\n\nDECLARE\n\n v_emp_id NUMBER := 102;\n\n v_emp_name VARCHAR2(100);\n\n BEGIN\n\n EXECUTE IMMEDIATE 'SELECT name FROM employees WHERE employee_id = :id' INTO v_emp_name USING v_emp_id;\n\n DBMS_OUTPUT.PUT_LINE('Employee Name: ' || v_emp_name);\n\n END;\n\nDECLARE\n\n v_emp_id NUMBER := 105;\n\n v_emp_name VARCHAR2(100) := 'Alice Johnson';\n\n BEGIN\n\n EXECUTE IMMEDIATE 'INSERT INTO employees (employee_id, name) VALUES (:id, :name)' USING v_emp_id, v_emp_name;\n\n DBMS_OUTPUT.PUT_LINE('Employee added successfully.');\n\n END;\n\nYou can also construct SQL statements that include dynamic table names:\n• None Use Bind Variables: Always prefer bind variables over concatenating values directly into the SQL string to avoid SQL injection vulnerabilities and improve performance.\n• None Error Handling: Implement proper error handling (e.g., using EXCEPTION blocks) when executing dynamic SQL to manage potential issues such as syntax errors or runtime exceptions.\n• None Performance Considerations: Dynamic SQL may be less efficient than static SQL due to the additional overhead of parsing and optimizing the SQL statement at runtime. Use it judiciously.\n• None Logging and Debugging: If you are building complex SQL strings dynamically, consider logging the constructed SQL statement for debugging purposes.\n• None Keep SQL Simple: If you find that the dynamic SQL is getting complex, consider whether you can simplify your logic or break it down into smaller parts.\n\nUsing EXECUTE IMMEDIATE can greatly enhance the flexibility of your PL/SQL code, enabling you to construct and execute SQL statements at runtime based on varying conditions. Let me know if you need further assistance or examples!"
    },
    {
        "link": "https://forums.oracle.com/ords/apexds/post/best-practice-when-using-an-execute-immediate-running-a-lar-0035",
        "document": "What is the best practice when using an EXECUTE IMMEDIATE running a very large DML operation like, say a MERGE? To be specific, I have 2 scenarios below -- one which embeds a COMMIT inside the string that is executed by an EXECUTE IMMEDIATE with IN and OUT params being supplied dynamically via bind variables while the other scenario has a COMMIT outside. Does Oracle treat this differently in terms of performance?\n\nSCENARIO A: COMMIT is embedded inside the EXECUTE IMMEDIATE string\n\nSCENARIO B: COMMIT is executed outside the EXECUTE IMMEDIATE string\n\nWhich one do you recommend and why?"
    },
    {
        "link": "https://docs.oracle.com/database/121/TTPLP/d_output.htm",
        "document": "The package enables you to send messages from stored procedures and packages. The package is especially useful for displaying PL/SQL debugging information.\n\nThis chapter contains the following topics:\n\nThis section contains topics which relate to using the package. The PUT procedure and PUT_LINE procedure in this package enable you to place information in a buffer that can be read by another procedure or package. In a separate PL/SQL procedure or anonymous block, you can display the buffered information by calling the GET_LINE procedure and GET_LINES procedure. If the package is disabled, all calls to subprograms are ignored. In this way, you can design your application so that subprograms are available only when a client can process the information.\n• If you do not call , or if you do not display the messages on your screen in , the buffered messages are ignored.\n• The utility calls after issuing a SQL statement or anonymous PL/SQL calls.\n• Typing in has the same effect as the following: There is no limit on the output.\n• You should generally avoid having application code invoke either the DISABLE procedure or ENABLE procedure because this could subvert the attempt by an external tool like to control whether to display output. Messages sent using are not actually sent until the sending subprogram completes. There is no mechanism to flush output during the execution of a procedure. Messages sent usingare not actually sent until the sending subprogram completes. There is no mechanism to flush output during the execution of a procedure.\n• The default buffer size is 20000 bytes. The minimum size is 2000 bytes and the maximum is unlimited. subprograms raise the application error , and the output procedures can return the following errors: The package is commonly used to debug stored procedures or functions. This function queries the table of the schema and returns the total salary for a specified department. The function includes calls to the procedure: CREATE OR REPLACE FUNCTION dept_salary (dnum NUMBER) RETURN NUMBER IS CURSOR emp_cursor IS select salary, commission_pct from employees where department_id = dnum; total_wages NUMBER(11, 2) := 0; counter NUMBER(10) := 1; BEGIN FOR emp_record IN emp_cursor LOOP emp_record.commission_pct := NVL(emp_record.commission_pct, 0); total_wages := total_wages + emp_record.salary + emp_record.commission_pct; DBMS_OUTPUT.PUT_LINE('Loop number = ' || counter || '; Wages = '|| TO_CHAR(total_wages)); /* Debug line */ counter := counter + 1; /* Increment debug counter */ END LOOP; /* Debug line */ DBMS_OUTPUT.PUT_LINE('Total wages = ' || TO_CHAR(total_wages)); RETURN total_wages; END; Assume the user executes the following statements in : The user would then see output such as the following:\n\nRetrieves an array of lines from buffer. \n\n This procedure disables calls to , , , , and , and purges the buffer of any remaining information. As with the ENABLE procedure, you do not need to call this procedure if you are using the setting from . This procedure enables calls to , , , , and . Calls to these procedures are ignored if the package is not activated. Upper limit, in bytes, for the amount of buffered information Setting to specifies that there should be no limit.\n• It is not necessary to call this procedure when you use from . It is called automatically (with value for in the current release).\n• If there are multiple calls to , then is the last of the values specified. The maximum size is 1,000,000 and the minimum is 2000 when the user specifies ( ).\n• is expected to be the usual choice. The default is 20000 for backward compatibility with earlier database versions that did not support unlimited buffering. You should declare this parameter as to avoid the risk of \" ORA-06502: PL/SQL: numeric or value error: character string buffer too small \". If the call completes successfully, then the status returns as 0. If there are no more lines in the buffer, then the status is 1.\n• You can choose to retrieve from the buffer a single line or an array of lines. Call to retrieve a single line of buffered information. To reduce the number of calls to the server, call to retrieve an array of lines from the buffer.\n• You can choose to automatically display this information if you are using by using the special command.\n• After calling or , any lines not retrieved before the next call to , , or are discarded to avoid confusing them with the next message. This procedure retrieves an array of lines from the buffer. DBMS_OUTPUT.GET_LINES ( OUT DBMS_OUTPUT.CHARARR, IN OUT INTEGER); DBMS_OUTPUT.GET_LINES ( OUT DBMS_OUTPUT.DBMSOUTPUT_LINESARRAY, IN OUT INTEGER); The maximum length of each line in the array is 32767 bytes. It is recommended that you use the varray overload version in a 3GL host program to execute the procedure from a PL/SQL anonymous block. Number of lines you want to retrieve from the buffer After retrieving the specified number of lines, the procedure returns the number of lines actually retrieved. If this number is less than the number of lines requested, then there are no more lines in the buffer.\n• You can choose to retrieve from the buffer a single line or an array of lines. Call to retrieve a single line of buffered information. To reduce the number of trips to the server, call to retrieve an array of lines from the buffer.\n• You can choose to automatically display this information if you are using by using the special command.\n• After or is called, any lines not retrieved before the next call to , , or are discarded to avoid confusing them with the next message. This procedure puts an end-of-line marker. The GET_LINE procedure and the GET_LINES procedure return \"lines\" as delimited by \"newlines\". Every call to the PUT_LINE procedure or to generates a line that is returned by or . This procedure places a partial line in the buffer. The version that takes a input is obsolete. It is supported for legacy reasons only. Theversion that takes ainput is obsolete. It is supported for legacy reasons only.\n• You can build a line of information piece by piece by making multiple calls to , or place an entire line of information into the buffer by calling .\n• When you call , the item you specify is automatically followed by an end-of-line marker. If you make calls to to build a line, you must add your own end-of-line marker by calling . and do not return lines that have not been terminated with a newline character.\n• If your lines exceed the line limit, you receive an error message.\n• Output that you create using or is buffered. The output cannot be retrieved until the PL/SQL program unit from which it was buffered returns to its caller. Buffer overflow, according to the limit specified in the ENABLE procedure call Line length overflow, limit of 32767 bytes for each line \n\n This procedure places a line in the buffer. The version that takes a input is obsolete. It is supported for legacy reasons only. Theversion that takes ainput is obsolete. It is supported for legacy reasons only.\n• You can build a line of information piece by piece by making multiple calls to , or place an entire line of information into the buffer by calling .\n• When you call , the item you specify is automatically followed by an end-of-line marker. If you make calls to to build a line, then you must add your own end-of-line marker by calling . and do not return lines that have not been terminated with a newline character.\n• If your lines exceeds the line limit, you receive an error message.\n• Output that you create using or is buffered. The output cannot be retrieved until the PL/SQL program unit from which it was buffered returns to its caller. Buffer overflow, according to the limit specified in the ENABLE procedure call Line length overflow, limit of 32767 bytes for each line"
    },
    {
        "link": "https://docs.oracle.com/cd/E11882_01/timesten.112/e21645/d_output.htm",
        "document": "The package enables you to send messages from stored procedures and packages. The package is especially useful for displaying PL/SQL debugging information.\n\nThis chapter contains the following topics:\n\nThis section contains topics which relate to using the package. The PUT procedure and PUT_LINE procedure in this package enable you to place information in a buffer that can be read by another procedure or package. In a separate PL/SQL procedure or anonymous block, you can display the buffered information by calling the GET_LINE procedure and GET_LINES procedure. If the package is disabled, all calls to subprograms are ignored. In this way, you can design your application so that subprograms are available only when a client can process the information.\n• If you do not call , or if you do not display the messages on your screen in , the buffered messages are ignored.\n• The utility calls after issuing a SQL statement or anonymous PL/SQL calls.\n• Typing in has the same effect as the following: There is no limit on the output.\n• You should generally avoid having application code invoke either the DISABLE procedure or ENABLE procedure because this could subvert the attempt by an external tool like to control whether to display output. Messages sent using are not actually sent until the sending subprogram completes. There is no mechanism to flush output during the execution of a procedure. Messages sent usingare not actually sent until the sending subprogram completes. There is no mechanism to flush output during the execution of a procedure.\n• The default buffer size is 20000 bytes. The minimum size is 2000 bytes and the maximum is unlimited. subprograms raise the application error , and the output procedures can return the following errors: The package is commonly used to debug stored procedures or functions. This function queries the table of the schema and returns the total salary for a specified department. The function includes calls to the procedure: CREATE OR REPLACE FUNCTION dept_salary (dnum NUMBER) RETURN NUMBER IS CURSOR emp_cursor IS select salary, commission_pct from employees where department_id = dnum; total_wages NUMBER(11, 2) := 0; counter NUMBER(10) := 1; BEGIN FOR emp_record IN emp_cursor LOOP emp_record.commission_pct := NVL(emp_record.commission_pct, 0); total_wages := total_wages + emp_record.salary + emp_record.commission_pct; DBMS_OUTPUT.PUT_LINE('Loop number = ' || counter || '; Wages = '|| TO_CHAR(total_wages)); /* Debug line */ counter := counter + 1; /* Increment debug counter */ END LOOP; /* Debug line */ DBMS_OUTPUT.PUT_LINE('Total wages = ' || TO_CHAR(total_wages)); RETURN total_wages; END; Assume the user executes the following statements in : The user would then see output such as the following:\n\nRetrieves an array of lines from buffer. \n\n This procedure disables calls to , , , , and , and purges the buffer of any remaining information. As with the ENABLE procedure, you do not need to call this procedure if you are using the setting from . This procedure enables calls to , , , , and . Calls to these procedures are ignored if the package is not activated. Upper limit, in bytes, for the amount of buffered information Setting to specifies that there should be no limit.\n• It is not necessary to call this procedure when you use from . It is called automatically (with value for in the current release).\n• If there are multiple calls to , then is the last of the values specified. The maximum size is 1,000,000 and the minimum is 2000 when the user specifies ( ).\n• is expected to be the usual choice. The default is 20000 for backward compatibility with earlier database versions that did not support unlimited buffering. You should declare this parameter as to avoid the risk of \" ORA-06502: PL/SQL: numeric or value error: character string buffer too small \". If the call completes successfully, then the status returns as 0. If there are no more lines in the buffer, then the status is 1.\n• You can choose to retrieve from the buffer a single line or an array of lines. Call to retrieve a single line of buffered information. To reduce the number of calls to the server, call to retrieve an array of lines from the buffer.\n• You can choose to automatically display this information if you are using by using the special command.\n• After calling or , any lines not retrieved before the next call to , , or are discarded to avoid confusing them with the next message. This procedure retrieves an array of lines from the buffer. DBMS_OUTPUT.GET_LINES ( OUT DBMS_OUTPUT.CHARARR, IN OUT INTEGER); DBMS_OUTPUT.GET_LINES ( OUT DBMS_OUTPUT.DBMSOUTPUT_LINESARRAY, IN OUT INTEGER); The maximum length of each line in the array is 32767 bytes. It is recommended that you use the varray overload version in a 3GL host program to execute the procedure from a PL/SQL anonymous block. Number of lines you want to retrieve from the buffer After retrieving the specified number of lines, the procedure returns the number of lines actually retrieved. If this number is less than the number of lines requested, then there are no more lines in the buffer.\n• You can choose to retrieve from the buffer a single line or an array of lines. Call to retrieve a single line of buffered information. To reduce the number of trips to the server, call to retrieve an array of lines from the buffer.\n• You can choose to automatically display this information if you are using by using the special command.\n• After or is called, any lines not retrieved before the next call to , , or are discarded to avoid confusing them with the next message. This procedure puts an end-of-line marker. The GET_LINE procedure and the GET_LINES procedure return \"lines\" as delimited by \"newlines\". Every call to the PUT_LINE procedure or to generates a line that is returned by or . This procedure places a partial line in the buffer. The version that takes a input is obsolete. It is supported for legacy reasons only. Theversion that takes ainput is obsolete. It is supported for legacy reasons only.\n• You can build a line of information piece by piece by making multiple calls to , or place an entire line of information into the buffer by calling .\n• When you call , the item you specify is automatically followed by an end-of-line marker. If you make calls to to build a line, you must add your own end-of-line marker by calling . and do not return lines that have not been terminated with a newline character.\n• If your lines exceed the line limit, you receive an error message.\n• Output that you create using or is buffered. The output cannot be retrieved until the PL/SQL program unit from which it was buffered returns to its caller. Buffer overflow, according to the limit specified in the ENABLE procedure call Line length overflow, limit of 32767 bytes for each line \n\n This procedure places a line in the buffer. The version that takes a input is obsolete. It is supported for legacy reasons only. Theversion that takes ainput is obsolete. It is supported for legacy reasons only.\n• You can build a line of information piece by piece by making multiple calls to , or place an entire line of information into the buffer by calling .\n• When you call , the item you specify is automatically followed by an end-of-line marker. If you make calls to to build a line, then you must add your own end-of-line marker by calling . and do not return lines that have not been terminated with a newline character.\n• If your lines exceeds the line limit, you receive an error message.\n• Output that you create using or is buffered. The output cannot be retrieved until the PL/SQL program unit from which it was buffered returns to its caller. Buffer overflow, according to the limit specified in the ENABLE procedure call Line length overflow, limit of 32767 bytes for each line"
    },
    {
        "link": "https://docs.oracle.com/database/timesten-18.1/TTPLP/d_output.htm",
        "document": "The package enables you to send messages from stored procedures and packages. The package is especially useful for displaying PL/SQL debugging information.\n\nThis chapter contains the following topics:"
    },
    {
        "link": "https://tutorialspoint.com/plsql/plsql_dbms_output.htm",
        "document": "In this chapter, we will discuss the DBMS Output in PL/SQL. The DBMS_OUTPUT is a built-in package that enables you to display output, debugging information, and send messages from PL/SQL blocks, subprograms, packages, and triggers. We have already used this package throughout our tutorial.\n\nLet us look at a small code snippet that will display all the user tables in the database. Try it in your database to list down all the table names −\n\nThe DBMS_OUTPUT package has the following subprograms −\n\nWhen the above code is executed at the SQL prompt, it produces the following result −"
    },
    {
        "link": "https://stackoverflow.com/questions/49537114/how-to-automatically-display-output-of-all-sql-statements-inside-anonymous-pl-sq",
        "document": "Our data migration scripts make use of anonymous PL/SQL blocks to help tidy up the code, mainly so we can set the create and updated user Id columns to a \"system\" user.\n\nOur migration scripts look something like:\n\nThe user who updated a record is a numeric Id from our users table, not the string username. This was a requirement from our data modeling team, otherwise I would just hard-code the username of our \"system\" account.\n\nAnd as an additional side note, our DBA runs the scripts, and he should not be the one showing up as the person/user who updated or inserted records. Another requirement from the larger enterprise environment.\n\nThe output I would like to see from the sqlplus command line is something like:\n\nJust like if you had run the INSERT and UPDATE statements outside of the PL/SQL block.\n\nAnd I'm really hoping for a solution that doesn't require explicit calls to .\n\nHow can I automatically display the output of each DML statement inside an anonymous PL/SQL block without explicit calls to for each statement?"
    }
]