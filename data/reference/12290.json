[
    {
        "link": "https://docs.python.org/3/library/random.html",
        "document": "This module implements pseudo-random number generators for various distributions.\n\nFor integers, there is uniform selection from a range. For sequences, there is uniform selection of a random element, a function to generate a random permutation of a list in-place, and a function for random sampling without replacement.\n\nOn the real line, there are functions to compute uniform, normal (Gaussian), lognormal, negative exponential, gamma, and beta distributions. For generating distributions of angles, the von Mises distribution is available.\n\nAlmost all module functions depend on the basic function , which generates a random float uniformly in the half-open range . Python uses the Mersenne Twister as the core generator. It produces 53-bit precision floats and has a period of 2**19937-1. The underlying implementation in C is both fast and threadsafe. The Mersenne Twister is one of the most extensively tested random number generators in existence. However, being completely deterministic, it is not suitable for all purposes, and is completely unsuitable for cryptographic purposes.\n\nThe functions supplied by this module are actually bound methods of a hidden instance of the class. You can instantiate your own instances of to get generators that don’t share state.\n\nClass can also be subclassed if you want to use a different basic generator of your own devising: see the documentation on that class for more details.\n\nThe module also provides the class which uses the system function to generate random numbers from sources provided by the operating system.\n\nReturn a random element from the non-empty sequence seq. If seq is empty, raises . Return a k sized list of elements chosen from the population with replacement. If the population is empty, raises . If a weights sequence is specified, selections are made according to the relative weights. Alternatively, if a cum_weights sequence is given, the selections are made according to the cumulative weights (perhaps computed using ). For example, the relative weights are equivalent to the cumulative weights . Internally, the relative weights are converted to cumulative weights before making selections, so supplying the cumulative weights saves work. If neither weights nor cum_weights are specified, selections are made with equal probability. If a weights sequence is supplied, it must be the same length as the population sequence. It is a to specify both weights and cum_weights. The weights or cum_weights can use any numeric type that interoperates with the values returned by (that includes integers, floats, and fractions but excludes decimals). Weights are assumed to be non-negative and finite. A is raised if all weights are zero. For a given seed, the function with equal weighting typically produces a different sequence than repeated calls to . The algorithm used by uses floating-point arithmetic for internal consistency and speed. The algorithm used by defaults to integer arithmetic with repeated selections to avoid small biases from round-off error. Changed in version 3.9: Raises a if all weights are zero. To shuffle an immutable sequence and return a new shuffled list, use instead. Note that even for small , the total number of permutations of x can quickly grow larger than the period of most random number generators. This implies that most permutations of a long sequence can never be generated. For example, a sequence of length 2080 is the largest that can fit within the period of the Mersenne Twister random number generator. Return a k length list of unique elements chosen from the population sequence. Used for random sampling without replacement. Returns a new list containing elements from the population while leaving the original population unchanged. The resulting list is in selection order so that all sub-slices will also be valid random samples. This allows raffle winners (the sample) to be partitioned into grand prize and second place winners (the subslices). Members of the population need not be hashable or unique. If the population contains repeats, then each occurrence is a possible selection in the sample. Repeated elements can be specified one at a time or with the optional keyword-only counts parameter. For example, is equivalent to . To choose a sample from a range of integers, use a object as an argument. This is especially fast and space efficient for sampling from a large population: . If the sample size is larger than the population size, a is raised. Changed in version 3.11: The population must be a sequence. Automatic conversion of sets to lists is no longer supported.\n\nThe following functions generate specific real-valued distributions. Function parameters are named after the corresponding variables in the distribution’s equation, as used in common mathematical practice; most of these equations can be found in any statistics text. Return the next random floating-point number in the range Return a random floating-point number N such that for and for . The end-point value may or may not be included in the range depending on floating-point rounding in the expression . Return a random floating-point number N such that and with the specified mode between those bounds. The low and high bounds default to zero and one. The mode argument defaults to the midpoint between the bounds, giving a symmetric distribution. Beta distribution. Conditions on the parameters are and . Returned values range between 0 and 1. Exponential distribution. lambd is 1.0 divided by the desired mean. It should be nonzero. (The parameter would be called “lambda”, but that is a reserved word in Python.) Returned values range from 0 to positive infinity if lambd is positive, and from negative infinity to 0 if lambd is negative. Changed in version 3.12: Added the default value for . Gamma distribution. (Not the gamma function!) The shape and scale parameters, alpha and beta, must have positive values. (Calling conventions vary and some sources define ‘beta’ as the inverse of the scale). Normal distribution, also called the Gaussian distribution. mu is the mean, and sigma is the standard deviation. This is slightly faster than the function defined below. Multithreading note: When two threads call this function simultaneously, it is possible that they will receive the same return value. This can be avoided in three ways. 1) Have each thread use a different instance of the random number generator. 2) Put locks around all calls. 3) Use the slower, but thread-safe function instead. Changed in version 3.11: mu and sigma now have default arguments. Log normal distribution. If you take the natural logarithm of this distribution, you’ll get a normal distribution with mean mu and standard deviation sigma. mu can have any value, and sigma must be greater than zero. Normal distribution. mu is the mean, and sigma is the standard deviation. Changed in version 3.11: mu and sigma now have default arguments. mu is the mean angle, expressed in radians between 0 and 2*pi, and kappa is the concentration parameter, which must be greater than or equal to zero. If kappa is equal to zero, this distribution reduces to a uniform random angle over the range 0 to 2*pi. Weibull distribution. alpha is the scale parameter and beta is the shape parameter.\n\n# Even integer from 0 to 100 inclusive ['four', 'two', 'ace', 'three'] # of 52 playing cards, and determine the proportion of cards # Estimate the probability of getting 5 or more heads from 7 spins # of a biased coin that settles on heads 60% of the time. # Probability of the median of 5 samples being in middle two quartiles Example of statistical bootstrapping using resampling with replacement to estimate a confidence interval for the mean of a sample: Example of a resampling permutation test to determine the statistical significance or p-value of an observed difference between the effects of a drug versus a placebo: # Example from \"Statistics is Easy\" by Dennis Shasha and Manda Wilson 'at least as extreme as the observed difference of leads us to reject the null' 'hypothesis that there is no difference between the drug and the placebo.' Simulation of arrival times and service deliveries for a multiserver queue: # time when each server becomes available Statistics for Hackers a video tutorial by Jake Vanderplas on statistical analysis using just a few fundamental concepts including simulation, sampling, shuffling, and cross-validation. Economics Simulation a simulation of a marketplace by Peter Norvig that shows effective use of many of the tools and distributions provided by this module (gauss, uniform, sample, betavariate, choice, triangular, and randrange). A Concrete Introduction to Probability (using Python) a tutorial by Peter Norvig covering the basics of probability theory, how to write simulations, and how to perform data analysis using Python.\n\nThese recipes show how to efficiently make random selections from the combinatoric iterators in the module: \"Choose r elements with replacement. Order the result to match the iterable.\" # Result will be in set(itertools.combinations_with_replacement(iterable, r)). The default returns multiples of 2⁻⁵³ in the range 0.0 ≤ x < 1.0. All such numbers are evenly spaced and are exactly representable as Python floats. However, many other representable floats in that interval are not possible selections. For example, isn’t an integer multiple of 2⁻⁵³. The following recipe takes a different approach. All floats in the interval are possible selections. The mantissa comes from a uniform distribution of integers in the range 2⁵² ≤ mantissa < 2⁵³. The exponent comes from a geometric distribution where exponents smaller than -53 occur half as often as the next larger exponent. All real valued distributions in the class will use the new method: The recipe is conceptually equivalent to an algorithm that chooses from all the multiples of 2⁻¹⁰⁷⁴ in the range 0.0 ≤ x < 1.0. All such numbers are evenly spaced, but most have to be rounded down to the nearest representable Python float. (The value 2⁻¹⁰⁷⁴ is the smallest positive unnormalized float and is equal to .) Generating Pseudo-random Floating-Point Values a paper by Allen B. Downey describing ways to generate more fine-grained floats than normally generated by ."
    },
    {
        "link": "https://stackoverflow.com/questions/17779480/python-random-map-generation-with-perlin-noise",
        "document": "Recently, I've been attempting to defeat one of my main weaknesses in programming in general, random generation. I thought it would be an easy thing to do, but the lack of simple information is killing me on it. I don't want to sound dumb, but it feels to me like most of the information from places like this are written for mathematicians who went to college to graduate in theoretical mathematics. I just don't understand what I'm meant to do with that information in order to apply it to programming in a language such as python.\n\nI've been working a few days staring at equations and attempting attempt after attempt, but still after all those days, after ripping my code apart again and again, all that's been working properly this entire time is this noise generator to generate basic noise:\n\nI'm wanting it to eventually produce something like this:\n\nHow can I manage to smooth out the white-noise I generate, and turn it into islands? Can anyone explain it in a very simplistic way for me?\n\nI may be thinking about all of this very wrong."
    },
    {
        "link": "https://docs.python.org/2/library/random.html",
        "document": "This module implements pseudo-random number generators for various distributions.\n\nFor integers, uniform selection from a range. For sequences, uniform selection of a random element, a function to generate a random permutation of a list in-place, and a function for random sampling without replacement.\n\nOn the real line, there are functions to compute uniform, normal (Gaussian), lognormal, negative exponential, gamma, and beta distributions. For generating distributions of angles, the von Mises distribution is available.\n\nAlmost all module functions depend on the basic function , which generates a random float uniformly in the semi-open range [0.0, 1.0). Python uses the Mersenne Twister as the core generator. It produces 53-bit precision floats and has a period of 2**19937-1. The underlying implementation in C is both fast and threadsafe. The Mersenne Twister is one of the most extensively tested random number generators in existence. However, being completely deterministic, it is not suitable for all purposes, and is completely unsuitable for cryptographic purposes.\n\nThe functions supplied by this module are actually bound methods of a hidden instance of the class. You can instantiate your own instances of to get generators that don’t share state. This is especially useful for multi-threaded programs, creating a different instance of for each thread, and using the method to make it likely that the generated sequences seen by each thread don’t overlap.\n\nClass can also be subclassed if you want to use a different basic generator of your own devising: in that case, override the , , , and methods. Optionally, a new generator can supply a method — this allows to produce selections over an arbitrarily large range.\n\nAs an example of subclassing, the module provides the class that implements an alternative generator in pure Python. The class provides a backward compatible way to reproduce results from earlier versions of Python, which used the Wichmann-Hill algorithm as the core generator. Note that this Wichmann-Hill generator can no longer be recommended: its period is too short by contemporary standards, and the sequence generated is known to fail some stringent randomness tests. See the references below for a recent variant that repairs these flaws.\n\nThe module also provides the class which uses the system function to generate random numbers from sources provided by the operating system.\n\nReturn a k length list of unique elements chosen from the population sequence. Used for random sampling without replacement. Returns a new list containing elements from the population while leaving the original population unchanged. The resulting list is in selection order so that all sub-slices will also be valid random samples. This allows raffle winners (the sample) to be partitioned into grand prize and second place winners (the subslices). Members of the population need not be hashable or unique. If the population contains repeats, then each occurrence is a possible selection in the sample. To choose a sample from a range of integers, use an object as an argument. This is especially fast and space efficient for sampling from a large population: .\n\nThe following functions generate specific real-valued distributions. Function parameters are named after the corresponding variables in the distribution’s equation, as used in common mathematical practice; most of these equations can be found in any statistics text."
    },
    {
        "link": "https://numpy.org/doc/2.1/reference/random/generator.html",
        "document": "The provides access to a wide range of distributions, and served as a replacement for . The main difference between the two is that relies on an additional BitGenerator to manage state and generate the random bits, which are then transformed into random values from useful distributions. The default BitGenerator used by is . The BitGenerator can be changed by passing an instantized BitGenerator to .\n\nConstruct a new Generator with the default BitGenerator (PCG64). A seed to initialize the . If None, then fresh, unpredictable entropy will be pulled from the OS. If an or is passed, then all values must be non-negative and will be passed to to derive the initial state. One may also pass in a instance. Additionally, when passed a , it will be wrapped by . If passed a , it will be returned unaltered. If is not a or a , a new is instantiated. This function does not manage a default global instance. See Seeding and entropy for more information about seeding. is the recommended constructor for the random number class . Here are several ways we can construct a random number generator using and the class. Here we use to generate a random float: Here we use to generate 3 random integers between 0 (inclusive) and 10 (exclusive): Here we specify a seed so that we have reproducible results: If we exit and restart our Python interpreter, we’ll see that we generate the same random numbers again:\n\nexposes a number of methods for generating random numbers drawn from a variety of probability distributions. In addition to the distribution-specific arguments, each method takes a keyword argument size that defaults to . If size is , then a single value is generated and returned. If size is an integer, then a 1-D array filled with generated values is returned. If size is a tuple, then an array with that shape is filled and returned. The function will instantiate a with numpy’s default . does not provide a version compatibility guarantee. In particular, as better algorithms evolve the bit stream may change. BitGenerator to use as the core generator. The Python stdlib module contains pseudo-random number generator with a number of methods that are similar to the ones available in . It uses Mersenne Twister, and this bit generator can be accessed using . , besides being NumPy-aware, has the advantage that it provides a much larger number of probability distributions to choose from.\n\nThe methods for randomly permuting a sequence are Modify an array or sequence in-place by shuffling its contents. The following table summarizes the behaviors of the methods. either (use ‘out’ for in-place) The following subsections provide more details about the differences. The main difference between and is that operates in-place, while returns a copy. By default, returns a copy. To operate in-place with , pass the same array as the first argument and as the value of the parameter. For example, Note that when is given, the return value is : An important distinction for these methods is how they handle the parameter. Both and treat the input as a one-dimensional sequence, and the parameter determines which dimension of the input array to use as the sequence. In the case of a two-dimensional array, will, in effect, rearrange the rows of the array, and will rearrange the columns. For example Note that the columns have been rearranged “in bulk”: the values within each column have not changed. The method treats the parameter similar to how treats it. Each slice along the given axis is shuffled independently of the others. Compare the following example of the use of to the above example of : In this example, the values within each row (i.e. the values along ) have been shuffled independently. This is not a “bulk” shuffle of the columns. works on non-NumPy sequences. That is, if it is given a sequence that is not a NumPy array, it shuffles that sequence in-place."
    },
    {
        "link": "https://reddit.com/r/Python/comments/2ei05d/noise_library_is_producing_nonrandom_results_what",
        "document": "Here is the source code, here is the noise code, and here is an image of the result\n\nIt returns the same result and I am not sure how to randomize it. I am starting to think that the library is not responsible for randomizing it's perlin noise, and if that is the case I'm not sure how to go about from here on. I want the program to produce a new \"island\" every time I run the program."
    },
    {
        "link": "https://medium.com/@yvanscher/playing-with-perlin-noise-generating-realistic-archipelagos-b59f004d8401",
        "document": "In the python noise module there are a few parameters that affect what you see when you generate your perlin noise:\n• scale: number that determines at what distance to view the noisemap.\n• octaves: the number of levels of detail you want you perlin noise to have.\n• lacunarity: number that determines how much detail is added or removed at each octave (adjusts frequency).\n• persistence: number that determines how much each octave contributes to the overall shape (adjusts amplitude).\n\nWe won’t worry about scale too much, you can use it to zoom out (bigger scale) or in (smaller scale).\n\nPerlin noise combines multiple functions called ‘octaves’ to produce natural looking surfaces. Each octave adds a layer of detail to the surface. For example: octave 1 could be mountains, octave 2 could be boulders, octave 3 could be the rocks.\n\nLacunarity of more than 1 means that each octave will increase it’s level of fine grained detail (increased frqeuency). Lacunarity of 1 means that each octave will have the sam level of detail. Lacunarity of less than one means that each octave will get smoother. The last two are usually undesirable so a lacunarity of 2 works quite well.\n\nPersistence determines how much each octave contributes to the overall structure of the noise map. If your persistence is 1 all octaves contribute equally. If you persistence is more than 1 sucessive octaves contribute more and you get something closer to regular noise (spoiler the regular noise image above is actually a perlin noise with a presistence of 5.0). A more default setting would be a presistance of less than 1.0 which will decrease the effect of later octaves.\n\nEnough chatting though! Let’s run some experiments. First let’s start with default perlin noise, and its accompanying image:\n\nThe way this perlin noise looks in our script is a 2D array of values between -1 and 1. The values that are darker on the map are lower values, the values that are close to 1 are lighter. What I want to try next is assigning two colors to different ranges of values in this map to produce some terrain:\n\nThis terrain map is pretty neat; it has jagged coasts, beaches, and lots of water. while I have never observed natural terrain that looks like this if we look at any one part of the map it seems ‘realistic.’ Let’s take it a step further and add mountains and snow:\n\nThis is cool but this terrain pattern is clearly not natural. To make it more natural we will use a circular filter to get rid of all the preipheral perlin noise:\n\nHere I was trying to create an island so I made a circular filter and then applied it to the color_world perlin noise array. What I ended up was a planet floating in an ocean. I changed the ocean color to black and it looks pretty cool! That said what I wanted was an island so let’s try again. This time we’re going to calculate a circular gradient and then apply that over the perlin noise as a filter.\n\nI struggled a lot with this part. I’m sure there is a more efficient way to get the gradient like this but the above was what I came up with. I calculated a distance metric from the center of the map and then normalized, shrunk, and renomalized those distances to produce this spherical gradient. Again lighter means the value is closer to 1, darker colors are closer to 0. Next I apply this circular gradient to the perlin noise we created before.\n\nThis part was less tricky but still a pain. I multiply the perlin noise by the circle gradient and then I increase the contrast by multiplying positive (lighter values) by 20. Then I renormalize to make it 0–1 again.\n\nThis is really cool and it looks like a much more natural archipelago. I encourage you to try different shading methods and maybe randomly removing some sections. I’m going to change the threshold value and set it as . That will produce a smaller but more realistic archipelago as so:\n\nThere we are! We have a natural looking island archipelago! So now that we have our islands you may notice that no matter how often you rerun this script perlin noise will produce the same islands. To get new islands you can set the parameter of the pnoise2 function to a random integer number, let’s try :"
    },
    {
        "link": "https://gmschroeder.com/blog/intro_pyart1.html",
        "document": ""
    },
    {
        "link": "https://stackoverflow.com/questions/60350598/perlin-noise-in-pythons-noise-library",
        "document": "I have a problem with generating Perlin noise for my project. As I wanted to understand how to use library properly, I tried to follow step-by-step this page: https://medium.com/@yvanscher/playing-with-perlin-noise-generating-realistic-archipelagos-b59f004d8401 In first part, there is code:\n\nI copy-paste it with small change at the end (toimage is obsolete) so I have:\n\nI tried a lot of diffrient modes, but this noise is not even close to coherent noise. My result is something like this (mode='L'). Could someone explain me, what am I doing wrong?"
    },
    {
        "link": "https://github.com/pvigier/perlin-numpy",
        "document": "I wrote two articles on my blog about this project, the first one is about the generation of 2D noise while the second one is about the generation of 3D noise, feel free to read them!\n\nYou can find implementations using numba here.\n\nYou can install this package via:\n\nThe function generates a 2D texture of perlin noise. Its parameters are:\n• : shape of the generated array (tuple of 2 ints)\n• : number of periods of noise to generate along each axis (tuple of 2 ints)\n• : if the noise should be tileable along each axis (tuple of 2 bools)\n\nNote: must be a multiple of\n\nThe function combines several octaves of 2D perlin noise to make 2D fractal noise. Its parameters are:\n• : shape of the generated array (tuple of 2 ints)\n• : number of periods of noise to generate along each axis (tuple of 2 ints)\n• : number of octaves in the noise (int)\n• : if the noise should be tileable along each axis (tuple of 2 bools)\n\nNote: must be a multiple of\n\nThe function generates a 3D texture of perlin noise. Its parameters are:\n• : shape of the generated array (tuple of 3 ints)\n• : number of periods of noise to generate along each axis (tuple of 3 ints)\n• : if the noise should be tileable along each axis (tuple of 3 bools)\n\nNote: must be a multiple of\n\nThe function combines several octaves of 3D perlin noise to make 3D fractal noise. Its parameters are:\n• : shape of the generated array (tuple of 3 ints)\n• : number of periods of noise to generate along each axis (tuple of 3 ints)\n• : number of octaves in the noise (int)\n• : if the noise should be tileable along each axis (tuple of 3 bools)\n\nNote: must be a multiple of"
    },
    {
        "link": "http://kmdouglass.github.io/posts/perlin-noise",
        "document": "Since my last post, I have been experimenting with the noise package from Casey Duncan. This package is the easy solution for generating Perlin noise that I had hoped for. It seems simple and fast, though one downside at least to me is that it doesn't play so nicely with numpy arrays. This is not a big deal, though. It was probably not developed for scientists but rather for game design and/or computer graphics. So, let's use this library to continue exploring the question of why correlated noise often makes for a better model of the real world.\n\nThe and parameters determine how much energy is contained at frequencies in each successive octave of the noise's power spectrum. These parameters determine the presence and strength, respectively, of the finer details in the noise signal. Before going into them with more detail, we can vary them and observe the outcome. Here's the result of varying the number of octaves.\n\nIn the above plot, and besides constant offsets to aid in visualization, I added one and three additional octaves to the noise, keeping the persistence fixed. Increasing the octaves makes the curve appear more 'jagged' and noisy on the smaller scales, much like extending the frequency range of the filter applied to the random signal from my last post. Over longer time scales, the curve more or less follows the original one. Below you can see what happens when we use four octaves but increase the persistence gradually. The amplitude of the spikes at small time scales increases with increasing persistence.\n\nWe're now in a good position to summarize a few of the main characteristics about Perlin noise. I'll use the term 'feature' as a loose definition for the hills and valleys seen in the curves.\n• Perlin noise is a random signal that is correlated over short time scales.\n• The number of octaves determines the time/length scales at which features in the signal are present.\n• The persistence determines the amplitude of the features. The existence of features at smaller-and-smaller scales and how strongly these features decrease in amplitude with scale are the fractal-like properties of the noise signal. So Perlin noise is essentially a way of generating random fractals on a computer. Unlike the deterministic fractals that we normally think of, these are statistical. In the final parts of this post, let's see how we can use correlated noise to model realistic motions of particles.\n\nThe Perlin walker is just a calm, casual guy out for a walk, whereas the Brownian walker is your officemate after five cups of coffee. So there you have it! Perlin noise is an interesting tool for generating correlated noise forms on a computer. It's used in a number of applications in computer graphics, animation, and games to produce realistic-looking patterns. I only mentioned it briefly, but one of the reasons its patterns look more realistic than white noise forms is that it has fractal properties. In a later post, I'll explore what I mean by this by using the FFT tools and the pink noise example I generated in my last post."
    }
]