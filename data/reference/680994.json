[
    {
        "link": "https://freecodecamp.org/news/with-open-in-python-with-statement-syntax-example",
        "document": "The Python programming language has various functions and statements for working with a file. The statement and function are two of those statements and functions.\n\nIn this article, you will learn how to use both the statement and function to work with files in Python.\n\nWhat Does Do in Python?\n\nTo work with files in Python, you have to open the file first. So, the function does what the name implies – it opens a file for you so you can work with the file.\n\nTo use the open function, you declare a variable for it first. The function takes up to 3 parameters – the filename, the mode, and the encoding. You can then specify what you want to do with the file in a print function.\n\nThat’s not all. The function does not close the file, so you also have to close the file with the method.\n\nSo, a proper way to use the open function looks like this:\n\nThe read mode is the default file mode in Python, so if you don’t specify the mode, the code above still works fine:\n\nHow Does the Statement Work in Python?\n\nThe statement works with the function to open a file.\n\nSo, you can re-write the code we used in the function example like this:\n\nUnlike where you have to close the file with the method, the statement closes the file for you without you telling it to.\n\nThis is because the statement calls 2 built-in methods behind the scene – and .\n\nThe method closes the file when the operation you specify is done.\n\nWith the method, you also write to the file as I did below:\n\nYou can also loop through the file and print the text line by line:\n\nYou might be wondering which way you should use to work with files between the combo of and and just the function.\n\nI would advise you to use the combination of and because the statement closes the file for you and you get to write less code."
    },
    {
        "link": "https://geeksforgeeks.org/file-handling-python",
        "document": "File handling refers to the process of performing operations on a file such as creating, opening, reading, writing and closing it, through a programming interface. It involves managing the data flow between the program and the file system on the storage device, ensuring that data is handled safely and efficiently.\n\nTo open a file we can use function, which requires file path and mode as arguments:\n\nWhen opening a file, we must specify the mode we want to which specifies what we want to do with the file. Here’s a table of the different modes available:\n\nOpens the file for reading. File must exist; otherwise, it raises an error. Opens the file for reading binary data. File must exist; otherwise, it raises an error. Opens the file for both reading and writing. File must exist; otherwise, it raises an error. Opens the file for both reading and writing binary data. File must exist; otherwise, it raises an error. Opens the file for writing. Creates a new file or truncates the existing file. Opens the file for writing binary data. Creates a new file or truncates the existing file. Opens the file for both writing and reading. Creates a new file or truncates the existing file. Opens the file for both writing and reading binary data. Creates a new file or truncates the existing file. Opens the file for appending data. Creates a new file if it doesn’t exist. Opens the file for appending binary data. Creates a new file if it doesn’t exist. Opens the file for appending and reading. Creates a new file if it doesn’t exist. Opens the file for appending and reading binary data. Creates a new file if it doesn’t exist. Creates a new file. Raises an error if the file already exists. Creates a new binary file. Raises an error if the file already exists. Creates a new file for reading and writing. Raises an error if the file exists. Exclusive creation with read and write in binary mode. Creates a new binary file for reading and writing. Raises an error if the file exists.\n\nFor this article we are using text file with text:\n\nReading a file can be achieved by file.read() which reads the entire content of the file. After reading the file we can close the file using file.close() which closes the file after reading it, which is necessary to free up system resources.\n\nWriting to a file is done using file.write() which writes the specified string to the file. If the file exists, its content is erased. If it doesn’t exist, a new file is created.\n\nExample: Writing to a File in Write Mode (w)\n\nIt is done using adds the specified string to the end of the file without erasing its existing content.\n\nExample: For this example, we will use the Python file created in the previous example.\n\nClosing a file is essential to ensure that all resources used by the file are properly released. loses the file and ensures that any changes made to the file are saved.\n\nstatement is used for resource management. It ensures that file is properly closed after its suite finishes, even if an exception is raised. with open() as method automatically handles closing the file once the block of code is exited, even if an error occurs. This reduces the risk of file corruption and resource leakage.\n\nIt’s important to handle exceptions to ensure that files are closed properly, even if an error occurs during file operations.\n• None Versatility : File handling in Python allows us to perform a wide range of operations, such as creating, reading, writing, appending, renaming and deleting files.\n• Flexibility : File handling in Python is highly flexible, as it allows us to work with different file types (e.g. text files, binary files, CSV files , etc.) and to perform different operations on files (e.g. read, write, append, etc.).\n• User – friendly : Python provides a user-friendly interface for file handling, making it easy to create, read and manipulate files.\n• Cross-platform : Python file-handling functions work across different platforms (e.g. Windows, Mac, Linux), allowing for seamless integration and compatibility.\n• Error-prone: File handling operations in Python can be prone to errors, especially if the code is not carefully written or if there are issues with the file system (e.g. file permissions, file locks, etc.).\n• Security risks : File handling in Python can also pose security risks, especially if the program accepts user input that can be used to access or modify sensitive files on the system.\n• Complexity : File handling in Python can be complex, especially when working with more advanced file formats or operations. Careful attention must be paid to the code to ensure that files are handled properly and securely.\n• Performance : File handling operations in Python can be slower than other programming languages, especially when dealing with large files or performing complex operations.\n\nWhat are the types of files in Python?\n\nWhat are the 4 file handling functions?\n\nWhy is file handling useful?\n\nIn Python file handling, is a method of file objects that returns the current position of the file pointer (cursor) within the file. It returns an integer representing the byte offset from the beginning of the file where the next read or write operation will occur. # Open a file in read mode file = open('example.txt', 'r') # Read the first 10 characters content = file.read(10) print(content) # Check the current position of the file pointer position = file.tell() print(\"Current position:\", position) # Close the file file.close()\n• None reads the first 10 characters from the file.\n• None returns the current position of the file pointer after reading."
    },
    {
        "link": "https://docs.python.org/3/tutorial/inputoutput.html",
        "document": "There are several ways to present the output of a program; data can be printed in a human-readable form, or written to a file for future use. This chapter will discuss some of the possibilities.\n\nSo far we’ve encountered two ways of writing values: expression statements and the function. (A third way is using the method of file objects; the standard output file can be referenced as . See the Library Reference for more information on this.) Often you’ll want more control over the formatting of your output than simply printing space-separated values. There are several ways to format output.\n• None To use formatted string literals, begin a string with or before the opening quotation mark or triple quotation mark. Inside this string, you can write a Python expression between and characters that can refer to variables or literal values.\n• None The method of strings requires more manual effort. You’ll still use and to mark where a variable will be substituted and can provide detailed formatting directives, but you’ll also need to provide the information to be formatted. In the following code block there are two examples of how to format variables: Notice how the are padded with spaces and a negative sign only for negative numbers. The example also prints multiplied by 100, with 2 decimal places and followed by a percent sign (see Format Specification Mini-Language for details).\n• None Finally, you can do all the string handling yourself by using string slicing and concatenation operations to create any layout you can imagine. The string type has some methods that perform useful operations for padding strings to a given column width. When you don’t need fancy output but just want a quick display of some variables for debugging purposes, you can convert any value to a string with the or functions. The function is meant to return representations of values which are fairly human-readable, while is meant to generate representations which can be read by the interpreter (or will force a if there is no equivalent syntax). For objects which don’t have a particular representation for human consumption, will return the same value as . Many values, such as numbers or structures like lists and dictionaries, have the same representation using either function. Strings, in particular, have two distinct representations. The value of x is 32.5, and y is 40000... # The repr() of a string adds string quotes and backslashes: # The argument to repr() may be any Python object: The module contains a class that offers yet another way to substitute values into strings, using placeholders like and replacing them with values from a dictionary, but offers much less control of the formatting. Formatted string literals (also called f-strings for short) let you include the value of Python expressions inside a string by prefixing the string with or and writing expressions as . An optional format specifier can follow the expression. This allows greater control over how the value is formatted. The following example rounds pi to three places after the decimal: 'The value of pi is approximately The value of pi is approximately 3.142. Passing an integer after the will cause that field to be a minimum number of characters wide. This is useful for making columns line up. Other modifiers can be used to convert the value before it is formatted. applies , applies , and applies : 'My hovercraft is full of My hovercraft is full of eels. 'My hovercraft is full of My hovercraft is full of 'eels'. The specifier can be used to expand an expression to the text of the expression, an equal sign, then the representation of the evaluated expression: See self-documenting expressions for more information on the specifier. For a reference on these format specifications, see the reference guide for the Format Specification Mini-Language. Basic usage of the method looks like this: We are the knights who say \"Ni!\" The brackets and characters within them (called format fields) are replaced with the objects passed into the method. A number in the brackets can be used to refer to the position of the object passed into the method. If keyword arguments are used in the method, their values are referred to by using the name of the argument. Positional and keyword arguments can be arbitrarily combined: The story of Bill, Manfred, and Georg. If you have a really long format string that you don’t want to split up, it would be nice if you could reference the variables to be formatted by name instead of by position. This can be done by simply passing the dict and using square brackets to access the keys. This could also be done by passing the dictionary as keyword arguments with the notation. This is particularly useful in combination with the built-in function , which returns a dictionary containing all local variables: __name__: __main__; __doc__: None; __package__: None; __loader__: ... As an example, the following lines produce a tidily aligned set of columns giving integers and their squares and cubes: For a complete overview of string formatting with , see Format String Syntax. Here’s the same table of squares and cubes, formatted manually: # Note use of 'end' on previous line The method of string objects right-justifies a string in a field of a given width by padding it with spaces on the left. There are similar methods and . These methods do not write anything, they just return a new string. If the input string is too long, they don’t truncate it, but return it unchanged; this will mess up your column lay-out but that’s usually better than the alternative, which would be lying about a value. (If you really want truncation you can always add a slice operation, as in .) There is another method, , which pads a numeric string on the left with zeros. It understands about plus and minus signs: The % operator (modulo) can also be used for string formatting. Given (where format is a string), conversion specifications in format are replaced with zero or more elements of values. This operation is commonly known as string interpolation. For example: 'The value of pi is approximately The value of pi is approximately 3.142. More information can be found in the printf-style String Formatting section.\n\nreturns a file object, and is most commonly used with two positional arguments and one keyword argument: The first argument is a string containing the filename. The second argument is another string containing a few characters describing the way in which the file will be used. mode can be when the file will only be read, for only writing (an existing file with the same name will be erased), and opens the file for appending; any data written to the file is automatically added to the end. opens the file for both reading and writing. The mode argument is optional; will be assumed if it’s omitted. Normally, files are opened in text mode, that means, you read and write strings from and to the file, which are encoded in a specific encoding. If encoding is not specified, the default is platform dependent (see ). Because UTF-8 is the modern de-facto standard, is recommended unless you know that you need to use a different encoding. Appending a to the mode opens the file in binary mode. Binary mode data is read and written as objects. You can not specify encoding when opening file in binary mode. In text mode, the default when reading is to convert platform-specific line endings ( on Unix, on Windows) to just . When writing in text mode, the default is to convert occurrences of back to platform-specific line endings. This behind-the-scenes modification to file data is fine for text files, but will corrupt binary data like that in or files. Be very careful to use binary mode when reading and writing such files. It is good practice to use the keyword when dealing with file objects. The advantage is that the file is properly closed after its suite finishes, even if an exception is raised at some point. Using is also much shorter than writing equivalent - blocks: # We can check that the file has been automatically closed. If you’re not using the keyword, then you should call to close the file and immediately free up any system resources used by it. Calling without using the keyword or calling might result in the arguments of not being completely written to the disk, even if the program exits successfully. After a file object is closed, either by a statement or by calling , attempts to use the file object will automatically fail. The rest of the examples in this section will assume that a file object called has already been created. To read a file’s contents, call , which reads some quantity of data and returns it as a string (in text mode) or bytes object (in binary mode). size is an optional numeric argument. When size is omitted or negative, the entire contents of the file will be read and returned; it’s your problem if the file is twice as large as your machine’s memory. Otherwise, at most size characters (in text mode) or size bytes (in binary mode) are read and returned. If the end of the file has been reached, will return an empty string ( ). 'This is the entire file.\n\n' reads a single line from the file; a newline character ( ) is left at the end of the string, and is only omitted on the last line of the file if the file doesn’t end in a newline. This makes the return value unambiguous; if returns an empty string, the end of the file has been reached, while a blank line is represented by , a string containing only a single newline. 'This is the first line of the file.\n\n' 'Second line of the file\n\n' For reading lines from a file, you can loop over the file object. This is memory efficient, fast, and leads to simple code: This is the first line of the file. If you want to read all the lines of a file in a list you can also use or . writes the contents of string to the file, returning the number of characters written. Other types of objects need to be converted – either to a string (in text mode) or a bytes object (in binary mode) – before writing them: returns an integer giving the file object’s current position in the file represented as number of bytes from the beginning of the file when in binary mode and an opaque number when in text mode. To change the file object’s position, use . The position is computed from adding offset to a reference point; the reference point is selected by the whence argument. A whence value of 0 measures from the beginning of the file, 1 uses the current file position, and 2 uses the end of the file as the reference point. whence can be omitted and defaults to 0, using the beginning of the file as the reference point. # Go to the 6th byte in the file # Go to the 3rd byte before the end In text files (those opened without a in the mode string), only seeks relative to the beginning of the file are allowed (the exception being seeking to the very file end with ) and the only valid offset values are those returned from the , or zero. Any other offset value produces undefined behaviour. File objects have some additional methods, such as and which are less frequently used; consult the Library Reference for a complete guide to file objects. Strings can easily be written to and read from a file. Numbers take a bit more effort, since the method only returns strings, which will have to be passed to a function like , which takes a string like and returns its numeric value 123. When you want to save more complex data types like nested lists and dictionaries, parsing and serializing by hand becomes complicated. Rather than having users constantly writing and debugging code to save complicated data types to files, Python allows you to use the popular data interchange format called JSON (JavaScript Object Notation). The standard module called can take Python data hierarchies, and convert them to string representations; this process is called serializing. Reconstructing the data from the string representation is called deserializing. Between serializing and deserializing, the string representing the object may have been stored in a file or data, or sent over a network connection to some distant machine. The JSON format is commonly used by modern applications to allow for data exchange. Many programmers are already familiar with it, which makes it a good choice for interoperability. If you have an object , you can view its JSON string representation with a simple line of code: Another variant of the function, called , simply serializes the object to a text file. So if is a text file object opened for writing, we can do this: To decode the object again, if is a binary file or text file object which has been opened for reading: JSON files must be encoded in UTF-8. Use when opening JSON file as a text file for both of reading and writing. This simple serialization technique can handle lists and dictionaries, but serializing arbitrary class instances in JSON requires a bit of extra effort. The reference for the module contains an explanation of this. Contrary to JSON, pickle is a protocol which allows the serialization of arbitrarily complex Python objects. As such, it is specific to Python and cannot be used to communicate with applications written in other languages. It is also insecure by default: deserializing pickle data coming from an untrusted source can execute arbitrary code, if the data was crafted by a skilled attacker."
    },
    {
        "link": "https://geeksforgeeks.org/how-to-open-a-file-using-the-with-statement",
        "document": "How to open a file using the with statement\n\nThe with keyword in Python is used as a context manager. As in any programming language, the usage of resources like file operations or database connections is very common. But these resources are limited in supply. Therefore, the main problem lies in making sure to release these resources after usage. If they are not released, then it will lead to resource leakage and may cause the system to either slow down or crash.\n\nAs we know, the open() function is generally used for file handling in Python. But it is a standard practice to use context managers like with keywords to handle files as it will automatically release files once its usage is complete.\n\nfile_path: It is the path to the file to open mode: mode of operation on the file. ex.: read, write etc. (represented by r, w, r+, w+, rb, wb etc.)\n\nExample 1: Simple Example Using The with Statement\n\nWe already have a file name geeksforgeeks.txt in our system, and it has the following data:\n\nNow we will open the file and read the contents of the file using with open() statement:\n\nNote: Here we have used mode as “r” to read the data, because the target file has text data. In case we are reading some binary file, we need to use “rb” as the mode.\n\nExample 2: We can also use the with statement to append or write data to the file.\n\nWe will append the string “Hello geeks!” to our geeksforgeeks.txt file.\n\nNote: Here we have used “a” as the mode of opening the file, this is because we want to append to the file data. Instead, if we wanted to overwrite the file data, we would use the “w” mode.\n\nExample 3: Using nested with open statement to open multiple files\n\nWe have defined a links.txt file containing some random links. We will open the geeksforgeeks.txt file mentioned above and append the content of the links file into the geeksforgeeks.txt file.\n\nHere, we can see that the contents of the links.txt file has been added to the geeksforgeeks.txt file after running the script.\n\nDifference of using open() vs with open()\n\nAlthough the function of using open() and with open() is exactly same but, there are some important differences:\n• Using open() we can use the file handler as long as the file has not been explicitly closed using file_handler.close(), but in case of using with open() context manager, we cannot use a file handler outside the with block. It will raise ValueError: I/O operation on closed file in that case.\n• While using open() we need to explicitly close an opened file instance, else other parts of code may face errors while opening the same file. In with open() the closing of the file is handled by the context manager.\n• Using with open() context statement makes the code more tidy as we can easily separate between code block by difference in indents. In case of open(), we might miss closing the file instance, this may cause memory leaks and other I/O operation errors."
    },
    {
        "link": "https://stackoverflow.com/questions/9282967/how-to-open-a-file-using-the-open-with-statement",
        "document": "Python allows putting multiple statements in a single . You comma-separate them. Your code would then be:\n\nAnd no, you don't gain anything by putting an explicit at the end of your function. You can use to exit early, but you had it at the end, and the function will exit without it. (Of course with functions that return a value, you use the to specify the value to return.)\n\nUsing multiple items with was not supported in Python 2.5 when the statement was introduced, or in Python 2.6, but it is supported in Python 2.7 and Python 3.1 or newer.\n\nIf you are writing code that must run in Python 2.5, 2.6 or 3.0, nest the statements as the other answers suggested or use ."
    },
    {
        "link": "https://geeksforgeeks.org/string-slicing-in-python",
        "document": "String slicing in Python is a way to get specific parts of a string by using start, end, and step values. It’s especially useful for text manipulation and data parsing.\n\nLet’s take a quick example of string slicing:\n\nExplanation: In this example, we used the slice s[0:5] to obtain the substring “Hello” from the original string.\n• end (optional): Stopping index (exclusive). Defaults to the end of the string if omitted.\n• step (optional): Interval between indices. A positive value slices from left to right, while a negative value slices from right to left. If omitted, it defaults to 1 (no skipping of characters).\n• None The result of a slicing operation is always a string ( str type) that contains a subset of the characters from the original string.\n\nLet’s see how to use string slicing in Python with the examples below.\n\nTo retrieve the entire string, use slicing without specifying any parameters.\n\nExplanation: Using [:] or [::] without specifying start, end, or step returns the complete string.\n\nGet All Characters Before or After a Specific Position\n\nTo get all the items from a specific position to the end of the string, we can specify the start index and leave the end blank.\n\nAnd to get all the items before a specific index, we can specify the end index while leaving start blank.\n\nExplanation: The slice s[7:] starts from index 7 and continues to the end of the string.\n\nTo extract characters between specific positions, provide both start and end indices.\n\nTo retrieve characters at regular intervals, use the step parameter.\n\nExplanation: The slice s[::2] takes every second character from the string.\n\nIn Python, String slicing allows out-of-bound indexing without raising errors. If indices exceed the string length, the slice returns only available characters without raising an error.\n\nExample: The slice s[3:15] starts at index 3 and attempts to reach index 15, but if string ends at index 8 then it will return only the available elements.\n\nNegative indexing is useful for accessing elements from the end of the String. The last element has an index of -1, the second last element -2, and so on.\n\nBelow example shows how to use negative numbers to access elements from the string starting from the end. Negative indexing makes it easy to get items without needing to know the exact length of the string.\n\nTo reverse a string, use a negative step value of -1, which moves from the end of the string to the beginning.\n\nExplanation: The slice s[::-1] starts from the end and steps backward through the string, which effectively reversing it. This method does not alter the original string."
    },
    {
        "link": "https://stackoverflow.com/questions/52982551/find-repeating-pattern-in-a-string",
        "document": "What I need is\n\nI don't want to use a regex as I'll get different pattern of repetition such as the below where regex for above won't work for the below\n\nI started with creating the structural representation(converting [A-Z] to 'A' and [0-9] to '9') for the first example\n\nMy question is, how do I go by recognizing pattern in each string on the fly and then get the matches?\n\nNOTE: The pattern is unknown, but it is known that some set of charcters repeat after sometime\n\nI don't want to use regex written manually. If system generates the regex, then it would be fine."
    },
    {
        "link": "https://geeksforgeeks.org/python-string",
        "document": "A string is a sequence of characters. Python treats anything inside quotes as a string. This includes letters, numbers, and symbols. Python has no character data type so single character is a string of length 1.\n\nIn this example, s holds the value “GfG” and is defined as a string.\n\nStrings can be created using either single (‘) or double (“) quotes.\n\nIf we need a string to span multiple lines then we can use triple quotes (”’ or “””).\n\nStrings in Python are sequences of characters, so we can access individual characters using indexing. Strings are indexed starting from 0 and -1 from end. This allows us to retrieve specific characters from the string.\n\nNote: Accessing an index out of range will cause an IndexError. Only integers are allowed as indices and using a float or other types will result in a TypeError.\n\nPython allows negative address references to access characters from back of the String, e.g. -1 refers to the last character, -2 refers to the second last character, and so on.\n\nSlicing is a way to extract portion of a string by specifying the start and end indexes. The syntax for slicing is string[start:end], where start starting index and end is stopping index (excluded).\n\nStrings in Python are immutable. This means that they cannot be changed after they are created. If we need to manipulate strings then we can use methods like concatenation, slicing, or formatting to create new strings based on the original.\n\nIn Python, it is not possible to delete individual characters from a string since strings are immutable. However, we can delete an entire string variable using the del keyword.\n\nNote: After deleting the string using del and if we try to access s then it will result in a NameError because the variable no longer exists.\n\nTo update a part of a string we need to create a new string since strings are immutable.\n• For s1, s is sliced from index 1 to end of string and then concatenate “H” to create a new string s1\n• For s2, we can created a new string s2 and used\n\nPython provides a various built-in methods to manipulate strings. Below are some of the most useful methods.\n\nlen(): The len() function returns the total number of characters in a string.\n\nupper() and lower(): upper() method converts all characters to uppercase. lower() method converts all characters to lowercase.\n\nstrip() and replace(): strip() removes leading and trailing whitespace from the string and replace(old, new) replaces all occurrences of a specified substring with another.\n\nTo learn more about string methods, please refer to Python String Methods.\n\nWe can concatenate strings using + operator and repeat them using * operator.\n\nStrings can be combined by using + operator.\n\nWe can repeat a string multiple times using * operator.\n\nPython provides several ways to include variables inside strings.\n\nThe simplest and most preferred way to format strings is by using f-strings.\n\nAnother way to format strings is by using format() method.\n\nThe in keyword checks if a particular substring is present in a string.\n• None Split String into list of Characters in Python\n• None Iterate over characters of strings in Python\n• None Check if two strings are k-anagrams or not\n• None Check if string is rotated by two places\n• None Look and say Pattern"
    },
    {
        "link": "https://nathanrosidi.medium.com/python-string-methods-here-is-how-to-master-them-816fc34ac2db",
        "document": "Explore practical examples, learn how to effectively clean and format strings, and harness the power of Python’s memory model to master string operations.\n\nThe overall idea is that most people feel that Python’s string methods are too technical to understand correctly from the beginning.\n\nHowever, the reality is that all it takes is a bit of interest and some guidance to excel.\n\nI aim to share the steps and some essential facts that might turn anyone into a relatively professional string manipulator.\n\nFirst, I want to introduce you to the concatenation method, which stands for putting sequences of strings one after the other in a non-disconnectable manner. One classic example is the form of welcoming a user with a specific name:\n\nHere is the code.\n\nHere is the output.\n\nIn this case, the + operator is the welcomed, experienced tailor who sews the fragmented string into a pleasant greeting.\n\nAs you’ve discovered, the repetition can double or even spread a single chain. While working on the fabric of the code, you can place a single chain as follows;\n\nHere is the output.\n\nThe * operator can be likened to a chorus that has repeated the string ha three times to form a gleeful expression of laughter. By combining and repeating strings, developers can forcibly handle linguistic creations as they please.\n\nThen, at that delicate and sensitive level, devs can create even deep, intricate, and delicate overall linguistic unions.\n\nThe Art of Accessing Characters and Slicing\n\nAnother layer corresponding to the world of Python strings can be character access and slicing excavation, which are sharp tools for precisely extracting and operating substrings.\n\nAccessing Characters: The Key to Each Element\n\nPython string has its elements. They preserved a location described by an index, with each component having a decimal spot from 0 to the number of components in each.\n\nFurthermore, the following is easy to obtain. All one needs to do is open the bracket and provide the index. Here is the code.\n\nHere is the output.\n\nIn short, the slice defined the first character and snapped the last one, using just two signs to get to it.\n\nSlicing gets a part of a string marking distinguishing points. It is characterized by its [starting point: sorting] syntax. Here’s the code:\n\nHere is the output.\n\nI sliced “Hello, the world” from the above example. You can add a step using colons [start:end:step]. Thus, you can extract more complex and take more complex ones, such as reversing the order of the string or obtaining every second letter.\n\nPython strings are immutable. Therefore, any operation that changes a string results in the creation of a new string. By Python maintaining this behavior, it is highly linked with their memory model to maintain the efficiency and integrity of data:\n\nHere is the output.\n\nEven though it looks like it changed the original, the modified version is an entirely new string in memory. Strings’ immutability is a fundamental factor in most other string manipulation operations in Python and ensures that every string remains consistent and reliable.\n\nAfter learning these methods, you can better understand and work with your textual data and build on these basic principles to develop more advanced string manipulations.\n\nPython string methods open a toolkit for the user to follow a hammer with functionality to quickly and effortlessly perform virtually any action with string data or inquiry.\n\nThe function is built into and already exists in any string object, and you just need to call it and use it to work with strings.\n\nHowever, many methods can be used only by strings.\n\nNevertheless, this is not mockery but “glorification,” thanks to these methods, the user does not need to write much more code.\n\nThe len() function is not a string method but can be used to determine the string’s length. Here is the code.\n\nHere is the output.\n\nThis simple invocation provides the number of characters, including spaces and punctuation, and the primary understanding of the string size.\n\nOn the other hand, case transformations are done instantly with the help of several of them: upper() and lower(), and text normalization is allowed to be ready for comparison, searching, or presentation to the user.\n\nHere is the code:\n\nHere is the output.\n\nThese methods make text data comparable in processing and solve all problems with case-based operations.\n\nAnother vital area where whitespace needs to be managed is cleaning input or preparing data for further processing. Here is the code.\n\nHere is the output.\n\nHere, the strip() family of methods is unmatched in removing every piece of space not wanted. From eliminating the left and suitable spaces with strip() to simply stripping the leading or trailing spaces by using l strip() or rstrip(), respectively, they are vital for clean string data.\n\nQuick Wins: Brief Examples of Each Method\n\nAs you can see, python strings have numerous methods: find(), replace(), startswith(), endswith(), etc. Most of them are used for exceptional cases. Here is the code.\n\nHere is the output.\n\nThis short review shows how expansive the string methods’ toolkit is for a user who wants to work with text data efficiently and expressively.\n\nNow, you are armed and ready to perform numerous string-manipulating operations and begin exploring even more advanced ones.\n\nThe Search and Replace Commandos: Navigating Through Strings\n\nNavigating and manipulating strings accurately is vital in Python, especially if your data is primarily text. Python’s string methods for searching and replacing are like a well-trained search-and-rescue squad, able to quickly locate and alter textual content with tremendous accuracy.\n\nWhen it is necessary to determine the position of a substring in a string, the method find is useful. This method searches the substring from the start and returns the smallest index to this substring or -1 in case of search failure. If it is required to search from the end, you should use the method rfind():\n\nHere is the output.\n\nAll these methods are essential for parsing and processing text, which enables you to navigate strings accurately.\n\nThe Art of Substitution with replace()\n\nBesides, str.replace() is extremely valuable when changing parts of a string. This one finds a defined substring and puts a new one in place. Thus, it simply lets you renovate your text:\n\nHere is the code.\n\nHere is the output.\n\nThis example shows how replace() can transform content. It makes it a staple for text editing and data cleaning.\n\nNow that we have learned these methods, I want to model a practice I will use to perform. For instance, we have a dataset that has not been cleaned or updated for a long time. There will be different capitalization variations and even deprecated terms.\n\nA uniform model of these string data sources that can be analyzed will be feasible through the combination of find(), rfind(), and replace().\n\nHere is the output.\n\nThe above approach smooths out the data, preparing it for general analysis and demonstrating how Python’s string search and replacement equipment can be used properly.\n\nEntering more profoundly into the dispersion category, Python suggests three powerful pieces of equipment: split, join, and format.\n\nThey are perfect for dispersing, joining, and designing strings, so use them to advance the appearance.\n\nIt’s always tough to split something; it is an unwritten rule. However, when it is necessary to start splitting from the end, you will become best friends with it.\n\nFor those who want to split from the end, rsplit() is your ally:\n\nHere is the output.\n\nThe best use case is when you need to tokenize data, which implies splitting one large text into items containing one or several separate pieces of information.\n\nOn the other hand, join() constructs an iterable of strings, such as a list, into one single string with a specified separator threaded through it. It is the adhesive holding disparate strings together. Here is the code.\n\nHere is the output.\n\nThis method is especially beneficial when creating sentences, file paths, or any string that must be certain about how its components combine.\n\nAnother reasonable method is format() because it cautiously embeds variables into a string template. It is a much cleaner option while maintaining the string as a dynamic product of various merging factors. Here is the code.\n\nHere is the output.\n\nformat() allows madness in the form of strings and the sanity of “inserting things,” which makes it fundamental in Python string handling.\n\nAs string manipulation difficulties grow past basic operations, Python’s re-module becomes valuable. Python Regular expressions offer a compact and potent syntax to bridge the gap between what you can find, match, or substitute in a string, allowing you to conduct complicated text processing activities with minimal code.\n\nTapping into the re Module for Advanced Manipulations\n\nThe Python re-module provides tools to perform complex string manipulations using pattern matching. Below is how you may import and use the module for a basic search:\n\nHere is the output.\n\nIt is such a short example; however, it illustrates findall and how you can realize the potential of regular expressions to detect patterns.\n\nRegular expressions are used when you can describe the pattern you need in detail. They can validate emails, scroll logs for specific information, or clean up data. Here is the code.\n\nHere is the output.\n\nThese example cases show how regular expressions are versatile to perform complex string processing tasks pertinent to our day-to-day work. For these reasons, the tool confirms that it is an essential feature for a Python programmer.\n\nBringing It All Together: Examples\n\nNow let’s see one example, which includes Python string methods that we learned, from our platform.\n\nIn this question, the City of Francisco requires that we identify the number of words in each business’ name and exclude special symbols such as ‘&’ from what counts as a word at the end to display the business name and the number of words.\n\nFirst, let’s see a few rows and columns of the dataset.\n\nNow, let’s break down this question into multiple codable pieces;\n• Remove Duplicates: Ensures each business name is unique, preventing repeated word count calculations for the same entity.\n• Clean Business Names: Strips out special characters from business names, leaving only alphabets, numbers, and spaces for accurate word counting.\n• Count Words: Splits the cleaned business names into words based on spaces and counts the total number of words in each name, providing the desired information about word frequency.\n\nNow, let’s do this. Here is the code.\n\nHere are the first few rows of the output.\n\nIn this one, we went deep into Python’s string methods, exploring the intricacies of concatenation, slicing, memory models, and more to master the art of string manipulation.\n\nOne thing that deepens your understanding is doing repetition, like we did in the previous section.\n\nTo do that, try the StrataScratch platform, and check out Python interview questions, that include string methods, and master these methods, by solving questions from interviews of big companies."
    },
    {
        "link": "https://realpython.com/python-strings",
        "document": "Python strings are a sequence of characters used for handling textual data. You can create strings in Python using quotation marks or the function, which converts objects into strings. Strings in Python are immutable, meaning once you define a string, you can’t change it.\n\nBy the end of this tutorial, you’ll understand that:\n• The function converts objects to their string representation.\n• String interpolation in Python allows you to insert values into placeholders in strings using f-strings or the method.\n• You access string elements in Python using indexing with square brackets.\n• You can slice a string in Python by using the syntax to extract a substring.\n• You concatenate strings in Python using the operator or by using the method.\n\nYou’ll explore creating strings with string literals and functions, using operators and built-in functions with strings, indexing and slicing techniques, and methods for string interpolation and formatting. These skills will help you manipulate and format textual data in your Python programs effectively.\n\nTo get the most out of this tutorial, you should have a good understanding of core Python concepts, including variables, functions, and operators and expressions.\n\nThere are different ways to create strings in Python. The most common practice is to use string literals. Because strings are everywhere and have many use cases, you’ll find a few different types of string literals. There are standard literals, raw literals, and formatted literals. Additionally, you can use the built-in function to create new strings from other existing objects. In the following sections, you’ll learn about the multiple ways to create strings in Python and when to use each of them. A standard string literal is just a piece of text or a sequence of characters that you enclose in quotes. To create single-line strings, you can use single ( ) and double ( ) quotes: In the first example, you use single quotes to delimit the string literal. In the second example, you use double quotes. Note: Python’s standard REPL displays string objects using single quotes even though you create them using double quotes. You can define empty strings using quotes without placing characters between them: An empty string doesn’t contain any characters, so when you use the built-in function with an empty string as an argument, you get as a result. To create multiline strings, you can use triple-quoted strings. In this case, you can use either single or double quotes: The primary use case for triple-quoted strings is to create multiline strings. You can also use them to define single-line strings, but this is a less common practice. Probably the most common use case for triple-quoted strings is when you need to provide docstrings for your packages, modules, functions, classes, and methods. If you want to include a quote character within the string, then you can delimit that string with another type of quote. For example, if a string contains a single quote character, then you can delimit it with double quotes, and vice versa: \"This string contains a single quote (') character\" \"This string contains a single quote (') character\" 'This string contains a double quote (\") character' 'This string contains a double quote (\") character' In the first example, your string includes a single quote as part of the text. To delimit the literal, you use double quotes. In the second example, you do the opposite. Sometimes, you want Python to interpret a character or sequence of characters within a string differently. This may occur in one of two ways. You may want to: To achieve these goals, you can use a backslash ( ) character combined with other characters. The combination of a backslash and a specific character is called an escape sequence. That’s because the backslash causes the subsequent character to escape its usual meaning. For example, you can escape a single quote character using the escape sequence in a string delimited by single quotes: 'This string contains a single quote ( \"This string contains a single quote (') character\" In this example, the backslash escapes the single quote character by suppressing its usual meaning, which is delimiting string literals. Now, Python knows that your intention isn’t to terminate the string but to embed the single quote. The following table shows sequences that escape the default meaning of characters in string literals: You already have an idea of how the first two escape sequences work. Now, how does the newline escape sequence work? Usually, a newline character terminates a physical line of input. To add a newline character, you just press in the middle of a string. This will raise a exception: When you press after typing , you get a . If you need to break up a string over more than one line, then you can include a backslash before each newline or before pressing the key: When you add a backslash before you press , Python ignores the newline and interprets the whole construct as a single physical line. Sometimes, you need to include a literal backslash character in a string. If that backslash doesn’t precede a character with a special meaning, then you can insert it right away: In this example, the character after the backslash doesn’t match any known escape sequence, so Python inserts the actual backslash for you. Note how the resulting string automatically doubles the backslash. Even though this example works, the best practice is to always double the backslash when you need this character in a string. However, you may have the need to include a backslash right before a character that makes up an escape sequence: \"In this string, the backslash should be at the end File , line \"In this string, the backslash should be at the end : Because the sequence matches a known escape sequence, your string fails with a . To avoid this issue, you can double the backslash: \"In this string, the backslash should be at the end 'In this string, the backslash should be at the end \\\\' In this update, you double the backslash to escape the character and prevent Python from raising an error. Note: When you use the built-in function to print a string that includes an escaped backslash, then you won’t see the double backslash in the output: \"In this string, the backslash should be at the end In this string, the backslash should be at the end \\ In this example, the output only displays one backslash, producing the desired effect. Up to this point, you’ve learned how to suppress the meaning of a given character by escaping it. Suppose you need to create a string containing a tab character. Some text editors may allow you to insert a tab character directly into your code. However, this is considered a poor practice for several reasons:\n• Computers can distinguish between tabs and a sequence of spaces, but human beings can’t because these characters are visually indistinguishable.\n• Some text editors automatically eliminate tabs by expanding them to an appropriate number of spaces. In Python, you can specify a tab character with the escape sequence: The escape sequence changes the usual meaning of the letter , making Python interpret the combination as a tab character. Here’s a list of escape sequences that cause Python to apply special meaning to some characters instead of interpreting them literally: Character from Unicode database with given The newline or linefeed character ( ) is probably the most popular of these escape sequences. This sequence is commonly used to create nicely formatted text outputs that span multiple lines. Here are a few examples of the escape sequences in action: These escape sequences are useful when you need to insert characters that aren’t readily generated from the keyboard or aren’t easily readable or printable. With raw string literals, you can create strings that don’t translate escape sequences. Any backslash characters are left in the string. Note: To learn more about raw strings, check out the What Are Python Raw Strings? tutorial. To create a raw string, you have to prepend the string literal with the letter or : The raw string suppresses the meaning of the escape sequence, such as , and presents the characters as they are. Raw strings are commonly used to create regular expressions because they allow you to use several different characters that may have special meanings without restrictions. Note: To learn more about regular expressions in Python, check out the tutorials on regular expressions in Python Part 1 and Part 2. For example, say that you want to create a regular expression to match email addresses. To do this, you can use a raw string to create the regular expression like in the code below: Please contact us at support@example.com or sales@example.com for further information. The variable holds a raw string that makes up a regular expression to match email addresses. Note how the string contains several backslashes that are escaped and inserted into the resulting string as they are. Then, you compile the regular expression and check for matches in a sample piece of text. Formatted string literals, or f-strings for short, allow you to interpolate values into your strings and format them as you need. To create a string with an f-string literal, you must prepend the literal with an or letter. F-strings let you interpolate values into replacement fields in your string literal. You create these fields using curly brackets. Here’s a quick example of an f-string literal: In this example, you interpolate the variable into your string using an f-string literal and a replacement field. You’ll learn more about using f-strings for string interpolation and formatting in the Doing String Interpolation and Formatting section. You can create new strings using the built-in function. However, a more common use case for this function is to convert other data types into strings, which is also a way to create new strings. Consider the following examples: \"{'one': 1, 'two': 2, 'three': 3}\" In the first example, you call the function without an argument to create an empty string. Then, you use the function to convert objects from different built-in types into strings.\n\nYou can also use a few operators with string values as operands. For example, the and operators allow you to perform string concatenation and repetition, respectively. In the following sections, you’ll learn how these and other operators work with strings. The operator lets you concatenate strings. So, in this context, you can call it the concatenation operator. Concatenation involves joining two or more string objects to create a single new string: In this example, you use the plus operator to concatenate several string objects. You start with the variable and add a comma followed by a space. Next, you add the name variable and finally, some exclamation points. Note that you’ve combined variables holding strings and string literals to build the final string. Note: Often you’d use f-strings instead of to concatenate strings. The concatenation operator also has an augmented variation denoted by . This operator allows you to do something like but in a shorter way: In this example, you create a filename incrementally. You start with the filename without the file extension. Then, you use the augmented concatenation operator to add the file extension to the existing filename. Note that the augmented operator doesn’t change the initial string because strings are immutable. Instead, it creates a new string and reassigns it to the name . The operator allows you to repeat a given string a certain number of times. In this context, this operator is known as the repetition operator. Its syntax is shown below: The repetition operator takes two operands. One operand is the string that you want to repeat, while the other operand is an integer number representing the number of times you want to repeat the target string: In the first example, you repeat the character ten times. In the second example, you repeat the text ten times as well. Note that the order of the operands doesn’t affect the result. The multiplier operand, , is usually a positive integer. If it’s a zero or negative integer, the result is an empty string: You need to be aware of this behavior in situations where you compute dynamically, and or negative values can occur. Otherwise, this operator comes in handy when you need to present some output to your users in a table format. For example, say that you have the following data about your company’s employees: You want to create a function that takes this data, puts it into a table, and prints it to the screen. In this situation, you can write a function like the following: This function takes the employees’ data as an argument and the headers for the table. Then, it gets the maximum header length, prints the headers using the pipe character ( ) as a separator, and justifies the headers to the left. To separate the headers from the table’s content, you build a line of hyphens. To create the line, you use the repetition operator with the maximum header length as the multiplier operand. The effect of using the operator here is that you’ll get a visual line under each header that’s always as long as the longest header field. Finally, you print the employees’ data. Here’s how the function works in practice: Again, creating tables like this one is a great use case for the repetition operator because it allows you to create separators dynamically. The repetition operator also has an augmented variation that lets you do something like in a shorter way: In this example, the operator repeats the string in ten times and assigns the result back to the variable. Finding Substrings in a String: The and Operators Python also provides the and operators that you can use with strings. The operator returns if the left-hand operand is contained within the right-hand one and False otherwise. This type of check is known as a membership test. You can take advantage of a membership test when you need to determine if a substring appears in a given string: In these examples, you check whether the string is a substring of the strings on the right-hand side. Note: To learn more about how to find substrings in existing strings, check out the How to Check if a Python String Contains a Substring tutorial. The operator does the opposite check: With the operator, you can check if a substring isn’t found in a given string. If the substring isn’t in the target string, then you get . Otherwise, you get .\n\nPython provides many functions that are built into the language and, therefore, are always available to you. Here are a few of these functions that are especially useful when you’re processing strings: In the following sections, you’ll learn how to use these functions to work with your strings. To kick things off, you’ll start by determining the length of an existing string with . A common operation that you’ll perform on strings is determining their number of characters. To complete this task, you can use the built-in function. Note: To learn more about the function, check out the Using the Function in Python tutorial. With a string as an argument, the function returns the length of the input string or the number of characters in that string. Here are a couple of examples of how to use : The word has six letters, so calling with this word as an argument returns . Note that returns when you call it with empty strings. The function calculates the number of characters in a string object, independent of how you constructed the string: You use the escape sequence to define a string with a single snake emoji. Even though you wrote nine characters in the string literal, the string object consist of a single 🐍 character. And reports its length as one. You get the same result when you create the string with a literal emoji character. To convert objects into their string representation, you can use the built-in and functions. With the function, you can convert a given object into its user-friendly representation. This type of string representation is targeted at end users. For example, if you pass an object of a built-in type to , then you get a representation that typically consists of a string containing the literal that defines the object at hand: \"{'one': 1, 'two': 2, 'three': 3}\" In these examples, the outputs show user-friendly representations of the input objects. These representations coincide with the objects’ literals. You can provide a user-friendly string representation for your custom classes through the special method, as you’ll learn in a moment. Similarly, the built-in function gives you a developer-friendly representation of the object at hand: \"{'one': 1, 'two': 2, 'three': 3}\" Ideally, you should be able to copy the output of to re-create the original object. Also, this representation lets you know how the object is built. It’s because of these two distinctions that you can say returns a developer-friendly string representation of the object at hand. As you can see in the example above, the output of and is the same for built-in data types. Both functions return the object’s literal as a string. Note: Behind the function, you have the special method. Similarly, behind , you have the method. To learn more about these special methods, check out the When Should You Use vs in Python? tutorial. To see the difference between and , consider the class in the following example: The method gives you a developer-friendly string representation of specific objects. You’ll be able to re-create the object using the output of the function. In contrast, the string representation that you get from calling should aim to be readable and informative for end users. You can access this representation with the function. Here’s how the two functions work with an instance of your class: In this example, you can use the output of to re-create the object stored in . You also have all the information about how this specific object was built. Meanwhile, the output of gives you no clue about how to build the object. However, it does provide useful information for the end user. You can use the built-in function to format strings. This function converts an input value into a formatted representation. To define the desired format, you can use a format specifier, which should be a string that follows the syntax defined in the string formatting mini-language. Note: To learn more about format specifiers, check out the Python’s Format Mini-Language for Tidy Strings tutorial. Consider the following examples of using the function with different input values and format specifiers: In these examples, the specifier formats the input value as a floating-point number with four decimal places. With the format specifier, you can format a number using commas as thousand separators and with two decimal places, which could be appropriate for formatting currency values. Next, you use the specifier to format the string centered in a width of characters using the equal sign as a filler character. Finally, you use to format the date. The function returns an integer value representing the Unicode code point for the given character. At the most basic level, computers store all information as numbers. To represent character data, computers use a translation scheme that maps each character to its associated number, which is its code point. The most commonly used scheme is ASCII, which covers the familiar Latin characters you’re probably most accustomed to working with. For these characters, returns the ASCII value that corresponds to the character at hand: While the ASCII character set is fine for representing English, many natural languages are used worldwide, and countless symbols and glyphs appear in digital media. The complete set of characters that you may need to represent in code surpasses the Latin letters, numbers, and symbols. Unicode is a generally accepted standard that attempts to provide a numeric code for every possible character in every possible natural language on every platform or operating system. The Unicode character set is the standard in Python. Note: For more information about Unicode in Python, check out the Unicode & Character Encodings in Python: A Painless Guide tutorial and Python’s Unicode Support in the Python documentation. The function will return numeric values for Unicode characters as well: In the Unicode table, the character has as its associated code point, and the character has the code point. The function does the reverse of . It returns the character value associated with a given code point: Given the numeric value , returns the character that corresponds to . Note that handles Unicode characters as well.\n\nPython’s strings are ordered sequences of characters. Because of this, you can access individual characters from a string using the characters’ associated index. What’s a character’s index? Each character in a string has an index that specifies its position. Indices are integer numbers that start at and go up to the number of characters in the string minus one. You can use these indices to perform two common operations:\n• Indexing: Consists of retrieving a given character using its associated index.\n• Slicing: Allows you to get a portion of an existing string using indices. In the following sections, you’ll learn how to run these two operations on your Python strings. You can access individual characters in a string by specifying the string object followed by the character’s index in square brackets ( ). This operation is known as indexing. String indexing in Python is zero-based, which means that the first character in the string has an index of , the next has an index of , and so on. The index of the last character will be the length of the string minus one. For example, a schematic diagram of the indices of the string would look like this: You can access individual characters by their index: Using the indexing operator , you can access individual characters in an existing string. Note that attempting to index beyond the end of the string results in an error: When you use an index that’s beyond the number of characters in the string minus one, you get an exception. You can also use negative numbers as indices. If you do that, then the indexing occurs from the end of the string backward. Index refers to the last character, index refers to the second-last character, and so on. Here’s the diagram showing both positive and negative indices in the string : Here are some examples of negative indexing: With negative indices, you can access the characters from the end of the string to its beginning. Again, attempting to index with negative numbers beyond the beginning of the string results in an error: Because the string only has six characters, the last negative index that you can use is , which corresponds to the first character in the string. In short, for any non-empty string, and both return the last character. Similarly, and return the first character. Note that no index makes sense on an empty string. Finally, you should keep in mind that because strings are immutable, you can’t perform index assignments on them. The following example illustrates this fact: If you try to change a character in an existing string, then you’ll get a telling you that strings don’t support item assignment. Python allows you to extract substrings from a string. This operation is known as slicing. If is a string, then an expression of the form returns the portion of starting at index , and up to but not including index : The first index sets the starting point of the indexing operation. The second index specifies the first character that isn’t included in the result—the character with index in the example above. Note: String indices are zero-based. This means that the first character in a string has an index of . This applies to both standard indexing and slicing. If you omit the first index, then the slicing starts at the beginning of the string: Therefore, slicings like and are equivalent. Similarly, if you omit the second index as in , then the slicing extends from the first index to the end of the string. This is an excellent and concise alternative to the more cumbersome syntax: When you omit the last index, the slicing operation extends up to the end of the string. For any string and any integer , provided that , you’ll have is equal to : The first slicing extracts the characters from the beginning and up to index , which isn’t included. The second slicing extracts the characters from to the end of the string. So, the result will contain the same characters as the original string. Omitting both indices returns the original string in its entirety. It doesn’t return a copy but a reference to the original string: When you omit both indices, you tell Python that you want to extract a slice containing the whole string. Again, for efficiency reasons, Python returns a reference instead of a copy of the original string. You can confirm this behavior using the built-in function. If the first index in a slicing is greater than or equal to the second index, then Python returns an empty string: As you can see, this behavior provides a somewhat obfuscated way to generate empty strings. You can also use negative indices in slicing. Just as with indexing, refers to the last character, to the second-last character, and so on. The diagram below shows how to slice the substring from the string using both positive and negative indices: Slicing with negative indices really shines when you need to get slices that have the last character of the string as a reference point. There’s one more variant of the slicing syntax to discuss. An additional colon ( ) and a third index designate a stride, also known as a step. This index indicates how many characters to jump after retrieving each character in the slice. For example, for the string , the slice starts with the first character and ends with the last character, skipping every second character. This behavior is shown in the following diagram, where the green items are the ones included in the slice: Similarly, specifies a slice that starts with the second character, which is index , and ends with the last character. Again, the stride value skips every other character: The illustrative REPL code is shown below: As with any slicing, the first and second indices can be omitted and default to the first and last characters, respectively: In the first slicing, you omit the first and second indices, making the slice start at index and go up to the end of the string. In the second slicing, you only omit the second index, and the slice goes up to the end of the string. You can also specify a negative stride value, in which case Python steps backward through the string. Note that the initial index should be greater than the ending index: In the above example, means this: start at the last character and step backward by , up to but not including the first character. When you step backward, if the first and second indices are omitted, the defaults are reversed intuitively. In other words, the initial index defaults to the end of the string, and the ending index defaults to the beginning. Using a step equal to provides a common technique for reversing strings: \"Beautiful is better than ugly.\" To dive deeper into how to reverse strings, check out the Reverse Strings in Python: , Slicing, and More tutorial.\n\nString interpolation refers to building new strings by inserting values into a string that works as a template with replacement fields for each value you insert. String formatting, on the other hand, involves applying a desired format to the values you insert in a given string through interpolation. Note: To dive deeper into string interpolation, check out the String Interpolation in Python: Exploring Available Tools tutorial. Similarly, if you want to learn more about string formatting, check out the Python String Formatting: Available Tools and Their Features tutorial. In the following sections, you’ll learn the basics of string interpolation and formatting in Python. You can also use f-strings to interpolate values into a string and format them, as you quickly touched on in the section about f-string literals. To do this, you use format specifiers that use the syntax defined in Python’s string format mini-language. For example, here’s how you can present numeric values using a currency format: Inside the replacement field delimited by the curly brackets, you have the variable you want to interpolate and the format specifier, which is the string that starts with a colon ( ). In this example, the format specifier defines a floating-point number with two decimal places. Note: To learn more about using f-strings for string interpolation and formatting, check out the Python’s F-String for String Interpolation and Formatting tutorial. F-strings have a clean syntax and are quite popular in Python code. However, they’re only suitable for those situations where you want to do the interpolation eagerly because the interpolated values are inserted when Python executes the strings. You can’t use f-strings for lazy interpolation. In other words, you can’t use f-string for those situations where you need a reusable template that you’ll fill with values dynamically in different parts of your code. In this situation, you can use the method. Python’s class has a method called that allows for string interpolation and formatting. This method is pretty powerful. Like f-strings, it supports the string formatting mini-language, but unlike f-strings, it allows for both eager and lazy string interpolation. Consider the following example that uses to create a balance report: In this example, you first define two variables to hold the debit and credit of a bank account. Then, you create a template to construct a report showing the account’s credit, debit, and balance. Finally, you call with the required argument to create the report. Python has another tool you can use for string interpolation and formatting called the modulo operator ( ). This operator was the first tool Python provided for string interpolation and formatting. It also allows you to do both eager and lazy interpolation. Note: To learn more about the modulo operator for string formatting and interpolation, check out the Modulo String Formatting in Python tutorial. While you can use the modulo operator for string formatting, its formatting capabilities are limited and it doesn’t support the string formatting mini-language. Here’s how you would use the modulo operator to code the example from the previous section: In this version of the report template, you use named placeholders with the modulo operator syntax. To provide the values to interpolate, you use a dictionary. The operator unpacks it using the keys that match the replacement fields.\n\nMethods are functions that you define inside classes. Like a function, you call a method to perform a specific task. Unlike a function, you invoke a method on a specific object or class so it has knowledge of its containing object during execution. The syntax for invoking a method on an object is shown below: This invokes method on object . Inside the parentheses, you can specify the arguments for the method to work, but these arguments are optional. Note that you can have both instance and class methods. Note: In the above syntax, the arguments specified in square brackets ( ) are optional and the brackets aren’t part of the syntax. You’ll use this same convention throughout the following sections. Python’s class provides a rich set of methods that you can use to format your strings in several different ways. In the next section, you’ll learn the basics of some of the more commonly used methods. The methods you’ll look at in this section allow you to perform case conversion on the target string. Note that the methods in this section only affect letters. Non-letter characters remain the same because they don’t have uppercase and lowercase variations. Note: Keep in mind that because strings are immutable, when string methods apply changes to an existing string they return a new string object. To kick things off, you’ll start by capitalizing some strings using the method. The method returns a copy of the target string with its first character converted to uppercase, and all other characters converted to lowercase: In this example, only the first letter in the target string is converted to uppercase. The rest of the letters are converted to lowercase. The method returns a copy of the target string with all alphabetic characters converted to lowercase: You can see in this example how all the uppercase letters were converted to lowercase. The method returns a copy of the target string with uppercase alphabetic characters converted to lowercase and vice versa: In this example, the call to turned the lowercase letters into uppercase and the uppercase letters into lowercase. The method returns a copy of the target string in which the first letter of each word is converted to uppercase, and the remaining letters are lowercase: Note that this method doesn’t attempt to distinguish between important and unimportant words, and it doesn’t handle apostrophes, possessives, or acronyms gracefully: The method converts the first letter of each word in the target string to uppercase. As you can see, it doesn’t do a great job with apostrophes and acronyms! The method returns a copy of the target string with all alphabetic characters converted to uppercase: By calling on a string, you get a new string with all the letters in uppercase. The methods in this section provide various ways to search the target string for a specified substring. Each method supports optional and arguments. These arguments mean that the action of the method is restricted to the portion of the target string starting with the character at index and up to but not including the character at index . If is specified but isn’t, then the method applies to the portion of the target string from through the end of the string. The method returns the number of non-overlapping occurrences of the substring in the target string: The count is restricted to the number of occurrences within the substring indicated by and if you specify them: In this example, the search starts at index and ends at index . Because of this, the last occurrence of isn’t counted. You can use to check whether a string contains a particular substring. Calling returns the lowest index in the target string where is found: Note that returns if the specified substring isn’t found in the target string: Again, the search is restricted to the substring indicated by and if you specify them: With the and indices, you restrict the search to a portion of the target string. The method is similar to , except that it raises an exception rather than returning if isn’t found in the target string: If the substring exists in the target string, then returns the index at which the first instance of the substring starts. If the substring isn’t found in the target string, then you get a exception. The call returns the highest index in the target string where the substring is found: As with , if the substring isn’t found, then returns : You can restrict the search to the substring indicated by and : Again, with the and indices, you restrict the search to a portion of the target string. The method is similar to , except that it raises an exception if isn’t found in the target string: If the substring isn’t found in the target string, then raises a exception. The call returns if the target string starts with the specified and otherwise: The comparison is restricted to the substring indicated by and if they’re specified: In these examples, you use the and indices to restrict the search to a given portion of the target string. The call returns if the target string ends with the specified and otherwise: The comparison is restricted to the substring indicated by and if you specify them. The methods in this section classify a string based on its characters. In all cases, the methods are predicates, meaning they return or depending on the condition they check. The method returns if the target string isn’t empty and all its characters are alphanumeric, meaning either a letter or number. Otherwise, it returns : In the first example, you get because the target string contains only letters and numbers. In the second example, you get because of the character. The method returns if the target string isn’t empty and all its characters are alphabetic. Otherwise, it returns : The method allows you to check whether all the characters in a given string are letters. Note that whitespaces aren’t considered alpha characters, which makes sense but might be missed if you’re working with normal text. You can use the method to check whether your string is made of only digits: The method returns if the target string is not empty and all its characters are numeric digits. Otherwise, it returns . The method returns if the target string is a valid Python identifier according to the language definition. Otherwise, it returns : It’s important to note that will return for a string that matches a Python keyword even though that wouldn’t be a valid identifier: You can test whether a string matches a Python keyword using a function called , which is contained in a module called . One possible way to do this is shown below: If you want to ensure that a string serves as a valid Python identifier, you should check that returns and that returns . The method returns if the target string isn’t empty and all its alphabetic characters are lowercase. Otherwise, it returns : Note that non-alphabetic characters are ignored when you call the method on a given string. The method returns if the target string is empty or if all its alphabetic characters are printable: You get if the target string contains at least one non-printable character. Again, non-alphabetic characters are ignored. Note that is one of two methods that return if the target string is empty. The second one is . The method returns if the target string isn’t empty and all its characters are whitespaces. Otherwise, it returns . The most commonly used whitespace characters are space ( ), tab ( ), and newline ( ): There are a few other ASCII characters that qualify as whitespace characters, and if you account for Unicode characters, there are quite a few beyond that: The and combinations are the escape sequences for the ASCII form feed and carriage return characters. The combination is the escape sequence for the Unicode four-per-em space. The method returns if the target string isn’t empty, the first alphabetic character of each word is uppercase, and all other alphabetic characters in each word are lowercase. It returns otherwise: This method returns if the string is title-cased as would result from calling . It returns otherwise. The method returns if the target string isn’t empty and all its alphabetic characters are uppercase. Otherwise, it returns : Again, Python ignores non-alphabetic characters when you call the method on a given string object. The methods in this section allow you to modify or enhance the format of a string in many different ways. You’ll start by learning how to center your string within a given space. The call returns a string consisting of the target string centered in a field of characters. By default, padding consists of the ASCII space character: If you specify the optional argument, then it’s used as the padding character: Note that if the target string is as long as or longer, then it’s returned unchanged. The method replaces each tab character ( ) found in the target string with spaces. By default, spaces are filled in assuming eight characters per tab: In the final example, you use the argument, which is an optional argument that specifies an alternate tab size. The call returns a string consisting of the target string left-justified in a field of characters. By default, the padding consists of the ASCII space character: If you specify the optional argument, then it’s used as the padding character: If the target string is as long as or longer, then it’s returned unchanged. The call returns a string consisting of the target string right-justified in a field of characters. By default, the padding consists of the ASCII space character: If you specify the optional argument, then it’s used as the padding character: If the target string is as long as or longer, then it’s returned unchanged: When the target string is as long as or longer, then won’t have space to justify the text, so you get the original string back. The method returns a copy of the target string with removed from the beginning: The prefix is removed if the target string begins with that exact substring. If the original string doesn’t begin with , then the string is returned unchanged. The method returns a copy of the target string with removed from the end: The suffix is removed if the target string ends with that exact substring. If the original string doesn’t end with , then the string is returned unchanged. The and methods were introduced in Python 3.9. The method returns a copy of the target string with any whitespace characters removed from the left end: If you specify the optional argument, then it’s a string that specifies the set of characters to be removed: In this example, you remove the prefix from the input URL using the method with the characters as an argument. Note that this call to works only because the URL doesn’t start with any of the target characters: In this example, the result isn’t correct because the URL starts with a , which is included in the set of letters that you want to remove. You should use instead. The method with no arguments returns a copy of the target string with any whitespace characters removed from the right end: If you specify the optional argument, then it should be a string that specifies the set of characters to be removed: By providing a string value to , you can control the set of characters to remove from the right side of the target string. The method is equivalent to invoking and in succession. Without the argument, it removes leading and trailing whitespace in one go: As with and , the optional argument specifies the set of characters to be removed: Again, with , you can control the characters you want to remove from the original string, which defaults to whitespaces. To replace a substring of a string, you can use the method. This method returns a copy of the target string with all the occurrences of the substring replaced by : If you specify the optional argument, then a maximum of replacements are performed, starting at the left end of the target string: The argument lets you specify how many replacements you want to perform in the original string. The call returns a copy of the target string left-padded with zeroes to the specified : If the target string contains a leading sign, then it remains at the left edge of the result string after zeros are inserted: If the target string is as long as or longer, then it’s returned unchanged: Python will still zero-pad a string that isn’t a numeric value: The method is useful for representing numeric values. However, it also works with textual strings. The methods you’ll explore in this section allow you to convert between a string and some composite data types by joining objects together to make a string or by breaking a string up into pieces. These methods operate on or return iterables, which are collections of objects. For example, many of these methods return a or a . The method takes an iterable of string objects and returns the string that results from concatenating the objects in the input iterable separated by the target string. Note: To learn more about string concatenation, check out the Splitting, Concatenating, and Joining Strings tutorial. Note that is invoked on a string that works as the separator between each item in the input iterable, which must contain string objects. In the following example, the separator is a string consisting of a comma and a space. The input iterable is a list of string values: The result of this call to is a single string consisting of string objects separated by commas. Again, the input iterable must contain string objects. Otherwise, you’ll get an error: This example fails because the second object in the input iterable isn’t a string object but an integer number. When you have iterables of values that aren’t strings, then you can use the function to convert them before passing them to . Consider the following example: In this example, you use the function to convert the values in to strings before feeding them to . To do the conversion, you use a generator expression. The call splits the target string at the first occurrence of string . The return value is a tuple with three objects:\n• The portion of the target string that precedes\n• The portion of the target string that follows Here are a couple of examples of in action: Note that if the string ends with the target , then the last item in the tuple is an empty string. Similarly, if isn’t found in the target string, then the returned tuple contains the string followed by two empty strings, as you see in the final example. The call works like , except that the target string is split at the last occurrence of instead of the first: In this case, the string partition is done starting from the right side of the target string. Without arguments, splits the target string into substrings delimited by any sequence of whitespace and returns the substrings as a list: If you specify the argument, then it’s used as the delimiter for the splitting: When is explicitly given as a delimiter, consecutive instances of the delimiter in the target string are assumed to delimit empty strings: However, consecutive whitespace characters are combined into a single delimiter, and the resulting list will never contain empty strings: If the optional parameter is specified, then a maximum of that many splits are performed, starting from the left end of the target string: In this example, performs only one split, starting from the left end of the target string. The method behaves like , except that if is specified, then the splits are counted from the right end of the target string rather than from the left end: If isn’t specified, then the results of and are indistinguishable. The method splits the target string into lines and returns them in a list. The following escape sequences can work as line boundaries: Here’s an example of using several different line separators: If consecutive line boundary characters are present in the target string, then they’re assumed to delimit blank lines, which will appear in the result list as empty strings: Note that if you set the optional argument to , then the line boundaries are retained in the result strings."
    }
]