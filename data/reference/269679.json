[
    {
        "link": "https://api.libreoffice.org",
        "document": "LibreOffice 24.2 software is a complete, feature-rich office productivity suite that provides, in combination with this SDK, all the essential tools for building and deploying custom solutions that build on, or integrate with, the LibreOffice 24.2 suite of products. The SDK is a development kit for LibreOffice 24.2, which eases the development of office components. It provides a set of libraries, binaries, header, and IDL files which have final API's and can only be extended with new functionality. This set of libraries and binaries is the minimum set of functions needed to use system abstraction for base functionality and for using UNO (Universal Network Objects) component technology. The UNO component model is the base of the whole Office API. The SDK provides everything necessary to use the Office API from external programs (e.g. Java, C++) or to extend the Office functionality with new components (e.g. new filter components, CalcAddin functions). It is compatible over several versions because the API remains unaffected and will only be extended with new functions. The SDK provides the basic building blocks for external developers to develop components in any language for which a binding exists. Currently, there are language bindings for LibreOffice 24.2 Basic, Java, Python, and different C++ compilers on different platforms, for LibreOffice 24.2, thus covering the most commonly used programming languages. There will be no limit for office automation in heterogeneous environments. Currently supported platforms of the SDK are Linux, Solaris (sparc, x86), and Windows. The SDK also contains reference documentation for the API and a complete Developer's Guide is available online in TDF Wiki, with lots of examples, which introduce the API, explain the concepts behind it, and make it possible for all users to quickly get started with the Office API. An overview of all necessary installation steps (e.g. environment variables) to use this SDK. Detailed documentation, explaining the LibreOffice 24.2 API and the concepts behind it, with a rich set of examples, implemented mainly in Java. This documentation is online in TDF Wiki. Reference documentation of the C++ UNO runtime and a set of C/C++ base and helper functions and classes to abstract from the system layer. Overview and a short description of the UNO development tools. A collection of examples in different programming languages (Java, Python, C++, Basic, OLE, CLI). A git repository with additional examples from various contributors: Link to the OASIS Open Document Format for Office Applications (OpenDocument) Technical Committee where you can find the latest information about the OASIS Open Document XML file format which is the default document format for LibreOffice 24.2. The license for the LibreOffice 24.2 SDK."
    },
    {
        "link": "https://documentation.libreoffice.org/assets/Uploads/Documentation/en/GS7.5/GS75-GettingStarted.pdf",
        "document": ""
    },
    {
        "link": "https://javadoc.io/doc/org.libreoffice/libreoffice/7.5.4/index.html",
        "document": ""
    },
    {
        "link": "https://wiki.documentfoundation.org/ReleaseNotes/7.5",
        "document": "\n• Now tabs can be edited for multiple paragraphs with different settings at a time. Tabs dialogue ( ▸ ▸ ) is available even when multiple paragraphs are selected which has different settings. 9f7b3 (Pranam Lashkari)\n• Correctly calculate text caret position inside ligatures, and use caret positions from the font when available. tdf#30731 (Khaled Hosny)\n• It is now possible to define a custom color for Grammar mistakes in the Application Colors dialog ( ▸ ▸ ▸ ). 0aa61 (Rafael Lima)\n• AutoTexts created using \"New (text only)\" no longer insert a new line at the end of the AutoText. The currently embedded AutoTexts have been adjusted accordingly by explicitly adding a new line at the end of the text. User-created AutoTexts, relying on the trailing new line, should be re-created including the trailing empty paragraph. tdf#53023 (Andreas Heinisch)\n• Page number in status bar now uses a range when the view spans several pages. tdf#90150 (Jim Raykowski)\n• Elements can be highlighted on page by hovering over their name in the Navigator sidebar deck. tdf#152029 (Jim Raykowski)\n• Better recognition of typos, and better suggestions in Danish, Dutch, Estonian, German, Hungarian, Norwegian and Swedish with the improved compound word recognition algorithm of Hunspell spell checker. Hunspell 1.7.2 commit (László Németh, FSF.hu)\n• Moving text cursor Up/Down triggers pending spell checking of the last modified word. tdf#124603 (László Németh, NISZ)\n• Spell checking of plain words of hyperlinks tdf#45949 (László Németh, based on tdf#126657 (Khaled Hosny) and tdf#152492)\n• Keep comment of the corrected words, instead of removing it without being noticed tdf#65535 (László Németh) Note: continuation of the following improvements, which were left out of the previous release notes: d08e4137 tdf#66043 sw: fix spell checking of word with deletion (László Németh, introduced in version 7.2) and a6555eb8 tdf#65535 sw spell: ignore comment marker when checking spelling (Justin Luth, introduced in version 7.3).\n• Better column deletion when it intersects with merged cells. tdf#46733 (Justin Luth)\n• Allow table row/column selection, if last cell starts with a nested table. tdf#47979, tdf#151478 (László Németh, NISZ)\n• Allow tracked table row/column deletion, if last cell starts with a nested table. tdf#150976, tdf#151657 (László Németh, NISZ)\n• Bookmark text content can be edited in the dialog. aa6ec (Michael Stahl, allotropia)\n• The Bookmark dialog accessed from ▸ ▸ ▸ now opens with the clicked bookmark already selected. 9cc6a (Michael Stahl, allotropia)\n• Hidden _Toc and _Ref bookmarks imported from OOXML are shown as Hidden in the dialog, allowing sorting the not hidden (user-defined) bookmarks before them by a single click on header Hidden. tdf#150955 (László Németh, NISZ)\n\nSee also Custom color metadata field shading, introduced in LibreOffice 7.2.\n\nIn the form of\n\nWhere Bookmark, Start and End are localized words.\n\nVarious improvements of bookmark visibility (see Tools ▸ Options ▸ LibreOffice Writer ▸ Formatting Aids ▸ Bookmarks. (László Németh, NISZ)\n\nNote: this is a continuation to Michael Stahl’s fix for tdf#45589 (\"create and paint text portions for bookmarks\"), introduced in LibreOffice 7.0.\n• ⌶-shape point bookmark (The previous shape, a single vertical line was overlapped with visible page margin at beginning of the paragraphs, also it was very similar to the NBSP and narrow NBSP shading.) tdf#150791\n• ][-shape (i.e. double) marks for neighboring bookmark ranges (instead of a single vertical line, which could not be distinguished from point bookmark symbol previously). tdf#150790\n• All bookmarks at the same character position are visible now, e.g. instead of a single |, neighboring bookmarks with point bookmarks are shown e.g. as ] ⌶ [ or ] ] ⌶ ⌶ [ [\n• Do not show visible marks for hidden _Toc and _Ref bookmarks imported from OOXML, like Microsoft Office does. tdf#150956\n• Multiple start marks of range bookmarks positioned before the character position, multiple end marks of range bookmarks positioned after the character position, i.e. single type boundary marks are there outside of the bookmark text:\n• Neighboring end and start marks are centered around the character position:\n• Marks of the same character position are sorted based on their type: ], ⌶, [, e.g.\n• Same type marks of the same character position are sorted based on their color:\n• Images, embedded objects and text frames can now be marked as decorative, which allows assistive technology to ignore them in exported PDFs. (Michael Stahl, allotropia) tdf#143311 31084\n• Hyperlinks, table of content and other indices keep their language, and with this, their accessibility. tdf#39794 tdf#145104 (fixed in tdf#126657 by Khaled Hosny, follow-up fixes: tdf#152492 and tdf#45949 by László Németh)\n• Automatic (Online) Accessibility Check has been added, which scans for accessibility issues while the user is editing the document. The accessibility status is shown in the status bar. You can enable it in the main menu ( ▸ ). Currently it is only available when experimental mode is enabled, as it doesn't take all document objects into account. (Tomaž Vajngerl, Collabora)\n• Initial machine translation is available, backend by DeepL translate (Mert Tumer, Collabora) e20d2, tdf#34058\n• Cutting hundreds of pages with numbered lists in Writer tdf#129101 (Noel Grandin, Collabora)\n• Cell input with leading ' apostrophe in cells that are not formatted as Text was changed to always strip the first apostrophe and force the remainder as text content. Previously, the user had to know (or guess) whether an input could be converted to a numeric type (number, date, ...) and prefix only that to force text, but not prefix a textual type that could not be converted, which was confusing and bad UX. The handling is not changed for cells already formatted as Text, where every input is continued to be accepted literally as content and a leading apostrophe is not removed. tdf#149665 (Eike Rathke, Red Hat)\n• Conditional formatting's begins-with/ends-with/contains are now case-insensitive like the rest of the conditions were. tdf#123990 (Justin Luth, Collabora)\n• ▸ ▸ now always works even when first row or column are not visible. tdf#112641 (Justin Luth, Collabora)\n• Paste Special of cells now remembers last used settings between sessions. tdf#69750 (Siddhant Chaudhary)\n• Searching for a term in the Function Wizard now matches the function descriptions as well as their names. tdf#146781 (Andreas Heinisch)\n\nNumber format dialog windows of Calc and Writer got default NatNum12 (\"spell out\") format codes. tdf#115007 (László Németh, FSF.hu)\n• NatNum12 title case is fixed for English language: lowercase “and” and title case “-Five” e.g. in “One U.S. Dollar and Twenty-Five Cents”.\n• Find and replace in very large Calc sheets tdf#150749 (Noel Grandin, Collabora)\n• The presenter console supports running as a normal window instead of fullscreen, with a setting in ▸ ▸ ▸ ▸ (tdf#33495). This means it can be used in a single monitor too, sharing the presentation in a video-conferencing tool. (tdf#92717) (Daniel Lohmann)\n• The in-presentation pen function can be turned off with + (on top of the existing toggle + ), which should make more presenter devices compatible. tdf#149351 (Gabor Kelemen, allotropia)\n• Objects can be drag-and-dropped in the navigator, allowing reordering and moving them in and out of groups. tdf#145359 (Jim Raykowski)\n• The Navigator is now functional in Notes View too. tdf#155393 (Jim Raykowski)\n• Added basic support for modifying table styles, and creating new ones. Modified styles are saved into documents, and can be shared via templates. This function can be accessed by right-clicking on a design in the Table Design Sidebar panel. f23d3, 553cf, 5d683 (Maxim Monastirsky)\n• Data tables are now supported in Charts. See blog post for furter details (Tomaž Vajngerl, Collabora)\n• Elements pane from left side of Math's window was moved to Sidebar. tdf#150489 (Mike Kaganski, Collabora)\n• Added support for rotate and zoom gestures when using touchpads. (Povilas Kanapickas)\n• Allow searching for combining marks from so-called complex scripts. tdf#91764 (Khaled Hosny)\n• Fix disabled spellchecking and language-sensitive text layout (e.g. digit replacement) in table of contents and hyper link text. tdf#126657, tdf#145104 (Khaled Hosny)\n• A proper distinction between application and file-type icons was added to the Colibre and Sukapura icon themes. tdf#152595 tdf#153848 (Rizal Muttaqin)\n• Restored automatic detection of HighContrast (HC) mode while providing user ability to disable in ▸ ▸ ▸ . tdf#151522 (Caolán McNamara, Red Hat)\n• Improve kashida insertion by making the insertion positions explicit to avoid unwanted and spurious kashida insertion. tdf#104921, tdf#87731, tdf#106309, tdf#108604, tdf#112849, tdf#114257, tdf#127176, tdf#145647, tdf#146199 (Khaled Hosny)\n• Fix kashida position when inserted after a letter with a combining mark. tdf#139627 (Khaled Hosny)\n• Fix gaps inserted instead of kashida with some fonts. tdf#106653 (Khaled Hosny)\n• Fix justification of text containing spacing combining marks (e.g. in Malayalam). tdf#150665 (Khaled Hosny)\n• Correctly enable variable fonts variation setting during text layout, as well as font metrics. tdf#103596 (Khaled Hosny, Caolán McNamara / Red Hat)\n• Use underline size and position as well as strike-through size and position values from the font when available ba03e, and make overline size the same as underline size 8da25. (Khaled Hosny)\n• Use the same skew angle for artificial (synthetic) italic text across graphics backends and PDF export. f88e7 (Khaled Hosny)\n• Sync kashida insertion algorithm with Writer one to include fixes and enhancements from Writer that other LibreOffice components were missing. tdf#137528 (Khaled Hosny)\n• Fix gaps in justified Arabic text when the font does not have usable kashida glyph. tdf#137528 (Khaled Hosny)\n• Correctly calculate text caret position inside ligatures, and use caret positions from the font when available. tdf#83581 (Khaled Hosny)\n• Re-allow .doc files to be renamed as .dot. tdf#125216 (Justin Luth, Collabora)\n• Support embedding color (e.g. Emoji) fonts using color bitmaps (using / or OpenType tables). tdf#121327 (Khaled Hosny)\n• Correct set Postscript name when embedding for some broken fonts. tdf#138325 (Khaled Hosny)\n• Fix visual artifacts in glyphs that use fractional point coordinates. tdf#126242 (Khaled Hosny)\n• Fix missing accent chars in glyphs that use deprecated arguments to endchar operator. tdf#123234 (Khaled Hosny)\n• When exporting to PDF, you can now choose to export comments in the page margin. tdf#77650 (Samuel Mehrbrodt, allotropia)\n• When inserting a picture and using PDF as a source file, now it is possible to use larger files. a5c1c (Szymon Kłos, Collabora)\n• Support for dark and high contrast operating system themes on Windows, macOS and Linux was greatly improved. More than 40 bugs were fixed by contributors including Caolán McNamara (Red Hat), Rafael Lima, Michael Weghorn and Rizal Muttaqin.\n• When previewing styles in the side bar and the styles menu, use the CTL and Asian fonts set on the style for respective text instead of always using Western fonts. tdf#87535 (Khaled Hosny)\n• An improved version of a single toolbar user interface was implemented, supporting context-aware controls and their customization. It can be activated via ▸ ▸ . Customization can be done either with a right click context menu actions, or via ▸ ▸ , for various \"Standard (Single Mode) - <context name>\" targets. For now, context aware controls were added to Writer only. This largely makes the Contextual Single user interface obsolete, and it might be removed in future versions. tdf#125040 (Maxim Monastirsky)\n• GTK3 scrollbars now benefit from the \"smooth scrolling\" feature. Long-press on a scrollbar or use + for more precise scrolling. tdf#117388 (Caolán McNamara, Red Hat)\n• The Start Center can now filter recent documents by type. tdf#80934 (Heiko Tietze, TDF)\n• The Document Recovery dialog now has checkboxes for individual documents. tdf#114508 (Heiko Tietze, TDF)\n• The Sifr icon set was refreshed to follow GNOME Adwaita’s new rounded style. tdf#151071 (Rizal Muttaqin)\n• In Calc, the \"language\" label was changed to the more accurate \"locale\" label in the (HTML) Import Options and Text Import dialogs. tdf#138748 (Pedro Silva, Collabora)\n• Font features that are enabled by default (e.g. Standard Ligatures) can now be disabled. tdf#127423 (Khaled Hosny)\n• Stylistic Sets and Character Variants features each is now grouped together in a separate section, so they stand out from other common font features. 3f9a8 (Khaled Hosny)\n• Stylistic Sets and Character Variants features can have user-friendly labels defined in the font, these are now shown in the dialog instead of the generic feature names. Additionally, localized versions of these labels that are provided by the font are also shown when LibreOffice user interface is in the respective languages. 19787 (Khaled Hosny)\n• Some font features can have multiple alternates, these are now supported for OpenType fonts as well (previously it was supported for Graphite fonts only). 9ca3c (Khaled Hosny)\n• The language list combo-box now accepts input of BCP 47 private-use language tags like or (with every valid script subtag for Latn of course). This is an exception to the otherwise not accepted input of private-use subtags preventing mis-spreading arbitrary private-use tags, to support language attribution of artificial constructed languages. tdf#150370 (Eike Rathke, Red Hat)\n• Language list entries can be permanently added by dropping an auto-correction file into the shared or user profile's directory with the corresponding well-formed and valid BCP 47 language tag in its name. The file can be empty (0 bytes length) with no auto-correction data being present, data can be added and edited as usual in AutoCorrect Options. For example, will add the de-DE-1901 tag's language entry that will be displayed as \n\n \n\n If the tag in the file name is not a well-formed BCP 47 language tag or not valid, it is silently ignored and no language list entry will be added. tdf#150371 (Eike Rathke, Red Hat)\n• For information about IETF BCP 47 language tags, see Wikipedia and W3.org\n\nAvailable as default document language and for locale specific formatting.\n• As Croatia joins the Eurozone on the 1st of January 2023, Croatian kuna (HRK) conversion to and from euro (EUR) is now supported in the function, and the new default currency for Croatia is the euro. tdf#150011 (Eike Rathke, Red Hat)\n• The Macro Selector dialog ( ▸ ▸ ) now remembers the last run macro (792e4 - Rafael Lima).\n• The Basic IDE now has a Zoom Slider that allow users to more easily increase/decrease the zoom factor applied to the code editing window. It can also be controlled with + . The font size defined in the Options dialog ( ▸ ▸ ▸ ) is used as the 100% zoom factor (0d923 - Rafael Lima).\n\nLibreLogo programming language is more usable for graphics design with the following improvements (László Németh):\n• Up to 6 times speed increase of LABEL command by temporary layout locking of font settings. (Note: locking was suggested by Noel Grandin in tdf#105575, also he made several other performance improvements previously.)\n• Up to 32 times speed increase of drawing by custom layout locking using SLEEP -1 & SLEEP 0 command pairs. For example, 800 vector shapes drawn by 4 seconds instead of more than 2 minutes (e50f0)\n• LABEL command supports more HTML-like tags for formatting: localized color names, hundreds of OpenType and Graphite font features, font family, font size, strikethrough and highlighting. (43570) Note: bold, italic and underline formatting have been introduced by LO 7.4 in 89c34.\n• Portable SVG export for OpenType/Graphite font features, also for rotated text with text portions: font features (glyphs and other settings) and positions of text portions are exported correctly by converting text to curve, as a workaround for the bugs and incompleteness of the SVG export. (fe5cc) Test code with a rotated text containing OpenType/Graphite scientific inferior and red text portion:\n\nNote: see also #SVG for SVG export which was improved during these LibreLogo developments.\n• Fix regression of parsing of default commands in 37d86.\n\nAn extensible and robust collection of macro scripting resources for LibreOffice to be invoked from user Basic or Python scripts. (Jean-Pierre Ledure)\n\nThe libraries expose a total of 28 services each with a bunch of methods and properties.\n• The (new) Datasheet service, to manage tabular views of database data. A datasheet may be opened from a Base window or at any moment (without the Base component being open). Cursor movement and current selection content may be processed by a user script.\n• The RunCommand() method may receive arguments (see .UNO:Commands wiki page).\n• Error messages provide direct access to the help page of the failing method.\n• A new Normalize() method in the FileSystem service.\n• In the Calc service, new uses of the FilterFormula concept to selectively clear or format cells, rows or columns.\n• Support of 16,384 columns in the Calc service.\n• In the Dialog service, a new SetPageManager() method synchronizes automatically dropdown lists, next/previous buttons and tab headers while the user browses through the dialog pages.\n\nThe whole set of services (except when not relevant) is made available for Python scripts with identical syntax and behaviour as in Basic.\n\nThe English version of the documentation of the ScriptForge libraries (7.5) is fully integrated in the LibreOffice help pages (https://help.libreoffice.org/7.5/en-US/text/sbasic/shared/03/lib_ScriptForge.html?DbPAR=BASIC). Their translation into other languages is underway. (Alain Romedenne, Rafael Lima)\n\nAdded sending unique window id along with other data to LOK API. 05a77 (Gökay Şatır, Collabora)\n• In the SDK, the deprecated tools and (using the legacy type registry format) have been removed in favor of (using the incompatible new type registry format internally introduced in LibreOffice 4.1). a8485d55\n• Experimental Emoji toolbar button has been removed. Using system Emoji insertion tools is preferred. tdf#151197 (Khaled Hosny)\n• The following font families are no longer bundled with LibreOffice, Users using these fonts are advised to install them on their system:\n• The options \"Use printer metrics for document formatting\" and \"Use printer metrics for text formatting\" ( internally) were removed from various places in the Options dialog. tdf#131136 (Heiko Tietze, TDF)\n• The obsolete UNOIDL method has been deprecated (without a replacement), and its implementation now unconditionally throws a . 25fc5 (Stephan Bergmann, Red Hat)\n• Added a new property to the com::sun::star::view::PrintOptions service to allow specifying a job name which is sent to the printer. (Samuel Mehrbrodt, allotropia)"
    },
    {
        "link": "https://api.libreoffice.org/docs/idl/ref/servicecom_1_1sun_1_1star_1_1table_1_1CellProperties.html",
        "document": "contains the properties of a table cell. More...\n\ncontains the index of the number format that is used in the cells. The proper value can be determined by using the com::sun::star::util::NumberFormatter interface of the document.\n\nThe documentation for this service was generated from the following file:"
    },
    {
        "link": "https://wiki.documentfoundation.org/Documentation/DevGuide/Spreadsheet_Documents",
        "document": "LibreOffice API knows three variants of tables: text tables (see Tables), database tables (see Table Service) and spreadsheets. Each table concept has its own purpose. Text tables handle text contents, database tables offer database functionality and spreadsheets operate on data cells that can be evaluated. Being specialized in such a way means that each concept has its strength. Text tables offer full functionality for text formatting, where spreadsheets support complex calculations. Alternately, spreadsheets support only basic formatting capabilities and text tables perform elementary calculations.\n\nThe implementations of the various tables differ due to each of their specializations. Basic table features are defined in the module com.sun.star.table. Regarding the compatibility of text and spreadsheet tables, the corresponding features are also located in the module com.sun.star.table. In addition, spreadsheet tables are fully based on the specifications given and are extended by additional specifications from the module com.sun.star.sheet. Several services of the spreadsheet application representing cells and cell ranges extend the common services from the module com::sun::star::table. The following table shows the services for cells and cell ranges.\n\nThe spreadsheet document model in the LibreOffice API has five major architectural areas (see Illustration 9.1) The five areas are:\n\nThe core of the spreadsheet document model are the spreadsheets contained in the spreadsheets container. When working with document data, almost everything happens in the spreadsheet objects extracted from the spreadsheets container.\n\nThe service manager of the spreadsheet document model creates shape objects, text fields for page headers and form controls that can be added to spreadsheets. Note, that the document service manager is different from the main service manager used when connecting to the office. Each document model has its own service manager, so that the services can be adapted to the document they are required for. For instance, a text field is ordered and inserted into the page header text of a sheet using insertTextContent() or the service manager is asked for a shape object and inserts it into a sheet using at the drawpage.\n\nEach sheet in a spreadsheet document can have a drawpage for drawing contents. A drawpage can be visualized as a transparent layer above a sheet. The spreadsheet model is able to provide all drawpages in a spreadsheet document at once.\n\nLinked and named contents from all sheets are accessed through content properties at the document model. There are no content suppliers as in text documents, because the actual content of a spreadsheet document lies in its sheet objects. Rather, there are only certain properties for named and linked contents in all sheets.\n\nFinally, there are services that allow for document wide styling and structuring of the spreadsheet document. Among them are style family suppliers for cells and pages, and a number formats supplier.\n\nBesides these five architectural areas, there are document and calculation aspects shown at the bottom of the illustration. The document aspects of our model are: it is printable, storable, and modifiable, it can be protected and audited, and it supplies general information about itself. On the lower left of the illustration, the calculation aspects are listed. Although almost all spreadsheet functionality can be found at the spreadsheet objects, a few common functions are bound to the spreadsheet document model: goal seeking, consolidation and recalculation of all cells.\n\nFinally, the document model has a controller that provides access to the graphical user interface of the model and has knowledge about the current view status in the user interface (see the upper left of the illustration).\n\nThe usage of the spreadsheet objects in the spreadsheets container is discussed in detail in the section Working With Spreadsheet Documents. Before discussing spreadsheet objects, consider two examples and how they handle a spreadsheet document, that is, how to create, open, save and print.\n\nThe following helper method opens a new spreadsheet document component. The method retrieves a connection. Refer to chapter First Steps for additional information.\n\nOur helper returns a com.sun.star.lang.XComponent interface for the recently loaded document. Now the XComponent is passed to the following method to add a new spreadsheet to our document.\n\nThe method returns a com.sun.star.sheet.XSpreadsheet interface. This interface is passed to the method below, which shows how to access and modify the content and formatting of single cells. The interface com.sun.star.sheet.XSpreadsheet returned by is derived from com.sun.star.table.XCellRange. By working with it, cells can be accessed immediately using :\n\nSee also Working with a Spreadsheet Document (Example).\n\nRunning an example showing how to find out which properties an object provides (with an object of type com.sun.star.table.XCell instead of ), one gets for example the following properties (OpenOffice.org 2.4):\n\nIf a document in LibreOffice API is required, begin by getting a com.sun.star.frame.Desktop service from the service manager. The desktop handles all document components in LibreOffice API. It is discussed thoroughly in the chapter Office Development. Office documents are often called components, because they support the com.sun.star.lang.XComponent interface. An is a UNO object that can be disposed of directly and broadcast an event to other UNO objects when the object is disposed.\n\nThe Desktop can load new and existing components from a URL. For this purpose it has a com.sun.star.frame.XComponentLoader interface that has one single method to load and instantiate components from a URL into a frame:\n\nThe interesting parameters in our context is the URL that describes the resource that is loaded and the load arguments. For the target frame, pass a \" \" and set the search flags to 0. In most cases, existing frames are not reused.\n\nThe URL can be a URL, an URL, an URL or a private: URL. Locate the correct URL format in the Load URL box in the function bar of LibreOffice API. For new spreadsheet documents, a special URL scheme is used. The scheme is \"private:\", followed by \"factory\". The resource is \"scalc\" for LibreOffice API spreadsheet documents. For a new spreadsheet document, use \"private:factory/scalc\".\n\nThe load arguments are described in com.sun.star.document.MediaDescriptor. The properties and are boolean values and used for programming. If is true, the loader creates a new untitled document from the given URL. If it is false, template files are loaded for editing. If is true, the document is loaded in the background. This is useful to generate a document in the background without letting the user observe what is happening. For instance, use it to generate a document and print it out without previewing. Refer to Office Development for other available options. This snippet loads a document in hidden mode:\n\nDocuments are storable through their interface com.sun.star.frame.XStorable. This interface is discussed in detail in Office Development. An implements these operations:\n\nThe method names are evident. The method is the exact representation of File - Save As from the File menu, that is, it changes the current document location. In contrast, stores a copy to a new location, but leaves the current document URL untouched.\n\nFor exporting purposes, a filter name can be passed that triggers an export to other file formats. The property needed for this purpose is the string argument that takes filter names defined in the configuration file:\n\nIn TypeDetection.xml look for elements, their attribute contains the needed strings for . The proper filter name for StarWriter 5.x is \"StarWriter 5.0\", and the export format \"MS Word 97\" is also popular. This is the element in TypeDetection.xml that describes the MS Excel 97 filter:\n\nThe following method stores a document using this filter:\n\nIf an empty array of structs is passed, the native .ods format of LibreOffice API is used.\n\nLoading and saving LibreOffice API documents is described in Handling Documents. This section lists all the filter names for spreadsheet documents and describes the filter options for text file import.\n\nThe filter name and options are passed on loading or saving a document in a sequence of com.sun.star.beans.PropertyValues. The property contains the name and the property contains the filter options.\n\nThe list of filter names (the last two columns show the possible directions of the filters):\n\nThese filters accept a string containing the numerical index of the used character set for single-byte characters, that is, 0 for the system character set.\n\nThe numerical indexes assigned to the character sets:\n\nThis filter accepts an option string containing at least 5 tokens, separated by commas. Tokens 6 and following are optional.\n\nThe following table shows an example string for a file with four columns of type date - number - number - number. In the table the tokens are numbered from (1) to (5). Each token is explained below.\n\nFor the filter options above, set the PropertyValue in the load arguments to \"44,34,0,1,1/5/2/1/3/1/4/1\". There are a number of possible settings for the five tokens.\n• Field separator(s) as ASCII values. Multiple values are separated by the slash sign (\"/\"), that is, if the values are separated by semicolons and horizontal tabulators, the token would be 59/9. To treat several consecutive separators as one, the four letters /MRG have to be appended to the token. If the file contains fixed width fields, the three letters FIX are used.\n• The text delimiter as ASCII value, that is, 34 for double quotes and 39 for single quotes.\n• The character set used in the file as described above.\n• Number of the first line to convert. The first line in the file has the number 1.\n• Cell format of the columns. The content of this token depends on the value of the first token.\n\nThis token is the equivalent of the \"Language\" listbox in the user interface for csv import.\n\n It is a String expressed in decimal notation. If the value is 0 or omitted, the language identifier of the user interface is used.\n\nThe language identifier is based on the Microsoft language identifiers, for further information please see:\n\nUse the decimal notation, example for English US : 1033 whereas Microsoft documentation used hexadecimal notation 0x0409.\n\nThis token is the equivalent of the check box \"Quoted field as text\".\n\nString, either or . Default value : .\n\nThis token is the equivalent of the check box \"Quote all text cells\".\n\nString, either or . Default value : .\n\nThis token is the equivalent of the check box \"Detect special numbers\".\n\nString, either or . Default value : .\n\nThis token has no UI equivalent. If , the number cells are stored as numbers. If , the numbers are stored as text, with text delimiters.\n\nString, either or . Default value : .\n\nThis token is the equivalent of the check box \"Save cell contents as shown\".\n\nString, either or . Default value : .\n\nString, either or . Default value : .\n\nRemove spaces. Trim leading and trailing spaces, when reading the file.\n\nString, either or . Default value : .\n\nExport the entire document to individual sheets .csv files or a specified sheet.\n• 0 or absent means the default behaviour, first sheet from command line, or current sheet in macro filter options, exported to sample.csv\n• -1 for all sheets, each sheet is exported to an individual file of the base file name concatenated with the sheet name, for example sample-Sheet1.csv, sample-Sheet2.csv and sample-Sheet3.csv\n• N export the N-th sheet within the range of number of sheets. Example: to export the second sheet, set 2 here to get sample-Sheet2.csv\n\nDetermines whether formula expressions starting with a = equal sign character are to be evaluated as formulas or imported as textual data.\n\nString, either or . Default value : .\n\nIf evaluate formulas on input. If formulas are input as text. If omitted (not present at all), the default value is to keep the behaviour of old versions' options string that didn't have this token at all. If present and empty (or any other value than ) the default value is .\n\nString, either or . Default value : .\n\nIf include a byte-order-mark (BOM) in the export. If the export does not include a BOM. If omitted (not present at all), the default value is to keep the behaviour of old versions' options string that didn't have this token at all. If present and empty (or any other value than ) the default value is .\n\nExport to Windows-1252, Field delimiter : comma, Text delimiter : quote, Save cell contents as shown: \n\n\n\nExport all 3 sheets of sample.ods to sample-Sheet1.csv, sample-Sheet2.csv and sample-Sheet3.csv: \n\n\n\nPrinting is a common office functionality. The chapter Office Development provides in-depth information about it. The spreadsheet document implements the com.sun.star.view.XPrintable interface for printing. It consists of three methods:\n\nThe following code is used with a given document to print to the standard printer without any settings:\n\nThere are two groups of properties involved in general printing. The first one is used with and , and controls the printer, and the second is passed to and controls the print job.\n\ncom.sun.star.view.PrinterDescriptor comprises the properties for the printer:\n\ncom.sun.star.view.PrintOptions contains the following possibilities for a print job:\n\nThe following method uses and to print to a special printer, and preselect the pages to print.\n\nManual page breaks can be inserted and removed using the property of the services com.sun.star.table.TableColumn and com.sun.star.table.TableRow. For details, refer to the section about page breaks in the chapter Spreadsheet Documents.\n\nTo reduce the page size of a sheet so that the sheet fits on a fixed number of printout pages, use the properties and of the current page style. Both of the properties are short numbers. The property expects a percentage and is the number of pages the printout is to fit. The page style is available through the interface com.sun.star.style.XStyleFamiliesSupplier of the document component, and is described in the chapter Overall Document Features.\n\nThe Interface com.sun.star.sheet.XPrintAreas is available at spreadsheets. It provides access to the addresses of all printable cell ranges, represented by a sequence of com.sun.star.table.CellRangeAddress structs.\n\nThe whole spreadsheet document is represented by the service com.sun.star.sheet.SpreadsheetDocument. It implements interfaces that provide access to the container of spreadsheets and methods to modify the document wide contents, for instance, data consolidation.\n\nA spreadsheet document contains a collection of spreadsheets with at least one spreadsheet, represented by the service com.sun.star.sheet.Spreadsheets. The method of the Interface com.sun.star.sheet.XSpreadsheetDocument returns the interface com.sun.star.sheet.XSpreadsheets for accessing the container of sheets.\n\nWhen the spreadsheet container is retrieved from a document using its method, it is possible to access the sheets in three different ways:\n\nThe following two helper methods demonstrate how spreadsheets are accessed by their indexes and their names:\n\nThe interface com.sun.star.sheet.XSpreadsheets contains additional methods that use the name of spreadsheets to add new sheets, and to move and copy them:\n\nThe method below shows how a new spreadsheet is inserted into the spreadsheet collection of a document with the specified name.\n\nThe previous section introduced the organization of the spreadsheets in a document and how they can be handled. This section discusses the spreadsheets themselves. The following illustration provides an overview about the main API objects that can be used in a spreadsheet.\n\nThe main services in a spreadsheet are com.sun.star.sheet.Spreadsheet, com.sun.star.sheet.SheetCellRange, the cell service com.sun.star.sheet.SheetCell, the collection of cell ranges com.sun.star.sheet.SheetCellRanges and the services com.sun.star.table.TableColumn and com.sun.star.table.TableRow. An overview of the capabilities of these services is provided below.\n\nThe spreadsheet is a com.sun.star.sheet.Spreadsheet service that includes the service com.sun.star.sheet.SheetCellRange, that is, a spreadsheet is a cell range with additional capabilities concerning the entire sheet:\n• It can be named using com.sun.star.container.XNamed.\n• It has interfaces for sheet analysis. Data pilot tables, sheet outlining, sheet auditing (detective) and scenarios all are controlled from the spreadsheet object. The corresponding interfaces are com.sun.star.sheet.XDataPilotTablesSupplier, com.sun.star.sheet.XScenariosSupplier, com.sun.star.sheet.XSheetOutline and com.sun.star.sheet.XSheetAuditing.\n• Cells can be inserted, and entire cell ranges can be removed, moved or copied on the spreadsheet level using com.sun.star.sheet.XCellRangeMovement.\n• Drawing elements in a spreadsheet are part of the draw page available through com.sun.star.drawing.XDrawPageSupplier.\n• Certain sheet printing features are accessed at the spreadsheet. The com.sun.star.sheet.XPrintAreas and com.sun.star.sheet.XSheetPageBreak are used to get page breaks and control print areas.\n• The spreadsheet maintains charts. The interface com.sun.star.table.XTableChartsSupplier controls charts in the spreadsheet.\n• All cell annotations can be retrieved on the spreadsheet level with com.sun.star.sheet.XSheetAnnotationsSupplier.\n• A spreadsheet can be permanently protected from changes through com.sun.star.util.XProtectable.\n\nThe spreadsheet, as well as the cell ranges in a spreadsheet are com.sun.star.sheet.SheetCellRange services. A is a rectangular range of calculation cells that includes the following services:\n\nThe interfaces supported by a are depicted in the following illustration:\n\nA has the following capabilities:\n• Supplies cells and sub-ranges of cells, as well as rows and columns. It has the interfaces com.sun.star.sheet.XSheetCellRange and com.sun.star.table.XColumnRowRange.\n• Performs calculations with a . The interface com.sun.star.sheet.XSheetOperation is for aggregate operations, com.sun.star.sheet.XMultipleOperation copies formulas adjusting their cell references, com.sun.star.sheet.XSubTotalCalculatable applies and removes sub totals, and com.sun.star.sheet.XArrayFormulaRange handles array formulas.\n• Formats cells in a range. The settings affect all cells in the range. There are cell properties, character properties and paragraph properties for formatting purposes. Additionally, a supports auto formats with com.sun.star.table.XAutoFormattable and the content of the cells can be indented using com.sun.star.util.XIndent. The interfaces com.sun.star.sheet.XCellFormatRangesSupplier and com.sun.star.sheet.XUniqueCellFormatRangesSupplier obtain enumeration of cells that differ in formatting.\n• Works with the data in a cell range through a sequence of sequences of any that maps to the two-dimensional cell array of the range. This array is available through com.sun.star.sheet.XCellRangeData.\n• Fills a cell range with data series automatically through its interface com.sun.star.sheet.XCellSeries.\n• Perform queries for cell contents, such as formula cells, formula result types, or empty cells. The interface com.sun.star.sheet.XCellRangesQuery of the included com.sun.star.sheet.SheetRangesQuery service is responsible for this task.\n• Sorts and filters the content of a , using com.sun.star.util.XSortable, com.sun.star.sheet.XSheetFilterable and com.sun.star.sheet.XSheetFilterableEx.\n• Provides its unique range address in the spreadsheet document, that is, the start column and row, end column and row, and the sheet where it is located. The getRangeAddress() returns the corresponding address description struct com.sun.star.table.CellRangeAddress.\n• Charts can be based on a , because it supports com.sun.star.chart.XChartDataArray.\n\nA com.sun.star.sheet.SheetCell is the base unit of LibreOffice Calc tables. Values, formulas and text required for calculation jobs are all written into sheet cells. The includes the following services:\n\nThe exports the following interfaces:\n\nThe service has the following capabilities:\n• It can access the cell content. It can contain numeric values that are used for calculations, formulas that operate on these values, and text supporting full-featured formatting and hyperlink text fields. The access to the cell values and formulas is provided through the parent service com.sun.star.table.Cell. The interface com.sun.star.table.XCell is capable of manipulating the values and formulas in a cell. For text, the service com.sun.star.text.Text with the main interface com.sun.star.text.XText is available at a . Its text fields are accessed through com.sun.star.text.XTextFieldsSupplier.\n• A is a special case of a . As such, it has all capabilities of the com.sun.star.sheet.SheetCellRange described above.\n• It can have an annotation: com.sun.star.sheet.XSheetAnnotationAnchor.\n• It can provide its unique cell address in the spreadsheet document, that is, its column, row and the sheet it is located in. The getCellAddress() returns the appropriate com.sun.star.table.CellAddress struct.\n• It can be locked temporarily against user interaction with com.sun.star.document.XActionLockable.\n\nThe container of com.sun.star.sheet.SheetCellRanges is used where several cell ranges have to be handled at once for cell query results and other situations. The service includes cell, paragraph and character property services, and it offers a query option:\n\nThe interfaces of com.sun.star.sheet.SheetCellRanges are element accesses for the ranges in the container. These interfaces are discussed below.\n\nThe container has the following capabilities:\n• It can be formatted using the character, paragraph and cell property services it includes.\n• It yields independent cell ranges through the element access interfaces com.sun.star.container.XIndexAccess, com.sun.star.container.XNameAccess and com.sun.star.container.XEnumerationAccess.\n• It can access, replace, append and remove ranges by name through com.sun.star.container.XNameContainer\n• It can add new ranges to by their address descriptions, access the ranges by index, and obtain the cells in the ranges. This is possible through the interface com.sun.star.sheet.XSheetCellRangeContainer that was originally based on com.sun.star.container.XIndexAccess. The maintain a sub-container of all cells in the ranges that are not empty, obtainable through the getCells() method.\n• It can enumerate the ranges using com.sun.star.container.XEnumerationAccess.\n• It can query the ranges for certain cell contents, such as formula cells, formula result types or empty cells. The interface com.sun.star.sheet.XCellRangesQuery of the included com.sun.star.sheet.SheetRangesQuery service is responsible for this task.\n• The supports selected features, such as searching and replacing, indenting, sheet operations and charting.\n\nAll cell ranges are organized in columns and rows, therefore column and row containers are retrieved from a spreadsheet, as well as from sub-ranges of a spreadsheet through com.sun.star.table.XColumnRowRange. These containers are com.sun.star.table.TableColumns and com.sun.star.table.TableRows. Both containers support index and enumeration access. Only the supports name access to the single columns and rows (com.sun.star.table.TableColumn and com.sun.star.table.TableRow) of a .\n\nThe following UML charts show table columns and rows. The first chart shows columns:\n\nThe collection of table rows differs from the collection of columns, that is, it does not support com.sun.star.container.XNameAccess:\n\nThe services for table rows and columns control the table structure and grid size of a cell range:\n• The containers for columns and rows have methods to insert and remove columns, and rows by index in their main interfaces com.sun.star.table.XTableRows and com.sun.star.table.XTableColumns.\n• The services and have properties to adjust their column width and row height, toggle their visibility, and set page breaks.\n\nA spreadsheet is a cell range with additional interfaces and is represented by the service com.sun.star.sheet.Spreadsheet.\n\nThe properties of a spreadsheet deal with its visibility and its page style:\n\nThe spreadsheet interface com.sun.star.container.XNamed obtains and changes the name of the spreadsheet, and uses it to get a spreadsheet from the spreadsheet collection. Refer to Spreadsheet Documents.\n\nThe interface com.sun.star.sheet.XCellRangeMovement of the service supports inserting and removing cells from a spreadsheet, and copying and moving cell contents. When cells are copied or moved, the relative references of all formulas are updated automatically. The sheet index included in the source range addresses should be equal to the index of the sheet of this interface.\n\nThe following example copies a cell range to another location in the sheet.\n\nThe methods and of the interface com.sun.star.sheet.XSheetPageBreak return the positions of column and row page breaks, represented by a sequence of com.sun.star.sheet.TablePageBreakData structs. Each struct contains the position of the page break and a boolean property that determines if the page break was inserted manually. Inserting and removing a manual page break uses the property of the services com.sun.star.table.TableColumn and com.sun.star.table.TableRow.\n\nThe following example prints the positions of all the automatic column page breaks:\n\nA cell range is a rectangular range of cells. It is represented by the service com.sun.star.sheet.SheetCellRange.\n\nThe cell range properties deal with the position and size of a range, conditional formats, and cell validation during user input.\n\nThis service extends the service com.sun.star.table.CellRange to provide common table cell range functionality.\n\nThe interface com.sun.star.sheet.XSheetCellRange is derived from com.sun.star.table.XCellRange. It provides access to cells of the range and sub ranges, and is supported by the spreadsheet and sub-ranges of a spreadsheet. The methods in com.sun.star.sheet.XSheetCellRange are:\n\nThe interface com.sun.star.table.XCellRange provides methods to access cell ranges and single cells from a cell range.\n\nCells are retrieved by their position. Cell addresses consist of a row index and a column index. The index is zero-based, that is, the index 0 means the first row or column of the table.\n\n\n\n Additionally, contains the method that returns the com.sun.star.sheet.XSpreadsheet interface of the spreadsheet which contains the cell range.\n\nThere are no methods to modify the contents of all cells of a cell range. Access to cell range formatting is supported. Refer to the chapter Formatting for additional details.\n\nIn the following example, is an existing cell range (a com.sun.star.table.XCellRange interface):\n• The method merges or undoes merged the whole cell range.\n• The method determines if the cell range is completely merged.\n\nThe cell range interface com.sun.star.table.XColumnRowRange accesses the column and row ranges in the current cell range. A column or row range contains all the cells in the selected column or row. This type of range has additional properties, such as, visibility, and width or height. For more information, see Columns and Rows.\n• The method returns the interface com.sun.star.table.XTableColumns of the collection of columns.\n• The method returns the interface com.sun.star.table.XTableRows of the collection of rows.\n\nThe contents of a cell range that are stored in a 2-dimensional array of objects are set and obtained by the interface com.sun.star.sheet.XCellRangeData.\n• The method returns a 2-dimensional array with the contents of all cells of the range.\n• The method fills the data of the passed array into the cells. An empty cell is created by an empty string. The size of the array has to fit in the size of the cell range.\n\nThe following example uses the cell range that has the size of 2 columns and 3 rows.\n\nThe method of the interface com.sun.star.sheet.XCellRangeAddressable returns a com.sun.star.table.CellRangeAddress struct that contains the absolute address of the cell in the spreadsheet document, including the sheet index. This is useful to get the address of cell ranges returned by other methods.\n\nThe interface com.sun.star.sheet.XCellSeries fills out each cell of a cell range with values based on a start value, step count and fill mode. It is possible to fill a series in each direction, specified by a com.sun.star.sheet.FillDirection constant. If the fill direction is horizontal, each row of the cell range forms a separate series. Similarly each column forms a series on a vertical fill.\n• The method uses the first cell of each series as start value. For example, if the fill direction is \"To top\", the bottom-most cell of each column is used as the start value. It expects a fill mode to be used to continue the start value, a com.sun.star.sheet.FillMode constant. If the values are dates, com.sun.star.sheet.FillDateMode constants describes the mode how the dates are calculated. If the series reaches the specified end value, the calculation is stopped.\n• The method determines the fill mode and step count automatically. It takes a parameter containing the number of cells to be examined. For example, if the fill direction is \"To top\" and the specified number of cells is three, the three bottom-most cells of each column are used to continue the series.\n\nThe following example may operate on the following spreadsheet:\n\nThis example produces the following result:\n\nThe cell range interface com.sun.star.sheet.XSheetOperation computes a value based on the contents of all cells of a cell range or clears specific contents of the cells.\n• The method returns the result of the calculation. The constants com.sun.star.sheet.GeneralFunction specify the calculation method.\n• The method clears contents of the cells used. The parameter describes the contents to clear, using the constants of com.sun.star.sheet.CellFlags.\n\nThe following code shows how to compute the average of a cell range and clear the cell contents:\n\nA multiple operation combines a series of formulas with a variable and a series of values. The results of each formula with each value is shown in the table. Additionally, it is possible to calculate a single formula with two variables using a 2-value series. The method of the interface com.sun.star.sheet.XMultipleOperation inserts a multiple operation range.\n\nThe following example shows how to calculate the values 1 to 5 raised to the powers of 1 to 5 (each value to each power). The first column contains the base values, and the first row the exponents, for example, cell E3 contains the result of 24. Below there are three trigonometrical functions calculated based on a series of values, for example, cell C11 contains the result of cos(0.2).\n\nNote that the value series have to be included in the multiple operations cell range, but not the formula cell range (in the second example). The references in the formulas address any cell outside of the area to be filled. The column cell and row cell parameter have to reference these cells exactly. In the second example, a row cell address does not have to be used, because the row contains the formulas.\n• If the whole cell range contains an array formula, the method returns the formula string, otherwise an empty string is returned.\n• The method sets an array formula to the complete cell range.\n\nA single cell of a spreadsheet is represented by the service com.sun.star.sheet.SheetCell. This service extends the service com.sun.star.table.Cell, that provides fundamental table cell functionality, such as setting formulas, values and text of a cell.\n\nThe service com.sun.star.sheet.SheetCell introduces new properties and interfaces, extending the formatting-related cell properties of com.sun.star.table.Cell.\n\nThe cell interface com.sun.star.table.XCell provides methods to access the value, formula, content type, and error code of a single cell:\n\nThe value of a cell is a floating-point number. To set a formula to a cell, the whole formula string has to be passed including the leading equality sign. The function names must be in English.\n\n\n\n The method returns a value of the enumeration com.sun.star.table.CellContentType indicating the type of the cell content.\n\nThe following code fragment shows how to access and modify the content, and formatting of single cells. The is an existing cell range (a com.sun.star.table.XCellRange interface, described in Cell Ranges). The method is provided by this interface.\n\nNote that since the only data attributes a cell has for representing numbers is value and formula, other types available in LibreOffice Calc have to be translated before you can use them. See com.sun.star.util.NumberFormat for the standard formats.\n\nHow this value will be shown to the user depends on the cell's Number Format.\n\nThe service com.sun.star.text.Text supports the modification of simple or formatted text contents. Changing text contents and text formatting is provided by the interface com.sun.star.text.XText as discussed in First Steps. Refer to chapter Editing Text for further information. It implements the interfaces com.sun.star.container.XEnumerationAccess that provides access to the paragraphs of the text and the interface com.sun.star.text.XText to insert and modify text contents. For detailed information about text handling, see Editing Text.\n\nThe interface com.sun.star.text.XTextFieldsSupplier contains methods that provide access to the collection of text fields in the cell. For details on inserting text fields, refer to Text Fields.\n\nThe method of the interface com.sun.star.sheet.XCellAddressable returns a com.sun.star.table.CellAddress struct that contains the absolute address of the cell in the spreadsheet document, including the sheet index. This is useful to get the address of cells returned by other methods.\n\nCell range collections are represented by the service com.sun.star.sheet.SheetCellRanges. They are returned by several methods, for instance the cell query methods of com.sun.star.sheet.SheetRangesQuery. Besides standard container operations, it performs a few spreadsheet functions also usable with a single cell range.\n\nThe interfaces com.sun.star.container.XEnumerationAccess and com.sun.star.container.XIndexAccess iterates over all contained cell ranges by index or enumeration. With the com.sun.star.container.XNameContainer, it is possible to insert ranges with a user-defined name. Later the range can be found, replaced or removed using the name.\n\nThe following interfaces and service perform cell range actions on all ranges contained in the collection:\n\nThe interfaces com.sun.star.sheet.XSheetCellRangeContainer and com.sun.star.sheet.XSheetCellRanges support basic handling of cell range collections.\n• The method returns the string representation of all cell ranges.\n• The method returns a sequence with all cell range addresses.\n\nThe interface com.sun.star.sheet.XSheetCellRangeContainer is derived from the interface com.sun.star.sheet.XSheetCellRanges to insert and remove cell ranges.\n• The methods and insert one or more ranges into the collection. If the boolean parameter is set to , the methods try to merge the new range(s) with the ranges of the collection.\n• The methods and remove existing ranges from the collection. Only ranges that are contained in the collection are removed. The methods do not try to shorten a range.\n\nThe interface com.sun.star.sheet.XSheetCellRanges implements methods for access to cells and cell ranges:\n• The method returns the interface com.sun.star.container.XEnumerationAccess of a cell collection. The service com.sun.star.sheet.Cells is discussed below. This collection contains the cell addresses of non-empty cells in all cell ranges.\n\nThe following example demonstrates the usage of cell range collections and cell collections.\n\nThe services com.sun.star.table.TableColumns and com.sun.star.table.TableRows represent collections of all columns and rows of a table. It is possible to access cells of columns and rows, and insert and remove columns and rows using the interfaces com.sun.star.table.XTableColumns and com.sun.star.table.XTableRows that are derived from com.sun.star.container.XIndexAccess. The method of the interface com.sun.star.container.XEnumerationAccess creates an enumeration of all columns or rows. The interface com.sun.star.container.XNameAccess accesses columns through their names. The implementation of this interface is optional.\n\nA single column or row is represented by the services com.sun.star.table.TableColumn and com.sun.star.table.TableRow. They implement the interfaces com.sun.star.table.XCellRange that provide access to the cells and com.sun.star.beans.XPropertySet for modifying settings. Additionally, the service implements the interface com.sun.star.container.XNamed. It provides the method that returns the name of a column. Changing the name of a column is not supported.\n\nIn the following example, is an interface of a collection of columns, is an interface of a collection of rows, and is the range formed by the columns and rows.\n\nIn cells, cell ranges, table rows, table columns and cell ranges collections, the cells are formatted through the service com.sun.star.table.CellProperties. These properties are accessible through the interface com.sun.star.beans.XPropertySet that is supported by all the objects mentioned above. The service contains all properties that describe the cell formatting of the cell range, such as the cell background color, borders, the number format and the cell alignment. Changing the property values affects all cells of the object being formatted.\n\nThe cell border style is stored in the struct com.sun.star.table.TableBorder. A cell range contains six different kinds of border lines: upper, lower, left, right, horizontal inner, and vertical inner line. Each line is represented by a struct com.sun.star.table.BorderLine that contains the line style and color. The boolean members specifies the validity of the members containing the line style. If the property contains the value true, the line style is equal in all cells that include the line. The style is contained in the struct. The value false means the cells are formatted differently and the content of the struct is undefined. When changing the border property, these boolean values determine if the lines are changed to the style contained in the respective struct.\n\nThe following services of a cell range contain properties for the character style and paragraph format:\n\nThe chapter Formatting contains a description of these properties.\n\nThis example formats a given cell range :\n\nThe code below changes the character and paragraph formatting of a cell. Assume that is a com.sun.star.table.XCell interface of a spreadsheet cell.\n\nThe methods of the interface com.sun.star.util.XIndent change the left indentation of the cell contents. This interface is supported by cells, cell ranges and collections of cell ranges. The indentation is incremental and decremental, independent for each cell.\n• The method reduces the indentation of each cell by 1.\n• The method enlarges the indentation of each cell by 1.\n\nThe following sample shows how to increase the cell indentation by 1.\n\nIt is possible to get collections of all equally formatted cell ranges contained in a source cell range.\n\nThe service com.sun.star.sheet.CellFormatRanges represents a collection of equally formatted cell ranges. The cells inside of a cell range of the collection have the same formatting attributes. All cells of the source range are contained in one of the ranges. If there is a non-rectangular, equal-formatted range, it is split into several rectangular ranges.\n\nThe service com.sun.star.sheet.UniqueCellFormatRanges represents, similar to Cell Format Ranges above, a collection of equally formatted cell ranges, but this collection contains cell range container objects (service com.sun.star.sheet.SheetCellRanges) that contain the cell ranges. The cells of all ranges inside of a cell range container are equally formatted. The formatting attributes of a range container differ from each other range container. All equally formatted ranges are consolidated into one container.\n\nIn the following example, the cells have two different background colors. The formatted ranges of the range A1:G3 are queried in both described ways.\n\nA com.sun.star.sheet.CellFormatRanges object contains the following ranges: A1:C2, D1:G1, D2:F2, G2:G2, and A3:G3.\n\nA com.sun.star.sheet.UniqueCellFormatRanges object contains two com.sun.star.sheet.SheetCellRanges range collections. One collection contains the white ranges, that is, A1:C2, D1:G1, G2:G2, and the other collection, the gray ranges, that is, D2:F2, A3:G3.\n\nThe following code is an example of accessing the formatted ranges in Java. The is a helper method that returns the range address as a string.\n\nTable auto formats are used to apply different formats to a cell range. A table auto format is a collection of cell styles used to format all cells of a range. The style applied is dependent on the position of the cell.\n\nThe table auto format contains separate information about four different row types and four different column types:\n• First row (header), first data area row, second data area row, last row (footer)\n• First column, first data area column, second data area column, last column\n\nThe row or column types for the data area (between first and last row/column) are repeated in sequence. Each cell of the formatted range belongs to one of the row types and column types, resulting in 16 different auto-format fields. In the example below, the highlighted cell has the formatting of the first data area row and last column field. Additionally, this example shows the indexes of all the auto format fields. These indexes are used to access the field with the interface com.sun.star.container.XIndexAccess.\n\nA table auto format is represented by the service com.sun.star.sheet.TableAutoFormat. It contains exactly 16 auto format fields (service com.sun.star.sheet.TableAutoFormatField). Each auto format field contains all properties of a single cell.\n\nThe cell range interface com.sun.star.table.XAutoFormattable contains the method that applies a table auto format to a cell range. The cell range must have a size of at least 3x3 cells. The properties of the table auto format determine the formatting properties are copied to the cells. The default setting of all the properties is true.\n\nThe collection of all table auto formats is represented by the service com.sun.star.sheet.TableAutoFormats. There is only one instance of this collection in the whole application. It contains all default and user-defined auto formats that are used in spreadsheets and tables of the word-processing application. It is possible to iterate through all table auto formats with an enumeration, or to access them directly using their index or their name.\n\nThe following example shows how to insert a new table auto format, fill it with properties, apply it to a cell range and remove it from the format collection.\n\nA cell can be formatted automatically with a conditional format, depending on its contents or the result of a formula. A conditional format consists of several condition entries that contain the condition and name of a cell style. The style of the first met condition, true or \"not zero\", is applied to the cell.\n\nA cell or cell range object contains the properties and . These properties return the interface com.sun.star.sheet.XSheetConditionalEntries of the conditional format container com.sun.star.sheet.TableConditionalFormat. The objects of both properties are equal, except for the representation of formulas. The property uses function names in the current language.\n\nA condition entry of a conditional format is represented by the service com.sun.star.sheet.TableConditionalEntry. It implements two interfaces:\n• The interface com.sun.star.sheet.XSheetCondition gets and sets the operator, the first and second formula and the base address for relative references.\n• The interface com.sun.star.sheet.XSheetConditionalEntry gets and sets the cell style name.\n\nThe service com.sun.star.sheet.TableConditionalFormat contains all format conditions and returns com.sun.star.sheet.TableConditionalEntry objects. The interface com.sun.star.sheet.XSheetConditionalEntries inserts new conditions and removes them.\n• The method inserts a new condition. It expects a sequence of com.sun.star.beans.PropertyValue objects. The following properties are supported:\n• and : Strings that contain the values or formulas to evaluate. is used only if the property Operator contains or .\n• : A com.sun.star.table.CellAddress struct that contains the base address for relative cell references in formulas.\n• : The name of the cell style to apply.\n• The methods removes the condition entry at the specified position.\n\nThe following example applies a conditional format to a cell range. It uses the cell style \"MyNewCellStyle\" that is applied to each cell containing a value greater than 1. The xSheet is the com.sun.star.sheet.XSpreadsheet interface of a spreadsheet.\n\nUnlike other document models that provide access to their content by content suppliers, the spreadsheet document contains properties that allow direct access to various containers.\n\n\n\n The properties allow access to various containers:\n• : The container with all the named ranges. See Named Ranges.\n• and : Containers with row labels and column labels. See Label Ranges.\n• : The container with all database ranges. See Database Ranges.\n• , and : Containers with external links. See Sheet Links.\n\nA cell cursor is a cell range with extended functionality and is represented by the service com.sun.star.sheet.SheetCellCursor. With a cell cursor it is possible to move through a cell range. Each table can contain only one cell cursor.\n\nIt implements all interfaces described in Cell Ranges and the basic cursor interfaces of the service com.sun.star.table.CellCursor that represents the cell or cell range cursor of a table.\n\nThe interface com.sun.star.sheet.XSpreadsheet of a spreadsheet creates the cell cursors. The methods return the interface com.sun.star.sheet.XSheetCellCursor of the cursor. It is derived from the interface com.sun.star.sheet.XSheetCellRange that provides access to cells and cell ranges. Refer to Cell Ranges for additional information.\n• The method creates a cursor that spans over the whole spreadsheet.\n• The method creates a cursor that spans over the given cell range.\n\nThe includes the service from the table module:\n\nThe service com.sun.star.table.CellCursor implements the interface com.sun.star.table.XCellCursor that provides methods to move to specific cells of a cell range. This interface is derived from com.sun.star.table.XCellRange so all methods that access single cells can be used.\n\nThe following example shows how to modify a cell beyond a filled area.The xCursor may be an initialized cell cursor.\n\nThe interface com.sun.star.sheet.XSheetCellCursor sets the cursor to specific ranges in the sheet.\n• The method expands the cursor to the shortest cell range filled with any data. A few examples from the spreadsheet below are: the cursor C2:C2 expands to B2:D3, cursor C1:C2 expands to B1:D3 and cursor A1:D4 is unchanged.\n• The method expands or shortens the cursor range to an array formula range. This works only if the top-left cell of the current cursor contains an array formula. An example using the spreadsheet above: All the cursors with a top-left cell located in the range F2:G3 are modified to this array formula range, F2:F2 or G2:G4.\n• The method expands the current cursor range so that all merged cell ranges intersecting the current range fit completely.\n• The methods and expand the cursor range so that it contains all cells of the columns or rows of the current range.\n• The method resizes the cursor range to the given dimensions. The start address of the range is left unmodified. To move the cursor range without changing the current size, use the method from the interface com.sun.star.table.XCellCursor.\n\nThe following example tries to find the range of the array formula in cell F22. The is a com.sun.star.sheet.XSpreadsheet interface of a spreadsheet and is a helper method that returns the range address as a string.\n\nThe cursor interface com.sun.star.sheet.XUsedAreaCursor contains methods to locate the used area of the entire sheet. The used area is the smallest cell range that contains all cells of the spreadsheet with any contents, such as values, text, and formulas, or visible formatting, such as borders and background color. In the following example, is a com.sun.star.sheet.XSpreadsheet interface of a spreadsheet.\n\nCell ranges can be assigned a name that they may be addressed by in formulas. This is done with named ranges. Another way to use names for cell references in formulas is the automatic label lookup which is controlled using label ranges.\n\nA named range is a named formula expression, where a cell range is just one possible content. Thus, the content of a named range is always set as a string.\n\nThe collection of named ranges is accessed using the document's property. A new named range is added by calling the com.sun.star.sheet.XNamedRanges interface's method. The method's parameters are:\n• The name for the new named range.\n• The content. This must be a string containing a valid formula expression. A commonly used type of expression is an absolute cell range reference like \"$Sheet1.$A1:$C3\".\n• A reference position for relative references. If the content contains relative cell references, and the named range is used in a formula, the references are adjusted for the formula's position. The reference position states which cell the references are relative to.\n• The type of the named range that controls if the named range is included in some dialogs. The type must be a combination of the com.sun.star.sheet.NamedRangeFlag constants:\n• If the bit is set, the named range is offered as a criteria range in the \"Advanced Filter\" dialog.\n• If the , or bit is set, the named range is selected as \"Print range\", \"Columns to repeat\" or \"Rows to repeat\" in the Edit Print Ranges dialog.\n\nThe method creates named ranges from header columns or rows in a cell range. The com.sun.star.sheet.Border enum parameter selects which named ranges are created:\n• If the value is , a named range is created for each column of the cell range with the name taken from the range's first row, and the other cells of that column within the cell range as content.\n• For , the names are taken from the range's last row.\n• If the value is , a named range is created for each row of the cell range with the name taken from the range's first column, and the other cells of that row within the cell range as content.\n• For , the names are taken from the range's last column.\n\nThe method is used to remove a named range. The method writes a list of all the named ranges into the document, starting at the specified cell position.\n\nThe com.sun.star.sheet.NamedRange service accesses an existing named range. The com.sun.star.container.XNamed interface changes the name, and the com.sun.star.sheet.XNamedRange interface changes the other settings. See the description above for the meaning of the individual values.\n\nIf the content of the name is a single cell range reference, the com.sun.star.sheet.XCellRangeReferrer interface is used to access that cell range.\n\nThe following example creates a named range that calculates the sum of the two cells above the position where it is used. This is done by using the relative reference \"G43:G44\" with the reference position G45. Then, the example uses the named range in two formulas.\n\nA label range consists of a label area containing the labels, and a data area containing the data that the labels address. There are label ranges for columns and rows of data, which are kept in two separate collections in the document.\n\nThe com.sun.star.sheet.LabelRanges service contains the document's column label ranges or row label ranges, depending if the or property was used to get it. The com.sun.star.sheet.XLabelRanges interface's method is used to add a new label range, specifying the label area and data area. The method removes a label range.\n\nThe com.sun.star.sheet.LabelRange service represents a single label range and contains the com.sun.star.sheet.XLabelRange interface to modify the label area and data area.\n\nThe following example inserts a column label range with the label area G48:H48 and the data area G49:H50, that is, the content of G48 is used as a label for G49:G50 and the content of H48 is used as a label for H49:H50, as shown in the two formulas the example inserts.\n\nCells, cell ranges and collections of cell ranges are queried for certain cell contents through the service com.sun.star.sheet.SheetRangesQuery. It implements interfaces to query cells and cell ranges with specific properties.\n\nThe methods of the interface com.sun.star.sheet.XCellRangesQuery search for cells with specific contents or properties inside of the given cell range. The methods of the interface com.sun.star.sheet.XFormulaQuery search for cells in the entire spreadsheet that are reference to or are referenced from formula cells in the given range.\n\n\n\n All methods return the interface com.sun.star.sheet.XSheetCellRanges of a cell range collection. Cell range collections are described in the chapter Cell Ranges and Cells Container.\n\nThe queried range is A1:C4 and the passed cell address is B2.\n• : (the row number is of interest) The cells of column A are compared with cell A2, the cells of column B with B2 and so on. The function returns the cell range list B1:B1, B4:B4, C3:C4.\n• : (the column index is of interest) The function compares row 1 with cell B1, row 2 with cell B2 and so on. It returns the cell range list C1:C1, A2:A2, A3:A3, C3:C3.\n\nThe following code queries all cells with text content:\n\nThe cell range interface com.sun.star.util.XReplaceable is derived from com.sun.star.util.XSearchable providing search and replacement of text.\n• The method creates a new descriptor that contains all data for the replace action. It returns the interface com.sun.star.util.XReplaceDescriptor of this descriptor.\n• The method performs a replacement in all cells according to the passed replacedescriptor.\n\nThe following example replaces all occurrences of \"cell\" with \"text\":\n\nA sort descriptor describes all properties of a sort operation. The service com.sun.star.table.TableSortDescriptor2 extends the service com.sun.star.util.SortDescriptor2 with table specific sorting properties, such as:\n\nThe sorting orientation using the boolean .\n\nA sequence of sorting fields using the property that contains a sequence of com.sun.star.table.TableSortField structs.\n\nThe size of the sequence using the property.\n\nThe service com.sun.star.sheet.SheetSortDescriptor2 extends the service com.sun.star.table.TableSortDescriptor2with spreadsheet specific sorting properties, such as:\n\nMoving cell formats with the cells they belong to using the boolean property .The existence of column or row headers using the boolean property .\n\nCopying the sorted data to another position in the document using the boolean property .\n\nPosition where sorted data are to be copied using the property .\n\nIf the property is true, a user-defined sort list is used that specifies an order for the strings it contains. The property selects an entry from the property of the com.sun.star.sheet.GlobalSheetSettings service to find the sort list that is used.\n\nTo sort the contents of a cell range, the method from the com.sun.star.util.XSortable interface is called, passing a sequence of property values with properties from the com.sun.star.sheet.SheetSortDescriptor2 service. The sequence can be constructed from scratch containing the properties that should be set, or the return value of the method can be used and modified. If the cell range is a database range that has a stored sort operation, returns a sequence with the options of this sort operation.\n\nThe fields that the cell range is sorted by are specified in the property as a sequence of com.sun.star.table.TableSortField elements. In the com.sun.star.table.TableSortField struct, the Field member specifies the field number by which to sort, and the boolean member switches between ascending and descending sorting for that field. The boolean specifies whether the case of letters is important when comparing entries. The is used to sort according to the sorting rules of a given locale. For some locales, several different sorting rules exist. In this case, the is used to select one of the sorting rules. The com.sun.star.i18n.Collator service is used to find the possible values for a locale. Currently, it is not possible to have different locales, algorithms and case sensitivity on the different fields.\n\nThe following example sorts the cell range by the second column in ascending order:\n\nThis section discusses the operations that treat the contents of a cell range as database data, organized in rows and columns like a database table. These operations are filtering, sorting, adding of subtotals and importing from an external database. Each of the operations is controlled using a descriptor service. The descriptors can be used in two ways:\n• Performing an operation on a cell range. This is described in the following sections about the individual descriptors.\n• Accessing the settings that are stored with a database range. This is described in the section about database ranges.\n\nA com.sun.star.sheet.SheetFilterDescriptor object is created using the method from the range's com.sun.star.sheet.XSheetFilterable interface to filter data in a cell range. After applying the settings to the descriptor, it is passed to the method.\n\nIf true is passed as a parameter to , the returned descriptor contains default values for all settings. If false is passed and the cell range is a database range that has a stored filter operation, the settings for that filter are used.\n\nThe com.sun.star.sheet.XSheetFilterDescriptor interface is used to set the filter criteria as a sequence of com.sun.star.sheet.TableFilterField elements. The com.sun.star.sheet.TableFilterField struct describes a single condition and contains the following members:\n• has the values or , and specifies how the condition is connected to the previous condition in the sequence. For the first entry, is ignored.\n• is the number of the field that the condition is applied to.\n• is the type of the condition, such as or\n• contains the value that is used in the condition if is true.\n• contains the text that is used in the condition if is false.\n\nAdditionally, the filter descriptor contains a com.sun.star.beans.XPropertySet interface for settings that affect the whole filter operation.\n\nIf the property is , the data that matches the filter criteria is copied to a cell range in the document that starts at the position specified by the property. Otherwise, the rows that do not match the filter criteria are filtered (hidden) in the original cell range.\n\nThe following example filters the range that is in the variable xRange for values greater or equal to 1998 in the second column:\n\nThe com.sun.star.sheet.XSheetFilterableEx interface is used to create a filter descriptor from criteria in a cell range in the same manner as the \"Advanced Filter\" dialog. The com.sun.star.sheet.XSheetFilterableEx interface must be queried from the range that contains the conditions, and the com.sun.star.sheet.XSheetFilterable interface of the range to be filtered must be passed to the call.\n\nThe following example performs the same filter operation as the example before, but reads the filter criteria from a cell range:\n\nA com.sun.star.sheet.SubTotalDescriptor object is created using the method from the range's com.sun.star.sheet.XSubTotalCalculatable interface to create subtotals for a cell range. After applying the settings to the descriptor, it is passed to the method.\n\nThe parameter to the method works in the same manner as the parameter to the method described in the filtering section. If the parameter to the method is , existing subtotal rows are deleted before inserting new ones.\n\nThe method removes the subtotal rows from the cell range without modifying the stored subtotal settings, so that the same subtotals can later be restored.\n\nNew fields are added to the subtotal descriptor using the com.sun.star.sheet.XSubTotalDescriptor interface's method. The parameter selects the column by which values are grouped. The subtotals are inserted at changes of the column's values. The parameter specifies which column subtotal values are calculated. It is a sequence of com.sun.star.sheet.SubTotalColumn entries where each entry contains the column number and the function to be calculated.\n\nTo query or modify the fields in a subtotal descriptor, the com.sun.star.container.XIndexAccess interface is used to access the fields. Each field's com.sun.star.sheet.XSubTotalField interface gets and sets the group and subtotal columns.\n\nThe example below creates subtotals, grouping by the first column and calculating the sum of the third column:\n\nThe com.sun.star.util.XImportable interface imports data from an external data source (database) into spreadsheet cells. The database has to be registered in LibreOffice API, so that it can be selected using its name. The call takes a sequence of property values that select the data to import.\n\nSimilar to the sort descriptor, the import descriptor's sequence of property values can be constructed from scratch, or the return value of the method can be used and modified. The method returns a description of the previously imported data if the cell range is a database range with stored import settings and the parameter is .\n\nThe property selects a database. The selects the kind of object from the database that is imported. It can have the following values:\n• If is , the whole table that is named by is imported.\n• If is , the must be the name of a named query.\n• If is , the is used as a literal SQL command string.\n\nIf a database name is in the variable and a table name in , the following code imports that table from the database:\n\nA database range is a name for a cell range that also stores filtering, sorting, subtotal and import settings, as well as some options.\n\nThe com.sun.star.sheet.SpreadsheetDocument service has a property that is used to get the document's collection of database ranges. A new database range is added using the com.sun.star.sheet.XDatabaseRanges interface's method that requires the name of the new database range, and a com.sun.star.table.CellRangeAddress with the address of the cell range as arguments. The method removes a database range.\n\nThe com.sun.star.container.XNameAccess interface is used to get a single com.sun.star.sheet.DatabaseRange object. Its com.sun.star.sheet.XCellRangeReferrer interface is used to access the cell range that it is pointed to. The com.sun.star.sheet.XDatabaseRange interface retrieves or changes the com.sun.star.table.CellRangeAddress that is named, and gets the stored descriptors.\n\nAll descriptors of a database range are updated when a database operation is carried out on the cell range that the database range points to. The stored filter descriptor and subtotal descriptor can also be modified by changing the objects that are returned by the and methods. Calling the refresh() method carries out the stored operations again.\n\nWhenever a database operation is carried out on a cell range where a database range is not defined, a temporary database range is used to hold the settings. This temporary database range has its property set to and is valid until another database operation is performed on a different cell range. In this case, the temporary database range is modified to refer to the new cell range.\n\nThe following example uses the property to find the temporary database range, and applies a background color to the corresponding cell range. If run directly after the database import example above, this marks the imported data.\n\nThis section explains different ways to link data from external sources into a spreadsheet document. Refer to the Database Import chapter for linking data from a database.\n\nEach sheet in a spreadsheet document can be linked to a sheet from a different document. The spreadsheet document has a collection of all the sheet links to different source documents.\n\nThe interface com.sun.star.sheet.XSheetLinkable is relevant if the current sheet is used as buffer for an external sheet link. The interfaces provides access to the data of the link. A link is established using the com.sun.star.sheet.XSheetLinkable interface's method. The method's parameters are:\n• The source document's URL. When a sheet link is inserted or updated, the source document is loaded from its URL. Unsaved changes in a source document that is open in memory are not included. All URL types that can be used to load files can also be used in links, including HTTP to link to data from a web server.\n• The name of the sheet in the source document from the contents are copied from. If this string is empty, the source document's first sheet is used, regardless of its name.\n• The filter name and options that are used to load the source document. Refer to the Handling Documents chapter. All spreadsheet file filters can be used, so it is possible, for example, to link to a CSV text file.\n• A com.sun.star.sheet.SheetLinkMode enum value that controls how the contents are copied:\n• If the mode is , all cells from the source sheet are copied, including formulas.\n• If the mode is , formulas are replaced by their results in the copy.\n\nThe link mode, source URL and source sheet name can also be queried and changed using the , , , , and methods. Setting the mode to removes the link.\n\nThe com.sun.star.sheet.SheetLinks collection contains an entry for every source document that is used in sheet links. If several sheets are linked to different sheets from the same source document, there is only one entry for them. The name that is used for the com.sun.star.container.XNameAccess interface is the source document's URL.\n\nThe com.sun.star.sheet.SheetLink service changes a link's source URL, filter or filter options through the com.sun.star.beans.XPropertySet interface. The com.sun.star.util.XRefreshable interface is used to update the link. This affects all sheets that are linked to any sheet from the link's source document.\n\nA cell area link is a cell area (range) in a spreadsheet that is linked to a cell area from a different document.\n\nTo insert an area link, the com.sun.star.sheet.XAreaLinks interface's method is used with the following parameters:\n• The position where the link is placed in the document as a com.sun.star.table.CellAddress struct.\n• The source document's URL is used in the same manner as sheet links.\n• A string describing the source range in the source document. This can be the name of a named range or database range, or a direct cell reference, such as \"sheet1.a1:c5\". Note that the WebQuery import filter creates a named range for each HTML table. These names can be used also.\n• The filter name and filter options are used in the same manner as sheet links.\n\nThe method is used to remove a link.\n\nThe com.sun.star.sheet.CellAreaLink service is used to modify or refresh an area link. The com.sun.star.sheet.XAreaLink interface queries and modifies the link's source range and its output range in the document. Note that the output range changes in size after updating if the size of the source range changes.\n\nThe com.sun.star.beans.XPropertySet interface changes the link's source URL, filter name and filter options. Unlike sheet links, these changes affect only one linked area. Additionally, the property is used to set an interval in seconds to periodically update the link. If the value is 0, no automatic updates occur.\n\nThe com.sun.star.util.XRefreshable interface is used to update the link.\n\nA DDE link is created whenever the DDE spreadsheet function is used in a cell formula.\n\nThe com.sun.star.sheet.DDELink service is only used to query the link's parameters using the com.sun.star.sheet.XDDELink interface, and refresh it using the com.sun.star.util.XRefreshable interface. The DDE link's parameters, Application, Topic and Item are determined by the formula that contains the DDE function, therefore it is not possible to change these parameters in the link object.\n\nThe link's name used for the com.sun.star.container.XNameAccess interface consists of the three parameter strings concatenated.\n\nThe com.sun.star.sheet.DataPilotTables and related services create and modify tables in a spreadsheet.\n\nThe method of the interface com.sun.star.sheet.XDataPilotTablesSupplier returns the interface com.sun.star.sheet.XDataPilotTables of the collection of all data pilot tables contained in the spreadsheet.\n\nThe com.sun.star.sheet.DataPilotTables service is accessed by getting the com.sun.star.sheet.XDataPilotTablesSupplier interface from a spreadsheet object and calling the method.\n\nThe first step to creating a new table is to create a new com.sun.star.sheet.DataPilotDescriptor object by calling the com.sun.star.sheet.XDataPilotTables interface's method. The descriptor is then used to describe the DataPilot table's layout and options, and passed to the method of . The other parameters for are the name for the new table, and the position where the table is to be placed on the spreadsheet.\n\nThe com.sun.star.sheet.XDataPilotDescriptor interface offers methods to change the DataPilot table settings:\n• The cell range that contains the source data is set with the method. It is a com.sun.star.table.CellRangeAddress struct.\n• The individual fields are handled using the , , , , and methods. The details are discussed below.\n• The method sets an additional string that is stored with the DataPilot table, but does not influence its results.\n• The method returns a com.sun.star.sheet.SheetFilterDescriptor object that can be used to apply filter criteria to the source data. Refer to the section on data operations for details on how to use a filter descriptor.\n\nThe layout of the DataPilot table is controlled using the com.sun.star.sheet.DataPilotFields service. Each com.sun.star.sheet.DataPilotField object has an property that controls where in the DataPilot table the field is used. The com.sun.star.sheet.DataPilotFieldOrientation enum contains the possible orientations:\n• : The field is not used in the table.\n• : Values from this field are used to determine the columns of the table.\n• : Values from this field are used to determine the rows of the table.\n• : The field is used in the table's \"page\" area, where single values from the field can be selected.\n• : The values from this field are used to calculate the table's data area.\n\nThe property is used to assign a function to the field. For instance, if the field has a orientation, this is the function that is used for calculation of the results. If the field has or orientation, it is the function that is used to calculate subtotals for the values from this field.\n\nThe method returns a collection containing one com.sun.star.sheet.DataPilotField entry for each column of source data, and one additional entry for the \"Data\" column that becomes visible when two or more fields get the orientation. Each source column appears only once, even if it is used with several orientations or functions.\n\nThe , , and methods each return a collection of the fields with the respective orientation. In the case of , a single source column can appear several times if it is used with different functions. The method returns a collection of those fields from the collection that are not in any of the other collections.\n\nThe exact effect of changing a field orientation depends on which field collection the field object was taken from. If the object is from the collection, the field is added to the collection that corresponds to the new Orientation value. If the object is from any of the other collections, the field is removed from the old orientation and added to the new orientation.\n\nThe following example creates a simple DataPilot table with one column, row and data field.\n\nThe com.sun.star.sheet.DataPilotTable service is used to modify an existing DataPilot table. The object for an existing table is available through the com.sun.star.container.XNameAccess interface of the com.sun.star.sheet.DataPilotTables service. It implements the com.sun.star.sheet.XDataPilotDescriptor interface, so that the DataPilot table can be modified in the same manner as the descriptor for a new table in the preceding section. After any change to a DataPilot table's settings, the table is automatically recalculated.\n\nAdditionally, the com.sun.star.sheet.XDataPilotTable interface offers a method that is used to find which range on the spreadsheet the table occupies, and a method that recalculates the table without changing any settings.\n\nThe following example modifies the table from the previous example to contain a second data field using the same source column as the existing data field, but using the \"average\" function instead.\n\nTo remove a DataPilot table from a spreadsheet, call the com.sun.star.sheet.XDataPilotTables interface's method, passing the DataPilot table's name.\n\nThe DataPilot feature in LibreOffice API Calc makes use of an external component that provides the tabular results in the DataPilot table using the field orientations and other settings that are made in the DataPilot dialog or interactively by dragging the fields in the spreadsheet.\n\nSuch a component might, for example, connect to an OLAP server, allowing the use of a DataPilot table to interactively display results from that server.\n\nThe example that is used here provides four dimensions with the same number of members each, and one data dimension that uses these members as digits to form integer numbers. A resulting DataPilot table look similar to the following:\n\nThe example uses the following class to hold the settings that are applied to the DataPilot source:\n\nTo create a DataPilot table using a DataPilot source component, three steps are carried out:\n• The application gets the list of available dimensions (fields) from the component.\n• The application applies the user-specified settings to the component.\n• The application gets the results from the component.\n\nThe same set of objects are used for all three steps. The root object from which the other objects are accessed is the implementation of the com.sun.star.sheet.DataPilotSource service.\n\nThe com.sun.star.sheet.DataPilotSourceDimensions, com.sun.star.sheet.DataPilotSourceHierarchies, com.sun.star.sheet.DataPilotSourceLevels and com.sun.star.sheet.DataPilotSourceMembers services are accessed using their parent object interfaces. That is:\n• com.sun.star.sheet.DataPilotSourceDimensions is the parent object of com.sun.star.sheet.XDimensionsSupplier\n• com.sun.star.sheet.DataPilotSourceHierarchies is the parent object of com.sun.star.sheet.XHierarchiesSupplier\n• com.sun.star.sheet.DataPilotSourceLevels is the parent object of com.sun.star.sheet.XLevelsSupplier\n• com.sun.star.sheet.DataPilotSourceMembers is the parent object of com.sun.star.sheet.XMembersSupplier\n\nAll contain the com.sun.star.container.XNameAccess interface to access their children.\n\nAn implementation of the com.sun.star.sheet.DataPilotSource service must be registered, so that a component can be used as a DataPilot source. If any implementations for the service are present, the External source/interface option in the DataPilot Select Source dialog is enabled. Any of the implementations can then be selected by its implementation name in the External Source dialog, along with four option strings labeled \"Source\", \"Name\", \"User\" and \"Password\". The four options are passed to the component unchanged.\n\nThe option strings are passed to the com.sun.star.lang.XInitialization interface's method if that interface is present. The sequence that is passed to the call contains four strings with the values from the dialog. Note that the \"Password\" string is only saved in LibreOffice API's old binary file format, but not in the XML-based format. If the component needs a password, for example, to connect to a database, it must be able to prompt for that password.\n\nThe example below uses the first of the strings to determine how many members each dimension should have:\n\nThe source object's com.sun.star.beans.XPropertySet interface is used to apply two settings: The and properties control if grand totals for columns or rows should be added. The settings are taken from the DataPilot dialog. The example does not use them.\n\nThe com.sun.star.sheet.XDataPilotResults interface is used to query the results from the component. This includes only the numeric \"data\" part of the table. In the example table above, it would be the 9x3 area of cells that are right-aligned. The call returns a sequence of rows, where each row is a sequence of the results for that row. The com.sun.star.sheet.DataResult struct contains the numeric value in the Value member, and a Flags member contains a combination of the com.sun.star.sheet.DataResultFlags constants:\n• is set if there is a valid result at the entry's position. A result value of zero is different from no result, so this must be set only if the result is not empty.\n• marks a subtotal value that is formatted differently in the DataPilot table output.\n• is set if the result at the entry's position is an error.\n\nIn the example table above, all entries have different numbers, and a value of . The implementation for the example looks like this:\n\nThe com.sun.star.util.XRefreshable interface contains a method that tells the component to discard cached results and recalculate the results the next time they are needed. The and methods are not used by LibreOffice API Calc. The implementation in the example is empty, because the results are always calculated dynamically.\n\nThe com.sun.star.sheet.DataPilotSourceDimensions service contains an entry for each dimension that can be used as column, row or page dimension, for each possible data (measure) dimension, and one for the \"data layout\" dimension that contains the names of the data dimensions.\n\nThe example below initializes a dimension's orientation as DATA for the data dimension, and is otherwise HIDDEN. Thus, when the user creates a new DataPilot table using the example component, the data dimension is already present in the \"Data\" area of the DataPilot dialog.\n\nThe com.sun.star.sheet.DataPilotSourceDimension service contains a com.sun.star.beans.XPropertySet interface that is used for the following properties of a dimension:\n• (read-only) contains the dimension object from which a dimension was cloned, or null if it was not cloned. A description of the com.sun.star.util.XCloneable interface is described below.\n• (read-only) must contain true if the dimension is the \"data layout\" dimension, otherwise false.\n• controls how a dimension is used in the DataPilot table. If it contains the com.sun.star.sheet.DataPilotFieldOrientation enum values or , the dimension is used as a column or row dimension, respectively. If the value is , the dimension is used as data (measure) dimension. The designates a page dimension, but is not currently used in LibreOffice API Calc. If the value is , the dimension is not used.\n• contains the position of the dimension within the orientation. This controls the order of the dimensions. If a dimension's orientation is changed, it is added at the end of the dimensions for that orientation, and the property reflects that position.\n• specifies the function that is used to aggregate data for a data dimension.\n• selects which of the dimension's hierarchies is used in the DataPilot table. See the section on hierarchies below.\n• specifies a list of filter criteria to be applied to the source data before processing. It is currently not used by LibreOffice API Calc.\n\nIn the following example, the method for the dimension only implements the modification of and , using two lists to store the order of column and row dimensions. Page dimensions are not supported in the example.\n\nThe associated method returns the stored values for and . If it is the data layout dimension, then IsDataLayoutDimension is true, and the values default for the remaining properties.\n\nThe dimension's com.sun.star.util.XCloneable interface is required when a dimension is used in multiple positions. The DataPilot dialog allows the use of a column or row dimension additionally as data dimension, and it also allows multiple use of a data dimension by assigning several functions to it. In both cases, additional dimension objects are created from the original one by calling the method. Each clone is given a new name using the com.sun.star.container.XNamed interface's method, then the different settings are applied to the objects. A dimension object that was created using the method must return the original object that it was created from in the property.\n\nThe example does not support multiple uses of a dimension, so it always returns null from the method, and the property is also always .\n\nA single dimension can have several hierarchies, that is, several ways of grouping the elements of the dimension. For example, date values may be grouped:\n• in a hierarchy with the levels \"year\", \"month\" and \"day of month\".\n• in a hierarchy with the levels \"year\", \"week\" and \"day of week\".\n\nThe property of the com.sun.star.sheet.DataPilotSourceDimension service selects which hierarchy of a dimension is used. The property contains an index into the sequence of names that is returned by the dimension's method. LibreOffice API Calc currently has no user interface to select a hierarchy, so it uses the hierarchy that the initial value of the property selects.\n\nThe com.sun.star.sheet.DataPilotSourceHierarchy service serves as a container to access the levels object.\n\nIn the example, each dimension has only one hierarchy, which in turn has one level.\n\nEach level of a hierarchy that is used in a DataPilot table corresponds to a column or row showing its members in the left or upper part of the table. The com.sun.star.sheet.DataPilotSourceLevel service contains a com.sun.star.beans.XPropertySet interface that is used to apply the following settings to a level:\n• The property defines a list of functions that are used to calculate subtotals for each member. If the sequence is empty, no subtotal columns or rows are generated. The com.sun.star.sheet.GeneralFunction enum value is used to select \"automatic\" subtotals, determined by the type of the data.\n• The property controls if result columns or rows are generated for members that have no data.\n\nBoth of these settings can be modified by the user in the \"Data Field\" dialog. The example does not use them.\n\nThe com.sun.star.sheet.XDataPilotMemberResults interface is used to get the result header column that is displayed below the level's name for a row dimension, or the header row for a column dimension. The sequence returned from the call must have the same size as the data result's columns or rows respectively, or be empty. If the sequence is empty, or none of the entries contains the flag, the level is not shown.\n\nThe com.sun.star.sheet.MemberResult struct contains the following members:\n• is the name of the member that is represented by the entry, exactly as returned by the member object's method. It is used to find the member object, for example when the user double-clicks on the cell.\n• is the string that will be displayed in the cell. It may or may not be the same as .\n• indicates the kind of result the entry represents. It can be a combination of the com.sun.star.sheet.MemberResultFlags constants:\n• indicates there is a member that belongs to this entry.\n• marks an entry that corresponds to a subtotal column or row. The should be set.\n• marks an entry that is a continuation of the previous entry. In this case, none of the others are set, and the Name and Caption members are both empty.\n\nIn the example table shown above, the resulting sequence for the \"ones\" level would consist of:\n• an entry containing the name and caption \"1\" and the flag\n• two entries containing only the flag\n• the same repeated for member names \"2\" and \"3\".\n\nThe implementation for the example looks similar to this:\n\nThe com.sun.star.sheet.DataPilotSourceMember service contains two settings that are accessed through the com.sun.star.beans.XPropertySet interface:\n• If the boolean property is , the member and its data are hidden. There is currently no user interface to change this property.\n• The boolean property controls if the results for a member should be detailed in the following level. If a member has this property set to , only a single result column or row is generated for each data dimension. The property can be changed by the user by double-clicking on a result header cell for the member.\n\nThese properties are not used in the example.\n\nThe interface com.sun.star.document.XActionLockable protects this cell from painting or updating during changes. The interface can be used to optimize the performance of complex changes, for instance, inserting or deleting formatted text.\n\nThe interface com.sun.star.util.XProtectable contains methods to protect and unprotect the spreadsheet with a password. Protecting the spreadsheet protects the locked cells only.\n• The methods and to switch the protection on and off. If a wrong password is used to unprotect the spreadsheet, it leads to an exception.\n• The method returns the protection state of the spreadsheet as a boolean value.\n\nThe spreadsheet interface com.sun.star.sheet.XSheetOutline contains all the methods to control the row and column outlines of a spreadsheet:\n\nThe spreadsheet interface com.sun.star.sheet.XSheetAuditing supports the detective functionality of the spreadsheet.\n\nA cell or cell range object contains the properties and . They return the interface com.sun.star.beans.XPropertySet of the validation object com.sun.star.sheet.TableValidation. The objects of both properties are equal, except the representation of formulas. The property uses function names in the current language).\n• Type (type com.sun.star.sheet.ValidationType): Describes the type of data the cells contain. In text cells, it is possible to check the length of the text.\n• ShowInputMessage, InputTitle and InputMessage: These properties describe the message that appears if a cell of the validation area is selected.\n• , , and (type com.sun.star.sheet.ValidationAlertStyle): These properties describe the error message that appear if an invalid value has been entered. If the alert style is STOP, all invalid values are rejected. With the alerts WARNING and INFO, it is possible to keep invalid values. The alert MACRO starts a macro on invalid values. The property has to contain the name of the macro.\n\nThe interface com.sun.star.sheet.XSheetCondition sets the conditions for valid values. The comparison operator, the first and second formula and the base address for relative references in formulas.\n\nThe following example enters values between 0.0 and 5.0 in a cell range. The is the interface com.sun.star.sheet.XSpreadsheet of a spreadsheet.\n\nThe macro started on invalid values has two arguments of type String.\n• The first argument is the exact string typed by the user. It is always a string, even for numbers. It may differ from the value displayed by the cell.\n• The second argument is a string that represents the cell address, example : Sheet3.B17\n\nThe macro should return a Boolean value. If it returns nothing, or if it returns True, the input is accepted and the cell is updated according to the input.\n\nIf the macro decides that the input is incorrect, it may set a value in the cell and then it returns False to reject the input.\n\nThe data consolidation feature calculates results based on several cell ranges.\n\nThe com.sun.star.sheet.XConsolidatable's method returns the interface com.sun.star.sheet.XConsolidationDescriptor of a consolidation descriptor (service com.sun.star.sheet.ConsolidationDescriptor). This descriptor contains all data needed for a consolidation. It is possible to get and set all properties:\n• and : The function for calculation, type com.sun.star.sheet.GeneralFunction.\n• and : A sequence of com.sun.star.table.CellRangeAddress structs with all cell ranges containing the source data.\n• and : A com.sun.star.table.CellAddress containing the first cell of the result cell range.\n• , , and : Determine if the first column or row of each cell range is used to find matching data.\n• and : Determine if the results are linked to the source data (formulas are inserted) or not (only results are inserted).\n\nThe method of the interface com.sun.star.sheet.XConsolidatable performs a consolidation with the passed descriptor.\n\nThe service com.sun.star.table.TableChart represents a chart object. The interface com.sun.star.table.XTableChart provides access to the cell range of the source data and controls the existence of column and row headers.\n\nThe interface com.sun.star.container.XNamed retrieves and changes the name of the chart object.\n\nFor further information about charts, see Charts.\n\nThe service com.sun.star.table.TableCharts represents the collection of all chart objects contained in the table. It implements the interfaces:\n• com.sun.star.table.XTableCharts to create new charts and accessing them by their names.\n• com.sun.star.container.XIndexAccess to access the charts by the insertion index.\n• com.sun.star.container.XEnumerationAccess to create an enumeration of all charts.\n\nThe following example shows how can be a com.sun.star.table.XTableCharts interface of a collection of charts.\n\nA set of scenarios contains different selectable cell contents for one or more cell ranges in a spreadsheet. The data of each scenario in this set is stored in a hidden sheet following the scenario sheet. To change the scenario's data, its hidden sheet has to be modified.\n\nThe com.sun.star.sheet.XScenariosSupplier's method returns the interface com.sun.star.sheet.XScenarios of the scenario set of the spreadsheet. This scenario set is represented by the service com.sun.star.sheet.Scenarios containing spreadsheet objects. It is possible to access the scenarios through their names that is equal to the name of the corresponding spreadsheet, their index, or using an enumeration (represented by the service com.sun.star.sheet.ScenariosEnumeration).\n• The method adds a scenario with the given name that contains the specified cell ranges.\n• The method removes the scenario (the spreadsheet) with the given name.\n\nThe following method shows how to create a scenario:\n\nThe service com.sun.star.sheet.Spreadsheet implements the interface com.sun.star.sheet.XScenario to modify an existing scenario:\n• The method tests if this spreadsheet is used to store scenario data.\n• The methods and retrieves and sets the user comment for this scenario.\n• The method adds new cell ranges to the scenario.\n• The method copies the data of this scenario to the spreadsheet containing the scenario set, that is, it makes the scenario visible.\n\nThe following method shows how to activate a scenario:\n\nA style contains all formatting properties for a specific object. All styles of the same type are contained in a collection named a style family. Each style family has a specific name to identify it in the collection. In LibreOffice API Calc, there are two style families named CellStyles and PageStyles. A cell style can be applied to a cell, a cell range, or all cells of the spreadsheet. A page style can be applied to a spreadsheet itself.\n\nThe collection of style families is available from the spreadsheet document with the com.sun.star.style.XStyleFamiliesSupplier's method . The general handling of styles is described in this section, therefore this chapter focuses on the spreadsheet specific style properties.\n\nCell styles are predefined packages of format settings that are applied in a single step.\n\nA cell style is represented by the service com.sun.star.sheet.TableCellStyle. If a formatting property is applied directly to a cell, it covers the property of the applied cell style. This service does not support the property . The name of the style is set with the interface com.sun.star.container.XNamed.\n\nThe following example creates a new cell style with gray background. The is the com.sun.star.sheet.XSpreadsheetDocument interface of a spreadsheet document.\n\nA page style is represented by the service com.sun.star.sheet.TablePageStyle. It contains the service com.sun.star.style.PageStyle and additional spreadsheet specific page properties.\n\nThe properties , , and return the interface com.sun.star.sheet.XHeaderFooterContent for the headers and footers for the left and right pages. Headers and footers are represented by the service com.sun.star.sheet.HeaderFooterContent. Each header or footer object contains three text objects for the left, middle and right portion of a header or footer. The methods , and return the interface com.sun.star.text.XText of these text portions.\n\nThis section describes the services which handle spreadsheet functions.\n\nThe com.sun.star.sheet.FunctionAccess service calls any spreadsheet function and gets its result without having to insert a formula into a spreadsheet document.\n\nThe service can be instantiated through the service manager. The com.sun.star.sheet.XFunctionAccess interface contains only one method, . The first parameter is the name of the function to call. The name has to be the function's programmatic name.\n• For a built-in function, the English name is always used, regardless of the application's UI language.\n• For an add-in function, the complete internal name that is the add-in component's service name, followed by a dot and the function's name as defined in the interface. For the function in the example from the add-in section, this would be: \" \".\n\nThe second parameter to is a sequence containing the function arguments. The supported types for each argument are described in the com.sun.star.sheet.XFunctionAccess interface description, and are similar to the argument types for add-in functions. The following example passes two arguments to the function, an array of values and a single value.\n\nIn Calc, an argument of the function may accept a range of cells, e.g . When calling a spreadsheet function, a range argument is transmitted as an array with two dimensions. The first corresponds to the row, the second corresponds to the column, indexes are zero-based.\n\nThe services com.sun.star.sheet.FunctionDescriptions and com.sun.star.sheet.FunctionDescription provide help texts about the available spreadsheet cell functions, including add-in functions and their arguments. This is the same information that LibreOffice API Calc displays in the function AutoPilot.\n\nThe com.sun.star.sheet.FunctionDescriptions service is instantiated through the service manager. It provides three different methods to access the information for the different functions:\n• By name through the com.sun.star.container.XNameAccess interface.\n• By index through the com.sun.star.container.XIndexAccess interface.\n• By function identifier through the com.sun.star.sheet.XFunctionDescriptions interface's method. The function identifier is the same used in the com.sun.star.sheet.RecentFunctions service.\n\nThe com.sun.star.sheet.FunctionDescription that is returned by any of these calls is a sequence of com.sun.star.beans.PropertyValue structs. To access one of these properties, loop through the sequence, looking for the desired property's name in the Name member. The Arguments property contains a sequence of com.sun.star.sheet.FunctionArgument structs, one for each argument that the function accepts. The struct contains the name and description of the argument, as well as a boolean flag showing if the argument is optional.\n\nThe Recently Used Functions section below provides an example on how to use the com.sun.star.sheet.FunctionDescriptions service.\n\nThe com.sun.star.sheet.RecentFunctions service provides access to the list of recently used functions of the spreadsheet application, that is displayed in the AutoPilot:Functions and the Function List window for example.\n\nThe service can be instantiated through the service manager. The com.sun.star.sheet.XRecentFunctions interface's method returns a sequence of function identifiers that are used with the com.sun.star.sheet.FunctionDescriptions service. The method changes the list. If the parameter to the call contains more entries than the application handles, only the first entries are used. The maximum size of the list of recently used functions, currently 10, can be queried with the method.\n\nThe following example demonstrates the use of the com.sun.star.sheet.RecentFunctions and com.sun.star.sheet.FunctionDescriptions services.\n\nThe com.sun.star.sheet.GlobalSheetSettings service contains settings that affect the whole spreadsheet application. It can be instantiated through the service manager. The properties are accessed using the com.sun.star.beans.XPropertySet interface.\n\nThe following example gets the list of user-defined sort lists from the settings and displays them:\n\nThe com.sun.star.sheet.SpreadsheetView service is the spreadsheet's extension of the com.sun.star.frame.Controller service and represents a table editing view for a spreadsheet document.\n\nThe view object is the spreadsheet application's controller object as described in the chapter Frame-Controller-Model Paradigm in OpenOffice.org. The com.sun.star.frame.XController, com.sun.star.frame.XDispatchProvider and com.sun.star.ui.XContextMenuInterception interfaces work as described in that chapter.\n\nThe com.sun.star.view.XSelectionSupplier interface queries and modifies the view's selection. The selection in a spreadsheet view can be a com.sun.star.sheet.SheetCell, com.sun.star.sheet.SheetCellRange, com.sun.star.sheet.SheetCellRanges, com.sun.star.drawing.Shape or com.sun.star.drawing.Shapes object.\n\nThe com.sun.star.sheet.XSpreadsheetView interface gives access to the spreadsheet that is displayed in the view. The method returns the active sheet's object, the method switches to a different sheet. The parameter to must be a sheet of the view's document.\n\nThe com.sun.star.sheet.XViewSplitable interface splits a view into two parts or panes, horizontally and vertically. The method splits the view at the specified pixel positions. To remove the split, a position of 0 is passed. The method returns true if the view is split, the and methods return the pixel positions where the view is split. The and methods return the cell column or row that corresponds to the split position, and are used with frozen panes as discussed below.\n\nThe com.sun.star.sheet.XViewFreezable interface is used to freeze a number of columns and rows in the left and upper part of the view. The method freezes the specified number of columns and rows. This also sets the split positions accordingly. The method returns true if the columns or rows are frozen. A view can only have frozen columns or rows, or normal split panes at a time.\n\nIf a view is split or frozen, it has up to four view pane objects that represent the individual parts. These are accessed using the com.sun.star.container.XIndexAccess interface. If a view is not split, it contains only one pane object. The active pane of a spreadsheet view is also accessed using the com.sun.star.sheet.SpreadsheetViewPane service's interfaces directly with the com.sun.star.sheet.SpreadsheetView service that inherits them.\n\nThe com.sun.star.sheet.XRangeSelection interface is explained in the \"Range Selection\" chapter below.\n\nThe following example uses the com.sun.star.sheet.XViewFreezable interface to freeze the first column and the first two rows:\n\nThe com.sun.star.sheet.SpreadsheetViewPane service represents a pane in a view that shows a rectangular area of the document. The exposed area of a view pane always starts at a cell boundary. The com.sun.star.sheet.XViewPane interface's , , and methods query and set the start of the exposed area. The method returns a com.sun.star.table.CellRangeAddress struct describing which cells are shown in the pane. Columns or rows that are only partly visible at the right or lower edge of the view are not included.\n\nThe com.sun.star.sheet.XCellRangeReferrer interface gives direct access to the same cell range of exposed cells that are addressed by the return value.\n\nThe com.sun.star.view.XControlAccess interface's method gives access to a control model's control for the view pane. Refer to the chapter Models and Views for additional information.\n\nThe example below retrieves the cell range that is shown in the second pane. It is the lower left one after freezing both columns and rows, and assigns a cell background:\n\nThe index container provides the available panes in a specific order, depending on how the view has been split.\n\n(*) If the sheet is in right-to-left layout mode, the panes are swapped too (e.g., pane 0 would be the right pane or the top right pane).\n\nThe properties from the com.sun.star.sheet.SpreadsheetViewSettings service are accessed through the com.sun.star.beans.XPropertySet interface controlling the appearance of the view. Most of the properties correspond to settings in the options dialog. The , and properties take values of 0 for \"show\" and 1 for \"hide\", see com.sun.star.sheet.SpreadsheetViewObjectsMode.\n\nThe following example changes the view to display green grid lines:\n\nThe view's com.sun.star.sheet.XRangeSelection interface is used to let a user interactively select a cell range in the view, independently of the view's selection. This is used for dialogs that require a cell reference as input. While the range selection is active, a small dialog is shown, similar to the minimized state of LibreOffice API's own dialogs that allow cell reference input.\n\nBefore the range selection mode is started, a listener is registered using the method. The listener implements the com.sun.star.sheet.XRangeSelectionListener interface. Its or method is called when the selection is finished or aborted. The com.sun.star.sheet.RangeSelectionEvent struct that is passed to the calls contains the selected range in the member. It is a string because the user can type into the minimized dialog during range selection.\n\nIn the following example, the listener implementation stores the result in a member in the method, and notifies the main thread about the completion of the selection in the and methods:\n\nIt is also possible to add another listener using the method. This listener implements the com.sun.star.sheet.XRangeSelectionChangeListener interface, and its method is called during the selection when the selection changes. Using this listener normally is not necessary.\n\nAfter registering the listeners, the range selection mode is started using the method. The parameter to that method is a sequence of property values with properties from the com.sun.star.sheet.RangeSelectionArguments service:\n• specifies an existing selection value that is shown in the dialog and highlighted in the view when the selection mode is started.\n• is the title for the range selection dialog.\n• specifies when the selection mode is ended. If the value is true, selection is ended when the mouse button is released after selecting a cell range. If it is false or not specified, the user presses the Shrink button in the dialog to end selection mode.\n\nThe method returns immediately after starting the range selection mode. This allows it to be called from a dialog's event handler. The method is used to cancel the range selection mode programmatically.\n\nThe following example lets the user pick a range, and then selects that range in the view. Note that the use of wait to wait for the end of the selection is not how a GUI application normally handles the events.\n\nAn add-in component is used to add new functions to the spreadsheet application that can be used in cell formulas, such as the built-in functions. A spreadsheet add-in is a UNO component. The chapter Writing UNO Components describes how to write and deploy a UNO component.\n\nThe functions that the add-in component exports to the spreadsheet application have to be defined in a new interface. The function names in the interface, together with the component's service name, are used internally to identify an add-in function. For a list of the supported types for function arguments and return values, see the com.sun.star.sheet.AddIn service description. An example interface that defines two functions is similar to the following code:\n\nIn addition to this interface, the add-in has to implement the interfaces from the com.sun.star.sheet.AddIn service and the usual interfaces every component has to support.\n\nThe methods from the com.sun.star.sheet.XAddIn interface are used to provide descriptions of the user-visible functions.\n\nThe and methods are used to map between the internal function name, as defined in the interface and the function name as shown to the user of the spreadsheet application. The user-visible name, as well as the function and argument descriptions, can be translated strings for the language which is set using .\n\nThe method sorts each add-in functions into one of the spreadsheet application's function categories. It returns the category's internal (non-translated) name. In addition, the method provides a translated name for the category.\n\nThe , and methods provide descriptions of the function and its arguments that are shown to the user, for example in the function AutoPilot.\n\nThe add-in component has to support two services, the com.sun.star.sheet.AddIn service, and an additional service that is used to identify the set of functions that the add-in supplies. There may be several implementations of the same set of functions. In that case, they all use the same service name, but different implementation names. Therefore, a spreadsheet document that uses the functions can make use of the implementation that is present.\n\nThe com.sun.star.lang.XServiceInfo methods and handle both service names, and the component also has to be registered for both services. In addition, the component has to implement the com.sun.star.lang.XServiceName interface, and in its method return the name of the function-specific service.\n\nOptionally, the component can implement the com.sun.star.sheet.XCompatibilityNames interface, and in the method return a sequence of locale-dependent compatibility names for a function. These names are used by the spreadsheet application when loading or saving Excel files. They should only be present for a function if it is known to be an Excel add-in function with equivalent functionality.\n\nThe sequence of compatibility names for a function may contain several names for a single locale. In that case, all of these names are considered when importing a file. When exporting, the first name is used. If a file is exported in a locale for which no entry is present, the first entry is used. If there is a default locale, the entries for that locale are first in the sequence.\n\nThe user-visible functions have to be implemented as defined in the interface. The spreadsheet application does the necessary conversions to pass the arguments. For example, floating point numbers are rounded if a function has integer arguments. To enable the application to find the functions, it is important that the component implements the com.sun.star.lang.XTypeProvider interface.\n\nThe function from the example interface above can be implemented like this:\n\nIt is also possible to implement functions with results that change over time. Whenever such a result changes, the formulas that use the result are recalculated and the new values are shown in the spreadsheet. This can be used to display data from a real-time data feed in a spreadsheet.\n\nIn its interface, a function with a variable result must be defined with a return type of com.sun.star.sheet.XVolatileResult, such as the function from the example interface above. The function's implementation must return an object that implements the com.sun.star.sheet.VolatileResult service. Subsequent calls to the same function with the same arguments return the same object. An implementation that returns a different result object for every name looks like this:\n\nThe result object has to implement the and methods from the com.sun.star.sheet.XVolatileResult interface to maintain a list of listeners, and notify each of these listeners by calling the com.sun.star.sheet.XResultListener interface's method whenever a new result is available. The com.sun.star.sheet.ResultEvent object that is passed to the call must contain the new result in the Value member. The possible types for the result are the same as for a function's return value if no volatile results are involved.\n\nIf a result is already available when is called, it can be publicized by immediately calling for the new listener. Otherwise, the spreadsheet application displays a \"#N/A\" error value until a result is available.\n\nThe following example shows a simple implementation of a result object. Every time the incrementValue method is called, for example, from a background thread, the result value is incremented and the listeners are notified."
    },
    {
        "link": "https://wiki.documentfoundation.org/Documentation/DevGuide/Text_Documents",
        "document": "In the LibreOffice API, a text document is a document model which is able to handle text contents. A document in our context is a product of work that can be stored and printed to make the result of the work a permanent resource. By model, we mean data that forms the basis of a document and is organized in a manner that allows working with the data independently of their visual representation in a graphical user interface.\n\nIt is important to understand that developers have to work with the model directly, when they want to change it through the LibreOffice API. The model has a controller object which enables developers to manipulate the visual presentation of the document in the user interface. But the controller is not used to change a document. The controller serves two purposes.\n• The controller interacts with the user interface for movement, such as moving the visible text cursor, flipping through screen pages or changing the zoom factor.\n• The second purpose is getting information about the current view status, such as the current selection, the current page, the total page count or the line count. Automatic page or line breaks are not really part of the document data, but rather something that is needed in a certain presentation of the document.\n\nKeeping the difference between model and controller in mind, we will now discuss the parts of a text document model in the LibreOffice API.\n\nThe text document model in the LibreOffice API has five major architectural areas, cf. Illustration 1 below. The five areas are:\n\nThe core of the text document model is the text. It consists of character strings organized in paragraphs and other text contents. The usage of text will be discussed in Working with Text Documents.\n\nThe service manager of the document model creates all text contents for the model, except for the paragraphs. Note that the document service manager is different from the main service manager that is used when connecting to the office. Each document model has its own service manager, so that the services can be adapted to the document when required. Examples for text contents created by the text document service manager are text tables, text fields, drawing shapes, text frames or graphic objects. The service manager is asked for a text content, then you insert it into the text.\n\nAfterwards, the majority of these text contents in a text can be retrieved from the model using text content suppliers. The exception are drawing shapes. They can be found on the , which is discussed below.\n\nAbove the text lies the . It is used for drawing contents. Imagine it as a transparent layer with contents that can affect the text under the layer, for instance by forcing it to wrap around contents on the . However, text can also wrap through contents, so the similarity is limited.\n\nFinally, there are services that allow for document wide styling and structuring of the text. Among them are style family suppliers for paragraphs, characters, pages and numbering patterns, and suppliers for line and outline numbering.\n\nBesides these five architectural areas, there are a number of aspects covering the document character of our model: It is printable, storable, modifiable, it can be refreshed, its contents are able to be searched and replaced and it supplies general information about itself. These aspects are shown at the lower right of the illustration.\n\nFinally, the controller provides access to the graphical user interface for the model and has knowledge about the current view status in the user interface, cf. the upper left of the diagram above.\n\nThe usage of text is discussed in the section Working with Text Documents.\n\nAll following code samples are contained in TextDocuments.java. This file is located in the Samples folder that comes with the resources for the developer's manual.\n\nThe examples use the environment from chapter First Steps, for instance, connecting using the method.\n\nWe want to use a template file containing text fields and bookmarks and insert text into the fields and at the cursor position. The suitable template file TextTemplateWithUserFields.odt lies in the Samples folder, as well. Edit the path to this file below before running the sample.\n\nThe first step is to load the file as a template, so that LibreOffice creates a new, untitled document. As in the chapter First Steps, we have to connect, get the Desktop object, query its interface and call . This time we tell LibreOffice how it should load the file. The key for loading parameters is the sequence of structs passed to . The appropriate name is and we have to set to true.\n\nNow that we are able to load a text document as a template, we will open an existing template file that contains five text fields and a bookmark. We want to demonstrate how to insert text at predefined positions in a document.\n\nText fields and bookmarks are supplied by the appropriate and interfaces. Their fully qualified names are com.sun.star.text.XTextFieldsSupplier and com.sun.star.text.XBookmarksSupplier.\n\nThe provides collections of text fields in our text. We use document variable fields for our purpose, which are com.sun.star.text.textfield.User services. All User fields have a field master that holds the actual content of the variable. Therefore, the collection, as well as the are required for our example. We get the field masters for the five fields by name and set their property. Finally, we refresh the text fields so that they reflect the changes made to the field masters.\n\nThe returns all bookmarks in our document. The collection of bookmarks is a com.sun.star.container.XNameAccess, so that the bookmarks are retrieved by name. Every object in a text supports the interface that has a method . The anchor is the text range an object takes up, so retrieves is a . From the chapter First Steps, a com.sun.star.text.XTextRange allows setting the string of a text range. Our bookmark is a text content and therefore must support . Inserting text at a bookmark position is straightforward: get the anchor of the bookmark and set its string.\n\nAs discussed earlier, the LibreOffice API distinguishes between the model and controller. This difference is mirrored in two different kinds of cursors in the API: model cursors and visible cursors. The visible cursor is also called view cursor.\n\nThe second example assumes that the user has selected a text range in a paragraph and expects something to happen at that cursor position. Setting character and paragraph styles, and retrieving the current page number at the view cursor position is demonstrated in the example. The view cursor will be transformed into a model cursor.\n\nWe want to work with the current document, therefore we cannot use . Rather, we ask the com.sun.star.frame.Desktop service for the current component. Once we have the current component - which is our document model - we go from the model to the controller and get the view cursor.\n\nThe view cursor has properties for the current character and paragraph style. The example uses built-in styles and sets the property to \" \" and to \" \". Furthermore, the view cursor knows about the automatic page breaks. Because we are interested in the current page number, we get it from the view cursor and print it out.\n\nThe model cursor is much more powerful than the view cursor when it comes to possible movements and editing capabilities. We create a model cursor from the view cursor. Two steps are necessary: We ask the view cursor for its Text service, then we have the Text service create a model cursor based on the current cursor position. The model cursor knows where the paragraph ends, so we go there and insert a string.\n\nIf a document in LibreOffice is required, begin by getting a com.sun.star.frame.Desktop service from the service manager. The desktop handles all document components in LibreOffice, among other things. It is discussed thoroughly in the chapter Office Development. Office documents are often called components, because they support the com.sun.star.lang.XComponent interface. An is a UNO object that can be disposed explicitly and broadcast an event to other UNO objects when this happens.\n\nThe Desktop can load new and existing components from a URL. For this purpose it has a com.sun.star.frame.XComponentLoader interface that has one single method to load and instantiate components from a URL into a frame:\n\nThe interesting parameters in our context are the URL that describes which resource should be loaded and the sequence of load arguments. For the target frame pass \" \" and set the search flags to 0. In most cases you will not want to reuse an existing frame.\n\nThe URL can be a URL, a URL, an URL or a URL. Look up the correct URL format in the load URL box in the function bar of LibreOffice. For new Writer documents, a special URL scheme has to be used. The scheme is \"private:\", followed by \"factory\" as hostname. The resource is \"swriter\" for LibreOffice Writer documents. For a new Writer document, use \" \".\n\nThe load arguments are described in com.sun.star.document.MediaDescriptor. The arguments and have properties that are boolean values. If is true, the loader creates a new untitled document from the given URL. If it is false, template files are loaded for editing. If is true, the document is loaded in the background. This is useful when generating a document in the background without letting the user observe; for example, it can be used to generate a document and print it without previewing. Office development describes other available options.\n\nThe section Example: Fields in a Template discusses a complete example about how loading works. The following snippet loads a document in hidden mode:\n\nDocuments are storable through their interface com.sun.star.frame.XStorable. This interface is discussed in detail in Office Development. An implements these operations:\n\nThe method names are evident. The method is the exact representation of File - Save As, that is, it changes the current document location. In contrast, stores a copy to a new location, but leaves the current document URL untouched.\n\nFor exporting purposes, a filter name can be passed to and that triggers an export to other file formats. The property needed for this purpose is the string argument that takes filter names defined in the configuration file:\n\nIn TypeDetection.xml, look for elements, their attribute contains the needed strings for . The proper filter name for StarWriter 5.x is \"StarWriter 5.0\", and the export format \"MS Word 97\" is also popular. This is the element in TypeDetection.xml that describes the MS Word 97 filter:\n\nThe following method stores a document using this filter:\n\nIf an empty array of structs is passed, the native .odt format of LibreOffice is used.\n\nPrinting is a common office functionality. The chapter Office Development provides in-depth information about it. The writer document implements the com.sun.star.view.XPrintable interface for printing. It consists of three methods:\n\nThe following code is used with a given document xDoc to print to the standard printer without any settings:\n\nThere are two groups of properties involved in general printing. The first one is used with and that controls the printer, and the second one is passed to and controls the print job.\n\ncom.sun.star.view.PrinterDescriptor comprises the properties for the printer:\n\ncom.sun.star.view.PrintOptions contains the following possibilities for a print job:\n\nThe following method uses and to print to a special printer, and preselect the pages to print.\n\nThe interface com.sun.star.text.XPagePrintable is used to print more than one document page to a single printed page.\n\nThe first two methods and control the page printing. They use a sequence of com.sun.star.beans.PropertyValues whose possible values are defined in com.sun.star.text.PagePrintSettings:\n\nThe method prints the document according to the previous settings. The argument for the method may contain the as described in the section above (containing the properties , , and ).\n\nThe text model in the illustration below shows that working with text starts with the method at the interface of the document model. It returns a com.sun.star.text.Text service that handles text in LibreOffice.\n\nThe Text service has two mandatory interfaces and no properties:\n\nThe is used to edit a text, and is used to iterate over text. The following sections discuss these aspects of the Text service.\n\nAs previously discussed in the introductory chapter First Steps, the interface com.sun.star.text.XText incorporates three interfaces: , and . When working with an , you work with the string it contains, or you insert and remove contents other than strings, such as tables, text fields, and graphics.\n\nThe is handled as a whole. There are two possibilities if the text is handled as one string. The complete string can be set at once, or strings can be added at the beginning or end of the existing text. These are the appropriate methods used for that purpose:\n\nConsider the following example:\n\nBeginning and end of a text can be determined calling and :\n\nThe following example adds text using the start and end range of a text:\n\nThe above code is not very flexible. To gain flexibility, create a text cursor that is a movable text range. Note that such a text cursor is not visible in the user interface. The creates a cursor that works on the model immediately. The following methods can be used to get as many cursors as required:\n\nThe text cursor travels through the text as a \"collapsed\" text range with identical start and end as a point in text, or it can expand while it moves to contain a target string. This is controlled with the methods of the interface:\n\nIn writer, a text cursor has three interfaces that inherit from : com.sun.star.text.XWordCursor, com.sun.star.text.XSentenceCursor and com.sun.star.text.XParagraphCursor. These interfaces introduce the following additional movements and status checks:\n\nSince inherits from , a cursor is an and incorporates the methods of an :\n\nThe cursor can be told where it is required and the string content can be set later. This does have a drawback. After setting the string, the inserted string is always selected. That means further text can not be added without moving the cursor again. Therefore the most flexible method to insert strings by means of a cursor is the method in . It takes an as the target range that is replaced during insertion, a string to insert, and a boolean parameter that determines if the inserted text should be absorbed by the cursor after it has been inserted. The could be any . The is an , so it is used here:\n\nTo insert text sequentially the parameter must be set to false, so that the collapses at the end of the inserted string after insertion. If is true, the text range selects the new inserted string. The string that was selected by the text range prior to insertion is deleted.\n\nConsider the use of below:\n\nUp to this point, we have discussed paragraphs made up of character strings. Text can also contain other objects besides character strings in paragraphs. They all support the interface com.sun.star.text.XTextContent. In fact, everything in texts must support .\n\nA text content is an object that is attached to a com.sun.star.text.XTextRange. The text range it is attached to is called the anchor of the text content.\n\nAll text contents mentioned below, starting with tables, support the service com.sun.star.text.TextContent. It includes the interface com.sun.star.text.XTextContent that inherits from the interface com.sun.star.lang.XComponent. The services may have the following properties:\n\nThe method of the interface deletes the object from the document. Since a text content is an , com.sun.star.lang.XEventListener can be added or removed with the methods and . These methods are called back when the object is disposed. Other events are not supported.\n\nThe method at the interface returns a text range which reflects the text position where the object is located. This method may return a void object, for example, for text frames that are bound to a page. The method is used in situations where an is required. For instance, placeholder fields (com.sun.star.text.textfield.JumpEdit) can be filled out using their method. Also, you can get a bookmark, retrieve its from and use it to insert a string at the bookmark position.\n\nThe method is an intended method to attach text contents to the document, but it is currently not implemented.\n\nAll text contents - including paragraphs - can be created by the service manager of the document. They are created using the factory methods or at the com.sun.star.lang.XMultiServiceFactory interface of the document.\n\nAll text contents - except for paragraphs - can be inserted into text using the com.sun.star.text.XText method . They can be removed by calling . Starting with the section Tables, there are code samples showing the usage of the document service manager with .\n\nParagraphs cannot be inserted by . Only the interface can insert paragraphs. A paragraph created by the service manager can be used for creating a new paragraph before or after a table, or a text section positioned at the beginning or the end of page where no cursor can insert new paragraphs. Cf. the section Inserting a Paragraph where no Cursor can go below.\n\nWe have used Java escape sequences for paragraph breaks, but this may not be feasible in every language. Moreover, LibreOffice supports a number of control characters that can be used. There are two possibilities: use the method\n\nto insert single control characters as defined in the constants group com.sun.star.text.ControlCharacter, or use the corresponding unicode character from the following list as escape sequence in a string if your language supports it. In Java, Unicode characters in strings can be incorporated using the escape sequence, where H represents a hexadecimal digit\n\nThe section Formatting describes how page breaks are created by setting certain paragraph properties.\n\nThe second interface of com.sun.star.text.Text is . A Text service enumerates all paragraphs in a text and returns objects which support com.sun.star.text.Paragraph. This includes tables, because writer sees tables as specialized paragraphs that support the com.sun.star.text.TextTable service.\n\nParagraphs also have an com.sun.star.container.XEnumerationAccess of their own. They can enumerate every single text portion that they contain. A text portion is a text range containing a uniform piece of information that appears within the text flow. An ordinary paragraph, formatted in a uniform manner and containing nothing but a string, enumerates just a single text portion. In a paragraph that has specially formatted words or other contents, the text portion enumeration returns one com.sun.star.text.TextPortion service for each differently formatted string, and for every other text content. Text portions include the service com.sun.star.text.TextRange and have the properties listed below:\n\nPossible Values for are:\n\nThe text portion enumeration of a paragraph does not supply contents which do belong to the paragraph, but do not fuse together with the text flow. These could be text frames, graphic objects, embedded objects or drawing shapes anchored at the paragraph, characters or as character. The \" \" indicate if there is a content anchored at a character or as a character. If you have a portion type, you know that there are shape objects anchored at a character or as a character.\n\nThis last group of data contained in a text, and in writer support the interface com.sun.star.container.XContentEnumerationAccess. This interface tells which text contents other than the text flow contents exist, and supplies them as an com.sun.star.container.XEnumeration:\n\nThe of the paragraph lists the shape objects anchored at the paragraph while the of a text portion lists the shape objects anchored at a character or as a character.\n\nThe enumeration access to text through paragraphs and text portions is used if every single paragraph in a text needs to be touched. The application area for this enumeration are export filters, that uses this enumeration to go over the whole document, writing out the paragraphs to the target file. The following code snippet centers all paragraphs in a text.\n\nInserting a Paragraph where no Cursor can go\n\nThe service com.sun.star.text.Text has an optional interface com.sun.star.text.XRelativeTextContentInsert which is available in Text services in Writer. The intention of this interface is to insert paragraphs in positions where no cursor or text portion can be located to use the method. These situation occurs when text sections or text tables are at the start or end of the document, or if they follow each other directly.\n\nThe only supported text contents are com.sun.star.text.Paragraph as new content, and com.sun.star.text.TextSection and com.sun.star.text.TextTable as successor or predecessor.\n\nIt is possible to sort text or the content of text tables.\n\nSorting of text is done by the text cursor that supports com.sun.star.util.XSortable. It contains two methods:\n\nThe method returns a sequence of com.sun.star.beans.PropertyValue that provides the elements as described in the service com.sun.star.text.TextSortDescriptor\n\nThe method sorts the text that is selected by the cursor, by the given parameters.\n\nSorting of tables happens directly at the table service, which supports . Sorting is a common feature of LibreOffice and it is described in detail in Office Development.\n\nThe text cursor in writer supports the interface com.sun.star.document.XDocumentInsertable which has a single method to insert a file at the current cursor position:\n\nPass an URL and an empty sequence of structs. However, load properties could be used as described in com.sun.star.document.MediaDescriptor.\n\nThe auto text function can be used to organize reusable text passages. They allow storing text, including the formatting and all other contents in a text block collection to apply them later. Three services deal with auto text in LibreOffice:\n\nThe current implementation forces the user to close the instance when they are changed, so that the changes can take effect. However, the new is not written to disk until the destructor of the instance inside the writer is called. When this example has finished executing, the file on disk correctly contains the complete text \" This string was inserted using the API!\n\n\n\nSome text for a new autotext block \", but there is no way in Java to call the destructor. It is not clear when the garbage collector deletes the object and writes the modifications to disk.\n\nA multitude of character, paragraph and other properties are available for text in LibreOffice. However, the objects implemented in the writer do not provide properties that support com.sun.star.beans.XPropertyChangeListener or com.sun.star.beans.XVetoableChangeListener yet.\n\nCharacter and paragraph properties are available in the following services:\n\nThe character properties are described in the services com.sun.star.style.CharacterProperties, com.sun.star.style.CharacterPropertiesAsian and com.sun.star.style.CharacterPropertiesComplex.\n\ncom.sun.star.style.CharacterProperties describes common character properties for all language zones and character properties in Western text. The following table provides possible values.\n\ncom.sun.star.style.CharacterPropertiesAsian describes properties used in Asian text. All of these properties have a counterpart in . They apply as soon as a text is recognized as Asian by the employed Unicode character subset.\n\nThe complex properties com.sun.star.style.CharacterPropertiesComplex refer to the same character settings as in , only they have the suffix \"Complex\" instead of \"Asian\".\n\ncom.sun.star.style.ParagraphPropertiesAsian describes some further properties used in Asian text.\n\nObjects supporting these properties support com.sun.star.beans.XPropertySet, as well. To change the properties, use the method .\n\nThe same procedure is used for all properties. The more complex properties are described here.\n\nIf a change of the page style is required the paragraph property has to be set using an existing page style name. This forces a page break at the cursor position and the new inserted page uses the requested page style. The property has to be set to start with a new page count. If inserting an additional paragraph should be avoided, the cursor must be placed at the beginning of the first paragraph before inserting it.\n\nIf a page break (or a column break) without a change in the used style is required, the property is set using the values of com.sun.star.style.BreakType:\n\nThe property is used to include a paragraph in the line numbering. The setting of the line numbering options is done using the property set provided by the com.sun.star.text.XLineNumberingProperties interface implemented at the text document model.\n\nTo create a hyperlink these properties are set at the current cursor position or the current com.sun.star.text.Paragraph service.\n\nHyperlink properties are not specified for paragraphs in the API reference.\n\nSome properties are connected with each other. There may be side effects or dependencies between the following properties:\n\nThe text model cursor allows for free navigation over the model by character, words, sentences, or paragraphs. There can be several model cursors at the same time. Model cursor creation, movement and usage is discussed in the section Word Processing . The text model cursors are com.sun.star.text.TextCursor services that are based on the interface com.sun.star.text.XTextCursor, which is based on com.sun.star.text.XTextRange.\n\nThe text view cursor enables the user to travel over the document in the view by character, line, screen page and document page. There is only one text view cursor. Certain information about the current layout, such as the number of lines and page number must be retrieved at the view cursor. The chapter Text Document Controller below discusses the view cursor in detail. The text view cursor is a com.sun.star.text.TextViewCursor service that includes com.sun.star.text.TextLayoutCursor.\n\nThe text document model has suppliers that yield all text contents in a document as collections. To find a particular text content, such as bookmarks or text fields, use the appropriate supplier interface. The following supplier interfaces are available at the model:\n\nYou can work with text content directly, set properties and use its interfaces, or find out where it is and do an action at the text content location in the text. To find out where a text content is located call the method at the interface com.sun.star.text.XTextContent, which every text content must support.\n\nIn addition, text contents located at the current text cursor position or the content where the cursor is currently located are provided in the of the cursor. The corresponding cursor properties are:\n\nThe writer model supports the interface com.sun.star.util.XReplaceable that inherits from the interface com.sun.star.util.XSearchable for searching and replacing in text. It contains the following methods:\n\nTo search or replace text, first create a descriptor service using or . You receive a service that supports the interface com.sun.star.util.XPropertyReplace with methods to describe what you are searching for, what you want to replace with and what attributes you are looking for. It is described in detail below.\n\nPass in this descriptor to the methods , , or .\n\nThe methods and return a com.sun.star.uno.XInterface pointing to an object that contains the found item. If the search is not successful, a null reference to an is returned, that is, if you try to query other interfaces from it, null is returned. The method returns a com.sun.star.container.XIndexAccess containing one or more com.sun.star.uno.XInterface pointing to the found text ranges or if they failed an empty interface. The method returns the number of replaced occurrences only.\n\nThe interface com.sun.star.util.XPropertyReplace is required to describe your search. It is a powerful interface and inherits from , and .\n\nThe target of your search is described by a string containing a search text or a style name using . Correspondingly, provide the text string or style name that should replace the found occurrence of the search target to the using . Refine the search mode through the properties included in the service com.sun.star.util.SearchDescriptor:\n\nIn , the methods to get and set search attributes, and replace attributes allow the attributes to search for to be defined and the attributes to insert instead of the existing attributes. All of these methods expect a sequence of com.sun.star.beans.PropertyValue structs.\n\nAny properties contained in the services com.sun.star.style.CharacterProperties, com.sun.star.style.CharacterPropertiesAsian and com.sun.star.style.ParagraphProperties can be used for an attribute search. If is used, LibreOffice checks if an attribute exists, whereas finds specific attribute values. If only searching to see if an attribute exists at all, it is sufficient to pass a struct with the Name field set to the name of the required attribute.\n\nThe following code snippet replaces all occurrences of the text \"random numbers\" by the bold text \"replaced numbers\" in a given document .\n\nLibreOffice text tables consist of rows, rows consist of one or more cells, and cells can contain text or rows. There is no logical concept of columns. From the API's perspective, a table acts as if it had columns, as long as there are no split or merged cells.\n\nCells in a row are counted alphabetically starting from A, where rows are counted numerically, starting from 1. This results in a cell-row addressing pattern, where the cell letter is denoted first (A-Zff.), followed by the row number (1ff.):\n\nWhen a cell is split vertically, the new cell gets the letter of the former right-hand-side neighbor cell and the former neighbor cell gets the next letter in the alphabet. Consider the example table below: B2 was split vertically, a new cell C2 is inserted and the former C2 became D2, D2 became E2, and so forth.\n\nWhen cells are merged vertically, the resulting cell counts as one cell and gets one letter. The neighbor cell to the right gets the subsequent letter. B4 in the table below shows this. The former B4 and C4 have been merged, so the former D4 could become C4. The cell name D4 is no longer required.\n\nAs shown, there is no way to address a column C anymore, for the cells C1 to C4 no longer form a column:\n\nWhen cells are split horizontally, LibreOffice simply inserts as many rows into the cell as required.\n\nIn our example table, we continued by splitting C2 first horizontally and then vertically so that there is a range of four cells.\n\nThe writer treats the content of C2 as two rows and starts counting cells within rows. To address the new cells, it extends the original cell name C2 by new addresses following the cell-row pattern. The upper row gets row number 1 and the first cell in the row gets cell number 1, resulting in the cell address C2.1.1, where the latter 1 indicates the row and the former 1 indicates the first cell in the row. The right neighbor of C2.1.1 is C2.2.1. The subaddress 2.1 means the second cell in the first row.\n\nThe cell-row pattern is used for all further subaddressing as the cells are split and merged. The cell addresses can change radically depending on the table structure generated by LibreOffice. The next table shows what happens when E2 is merged with D3. The table is reorganized, so that it has three rows instead of four. The second row contains two cells, A2 and B2 (sic!). The cell A2 has two rows, as shown from the cell subaddresses: The upper row consists of four cells, namely A2.1.1 through A2.4.1, whereas the lower row consists of the three cells A2.1.2 through A2.3.2.\n\nThe cell range C2.1.1:C2.2.2 that was formerly contained in cell C2 is now in cell A2.3.1 that denotes the third cell in the first row of A2. Within the address of the cell A2.3.1, LibreOffice has started a new subaddressing level using the cell-row pattern again.\n\nCell addresses can become complicated. The cell address can be looked up in the user interface. Set the GUI text cursor in the desired cell and observe the lower-right corner of the status bar in the text document.\n\nRemember that there are only \"columns\" in a text table, as long as there are no split or merged cells.\n\nText tables support the service com.sun.star.text.TextTable, which includes the service com.sun.star.text.TextContent:\n\nThe service com.sun.star.text.TextTable offers access to table cells in two different ways::\n• Yields named table cells which are organized in rows and columns.\n• Provides a table cursor to travel through the table cells and alter the cell properties.\n\nThese aspects are reflected in the interface com.sun.star.text.XTextTable which inherits from com.sun.star.text.XTextContent. It can be seen as a rectangular range of cells defined by numeric column indexes, as described by com.sun.star.table.XCellRange. This aspect makes text tables compatible with spreadsheet tables. Also, text tables have a name, can be sorted, charts can be based on them, and predefined formats can be applied to the tables. The latter aspects are covered by the interfaces com.sun.star.container.XNamed, com.sun.star.util.XSortable, com.sun.star.chart.XChartDataArray and com.sun.star.table.XAutoFormattable.\n\nThe usage of these interfaces and the properties of the TextTable service are discussed below.\n\nNamed Table Cells in Rows, Columns and the Table Cursor\n\nThe interface introduces the following methods to initialize a table, work with table cells, rows and columns, and create a table cursor:\n\nThe method sets the number of rows and columns prior to inserting the table into the text. Non-initialized tables default to two rows and two columns.\n\nThe method returns a sequence of strings containing the names of all cells in the table in A1[.1.1] notation.\n\nThe method expects a cell name in A1[.1.1] notation, and returns a cell object that is a com.sun.star.table.XCell and a com.sun.star.text.XText. The advantage of is its ability to retrieve cells even in tables with split or merged cells.\n\nThe method returns a table row container supporting com.sun.star.table.XTableRows that is a com.sun.star.container.XIndexAccess, and introduces the following methods to insert an arbitrary number of table rows below a given row index position and remove rows from a certain position:\n\nThe following table shows which methods work under which circumstances.\n\nEvery row returned by supports the service com.sun.star.text.TextTableRow, that is, it is a com.sun.star.beans.XPropertySet which features these properties:\n\nThe method is similar to , but restrictions apply. It returns a table column container supporting com.sun.star.table.XTableColumns that is a com.sun.star.container.XIndexAccess and introduces the following methods to insert an arbitrary number of table columns behind a given column index position and remove columns from a certain position:\n\nThe following table shows which methods work in which situation.\n\nThe method creates a text table cursor that can select a cell range in the table, merge or split cells, and read and write cell properties of the selected cell range. It is a com.sun.star.text.TextTableCursor service with the interfaces com.sun.star.text.XTextTableCursor and com.sun.star.beans.XPropertySet.\n\nThese are the methods contained in :\n\nTraveling through the table calls the cursor's , , , , , , and methods, passing true to select cells on the way.\n\nOnce a cell range is selected, apply character and paragraph properties to the cells in the range as defined in the services com.sun.star.style.CharacterProperties, com.sun.star.style.CharacterPropertiesAsian, com.sun.star.style.CharacterPropertiesComplex and com.sun.star.style.ParagraphProperties. Moreover, split and merge cells using the text table cursor. An example is provided below.\n\nThe interface com.sun.star.table.XCellRange provides access to cells using their row and column index as position, and to create sub ranges of tables:\n\nThe method returns a cell object supporting the interfaces com.sun.star.table.XCell and com.sun.star.text.XText. To find the cell the name is internally created from the position using the naming scheme described above and returns this cell if it exists. Calling in the table at the beginning of this chapter returns the cell \"B2\" .\n\nThe methods and return a range object that is described below. The name of the range is created with the top-left cell and bottom-right cell of the table separated by a colon as in . Both methods fail when the structure of the table contains merged or split cells.\n\nEach table has a unique name that can be read and written using the interface com.sun.star.container.XNamed.\n\nA text table is a XNamed. Its method returns a sequence of com.sun.star.beans.PropertyValue structs that provides the elements as described in the service com.sun.star.text.TextSortDescriptor. The method sorts the table content by the given parameters.\n\nThe interface com.sun.star.chart.XChartDataArray is used to connect a table or a range inside of a table to a chart. It reads and writes the values of a range, and sets the column and row labels. The inherited interface com.sun.star.chart.XChartData enables the chart to connect listeners to be notified when changes to the values of a table are made. For details about charting, refer to chapter Charts.\n\nThe interface com.sun.star.table.XAutoFormattable provides in its method a method to format the table using a predefined table format. To access the available auto formats, the service com.sun.star.sheet.TableAutoFormats has to be accessed. For details, refer to chapter Table Auto Formats.\n\nThe text table supports the properties described in the service com.sun.star.text.TextTable:\n\nTo create and insert a new text table, a five-step procedure must be followed:\n• Get the service manager of the text document, querying the document's factory interface com.sun.star.lang.XMultiServiceFactory.\n• Order a new text table from the factory by its service name \" \", using the factory method .\n• From the object received, query the com.sun.star.text.XTextTable interface that inherits from com.sun.star.text.XTextContent.\n• If necessary, initialize the table with the number of rows and columns. For this purpose, offers the method.\n• Insert the table into the text using the method at its com.sun.star.text.XText interface. The method expects an to insert. Since inherits from , pass the interface retrieved previously.\n\nYou are now ready to get cells, fill in text, values and formulas and set the table and cell properties as needed.\n\nIn the following code sample, there is a small helper function to put random numbers between -1000 and 1000 into the table to demonstrate formulas:\n\nThe following helper function inserts a string into a cell known by its name and sets its text color to white:\n\nUsing the above helper functions, create a text table and insert it into the text document.\n\nThe next sample inserts auto text entries into a table, splitting cells during its course.\n\nTo access the tables contained in a text document, the text document model supports the interface com.sun.star.text.XTextTablesSupplier with one single method . It returns a com.sun.star.text.TextTables service, which is a named and indexed collection, that is, tables are retrieved using com.sun.star.container.XNameAccess or com.sun.star.container.XIndexAccess.\n\nThe following snippet iterates over the text tables in a given text document object and colors them green.\n\nText fields are text contents that add a second level of information to text ranges. Usually their appearance fuses together with the surrounding text, but actually the presented text comes from elsewhere. Field commands can insert the current date, page number, total page numbers, a cross-reference to another area of text, the content of certain database fields, and many variables, such as fields with changing values, into the document. There are some fields that contain their own data, where others get the data from an attached field master.\n\nFields are created using the com.sun.star.lang.XMultiServiceFactory of the model before inserting them using . The following text field services are available:\n\nAll fields support the interfaces com.sun.star.text.XTextField, com.sun.star.util.XUpdatable, com.sun.star.text.XDependentTextField and the service com.sun.star.text.TextContent.\n\nThe method of the interface com.sun.star.text.XTextField returns the textual representation of the result of the text field operation, such as a date, time, variable value, or the command, such as CHAPTER, TIME (fixed) depending on the boolean parameter.\n\nThe method of the interface com.sun.star.util.XUpdatable affects only the following field types:\n• Date and time fields are set to the current date and time.\n• The fields that show parts of the user data set for LibreOffice, such as the Name, City, Phone No. and the Author fields that are set to the current values.\n• The fields are updated with the current name of the file.\n• The fields are updated with the current document info of the document.\n\nAll other fields ignore calls to .\n\nSome of these fields need a field master that provides the data that appears in the field. This applies to the field types , , , and . The interface com.sun.star.text.XDependentTextField handles these pairs of FieldMasters and TextFields. The method must be called prior to inserting the field into the document. The method does not work unless the dependent field is inserted into the document.\n\nTo create a valid text field master, the instance has to be created using the com.sun.star.lang.XMultiServiceFactory interface of the model with the appropriate service name:\n\nThe property Name has to be set after the field instance is created, except for the field master type where the properties , , and are set instead of the property.\n\nTo access existing text fields and field masters, use the interface com.sun.star.text.XTextFieldsSupplier that is implemented at the text document model.\n\nIts method returns a com.sun.star.text.TextFields container which is a com.sun.star.container.XEnumerationAccess and can be refreshed through the method in its interface com.sun.star.util.XRefreshable.\n\nIts method returns a com.sun.star.text.TextFieldMasters container holding the text field masters of the document. This container provides a com.sun.star.container.XNameAccess interface. All field masters, except for are named by the service name followed by the name of the field master. The field masters create their names by appending the , and to the service name.\n\nConsider the following examples for this naming convention:\n\nEach text field master has a property that contains its name in the format of the related container.\n\nSome text field masters are always available if they are not deleted. These are the masters with the names Text, Illustration, Table and Drawing. They are predefined as number range field masters used for captions of text frames, graphics, text tables and drawings. Note that these predefined names are internal names that are usually not used at the user interface.\n\nThe following methods show how to create and insert text fields.\n\nA Bookmark is a text content that marks a position inside of a paragraph or a text selection that supports the com.sun.star.text.TextContent service. To search for a bookmark, the text document model implements the interface com.sun.star.text.XBookmarksSupplier that supplies a collection of the bookmarks. The collection supports the service com.sun.star.text.Bookmarks which consists of com.sun.star.container.XNameAccess and com.sun.star.container.XIndexAccess.\n\nThe bookmark name can be read and changed through its (com.sun.star.container.XNamed) interface.\n\nTo insert, remove or change text, or attributes starting from the position of a bookmark, retrieve its com.sun.star.text.XTextRange by calling at its com.sun.star.text.XTextContent interface. Then use or at the , or pass this to methods expecting a text range, such as createTextCursorByRange(), insertString() or insertTextContent().\n\n\n\n Use the method of the com.sun.star.lang.XMultiServiceFactory interface provided by the text document model to insert an new bookmark into the document. The service name is \" \". Then use the bookmark's com.sun.star.container.XNamed interface and call . If no name is set, LibreOffice makes up generic names, such as Bookmark1 and Bookmark2. Similarly, if a name is used that is not unique, writer automatically appends a number to the bookmark name. The bookmark object obtained from can only be inserted once.\n\nIndexes are text contents that pull together information that is dispersed over the document. They can contain chapter headings, locations of key words, locations of arbitrary index marks and locations of text objects, such as illustrations, objects or tables. In addition, LibreOffice features a bibliographical index.\n\nThe following index services are available in LibreOffice:\n\nTo access the indexes of a document, the text document model supports the interface com.sun.star.text.XDocumentIndexesSupplier with a single method . The returned object is a com.sun.star.text.DocumentIndexes service supporting the interfaces com.sun.star.container.XIndexAccess and com.sun.star.container.XNameAccess.\n\nAll indexes support the services com.sun.star.text.TextContent and com.sun.star.text.BaseIndex that include the interface com.sun.star.text.XDocumentIndex. This interface is used to access the service name of the index and update the current content of an index:\n\nFurthermore, indexes have properties and a name, and support:\n\nAn index is usually composed of two text sections which are provided as properties. The provided property includes the complete index and the property contains the title if there is one. They enable the index to have background or column attributes independent of the surrounding page format valid at the index position. In addition, there may be different settings for the content and the heading of the index. However, these text sections are not part of the document's text section container.\n\nThe indexes are structured by levels. The number of levels depends on the index type. The content index has ten levels, corresponding to the number of available chapter numbering levels, which is ten. Alphabetical indexes have four levels, one of which is used to insert separators, that are usually characters that show the alphabet. The bibliography has 22 levels, according to the number of available bibliographical type entries (com.sun.star.text.BibliographyDataType). All other index types only have one level.\n\nFor all levels, define a separate structure that is provided by the property of the service com.sun.star.text.BaseIndex. contains the various levels as a com.sun.star.container.XIndexReplace object. Each level is a sequence of com.sun.star.beans.PropertyValues which are defined in the service com.sun.star.text.DocumentIndexLevelFormat. Although provides a level for the heading, changing that level is not supported.\n\nEach com.sun.star.beans.PropertyValues sequence has to contain at least one com.sun.star.beans.PropertyValue with the name . This struct must contain one of the following string values in its Value member variable:\n\nAn example for such a sequence of struct could be constructed like this:\n\nThe following table explains the sequence members which can be present, in addition to the member, as mentioned above.\n\nIndex marks are text contents whose contents and positions are collected and displayed in indexes.\n\nTo access all index marks that are related to an index, use the property of the index. It contains a sequence of com.sun.star.text.XDocumentIndexMark interfaces.\n\nAll index marks support the service com.sun.star.text.BaseIndexMark that includes com.sun.star.text.TextContent. Also, they all implement the interfaces com.sun.star.text.XDocumentIndexMark and com.sun.star.beans.XPropertySet.\n\nThe inherits from and defines two methods:\n• com.sun.star.text.ContentIndexMark for entries in tables of content which are independent from chapter headings.\n\nAn index mark can be set at a point in text or it can mark a portion of a paragraph, usually a word. It cannot contain text across paragraph breaks. If the index mark does not include text, the property has to be set, otherwise there will be no string to insert into the index.\n\nA reference mark is a text content that is used as a target for com.sun.star.text.textfield.GetReference text fields. These text fields show the contents of reference marks in a text document and allows the user to jump to the reference mark. Reference marks support the com.sun.star.text.XTextContent and com.sun.star.container.XNamed interfaces. They can be accessed by using the text document's com.sun.star.text.XReferenceMarksSupplier interface that defines a single method .\n\nThe returned collection is a com.sun.star.text.ReferenceMarks service which has a com.sun.star.container.XNameAccess and a com.sun.star.container.XIndexAccess interface.\n\nThe name of a reference mark can be used in a com.sun.star.text.textfield.GetReference text field to refer to the position of the reference mark.\n\nFootnotes and endnotes are text contents that provide background information for the reader that appears in page footers or at the end of a document.\n\nFootnotes and endnotes implement the service com.sun.star.text.Footnote that includes com.sun.star.text.TextContent. The service has the interfaces com.sun.star.text.XText and com.sun.star.text.XFootnote that inherit from com.sun.star.text.XTextContent. The introduces the following methods:\n\nThe service defines a property that is used for import and export, and contains an internal sequential number.\n\nThe interface com.sun.star.text.XText which is provided by the com.sun.star.text.Footnote service accesses the text object in the footnote area where the footnote text is located. It is not allowed to insert text tables into this text object.\n\nWhile footnotes can be placed at the end of a page or the end of a document, endnotes always appear at the end of a document. Endnote numbering is separate from footnote numbering. Footnotes are accessed using the com.sun.star.text.XFootnotesSupplier interface of the text document through the method . Endnotes are accessed similarly by calling at the text document's com.sun.star.text.XEndnotesSupplier interface. Both of these methods return a com.sun.star.container.XIndexAccess.\n\nA label is set for a footnote or endnote to determine if automatic footnote numbering is used. If no label is set (= empty string), the footnote is labeled automatically. There are footnote and endnote settings that specify how the automatic labeling is formatted. These settings are obtained from the document model using the interfaces com.sun.star.text.XFootnotesSupplier and com.sun.star.text.XEndnotesSupplier. The corresponding methods are and . The object received is a com.sun.star.beans.XPropertySet and has the properties described in com.sun.star.text.FootnoteSettings:\n\nThe Footnotes service applies to footnotes and endnotes.\n\nThe following sample works with footnotes\n\nShape objects are text contents that act independently of the ordinary text flow. The surrounding text may wrap around them. Shape objects can lie in front or behind text, and be anchored to paragraphs or characters in the text. Anchoring allows the shape objects to follow the paragraphs and characters while the user is writing. Currently, there are two different kinds of shape objects in LibreOffice, base frames and drawing shapes.\n\nThe first group are shape objects that are com.sun.star.text.BaseFrames. The three services com.sun.star.text.TextFrame, com.sun.star.text.TextGraphicObject and com.sun.star.text.TextEmbeddedObject are all based on the service com.sun.star.text.BaseFrame. The contain an independent text area that can be positioned freely over ordinary text. The are bitmaps or vector oriented images in a format supported by LibreOffice internally. The are areas containing a document type other than the document they are embedded in, such as charts, formulas, internal LibreOffice documents (Calc/Draw/Impress), or OLE objects.\n\nThe , and in a text are supplied by their corresponding supplier interfaces at the document model:\n\nThese interfaces all have one single get method that supplies the respective Shape objects collection:\n\nThe method returns a com.sun.star.text.TextFrames collection, returns a com.sun.star.text.TextEmbeddedObjects collection and yields a com.sun.star.text.TextGraphicObjects collection. All of these collections support com.sun.star.container.XIndexAccess and com.sun.star.container.XNameAccess. The collection may (optional) support the com.sun.star.container.XContainer interface to broadcast an event when an is added to the collection. However, the current implementation of the collection does not support this.\n\nThe service com.sun.star.text.BaseFrame defines the common properties and interfaces of text frames, graphic objects and embedded objects. It includes the services com.sun.star.text.BaseFrameProperties and com.sun.star.text.TextContent, and defines the following interfaces.\n\nThe position and size of a is covered by com.sun.star.drawing.XShape. All objects share a majority of the core implementation of drawing objects. Therefore, they have a position and size on the .\n\nThe name of a is set and read through com.sun.star.container.XNamed. The names of the frame objects have to be unique for text frames, graphic objects and embedded objects, respectively.\n\nThe com.sun.star.beans.XPropertySet has to be present, because many aspects of are controlled through properties.\n\nThe interface com.sun.star.document.XEventsSupplier is not a part of the service, but is available in text frames, graphic objects and embedded objects. This interface provides access to the event macros that may be attached to the object in the GUI.\n\nThe properties of are those of the service com.sun.star.text.TextContent, as well there is a number of frame properties defined in the service com.sun.star.text.BaseFrameProperties:\n\nThe second group of shape objects are the varied drawing shapes that can be inserted into text, such as rectangles and ellipses. They are based on com.sun.star.text.Shape. The service includes Shape, but adds a number of properties related to shapes in text (cf. Drawing Shapes below). In addition, drawing shapes support the interface com.sun.star.text.XTextContent so that they can be inserted into an XText.\n\nThere are no specialized supplier interfaces for drawing shapes. All the drawing shapes on the object are supplied by the document model's com.sun.star.drawing.XDrawPageSupplier and its single method:\n\nA text frame is a com.sun.star.text.TextFrame service consisting of com.sun.star.text.BaseFrame and the interface com.sun.star.text.XTextFrame.The is based on com.sun.star.text.XTextContent and introduces one method to provide the of the frame:\n\nThe properties of com.sun.star.text.TextFrame that add to the are the following:\n\nAdditionally, text frames are com.sun.star.text.Text services and support all of its interfaces, except for com.sun.star.text.XTextRangeMover.\n\nText frames can be connected to a chain, that is, the text of the first text frame flows into the next chain element if it does not fit. The properties and are provided to take advantage of this feature. They contain the names of the predecessor and successor of a frame. All frames have to be empty to chain frames, except for the first member of the chain.\n\nThe effect at the API is that the visible text content of the chain members is only accessible at the first frame in the chain. The content of the following chain members is not shown when chained before their content is set.\n\nThe API reference does not know the properties above. Instead, it specifies a com.sun.star.text.ChainedTextFrame with an interface, but this is not yet supported by text frames.\n\nThe following example uses text frames:\n\nA is a com.sun.star.text.BaseFrame providing the interface com.sun.star.document.XEmbeddedObjectSupplier. The only method of this interface,\n\nprovides access to the model of the embedded document. That way, an embedded LibreOffice spreadsheet, drawing, chart or a formula document can be used in a text over its document model.\n\nAn embedded object is inserted by using the document's factory to create an instance of the the service com.sun.star.text.TextEmbeddedObject. The type of object is determined by setting the string property CLSID to an appropriate value before inserting the object as text content in the document.\n\nA is a and does not provide any additional interfaces, compared with com.sun.star.text.BaseFrame. However, it introduces a number of properties that allow manipulating of a graphic object. They are described in the service com.sun.star.text.TextGraphicObject:\n\nWriter uses the same drawing engine as LibreOffice Impress and LibreOffice Draw. The limitations are that in Writer only one drawpage can exist and 3D objects are not supported. All drawing shapes support these properties:\n\nIn addition to the properties of the shapes natively supported by the drawing engine, the writer shape adds some properties, so that they are usable for text documents. These are defined in the service com.sun.star.text.Shape:\n\nThe chapter Drawing Documents and Presentation Documents describes how to use shapes and the interface of the draw page.\n\nRedlines are text portions created in the user interface by switching on Edit ▸ Changes ▸ Record. Redlines in a document are accessed through the com.sun.star.document.XRedlinesSupplier interface at the document model. A collection of redlines as com.sun.star.beans.XPropertySet objects are received that can be accessed as com.sun.star.container.XIndexAccess or as com.sun.star.container.XEnumerationAccess. Their properties are described in com.sun.star.text.RedlinePortion.\n\nIf a change is recorded, but not visible because the option Edit ▸ Changes ▸ Show has been switched off, redline text is contained in the property , which is a com.sun.star.text.XText.\n\nRuby text is a character layout attribute used in Asian languages. Ruby text appears above or below text in left to right writing, and left to right of text in top to bottom writing. For examples, cf. https://www.w3.org/TR/1999/WD-ruby-19990322/.\n\nRuby text is created using the appropriate character properties from the service com.sun.star.style.CharacterProperties wherever this service is supported. However, the Asian languages support must be switched on in Tools - Options - LanguageSettings - Languages.\n\nThere is no convenient supplier interface for ruby text at the model at this time. However, the controller has an interface com.sun.star.text.XRubySelection that provides access to rubies contained in the current selection.\n\nTo find ruby text in the model, enumerate all text portions in all paragraphs and check if the property contains the string \" \" to find ruby text. When there is ruby text, access the property of the text portion that contains ruby text as a string.\n\nStyles distinguish sections in a document that are commonly formatted and separates this information from the actual formatting. This way it is possible to unify the appearance of a document, and adjust the formatting of a document by altering a style, instead of local format settings after the document has been completed. Styles are packages of attributes that can be applied to text or text contents in a single step.\n\nThe following style families are available in LibreOffice.\n\nThe text document model implements the interface com.sun.star.style.XStyleFamiliesSupplier to access these styles. Its method returns a collection of com.sun.star.style.StyleFamilies with a com.sun.star.container.XNameAccess interface. The com.sun.star.container.XNameAccess interface retrieves the style families by the names listed above. The service supports a com.sun.star.container.XIndexAccess.\n\nFrom the , retrieve one of the families listed above by name or index. A collection of styles are received which is a com.sun.star.style.StyleFamily service, providing access to the single styles through an com.sun.star.container.XNameContainer or an com.sun.star.container.XIndexAccess.\n\nEach style is a com.sun.star.style.Style and supports the interface com.sun.star.style.XStyle that inherits from com.sun.star.container.XNamed. The contains:\n\nThe office comes with a set of default styles. These styles use programmatic names on the API level. The method in always throws an exception if called at such styles. The same applies to changing the property Category. At the user interface localized names are used. The user interface names are provided through the property .\n\nNote that page and numbering styles are not hierarchical and cannot have parent styles. The method always returns an empty string, and the method throws a com.sun.star.uno.RuntimeException when called at a default style.\n\nThe method determines whether a style is defined by a user or is a built-in style. A built-in style cannot be deleted. Additionally the built-in styles have two different names: a true object name and an alias that is displayed at the user interface. This is not usually visible in an English LibreOffice version, except for the default styles that are named \"Standard\" as programmatic name and \"Default\" in the user interface.\n\nThe Style service defines the following properties which are shared by all styles:\n\nTo determine the user interface name, each style has a string property that contains the name that is used at the user interface. It is not allowed to use a of a style as a name of a user-defined style of the same style family.\n\nThe built-in styles are not created actually as long as they are not used in the document. The property checks for this. It is necessary, for file export purposes, to detect styles which do not need to be exported.\n\nConditional paragraph styles are handled by the property ParaStyleConditions. The sequence consists of pairs where the name part (the first part) of the pair defines the context where the style (the second part, a string that denotes a style name or an empty string) should be applied to. Assigning an empty string to the style name will disable the conditional style for that context.\n\nThe collection can load styles. For this purpose, the interface com.sun.star.style.XStyleLoader is available at the collection. It consists of two methods:\n\nThe method enables the document to import styles from other documents. The expected sequence of structs can contain the following properties:\n\nThe method returns a sequence of these structs, set to their default values.\n\nCharacter styles support all properties defined in the services com.sun.star.style.CharacterProperties and com.sun.star.style.CharacterPropertiesAsian.\n\nThey are created using the com.sun.star.lang.XMultiServiceFactory interface of the text document model using the service name \" \".\n\nThe default style that is shown in the user interface and accessible through the API is not a style, but a tool to remove applied character styles. Therefore, its properties cannot be changed.\n\nSet the property at an object including the service com.sun.star.style.CharacterProperties to set its character style.\n\nParagraph styles support all properties defined in the services com.sun.star.style.ParagraphProperties and com.sun.star.style.ParagraphPropertiesAsian.\n\nThey are created using the com.sun.star.lang.XMultiServiceFactory interface of the text document model using the service name \" \".\n\nAdditionally, there is a service com.sun.star.style.ConditionalParagraphStyle which creates conditional paragraph styles. Conditional styles are paragraph styles that have different effects, depending on the context. There is currently no support of the condition properties at the API.\n\nSet the property at an object, including the service com.sun.star.style.ParagraphProperties to set its paragraph style.\n\nFrame styles support all properties defined in the services com.sun.star.text.BaseFrameProperties.\n\nThe frame styles are applied to text frames, graphic objects and embedded objects.\n\nThey are created using the com.sun.star.lang.XMultiServiceFactory interface of the text document model using the service name \" \".\n\nSet the property at com.sun.star.text.BaseFrame objects to set their frame style.\n\nPage styles are controlled via properties. The page related properties are defined in the services com.sun.star.style.PageStyle\n\nThey are created using the com.sun.star.lang.XMultiServiceFactory interface of the text document model using the service name \" \".\n\nAs mentioned above, page styles are not hierarchical. The section Page Layout discusses page styles.\n\nThe is set at the current text cursor position by setting the property to an existing page style name.This will insert a new page that uses the new page style. If no new page should be inserted, the cursor has to be at the beginning of the first paragraph.\n\nNumbering styles support all properties defined in the services com.sun.star.text.NumberingStyle.\n\nThey are created using the com.sun.star.lang.XMultiServiceFactory interface of the text document model using the service name \" \".\n\nThe structure of the numbering rules is described in section Line Numbering and Outline Numbering.\n\nThe name of the numbering style is set in the property of paragraphs (set through the of a ) or a paragraph style to apply the numbering to the paragraphs.\n\nThe following example demonstrates the use of paragraph styles:\n\nText documents offer general information about the document through their com.sun.star.document.XDocumentPropertiesSupplier interface. The DocumentProperties is a common LibreOffice feature and is discussed in Office Development.\n\nThe XDocumentPropertiesSupplier has one single method:\n\nwhich returns a com.sun.star.document.DocumentProperties service, offering metadata and statistical information about the document that is available through File - Properties in the GUI.\n\nThe model implements a com.sun.star.beans.XPropertySet that provides properties concerning character formatting and general settings.\n\nThe properties for character attributes are , , , , and their Asian counterparts , , , .\n\nThe com.sun.star.lang.XMultiServiceFactory implemented at the model provides the service com.sun.star.text.Defaults. Use this service to find default values to set paragraph and character properties of the document to default.\n\nAnother set of properties can be created by the service name com.sun.star.document.Settings that contains a number of additional settings.\n\nLibreOffice provides automatic numbering for texts. For instance, paragraphs can be numbered or listed with bullets in a hierarchical manner, chapter headings can be numbered and lines can be counted and numbered.\n\ncom.sun.star.text.NumberingRulesThe key for paragraph numbering is the paragraph property . This property is provided by paragraphs and numbering styles and is a member of com.sun.star.style.ParagraphProperties.\n\nA similar object controls outline numbering and is returned from the method:\n\nat the com.sun.star.text.XChapterNumberingSupplier interface that is implemented at the document model.\n\nThese objects provide an interface com.sun.star.container.XIndexReplace. Each element of the container represents a numbering level. The writer document provides ten numbering levels. The highest level is zero. Each level of the container consists of a sequence of com.sun.star.beans.PropertyValue.\n\nThe two related objects differ in some of properties they provide.\n\nBoth of them provide the following properties:\n\nOnly paragraphs have the following properties in their property:\n\nOnly the chapter numbering rules provide the following property:\n\nThe following is an example for the service:\n\nThe text document model supports the interface com.sun.star.text.XLineNumberingProperties. The provided object has the properties described in the service com.sun.star.text.LineNumberingProperties. It is used in conjunction with the paragraph properties and .\n\nThe text document model provides access to the number formatter through aggregation, that is, it provides the interface com.sun.star.util.XNumberFormatsSupplier seamlessly.\n\nThe number formatter is used to format numerical values. For details, refer to Number Formats.\n\nIn text, text fields with numeric content and table cells provide a property that contains a long value that refers to a number format.\n\nA text section is a range of complete paragraphs that can have its own format settings and source location, separate from the surrounding text. Text sections can be nested in a hierarchical structure.\n\nFor example, a section is formatted to have text columns that different column settings in a text on a paragraph by paragraph basis. The content of a section can be linked through file links or over a DDE connection.\n\nThe text sections support the service com.sun.star.text.TextSection. To access the sections, the text document model implements the interface com.sun.star.text.XTextSectionsSupplier that provides an interface com.sun.star.container.XNameAccess. The returned objects support the interface com.sun.star.container.XIndexAccess, as well.\n\nMaster documents implement the structure of sub documents using linked text sections.\n\nAn example demonstrating the creation, insertion and linking of text sections:\n\nA page layout in LibreOffice is always a page style. A page can not be hard formatted. To change the current page layout, retrieve the current page style from the text cursor property and get this page style from the .\n\nChanges of the page layout happen through the properties described in com.sun.star.style.PageProperties. Refer to the API reference for details on all the possible properties, including the header and footer texts which are part of these properties.\n\nAs headers or footers are connected to a page style, the text objects are provided as properties of the style. Depending on the setting of the page layout, there is one header and footer text object per style available or there are two, a left and right header, and footer text:\n\nThe page layout of a page style can be equal on left and right pages, mirrored, or separate for right and left pages. This is controlled by the property that expects values from the enum com.sun.star.style.PageStyleLayout. As long as left and right pages are equal, and are identical. The same applies to the footers.\n\nThe text objects in headers and footers are only available if headers or footers are switched on, using the properties and .\n\nDrawing objects cannot be inserted into headers or footers.\n\nText frames, text sections and page styles can be formatted to have columns. The width of columns is relative since the absolute width of the object is unknown in the model. The layout formatting is responsible for calculating the actual widths of the columns.\n\nColumns are applied using the property . It expects a com.sun.star.text.TextColumns service that has to be created by the document factory. The interface com.sun.star.text.XTextColumns refines the characteristics of the text columns before applying the created service to the property .\n\nConsider the following example to see how to work with text columns:\n\nThe text columns property consists of com.sun.star.text.TextColumn structs. The Width elements of all structs in the sequence make up a sum, that is provided by the method of the interface. To determine the metric width of an actual column, the reference value and the columns width element have to be calculated using the metric width of the object (page, text frame, text section) and a rule of three, for example:\n\nThe column margins ( , and elements of the struct) are inside the column. Their values do not influence the column width. They just limit the space available for the column content.\n\nThe default column setting in LibreOffice creates columns with equal margins at inner columns, and no left margin at the leftmost column and no right margin at the rightmost column. Therefore, the relative width of the first and last column is smaller than those of the inner columns. This causes a limitation of this property: Setting the text columns with equal column content widths and equal margins is only possible when the width of the object (text frame, text section) can be determined. Unfortunately this is impossible when the width of the object depends on its environment itself.\n\nThe interface com.sun.star.document.XLinkTargetSupplier of the document model provides all elements of the document that can be used as link targets. These targets can be used for load URLs and sets the selection to a certain position object inside of a document. An example of a URL containing a link target is \"file:///c:/documents/document1|bookmarkname\".\n\nThis interface is used from the hyperlink dialog to detect the links available inside of a document.\n\nThe interface com.sun.star.container.XNameAccess returned by the method provides access to an array of target types. These types are:\n\nThe names of the elements depend on the installed language.\n\nEach returned object supports the interfaces com.sun.star.beans.XPropertySet and interface com.sun.star.container.XNameAccess. The property set provides the properties (string) and (com.sun.star.awt.XBitmap). Each of these objects provides an array of targets of the relating type. Each target returned supports the interface com.sun.star.beans.XPropertySet and the property (string).\n\nThe name of the objects is the bookmark to be added to the document URL, for example, \"Table1|table\". The contains the name of the object, e.g. \" \".\n\nThe text document model knows its controller and it can lock the controller to block user interaction. The appropriate methods in the model's com.sun.star.frame.XModel interface are:\n\nThe controller returned by shares the following interfaces with all other document controllers in LibreOffice:\n\nDocument controllers are explained in the Office Development.\n\nThe writer controller implementation supports the interface com.sun.star.view.XSelectionSupplier that returns the object that is currently selected in the user interface.\n\nIts method returns an any that may contain the following object depending on the selection:\n\nIn StarOffice 6.0 and OpenOffice.org 1.0 you can only influence the zoom factor by setting the to and adjusting explicitly. The other zoom types have no effect.\n\nThe text controller has a visible cursor that is used in the GUI. Get the com.sun.star.text.TextViewCursor by calling at the com.sun.star.text.XTextViewCursorSupplier interface of the current text document controller.\n\nIt supports the following cursor capabilities that depend on having the necessary information about the current layout state, therefore it is not supported by the model cursor.\n\nCurrently, the view cursor does not have the capabilities as the document cursor does. Therefore, it is necessary to create a document cursor to have access to the full text cursor functionality. The method is used:"
    },
    {
        "link": "https://stackoverflow.com/questions/49640951/libreoffice-writer-macro-change-font-size",
        "document": "This question was posted to help solve this Ask Ubuntu 350 point bounty that ends today. I would rather someone in Stack Overflow post an answer and get the bounty than see it go unrewarded and the OP not getting a working solution.\n\nI have this macro pieced together from three sources (sorry kind of ugly at this stage). The total project is to change everything not 18 pt to 12 pt. Then change 18 pt to 22 pt. Then set Heading 1 to 28 pt. I've spent hours trying to get this simple thing done by recording macros which just leaves one dissappointed.\n\nHere is the recorded macro so far:\n\nto change 10 point to 12 point. It runs without error but doesn't change a thing:\n\nIt crashes at end with this message:"
    },
    {
        "link": "https://api.libreoffice.org/examples/CLI/CSharp/Spreadsheet/SpreadsheetSample.cs",
        "document": ""
    },
    {
        "link": "https://stackoverflow.com/questions/72773932/libreoffice-calc-macro-set-two-different-types-of-fonts-within-the-same-cell",
        "document": "Good morning everyone, I would like to build a Uno Basic macro that allows us to set the formatting one cell in such a way as to have the content first formatted with one character and then subsequently with a different character. I would need it to be able to produce labels to then print with the Writer using serial printing.\n\nThis is my code:\n\nThis below the image of what I would like to be able to do:\n\nI have already written some macroes that generate the header in the correct cells and that generate the relative Bar Code (Code128) correctly. But since an inscription is made with a font while the BarCode uses another one, now I would like to write everything in a final cell and then serialize the print. You can help me ? I thank."
    }
]