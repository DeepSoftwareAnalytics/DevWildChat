[
    {
        "link": "https://autohotkey.com/boards/viewtopic.php?t=44484",
        "document": "There are absolutely no windows settings which alter the behaviour of the mouse in mouse-aim games.Windows \"Sensitivity\" is utterly unrelated, that is to do with mouse cursor.The ONLY thing that will alter it is changing the DPI setting in the software that came with your mouse. If your mouse did not come with any software, then it is technically impossible to move a fraction of a unit.Secondly,IS NOT sleeping for 2ms. Minimum granularity of sleep on a windows system is 10-15ms.If you are sending a move of 1 @ 10ms and it is twice as much movement as you want, you have 3 options:1) Halve the sensitivity setting IN GAME (NOT in windows)2) Double the amount of time you wait between sending updates (ie sleep 20 instead of sleep 10).This will result in less smooth movement.3) Halve the DPI setting in the mouse's software (if it exists)BTW, if you really do want to send moves at a faster rate than 10ms, you need a more accurate timing system such as QPX, or my MicroTimer library"
    },
    {
        "link": "https://reddit.com/r/AutoHotkey/comments/10h0bss/how_is_dll_call_mouse_movement_used",
        "document": "Hi folks, I'm struggling to find documentation on DLL calling mouse movement. I found an example script online that does this:\n\nThe above moves the mouse to the right 500 units. Inverting it moves it left. How do I move it up and down, though? That much I am confused about."
    },
    {
        "link": "https://autohotkey.com/docs/v2/lib/DllCall.htm",
        "document": "The DLL or EXE file name followed by a backslash and the name of the function. For example: (the file extension \".dll\" is the default when omitted). If an absolute path isn't specified, DllFile is assumed to be in the system's PATH or A_WorkingDir. Note that DllCall expects a path with backslashes (\\). Forward slashes (/) are not supported. DllFile may be omitted when calling a function that resides in User32.dll, Kernel32.dll, ComCtl32.dll, or Gdi32.dll. For example, produces the same result as . If no function can be found by the given name, a \"W\" (Unicode) suffix is automatically appended. For example, is the same as . Performance can be dramatically improved when making repeated calls to a DLL by loading it beforehand. This parameter may also consist solely of an integer, which is interpreted as the address of the function to call. Sources of such addresses include COM and CallbackCreate. If this parameter is an object, the value of the object's property is used. If no such property exists, a PropertyError is thrown. Each of these pairs represents a single parameter to be passed to the function. The number of pairs is unlimited. For Type, see the types table below. For Arg, specify the value to be passed to the function. The word Cdecl is normally omitted because most functions use the standard calling convention rather than the \"C\" calling convention (functions such as wsprintf that accept a varying number of arguments are one exception to this). Note that most object-oriented C++ functions use the thiscall convention, which is not supported. If present, the word Cdecl should be listed before the return type (if any). Separate each word from the next with a space or tab. For example: . Since a separate \"C\" calling convention does not exist in 64-bit code, Cdecl may be specified but has no effect on 64-bit builds of AutoHotkey. ReturnType: If the function returns a 32-bit signed integer (Int), BOOL, or nothing at all, ReturnType may be omitted. Otherwise, specify one of the argument types from the types table below. The asterisk suffix is also supported.\n\nDllCall returns the actual value returned by Function. If Function is of a type that does not return a value, the result is an undefined value of the specified return type (integer by default).\n\nA string such as or , or a VarRef such as . If the called function modifies the string and the argument is a naked variable or VarRef, its contents will be updated. For example, the following call would convert the contents of MyVar to uppercase: . If the function is designed to store a string longer than the parameter's input value (or if the parameter is for output only), the recommended approach is to create a Buffer, use the Ptr type to pass it, and use StrGet to retrieve the string after the function returns, as in the wsprintf example. Otherwise, ensure that the variable is large enough before calling the function. This can be achieved by calling , where 123 is the number of 16-bit units (loosely referred to as characters) that MyVar must be able to hold. If the variable is not null-terminated upon return, an error message is shown and the program exits as it is likely that memory has been corrupted via buffer overrun. This would typically indicate that the variable's capacity was insufficient. A Str argument must not be an expression that evaluates to a number (such as ). If it is, the function is not called and a TypeError is thrown. The rarely-used Str* arg type passes the address of a temporary variable containing the address of the string. If the function writes a new address into the temporary variable, the new string is copied into the script's variable, if a VarRef was passed. This can be used with functions that expect something like \"TCHAR **\" or \"LPTSTR *\". However, if the function allocates memory and expects the caller to free it (such as by calling CoTaskMemFree), the arg type must be used instead. Note: When passing a string to a function, be aware what type of string the function expects. Since AutoHotkey uses UTF-16 natively, WStr (wide character string) is equivalent to Str. AStr causes the input value to be automatically converted to ANSI. Since the temporary memory used for this conversion is only large enough for the converted input string, any value written to it by the function is discarded. To receive an ANSI string as an output parameter, follow this example: The rarely-used AStr* arg type is also supported and behaves similarly to the Str* type, except that any new string is converted from ANSI to the native format, UTF-16. See Binary Compatibility for equivalent Win32 types and other details. A 64-bit integer, whose range is -9223372036854775808 (-0x8000000000000000) to 9223372036854775807 (0x7FFFFFFFFFFFFFFF). A 32-bit integer (the most common integer type), whose range is -2147483648 (-0x80000000) to 2147483647 (0x7FFFFFFF). An Int is sometimes called a \"Long\". An Int should also be used for each BOOL argument expected by a function (a BOOL value should be either 1 or 0). An unsigned Int (UInt) is also used quite frequently, such as for DWORD. A 16-bit integer, whose range is -32768 (-0x8000) to 32767 (0x7FFF). An unsigned Short (UShort) can be used with functions that expect a WORD. An 8-bit integer, whose range is -128 (-0x80) to 127 (0x7F). An unsigned character (UChar) can be used with functions that expect a BYTE. A 32-bit floating point number, which provides 6 digits of precision. A 64-bit floating point number, which provides 15 digits of precision. A pointer-sized integer, equivalent to Int or Int64 depending on whether the exe running the script is 32-bit or 64-bit. Ptr should be used for pointers to arrays or structures (such as RECT* or LPPOINT) and almost all handles (such as HWND, HBRUSH or HBITMAP). If the parameter is a pointer to a single numeric value such as LPDWORD or int*, generally the * or P suffix should be used instead of \"Ptr\". If an object is passed to a Ptr parameter, the value of the object's property is used. If no such property exists, a PropertyError is thrown. Typically the object would be a Buffer. If an object is passed to a Ptr* parameter, the value of the object's property is retrieved before the call and the address of a temporary variable containing this value is passed to the function. After the function returns, the new value is assigned back to the object's property. Ptr can also be used with the * or P suffix; it should be used with functions that output a pointer via LPVOID* or similar. UPtr is also valid, with the following limitations:\n• It is only unsigned in 32-bit builds as AutoHotkey does not support unsigned 64-bit integers. Note: To pass a NULL handle or pointer, pass the integer 0. Append an asterisk (with optional preceding space) to any of the above types to cause the address of the argument to be passed rather than the value itself (the called function must be designed to accept it). Since the value of such an argument might be modified by the function, whenever a VarRef is passed as the argument, the variable's contents will be updated after the function returns. For example, the following call would pass the contents of MyVar to MyFunction by address, but would also update MyVar to reflect any changes made to it by MyFunction: . In general, an asterisk is used whenever a function has an argument type or return type that starts with \"LP\". The most common example is LPDWORD, which is a pointer to a DWORD. Since a DWORD is an unsigned 32-bit integer, use \"UInt*\" or \"UIntP\" to represent LPDWORD. An asterisk should not be used for string types such as LPTSTR, pointers to structures such as LPRECT, or arrays; for these, \"Str\" or \"Ptr\" should be used, depending on whether you pass a string, address or Buffer. Note: \"Char*\" is not the same as \"Str\" because \"Char*\" passes the address of an 8-bit number, whereas \"Str\" passes the address of a series of characters, which may be either 16-bit (Unicode) or 8-bit (for \"AStr\"), depending on the version of AutoHotkey. Similarly, \"UInt*\" passes the address of a 32-bit number, so should not be used if the function expects an array of values or a structure larger than 32 bits. Since variables in AutoHotkey have no fixed type, the address passed to the function points to temporary memory rather than the caller's variable. Prepend the letter U to any of the integer types above to interpret it as an unsigned integer (UInt64, UInt, UShort, and UChar). Strictly speaking, this is necessary only for return values and asterisk variables because it does not matter whether an argument passed by value is unsigned or signed (except for Int64). If a negative integer is specified for an unsigned argument, the integer wraps around into the unsigned domain. For example, when -1 is sent as a UInt, it would become 0xFFFFFFFF. Unsigned 64-bit integers produced by a function are not supported. Therefore, to work with numbers greater or equal to 0x8000000000000000, omit the U prefix and interpret any negative values received from the function as large integers. For example, a function that yields -1 as an Int64 is really yielding 0xFFFFFFFFFFFFFFFF if it is designed to yield a UInt64. A 32-bit integer. This is generally used with COM functions and is valid only as a return type without any prefix or suffix. Error values (as defined by the FAILED macro) are never returned; instead, an OSError is thrown. Therefore, the return value is a success code in the range 0 to 2147483647. HRESULT is the default return type for ComCall.\n\nDllCall throws an Error under any of the following conditions:\n• OSError: The HRESULT return type was used and the function returned an error value (as defined by the FAILED macro). contains the hexadecimal error code.\n• TypeError: The [DllFile\\]Function parameter is a floating point number. A string or positive integer is required.\n• ValueError: The return type or one of the specified arg types is invalid.\n• TypeError: An argument was passed a value of an unexpected type. For instance, an expression that evaluates to a number was passed to a string (str) argument, a non-numeric string was passed to a numeric argument, or an object was passed to an argument not of type Ptr.\n• Error: The specified DllFile could not be accessed or loaded. If no explicit path was specified for DllFile, the file must exist in the system's PATH or A_WorkingDir. This error might also occur if the user lacks permission to access the file, or if AutoHotkey is 32-bit and the DLL is 64-bit or vice versa.\n• Error: The specified function could not be found inside the DLL.\n• Error: The function was called but it aborted with a fatal exception. contains the exception code. For example, 0xC0000005 means \"access violation\". In such cases, the thread is aborted (if try is not used), but any asterisk variables are still updated. An example of a fatal exception is dereferencing an invalid pointer such as NULL (0). Since a Cdecl function never produces the error described in the next paragraph, it may generate an exception when too few arguments are passed to it.\n• Error: The function was called but was passed too many or too few arguments. contains the number of bytes by which the argument list was incorrect. If it is positive, too many arguments (or arguments that were too large) were passed, or the call requires CDecl. If it is negative, too few arguments were passed. This situation should be corrected to ensure reliable operation of the function. The presence of this error may also indicate that an exception occurred. Note that due to the x64 calling convention, 64-bit builds never raise this error.\n\nIn spite of the built-in exception handling, it is still possible to crash a script with DllCall. This can happen when a function does not directly generate an exception but yields something inappropriate, such as a bad pointer or a string that is not terminated. This might not be the function's fault if the script passed it an unsuitable value such as a bad pointer or a \"str\" with insufficient capacity. A script can also crash when it specifies an inappropriate argument type or return type, such as claiming that an ordinary integer yielded by a function is an asterisk variable or str.\n\nThe built-in variable A_LastError contains the result of the operating system's GetLastError() function.\n\nWhen making repeated calls to a DLL, performance can be dramatically improved by loading it explicitly (this is not necessary for a standard DLL such as User32 because it is always resident). This practice avoids the need for DllCall to internally call LoadLibrary and FreeLibrary each time. For example:\n\nEven faster performance can be achieved by looking up the function's address beforehand. For example:\n\nIf DllCall's first parameter is a literal string such as and the DLL containing the function is ordinarily loaded before the script starts, or has been successfully loaded with #DllLoad, the string is automatically resolved to a function address. This built-in optimization is more effective than the example shown above.\n\nFinally, when passing a string-variable to a function that will not change the length of the string, performance is improved by passing the variable by address (e.g. ) rather than as a \"str\" (especially when the string is very long). The following example converts a string to uppercase: .\n\nA structure is a collection of members (fields) stored adjacently in memory. Most members tend to be integers.\n\nFunctions that accept the address of a structure (or a memory-block array) can be called by allocating memory by some means and passing the memory address to the function. The Buffer object is recommended for this purpose. The following steps are generally used:\n\n1) Call to allocate a buffer to hold the structure's data. Replace with a number that is at least as large as the size of the structure, in bytes. Specifying zero as the last parameter is optional; it initializes all members to be binary zero, which is typically used to avoid calling NumPut as often in the next step.\n\n2) If the target function uses the values initially in the structure, call to initialize any members that should be non-zero. Replace with the integer to be put into the target member (or specify to store the address of a string). Replace with the offset of the target member (see step #4 for description of \"offset\"). Replace with the appropriate type, such as if the member is a pointer or handle.\n\n3) Call the target function, passing MyStruct as a Ptr argument. For example, . The function will examine and/or change some of the members. DllCall automatically uses the address of the buffer, which is normally retrieved by using .\n\n4) Use to retrieve any desired integers from the structure. Replace with the offset of the target member in the structure. The first member is always at offset 0. The second member is at offset 0 plus the size of the first member (typically 4). Members beyond the second are at the offset of the previous member plus the size of the previous member. Most members -- such as DWORD, Int, and other types of 32-bit integers -- are 4 bytes in size. Replace with the appropriate type or omit it if the member is a pointer or handle.\n\nWhen a variable's string address (e.g. ) is passed to a function and that function alters the length of the variable's contents, subsequent uses of the variable may behave incorrectly. To fix this, do one of the following: 1) Pass MyVar as a \"Str\" argument rather than as a Ptr/address; 2) Call to update the variable's internally-stored length after calling DllCall.\n\nAny binary zero stored in a variable by a function may act as a terminator, preventing all data to the right of the zero from being accessed or changed by most built-in functions. However, such data can be manipulated by retrieving the string's address with StrPtr and passing it to other functions, such as NumPut, NumGet, StrGet, StrPut, and DllCall itself.\n\nA function that returns the address of one of the strings that was passed into it might return an identical string in a different memory address than expected. For example calling in a programming language would convert MyVar's contents to lowercase. But when the same is done with DllCall, MyVar would be uppercase after the following call because CharLower would have operated on a different/temporary string whose contents were identical to MyVar:\n\nTo work around this, change the two underlined \"Str\" values above to Ptr. This interprets CharUpper's return value as a pure address that will get passed as an integer to CharLower.\n\nCertain limitations may be encountered when dealing with strings. For details, see Binary Compatibility.\n\nCOM objects which are accessible to VBScript and similar languages are typically also accessible to AutoHotkey via ComObject, ComObjGet or ComObjActive and the built-in object syntax.\n\nCOM objects which don't support IDispatch can be used with DllCall by retrieving the address of a function from the virtual function table of the object's interface. For more details, see the example further below. However, it is usually better to use ComCall, which streamlines this process.\n\n.NET Framework libraries are executed by a \"virtual machine\" known as the Common Language Runtime, or CLR. That being the case, .NET DLL files are formatted differently to normal DLL files, and generally do not contain any functions which DllCall is capable of calling.\n\nHowever, AutoHotkey can utilize the CLR through COM callable wrappers. Unless the library is also registered as a general COM component, the CLR itself must first be manually initialized via DllCall. For details, see .NET Framework Interop."
    },
    {
        "link": "https://autohotkey.com/boards/viewtopic.php?t=102153",
        "document": "Get help with using AutoHotkey (v1.1 and older) and its commands and hotkeys\n\n\n\n\n\n so i got this script that move the mouse cursor down everytime i hold left click and i want the hotkeys to change the speed , but i dont know how pls help . (sorry for bad english) Last edited by imsuk000 on 31 Mar 2022, 18:03, edited 2 times in total.\n\nhelp your script does not work when i use together with this script\n\n \n\n $a::\n\n While (GetKeyState(\"a\",\"P\")) \n\n {\n\n Send, {a}\n\n Sleep, 15\n\n }\n\n Return\n\nline at the top. You can't put another hotkey above that line. See Show how you put it together. What do you mean it doesn't work? It doesn't move at all? Or you can't change the speed? I'm guessing you don't have theline at the top. You can't put another hotkey above that line. See Auto-execute Section in the documentation.\n\nand can u make for me these hotkeys f1=40 speed f2=50 speed f3=60 speed into that script bc i dont want to use ctrl +up down arrow to increse the speed (sorry if my english is bad)\n\nDid you just stop reading my last post halfway through? If you’re not going to make any effort to incorporate my feedback, then I’m not sure why you expect me to keep responding to your requests.\n\nand can u make for me these hotkeys f1=40 speed f2=50 speed f3=60 speed and can u make for me these hotkeys f1=40 speed f2=50 speed f3=60 speed Common you should be able to make a hotkey to set a variable.\n\n Here i will do the 1st one so you have an example.\n\n Also read what Boiler posted it's important to know how work. Common you should be able to make a hotkey to set a variable.Here i will do the 1st one so you have an example.Also read what Boiler posted it'sto know howwork.\n\nReturn to “Ask for Help (v1)”"
    },
    {
        "link": "https://reddit.com/r/AutoHotkey/comments/mz1hib/mouse_move_to_dllcall_mouse_event_help",
        "document": "I have a very simple help required :D, i have this script that inverts my mouse movement for 5 sec whenever run, but this only works while not in a game, mouse move in game seem dont do anything :/\n\nJust want to convert my mouse move to dll call mouse_event so it works in games to.\n\nI tried myself some dll call's but i couldnt figure out how to convert a working mouse move to dllcall\n\nSwitching x and y of dll call didnt seem to work neither in normal windows and nor in games.\n\nIts for a challenge of fps games while streaming with inverted mouse for a limited time :)\n\nIf anyone could help ❤ will be appreciated"
    },
    {
        "link": "https://autohotkey.com/docs/v1/lib/PixelSearch.htm",
        "document": "Searches a region of the screen for a pixel of the specified color.\n\nThe names of the output variables in which to store the X and Y coordinates of the first pixel that matches ColorID (if no match is found, the variables are made blank). Coordinates are relative to the active window unless CoordMode was used to change that. Either or both of these parameters may be left blank, in which case ErrorLevel (see below) can be used to determine whether a match was found. The X and Y coordinates of the starting corner of the rectangle to search, which can be expressions. Coordinates are relative to the active window unless CoordMode was used to change that. The X and Y coordinates of the ending corner of the rectangle to search, which can be expressions. Coordinates are relative to the active window unless CoordMode was used to change that. The decimal or hexadecimal color ID to search for, by default in Blue-Green-Red (BGR) format, which can be an expression. Color IDs can be determined using Window Spy (accessible from the tray menu) or via PixelGetColor. For example: . If blank or omitted, it defaults to 0. Otherwise, specify a number between 0 and 255 (inclusive) to indicate the allowed number of shades of variation in either direction for the intensity of the red, green, and blue components of the color (can be an expression). For example, if 2 is specified and ColorID is 0x444444, any color from 0x424242 to 0x464646 will be considered a match. This parameter is helpful if the color sought is not always exactly the same shade. If you specify 255 shades of variation, all colors will match. If blank or omitted, ColorID is interpreted as a BGR value that is searched in slow mode. Otherwise, specify one or more of the following words. If more than one word is present, separate each from the next with a space (e.g. ). Fast: Uses a faster searching method that in most cases dramatically reduces the amount of CPU time used by the search. Although color depths as low as 8-bit (256-color) are supported, the fast mode performs much better in 24-bit or 32-bit color. If the screen's color depth is 16-bit or lower, the Variation parameter might behave slightly differently in fast mode than it does in slow mode. Finally, the fast mode searches the screen row by row instead of column by column. Therefore, it might find a different pixel than that of the slow mode if there is more than one matching pixel. Warning: The default slow mode is unusable on most modern systems due to an incompatibility with desktop composition, which causes it to be orders of magnitude slower. RGB: Causes ColorID to be interpreted as an RGB value instead of BGR. In other words, the red and blue components are swapped.\n\n[v1.1.04+]: This command is able to throw an exception if there was a problem while searching. For more information, see Runtime Errors.\n\nErrorLevel is set to 0 if the color was found in the specified region, 1 if it was not found, or 2 if there was a problem that prevented the command from conducting the search.\n\nThe region to be searched must be visible; in other words, it is not possible to search a region of a window hidden behind another window. By contrast, pixels beneath the mouse cursor can usually be detected. The exception to this is game cursors, which in most cases will obstruct any pixels beneath them.\n\nThe search order depends on the order of the parameters. In other words, if X1 is greater than X2, the search will be conducted from right to left, starting at column X1. Similarly, if Y1 is greater than Y2, the search will be conducted from bottom to top. However, prior to [v1.1.32], the fast mode required X1 and Y1 to be the top-left corner.\n\nFast mode: The search starts at the coordinates specified by X1 and Y1 and checks all pixels in the row from X1 to X2 for a match. If no match is found there, the search continues toward Y2, row by row, until it finds a matching pixel.\n\nSlow mode: The search starts at the coordinates specified by X1 and Y1 and checks all pixels in the column from Y1 to Y2 for a match. If no match is found there, the search continues toward X2, column by column, until it finds a matching pixel.\n\nIf the region to be searched is large and the search is repeated with high frequency, it may consume a lot of CPU time. To alleviate this, keep the size of the area to a minimum."
    },
    {
        "link": "https://autohotkey.com/boards/viewtopic.php?t=89260",
        "document": "Ok so let me explain.So i use voice recognition to play majority of my games and being as potions juggle around the key is always different.In the game i play theres a belt with potions and the potions are constantly juggling around the beltthe belt has 4 slots from left to right labeled with hotkeys to drink a potion.Slot 1=1/Slot 2=2/Slot 3=3/Slot 4=4So for the script i want it to look for a target color in slot 1, if it finds the target color it'll Press the 1 key the script reloads and stops looking.If the Target color isn't in slot 1, i want to search slot 2 for the same target color, if it finds the target color it'll Press the 2 key the script reloads and stops looking.If the Target color isn't in slot 2, i want to search slot 3 for the same target color, if it finds the target color it'll Press the 3 key the script reloads and stops looking.If the Target color isn't in slot 3, i want to search slot 4 for the same target color, if it finds the target color it'll Press the 4 key the script reloads and stops looking.I hope i explained correctly."
    },
    {
        "link": "https://autohotkey.com/board/topic/93550-pixelsearch-in-an-area",
        "document": "Did you make a guide to help people? Post here! **Do not start question topics in here**\n\nSuggest features and fixes or report a problem with AutoHotkey here. **Do not start question topics in here**"
    },
    {
        "link": "https://autohotkey.com/boards/viewtopic.php?t=134149",
        "document": "Hey everyone!I'm using an AHK script for aim assistance that relies on color-based detection. It generally works well, but I'm running into issues with game modes that have objectives. When enemies are near objectives of the same color, the script sometimes misbehaves or snaps to the wrong target.To address this, I added a \"detection radius\" feature to the script, which helped a lot by reducing unwanted targeting on objectives. However, I'm still experiencing inconsistent targeting — sometimes it doesn’t lock onto the target even when they’re within the same distance. I suspect the issue could be with the loop function, but I didn’t code it myself. I asked GPT to add the detection radius, and it’s mostly working as intended.I’m unsure if there’s a more reliable solution than detection radius for this type of aim assist, like maybe improving target recognition or using pixel size to better differentiate between enemies and objectives.I'll include the code and some in-game images to show exactly what I mean. Any advice on troubleshooting or alternative methods would be greatly appreciated! Thanks in advance.Screenshots:"
    },
    {
        "link": "https://autohotkey.com/boards/viewtopic.php?t=121888",
        "document": "Get help with using AutoHotkey (v1.1 and older) and its commands and hotkeys\n\n\n\nHey everone,\n\n \n\n I am looking for help makin a script that uses pixel on screen.\n\n \n\n When i press key 4 i want my script to check if a certain pixel has a certain colour.\n\n If it has the colour that I am looking for then it must execute pressing key 0 .\n\n If it has a different(Any different colour) then it must press key 6.\n\n \n\n So in short \n\n - I press key 4\n\n - script checks pixel\n\n - script presses button 0 if colour match\n\n - script presses button 6 if false\n\n \n\n Hope you can help me. thanks in advance.\n\n \n\n Regards,\n\n Arnoud\n\nbutton 0\" i presume that is another hotkey command. If that's correct you can edit the if statement depending on if you wanna use nest hotkeys or change to using functions. If not then just remove the additional hotkeys/functions and Send 6 / Send 0\n\n \n\n Either way you will have to change both the desired color to compare against as well as decide the method to select the pixel to use for comparison\n\n 4::{ MouseGetPos &MouseX, &MouseY pixelPositionX := MouseX pixelPositionY := MouseY desiredColor := ffffff color := PixelGetColor(pixelPositionX, pixelPositionY) /* ;;debug code MsgBox \"The color at the current cursor position is \" color KeyWait \"a\" */ if (color = desiredColor) send 0 else function_6() } 0::{ MsgBox \"im script 0. from send\" } 6::{ MsgBox \"im script 6,a hotkey from send\" } function_0(){ MsgBox \"im script 0, called by function\" } function_6(){ MsgBox \"im script 6, called by function\" } Given you said \"button 0\" i presume that is another hotkey command. If that's correct you can edit the if statement depending on if you wanna use nest hotkeys or change to using functions. If not then just remove the additional hotkeys/functions and Send 6 / Send 0Either way you will have to change both the desired color to compare against as well as decide the method to select the pixel to use for comparison\n\n\n\n \n\n Thanks!\n\n \n\n I think I understand most of what you wrote. It looks as if the script uses mouse location and whatever pixel is underneath. What I need though, is a fixed location and the pixel that is in there.\n\n \n\n The fixed location can show two colours, or pixels. If pixel A is shown, the script must \"send 6\". If pixel B is shown, the script must \"send 0\" . All of this must happen while i spam keyboard key 4.\n\n \n\n What I have so far is this :\n\n \n\n SetTitleMatchMode 2 SetKeyDelay 5,15 ;toggle (Pauses and resumes script) Del:: Suspend,toggle return ; Suspends script when typing a message or slash command ~/:: Suspend, On return ; Unsuspends script after message/slash command is sent ~Enter:: Suspend, Off return 4:: send, 0 send, 6 return Hey!Thanks!I think I understand most of what you wrote. It looks as if the script uses mouse location and whatever pixel is underneath. What I need though, is a fixed location and the pixel that is in there.The fixed location can show two colours, or pixels. If pixel A is shown, the script must \"send 6\". If pixel B is shown, the script must \"send 0\" . All of this must happen while i spam keyboard key 4.What I have so far is this :\n\n\n\n \n\n You are right that I was using the mouse to check pixel colour, but that was pretty much just placeholder for testing purpose since I dont have the coordinates you wanna look at. You can very easily change that for your implementation by setting PixelPositionX to correct value, and vice versa for Y as well as the desired color value.\n\n \n\n A minor sidenote though, we are currently in the ahk v2 forum, the code you provided is from v1 so you will need to convert either your or my code to the other version.\n\n \n\n This should be pretty clear on what you need to change to have it do what you want. Excluding the possible version conversion\n\n 4::{ pixelPositionX := INSERT_X pixelPositionY := INSERT_Y desiredColor := \"INSERT_COLOR_CODE\" color := PixelGetColor(pixelPositionX, pixelPositionY) /* ;;debug code MsgBox \"The color at the current cursor position is \" color KeyWait \"a\" */ if (color = desiredColor) send 0 else send 6 } Yeah with minor edits you could have implemented the code from my '4' snippet into that.You are right that I was using the mouse to check pixel colour, but that was pretty much just placeholder for testing purpose since I dont have the coordinates you wanna look at. You can very easily change that for your implementation by setting PixelPositionX to correct value, and vice versa for Y as well as the desired color value.A minor sidenote though, we are currently in the ahk v2 forum, the code you provided is from v1 so you will need to convert either your or my code to the other version.This should be pretty clear on what you need to change to have it do what you want. Excluding the possible version conversion\n\nhmm alright, sorry.\n\n \n\n Can you somehow show me how your script looks in V1?\n\n \n\n I cant get V2 to work with the application that I use.\n\n \n\n Below an example of the pixel coordinates and the colour that it must find.\n\n \n\n Screen: 742, 1001\n\n Color: 9A7E84 (Red=9A Green=7E Blue=84)\n\n\n\n \n\n Thanks for your help guys. Making progress I think, but not there yet.\n\n \n\n Maybe it helps if I post my full script. But before I do that I will share what is working and what is not.\n\n \n\n 1. When I press key 4, the script is sending key 6. So that part works. \n\n 2. At some point a colour will change on the y x location, that specific colour should make the script press 0 instead of 6, that does not happen. It keeps pressing key 6.\n\n 3. I have used a MsgBox with mousemovement to check if the location is correct AND colour is correct. These both are good, so thats not the problem either.\n\n 4. In Script below I use key P to check if location and colour is correct.\n\n SetTitleMatchMode 2 SetKeyDelay 5,15 WinWaitActive, Warhammer WinActivate ;toggle (Pauses and resumes script) Del:: Suspend,toggle return ; Suspends script when typing a message or slash command ~/:: Suspend, On return ; Unsuspends script after message/slash command is sent ~Enter:: Suspend, Off return 4:: CoordMode, Pixel, Screen PixelGetColor, color, 743, 1009, RGB if (color = 0x191D2D) { send 0 } Else { send 6 } Return p:: x := 743, y := 1009 MouseMove, x, y PixelGetColor, color, x, y MsgBox, 64, Color, Color at (%x%,%y%) is %color% Hey,Thanks for your help guys. Making progress I think, but not there yet.Maybe it helps if I post my full script. But before I do that I will share what is working and what is not.1. When I press key 4, the script is sending key 6. So that part works.2. At some point a colour will change on the y x location, that specific colour should make the script press 0 instead of 6, that does not happen. It keeps pressing key 6.3. I have used a MsgBox with mousemovement to check if the location is correct AND colour is correct. These both are good, so thats not the problem either.4. In Script below I use key P to check if location and colour is correct.\n\nTry checking the color without the MouseMove to the pixel you are checking. This will verify if the pixel color is changing from a mouseover or not.\n\n \n\n Also move to the top of your script (aka AutoExec secton), so it works for the whole script (ie: both hotkeys)\n\nReturn to “Ask for Help (v1)”"
    }
]