[
    {
        "link": "https://developer.android.com/develop/ui/views/layout/linear",
        "document": "is a view group that aligns all children in a single direction, vertically or horizontally. You can specify the layout direction with the attribute.\n\nAll children of a are stacked one after the other, so a vertical list only has one child per row, no matter how wide they are. A horizontal list is only one row high, and it's the height of the tallest child, plus padding. A respects margins between children, and the gravity—right, center, or left alignment—of each child.\n\nalso supports assigning a weight to individual children with the attribute. This attribute assigns an \"importance\" value to a view in terms of how much space it occupies on the screen. A larger weight value lets it expand to fill the remaining space in the parent view. Child views can specify a weight value, and any remaining space in the view group is assigned to children proportionately, based on their declared weight. The default weight is zero.\n\nTo create a linear layout in which each child uses the same amount of space on the screen, set the of each view to for a vertical layout, or the of each view to for a horizontal layout. Then set the of each view to .\n\nYou can also create linear layouts where the child elements use different amounts of space on the screen. Consider the following examples:\n• Suppose you have three text fields: two with a weight value of 1, and a third with the default weight value of 0. The third text field, with the weight value of 0, occupies only the area required by its content. The other two text fields, with the weight value of 1, expand equally to fill the space that remains after the contents of all three fields are measured.\n• If instead you have three text fields where two have a weight value of 1 and the third has a weight of 2, then the space that remains after the contents of all three fields are measured is allocated as follows: half to the field with the weight value of 2, and half divided equally between the fields with the weight value of 1.\n\nThe following figure and code snippet show how layout weights might work in a \"send message\" activity. The To field, Subject line, and Send button each take up only the height they need. The message area takes up the rest of the activity's height.\n\nFor details about the attributes available to each child view of a , see ."
    },
    {
        "link": "https://stackoverflow.com/questions/50592597/how-to-set-a-xml-layout-as-the-view-to-a-linear-layout",
        "document": "As I understood your question from the post I suggest you to create separate layout for your bottom view and include it in your main xml layout file\n\nHere if I want to add 2 top view and bottom view separately you can add 2 file in layout\n\nlet say i have tow layout file top_view.xml and bottom_view.xml\n\nAnd in main_activiy.xml file include both file\n\nyou can access all controls of included layout in main.java file"
    },
    {
        "link": "https://developer.android.com/develop/ui/views/layout/declaring-layout",
        "document": "Save and categorize content based on your preferences.\n\nA layout defines the structure for a user interface in your app, such as in an activity. All elements in the layout are built using a hierarchy of and objects. A usually draws something the user can see and interact with. A is an invisible container that defines the layout structure for and other objects, as shown in figure 1.\n\nobjects are often called widgets and can be one of many subclasses, such as or . The objects are usually called layouts and can be one of many types that provide a different layout structure, such as or .\n\nYou can declare a layout in two ways:\n• Declare UI elements in XML. Android provides a straightforward XML vocabulary that corresponds to the classes and subclasses, such as those for widgets and layouts. You can also use Android Studio's Layout Editor to build your XML layout using a drag-and-drop interface.\n• Instantiate layout elements at runtime. Your app can create and objects and manipulate their properties programmatically.\n\nDeclaring your UI in XML lets you separate the presentation of your app from the code that controls its behavior. Using XML files also makes it easier to provide different layouts for different screen sizes and orientations. This is discussed further in Support different screen sizes.\n\nThe Android framework gives you the flexibility to use either or both of these methods to build your app's UI. For example, you can declare your app's default layouts in XML, and then modify the layout at runtime.\n\nUsing Android's XML vocabulary, you can quickly design UI layouts and the screen elements they contain, in the same way that you create web pages in HTML with a series of nested elements.\n\nEach layout file must contain exactly one root element, which must be a or object. After you define the root element, you can add additional layout objects or widgets as child elements to gradually build a hierarchy that defines your layout. For example, here's an XML layout that uses a vertical to hold a and a :\n\nAfter you declare your layout in XML, save the file with the extension in your Android project's directory so it properly compiles.\n\nFor more information about the syntax for a layout XML file, see Layout resource.\n\nWhen you compile your app, each XML layout file is compiled into a resource. Load the layout resource in your app's callback implementation. Do so by calling , passing it the reference to your layout resource in the form: . For example, if your XML layout is saved as , load it for your as follows:\n\nThe Android framework calls the callback method in your when the launches. For more information about activity lifecycles, see Introduction to activities.\n\nEvery and object supports its own variety of XML attributes. Some attributes are specific to a object. For example, supports the attribute. However, these attributes are also inherited by any objects that extend this class. Some are common to all objects, because they are inherited from the root class, like the attribute. Other attributes are considered layout parameters, which are attributes that describe certain layout orientations of the object, as defined by that object's parent object.\n\nAny object can have an integer ID associated with it to uniquely identify the within the tree. When the app is compiled, this ID is referenced as an integer, but the ID is typically assigned in the layout XML file as a string in the attribute. This is an XML attribute common to all objects, and it is defined by the class. You use it very often. The syntax for an ID inside an XML tag is the following:\n\nThe at symbol (@) at the beginning of the string indicates that the XML parser parses and expands the rest of the ID string and identifies it as an ID resource. The plus symbol (+) means this is a new resource name that must be created and added to your resources in the file.\n\nThe Android framework offers many other ID resources. When referencing an Android resource ID, you don't need the plus symbol, but you must add the package namespace as follows:\n\nThe package namespace indicates that you're referencing an ID from the resources class, rather than the local resources class.\n\nTo create views and reference them from your app, you can use a common pattern as follows:\n• Define a view in the layout file and assign it a unique ID, as in the following example:\n• Create an instance of the view object and capture it from the layout, typically in the method, as shown in the following example:\n\nDefining IDs for view objects is important when creating a . In a relative layout, sibling views can define their layout relative to another sibling view, which is referenced by the unique ID.\n\nAn ID doesn't need to be unique throughout the entire tree, but it must be unique within the part of the tree you search. It might often be the entire tree, so it's best to make it unique when possible.\n\nXML layout attributes named define layout parameters for the that are appropriate for the it resides in.\n\nEvery class implements a nested class that extends . This subclass contains property types that define the size and position of each child view, as appropriate for the view group. As shown in figure 2, the parent view group defines layout parameters for each child view, including the child view group.\n\nEvery subclass has its own syntax for setting values. Each child element must define a that is appropriate for its parent, though it might also define a different for its own children.\n\nAll view groups include a width and height, using and , and each view is required to define them. Many include optional margins and borders.\n\nYou can specify width and height with exact measurements, but you might not want to do this often. More often, you use one of these constants to set the width or height:\n• : tells your view to size itself to the dimensions required by its content.\n• : tells your view to become as big as its parent view group allows.\n\nIn general, we don't recommend specifying a layout width and height using absolute units such as pixels. A better approach is using relative measurements, such as density-independent pixel units (dp), , or , because it helps your app display properly across a variety of device screen sizes. The accepted measurement types are defined in Layout resource.\n\nA view has rectangular geometry. It has a location, expressed as a pair of left and top coordinates, and two dimensions, expressed as a width and height. The unit for location and dimensions is the pixel.\n\nYou can retrieve the location of a view by invoking the methods and . The former returns the left (x) coordinate of the rectangle representing the view. The latter returns the top (y) coordinate of the rectangle representing the view. These methods return the location of the view relative to its parent. For example, when returns 20, this means the view is located 20 pixels to the right of the left edge of its direct parent.\n\nIn addition, there are convenience methods to avoid unnecessary computations: namely and . These methods return the coordinates of the right and bottom edges of the rectangle representing the view. For example, calling is similar to the following computation: .\n\nThe size of a view is expressed with a width and height. A view has two pairs of width and height values.\n\nThe first pair is known as measured width and measured height. These dimensions define how big a view wants to be within its parent. You can obtain the measured dimensions by calling and .\n\nThe second pair is known as width and height, or sometimes drawing width and drawing height. These dimensions define the actual size of the view on screen, at drawing time and after layout. These values might, but don't have to, differ from the measured width and height. You can obtain the width and height by calling and .\n\nTo measure its dimensions, a view takes into account its padding. The padding is expressed in pixels for the left, top, right and bottom parts of the view. You can use padding to offset the content of the view by a specific number of pixels. For instance, a left padding of two pushes the view's content two pixels to the right of the left edge. You can set padding using the method and query it by calling , , , and .\n\nAlthough a view can define a padding, it doesn't support margins. However, view groups do support margins. See and for more information.\n\nFor more information about dimensions, see Dimension.\n\nBesides setting margins and padding programmatically, you can also set them in your XML layouts, as shown in the following example:\n\nThe preceding example shows margin and padding being applied. The has uniform margins and padding applied all around, and the shows how you can apply them independently to different edges.\n\nEach subclass of the class provides a unique way to display the views you nest within it. The most flexible layout type, and the one that provides the best tools for keeping your layout hierarchy shallow, is .\n\nThe following are some of the common layout types built into the Android platform.\n\nWhen the content for your layout is dynamic or not pre-determined, you can use or a subclass of . is generally the better option, because it uses memory more efficiently than .\n\nCommon layouts possible with and include the following:\n\noffers more possibilities and the option to create a custom layout manager.\n\nYou can populate an such as or by binding the instance to an , which retrieves data from an external source and creates a that represents each data entry.\n\nAndroid provides several subclasses of that are useful for retrieving different kinds of data and building views for an . The two most common adapters are:\n\nIf during the course of your app's life you change the underlying data that is read by your adapter, call . This notifies the attached view that the data has been changed and it refreshes itself.\n\nYou can respond to click events on each item in an by implementing the interface. For example:\n\nSee how layouts are used in the Sunflower demo app on GitHub."
    },
    {
        "link": "https://stackoverflow.com/questions/57379294/how-to-make-two-linearlayout-each-one-take-50-of-screen",
        "document": "You can have a layout like the following.\n\nCheck that, I have used to specify the portion of the screen which needs to be covered by this layout. The two having the same weight means the will have the screen equally. You can modify the weights and check how it affects the overall layout design.\n\nIf you want to divide the screen horizontally, just put instead of in the parent ."
    },
    {
        "link": "https://geeksforgeeks.org/linearlayout-and-its-important-attributes-with-examples-in-android",
        "document": ""
    },
    {
        "link": "https://developer.android.com/develop/ui/views/layout/declaring-layout",
        "document": "Save and categorize content based on your preferences.\n\nA layout defines the structure for a user interface in your app, such as in an activity. All elements in the layout are built using a hierarchy of and objects. A usually draws something the user can see and interact with. A is an invisible container that defines the layout structure for and other objects, as shown in figure 1.\n\nobjects are often called widgets and can be one of many subclasses, such as or . The objects are usually called layouts and can be one of many types that provide a different layout structure, such as or .\n\nYou can declare a layout in two ways:\n• Declare UI elements in XML. Android provides a straightforward XML vocabulary that corresponds to the classes and subclasses, such as those for widgets and layouts. You can also use Android Studio's Layout Editor to build your XML layout using a drag-and-drop interface.\n• Instantiate layout elements at runtime. Your app can create and objects and manipulate their properties programmatically.\n\nDeclaring your UI in XML lets you separate the presentation of your app from the code that controls its behavior. Using XML files also makes it easier to provide different layouts for different screen sizes and orientations. This is discussed further in Support different screen sizes.\n\nThe Android framework gives you the flexibility to use either or both of these methods to build your app's UI. For example, you can declare your app's default layouts in XML, and then modify the layout at runtime.\n\nUsing Android's XML vocabulary, you can quickly design UI layouts and the screen elements they contain, in the same way that you create web pages in HTML with a series of nested elements.\n\nEach layout file must contain exactly one root element, which must be a or object. After you define the root element, you can add additional layout objects or widgets as child elements to gradually build a hierarchy that defines your layout. For example, here's an XML layout that uses a vertical to hold a and a :\n\nAfter you declare your layout in XML, save the file with the extension in your Android project's directory so it properly compiles.\n\nFor more information about the syntax for a layout XML file, see Layout resource.\n\nWhen you compile your app, each XML layout file is compiled into a resource. Load the layout resource in your app's callback implementation. Do so by calling , passing it the reference to your layout resource in the form: . For example, if your XML layout is saved as , load it for your as follows:\n\nThe Android framework calls the callback method in your when the launches. For more information about activity lifecycles, see Introduction to activities.\n\nEvery and object supports its own variety of XML attributes. Some attributes are specific to a object. For example, supports the attribute. However, these attributes are also inherited by any objects that extend this class. Some are common to all objects, because they are inherited from the root class, like the attribute. Other attributes are considered layout parameters, which are attributes that describe certain layout orientations of the object, as defined by that object's parent object.\n\nAny object can have an integer ID associated with it to uniquely identify the within the tree. When the app is compiled, this ID is referenced as an integer, but the ID is typically assigned in the layout XML file as a string in the attribute. This is an XML attribute common to all objects, and it is defined by the class. You use it very often. The syntax for an ID inside an XML tag is the following:\n\nThe at symbol (@) at the beginning of the string indicates that the XML parser parses and expands the rest of the ID string and identifies it as an ID resource. The plus symbol (+) means this is a new resource name that must be created and added to your resources in the file.\n\nThe Android framework offers many other ID resources. When referencing an Android resource ID, you don't need the plus symbol, but you must add the package namespace as follows:\n\nThe package namespace indicates that you're referencing an ID from the resources class, rather than the local resources class.\n\nTo create views and reference them from your app, you can use a common pattern as follows:\n• Define a view in the layout file and assign it a unique ID, as in the following example:\n• Create an instance of the view object and capture it from the layout, typically in the method, as shown in the following example:\n\nDefining IDs for view objects is important when creating a . In a relative layout, sibling views can define their layout relative to another sibling view, which is referenced by the unique ID.\n\nAn ID doesn't need to be unique throughout the entire tree, but it must be unique within the part of the tree you search. It might often be the entire tree, so it's best to make it unique when possible.\n\nXML layout attributes named define layout parameters for the that are appropriate for the it resides in.\n\nEvery class implements a nested class that extends . This subclass contains property types that define the size and position of each child view, as appropriate for the view group. As shown in figure 2, the parent view group defines layout parameters for each child view, including the child view group.\n\nEvery subclass has its own syntax for setting values. Each child element must define a that is appropriate for its parent, though it might also define a different for its own children.\n\nAll view groups include a width and height, using and , and each view is required to define them. Many include optional margins and borders.\n\nYou can specify width and height with exact measurements, but you might not want to do this often. More often, you use one of these constants to set the width or height:\n• : tells your view to size itself to the dimensions required by its content.\n• : tells your view to become as big as its parent view group allows.\n\nIn general, we don't recommend specifying a layout width and height using absolute units such as pixels. A better approach is using relative measurements, such as density-independent pixel units (dp), , or , because it helps your app display properly across a variety of device screen sizes. The accepted measurement types are defined in Layout resource.\n\nA view has rectangular geometry. It has a location, expressed as a pair of left and top coordinates, and two dimensions, expressed as a width and height. The unit for location and dimensions is the pixel.\n\nYou can retrieve the location of a view by invoking the methods and . The former returns the left (x) coordinate of the rectangle representing the view. The latter returns the top (y) coordinate of the rectangle representing the view. These methods return the location of the view relative to its parent. For example, when returns 20, this means the view is located 20 pixels to the right of the left edge of its direct parent.\n\nIn addition, there are convenience methods to avoid unnecessary computations: namely and . These methods return the coordinates of the right and bottom edges of the rectangle representing the view. For example, calling is similar to the following computation: .\n\nThe size of a view is expressed with a width and height. A view has two pairs of width and height values.\n\nThe first pair is known as measured width and measured height. These dimensions define how big a view wants to be within its parent. You can obtain the measured dimensions by calling and .\n\nThe second pair is known as width and height, or sometimes drawing width and drawing height. These dimensions define the actual size of the view on screen, at drawing time and after layout. These values might, but don't have to, differ from the measured width and height. You can obtain the width and height by calling and .\n\nTo measure its dimensions, a view takes into account its padding. The padding is expressed in pixels for the left, top, right and bottom parts of the view. You can use padding to offset the content of the view by a specific number of pixels. For instance, a left padding of two pushes the view's content two pixels to the right of the left edge. You can set padding using the method and query it by calling , , , and .\n\nAlthough a view can define a padding, it doesn't support margins. However, view groups do support margins. See and for more information.\n\nFor more information about dimensions, see Dimension.\n\nBesides setting margins and padding programmatically, you can also set them in your XML layouts, as shown in the following example:\n\nThe preceding example shows margin and padding being applied. The has uniform margins and padding applied all around, and the shows how you can apply them independently to different edges.\n\nEach subclass of the class provides a unique way to display the views you nest within it. The most flexible layout type, and the one that provides the best tools for keeping your layout hierarchy shallow, is .\n\nThe following are some of the common layout types built into the Android platform.\n\nWhen the content for your layout is dynamic or not pre-determined, you can use or a subclass of . is generally the better option, because it uses memory more efficiently than .\n\nCommon layouts possible with and include the following:\n\noffers more possibilities and the option to create a custom layout manager.\n\nYou can populate an such as or by binding the instance to an , which retrieves data from an external source and creates a that represents each data entry.\n\nAndroid provides several subclasses of that are useful for retrieving different kinds of data and building views for an . The two most common adapters are:\n\nIf during the course of your app's life you change the underlying data that is read by your adapter, call . This notifies the attached view that the data has been changed and it refreshes itself.\n\nYou can respond to click events on each item in an by implementing the interface. For example:\n\nSee how layouts are used in the Sunflower demo app on GitHub."
    },
    {
        "link": "https://stackoverflow.com/questions/31237250/what-is-the-best-practise-for-padding-or-margin-in-android",
        "document": "It Depends on your need\n\nIf you just want to stack your and horizontally or vertically you should go with . If you want to make a layout that is more complex for example you can have an covering all of the screen and over the or if you want your layout elements to be stack on corners or at bottom, is your Guy.\n\nIt doesn't make much a difference its a personal preference, I Use margin-bottom on first element rather than margin-top for second element."
    },
    {
        "link": "https://medium.com/@manonpiette.pro/margins-and-padding-e4e9d0efa65d",
        "document": "This page is dedicated to explaining the basic rules around margins and padding in UI design. Margins and padding are two key concepts to master in order to achieve a clear and pleasing interface. The content below is based solely on my observations and personal experiences.\n\nMargins are the white spaces or empty spaces that separate elements. In the case of UI design, we distinguish between “margin” and “padding” with CSS. As seen in the example below, the “margin,” represented in yellow, is the space outside the elements that “pushes” other components away from the outside. The “padding,” represented in purple, is the margins that create space within components by adding space around their content.\n\nWhy is it important to use margins?\n\nBy using appropriate margins, we enhance the readability of content by providing sufficient space between elements. Margins provide visual breathing room for users, making the interface clearer. They also help group elements together for a visual understanding of the page. The benefits of smart margin usage can be directly observed by looking at the example below.\n\nMargins help define groups of elements, contributing to the visual organization of the interface. Margins allow for the creation of distinct groups, making navigation and understanding within the interface easier. As seen below, three colored groups are represented, with no visual hierarchy on the left, while each group is logically separated on the right. To visually create this hierarchy, elements can be grouped using “boxes” like Russian nesting dolls, as shown on the left in Figure 2. Once this hierarchy is established, the following rule is applied:\n\nor in other words:\n\nTo determine the size of margins, a system of proportionality using multiples of 8 pixels is employed. In this way, the spacing between elements follows a single and consistent logic, contributing to improved readability and homogeneity. To determine the size of margins, a system of proportionality using multiples of 8 pixels is employed. This approach ensures that element spacing follows a consistent logic, promoting improved readability and uniformity. We typically start with smaller margins, usually at 8 pixels, then progress to 16 pixels, 24 pixels, and so on.\n\nThere are no fixed rules regarding padding use; it all depends on the style and aesthetic desired: some choose a larger padding to give lightness and breathability, while others prefer a narrower padding to optimize available space.\n\nHowever, buttons can comply with certain padding rules/standards for their readability as CTAs (Call-to-Action). We write in a “horizontal” manner: words are longer than they are tall. So it’s preferable to comply with a “natural” rule of having more horizontal padding than vertical padding.\n\nGenerally, horizontal padding are around 2 to 3 times more than vertical padding. The benefits of this can be clearly seen in the example below.\n\n(If the proportion is around 2 to 3 times, I personally prefer a ratio of x3)\n\nThe rule for margins :\n\nThe more you go deep into subgroups, the smaller the margins become.\n\nThe rule for the button’s padding :\n\nHorizontal padding = between 2 and 3 times vertical padding"
    },
    {
        "link": "https://m2.material.io/design/layout/spacing-methods.html",
        "document": ""
    },
    {
        "link": "https://developer.android.com/design/ui/mobile/guides/layout-and-content/layout-basics",
        "document": "Stay organized with collections Save and categorize content based on your preferences.\n\nA layout defines the visual structure for a user to interface with your app, such as in an activity. Android provides a range of libraries, canonical starting points, and techniques to display and position content.\n• None Honor device safe areas, which includes parts of the UI such as display cutouts, edge-to-edge insets, edge displays, software keyboards, and system bars.\n• None Do: Provide a flexible layout for users to interact with the keyboard. Alas, your browser doesn't support HTML5 video. That's OK! You can still download the video and watch it with a video player.\n• None Keep essential interactions, like primary navigation, in a reachable screen area.\n• None Use containment to group related content to guide the user through content and actions. Figure 2: Cards using explicit containment to group content with related actions\n• Don't: disrupt readability by inconsistently spacing like elements, which can make designs appear haphazard. Do: Establish consistent spacing between like elements.\n• None Don't stick to portrait or an idealized layout: Consider different aspect ratios, size classes, and resolutions that users may encounter.\n• None Don't overwhelm your user with too many actions per view.\n• None When building custom layouts, notate how content should sit within the layout using alignment, constraints, or gravity terms. Include how images should respond to their container to display properly.\n\nMost Android apps consist of regions referred to as the system bars, the navigation area, and the body.\n\nThe status bar and navigation bar–collectively known as the system bars–display important information such as battery level, the time, and notification alerts, and provide direct device interaction from anywhere. Read more about system bars.\n\nNavigation represents the different affordances that allow a user to navigate within your app, access important actions, or across the Android platform.\n\nThe body region holds the screen content. Body content is composed of additional groupings and layout parameters. It must continue under navigation and system bar regions.\n\nTo determine the appropriate composition and navigation patterns for your layout, seek to understand how users interact with your content, and how they navigate your app's information architecture. This understanding can guide your design toward being more user-focused by creating UI that users can act on.\n\nBuild up a flexible flow and rhythm with a structure and containment methods for your content.\n\nBase structure: use margins and columns for visual guardrails\n\nTo begin creating a solid structure with consistent guardrails, add margins and columns to your layouts.\n\nMargins provide spacing on the left and right edges of the screen and content. A standard margin value for compact sizing is 16 dp, but margins should adapt to accommodate larger screens. Your app's body content and actions must stay within and align with these margins.\n\nYou can also ensure inset safe zones or insets at this step. System bar insets prevent crucial actions from falling under system bars. See Draw your content behind the system bars for details.\n\nUse columns to build a flexible grid structure for consistent alignment, and to provide vertical definition to a layout by dividing content within the body area. Content goes in the areas of the screen containing columns. These columns lend structure to your layout, providing convenient structure to arrange elements.\n\nUse a column grid to align content with an underlying grid but retain flexible sizing. The column grid can accommodate different form factors by changing the column sizes and number of columns as needed by the screen size at certain points while allowing content to also scale. Avoid being too granular with the column grid, this is what the baseline grid is for: providing consistent spacing units.\n\nBe careful of establishing an accompanying grid of rows as it can restrict horizontal content scaling across orientations and form factors, typically establishing padding rules will provide the needed visual consistency.\n\nContainment refers to using white space and visible elements together to create a visual grouping. A container is a shape that represents an enclosed area. In a single layout, you can group together elements that share similar content or functionality and separate them from other elements using open space, typography, and dividers.\n\nYou can group similar items together with white space or visible division to help guide the user through content.\n\nImplicit containment uses white space to visually group content to create container boundaries while explicit containment uses objects like divider lines and cards to group content together.\n\nThe following figure shows an example of using implicit containment to contain the header and primary copy. The column grid is used to align and create groupings. Highlights are explicitly contained within cards. Using iconography and type hierarchy for greater visual separation.\n\nAndroid has multiple ways to handle content elements in their respective containers that can help position them appropriately, including gravity, spacing, and scaling.\n\nGravity is a standard for placing an object within a potentially larger container for specific use cases. The following figure shows examples of positioning objects start and center (1), top and center horizontal (2), bottom left (3), and end and right (1).\n\nScaling is crucial to accommodate dynamic content, device orientation, and screen sizes. Elements can remain fixed or be scaled.\n\nNoting how images are displayed within their containers with scaling and position is important to ensure it appears how you want the image to look despite the device context, otherwise the image's primary focus could appear cut off, images could be too small or large for the layout, or other undesirable effects.\n\nContent that is not notated can appear differently than you expect or want.\n\nMany elements have built in interactions, scrolling, and positioning with slots or scaffolds. Some elements can be modified to stay fixed instead of reacting to scrolling, for example floating action buttons (FABs) that house critical actions.\n\nUse to create custom alignment lines, which parent layouts can use to align and position their children.\n\nDon't: disrupt readability by inconsistently spacing like elements, which can make designs appear haphazard.\n\nDo: Establish consistent spacing between like elements.\n\nMaterial 3 components provide their own configurations and states for interaction and content.\n\nCompose provides convenient layouts for combining Material Components into common screen patterns. Composables such as Scaffold provide slots for various components and other screen elements. Read more about Material Components and Layout.\n\nIf your app contains multiple destinations for users to traverse, we recommend employing layout and navigation pairings that are commonly used by other apps. Because many users already possess the mental models for these pairings, your app will be more intuitive for them.\n\nThe navigation bar and modal navigation drawer are used as primary navigation patterns for parent layout views and primary navigation destinations.\n\nThe navigation bar can hold three to five navigation destinations across the same hierarchy level. This component translates to the navigation rail for large screens.\n\nAlthough the navigation drawer can hold more than five navigation destinations, the pattern is not as ideal as the navigation bar due to the need to reach to the top bar on compact sizes.\n\nMaterial 3 Tabs and the bottom app bar are secondary navigation patterns that you can can use to supplement primary navigation or appear on children views.\n\nProvide controls to enable users to accomplish actions. Common patterns include top bar actions, floating action button (FAB), and menus.\n\nFor actions of the highest importance, a FAB provides a large and prominent button for the user. Provide only one action at a time at this level. A FAB can appear in multiple sizes and an expanded form, which includes a label. Use to pin a FAB, making sure it's always visible even on scroll by.\n\nYou can place secondary actions within the top bar or, if it's grouped near related content, within the page.\n\nFor any additional actions that aren't promptly or frequently needed, add those actions in an overflow menu.\n\nUtilize canonical layouts as a starting point, ready-to-use compositions that help layouts adapt for common use cases and screen sizes. These layouts are aesthetic and functional, and derived from Material 3 guidance.\n\nThe Android framework includes specialized components that make implementation of the layouts straightforward and reliable using either Jetpack Compose or views APIs.\n\nA list-detail layout enables users to explore lists of items that have descriptive, explanatory, or other supplementary information—the item detail. For compact screen sizes, only the list or detail view are visible. Displaying a collection of content in a row-based layout, lists make up the most common form of layouts for apps. List-detail is ideal for messaging apps, contact managers, file browsers, or any app where the content can be organized as a list of items that reveal additional information.\n\nContent can be static or dynamic.\n• Dynamic content is content that your app serves on-the-fly, and is ideal for showing user-generated content or reflect the user's preference or actions. For example, imagine a photo app with a scrollable list of user-generated photos, which is unique for each user and changes as the user uploads more images. These images are dynamic content.\n• Static content represents hard-coded content, which is modifiable only by making changes directly to your app's code. Examples of static content are images and text that every user might see.\n\nThe Now in Android Figma file provides multiple layout examples. The following example shows a one-dimensional collection of content.\n\nExplore Material 3 Lists for more design guidance on list components and specs.\n\nA feed layout arranges equivalent content elements in a configurable grid for quick, convenient viewing of a large amount of content. (See Material 3 guidelines for using cards in a collection.) Feeds can be list- or grid- based configuration on compact displays, typically in cards or tiles. Content can be dynamic, meaning it is “fed in” from a dynamic external source such as an API.\n\nA grid layout is composed of both rows and columns made up by implied or explicit containment principles. (See containment on this page for more information.) A grid layout can be more rigidly applied or staggered to vary the rows and columns. Both should have consistent application of spacing and logic to avoid confusing users. Explore Material 3 guidelines about designing feeds.\n\nYou can implement a feed layout in Compose with Lazy lists or lazy grids, or in Views with or .\n\nA mobile view may require supporting content or controls. Typically in the form of sheets or dialogs, they can help the primary view stay focused and uncluttered. Check out M3 guidance for using the supporting pane canonical layout.\n\nInputs, content, or other actions may appear relative to each other or constrained to a parent container. Layouts can be more custom, but make sure to follow consistent grouping, columns, and spacing.\n\nLayouts can also use a combination of layout types. For example, you might pair a carousel or horizontal scroll with vertical cards. Or, you could present a custom chart with vertical list data.\n\nYou can present content in scrolling rows or columns with lazy rows and lazy columns.\n\nLearn more about Compose layout basics and what makes up a composable.\n\nAuthentication is a common relative layout, as shown in the following figure.\n\nFull-screen layout is another common layout, as used in immersive mode.\n\nIf you're working with Views instead of Compose, you can use to lay out views according to relationships between sibling views and the parent layout, allowing for large and complex layouts. lets you build entirely by dragging and dropping instead of editing the XML using the layout editor. Learn more about building a UI with Layout Editor.\n\nAdaptive design is the practice of designing layouts that adapt to specific breakpoints and devices. Usually we consider the width of the device to determine where the layout should change, or adapt. Both Web and Android utilize responsive design concepts, like flexible grids and images, to create layouts that better respond to their context.\n\nFor design guidelines about adapting layouts to expanded screen sizes, read the Support different screen sizes developer guide in Compose and the M3 Applying Layout page. You can also check out the Android large screen canonical gallery for inspiration and implementation of large screen layouts.\n\nAlthough not every app needs to be available on every screen size, it does allow your users more freedom regarding ergonomics, usability, and app quality.\n• You can design key screens (communicate the essential concepts or your app) with class sizes as breakpoints to act as guidelines.\n• Or design content to act responsively by notating how content should be constrained, expand, or reflow.\n\nFor more on layouts, check out the Material Design 3 (M3) Understanding layout page.\n\nA Webview is a view that displays in-app web pages. In most cases, we recommend using a standard web browser, like Chrome, to deliver content to the user. To learn more about web browsers, read the guide for invoking a browser with an intent."
    }
]