[
    {
        "link": "https://docs.python.org/3/library/random.html",
        "document": "This module implements pseudo-random number generators for various distributions.\n\nFor integers, there is uniform selection from a range. For sequences, there is uniform selection of a random element, a function to generate a random permutation of a list in-place, and a function for random sampling without replacement.\n\nOn the real line, there are functions to compute uniform, normal (Gaussian), lognormal, negative exponential, gamma, and beta distributions. For generating distributions of angles, the von Mises distribution is available.\n\nAlmost all module functions depend on the basic function , which generates a random float uniformly in the half-open range . Python uses the Mersenne Twister as the core generator. It produces 53-bit precision floats and has a period of 2**19937-1. The underlying implementation in C is both fast and threadsafe. The Mersenne Twister is one of the most extensively tested random number generators in existence. However, being completely deterministic, it is not suitable for all purposes, and is completely unsuitable for cryptographic purposes.\n\nThe functions supplied by this module are actually bound methods of a hidden instance of the class. You can instantiate your own instances of to get generators that don’t share state.\n\nClass can also be subclassed if you want to use a different basic generator of your own devising: see the documentation on that class for more details.\n\nThe module also provides the class which uses the system function to generate random numbers from sources provided by the operating system.\n\nReturn a random element from the non-empty sequence seq. If seq is empty, raises . Return a k sized list of elements chosen from the population with replacement. If the population is empty, raises . If a weights sequence is specified, selections are made according to the relative weights. Alternatively, if a cum_weights sequence is given, the selections are made according to the cumulative weights (perhaps computed using ). For example, the relative weights are equivalent to the cumulative weights . Internally, the relative weights are converted to cumulative weights before making selections, so supplying the cumulative weights saves work. If neither weights nor cum_weights are specified, selections are made with equal probability. If a weights sequence is supplied, it must be the same length as the population sequence. It is a to specify both weights and cum_weights. The weights or cum_weights can use any numeric type that interoperates with the values returned by (that includes integers, floats, and fractions but excludes decimals). Weights are assumed to be non-negative and finite. A is raised if all weights are zero. For a given seed, the function with equal weighting typically produces a different sequence than repeated calls to . The algorithm used by uses floating-point arithmetic for internal consistency and speed. The algorithm used by defaults to integer arithmetic with repeated selections to avoid small biases from round-off error. Changed in version 3.9: Raises a if all weights are zero. To shuffle an immutable sequence and return a new shuffled list, use instead. Note that even for small , the total number of permutations of x can quickly grow larger than the period of most random number generators. This implies that most permutations of a long sequence can never be generated. For example, a sequence of length 2080 is the largest that can fit within the period of the Mersenne Twister random number generator. Return a k length list of unique elements chosen from the population sequence. Used for random sampling without replacement. Returns a new list containing elements from the population while leaving the original population unchanged. The resulting list is in selection order so that all sub-slices will also be valid random samples. This allows raffle winners (the sample) to be partitioned into grand prize and second place winners (the subslices). Members of the population need not be hashable or unique. If the population contains repeats, then each occurrence is a possible selection in the sample. Repeated elements can be specified one at a time or with the optional keyword-only counts parameter. For example, is equivalent to . To choose a sample from a range of integers, use a object as an argument. This is especially fast and space efficient for sampling from a large population: . If the sample size is larger than the population size, a is raised. Changed in version 3.11: The population must be a sequence. Automatic conversion of sets to lists is no longer supported.\n\nThe following functions generate specific real-valued distributions. Function parameters are named after the corresponding variables in the distribution’s equation, as used in common mathematical practice; most of these equations can be found in any statistics text. Return the next random floating-point number in the range Return a random floating-point number N such that for and for . The end-point value may or may not be included in the range depending on floating-point rounding in the expression . Return a random floating-point number N such that and with the specified mode between those bounds. The low and high bounds default to zero and one. The mode argument defaults to the midpoint between the bounds, giving a symmetric distribution. Beta distribution. Conditions on the parameters are and . Returned values range between 0 and 1. Exponential distribution. lambd is 1.0 divided by the desired mean. It should be nonzero. (The parameter would be called “lambda”, but that is a reserved word in Python.) Returned values range from 0 to positive infinity if lambd is positive, and from negative infinity to 0 if lambd is negative. Changed in version 3.12: Added the default value for . Gamma distribution. (Not the gamma function!) The shape and scale parameters, alpha and beta, must have positive values. (Calling conventions vary and some sources define ‘beta’ as the inverse of the scale). Normal distribution, also called the Gaussian distribution. mu is the mean, and sigma is the standard deviation. This is slightly faster than the function defined below. Multithreading note: When two threads call this function simultaneously, it is possible that they will receive the same return value. This can be avoided in three ways. 1) Have each thread use a different instance of the random number generator. 2) Put locks around all calls. 3) Use the slower, but thread-safe function instead. Changed in version 3.11: mu and sigma now have default arguments. Log normal distribution. If you take the natural logarithm of this distribution, you’ll get a normal distribution with mean mu and standard deviation sigma. mu can have any value, and sigma must be greater than zero. Normal distribution. mu is the mean, and sigma is the standard deviation. Changed in version 3.11: mu and sigma now have default arguments. mu is the mean angle, expressed in radians between 0 and 2*pi, and kappa is the concentration parameter, which must be greater than or equal to zero. If kappa is equal to zero, this distribution reduces to a uniform random angle over the range 0 to 2*pi. Weibull distribution. alpha is the scale parameter and beta is the shape parameter.\n\n# Even integer from 0 to 100 inclusive ['four', 'two', 'ace', 'three'] # of 52 playing cards, and determine the proportion of cards # Estimate the probability of getting 5 or more heads from 7 spins # of a biased coin that settles on heads 60% of the time. # Probability of the median of 5 samples being in middle two quartiles Example of statistical bootstrapping using resampling with replacement to estimate a confidence interval for the mean of a sample: Example of a resampling permutation test to determine the statistical significance or p-value of an observed difference between the effects of a drug versus a placebo: # Example from \"Statistics is Easy\" by Dennis Shasha and Manda Wilson 'at least as extreme as the observed difference of leads us to reject the null' 'hypothesis that there is no difference between the drug and the placebo.' Simulation of arrival times and service deliveries for a multiserver queue: # time when each server becomes available Statistics for Hackers a video tutorial by Jake Vanderplas on statistical analysis using just a few fundamental concepts including simulation, sampling, shuffling, and cross-validation. Economics Simulation a simulation of a marketplace by Peter Norvig that shows effective use of many of the tools and distributions provided by this module (gauss, uniform, sample, betavariate, choice, triangular, and randrange). A Concrete Introduction to Probability (using Python) a tutorial by Peter Norvig covering the basics of probability theory, how to write simulations, and how to perform data analysis using Python.\n\nThese recipes show how to efficiently make random selections from the combinatoric iterators in the module: \"Choose r elements with replacement. Order the result to match the iterable.\" # Result will be in set(itertools.combinations_with_replacement(iterable, r)). The default returns multiples of 2⁻⁵³ in the range 0.0 ≤ x < 1.0. All such numbers are evenly spaced and are exactly representable as Python floats. However, many other representable floats in that interval are not possible selections. For example, isn’t an integer multiple of 2⁻⁵³. The following recipe takes a different approach. All floats in the interval are possible selections. The mantissa comes from a uniform distribution of integers in the range 2⁵² ≤ mantissa < 2⁵³. The exponent comes from a geometric distribution where exponents smaller than -53 occur half as often as the next larger exponent. All real valued distributions in the class will use the new method: The recipe is conceptually equivalent to an algorithm that chooses from all the multiples of 2⁻¹⁰⁷⁴ in the range 0.0 ≤ x < 1.0. All such numbers are evenly spaced, but most have to be rounded down to the nearest representable Python float. (The value 2⁻¹⁰⁷⁴ is the smallest positive unnormalized float and is equal to .) Generating Pseudo-random Floating-Point Values a paper by Allen B. Downey describing ways to generate more fine-grained floats than normally generated by ."
    },
    {
        "link": "https://w3schools.com/python/module_random.asp",
        "document": "Python has a built-in module that you can use to make random numbers.\n\nThe module has a set of methods:"
    },
    {
        "link": "https://geeksforgeeks.org/python-random-module",
        "document": "Python Random module generates random numbers in Python. These are pseudo-random numbers means they are not truly random.\n\nThis module can be used to perform random actions such as generating random numbers, printing random a value for a list or string, etc. It is an in-built function in Python.\n\nList of all the functions Python Random Module\n\nThere are different random functions in the Random Module of Python. Look at the table below to learn more about these functions:\n\nLet’s discuss some common operations performed by Random module in Python.\n\nExample 1: Printing a random value from a list in Python.\n\nThis code uses the module to select a random element from the list using the function. It prints a random element from the list, demonstrating how to pick a random item from a sequence in Python.\n\nExample 2: Creating random numbers with Python seed() in Python.\n\nAs stated above random module creates pseudo-random numbers. Random numbers depend on the seeding value. For example, if the seeding value is 5 then the output of the below program will always be the same. Therefore, it must not be used for encryption.\n\nThe code sets the random number generator’s seed to 5 using , ensuring reproducibility. It then prints two random floating-point numbers between 0 and 1 using . The seed makes these numbers the same every time you run the code with a seed of 5, providing consistency in the generated random values.\n\nrandom.randint() method is used to generate random integers between the given range.\n\nThis code uses the ‘ module to generate random integers within specific ranges. It first generates a random integer between 5 and 15 (inclusive) and then between -10 and -2 (inclusive). The generated integers are printed with appropriate formatting.\n\nA random.random() method is used to generate random floats between 0.0 to 1.\n\nIn this code, we are using the function from the ‘ module in Python. It prints a random floating-point number between 0 and 1 when you call .\n\nRandom sampling from a list in Python (random.choice, and sample)\n\nExample 1: Python random.choice() function is used to return a random item from a list, tuple, or string.\n\nThe code uses the function from the module to randomly select elements from different data types. It demonstrates selecting a random element from a list, a string, and a tuple. The chosen elements will vary each time you run the code, making it useful for random selection from various data structures.\n\nExample 2: Python random.sample() function is used to return a random item from a list, tuple, or string.\n\nThis code utilizes the function from the ‘ module to obtain random samples from various data types. It selects three random elements without replacement from a list, a tuple, and a string, demonstrating its versatility in generating distinct random samples. With each execution, the selected elements will differ, providing random subsets from the input data structures.\n\nA random.shuffle() method is used to shuffle a sequence (list). Shuffling means changing the position of the elements of the sequence. Here, the shuffling operation is inplace.\n\nThis code uses the function from the ‘ module to shuffle the elements of a list named ‘ . It first prints the original order of the list, then shuffles it twice. The second shuffle creates a new random order, and the list’s content is displayed after each shuffle. This demonstrates how the elements are rearranged randomly in the list with each shuffle operation.\n\nIn this article we discussed about Python Random module, and also saw some examples of functions in random module in Python. Random module in Python is very important and contains very useful functions.\n\nHope this helps you in using Python Random module functions.\n\nWhat is a random module in Python?\n\nWhat is random vs Randint in Python?\n\nHow many functions are there in the random module?\n\nWhat is the syntax of the random function?\n\nWhat is the difference between the math module and the random module?"
    },
    {
        "link": "https://docs.python.org/2/library/random.html",
        "document": "This module implements pseudo-random number generators for various distributions.\n\nFor integers, uniform selection from a range. For sequences, uniform selection of a random element, a function to generate a random permutation of a list in-place, and a function for random sampling without replacement.\n\nOn the real line, there are functions to compute uniform, normal (Gaussian), lognormal, negative exponential, gamma, and beta distributions. For generating distributions of angles, the von Mises distribution is available.\n\nAlmost all module functions depend on the basic function , which generates a random float uniformly in the semi-open range [0.0, 1.0). Python uses the Mersenne Twister as the core generator. It produces 53-bit precision floats and has a period of 2**19937-1. The underlying implementation in C is both fast and threadsafe. The Mersenne Twister is one of the most extensively tested random number generators in existence. However, being completely deterministic, it is not suitable for all purposes, and is completely unsuitable for cryptographic purposes.\n\nThe functions supplied by this module are actually bound methods of a hidden instance of the class. You can instantiate your own instances of to get generators that don’t share state. This is especially useful for multi-threaded programs, creating a different instance of for each thread, and using the method to make it likely that the generated sequences seen by each thread don’t overlap.\n\nClass can also be subclassed if you want to use a different basic generator of your own devising: in that case, override the , , , and methods. Optionally, a new generator can supply a method — this allows to produce selections over an arbitrarily large range.\n\nAs an example of subclassing, the module provides the class that implements an alternative generator in pure Python. The class provides a backward compatible way to reproduce results from earlier versions of Python, which used the Wichmann-Hill algorithm as the core generator. Note that this Wichmann-Hill generator can no longer be recommended: its period is too short by contemporary standards, and the sequence generated is known to fail some stringent randomness tests. See the references below for a recent variant that repairs these flaws.\n\nThe module also provides the class which uses the system function to generate random numbers from sources provided by the operating system.\n\nReturn a k length list of unique elements chosen from the population sequence. Used for random sampling without replacement. Returns a new list containing elements from the population while leaving the original population unchanged. The resulting list is in selection order so that all sub-slices will also be valid random samples. This allows raffle winners (the sample) to be partitioned into grand prize and second place winners (the subslices). Members of the population need not be hashable or unique. If the population contains repeats, then each occurrence is a possible selection in the sample. To choose a sample from a range of integers, use an object as an argument. This is especially fast and space efficient for sampling from a large population: .\n\nThe following functions generate specific real-valued distributions. Function parameters are named after the corresponding variables in the distribution’s equation, as used in common mathematical practice; most of these equations can be found in any statistics text."
    },
    {
        "link": "https://codecademy.com/resources/docs/python/random-module",
        "document": "In Python, the built-in module is used to randomly generate numbers as well as randomly manipulate collections such as lists and strings.\n\nThis module can be used when imported at the top of a Python file:\n\nThe variable can then be used for executing the module’s built-in methods, like the below:"
    },
    {
        "link": "https://docs.python.org/3/library/math.html",
        "document": "This module provides access to the mathematical functions defined by the C standard.\n\nThese functions cannot be used with complex numbers; use the functions of the same name from the module if you require support for complex numbers. The distinction between functions which support complex numbers and those which don’t is made since most users do not want to learn quite as much mathematics as required to understand complex numbers. Receiving an exception instead of a complex result allows earlier detection of the unexpected complex number used as a parameter, so that the programmer can determine how and why it was generated in the first place.\n\nThe following functions are provided by this module. Except when explicitly noted otherwise, all return values are floats.\n\nReturn the number of ways to choose k items from n items without repetition and without order. Evaluates to when and evaluates to zero when . Also called the binomial coefficient because it is equivalent to the coefficient of k-th term in polynomial expansion of . Raises if either of the arguments are not integers. Raises if either of the arguments are negative. Return n factorial as an integer. Raises if n is not integral or is negative. Changed in version 3.10: Floats with integral values (like ) are no longer accepted. Return the greatest common divisor of the specified integer arguments. If any of the arguments is nonzero, then the returned value is the largest positive integer that is a divisor of all arguments. If all arguments are zero, then the returned value is . without arguments returns . Changed in version 3.9: Added support for an arbitrary number of arguments. Formerly, only two arguments were supported. Return the integer square root of the nonnegative integer n. This is the floor of the exact square root of n, or equivalently the greatest integer a such that a² ≤ n. For some applications, it may be more convenient to have the least integer a such that n ≤ a², or in other words the ceiling of the exact square root of n. For positive n, this can be computed using . Return the least common multiple of the specified integer arguments. If all arguments are nonzero, then the returned value is the smallest positive integer that is a multiple of all arguments. If any of the arguments is zero, then the returned value is . without arguments returns . Return the number of ways to choose k items from n items without repetition and with order. Evaluates to when and evaluates to zero when . If k is not specified or is , then k defaults to n and the function returns . Raises if either of the arguments are not integers. Raises if either of the arguments are negative.\n\nReturn the ceiling of x, the smallest integer greater than or equal to x. If x is not a float, delegates to , which should return an value. Return the absolute value of x. Return the floor of x, the largest integer less than or equal to x. If x is not a float, delegates to , which should return an value. Fused multiply-add operation. Return , computed as though with infinite precision and range followed by a single round to the format. This operation often provides better accuracy than the direct expression . This function follows the specification of the fusedMultiplyAdd operation described in the IEEE 754 standard. The standard leaves one case implementation-defined, namely the result of and . In these cases, returns a NaN, and does not raise any exception. Return the floating-point remainder of , as defined by the platform C library function . Note that the Python expression may not return the same result. The intent of the C standard is that be exactly (mathematically; to infinite precision) equal to for some integer n such that the result has the same sign as x and magnitude less than . Python’s returns a result with the sign of y instead, and may not be exactly computable for float arguments. For example, is , but the result of Python’s is , which cannot be represented exactly as a float, and rounds to the surprising . For this reason, function is generally preferred when working with floats, while Python’s is preferred when working with integers. Return the fractional and integer parts of x. Both results carry the sign of x and are floats. Note that has a different call/return pattern than its C equivalents: it takes a single argument and return a pair of values, rather than returning its second return value through an ‘output parameter’ (there is no such thing in Python). Return the IEEE 754-style remainder of x with respect to y. For finite x and finite nonzero y, this is the difference , where is the closest integer to the exact value of the quotient . If is exactly halfway between two consecutive integers, the nearest even integer is used for . The remainder thus always satisfies . Special cases follow IEEE 754: in particular, is x for any finite x, and and raise for any non-NaN x. If the result of the remainder operation is zero, that zero will have the same sign as x. On platforms using IEEE 754 binary floating point, the result of this operation is always exactly representable: no rounding error is introduced. Return x with the fractional part removed, leaving the integer part. This rounds toward 0: is equivalent to for positive x, and equivalent to for negative x. If x is not a float, delegates to , which should return an value. For the , , and functions, note that all floating-point numbers of sufficiently large magnitude are exact integers. Python floats typically carry no more than 53 bits of precision (the same as the platform C double type), in which case any float x with necessarily has no fractional bits.\n\nReturn a float with the magnitude (absolute value) of x but the sign of y. On platforms that support signed zeros, returns -1.0. Return the mantissa and exponent of x as the pair . m is a float and e is an integer such that exactly. If x is zero, returns , otherwise . This is used to “pick apart” the internal representation of a float in a portable way. Note that has a different call/return pattern than its C equivalents: it takes a single argument and return a pair of values, rather than returning its second return value through an ‘output parameter’ (there is no such thing in Python). Return if the values a and b are close to each other and otherwise. Whether or not two values are considered close is determined according to given absolute and relative tolerances. If no errors occur, the result will be: . rel_tol is the relative tolerance – it is the maximum allowed difference between a and b, relative to the larger absolute value of a or b. For example, to set a tolerance of 5%, pass . The default tolerance is , which assures that the two values are the same within about 9 decimal digits. rel_tol must be nonnegative and less than . abs_tol is the absolute tolerance; it defaults to and it must be nonnegative. When comparing to , is computed as , which is for any nonzero and rel_tol less than . So add an appropriate positive abs_tol argument to the call. The IEEE 754 special values of , , and will be handled according to IEEE rules. Specifically, is not considered close to any other value, including . and are only considered close to themselves. Return if x is neither an infinity nor a NaN, and otherwise. (Note that is considered finite.) Return if x is a positive or negative infinity, and otherwise. Return if x is a NaN (not a number), and otherwise. Return . This is essentially the inverse of function . Return the floating-point value steps steps after x towards y. If x is equal to y, return y, unless steps is zero.\n• None goes up: towards positive infinity.\n• None goes down: towards minus infinity.\n• None goes towards zero.\n• None goes away from zero. Return the value of the least significant bit of the float x:\n• None If x is a NaN (not a number), return x.\n• None If x is equal to zero, return the smallest positive denormalized representable float (smaller than the minimum positive normalized float, ).\n• None If x is equal to the largest positive representable float, return the value of the least significant bit of x, such that the first float smaller than x is .\n• None Otherwise (x is a positive finite number), return the value of the least significant bit of x, such that the first float bigger than x is . ULP stands for “Unit in the Last Place”. See also and .\n\nReturn e raised to the power x, where e = 2.718281… is the base of natural logarithms. This is usually more accurate than or . Return e raised to the power x, minus 1. Here e is the base of natural logarithms. For small floats x, the subtraction in can result in a significant loss of precision; the function provides a way to compute this quantity to full precision: With one argument, return the natural logarithm of x (to base e). With two arguments, return the logarithm of x to the given base, calculated as . Return the natural logarithm of 1+x (base e). The result is calculated in a way which is accurate for x near zero. Return the base-2 logarithm of x. This is usually more accurate than . returns the number of bits necessary to represent an integer in binary, excluding the sign and leading zeros. Return the base-10 logarithm of x. This is usually more accurate than . Return x raised to the power y. Exceptional cases follow the IEEE 754 standard as far as possible. In particular, and always return , even when x is a zero or a NaN. If both x and y are finite, x is negative, and y is not an integer then is undefined, and raises . Unlike the built-in operator, converts both its arguments to type . Use or the built-in function for computing exact integer powers. Changed in version 3.11: The special cases and were changed to return instead of raising , for consistency with IEEE 754.\n\nReturn the Euclidean distance between two points p and q, each given as a sequence (or iterable) of coordinates. The two points must have the same dimension. Return an accurate floating-point sum of values in the iterable. Avoids loss of precision by tracking multiple intermediate partial sums. The algorithm’s accuracy depends on IEEE-754 arithmetic guarantees and the typical case where the rounding mode is half-even. On some non-Windows builds, the underlying C library uses extended precision addition and may occasionally double-round an intermediate sum causing it to be off in its least significant bit. For further discussion and two alternative approaches, see the ASPN cookbook recipes for accurate floating-point summation. Return the Euclidean norm, . This is the length of the vector from the origin to the point given by the coordinates. For a two dimensional point , this is equivalent to computing the hypotenuse of a right triangle using the Pythagorean theorem, . Changed in version 3.8: Added support for n-dimensional points. Formerly, only the two dimensional case was supported. Changed in version 3.10: Improved the algorithm’s accuracy so that the maximum error is under 1 ulp (unit in the last place). More typically, the result is almost always correctly rounded to within 1/2 ulp. Calculate the product of all the elements in the input iterable. The default start value for the product is . When the iterable is empty, return the start value. This function is intended specifically for use with numeric values and may reject non-numeric types. Return the sum of products of values from two iterables p and q. Raises if the inputs do not have the same length. For float and mixed int/float inputs, the intermediate products and sums are computed with extended precision.\n\nThe mathematical constant π = 3.141592…, to available precision. The mathematical constant e = 2.718281…, to available precision. The mathematical constant τ = 6.283185…, to available precision. Tau is a circle constant equal to 2π, the ratio of a circle’s circumference to its radius. To learn more about Tau, check out Vi Hart’s video Pi is (still) Wrong, and start celebrating Tau day by eating twice as much pie! A floating-point positive infinity. (For negative infinity, use .) Equivalent to the output of . A floating-point “not a number” (NaN) value. Equivalent to the output of . Due to the requirements of the IEEE-754 standard, and are not considered to equal to any other numeric value, including themselves. To check whether a number is a NaN, use the function to test for NaNs instead of or . Example: Changed in version 3.11: It is now always available. CPython implementation detail: The module consists mostly of thin wrappers around the platform C math library functions. Behavior in exceptional cases follows Annex F of the C99 standard where appropriate. The current implementation will raise for invalid operations like or (where C99 Annex F recommends signaling invalid operation or divide-by-zero), and for results that overflow (for example, ). A NaN will not be returned from any of the functions above unless one or more of the input arguments was a NaN; in that case, most functions will return a NaN, but (again following C99 Annex F) there are some exceptions to this rule, for example or . Note that Python makes no effort to distinguish signaling NaNs from quiet NaNs, and behavior for signaling NaNs remains unspecified. Typical behavior is to treat all NaNs as though they were quiet. Complex number versions of many of these functions."
    },
    {
        "link": "https://w3schools.com/python/ref_math_pow.asp",
        "document": "W3Schools offers a wide range of services and products for beginners and professionals, helping millions of people everyday to learn and master new skills."
    },
    {
        "link": "https://datacamp.com/tutorial/exponents-in-python",
        "document": "Learn the art of Machine Learning and come away as a boss at prediction, pattern recognition, and the beginnings of Deep and Reinforcement Learning."
    },
    {
        "link": "https://devzery.com/post/your-ultimate-guide-to-exponentiation-in-python",
        "document": "Exponentiation is a fundamental mathematical operation that involves raising a number to the power of another number. In Python, exponentiation can be performed using various methods, including the ** operator, and the math.pow function, and the math.sqrt function. Understanding the differences, advantages, and best practices for using these methods is crucial for writing efficient and readable code. This guide provides an in-depth look at exponentiation in Python, helping you make informed decisions about which method to use in different scenarios.\n\nExponentiation is the process of raising a number (the base) to the power of an exponent. For example, in 232^323, 2 is the base, and 3 is the exponent, resulting in 2×2×2=82 \\times 2 \\times 2 = 82×2×2=8. In Python, exponentiation can be performed using the ** operator, the math.pow function, and the math.sqrt function for square roots.\n\nBest Practices for Exponentiation in Python\n\nCommon Pitfalls and How to Avoid Them\n\nExponentiation is a fundamental operation in Python that can be performed using the ** operator, math.pow, or math.sqrt. Each method has its advantages and specific use cases. The ** operator is generally preferred for its simplicity and performance, while math.pow ensures compatibility and consistent float return types. Understanding these methods and their best practices will help you write more efficient and readable code."
    },
    {
        "link": "https://w3schools.com/python/ref_func_pow.asp",
        "document": "W3Schools offers a wide range of services and products for beginners and professionals, helping millions of people everyday to learn and master new skills."
    },
    {
        "link": "https://medium.com/towards-data-science/hands-on-optimization-using-genetic-algorithms-with-python-bb7970dbbf0a",
        "document": "Have you ever heard of this sales tactic?\n\nI’m sure you did. For example: “Don’t spend hours writing your own code, use our software instead!”. Or “Stop wasting hours on your ads, use AI instead!” (my YouTube recommendation algorithm loves that one, and it’s probably my fault because I’m always talking about AI).\n\nThis sales tactic is based on the fact that the time that you spend on a problem that you want to solve can be optimized.\n\n“Nerdly” speaking, when you read this sales tactic, you usually have two options: exploration or exploitation. What do I mean by that? I’ll explain in a moment. For now, remember the sales tactic, and put it in the back of your head. We’ll be back on it.\n\nLet’s say you have a tool, a knob you can tune. By moving this knob, you get a waiting time. Imagine you are in line for a coffee at Starbucks and the knob has two states (0 and 1): 0 could mean “stay in the same line” and 1 could be “change the line”. Which one means “waiting the least amount of time”…"
    },
    {
        "link": "https://medium.com/data-science/hands-on-optimization-using-genetic-algorithms-with-python-bb7970dbbf0a",
        "document": "Have you ever heard of this sales tactic?\n\nI’m sure you did. For example: “Don’t spend hours writing your own code, use our software instead!”. Or “Stop wasting hours on your ads, use AI instead!” (my YouTube recommendation algorithm loves that one, and it’s probably my fault because I’m always talking about AI).\n\nThis sales tactic is based on the fact that the time that you spend on a problem that you want to solve can be optimized.\n\n“Nerdly” speaking, when you read this sales tactic, you usually have two options: exploration or exploitation. What do I mean by that? I’ll explain in a moment. For now, remember the sales tactic, and put it in the back of your head. We’ll be back on it.\n\nLet’s say you have a tool, a knob you can tune. By moving this knob, you get a waiting time. Imagine you are in line for a coffee at Starbucks and the knob has two states (0 and 1): 0 could mean “stay in the same line” and 1 could be “change the line”. Which one means “waiting the least amount of time”…"
    },
    {
        "link": "https://datacamp.com/tutorial/genetic-algorithm-python",
        "document": "Discover how to extract business value from AI. Learn to scope opportunities for AI, create POCs, implement solutions, and develop an AI strategy."
    },
    {
        "link": "https://stackoverflow.com/questions/75508427/fitness-function-in-a-genetic-algorithm-in-python",
        "document": "I'm trying to code a proper fitness function for a problem that we've choose to solve with a GA. The problem consists in identifying the start dates of production for different items and minimize the occurrences of conflicts in available hours of the machines used in each step of transforming raw material into a final product. The problem is that I'm little lost in the fitness function and I don't know how to proceed.\n\nI've calculated for each machine the total load for each production day in a range, finally, I've calculated the total sum of overload days and I'm using this as my \"note\" for every possible solution in my GA. Right now is quite simple, is returning the values and I think problably is wrong in the concept of the fitness function.\n\nI've a table for machines as index and production days as columns, for each day the production load is calculated and if it surpass 1.00 (100% of load capacity) the machine is considered overloaded.\n\nThe overload table is presented as:\n\nThe result of calculate_load_machine for the overload table is 3.\n\nI am thinking about changing the fitness function to be based in the total number of items I can do in a day, like, for each machin mN, I've a composition of different products that are contributing to the load capacity of a machine, therefore, I should choose which product I would do in order to not overcharge the machine.\n\nAny review, advice or comment is valid, thank you for your help!"
    },
    {
        "link": "https://stackoverflow.com/questions/73947238/best-way-to-define-a-fitness-function-which-can-be-optimized-by-ga-making-multip",
        "document": "Recently, I met such a questions, which require to optimize multiple properties of a designed material make them close to specified values.\n\nFor example, I have 3 reference property values (pv for short) values (i.e., pv01_ref = 10.2, pv02_ref = 200, pv03_ref = -0.5). These pv values can be calculated for the research material.\n\nNow, what I want to do is: designed a material, making it have pv values closed to the reference ones as above.\n\nI can think about this issue as the multiple-parameter optimization problem, which should be able to be solved by the genetic algorithm (GA) (or related heuristic methods).\n\nSuppose that I plan to use GA to solve this task. Now GA need optimize the fitness function (a scalar function), where trying to make the fitness the larger, the better (i.e., GA should try to obtain the maximum value of the fitness function from the material).\n\nI tried to propose such a fitness function as below.\n\nIn this fitness function, I want to make the pv01, pv02 and pv03 from the new designed material having values as closer to the reference ones as possible (i.e., 10.2, 200, -0.5). If so, the fitness value should be maximized by GA.\n\nBut I am not sure if this is a good defined fitness function, can you give me some suggestions about how to define such multiple-parameter optimization fitness function, making GA optimize/maximize it more reasonable?"
    }
]