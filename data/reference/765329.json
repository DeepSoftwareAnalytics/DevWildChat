[
    {
        "link": "https://airsdk.dev/reference/actionscript/3.0/flash/display/BitmapData.html",
        "document": "Calls to any method or property of a BitmapData object throw an ArgumentError error if the BitmapData object is invalid (for example, if it has height == 0 and width == 0 ) or it has been disposed of via dispose().\n\nStarting with AIR 3 and Flash player 11, the size limits for a BitmapData object have been removed. The maximum size of a bitmap is now dependent on the operating system.\n\nIn AIR 1.5 and Flash Player 10, the maximum size for a BitmapData object is 8,191 pixels in width or height, and the total number of pixels cannot exceed 16,777,215 pixels. (So, if a BitmapData object is 8,191 pixels wide, it can only be 2,048 pixels high.) In Flash Player 9 and earlier and AIR 1.1 and earlier, the limitation is 2,880 pixels in height and 2,880 in width.\n\nIn the AIR runtime, the DockIcon, Icon, InteractiveIcon, and SystemTrayIcon classes each include a bitmaps property that is an array of BitmapData objects that define the bitmap images for an icon.\n\nYou can use a BitmapData object to fill a Graphics object by using the Graphics.beginBitmapFill() method.\n\nYou can attach BitmapData objects to a Bitmap object by using the bitmapData property of the Bitmap object.\n\nThe four channels (alpha, red, green, and blue) are represented as numbers when you use them with the BitmapData.copyChannel() method or the DisplacementMapFilter.componentX and DisplacementMapFilter.componentY properties, and these numbers are represented by the following constants in the BitmapDataChannel class:\n\nEach 32-bit integer is a combination of four 8-bit channel values (from 0 to 255) that describe the alpha transparency and the red, green, and blue (ARGB) values of the pixel. (For ARGB values, the most significant byte represents the alpha channel value, followed by red, green, and blue.)\n\nA BitmapData object contains an array of pixel data. This data can represent either a fully opaque bitmap or a transparent bitmap that contains alpha channel data. Either type of BitmapData object is stored as a buffer of 32-bit integers. Each 32-bit integer determines the properties of a single pixel in the bitmap.\n\nThe methods of the BitmapData class support effects that are not available through the filters available to non-bitmap display objects.\n\nThis class lets you separate bitmap rendering operations from the internal display updating routines of Flash Player. By manipulating a BitmapData object directly, you can create complex images without incurring the per-frame overhead of constantly redrawing the content from vector data.\n\nThe BitmapData class lets you work with the data (pixels) of a. You can use the methods of the BitmapData class to create arbitrarily sized transparent or opaque bitmap images and manipulate them in various ways at runtime.\n\nYou can also access the BitmapData for a bitmap image that you load with the flash.display.Loader class.\n\n[read-only] The rectangle that defines the size and location of the bitmap image.\n\nUnlocks an image so that any objects that reference the BitmapData object, such as Bitmap objects, are updated when this BitmapData object changes.\n\nTests pixel values in an image against a specified threshold and sets pixels that pass the test to new color values.\n\nIndicates whether the specified property exists and is enumerable.\n\nPerforms a pixel dissolve either from a source image to a destination image or by using the same image.\n\nRemaps the color channel values in an image that has up to four arrays of color palette data, one for each channel.\n\nLocks an image so that any objects that reference the BitmapData object, such as Bitmap objects, are not updated when this BitmapData object changes.\n\nIndicates whether an instance of the Object class is in the prototype chain of the object specified as the parameter.\n\nReturns an integer that represents an RGB pixel value from a BitmapData object at a specific point (x, y).\n\nDetermines a rectangular region that either fully encloses all pixels of a specified color within the bitmap image (if the findColor parameter is set to true ) or fully encloses all pixels that do not include the specified color (if the findColor parameter is set to false ).\n\nPerforms a flood fill operation on an image starting at an (x, y) coordinate and filling with a certain color.\n\nProvides a fast routine to perform pixel manipulation between images with no stretching, rotation, or color effects.\n\nTransfers data from one channel of another BitmapData object or the current BitmapData object into a channel of the current BitmapData object.\n\nAdjusts the color values in a specified area of a bitmap image by using a ColorTransform object.\n\nReturns a new BitmapData object that is a clone of the original instance with an exact copy of the contained bitmap.\n\nDraws the display object onto the bitmap image, using the Flash runtime vector renderer. You can specify , , , and a destination parameter to control how the rendering performs. Optionally, you can specify whether the bitmap should be smoothed when scaled (this works only if the source object is a BitmapData object). Note: The method works exactly like the method, but instead of using the property to determine the quality of vector rendering, you specify the parameter to the method. This method directly corresponds to how objects are drawn with the standard vector renderer for objects in the authoring tool interface. The source display object does not use any of its applied transformations for this call. It is treated as it exists in the library or file, with no matrix transform, no color transform, and no blend mode. To draw a display object (such as a movie clip) by using its own transform properties, you can copy its property object to the property of the Bitmap object that uses the BitmapData object. This method is supported over RTMP in Flash Player 9.0.115.0 and later and in Adobe AIR. You can control access to streams on Flash Media Server in a server-side script. For more information, see the and properties in Server-Side ActionScript Language Reference for Adobe Flash Media Server. If the source object and (in the case of a Sprite or MovieClip object) all of its child objects do not come from the same domain as the caller, or are not in a content that is accessible to the caller by having called the method, a call to the throws a SecurityError exception. This restriction does not apply to AIR content in the application security sandbox. There are also restrictions on using a loaded bitmap image as the . A call to the method is successful if the loaded image comes from the same domain as the caller. Also, a cross-domain policy file on the image's server can grant permission to the domain of the SWF content calling the method. In this case, you must set the property of a LoaderContext object, and use this object as the parameter when calling the method of the Loader object used to load the image. These restrictions do not apply to AIR content in the application security sandbox. On Windows, the method cannot capture SWF content embedded in an HTML page in an HTMLLoader object in Adobe AIR. The method cannot capture PDF content in Adobe AIR. Nor can it capture or SWF content embedded in HTML in which the attribute is set to in Adobe AIR. — The display object or BitmapData object to draw to the BitmapData object. (The DisplayObject and BitmapData classes implement the IBitmapDrawable interface.) (default = ) — A Matrix object used to scale, rotate, or translate the coordinates of the bitmap. If you do not want to apply a matrix transformation to the image, set this parameter to an identity matrix, created with the default constructor, or pass a value. (default = ) — A ColorTransform object that you use to adjust the color values of the bitmap. If no object is supplied, the bitmap image's colors are not transformed. If you must pass this parameter but you do not want to transform the image, set this parameter to a ColorTransform object created with the default constructor. (default = ) — A string value, from the flash.display.BlendMode class, specifying the blend mode to be applied to the resulting bitmap. (default = ) — A Rectangle object that defines the area of the source object to draw. If you do not supply this value, no clipping occurs and the entire source object is drawn. (default = ) — A Boolean value that determines whether a BitmapData object is smoothed when scaled or rotated, due to a scaling or rotation in the parameter. The parameter only applies if the parameter is a BitmapData object. With set to , the rotated or scaled BitmapData image can appear pixelated or jagged. For example, the following two images use the same BitmapData object for the parameter, but the parameter is set to on the left and on the right: Drawing a bitmap with set to takes longer than doing so with set to . \n\n — The parameter is not a BitmapData or DisplayObject object. — The object and (in the case of a Sprite or MovieClip object) all of its child objects do not come from the same domain as the caller, or are not in a content that is accessible to the caller by having called the method. This restriction does not apply to AIR content in the application security sandbox. — The source is null or not a valid IBitmapDrawable object. \n\n \n\nThe following example shows how to draw a TextField object to a BitmapData object: import flash.display.Bitmap; import flash.display.BitmapData; import flash.text.TextField; var tf:TextField = new TextField(); tf.text = \"bitmap text\"; var myBitmapData:BitmapData = new BitmapData(80, 20); myBitmapData.draw(tf); var bmp:Bitmap = new Bitmap(myBitmapData); this.addChild(bmp); The following example shows how to draw a TextField object to a BitmapData object:\n\nDraws the display object onto the bitmap image, using the Flash runtime vector renderer. You can specify , , , and a destination parameter to control how the rendering performs. Optionally, you can specify whether the bitmap should be smoothed when scaled (this works only if the source object is a BitmapData object). Note: The method works exactly like the method, but instead of using the property to determine the quality of vector rendering, you specify the parameter to the method. This method directly corresponds to how objects are drawn with the standard vector renderer for objects in the authoring tool interface. The source display object does not use any of its applied transformations for this call. It is treated as it exists in the library or file, with no matrix transform, no color transform, and no blend mode. To draw a display object (such as a movie clip) by using its own transform properties, you can copy its property object to the property of the Bitmap object that uses the BitmapData object. This method is supported over RTMP in Flash Player 9.0.115.0 and later and in Adobe AIR. You can control access to streams on Flash Media Server in a server-side script. For more information, see the and properties in Server-Side ActionScript Language Reference for Adobe Flash Media Server. If the source object and (in the case of a Sprite or MovieClip object) all of its child objects do not come from the same domain as the caller, or are not in a content that is accessible to the caller by having called the method, a call to the throws a SecurityError exception. This restriction does not apply to AIR content in the application security sandbox. There are also restrictions on using a loaded bitmap image as the . A call to the method is successful if the loaded image comes from the same domain as the caller. Also, a cross-domain policy file on the image's server can grant permission to the domain of the SWF content calling the method. In this case, you must set the property of a LoaderContext object, and use this object as the parameter when calling the method of the Loader object used to load the image. These restrictions do not apply to AIR content in the application security sandbox. On Windows, the method cannot capture SWF content embedded in an HTML page in an HTMLLoader object in Adobe AIR. The method cannot capture PDF content in Adobe AIR. Nor can it capture or SWF content embedded in HTML in which the attribute is set to in Adobe AIR. — The display object or BitmapData object to draw to the BitmapData object. (The DisplayObject and BitmapData classes implement the IBitmapDrawable interface.) (default = ) — A Matrix object used to scale, rotate, or translate the coordinates of the bitmap. If you do not want to apply a matrix transformation to the image, set this parameter to an identity matrix, created with the default constructor, or pass a value. (default = ) — A ColorTransform object that you use to adjust the color values of the bitmap. If no object is supplied, the bitmap image's colors are not transformed. If you must pass this parameter but you do not want to transform the image, set this parameter to a ColorTransform object created with the default constructor. (default = ) — A string value, from the flash.display.BlendMode class, specifying the blend mode to be applied to the resulting bitmap. (default = ) — A Rectangle object that defines the area of the source object to draw. If you do not supply this value, no clipping occurs and the entire source object is drawn. (default = ) — A Boolean value that determines whether a BitmapData object is smoothed when scaled or rotated, due to a scaling or rotation in the parameter. The parameter only applies if the parameter is a BitmapData object. With set to , the rotated or scaled BitmapData image can appear pixelated or jagged. For example, the following two images use the same BitmapData object for the parameter, but the parameter is set to on the left and on the right: Drawing a bitmap with set to takes longer than doing so with set to . (default = ) — Any of one of the StageQuality values. Selects the antialiasing quality to be used when drawing vectors graphics. \n\n — The parameter is not a BitmapData or DisplayObject object. — The object and (in the case of a Sprite or MovieClip object) all of its child objects do not come from the same domain as the caller, or are not in a content that is accessible to the caller by having called the method. This restriction does not apply to AIR content in the application security sandbox. — The source is null or not a valid IBitmapDrawable object. \n\n \n\nThe following example shows how to draw a TextField object to a BitmapData object: import flash.display.Bitmap; import flash.display.BitmapData; import flash.text.TextField; var tf:TextField = new TextField(); tf.text = \"bitmap text\"; var myBitmapData:BitmapData = new BitmapData(80, 20); myBitmapData.drawWithQuality(tf, , , , , , StageQuality.LOW); var bmp:Bitmap = new Bitmap(myBitmapData); this.addChild(bmp); The following example shows how to draw a TextField object to a BitmapData object:"
    },
    {
        "link": "https://airsdk.dev/reference/actionscript/3.0/flash/display/Bitmap.html",
        "document": "The Bitmap class represents display objects that represent bitmap images. These can be images that you load with the flash.display.Loader class, or they can be images that you create with the constructor. The Bitmap class represents display objects that represent bitmap images. These can be images that you load with the flash.display.Loader class, or they can be images that you create with theconstructor. The constructor allows you to create a Bitmap object that contains a reference to a BitmapData object. After you create a Bitmap object, use the or method of the parent DisplayObjectContainer instance to place the bitmap on the display list. A Bitmap object can share its BitmapData reference among several Bitmap objects, independent of translation or rotation properties. Because you can create multiple Bitmap objects that reference the same BitmapData object, multiple display objects can use the same complex BitmapData object without incurring the memory overhead of a BitmapData object for each display object instance. A BitmapData object can be drawn to the screen by a Bitmap object in one of two ways: by using the vector renderer as a fill-bitmap shape, or by using a faster pixel-copying routine. The pixel-copying routine is substantially faster than the vector renderer, but the Bitmap object must meet certain conditions to use it:\n• No stretching, rotation, or skewing can be applied to the Bitmap object.\n• No color transform can be applied to the Bitmap object.\n• No blend mode can be applied to the Bitmap object.\n• No clipping can be done through mask layers or methods.\n• The image itself cannot be a mask.\n• The destination coordinates must be on a whole pixel boundary. If you load a Bitmap object from a domain other than that of the Loader object used to load the image, and there is no URL policy file that permits access to the domain of the Loader object, then a script in that domain cannot access the Bitmap object or its properties and methods. For more information, see the Flash Player Developer Center Topic: Security. Note: The Bitmap class is not a subclass of the InteractiveObject class, so it cannot dispatch mouse events. However, you can use the method of the display object container that contains the Bitmap object. \n\n\n\n[read-write] Controls whether or not the Bitmap object is snapped to the nearest pixel. The PixelSnapping class includes possible values:\n• —The image is always snapped to the nearest pixel, independent of transformation.\n• —The image is snapped to the nearest pixel if it is drawn with no rotation or skew and it is drawn at a scale factor of 99.9% to 100.1%. If these conditions are satisfied, the bitmap image is drawn at 100% scale, snapped to the nearest pixel. Internally, this value allows the image to be drawn as fast as possible using the vector renderer. \n\n \n\n \n\n [read-write] Controls whether or not the bitmap is smoothed when scaled. If , the bitmap is smoothed when scaled. If , the bitmap is not smoothed when scaled. \n\n \n\n \n\n Initializes a Bitmap object to refer to the specified BitmapData object. (default = \" \") — Whether or not the Bitmap object is snapped to the nearest pixel. (default = ) — Whether or not the bitmap is smoothed when scaled. For example, the following examples show the same bitmap scaled by a factor of 3, with set to (left) and (right): \n\n \n\nThe following example shows how you can dynamically load an image at runtime using the ActionScript 3.0 Loader class and then copy the image's pixels into four separate Bitmap object instances on the display list by using the Loader instance's content property and bitmapData properties. Example provided by const IMAGE_URL:String = \"http://www.helpexamples.com/flash/images/logo.png\"; var ldr:Loader = new Loader(); ldr.contentLoaderInfo.addEventListener(Event.COMPLETE, ldr_complete); ldr.load(new URLRequest(IMAGE_URL)); var bitmap1:Bitmap; var bitmap2:Bitmap; var bitmap3:Bitmap; var bitmap4:Bitmap; function ldr_complete(evt:Event):void { var bmp:Bitmap = ldr.content as Bitmap; bitmap1 = new Bitmap(bmp.bitmapData); bitmap1.x = 100; bitmap1.y = 100; bitmap1.rotation = 0; addChild(bitmap1); bitmap2 = new Bitmap(bmp.bitmapData); bitmap2.x = 200; bitmap2.y = 100; bitmap2.rotation = 90; addChild(bitmap2); bitmap3 = new Bitmap(bmp.bitmapData); bitmap3.x = 300; bitmap3.y = 100; bitmap3.rotation = 180; addChild(bitmap3); bitmap4 = new Bitmap(bmp.bitmapData); bitmap4.x = 400; bitmap4.y = 100; bitmap4.rotation = 270; addChild(bitmap4); } The following example shows how you can dynamically load an image at runtime using the ActionScript 3.0 Loader class and then copy the image's pixels into four separate Bitmap object instances on the display list by using the Loader instance's content property and bitmapData properties. Example provided by ActionScriptExamples.com method. This task is accomplished using the following steps:\n• A property is created, which is the location and name of the image file\n• The class constructor calls the method, which, in turn, calls the method.\n• creates a Loader object, which then instantiates an event listener, which is dispatched when completes the image manipulation.\n• Next, the method creates a new instance of a URLRequest object, , with passed so the file name and location are known.\n• The object is passed to the method, which loads the image into memory via a display object.\n• The image is then placed on the display list, which promptly displays the image on screen at coordinates x = 0, y = 0.\n• The method then performs the following tasks:\n• Creates a second Loader object, along with a Bitmap object, which is initialized with the Loader object.\n• Creates a second Bitmap object, , which in turn calls the method, which creates a duplicate of the original image.\n• Creates a BitmapData object, which is assigned to the object's BitmapData object.\n• Creates a new Rectangle object initialized with the same coordinates, width, and height as the original image.\n• Creates a new Point object, which defaults to x = 0, y = 0.\n• Creates the following variables:\n• : applies the new color when the threshold value is >= the original.\n• : the value against which each pixel is compared is set to light gray with an alpha of 0xCC.\n• : the color that the pixels will be set to that pass the threshold test, which is solid yellow in this case.\n• : set to the exact opposite of color, (transparent blue).\n• : set to false, indicating that the pixel values are not copied in the event the threshold value does not pass. This value has no meaning because the image is duplicated and only pixels that pass the threshold test are changed.\n• Calls the method by using the preceding variables. The resulting threshold equation is as follows: if (current pixel Value & 0x000000FF) >= (0xCCCCCCCC & 0x000000FF) then set pixel to 0xFFFFFF00 . The following example uses the BitmapExample class to load the \"Image.gif\" image into a DisplayObject in the default location (x = 0, y = 0). A copy of Image.gif is then placed to the right of the original, which has new colors applied to pixels that pass a test using themethod. This task is accomplished using the following steps:\n• You will need to compile the SWF file with \"Local playback security\" set to \"Access local files only\".\n• This example requires that a file named Image.gif be placed in the same directory as your SWF file.\n• It is recommended that you use an image up to 80 pixels wide. package { import flash.display.Bitmap; import flash.display.BitmapData; import flash.display.Loader; import flash.display.Sprite; import flash.events.*; import flash.geom.Point; import flash.geom.Rectangle; import flash.net.URLRequest; public class BitmapExample extends Sprite { private var url:String = \"Image.gif\"; private var size:uint = 80; public function BitmapExample() { configureAssets(); } private function configureAssets():void { var loader:Loader = new Loader(); loader.contentLoaderInfo.addEventListener(Event.COMPLETE, completeHandler); loader.contentLoaderInfo.addEventListener(IOErrorEvent.IO_ERROR, ioErrorHandler); var request:URLRequest = new URLRequest(url); loader.x = size * numChildren; loader.load(request); addChild(loader); } private function duplicateImage(original:Bitmap):Bitmap { var image:Bitmap = new Bitmap(original.bitmapData.clone()); image.x = size * numChildren; addChild(image); return image; } private function completeHandler(event:Event):void { var loader:Loader = Loader(event.target.loader); var image:Bitmap = Bitmap(loader.content); var duplicate:Bitmap = duplicateImage(image); var bitmapData:BitmapData = duplicate.bitmapData; var sourceRect:Rectangle = new Rectangle(0, 0, bitmapData.width, bitmapData.height); var destPoint:Point = new Point(); var operation:String = \">=\"; var threshold:uint = 0xCCCCCCCC; var color:uint = 0xFFFFFF00; var mask:uint = 0x000000FF; var copySource:Boolean = true; bitmapData.threshold(bitmapData, sourceRect, destPoint, operation, threshold, color, mask, copySource); } private function ioErrorHandler(event:IOErrorEvent):void { trace(\"Unable to load image: \" + url); } } }"
    },
    {
        "link": "https://stackoverflow.com/questions/10667104/actionscript-3-0-creating-bitmapdata-from-loaded-url",
        "document": "I want to load an image and then use its bitmapData. The program worked when I ran it from flash, but not when I uploaded it online. There seem to be a bunch of weird problems. The works online but does not, and the myLoader doesn't seem to have bitmapData I can access. For some reason the will work online but not the that I added to see what's going on. When I run this on my computer I get the urlInput saying \"[object Bitmap] hi\" like it should, but online it just says \"Loading...\" still"
    },
    {
        "link": "https://cs.vu.nl/~eliens/assets/flex3/langref/flash/display/BitmapData.html",
        "document": "Calls to any method or property of a BitmapData object throw an ArgumentError error if the BitmapData object is invalid (for example, if it has height == 0 and width == 0 ) or it has been disposed of via dispose().\n\nIn the AIR runtime, the DockIcon, Icon, InteractiveIcon, and SystemTrayIcon classes each include a bitmaps property that is an array of BitmapData objects that define the bitmap images for an icon.\n\nYou can use a BitmapData object to fill a Graphics object by using the Graphics.beginBitmapFill() method.\n\nYou can attach BitmapData objects to a Bitmap object by using the bitmapData property of the Bitmap object.\n\nThe four channels (alpha, red, green, and blue) are represented as numbers when you use them with the BitmapData.copyChannel() method or the DisplacementMapFilter.componentX and DisplacementMapFilter.componentY properties, and these numbers are represented by the following constants in the BitmapDataChannel class:\n\nEach 32-bit integer is a combination of four 8-bit channel values (from 0 to 255) that describe the alpha transparency and the red, green, and blue (ARGB) values of the pixel. (For ARGB values, the most significant byte represents the alpha channel value, followed by red, green, and blue.)\n\nA BitmapData object contains an array of pixel data. This data can represent either a fully opaque bitmap or a transparent bitmap that contains alpha channel data. Either type of BitmapData object is stored as a buffer of 32-bit integers. Each 32-bit integer determines the properties of a single pixel in the bitmap.\n\nThe methods of the BitmapData class support effects that are not available through the filters available to non-bitmap display objects.\n\nThis class lets you separate bitmap rendering operations from the internal display updating routines of Flash Player. By manipulating a BitmapData object directly, you can create complex images without incurring the per-frame overhead of constantly redrawing the content from vector data.\n\nThe BitmapData class lets you work with the data (pixels) of a. You can use the methods of the BitmapData class to create arbitrarily sized transparent or opaque bitmap images and manipulate them in various ways at runtime.\n\nYou can also access the BitmapData for a bitmap image that you load with the flash.display.Loader class.\n\n[read-only] The rectangle that defines the size and location of the bitmap image.\n\nUnlocks an image so that any objects that reference the BitmapData object, such as Bitmap objects, are updated when this BitmapData object changes.\n\nTests pixel values in an image against a specified threshold and sets pixels that pass the test to new color values.\n\nIndicates whether the specified property exists and is enumerable.\n\nPerforms a pixel dissolve either from a source image to a destination image or by using the same image.\n\nRemaps the color channel values in an image that has up to four arrays of color palette data, one for each channel.\n\nLocks an image so that any objects that reference the BitmapData object, such as Bitmap objects, are not updated when this BitmapData object changes.\n\nIndicates whether an instance of the Object class is in the prototype chain of the object specified as the parameter.\n\nReturns an integer that represents an RGB pixel value from a BitmapData object at a specific point (x, y).\n\nDetermines a rectangular region that either fully encloses all pixels of a specified color within the bitmap image (if the findColor parameter is set to true) or fully encloses all pixels that do not include the specified color (if the findColor parameter is set to false).\n\nPerforms a flood fill operation on an image starting at an (x, y) coordinate and filling with a certain color.\n\nDraws the source display object onto the bitmap image, using the Flash Player or AIR vector renderer.\n\nProvides a fast routine to perform pixel manipulation between images with no stretching, rotation, or color effects.\n\nTransfers data from one channel of another BitmapData object or the current BitmapData object into a channel of the current BitmapData object.\n\nAdjusts the color values in a specified area of a bitmap image by using a ColorTransform object.\n\nReturns a new BitmapData object that is a clone of the original instance with an exact copy of the contained bitmap.\n\nTakes a source image and a filter object and generates the filtered image. This method relies on the behavior of built-in filter objects, which determine the destination rectangle that is affected by an input source rectangle. After a filter is applied, the resulting image can be larger than the input image. For example, if you use a BlurFilter class to blur a source rectangle of (50,50,100,100) and a destination point of (10,10), the area that changes in the destination image is larger than (10,10,60,60) because of the blurring. This happens internally during the call. If the parameter of the parameter is an interior region, such as (50,50,100,100) in a 200 x 200 image, the filter uses the source pixels outside the parameter to generate the destination rectangle. If the BitmapData object and the object specified as the parameter are the same object, the application uses a temporary copy of the object to perform the filter. For best performance, avoid this situation. — The input bitmap image to use. The source image can be a different BitmapData object or it can refer to the current BitmapData instance. — A rectangle that defines the area of the source image to use as input. — The point within the destination image (the current BitmapData instance) that corresponds to the upper-left corner of the source rectangle. — The filter object that you use to perform the filtering operation. Each type of filter has certain requirements, as follows:\n• BlurFilter — This filter can use source and destination images that are either opaque or transparent. If the formats of the images do not match, the copy of the source image that is made during the filtering matches the format of the destination image.\n• BevelFilter, DropShadowFilter, GlowFilter, ChromeFilter — The destination image of these filters must be a transparent image. Calling DropShadowFilter or GlowFilter creates an image that contains the alpha channel data of the drop shadow or glow. It does not create the drop shadow onto the destination image. If you use any of these filters with an opaque destination image, an exception is thrown.\n• ConvolutionFilter — This filter can use source and destination images that are either opaque or transparent.\n• ColorMatrixFilter — This filter can use source and destination images that are either opaque or transparent.\n• DisplacementMapFilter — This filter can use source and destination images that are either opaque or transparent, but the source and destination image formats must be the same. \n\n — The sourceBitmapData, sourceRect, destPoint or filter are null. — The transparency of the BitmapData objects are not compatible with the filter operation. \n\n \n\n \n\n import flash.display.Bitmap; import flash.display.BitmapData; import flash.geom.Point; import flash.geom.Rectangle; import flash.filters.BlurFilter; var bmd:BitmapData = new BitmapData(80, 30, false, 0xFFCC00); var rect:Rectangle = new Rectangle(10, 10, 40, 10); bmd.fillRect(rect, 0xFF0000); var pt:Point = new Point(10, 10); var filter:BlurFilter = new BlurFilter(); bmd.applyFilter(bmd, rect, pt, filter); var bm:Bitmap = new Bitmap(bmd); addChild(bm); The following example shows how to apply a blur filter to a BitmapData instance:\n\nCompares two BitmapData objects. If the two BitmapData objects have the same dimensions (width and height), the method returns a new BitmapData object, in which each pixel is the \"difference\" between the pixels in the two source objects:\n• If two pixels are equal, the difference pixel is 0x00000000.\n• If two pixels have different RGB values (ignoring the alpha value), the difference pixel is 0xRRGGBB where RR/GG/BB are the individual difference values between red, green, and blue channels (the pixel value in the source object minus the pixel value in the object). Alpha channel differences are ignored in this case.\n• If only the alpha channel value is different, the pixel value is 0xZZFFFFFF, where ZZ is the difference in the alpha values (the alpha value in the source object minus the alpha value in the object). For example, consider the following two BitmapData objects: var bmd1:BitmapData = new BitmapData(50, 50, true, 0xFFFF8800); var bmd2:BitmapData = new BitmapData(50, 50, true, 0xCCCC6600); var diffBmpData:BitmapData = bmd1.compare(bmd2) as BitmapData; trace (\"0x\" + diffBmpData.getPixel(0,0).toString(16); // 0x332200 Note: The colors used to fill the two BitmapData objects have slightly different RGB values (0xFF0000 and 0xFFAA00). The result of the method is a new BitmapData object with each pixel showing the difference in the RGB values between the two bitmaps. Consider the following two BitmapData objects, in which the RGB colors are the same, but the alpha values are different: var bmd1:BitmapData = new BitmapData(50, 50, true, 0xFFFFAA00); var bmd2:BitmapData = new BitmapData(50, 50, true, 0xCCFFAA00); var diffBmpData:BitmapData = bmd1.compare(bmd2) as BitmapData; trace (\"0x\" + diffBmpData.getPixel32(0,0).toString(16); // 0x33ffffff The result of the method is a new BitmapData object with each pixel showing the difference in the alpha values between the two bitmaps. If the BitmapData objects are equivalent (with the same width, height, and identical pixel values), the method returns the number 0. If the widths of the BitmapData objects are not equal, the method returns the number -3. If the heights of the BitmapData objects are not equal, but the widths are the same, the method returns the number -4. The following example compares two Bitmap objects with different widths (50 and 60): — The BitmapData object to compare with the source BitmapData object. — If the two BitmapData objects have the same dimensions (width and height), the method returns a new BitmapData object that has the difference between the two objects (see the main discussion). If the BitmapData objects are equivalent, the method returns the number 0. If the widths of the BitmapData objects are not equal, the method returns the number -3. If the heights of the BitmapData objects are not equal, the method returns the number -4. \n\n \n\n \n\n \n\n import flash.display.Bitmap; import flash.display.BitmapData; var bmd1:BitmapData = new BitmapData(50, 50, true, 0xFFFFAA00); var bmd2:BitmapData = new BitmapData(50, 50, true, 0xCCFFAA00); var diffBmpData:BitmapData = BitmapData(bmd1.compare(bmd2)); var diffValue:String = diffBmpData.getPixel32(1, 1).toString(16); trace(diffValue); // 33ffffff var bm1:Bitmap = new Bitmap(bmd1); addChild(bm1); var bm2:Bitmap = new Bitmap(bmd2); addChild(bm2); bm2.x = 60; The following example shows the value of a pixel in the BitmapData object that results from comparing two BitmapData objects of the same dimensions:\n\nDraws the display object onto the bitmap image, using the Flash Player or AIR vector renderer. Flash Player or AIR vector renderer. You can specify , , , and a destination parameter to control how the rendering performs. Optionally, you can specify whether the bitmap should be smoothed when scaled (this works only if the source object is a BitmapData object). This method directly corresponds to how objects are drawn with the standard vector renderer for objects in the authoring tool interface. The source display object does not use any of its applied transformations for this call. It is treated as it exists in the library or file, with no matrix transform, no color transform, and no blend mode. To draw a display object (such as a movie clip) by using its own transform properties, you can copy its property object to the property of the Bitmap object that uses the BitmapData object. Note: The object and (in the case of a Sprite or MovieClip object) all of its child objects must come from the same domain as the caller, or must be in a SWF file that is accessible to the caller by having called the method. If these conditions are not met, the method does not draw anything. This method is supported over RTMP in Flash Player Update 3 and later and in Adobe AIR. You can control access to streams on Flash Media Server in a server-side script. For more information, see the and properties in Server-Side ActionScript Language Reference for Adobe Flash Media Server . If the source object and (in the case of a Sprite or MovieClip object) all of its child objects do not come from the same domain as the caller, or are not in a content that is accessible to the caller by having called the method, a call to the throws a SecurityError exception. This restriction does not apply to AIR content in the application security sandbox. On Windows, the method cannot capture SWF content embedded in an HTML page in an HTMLLoader object in Adobe AIR. The method cannot capture PDF content in Adobe AIR. Nor can it capture or SWF content embedded in HTML in which the attribute is set to in Adobe AIR. — The display object or BitmapData object to draw to the BitmapData object. (The DisplayObject and BitmapData classes implement the IBitmapDrawable interface.) (default = ) — A Matrix object used to scale, rotate, or translate the coordinates of the bitmap. If you do not want to apply a matrix transformation to the image, set this parameter to an identity matrix, created with the default constructor, or pass a value. (default = ) — A ColorTransform object that you use to adjust the color values of the bitmap. If no object is supplied, the bitmap image's colors are not transformed. If you must pass this parameter but you do not want to transform the image, set this parameter to a ColorTransform object created with the default constructor. (default = ) — A string value, from the flash.display.BlendMode class, specifying the blend mode to be applied to the resulting bitmap. (default = ) — A Rectangle object that defines the area of the source object to draw. If you do not supply this value, no clipping occurs and the entire source object is drawn. (default = ) — A Boolean value that determines whether a BitmapData object is smoothed when scaled or rotated, due to a scaling or rotation in the parameter. The parameter only applies if the parameter is a BitmapData object. With set to , the rotated or scaled BitmapData image can appear pixelated or jagged. For example, the following two images use the same BitmapData object for the parameter, but the parameter is set to on the left and on the right: Drawing a bitmap with set to takes longer than doing so with set to . \n\n — The parameter is not a BitmapData or DisplayObject object. — The object and (in the case of a Sprite or MovieClip object) all of its child objects do not come from the same domain as the caller, or are not in a content that is accessible to the caller by having called the method. This restriction does not apply to AIR content in the application security sandbox. — The source is null or not a valid IBitmapDrawable object. \n\n \n\n \n\n import flash.display.Bitmap; import flash.display.BitmapData; import flash.text.TextField; var tf:TextField = new TextField(); tf.text = \"bitmap text\"; var myBitmapData:BitmapData = new BitmapData(80, 20); myBitmapData.draw(tf); var bmp:Bitmap = new Bitmap(myBitmapData); this.addChild(bmp); The following example shows how to draw a TextField object to a BitmapData object:\n\nPerforms per-channel blending from a source image to a destination image. For each channel and each pixel, a new value is computed based on the channel values of the source and destination pixels. For example, in the red channel, the new value is computed as follows (where is the red channel value for a pixel in the source image and is the red channel value at the corresponding pixel of the destination image): The , , , and values are the multipliers used for each color channel. Use a hexadecimal value ranging from to (256) where specifies the full value from the destination is used in the result, specifies the full value from the source is used, and numbers in between specify a blend is used (such as for 50%). — The input bitmap image to use. The source image can be a different BitmapData object, or it can refer to the current BitmapData object. — A rectangle that defines the area of the source image to use as input. — The point within the destination image (the current BitmapData instance) that corresponds to the upper-left corner of the source rectangle. — A hexadecimal uint value by which to multiply the red channel value. — A hexadecimal uint value by which to multiply the green channel value. — A hexadecimal uint value by which to multiply the blue channel value. — A hexadecimal uint value by which to multiply the alpha transparency value. \n\n — The sourceBitmapData, sourceRect or destPoint are null. \n\n \n\n \n\n method, merging the second BitmapData pixels into the first BitmapData object, but only on a specified rectangular area: import flash.display.Bitmap; import flash.display.BitmapData; import flash.geom.Rectangle; import flash.geom.Point; var bmd1:BitmapData = new BitmapData(100, 80, true, 0xFF00FF00); var bmd2:BitmapData = new BitmapData(100, 80, true, 0xFFFF0000); var rect:Rectangle = new Rectangle(0, 0, 20, 20); var pt:Point = new Point(20, 20); var mult:uint = 0x80; // 50% bmd1.merge(bmd2, rect, pt, mult, mult, mult, mult); var bm1:Bitmap = new Bitmap(bmd1); addChild(bm1); var bm2:Bitmap = new Bitmap(bmd2); addChild(bm2); bm2.x = 110; The following example creates two BitmapData objects. Both are 100 x 80 pixels in size. The first is filled with green and the second is filled with red. The code calls themethod, merging the second BitmapData pixels into the first BitmapData object, but only on a specified rectangular area:\n\nThe Perlin noise generation algorithm interpolates and combines individual random noise functions (called octaves) into a single function that generates more natural-seeming random noise. Like musical octaves, each octave function is twice the frequency of the one before it. Perlin noise has been described as a \"fractal sum of noise\" because it combines multiple sets of noise data with different levels of detail. You can use Perlin noise functions to simulate natural phenomena and landscapes, such as wood grain, clouds, and mountain ranges. In most cases, the output of a Perlin noise function is not displayed directly but is used to enhance other images and give them pseudo-random variations. Simple digital random noise functions often produce images with harsh, contrasting points. This kind of harsh contrast is not often found in nature. The Perlin noise algorithm blends multiple noise functions that operate at different levels of detail. This algorithm results in smaller variations among neighboring pixel values. Note: The Perlin noise algorithm is named for Ken Perlin, who developed it after generating computer graphics for the 1982 film Tron. Perlin received an Academy Award for Technical Achievement for the Perlin noise function in 1997. — Frequency to use in the x direction. For example, to generate a noise that is sized for a 64 x 128 image, pass 64 for the value. — Frequency to use in the y direction. For example, to generate a noise that is sized for a 64 x 128 image, pass 128 for the value. — Number of octaves or individual noise functions to combine to create this noise. Larger numbers of octaves create images with greater detail. Larger numbers of octaves also require more processing time. — The random seed number to use. If you keep all other parameters the same, you can generate different pseudo-random results by varying the random seed value. The Perlin noise function is a mapping function, not a true random-number generation function, so it creates the same results each time from the same random seed. — A Boolean value. If the value is , the method attempts to smooth the transition edges of the image to create seamless textures for tiling as a bitmap fill. — A Boolean value. If the value is , the method generates fractal noise; otherwise, it generates turbulence. An image with turbulence has visible discontinuities in the gradient that can make it better approximate sharper visual effects like flames and ocean waves. (default = ) — A number that can be a combination of any of the four color channel values ( , , , and ). You can use the logical OR operator ( ) to combine channel values. (default = ) — A Boolean value. If the value is , a grayscale image is created by setting each of the red, green, and blue color channels to identical values. The alpha channel value is not affected if this value is set to . (default = ) — An array of points that correspond to x and y offsets for each octave. By manipulating the offset values you can smoothly scroll the layers of a perlinNoise image. Each point in the offset array affects a specific octave noise function. \n\n \n\n \n\n method to generate a red and blue watercolor effect: The following example creates a 200 x 200 pixel BitmapData object that calls themethod to generate a red and blue watercolor effect:\n\nTests pixel values in an image against a specified threshold and sets pixels that pass the test to new color values. Using the method, you can isolate and replace color ranges in an image and perform other logical operations on image pixels. The method's test logic is as follows:\n• If , then set the pixel to ;\n• Otherwise, if , then set the pixel to corresponding pixel value from . The parameter specifies the comparison operator to use for the threshold test. For example, by using \"==\" as the parameter, you can isolate a specific color value in an image. Or by using , you can set all destination pixels to be fully transparent when the source image pixel's alpha is less than 0x7F. You can use this technique for animated transitions and other effects. — The input bitmap image to use. The source image can be a different BitmapData object or it can refer to the current BitmapData instance. — A rectangle that defines the area of the source image to use as input. — The point within the destination image (the current BitmapData instance) that corresponds to the upper-left corner of the source rectangle. — One of the following comparison operators, passed as a String: \"<\", \"<=\", \">\", \">=\", \"==\", \"!=\" — The value that each pixel is tested against to see if it meets or exceeds the threshhold. (default = ) — The color value that a pixel is set to if the threshold test succeeds. The default value is 0x00000000. (default = ) — The mask to use to isolate a color component. (default = ) — If the value is , pixel values from the source image are copied to the destination when the threshold test fails. If the value is , the source image is not copied when the threshold test fails. — The number of pixels that were changed. \n\n — The sourceBitmapData, sourceRect destPoint or operation are null. — The operation string is not a valid operation \n\n \n\n \n\n method to add a blue and red pattern to one BitmapData object, and then uses the method to copy those pixels from the first BitmapData object to a second one, replacing those pixels in which the red value is greater than 0x80 (50%) with a pixel set to transparent red (0x20FF0000): import flash.display.Bitmap; import flash.display.BitmapData; import flash.display.BitmapDataChannel; import flash.geom.Point; import flash.geom.Rectangle; var bmd1:BitmapData = new BitmapData(200, 200, true, 0xFFCCCCCC); var seed:int = int(Math.random() * int.MAX_VALUE); var channels:uint = BitmapDataChannel.RED | BitmapDataChannel.BLUE; bmd1.perlinNoise(100, 80, 12, seed, false, true, channels, false, null); var bitmap1:Bitmap = new Bitmap(bmd1); addChild(bitmap1); var bmd2:BitmapData = new BitmapData(200, 200, true, 0xFFCCCCCC); var pt:Point = new Point(0, 0); var rect:Rectangle = new Rectangle(0, 0, 200, 200); var threshold:uint = 0x00800000; var color:uint = 0x20FF0000; var maskColor:uint = 0x00FF0000; bmd2.threshold(bmd1, rect, pt, \">\", threshold, color, maskColor, true); var bitmap2:Bitmap = new Bitmap(bmd2); bitmap2.x = bitmap1.x + bitmap1.width + 10; addChild(bitmap2); The following example uses themethod to add a blue and red pattern to one BitmapData object, and then uses themethod to copy those pixels from the first BitmapData object to a second one, replacing those pixels in which the red value is greater than 0x80 (50%) with a pixel set to transparent red (0x20FF0000):"
    },
    {
        "link": "https://community.adobe.com/t5/animate-discussions/bitmapdata-adobe-actionscript-3-as3-api-reference/m-p/4473785",
        "document": "Thank you, but I've already been using that for a while and it's not feasible. The synchronous executing thread will freeze a iOS application for fully a minute and a half to encode a 1024x768 image, even at 100% (least processing required) quality. It does nearly as badly for a 320x240 thumbnail.\n\nI'm wishing to use the internal API -as it's written-, not an extraneous workaround.... and do so in the hope that it will be a better alternative to this untenable problem.\n\nSidenote: I believe that the article is incorrect as to resulting filesize. Depending on quality of JPEG encoding, an encoded JPEG is nearly universally smaller than the lossless PNG, unless I'm missing something.\n\nI was hoping that by using PNG, which is less processor intensive to encode/decode, that I might get an additional performance boost, while preserving quality... at the cost of a larger filesize of course.\n\nIf anyone has had success using the encode method and the two (well, 3) encoder options classes, please let me know how you did it."
    },
    {
        "link": "https://airsdk.dev/reference/actionscript/3.0/flash/filters/BlurFilter.html",
        "document": "The BlurFilter class lets you apply a blur visual effect to display objects. A blur effect softens the details of an image. You can produce blurs that range from a softly unfocused look to a Gaussian blur, a hazy appearance like viewing an image through semi-opaque glass. When theproperty of this filter is set to low, the result is a softly unfocused look. When theproperty is set to high, it approximates a Gaussian blur filter. You can apply the filter to any display object (that is, objects that inherit from the DisplayObject class), such as MovieClip, SimpleButton, TextField, and Video objects, as well as to BitmapData objects.\n\nTo create a new filter, use the constructor . The use of filters depends on the object to which you apply the filter:\n• To apply filters to movie clips, text fields, buttons, and video, use the property (inherited from DisplayObject). Setting the property of an object does not modify the object, and you can remove the filter by clearing the property.\n• To apply filters to BitmapData objects, use the method. Calling on a BitmapData object takes the source BitmapData object and the filter object and generates a filtered image as a result.\n\nIf you apply a filter to a display object, the property of the display object is set to . If you remove all filters, the original value of is restored.\n\nThis filter supports Stage scaling. However, it does not support general scaling, rotation, and skewing. If the object itself is scaled ( and are not set to 100%), the filter effect is not scaled. It is scaled only when the user zooms in on the Stage.\n\nA filter is not applied if the resulting image exceeds the maximum dimensions. In AIR 1.5 and Flash Player 10, the maximum is 8,191 pixels in width or height, and the total number of pixels cannot exceed 16,777,215 pixels. (So, if an image is 8,191 pixels wide, it can only be 2,048 pixels high.) In Flash Player 9 and earlier and AIR 1.1 and earlier, the limitation is 2,880 pixels in height and 2,880 pixels in width. If, for example, you zoom in on a large movie clip with a filter applied, the filter is turned off if the resulting image exceeds the maximum dimensions."
    },
    {
        "link": "https://airsdk.dev/docs/development/display/filtering-display-objects/available-display-filters",
        "document": "ActionScript 3.0 includes ten filter classes that you can apply to display objects and BitmapData objects:\n\nThe first six filters are simple filters that can be used to create one specific effect, with some customization of the effect available. Those six filters can be applied using ActionScript, and can also be applied to objects in Flash Professional using the Filters panel. Consequently, even if you're applying filters using ActionScript, if you have Flash Professional you can use the visual interface to quickly try out different filters and settings to figure out how to create a desired effect.\n\nThe final four filters are available in ActionScript only. Those filters, the color matrix filter, convolution filter, displacement map filter, and shader filter, are much more flexible in the types of effects that they can be used to create. Rather than being optimized for a single effect, they provide power and flexibility. For example, by selecting different values for its matrix, the convolution filter can be used to create effects such as blurring, embossing, sharpening, finding color edges, transformations, and more.\n\nEach of the filters, whether simple or complex, can be customized using their properties. Generally, you have two choices for setting filter properties. All the filters let you set the properties by passing parameter values to the filter object's constructor. Alternatively, whether or not you set the filter properties by passing parameters, you can adjust the filters later by setting values for the filter object's properties. Most of the example code listings set the properties directlyto make the example easier to follow. Nevertheless, you could usually achieve the same result in fewer lines of code by passing the values as parameters in the filter object's constructor. For more details on the specifics of each filter, its properties and its constructor parameters, see the listings for the flash.filters package in the ActionScript 3.0 Reference for the Adobe Flash Platform."
    },
    {
        "link": "https://helpx.adobe.com/animate/using/graphic-filters.html",
        "document": ""
    },
    {
        "link": "https://bensilvis.com/as3-blurry-vision-effect",
        "document": "So I’m sitting here, having recently misplaced my glasses, and it’s become quite apparent to me that I can’t see. Somehow in the midst of the unfortunate circumstances I find the inspiration for my first tutorial:\n\nThe BlurFilter applies a blur to visual objects in your scene.\n\n It is one of AS3’s various filter effects including: Glow, Drop Shadow, and Bevel\n\n Play around with slider in the example above and you will see something similar to a Gaussian blur effect.\n\nLet’s look at some code then, shall we?\n\nThese are all the imports we should need in our package to achieve a blur effect.\n\nWhat we do here is:\n• Create an array which we add our filter to\n• Apply our filter array to a specified object\n• blurX: the amount of blur to apply in the X direction (0 – 255)\n• blurY: the amount of blur to apply in the Y direction (0 – 255)\n\nThe higher the blur values, the more blur you will see applied to your object. In the code above we set both of these values to 10. You can just as easily though blur in only the X or Y direction for a clever motion blur effect. Remember that the higher the blur value the more cpu intensive the blur becomes.\n\nNote: The way that the blur passes are processed it is more efficient to use powers of 2. (2, 4, 8, 16, etc.)\n\nYou may have been confused that my example code has quality set to BitmapFilterQuality.HIGH, while the default parameters directly above show quality as an integer of 1. The quality in itself is just a value telling Flash how many times to apply the blur. Generally the pre-made quality types are sufficient, but if you need you can replace BitmapFilterQuality with an integer (0 – 15).\n\nHere we create a new array myFilters and then push the BlurFilter we previously created into it. If we were planning on applying multiple kinds of filters to our object, we would add each of them to this array.\n\nHere we apply all of our filters (in this case the BlurFilter) to DisplayObject blurredMC.\n\nI guess I should mention that if you don’t want to deal with all this code crap, you can still apply filters to your object via the Filter’s tab. (Flash 8 and higher). You can find this at Window > Properties > Filters\n\nSo wraps up my first ever Flash tutorial! I hope it was exceedingly beneficial to you. Well, even if it wasn’t I would love to hear any constructive criticism.\n\nI’ve provided the source to the example above. Enjoy!"
    },
    {
        "link": "https://home.csulb.edu/~arezaei/ETEC570/Action%20script%203.pdf",
        "document": ""
    }
]