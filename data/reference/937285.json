[
    {
        "link": "https://stackoverflow.com/questions/67937521/which-method-to-follow-to-prevent-sql-injection-in-mysql-stored-procedure",
        "document": "hi friends i googled for this and find different methods use by others to prevent sql injection. i wrote in below stored procedure before finalising to follow specific method i want suggestion from you guys. which method should i follow.\n\nbelow is the example of my stored procedure, in which i wrote different methods\n\nresult : when i pass proper data then result set gives single user data for all then 4 method.\n\nresult : when i pass '231 OR 1=1' data then result set gives all user data for method 1 and single record for method,2,3,4. so concluded that method1 is prone to sql injection so not to follow this method, as its dynamic query & its advisable not to write dynamic query in stored procedure.\n\nmethod2, method3 worked & gave single user record, which means this query are not prone to sql injection.\n\nmethod4 is adviced by most of the developer to follow this to prevent sql injection in stored procedure. but my live project contains 20 to 30 queries(insert/update/delete) inside a stored procedure, so writing prepared statement for all is time consuming.\n\nso guide me to follow which method, method2, method3, or method4\n\nThanking you in advance, any help will be appreciated."
    },
    {
        "link": "https://learncsdesigns.medium.com/best-practices-for-preventing-sql-injection-attacks-842a30fd0342?source=rss------programming-5",
        "document": "Web developers see a lot of things threatening to harm the applications they build. One such attack targets your database and the data stored there — SQL injection. A common purpose of such an attack is to exfiltrate sensitive data from the database for personal gain. Developers overlook the importance of security when creating public, web-facing solutions, which is why this attack is so prevalent and dangerous.\n\nAn SQL injection attack involves injecting SQL queries into the application via input data from the client. SQL injection exploits can read sensitive database data, modify database data (Insert/Update/Delete), perform administration operations on the database (such as shutdown the DBMS), and in some cases issue commands to the operating system. In SQL injection attacks, SQL commands are injected into data-plane input in order to execute predefined SQL commands.\n\nA SQL Injection flaw occurs when software developers construct dynamic database queries based on string concatenation that includes user input. An SQL injection attack basically works by putting everything the user writes into an input field into a query and passing it to a database.\n• Ensure that user-supplied input containing malicious SQL does not affect the query logic.\n\nThe SQL injection occurs when you interpolate some content into an SQL query string and it modifies the syntax of your query in ways you didn’t intend. As with the classic example of SQL Injection, the value interpolated into your string completes the SQL statement and executes a second complete statement.\n\nAs an example, if ‘bugId’ is 1234; DELETE FROM bugs, the resulting SQL would be as follows:\n\nAll bugs would be deleted from the bugs table.\n\nWhen an attacker can manipulate your SQL statements, SQL Injection becomes more dangerous. Your application may allow users to change their passwords, for instance.\n\nYour SQL statement can be exploited by a clever attacker who knows how the request parameters are used.\n\nAfter interpolating the string from the ‘userId’ parameter into your SQL expression, the string has changed the syntax. It now changes passwords for every account in the database, not just one.\n\nBy changing the syntax of the SQL statement before it is parsed, SQL Injection works. You run the risk of SQL Injection if you insert dynamic portions before the statement is parsed.\n\nYou should leave parameter placeholders in your SQL string rather than interpolating dynamic values. As you execute the prepared query, provide a parameter value.\n\nA stored procedure is another method that many software developers claim is proof against SQL Injection vulnerabilities. Stored procedures typically contain fixed SQL statements, parsed when they are defined. Dynamic SQL can, however, be used in stored procedures in an unsafe manner. Dynamic SQL in stored procedures is as safe as dynamic SQL in application code.\n\nIt’s not legal to use bind variables in certain parts of SQL queries, such as the names of tables and columns and sort order indicators (ASC or DESC). The best defense in such cases is input validation or query redesign.\n\nSQL queries can be protected from accidental unmatched quote characters by escaping any quote characters to prevent them from becoming the end of the quoted string. Standard SQL allows you to make a literal quote character by using two quote characters.\n\nThe following quote character can also be escaped with a backslash in most databases.\n\nAlmost all database applications build SQL statements dynamically. Concatenating strings together or interpolating variables into strings can expose your application to SQL Injection attacks if you build any portion of an SQL statement in this manner.\n• All dynamic content used in your SQL statements should be traced back to its source. Look for data that originates from an external source, including user input, files, the environment, web services, third-party code, or even a database string.\n• Any external content should be regarded as potentially hazardous. Filters, validators, and mapping arrays can be used to transform untrusted content.\n• Utilize robust escaping functions or query parameters to integrate external data into your SQL statements.\n• Check your stored procedures and other places where dynamic SQL statements may be found."
    },
    {
        "link": "https://globaldots.com/resources/blog/how-to-prevent-sql-injection-attacks",
        "document": "Open source projects are the embodiment of the core philosophy: ‘free internet and technology for everyone around the globe’. They can be created, changed and distributed to anyone by anyone and for any purpose. Contributing to an open source projects is an endorsement of this philosophy, that promotes digital literacy in technological and non-technological communities. […]"
    },
    {
        "link": "https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html",
        "document": "This cheat sheet will help you prevent SQL injection flaws in your applications. It will define what SQL injection is, explain where those flaws occur, and provide four options for defending against SQL injection attacks. SQL Injection attacks are common because:\n• SQL Injection vulnerabilities are very common, and\n• The application's database is a frequent target for attackers because it typically contains interesting/critical data.\n\nAttackers can use SQL injection on an application if it has dynamic database queries that use string concatenation and user supplied input. To avoid SQL injection flaws, developers need to:\n• Prevent malicious SQL input from being included in executed queries.\n\nThere are simple techniques for preventing SQL injection vulnerabilities and they can be used with practically any kind of programming language and any type of database. While XML databases can have similar problems (e.g., XPath and XQuery injection), these techniques can be used to protect them as well.\n\nA common SQL injection flaw in Java is below. Because its unvalidated \"customerName\" parameter is simply appended to the query, an attacker can enter SQL code into that query and the application would take the attacker's code and execute it on the database.\n• Option 1: Use of Prepared Statements (with Parameterized Queries)\n\nWhen developers are taught how to write database queries, they should be told to use prepared statements with variable binding (aka parameterized queries). Prepared statements are simple to write and easier to understand than dynamic queries, and parameterized queries force the developer to define all SQL code first and pass in each parameter to the query later.\n\nIf database queries use this coding style, the database will always distinguish between code and data, regardless of what user input is supplied. Also, prepared statements ensure that an attacker cannot change the intent of a query, even if SQL commands are inserted by an attacker.\n\nIn the safe Java example below, if an attacker were to enter the userID as , the parameterized query would look for a username that literally matches the entire string . Thus, the database would be protected against injections of malicious SQL code.\n\nThe following code example uses a , Java's implementation of a parameterized query, to execute the same database query.\n\nIn .NET, the creation and execution of the query doesn't change. Just pass the parameters to the query using the call as shown below.\n\nWhile we have shown examples in Java and .NET, practically all other languages (including Cold Fusion and Classic ASP) support parameterized query interfaces. Even SQL abstraction layers, like the Hibernate Query Language (HQL) with the same type of injection problems (called HQL Injection) support parameterized queries as well:\n\nIf you need examples of prepared queries/parameterized languages, including Ruby, PHP, Cold Fusion, Perl, and Rust, see the Query Parameterization Cheat Sheet or this site.\n\nGenerally, developers like prepared statements because all the SQL code stays within the application, which makes applications relatively database independent.\n\nThough stored procedures are not always safe from SQL injection, developers can use certain standard stored procedure programming constructs. This approach has the same effect as using parameterized queries, as long as the stored procedures are implemented safely (which is the norm for most stored procedure languages).\n\nIf stored procedures are needed, the safest approach to using them requires the developer to build SQL statements with parameters that are automatically parameterized, unless the developer does something largely out of the norm. The difference between prepared statements and stored procedures is that the SQL code for a stored procedure is defined and stored in the database itself, then called from the application. Since prepared statements and safe stored procedures are equally effective in preventing SQL injection, your organization should choose the approach that makes the most sense for you.\n\nOccasionally, stored procedures can increase risk when a system is attacked. For example, on MS SQL Server, you have three main default roles: , and . Before stored procedures came into use, DBAs would give or rights to the webservice's user, depending on the requirements.\n\nHowever, stored procedures require execute rights, a role not available by default. In some setups where user management has been centralized, but is limited to those 3 roles, web apps would have to run as so stored procedures could work. Naturally, that means that if a server is breached, the attacker has full rights to the database, where previously, they might only have had read-access.\n\nThe following code example uses Java's implementation of the stored procedure interface ( ) to execute the same database query. The stored procedure has to be predefined in the database and use the same functionality as the query above.\n\nThe following code example uses a , .NET's implementation of the stored procedure interface, to execute the same database query. The stored procedure must be predefined in the database and use the same functionality as the query defined above.\n\nIf you are faced with parts of SQL queries that can't use bind variables, such as table names, column names, or sort order indicators (ASC or DESC), input validation or query redesign is the most appropriate defense. When table or column names are needed, ideally those values come from the code and not from user parameters.\n\nWARNING: Using user parameter values to target table or column names is a symptom of poor design and a full rewrite should be considered if time allows. If that is not possible, developers should map the parameter values to the legal/expected table or column names to make sure unvalidated user input doesn't end up in the query.\n\nIn the example below, since is identified as one of the legal and expected values for a table name in this query, it can be directly appended to the SQL query. Keep in mind that generic table validation functions can lead to data loss if table names are used in queries where they are not expected.\n\nWhen we say a stored procedure is \"implemented safely,\" that means it does not include any unsafe dynamic SQL generation. Developers do not usually generate dynamic SQL inside stored procedures. However, it can be done, but should be avoided.\n\nIf it can't be avoided, the stored procedure must use input validation or proper escaping, as described in this article, to make sure that all user supplied input to the stored procedure can't be used to inject SQL code into the dynamically generated query. Auditors should always look for uses of , or within SQL Server stored procedures. Similar audit guidelines are necessary for similar functions for other vendors.\n\nFor something simple like a sort order, it is best if the user supplied input is converted to a boolean, and then that boolean is used to select the safe value to append to the query. This is a very standard need in dynamic query creation.\n\nAny time user input can be converted to a non-String, like a date, numeric, boolean, enumerated type, etc. before it is appended to a query, or used to select a value to append to the query, this ensures it is safe to do so.\n\nInput validation is also recommended as a secondary defense in ALL cases, even when using bind variables as discussed earlier in this article. More techniques on how to implement strong input validation is described in the Input Validation Cheat Sheet.\n\nIn this approach, the developer will escape all user input before putting it in a query. It is very database specific in its implementation. This methodology is frail compared to other defenses, and we CANNOT guarantee that this option will prevent all SQL injections in all situations.\n\nIf an application is built from scratch or requires low risk tolerance, it should be built or re-written using parameterized queries, stored procedures, or some kind of Object Relational Mapper (ORM) that builds your queries for you.\n\nBeyond adopting one of the four primary defenses, we also recommend adopting all of these additional defenses to provide defense in depth. These additional defenses are:\n\nTo minimize the potential damage of a successful SQL injection attack, you should minimize the privileges assigned to every database account in your environment. Start from the ground up to determine what access rights your application accounts require, rather than trying to figure out what access rights you need to take away.\n\nMake sure that accounts that only need read access are only granted read access to the tables they need access to. DO NOT ASSIGN DBA OR ADMIN TYPE ACCESS TO YOUR APPLICATION ACCOUNTS. We understand that this is easy, and everything just \"works\" when you do it this way, but it is very dangerous.\n\nSQL injection is not the only threat to your database data. Attackers can simply change the parameter values from one of the legal values they are presented with, to a value that is unauthorized for them, but the application itself might be authorized to access. As such, minimizing the privileges granted to your application will reduce the likelihood of such unauthorized access attempts, even when an attacker is not trying to use SQL injection as part of their exploit.\n\nWhile you are at it, you should minimize the privileges of the operating system account that the DBMS runs under. Don't run your DBMS as root or system! Most DBMSs run out of the box with a very powerful system account. For example, MySQL runs as system on Windows by default! Change the DBMS's OS account to something more appropriate, with restricted privileges.\n\nDetails Of Least Privilege When Developing¶\n\nIf an account only needs access to portions of a table, consider creating a view that limits access to that portion of the data and assigning the account access to the view instead of the underlying table. Rarely, if ever, grant create or delete access to database accounts.\n\nIf you adopt a policy where you use stored procedures everywhere, and don't allow application accounts to directly execute their own queries, then restrict those accounts to only be able to execute the stored procedures they need. Don't grant them any rights directly to the tables in the database.\n\nThe designers of web applications should avoid using the same owner/admin account in the web applications to connect to the database. Different DB users should be used for different web applications.\n\nIn general, each separate web application that requires access to the database should have a designated database user account that the application will use to connect to the DB. That way, the designer of the application can have good granularity in the access control, thus reducing the privileges as much as possible. Each DB user will then have select access to only what it needs, and write-access as needed.\n\nAs an example, a login page requires read access to the username and password fields of a table, but no write access of any form (no insert, update, or delete). However, the sign-up page certainly requires insert privilege to that table; this restriction can only be enforced if these web apps use different DB users to connect to the database.\n\nYou can use SQL views to further increase the granularity of access by limiting the read access to specific fields of a table or joins of tables. It could have additional benefits.\n\nFor example, if the system is required (perhaps due to some specific legal requirements) to store the passwords of the users, instead of salted-hashed passwords, the designer could use views to compensate for this limitation. They could revoke all access to the table (from all DB users except the owner/admin) and create a view that outputs the hash of the password field and not the field itself.\n\nAny SQL injection attack that succeeds in stealing DB information will be restricted to stealing the hash of the passwords (could even be a keyed hash), since no DB user for any of the web applications has access to the table itself.\n\nIn addition to being a primary defense when nothing else is possible (e.g., when a bind variable isn't legal), input validation can also be a secondary defense used to detect unauthorized input before it is passed to the SQL query. For more information please see the Input Validation Cheat Sheet. Proceed with caution here. Validated data is not necessarily safe to insert into SQL queries via string building.\n\nThe following articles describe how to exploit different kinds of SQL injection vulnerabilities on various platforms (that this article was created to help you avoid):\n• OWASP Developers Guide article on how to avoid SQL injection vulnerabilities\n• OWASP Cheat Sheet that provides numerous language specific examples of parameterized queries using both Prepared Statements and Stored Procedures\n• The Bobby Tables site (inspired by the XKCD webcomic) has numerous examples in different languages of parameterized Prepared Statements and Stored Procedures\n\nHow to Review Code for SQL Injection Vulnerabilities:\n• OWASP Code Review Guide article on how to Review Code for SQL Injection Vulnerabilities\n\nHow to Test for SQL Injection Vulnerabilities:\n• OWASP Testing Guide article on how to Test for SQL Injection Vulnerabilities"
    },
    {
        "link": "https://dba.stackexchange.com/questions/127/do-stored-procedures-prevent-sql-injection",
        "document": "Stack Exchange network consists of 183 Q&A communities including Stack Overflow, the largest, most trusted online community for developers to learn, share their knowledge, and build their careers."
    },
    {
        "link": "https://percona.com/blog/dynamic-sql-workaround-in-mysql-prepared-statements",
        "document": "Dynamic SQL is a desirable feature that allows developers to construct and execute SQL statements dynamically at runtime. While MySQL lacks built-in support for dynamic SQL, this article presents a workaround using prepared statements. We will explore leveraging prepared statements to achieve dynamic query execution, parameterized queries, and dynamic table and column selection.\n• Reduced Parsing Overhead: Prepared statements minimize the overhead of parsing SQL queries each time they are executed. This is especially advantageous in database applications that process large volumes of nearly identical statements, with only changes to literal or variable values. By preparing the query once and executing it multiple times with different parameters, parsing time and resources are saved, resulting in improved performance.\n• Bandwidth Optimization: When using prepared statements, you only need to send the parameter values to the server during each execution, not the entire query. This reduces the amount of data transmitted over the network, optimizing bandwidth usage and improving data transfer efficiency, particularly in high-traffic applications.\n• SQL Injection Protection: Prepared statements safeguard against SQL injection attacks. As parameter values are bound separately from the SQL query, the need for explicit escaping of user input is eliminated. This ensures that unescaped SQL quote and delimiter characters in parameter values cannot disrupt the query’s structure, making the application more secure against SQL injection vulnerabilities.\n\nBut today, we’re going to use it for something else entirely than its mission.\n\nExample usage: Let’s consider a simple example where we want to construct a dynamic SELECT statement based on a user-defined table name and value:\n\nIn this example, we use the CONCAT function to construct the dynamic SQL statement. The table name and value are stored in variables and concatenated into the SQL string.\n• Prepared statements can be used both as a standalone SQL statement and inside stored procedures, providing flexibility in different contexts.\n• Support for Various SQL Statements: SQL statements can be executed using prepared statements, including statements like DROP DATABASE, TRUNCATE TABLE, FLUSH TABLES, and KILL. This allows for dynamic execution of diverse operations.\n• Usage of Stored Procedure Variables: Stored procedure variables can be incorporated into the dynamic expression, enabling dynamic SQL based on runtime values.\n\nLet’s look at another scenario:\n\nIn this case, the prepared statement is used to dynamically construct the KILL statement to terminate all queries associated with a specific user.\n\nYou might use prepared statements to make dynamic queries, but dynamic queries can definitely make debugging more challenging. You should consider implementing some additional testing and error handling to help mitigate this issue. That could help you catch any issues with the dynamic queries early on in the development process.\n\nPercona Monitoring and Management is a best-of-breed open source database monitoring solution. It helps you reduce complexity, optimize performance, and improve the security of your business-critical database environments, no matter where they are located or deployed."
    },
    {
        "link": "https://dev.mysql.com/doc/en/sql-prepared-statements.html",
        "document": "MySQL 8.4 provides support for server-side prepared statements. This support takes advantage of the efficient client/server binary protocol. Using prepared statements with placeholders for parameter values has the following benefits:\n\nThe following sections provide an overview of the characteristics of prepared statements:\n\nYou can use server-side prepared statements through client programming interfaces, including the MySQL C API client library for C programs, MySQL Connector/J for Java programs, and MySQL Connector/NET for programs using .NET technologies. For example, the C API provides a set of function calls that make up its prepared statement API. See C API Prepared Statement Interface. Other language interfaces can provide support for prepared statements that use the binary protocol by linking in the C client library, one example being the extension, available in PHP 5.0 and later.\n\nAn alternative SQL interface to prepared statements is available. This interface is not as efficient as using the binary protocol through a prepared statement API, but requires no programming because it is available directly at the SQL level:\n\nSQL syntax for prepared statements is intended to be used for situations such as these:\n\nSQL syntax for prepared statements is based on three SQL statements:\n\nThe following examples show two equivalent ways of preparing a statement that computes the hypotenuse of a triangle given the lengths of the two sides.\n\nThe first example shows how to create a prepared statement by using a string literal to supply the text of the statement:\n\nThe second example is similar, but supplies the text of the statement as a user variable:\n\nHere is an additional example that demonstrates how to choose the table on which to perform a query at runtime, by storing the name of the table as a user variable:\n\nA prepared statement is specific to the session in which it was created. If you terminate a session without deallocating a previously prepared statement, the server deallocates it automatically.\n\nA prepared statement is also global to the session. If you create a prepared statement within a stored routine, it is not deallocated when the stored routine ends.\n\nTo guard against too many prepared statements being created simultaneously, set the system variable. To prevent the use of prepared statements, set the value to 0.\n\nThe following SQL statements can be used as prepared statements:\n\nOther statements are not supported.\n\nFor compliance with the SQL standard, which states that diagnostics statements are not preparable, MySQL does not support the following as prepared statements:\n\nGenerally, statements not permitted in SQL prepared statements are also not permitted in stored programs. Exceptions are noted in Section 27.8, “Restrictions on Stored Programs”.\n\nMetadata changes to tables or views referred to by prepared statements are detected and cause automatic repreparation of the statement when it is next executed. For more information, see Section 10.10.3, “Caching of Prepared Statements and Stored Programs”.\n\nPlaceholders can be used for the arguments of the clause when using prepared statements. See Section 15.2.13, “SELECT Statement”.\n\nIn prepared statements used with and , placeholder support for and parameters is available beginning with MySQL 8.4. See Section 15.2.1, “CALL Statement”, for an example and a workaround for earlier versions. Placeholders can be used for parameters regardless of version.\n\nSQL syntax for prepared statements cannot be used in nested fashion. That is, a statement passed to cannot itself be a , , or statement.\n\nSQL syntax for prepared statements is distinct from using prepared statement API calls. For example, you cannot use the C API function to prepare a , , or statement.\n\nSQL syntax for prepared statements can be used within stored procedures, but not in stored functions or triggers. However, a cursor cannot be used for a dynamic statement that is prepared and executed with and . The statement for a cursor is checked at cursor creation time, so the statement cannot be dynamic.\n\nSQL syntax for prepared statements does not support multi-statements (that is, multiple statements within a single string separated by characters).\n\nTo write C programs that use the SQL statement to execute stored procedures that contain prepared statements, the flag must be enabled. This is because each returns a result to indicate the call status, in addition to any result sets that might be returned by statements executed within the procedure.\n\ncan be enabled when you call , either explicitly by passing the flag itself, or implicitly by passing (which also enables ). For additional information, see Section 15.2.1, “CALL Statement”."
    },
    {
        "link": "https://stackoverflow.com/questions/23545525/mysql-stored-procedure-prepared-statement-dynamic-sql-parameterized",
        "document": "The statement must be given a fixed list of arguments, so you'll have to prepare and execute the statement in an block.\n\nI don't know any way to solve this in the limited scope of MySQL stored procedure language. To me, it's another good reason not to use dynamic SQL in stored procedures.\n\nI see... you could use a statement instead of an , but you actually have 27 = 128 potential different cases for query strings, because I assume any of those 7 modules could either be searched or not.\n\nAn alternative that would allow you to use query parameters is to forget about using , and instead write the procedure in such a way that runs up to 7 separate queries and returns all of them as multiple result sets. That's something that stored procedures are intended to do. But you have to write code in your PHP layer to fetch each result set in turn. That is, loop over the result sets, and within that loop, loop over the rows of the current result set. See example at PDO::nextRowset() or mysqli::next_result().\n\nNo, you're not safe if you do that! Using a query parameter in PHP to pass a string to the is useless for protecting against SQL injection, if you then concatenate that parameter value into another string inside the procedure and do a dynamic SQL parse-and-execute. Using query parameters does not make parameter values \"safe,\" they just separate those values from the SQL parse phase.\n\nYou're safer if you use MySQL's built-in function QUOTE() when concatenating the strings. does escaping of special characters, just like . Except it's slightly different, because it also produces the single-quotes delimiting the string, like PDO::quote() does.\n\nUpdate: one more alternative: use to add more subqueries, and keep count of the modules. Then use a to execute the prepared query with a different number of parameters based on the accumulated count."
    },
    {
        "link": "https://stackoverflow.com/questions/74466924/best-practice-of-executing-dynamic-sql-strings-via-prepared-statements-and-proce",
        "document": "Background: I am building a Springboot+mySQL app that uses Spring Data JPA native queries (i.e. to retrieve database data.\n\nWe have to use the same SQL in every query we write to enable certain functionality (this can be seen in the example below). And wanted a way to remove this duplicate SQL and instead only declare it once. An option presented was to pass a dynamic SQL string into a stored procedure and then build a prepared statement by concatenating this dynamic SQL string with our static shared SQL string (show in example below).\n\nQuestion: This doesn't seem like a good idea to me, but I am not knowledgeable enough about databases to given the exact technical reasons. Is the below example safe, reasonable, and best-practice? Are there ways to mitigate issues with this approach, or are there other approaches to use instead?"
    },
    {
        "link": "https://dba.stackexchange.com/questions/42123/stored-procedure-and-prepared-statements",
        "document": "Stack Exchange network consists of 183 Q&A communities including Stack Overflow, the largest, most trusted online community for developers to learn, share their knowledge, and build their careers."
    }
]