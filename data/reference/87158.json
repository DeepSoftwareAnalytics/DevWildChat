[
    {
        "link": "https://docs.oracle.com/javase/8/docs/api/java/io/BufferedReader.html",
        "document": "Reads text from a character-input stream, buffering characters so as to provide for the efficient reading of characters, arrays, and lines.\n\nThe buffer size may be specified, or the default size may be used. The default is large enough for most purposes.\n\nIn general, each read request made of a Reader causes a corresponding read request to be made of the underlying character or byte stream. It is therefore advisable to wrap a BufferedReader around any Reader whose read() operations may be costly, such as FileReaders and InputStreamReaders. For example,\n\nwill buffer the input from the specified file. Without buffering, each invocation of read() or readLine() could cause bytes to be read from the file, converted into characters, and then returned, which can be very inefficient.\n\nPrograms that use DataInputStreams for textual input can be localized by replacing each DataInputStream with an appropriate BufferedReader."
    },
    {
        "link": "https://digitalocean.com/community/tutorials/java-read-file-line-by-line",
        "document": "In this article, you will learn about different ways to use Java to read the contents of a file line-by-line. This article uses methods from the following Java classes: , , , and .\n\nYou can use the method from to read a file line-by-line to String. This method returns when the end of the file is reached.\n\nHere is an example program to read a file line-by-line with :\n\nContinue your learning with the API Doc (Java SE 8).\n\nYou can use the class to open a file and then read its content line-by-line.\n\nHere is an example program to read a file line-by-line with :\n\nContinue your learning with the API Doc (Java SE 8).\n\nis a utility class that contains various useful methods. The method can be used to read all the file lines into a list of strings.\n\nHere is an example program to read a file line-by-line with :\n\nContinue your learning with the API Doc (Java SE 8).\n\nYou can use to open a file in read mode and then use its method to read a file line-by-line.\n\nHere is an example program to read a file line-by-line with :\n\nContinue your learning with the API Doc (Java SE 8).\n\nIf a file is stored in an encoding other than UTF-8, you should specify the correct encoding when reading it.\n\nFor massive files (GB-sized logs or datasets), Java’s NIO API ( ) is a high-performance alternative to standard file reading.\n\nHere is an example:\n\nUsing significantly reduces memory usage compared to loading a file into memory at once.\n\nFor more advanced file handling techniques, you can check out this tutorial on Java Files - java.nio.file.Files Class.\n\n1. How to read a file in Java using ?\n\nTo read a file in Java using , you can create an instance of and read character data from the file. However, is not the most efficient option as it does not buffer the input. A better alternative is to wrap it inside a .\n\nFor more efficient file reading, consider using BufferedReader instead.\n\n2. How to read a file line by line in Java?\n\nThe most common way to read a file line by line in Java is by using . This method is memory-efficient and performs well for large files.\n\nFor additional file handling methods, check out this tutorial on Java File Handling.\n\n3. What is the most efficient way to read a large file in Java?\n\nWhen dealing with large files, reading the entire file into memory is inefficient. Instead, use streams or Java NIO (Non-blocking I/O) APIs like for better performance.\n\nUsing BufferedReader with Streams (Efficient for Large Files)\n\nUsing (Best for Extremely Large Files)\n\nFor extremely large files, consider memory-mapped files or for improved performance as described in the section above.\n\n4. How to handle file reading errors in Java?\n\nError handling is crucial to avoid crashes due to file not found, permissions issues, or encoding mismatches.\n\n5. What is the difference between and ?\n\nTo handle large text files efficiently, always prefer over . Learn more about efficient file operations in tutorial on Java read text file.\n\nIn this comprehensive guide, you learned various methods to read the contents of a file line-by-line in Java, including the use of , , , and . You also learned how to handle file reading errors, the difference between and , and how to efficiently handle large files using or memory-mapped files.\n\nContinue your learning with more Java tutorials.\n\nYou can also refer to these tutorials on:"
    },
    {
        "link": "https://geeksforgeeks.org/difference-between-bufferedreader-and-filereader-in-java",
        "document": "BufferedReader and FileReader both classes are used to read data from a given character stream. Both of them have some pros and some cons. In this article, we will discuss the differences between them. Though the most important difference is in the way they work, but we will discuss the other details also.\n\nA buffer is a small portion of the device memory storage used to temporarily store some amount of data. Usually, Buffers use the RAM of the device to store the temporary data, and hence, accessing data from the buffer is much faster than accessing the same amount of data from the hard drive.\n\nDifferences between BufferedReader and FileReader are illustrated over and discussed over major parameters taken into consideration as follows:\n\nFileReader is used to read a file from a disk drive whereas BufferedReader is not bound to only reading files. It can be used to read data from any character stream. FileReader class provides two constructors:\n• FileReader(File file): It takes a File object that represents a file in your disk and creates a new FileReader instance.\n• FileReader(FileDescriptor fd) : Creates a new FileReader, given the FileDescriptor to read from.\n• FileReader(String fileName): Takes the name of the file as the only parameter and creates a new FileReader instance to read the file.\n• BufferedReader(Reader rd): It uses a Reader to read data from the character input stream and creates a default sized input buffer.\n• BufferedReader(Reader rd, int size): Takes two parameters:\n• First: A Reader that is used to read the input stream data\n• Second: The size of the input buffer. It creates a new BufferedReader with the given sized input buffer.\n\nAs seen, BufferedReader accepts any type of Reader(StringReader, FileReader, etc.) and hence capable of reading from any character input stream. Whereas, FileReader is capable of reading characters from files only. Usually, we wrap a FileReader with BufferedReader to read characters from files.\n\nBufferedReader is much more efficient than FileReader in terms of performance. FileReader directly reads the data from the character stream that originates from a file. Each time, it reads a character, it directly accesses the disk drive and every time it takes some time for the disk drive to position the read head correctly which makes it very inefficient.\n\nWhereas BufferedReader creates an input buffer and allows the input to be read from the hard drive in large chunks of data rather than a byte at a time, resulting in a huge improvement in performance. The default buffer size is 8Kb( which is enough in most cases) though it can be customized. BufferedReader reads lots of data at a time and stores it in the created buffer memory. When java.io.BufferedReader#read() is called, it reads the data from the memory buffer. When data is not available in the buffer, it makes a corresponding read request of the underlying character stream and loads lots of data into the created buffer. As a result, we do not have to access the hard drive directly when reading each character, we can read from the buffer memory which is fast and much more efficient.\n\nAs BufferedReader uses buffer internally, this class is much faster than FileReader. BufferReader doesn’t need to access the hard drive every time like FileReader and hence faster.\n\nIn most cases, you would like to read a line at a time rather than reading a character at a time and only the BufferedReader provides a readLine() method that reads a whole line at a time. Simply, the given Reader(FileReader in this case) reads the characters and stores them in the buffer. When the java.io.BufferedReader#readLine() method is called, characters of a line stored in the buffer, are returned as a String. It saves lots of time and hence is faster than FileReader#read() method. Note that, BufferedReader is able to read a whole line at a time only because it uses a buffer memory, it can store the characters of a line in the buffer and read all the characters together directly from the buffer.\n\nOutput: From the file ‘geeks.txt’ in the local directory used in the above program\n\nBufferedReader uses a FileReader to read data from this file. BufferedReader creates a input buffer with the given size (if no such size given then the default size is 8Kb). If we use only the FileReader, then it reads one character at a time by directly accessing the disk drive. Each time it reads the data, it takes some time for the disk drive to position the read head correctly which makes it very inefficient. Accessing the disk drive every time for reading a single character affects the performance. Whereas, BufferedReader creates a buffer, and reads large amount of data using the given FileReader and loads it into a input buffer in the memory. Each time you want to read the file data, you can read it from the buffer( you don’t have to directly access the disk drive every time) and hence is faster than FileReader.\n\nExample 2: Reading lines using only the FileReader\n\nOutput: From the file ‘geeks.txt’ in the local directory used in the above program\n\nBufferedReader uses a FileReader to read data from this file. BufferedReader creates a input buffer with the given size (if no such size given then the default size is 8Kb). If we use only the FileReader, then it reads one character at a time by directly accessing the disk drive. Each time it reads the data, it takes some time for the disk drive to position the read head correctly which makes it very inefficient. Accessing the disk drive every time for reading a single character affects the performance. Whereas, BufferedReader creates a buffer, and reads large amount of data using the given FileReader and loads it into a input buffer in the memory. Each time you want to read the file data, you can read it from the buffer( you don’t have to directly access the disk drive every time) and hence is much more efficient than FileReader.\n• The time taken for the reading process might vary in your system, but the fact is that BufferedReader works faster and more efficiently than the FileReader.\n• If you want a good performance, then you would you use both of them together. BufferedReader itself does not read data from an input stream, it uses a Reader(usually a FileReader) that interacts with the native system APIs to read characters from the given input source( A file in case of a FileReader ). The BufferedReader class just adds a buffer to the character stream and reads characters from the buffer, not directly from the input source. So, you can read a file using only the FileReader because it has access to the hard drive to read data from. But you can not use “only BufferedReader” to read a file, as it doesn’t have the access to the hard drive, you have to provide a Reader( a FileReader) that has the access."
    },
    {
        "link": "https://w3schools.com/java/java_files_read.asp",
        "document": "In the previous chapter, you learned how to create and write to a file.\n\nIn the following example, we use the class to read the contents of the text file we created in the previous chapter:\n\nTo get more information about a file, use any of the methods:\n\nNote: There are many available classes in the Java API that can be used to read and write files in Java: , etc. Which one to use depends on the Java version you're working with and whether you need to read bytes or characters, and the size of the file/lines etc."
    },
    {
        "link": "https://stackoverflow.com/questions/9648811/specific-difference-between-bufferedreader-and-filereader",
        "document": "First, You should understand \"streaming\" in Java because all \"Readers\" in Java are built upon this concept.\n\nFile streaming is carried out by the FileInputStream object in Java.\n\nThis object reads a byte(8-bits) at a time and writes it to the given file.\n\nA practical useful application of it would be to work with raw binary/data files, such as images or audio files (use AudioInputStream instead of FileInputStream for audio files). On the other hand, it is very inconvenient and slower for text files, because of looping through a byte at a time, then do some processing and store the processed byte back is tedious and time-consuming.\n\nYou also need to provide the character set of the text file, i.e if the characters are in Latin or Chinese, etc. Otherwise, the program would decode and encode 8-bits at a time and you'd see weird chars printed on the screen or written in the output file (if a char is more than 1 byte long, i.e. non-ASCII characters).\n\nThis is just a fancy way of saying \"File streaming\" with inclusive charset support (i.e no need to define the charset, like earlier).\n\nThe FileReader class is specifically designed to deal with the text files. As you've seen earlier, the file streaming is best to deal with raw binary data, but for the sake of text, it is not so efficient.\n\nSo the Java-dudes added the FileReader class, to deal specifically with the text files. It reads 2 bytes (or 4 bytes, depends on the charset) at a time. A remarkably huge improvement over the preceding FileInputStream!!\n\nso the streaming operation is like this,\n\nPlease note, Both classes use an integer variable to store the value retrieved from the input file (so every char is converted into an integer while fetching and back to the char while storing).\n\nThe only advantage here is that this class deals only with text files, so you don't have to specify the charset and a few other properties. It provides an out-of-the-box solution, for most of the text files processing cases. It also supports internationalization and localization.\n\nBut again it's still very slow (Imaging reading 2 bytes at a time and looping through it!).\n\nTo tackle the problem of continuous looping over a byte or 2. The Java-dudes added another spectacular functionality. \"To create a buffer of data, before processing.\"\n\nThe concept is pretty much alike when a user streams a video on YouTube. A video is buffered before playing, to provide flawless video watching experience. (Tho, the browser keeps buffering until the whole video is buffered ahead of time.) The same technique is used by the BufferedReader class.\n\nA BufferedReader object takes a FileReader object as an input which contains all the necessary information about the text file that needs to be read. (such as the file path and charset.)\n\nWhen the \"read\" instruction is given to the BufferedReader object, it uses the FileReader object to read the data from the file. When an instruction is given, the FileReader object reads 2 (or 4) bytes at a time and returns the data to the BufferedReader and the reader keeps doing that until it hits '\n\n' or '\\r\n\n' (The end of the line symbol). Once a line is buffered, the reader waits patiently, until the instruction to buffer the next line is given.\n\nMeanwhile, The BufferReader object creates a special memory place (On the RAM), called \"Buffer\", and stores all the fetched data from the FileReader object.\n\nNow here, instead of reading 2 bytes at a time, a whole line is fetched and stored in the RAM somewhere, and when you are done with processing the data, you can store the whole line back to the hard disk. So it makes the process run way faster than doing 2 bytes a time.\n\nBut again, why do we need to pass FileReader object to the BufferReader? Can't we just say \"buffer this file\" and the BufferReader would take care of the rest? wouldn't that be sweet?\n\nWell, the BufferReader class is created in a way that it only knows how to create a buffer and to store incoming data. It is irrelevant to the object from where the data is coming. So the same object can be used for many other input streams than just text files.\n\nSo being said that, When you provide the FileReader object as an input, it buffers the file, the same way if you provide the InputStreamReader as an object, it buffers the Terminal/Console input data until it hits a newline symbol. such as,\n\nThis way, you can read (or buffer) multiple streams with the same BufferReader class, such as text files, consoles, printers, networking data etc, and all you have to remember is,"
    },
    {
        "link": "https://stackoverflow.com/questions/18451232/eofexception-how-to-handle",
        "document": "I am using a simple Java Program from the Java tutorials's Data Streams Page, and at runtime, it keeps on showing . I was wondering if this was normal, as the reader has to come to the end of the file eventually.\n\nIt compiles fine, but the output is:\n\nFrom the Java tutorials's Data Streams Page, it says:\n\nSo, does this mean that catching is normal, so just catching it and not handling it is fine, meaning that the end of file is reached?\n\nIf it means I should handle it, please advise me on how to do it.\n\nFrom the suggestions, I've fixed it by using for the loop condition.\n\nOr, I could do nothing to handle the exception, because it's fine."
    },
    {
        "link": "https://rollbar.com/blog/java-eofexception",
        "document": "The java.io.EOFException is a checked exception in Java that occurs when an end of file or end of stream is reached unexpectedly during input. It's Java's way of letting you know, \"Hey, I was expecting more data here, but there's nothing left to read!\"\n\nSince EOFException is a checked exception, it must be explicitly handled in methods that can throw this exception - either by using a try-catch block or by throwing it up the chain using the throws clause.\n\nHere are some common scenarios that can lead to an EOFException:\n\nWhen using classes like DataInputStream, ObjectInputStream, or RandomAccessFile, if you attempt to read more data than is available, an EOFException will be thrown. For example:\n• Trying to read an int (4 bytes) when only 2 bytes are left in the stream.\n• Attempting to read a UTF-8 encoded string, but reaching the end of the stream before the full string is read.\n\nIn network communications or when reading compressed data (using ZipInputStream or GZIPInputStream), the stream might end prematurely due to connection issues or corrupted data.\n\nWhen using ObjectInputStream to deserialize objects, an EOFException can occur if the stream ends before all expected object data is read.\n\nIf you're using different read methods than those used to write the data, you might encounter an EOFException. For instance, writing data as bytes but trying to read it as integers.\n\nIf a file is truncated (shortened) while your program is reading from it, this can lead to an EOFException.\n\nIt's important to note that not all end-of-file situations result in an EOFException. Many other input operations return a special value (often -1 or null) on end of file or stream rather than throwing an exception. The methods that throw EOFException are typically those that expect to read a specific amount or type of data and cannot fulfill this expectation.\n\nHere's an example of a EOFException thrown when trying to read all characters from an input file:\n\nIn the above example, the contents of a file with the name myfile.txt are read in an infinite loop using the DataInputStream.readChar() method. When the readChar() method is called at the end of the file, an EOFException is thrown:\n\nSince EOFException is a checked exception, a try-catch block should be used to handle it. The try block should contain the lines of code that can throw the exception and the catch block should catch and handle the exception appropriately.\n\nThe above example can be updated to handle the EOFException in a try-catch block:\n\nHere, the inputStream.readChar() method call is placed in a try block and the EOFException is caught inside the catch block. When an EOFException occurs at the end of the file, it is handled and a break statement is used to break out of the loop.\n\nIt’s totally normal and expected to use try-catch blocks to detect the end of a file or stream when using classes like DataInputStream because their methods such as readBoolean(), readByte() and readChar() throw EOFException when they reach the end, rather than returning a special value.\n\nManaging errors and exceptions in your code is challenging. It can make deploying production code an unnerving experience. Being able to track, analyze, and manage errors in real-time can help you to proceed with more confidence. Rollbar automates error monitoring and triaging, making fixing Java errors easier than ever. Sign Up Today!"
    },
    {
        "link": "https://stackoverflow.com/questions/5122890/java-file-handling-and-exceptions",
        "document": "The standard way of handling file reading and writing in java goes something like this:\n\nBut I'm bothered by that code, because it could be possible here that the file is never closed if an exception is thrown. Sure we could add a finally clause and initialise the ObjectOutputStream outside the try block. However, when you do that you need to add another try/catch block INSIDE the finally block again...that's just ugly. Is there a better way of handling this problem?"
    },
    {
        "link": "https://digitalocean.com/community/tutorials/exception-handling-in-java",
        "document": "An exception is an error event that can happen during the execution of a program and disrupts its normal flow. Java provides a robust and object-oriented way to handle exception scenarios known as Java Exception Handling.\n\nExceptions in Java can arise from different kinds of situations such as wrong data entered by the user, hardware failure, network connection failure, or a database server that is down. The code that specifies what to do in specific exception scenarios is called exception handling.\n\nJava creates an exception object when an error occurs while executing a statement. The exception object contains a lot of debugging information such as method hierarchy, line number where the exception occurred, and type of exception.\n\nIf an exception occurs in a method, the process of creating the exception object and handing it over to the runtime environment is called “throwing the exception”. The normal flow of the program halts and the Java Runtime Environment (JRE) tries to find the handler for the exception. Exception Handler is the block of code that can process the exception object.\n• The logic to find the exception handler begins with searching in the method where the error occurred.\n• If no appropriate handler is found, then it will move to the caller method.\n• And so on.\n\nSo if the method’s call stack is and an exception is raised in method , then the search for the appropriate handler will move from .\n\nIf an appropriate exception handler is found, the exception object is passed to the handler to process it. The handler is said to be “catching the exception”. If there is no appropriate exception handler, found then the program terminates and prints information about the exception to the console.\n\nJava Exception handling framework is used to handle runtime errors only. The compile-time errors have to be fixed by the developer writing the code else the program won’t execute.\n• throw – We know that if an error occurs, an exception object is getting created and then Java runtime starts processing to handle them. Sometimes we might want to generate exceptions explicitly in our code. For example, in a user authentication program, we should throw exceptions to clients if the password is . The keyword is used to throw exceptions to the runtime to handle it.\n• throws – When we are throwing an exception in a method and not handling it, then we have to use the keyword in the method signature to let the caller program know the exceptions that might be thrown by the method. The caller method might handle these exceptions or propagate them to its caller method using the keyword. We can provide multiple exceptions in the clause, and it can be used with the method also.\n• try-catch – We use the block for exception handling in our code. is the start of the block and is at the end of the block to handle the exceptions. We can have multiple blocks with a block. The block can be nested too. The block requires a parameter that should be of type .\n• finally – the block is optional and can be used only with a block. Since exception halts the process of execution, we might have some resources open that will not get closed, so we can use the block. The block always gets executed, whether an exception occurred or not.\n• The method is throwing exceptions using the keyword. The method signature uses the keyword to let the caller know the type of exceptions it might throw.\n• In the method, I am handling exceptions using the block in the method. When I am not handling it, I am propagating it to runtime with the clause in the method.\n• The never gets executed because of the exception and then the block is executed.\n\nThe is one of the useful methods in the class for debugging purposes.\n\nThis code will output the following:\n• We can’t have or clause without a statement.\n• A statement should have either block or block, it can have both blocks.\n• We can’t write any code between blocks.\n• We can have multiple blocks with a single statement.\n• blocks can be nested similar to statements.\n• We can have only one block with a statement.\n\nAs stated earlier, when an exception is raised an exception object is getting created. Java Exceptions are hierarchical and inheritance is used to categorize different types of exceptions. is the parent class of Java Exceptions Hierarchy and it has two child objects – and . s are further divided into Checked s and Runtime s.\n• Errors: s are exceptional scenarios that are out of the scope of application, and it’s not possible to anticipate and recover from them. For example, hardware failure, Java virtual machine (JVM) crash, or out-of-memory error. That’s why we have a separate hierarchy of s and we should not try to handle these situations. Some of the common s are and .\n• Checked Exceptions: Checked s are exceptional scenarios that we can anticipate in a program and try to recover from it. For example, . We should catch this exception and provide a useful message to the user and log it properly for debugging purposes. The is the parent class of all Checked s. If we are throwing a Checked , we must it in the same method, or we have to propagate it to the caller using the keyword.\n• Runtime Exception: Runtime s are caused by bad programming. For example, trying to retrieve an element from an array. We should check the length of the array first before trying to retrieve the element otherwise it might throw at runtime. is the parent class of all Runtime s. If we are ing any Runtime in a method, it’s not required to specify them in the method signature clause. Runtime exceptions can be avoided with better programming.\n\nSome useful methods of Exception Classes\n\nJava and all of its subclasses don’t provide any specific methods, and all of the methods are defined in the base class - . The classes are created to specify different kinds of scenarios so that we can easily identify the root cause and handle the according to its type. The class implements the interface for interoperability.\n\nSome of the useful methods of the class are:\n• public String getMessage() – This method returns the message of and the message can be provided while creating the exception through its constructor.\n• public String getLocalizedMessage() – This method is provided so that subclasses can override it to provide a locale-specific message to the calling program. The class implementation of this method uses the method to return the exception message.\n• public synchronized Throwable getCause() – This method returns the cause of the exception or if the cause is unknown.\n• public String toString() – This method returns the information about in format, the returned contains the name of the class and localized message.\n• public void printStackTrace() – This method prints the stack trace information to the standard error stream, this method is overloaded, and we can pass or as an argument to write the stack trace information to the file or stream.\n\nIf you are ing a lot of exceptions in a single block, you will notice that the block code mostly consists of redundant code to log the error. In Java 7, one of the features was an improved block where we can catch multiple exceptions in a single block. Here is an example of the block with this feature:\n\nThere are some constraints such as the exception object is final and we can’t modify it inside the block, read the full analysis at Java 7 Catch Block Improvements.\n\nMost of the time, we use the block just to close the resources. Sometimes we forget to close them and get runtime exceptions when the resources are exhausted. These exceptions are hard to debug, and we might need to look into each place where we are using that resource to make sure we are closing it. In Java 7, one of the improvements was where we can create a resource in the statement itself and use it inside the block. When the execution comes out of the block, the runtime environment automatically closes these resources. Here is an example of the block with this improvement:\n\nJava provides a lot of exception classes for us to use, but sometimes we may need to create our own custom exception classes. For example, to notify the caller about a specific type of exception with the appropriate message. We can have custom fields for tracking, such as error codes. For example, let’s say we write a method to process only text files, so we can provide the caller with the appropriate error code when some other type of file is sent as input.\n\nWe can have a separate method to process different types of error codes that we get from different methods. Some of them get consumed because we might not want to notify the user of that, or some of them we will throwback to notify the user of the problem.\n\nHere I am extending so that whenever this exception is being produced, it has to be handled in the method or returned to the caller program. If we extend , there is no need to specify it in the clause.\n\nThis was a design decision. Using Checked s has the advantage of assisting developers with understanding which exceptions you can expect and take appropriate action to handle them.\n\nBest Practices for Exception Handling in Java\n• Use Specific Exceptions – Base classes of Exception hierarchy don’t provide any useful information, that’s why Java has so many exception classes, such as with further sub-classes as , , etc. We should always and specific exception classes so that caller will know the root cause of the exception easily and process them. This makes debugging easier and helps client applications handle exceptions appropriately.\n• Throw Early or Fail-Fast – We should try to exceptions as early as possible. Consider the above method, if we pass the argument to this method, we will get the following exception:\n\nWhile debugging we will have to look out at the stack trace carefully to identify the actual location of exception. If we change our implementation logic to check for these exceptions early as below:\n\nThen the exception stack trace will be indicate where the exception has occurred with clear message:\n• Catch Late – Since Java enforces to either handle the checked exception or to declare it in the method signature, sometimes developers tend to the exception and log the error. But this practice is harmful because the caller program doesn’t get any notification for the exception. We should exceptions only when we can handle them appropriately. For example, in the above method, I am ing exceptions back to the caller method to handle it. The same method could be used by other applications that might want to process the exception in a different manner. While implementing any feature, we should always exceptions back to the caller and let them decide how to handle it.\n• Closing Resources – Since exceptions halt the processing of the program, we should close all the resources in finally block or use Java 7 enhancement to let java runtime close it for you.\n• Logging Exceptions – We should always log exception messages and while ing exceptions provide a clear message so that caller will know easily why the exception occurred. We should always avoid an empty block that just consumes the exception and doesn’t provide any meaningful details of the exception for debugging.\n• Single catch block for multiple exceptions – Most of the time we log exception details and provide a message to the user, in this case, we should use Java 7 feature for handling multiple exceptions in a single block. This approach will reduce our code size, and it will look cleaner too.\n• Using Custom Exceptions – It’s always better to define an exception handling strategy at the design time and rather than ing and ing multiple exceptions, we can create a custom exception with an error code, and the caller program can handle these error codes. It’s also a good idea to create a utility method to process different error codes and use them.\n• Naming Conventions and Packaging – When you create your custom exception, make sure it ends with so that it will be clear from the name itself that it’s an exception class. Also, make sure to package them like it’s done in the Java Development Kit (JDK). For example, is the base exception for all IO operations.\n• Use Exceptions Judiciously – Exceptions are costly, and sometimes it’s not required to throw exceptions at all, and we can return a boolean variable to the caller program to indicate whether an operation was successful or not. This is helpful where the operation is optional, and you don’t want your program to get stuck because it fails. For example, while updating the stock quotes in the database from a third-party web service, we may want to avoid throwing exceptions if the connection fails.\n• Document the Exceptions Thrown – Use Javadoc to clearly specify the exceptions thrown by the method. It’s very helpful when you are providing an interface for other applications to use.\n\nIn this article, you learned about exception handling in Java. You learned about and . You also learned about (and ), , and blocks."
    },
    {
        "link": "https://baeldung.com/java-fix-eofexception",
        "document": "In this tutorial, we’ll look at the java.io.EOFException, a special type of IOException that we may encounter when working with files in Java.\n\nWe’ll first understand the cause of this exception and then discuss how we can resolve it.\n\nBefore diving into the details, let’s first understand what this exception means.\n\nEOF in EOFException stands for “End Of File”. It signals that the program has reached the end of the file while reading its contents.\n\nTypically, the exception is thrown while reading data using the input stream objects. For instance, the DataInputStream class provides methods such as readChar(), readInt(), readDouble(), etc., to read values from a stream. In such a scenario, an EOFException is thrown when the end of the stream is reached.\n\nSo, one of the most common causes behind the exception is the program reaching the end of the file while reading it.\n\nNow that we understand EOFException better let’s see how it looks in practice.\n\nIn this example program, integer values are indefinitely read from an input and printed to standard output.\n\nAs expected, this function throws an EOFException after printing the following output:\n\nNext, let’s take a look at how we can resolve this exception.\n\nIn the above example, EOFException is thrown at the following line:\n\nOne thing to note about the DataInputStream class is that we can’t read the contents of the input without reaching an end. So, we can use a try-catch block to handle the exception. Also, as values are read inside an infinite loop, we need to break from it when the exception is thrown.\n\nBelow is the updated code:\n\nNow, with the addition of the try-catch block, here’s the code output:\n\nAs we can see, the program now exits successfully without any exceptions.\n\nAn alternative to handling the exception is preventing it from happening in the first place. This can be done using the Scanner class, which provides the hasNext() method to check if the input has reached its end before reading it. As a result, the EOFException is never thrown. However, other exceptions like NoSuchElementException, InputMismatchException, and IllegalStateException can still occur.\n\nHere’s the code for preventing the EOFException:\n\nNote that the output for the above code remains the same without throwing and catching the EOFException.\n\nIn this article, we examined why the EOFException occurs and how to handle it using a try-catch block.\n\nAs always, the implementation for all examples is available over on GitHub."
    },
    {
        "link": "https://baeldung.com/sha-256-hashing-java",
        "document": "The SHA (Secure Hash Algorithm) is one of the popular cryptographic hash functions. A cryptographic hash can be used to make a signature for a text or a data file.\n\nIn this tutorial, let’s have a look at how we can perform SHA-256 and SHA3-256 hashing operations using various Java libraries.\n\nThe SHA-256 algorithm generates an almost unique, fixed-size 256-bit (32-byte) hash. This is a one-way function, so the result cannot be decrypted back to the original value.\n\nCurrently, SHA-2 hashing is widely used, as it is considered the most secure hashing algorithm in the cryptographic arena.\n\nSHA-3 is the latest secure hashing standard after SHA-2. Compared to SHA-2, SHA-3 provides a different approach to generate a unique one-way hash, and it can be much faster on some hardware implementations. Similar to SHA-256, SHA3-256 is the 256-bit fixed-length algorithm in SHA-3.\n\nNIST released SHA-3 in 2015, so there are not quite as many SHA-3 libraries as SHA-2 for the time being. It’s not until JDK 9 that SHA-3 algorithms were available in the built-in default providers.\n\nHowever, here we have to use a custom byte to hex converter to get the hashed value in hexadecimal:\n\nWe need to be aware that the MessageDigest is not thread-safe. Consequently, we should use a new instance for every thread.\n\nThe Google Guava library also provides a utility class for hashing.\n\nNext, here’s how we can use Guava to hash a String:\n\nSimilarly, we can also use Apache Commons Codecs:\n\nThe Bouncy Castle API provides a utility class for converting hex data to bytes and back again.\n\nHowever, we need to populate a digest using the built-in Java API first:\n\nNow let’s continue with SHA3-256. SHA3-256 hashing in Java isn’t that different from SHA-256.\n\nStarting from JDK 9, we can simply use the built-in SHA3-256 algorithm:\n\nApache Commons Codecs provides a convenient DigestUtils wrapper for the MessageDigest class.\n\nThis library began to support SHA3-256 since version 1.11, and it requires JDK 9+ as well:\n\nKeccak-256 is another popular SHA3-256 hashing algorithm. Currently, it serves as an alternative to the standard SHA3-256. Keccak-256 delivers the same security level as the standard SHA3-256, and it differs from SHA3-256 only on the padding rule. It has been used in several blockchain projects, such as Monero.\n\nAgain, we need to import the Bouncy Castle Library to use Keccak-256 hashing:\n\nWe can also make use of the Bouncy Castle API to do the hashing:\n\nIn this quick article, we had a look at a few ways of implementing SHA-256 and SHA3-256 hashing in Java, using both built-in and third-party libraries."
    },
    {
        "link": "https://stackoverflow.com/questions/5531455/how-to-hash-some-string-with-sha-256-in-java",
        "document": "Here is a slightly more performant way to turn the digest into a hex string:\n\nDoes anyone know of a faster way in Java?"
    },
    {
        "link": "https://medium.com/@AlexanderObregon/what-is-sha-256-hashing-in-java-0d46dfb83888",
        "document": "SHA-256 (Secure Hash Algorithm 256) is a cryptographic hash function that generates a 256-bit (32-byte) hash value. It is widely used in various security applications and protocols, including SSL/TLS and digital signatures. Understanding SHA-256 hashing in Java is important for beginners who want to ensure data integrity and security in their applications. This article will cover the basics of SHA-256, its implementation in Java, and practical use cases.\n\nSHA-256 (Secure Hash Algorithm 256) is one of the most widely used cryptographic hash functions today. Developed by the National Security Agency (NSA) and published by the National Institute of Standards and Technology (NIST) in 2001, SHA-256 is part of the SHA-2 family of cryptographic hash functions. The SHA-2 family also includes other hash functions like SHA-224, SHA-384, and SHA-512, each producing a hash of different lengths. Among them, SHA-256 has become particularly popular due to its balance of security and efficiency.\n\nBefore diving into SHA-256 specifically, it’s essential to understand what a hash function is. A hash function takes an input (or ‘message’) and returns a fixed-size string of bytes. The output, typically a hexadecimal number, appears random. However, the same input will always produce the same output. This consistency is crucial for verifying data integrity.\n• Deterministic: The same input always produces the same output.\n• Fast Computation: Hashing the input should be computationally efficient.\n• Pre-image Resistance: Given a hash value, it should be infeasible to find the original input.\n• Small Changes in Input Change the Output Significantly: A small alteration to the input should produce a vastly different hash.\n• Collision Resistance: It should be extremely unlikely for two different inputs to produce the same hash value.\n\nSHA-256 stands out because it produces a 256-bit (32-byte) hash value, often represented as a 64-character hexadecimal number. This large output size makes it highly resistant to brute force attacks, where an attacker tries to reverse-engineer the original input by trying many different inputs.\n\nSHA-256 processes data in blocks of 512 bits, or 64 bytes. If the input data isn’t a multiple of 512 bits, it is padded. The padding process involves appending a single ‘1’ bit, followed by enough ‘0’ bits to reach a length 64 bits short of a multiple of 512. The final 64 bits are filled with the original message length, in bits.\n\nOnce the data is padded, SHA-256 performs a series of bitwise operations and modular additions on the data blocks. These operations involve initializing a set of constants and working with them through a series of rounds to produce a final hash value. The intricate process make sure that even a tiny change in the input drastically changes the output hash.\n\nSHA-256 is integral to modern security practices for several reasons:\n• Data Integrity: It makes sure that data has not been altered. When you hash a message and later rehash it, the hashes should match if the data is unchanged.\n• Cryptographic Security: It’s used in encryption protocols like SSL/TLS, securing communications over the internet.\n• Digital Signatures: Ensuring authenticity and integrity of digital messages and documents.\n• Blockchain Technology: It underpins the security of blockchain, ensuring that once data is written, it cannot be altered without detection.\n\nWhile there are several hashing algorithms, SHA-256 strikes a balance between security and efficiency. For instance:\n• MD5: An older algorithm producing a 128-bit hash, now considered broken due to vulnerabilities.\n• SHA-1: Produces a 160-bit hash, but also compromised and no longer considered secure.\n• SHA-512: Another member of the SHA-2 family, it produces a 512-bit hash, offering greater security at the cost of computational resources.\n\nIn comparison to these, SHA-256 provides strong security while being computationally feasible for most applications, making it a preferred choice in many security implementations.\n\nJava provides strong support for cryptographic operations through its standard libraries, making it relatively straightforward to implement SHA-256 hashing. In this section, we will go through the step-by-step process of implementing SHA-256 hashing in Java, starting from importing the necessary packages to running the code.\n\nTo begin with, you need to import the class from the package. This class provides the functionality of a message digest algorithm, including SHA-256.\n\nThe core of our implementation will be a method that takes a string input and returns its SHA-256 hash. This method involves initializing a instance for SHA-256, performing the hash computation, and then converting the resulting byte array into a hexadecimal string.\n• MessageDigest Instance: The call returns a object that implements the SHA-256 algorithm. If SHA-256 is not available, a is thrown.\n• Hash Computation: The method computes the hash of the input string's bytes and returns the result as a byte array. The method converts the input string into a byte array.\n• Hexadecimal Conversion: The byte array is converted into a hexadecimal string. Each byte is converted to a two-digit hexadecimal number. The makes sure that the byte is treated as an unsigned value, and converts it to a hexadecimal string. If the resulting string has a length of 1, a '0' is appended to ensure two digits.\n\nWhen you run the code, you should see the SHA-256 hash of the input string printed to the console. Here is an example output for the input “Hello, SHA-256!”:\n\nBy default, the method uses the platform's default character encoding. However, it is often a good practice to specify a character encoding explicitly, such as UTF-8, to make sure consistent results across different environments.\n\nExplanation of the Code with UTF-8:\n• Character Encoding: The specifies that the string should be converted to bytes using the UTF-8 character encoding. This makes sure that the same bytes are generated regardless of the platform's default encoding.\n\nBest Practices for SHA-256 Hashing in Java\n• Handle Exceptions Properly: Always handle exceptions such as to make sure your application can gracefully deal with any issues related to the availability of the SHA-256 algorithm.\n• Use Secure Random Salts: When hashing sensitive data like passwords, use a secure random salt and hash the combination of the salt and the data to protect against rainbow table attacks.\n• Consistency in Encoding: Specify character encodings explicitly to make sure consistent behavior across different environments and platforms.\n\nSHA-256 is a versatile cryptographic hash function used in various scenarios where data integrity and security are crucial. This section will explore some of the most common and practical use cases of SHA-256 hashing, including data integrity verification, password hashing, and digital signatures.\n\nOne of the primary uses of SHA-256 hashing is to verify the integrity of data. When data is transmitted over a network or stored in a file, there is always a risk of it being altered, either accidentally or maliciously. By generating a hash of the original data and comparing it with the hash of the received data, we can make sure that the data has not been tampered with.\n\nHere’s an example of how to verify data integrity using SHA-256 in Java:\n\nIn this example, the method generates the SHA-256 hashes of the original and received data and compares them. If the hashes match, the data is intact; otherwise, it has been compromised.\n\nStoring passwords in plaintext is a significant security risk. Instead, passwords should be hashed using SHA-256 before storage. This way, even if the database is compromised, the actual passwords remain secure. When a user logs in, the password they provide is hashed, and the resulting hash is compared to the stored hash.\n\nHere’s an example of password hashing and verification using SHA-256 in Java:\n\nIn this example, the method generates the SHA-256 hash of the password. The method hashes the input password and compares it with the stored hash to verify if the passwords match.\n\nSHA-256 is also used in generating digital signatures, which make sure the authenticity and integrity of a message, software, or digital document. A digital signature is created using a private key and can be verified using the corresponding public key. This process involves hashing the data and then encrypting the hash with the private key.\n\nHere’s an example of creating and verifying digital signatures using SHA-256 in Java:\n\nIn this example, the method generates a digital signature for the given data using a private key, while the method verifies the signature using the corresponding public key. This makes sure that the data has not been altered and that it originates from a trusted source.\n\nSHA-256 plays a crucial role in blockchain technology, ensuring the security and integrity of blockchain data. In a blockchain, each block contains a cryptographic hash of the previous block, creating a chain of blocks. This makes it computationally infeasible to alter any block without changing all subsequent blocks, ensuring the immutability of the blockchain.\n\nHere’s a simplified example of how SHA-256 is used in a blockchain:\n\nIn this example, each block in the blockchain contains its data, a hash of the previous block, and a timestamp. The method generates the hash for each block, linking it to the previous block and ensuring the integrity of the entire chain.\n\nSHA-256 is also extensively used in SSL/TLS certificates issued by certificate authorities (CAs). When a website uses HTTPS, the SSL/TLS certificate ensures secure communication between the client and server. The certificate contains a public key and is signed by a CA using SHA-256, providing authenticity and integrity.\n\nWhen distributing software, it’s important to make sure that the software has not been tampered with. Developers often provide a SHA-256 hash of the software package alongside the download link. Users can then generate a hash of the downloaded file and compare it with the provided hash to verify the integrity and authenticity of the software.\n\nSHA-256 hashing is a fundamental tool in modern cryptography, offering strong security and data integrity across various applications. From verifying data integrity and securing passwords to enabling digital signatures and underpinning blockchain technology, SHA-256 makes sure that information remains protected and unaltered. By understanding and implementing SHA-256 hashing in Java, beginners can enhance the security of their applications and build a strong foundation for more advanced cryptographic practices. With its balance of efficiency and security, SHA-256 remains a vital component in safeguarding digital information.\n\nThank you for reading! If you find this guide helpful, please consider highlighting, clapping, responding or connecting with me on Twitter/X as it’s very appreciated and helps keep content like this free!"
    },
    {
        "link": "https://geeksforgeeks.org/sha-256-hash-in-java",
        "document": "Definition: \n\nIn Cryptography, SHA is cryptographic hash function which takes input as 20 Bytes and rendered the hash value in hexadecimal number, 40 digits long approx.\n\nMessage Digest Class: \n\nTo calculate cryptographic hashing value in Java, MessageDigest Class is used, under the package java.security.\n\nMessagDigest Class provides following cryptographic hash function to find hash value of a text, they are:\n\nThis Algorithms are initialized in static method called getInstance(). After selecting the algorithm it calculate the digest value and return the results in byte array.\n\nBigInteger class is used, which converts the resultant byte array into its sign-magnitude representation. This representation is converted into hex format to get the MessageDigest"
    },
    {
        "link": "https://christianschenk.org/blog/how-to-hash-data-with-java-messagedigest",
        "document": "Let’s have a look at the Java Security MessageDigest class that provides one-way hash functions and how to get individual MessageDigest instances without using Strings for the algorithm names everywhere in our code.\n\nIf you need hashing functions like the popular MD5 or one of the Secure Hash Algorithms (SHA) in your project I suggest that you either have a look at Apache Commons Codec or Google Guava for example.\n\nThere is a class called DigestUtils in Apache Commons Codec that helps you to work with hash functions. It even has helper methods that return the digest for the data as a hex string.\n\nGoogle Guava on the other hand has a class called Hashing with various helper methods to get the hash function you want. With the HashFunction you create a new Hasher, feed data into it and finally call the hash method. Have a look at the JavaDoc or the Wiki for very detailed information.\n\nIf you want to work with the standard Java API without any other libraries you can use the class. When creating an instance of the MessageDigest class it’s important to know that the algorithm names are defined in the Java Cryptography Architecture Standard Algorithm Name Documentation.\n\nBy definition every implementation of the Java platform is required to at least support MD5, SHA-1 and SHA-256. If you want to find out which algorithms are supported by your current installation you can use the following code:\n\nThis should print something like “[SHA-384, SHA-224, SHA-256, MD2, SHA, SHA-512, MD5]”. Now instead of calling the method on the MessageDigest class with these strings we can come up with a simple enum that holds them for us:\n\nThere is a helper method in the enum to get the actual algorithm name according to the Standard Algorithm Name Documentation.\n\nIn practice you can write another utility method to return the hash for a given string for example.\n\nIt starts by getting the MessageDigest instance, adding data to it, calculating the hash by calling the digest method and then converting this result to a hex string.\n\nAs you can see it is not that hard to set this up by yourself without any other libraries. It is a good exercise to understand what is going on. For production I would recommend using an existing, established library that has been reviewed like Apache Commons Codec or Google Guava instead."
    }
]