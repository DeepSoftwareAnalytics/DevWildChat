[
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/desktop/wpf/controls/styles-templates-overview?view=netdesktop-9.0",
        "document": "What are styles and templates? (WPF .NET)\n\nWindows Presentation Foundation (WPF) styling and templating refer to a suite of features that let developers and designers create visually compelling effects and a consistent appearance for their product. When customizing the appearance of an app, you want a strong styling and templating model that enables maintenance and sharing of appearance within and among apps. WPF provides that model.\n\nAnother feature of the WPF styling model is the separation of presentation and logic. Designers can work on the appearance of an app by using only XAML at the same time that developers work on the programming logic by using C# or Visual Basic.\n\nThis overview focuses on the styling and templating aspects of the app and doesn't discuss any data-binding concepts. For information about data binding, see Data Binding Overview.\n\nIt's important to understand resources, which are what enable styles and templates to be reused. For more information about resources, see Overview of XAML resources.\n\nThe sample code provided in this overview is based on a simple photo browsing application shown in the following illustration.\n\nThis simple photo sample uses styling and templating to create a visually compelling user experience. The sample has two TextBlock elements and a ListBox control that is bound to a list of images.\n\nFor the complete sample, see Introduction to Styling and Templating Sample.\n\nYou can think of a Style as a convenient way to apply a set of property values to multiple elements. You can use a style on any element that derives from FrameworkElement or FrameworkContentElement such as a Window or a Button.\n\nThe most common way to declare a style is as a resource in the section in a XAML file. Because styles are resources, they obey the same scoping rules that apply to all resources. Put simply, where you declare a style affects where the style can be applied. For example, if you declare the style in the root element of your app definition XAML file, the style can be used anywhere in your app.\n\nFor example, the following XAML code declares two styles for a , one automatically applied to all elements, and another that must be explicitly referenced.\n\nHere is an example of the styles declared above being used.\n\nFor more information, see Create a style for a control.\n\nIn WPF, the ControlTemplate of a control defines the appearance of the control. You can change the structure and appearance of a control by defining a new ControlTemplate and assigning it to a control. In many cases, templates give you enough flexibility so that you do not have to write your own custom controls.\n\nEach control has a default template assigned to the Control.Template property. The template connects the visual presentation of the control with the control's capabilities. Because you define a template in XAML, you can change the control's appearance without writing any code. Each template is designed for a specific control, such as a Button.\n\nCommonly you declare a template as a resource on the section of a XAML file. As with all resources, scoping rules apply.\n\nControl templates are a lot more involved than a style. This is because the control template rewrites the visual appearance of the entire control, while a style simply applies property changes to the existing control. However, since the template of a control is applied by setting the Control.Template property, you can use a style to define or set a template.\n\nDesigners generally allow you to create a copy of an existing template and modify it. For example, in the Visual Studio WPF designer, select a control, and then right-click and select Edit template > Create a copy. This command generates a style that defines a template.\n\nEditing a copy of a template is a great way to learn how templates work. Instead of creating a new blank template, it's easier to edit a copy and change a few aspects of the visual presentation.\n\nFor an example, see Create a template for a control.\n\nYou may have noticed that the template resource defined in the previous section uses the TemplateBinding Markup Extension. A is an optimized form of a binding for template scenarios, analogous to a binding constructed with . is useful for binding parts of the template to properties of the control. For example, each control has a BorderThickness property. Use a to manage which element in the template is affected by this control setting.\n\nIf a ContentPresenter is declared in the ControlTemplate of a ContentControl, the ContentPresenter will automatically bind to the ContentTemplate and Content properties. Likewise, an ItemsPresenter that is in the ControlTemplate of an ItemsControl will automatically bind to the ItemTemplate and Items properties.\n\nIn this sample app, there is a ListBox control that is bound to a list of photos.\n\nThis ListBox currently looks like the following.\n\nMost controls have some type of content, and that content often comes from data that you are binding to. In this sample, the data is the list of photos. In WPF, you use a DataTemplate to define the visual representation of data. Basically, what you put into a DataTemplate determines what the data looks like in the rendered app.\n\nIn our sample app, each custom object has a property of type string that specifies the file path of the image. Currently, the photo objects appear as file paths.\n\nFor the photos to appear as images, you create a DataTemplate as a resource.\n\nNotice that the DataType property is similar to the TargetType property of the Style. If your DataTemplate is in the resources section, when you specify the DataType property to a type and omit an , the DataTemplate is applied whenever that type appears. You always have the option to assign the DataTemplate with an and then set it as a for properties that take DataTemplate types, such as the ItemTemplate property or the ContentTemplate property.\n\nEssentially, the DataTemplate in the above example defines that whenever there is a object, it should appear as an Image within a Border. With this DataTemplate, our app now looks like this.\n\nThe data templating model provides other features. For example, if you are displaying collection data that contains other collections using a HeaderedItemsControl type such as a Menu or a TreeView, there is the HierarchicalDataTemplate. Another data templating feature is the DataTemplateSelector, which allows you to choose a DataTemplate to use based on custom logic. For more information, see Data Templating Overview, which provides a more in-depth discussion of the different data templating features.\n\nA trigger sets properties or starts actions, such as an animation, when a property value changes or when an event is raised. Style, ControlTemplate, and DataTemplate all have a property that can contain a set of triggers. There are several types of triggers.\n\nA Trigger that sets property values or starts actions based on the value of a property is called a property trigger.\n\nTo demonstrate how to use property triggers, you can make each ListBoxItem partially transparent unless it is selected. The following style sets the Opacity value of a ListBoxItem to . When the IsSelected property is , however, the Opacity is set to .\n\nThis example uses a Trigger to set a property value, but note that the Trigger class also has the EnterActions and ExitActions properties that enable a trigger to perform actions.\n\nNotice that the MaxHeight property of the ListBoxItem is set to . In the following illustration, the third item is the selected item.\n\nAnother type of trigger is the EventTrigger, which starts a set of actions based on the occurrence of an event. For example, the following EventTrigger objects specify that when the mouse pointer enters the ListBoxItem, the MaxHeight property animates to a value of over a second period. When the mouse moves away from the item, the property returns to the original value over a period of second. Note how it is not necessary to specify a To value for the MouseLeave animation. This is because the animation is able to keep track of the original value.\n\nFor more information, see the Storyboards overview.\n\nIn the following illustration, the mouse is pointing to the third item.\n\nIn addition to Trigger and EventTrigger, there are other types of triggers. MultiTrigger allows you to set property values based on multiple conditions. You use DataTrigger and MultiDataTrigger when the property of your condition is data-bound.\n\nControls are always in a specific state. For example, when the mouse moves over the surface of a control, the control is considered to be in a common state of . A control without a specific state is considered to be in the common state. States are broken into groups, and the previously mentioned states are part of the state group . Most controls have two state groups: and . Of each state group applied to a control, a control is always in one state of each group, such as and . However, a control can't be in two different states within the same group, such as and . Here is a table of states most controls recognize and use.\n\nBy defining a System.Windows.VisualStateManager on the root element of a control template, you can trigger animations when a control enters a specific state. The declares which combinations of VisualStateGroup and VisualState to watch. When the control enters a watched state, the animation defined by the is started.\n\nFor example, the following XAML code watches the state to animate the fill color of the element named . When the control returns to the state, the fill color of the element named is restored.\n\nFor more information about storyboards, see Storyboards Overview.\n\nA typical WPF app might have multiple UI resources that are applied throughout the app. Collectively, this set of resources can be considered the theme for the app. WPF provides support for packaging UI resources as a theme by using a resource dictionary that is encapsulated as the ResourceDictionary class.\n\nWPF themes are defined by using the styling and templating mechanism that WPF exposes for customizing the visuals of any element.\n\nWPF theme resources are stored in embedded resource dictionaries. These resource dictionaries must be embedded within a signed assembly, and can either be embedded in the same assembly as the code itself or in a side-by-side assembly. For PresentationFramework.dll, the assembly that contains WPF controls, theme resources are in a series of side-by-side assemblies.\n\nThe theme becomes the last place to look when searching for the style of an element. Typically, the search will begin by walking up the element tree searching for an appropriate resource, then look in the app resource collection and finally query the system. This gives app developers a chance to redefine the style for any object at the tree or app level before reaching the theme.\n\nYou can define resource dictionaries as individual files that enable you to reuse a theme across multiple apps. You can also create swappable themes by defining multiple resource dictionaries that provide the same types of resources but with different values. Redefining these styles or other resources at the app level is the recommended approach for skinning an app.\n\nTo share a set of resources, including styles and templates, across apps, you can create a XAML file and define a ResourceDictionary that includes reference to a file.\n\nIt is the sharing of , which itself defines a ResourceDictionary that contains a set of style and brush resources, that enables the controls in an app to have a consistent look.\n\nFor more information, see Merged resource dictionaries.\n\nIf you are creating a theme for your custom control, see the Defining resources at the theme level section of the Control authoring overview."
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/desktop/wpf/advanced/alignment-margins-and-padding-overview?view=netframeworkdesktop-4.8",
        "document": "The FrameworkElement class exposes several properties that are used to precisely position child elements. This topic discusses four of the most important properties: HorizontalAlignment, Margin, Padding, and VerticalAlignment. The effects of these properties are important to understand, because they provide the basis for controlling the position of elements in Windows Presentation Foundation (WPF) applications.\n\nThere are numerous ways to position elements using WPF. However, achieving ideal layout goes beyond simply choosing the right Panel element. Fine control of positioning requires an understanding of the HorizontalAlignment, Margin, Padding, and VerticalAlignment properties.\n\nThe following illustration shows a layout scenario that utilizes several positioning properties.\n\nAt first glance, the Button elements in this illustration may appear to be placed randomly. However, their positions are actually precisely controlled by using a combination of margins, alignments, and padding.\n\nThe following example describes how to create the layout in the preceding illustration. A Border element encapsulates a parent StackPanel, with a Padding value of 15 device independent pixels. This accounts for the narrow LightBlue band that surrounds the child StackPanel. Child elements of the StackPanel are used to illustrate each of the various positioning properties that are detailed in this topic. Three Button elements are used to demonstrate both the Margin and HorizontalAlignment properties.\n\nThe following diagram provides a close-up view of the various positioning properties that are used in the preceding sample. Subsequent sections in this topic describe in greater detail how to use each positioning property.\n\nThe HorizontalAlignment and VerticalAlignment properties describe how a child element should be positioned within a parent element's allocated layout space. By using these properties together, you can position child elements precisely. For example, child elements of a DockPanel can specify four different horizontal alignments: Left, Right, or Center, or to Stretch to fill available space. Similar values are available for vertical positioning.\n\nThe HorizontalAlignment property declares the horizontal alignment characteristics to apply to child elements. The following table shows each of the possible values of the HorizontalAlignment property.\n\nThe following example shows how to apply the HorizontalAlignment property to Button elements. Each attribute value is shown, to better illustrate the various rendering behaviors.\n\nThe preceding code yields a layout similar to the following image. The positioning effects of each HorizontalAlignment value are visible in the illustration.\n\nThe VerticalAlignment property describes the vertical alignment characteristics to apply to child elements. The following table shows each of the possible values for the VerticalAlignment property.\n\nThe following example shows how to apply the VerticalAlignment property to Button elements. Each attribute value is shown, to better illustrate the various rendering behaviors. For purposes of this sample, a Grid element with visible gridlines is used as the parent, to better illustrate the layout behavior of each property value.\n\nThe preceding code yields a layout similar to the following image. The positioning effects of each VerticalAlignment value are visible in the illustration.\n\nThe Margin property describes the distance between an element and its child or peers. Margin values can be uniform, by using syntax like . With this syntax, a uniform Margin of 20 device independent pixels would be applied to the element. Margin values can also take the form of four distinct values, each value describing a distinct margin to apply to the left, top, right, and bottom (in that order), like . Proper use of the Margin property enables very fine control of an element's rendering position and the rendering position of its neighbor elements and children.\n\nThe following example shows how to apply uniform margins around a group of Button elements. The Button elements are spaced evenly with a ten-pixel margin buffer in each direction.\n\nIn many instances, a uniform margin is not appropriate. In these cases, non-uniform spacing can be applied. The following example shows how to apply non-uniform margin spacing to child elements. Margins are described in this order: left, top, right, bottom.\n\nPadding is similar to Margin in most respects. The Padding property is exposed on only on a few classes, primarily as a convenience: Block, Border, Control, and TextBlock are samples of classes that expose a Padding property. The Padding property enlarges the effective size of a child element by the specified Thickness value.\n\nThe following example shows how to apply Padding to a parent Border element.\n\nUsing Alignment, Margins, and Padding in an Application\n\nHorizontalAlignment, Margin, Padding, and VerticalAlignment provide the positioning control necessary to create a complex user interface (UI). You can use the effects of each property to change child-element positioning, enabling flexibility in creating dynamic applications and user experiences.\n\nThe following example demonstrates each of the concepts that are detailed in this topic. Building on the infrastructure found in the first sample in this topic, this example adds a Grid element as a child of the Border in the first sample. Padding is applied to the parent Border element. The Grid is used to partition space between three child StackPanel elements. Button elements are again used to show the various effects of Margin and HorizontalAlignment. TextBlock elements are added to each ColumnDefinition to better define the various properties applied to the Button elements in each column.\n\nWhen compiled, the preceding application yields a UI that looks like the following illustration. The effects of the various property values are evident in the spacing between elements, and significant property values for elements in each column are shown within TextBlock elements.\n\nPositioning properties defined by the FrameworkElement class enable fine control of element placement within WPF applications. You now have several techniques you can use to better position elements using WPF.\n\nAdditional resources are available that explain WPF layout in greater detail. The Panels Overview topic contains more detail about the various Panel elements. The topic Walkthrough: My first WPF desktop application introduces advanced techniques that use layout elements to position components and bind their actions to data sources."
    },
    {
        "link": "https://stackoverflow.com/questions/25036660/programmatically-moving-textblocks-in-wpf",
        "document": "You first want to place a control on your screen, then you can populate it with TextBoxes placed at whatever and position you want.\n\nThat said though, WPF has a much better layout/arrangement system than WinForms, and trying to use it like it's WinForms means you'll miss out on a lot of what makes WPF so great, and you'll be making things a lot harder on yourself.\n\nThe WPF way of doing the same thing would be to use an ItemsControl, and a collection of objects that each contain data that the UI needs to to know for display purposes.\n\nFirst you would create a class to represent each TextBox\n\nNote: This class should implement INotifyPropertyChanged if you want to change the properties at runtime and have the UI automatically update.\n\nThen make a list of this class, and bind it to an\n\nThen you'd want to overwrite the to be a (the best WPF panel for positioning items according to an X,Y position)\n\nNext overwrite the to draw each item using a TextBlock\n\nAnd add an that binds Canvas.Left and Canvas.Top properties to X,Y properties on your object\n\nAnd this will take a List of objects, and render them to the screen inside a Canvas, with each item positioned at the specified X,Y coordinates.\n\nWith all that being said, are you sure this is what you want? WPF has much better layout panels than WinForms, and you don't have to position every element according to an X,Y coordinate if you don't want to.\n\nFor a quick visual introduction of WPF's Layouts, I'd recommend this link : WPF Layouts - A Visual Quick Start\n\nAlso since it sounds like you're new to WPF and coming from a WinForms background, you may find this answer to a related question useful : Transitioning from Windows Forms to WPF"
    },
    {
        "link": "https://stackoverflow.com/questions/9778294/center-text-at-a-given-point-on-a-wpf-canvas",
        "document": "You could achieve this by binding the margin of the label to the and of the label, and multiplying these values with -0.5. This moves the label left by half its width; and it moves the label upwards by half its height.\n\nHere is an example:\n\nThe red rectangle highlights the coordinate (40, 40) on which the label \"MMMMMM\" is centered.\n\nThe result looks like this:\n\nIn order to do that programmatically, define an attached property , like this:\n\nSetting to means that the margin of that framework element is automatically bound to its actual width and height such that the framework element is moved to its center point.\n\nYou would use it in your XAML code like this:\n\nAn alternative would be to bind to instead of . In this case, the converter would return\n\nand the attached property's callback method would contain these lines:\n\nThis alternative has the advantage that the effect of the attached property is visible in the Visual Studio designer (which is not the case when setting the Margin property)."
    },
    {
        "link": "https://wpf-tutorial.com/basic-controls/the-textblock-control",
        "document": "TextBlock is not a control, per se, since it doesn't inherit from the Control class, but it's used much like any other control in the WPF framework, so we'll call it a control to keep things simple.\n\nThe TextBlock control is one of the most fundamental controls in WPF, yet it's very useful. It allows you to put text on the screen, much like a Label control does, but in a simpler and less resource demanding way. A common understanding is that a Label is for short, one-line texts (but may include e.g. an image), while the TextBlock works very well for multiline strings as well, but can only contain text (strings). Both the Label and the TextBlock offers their own unique advantages, so what you should use very much depends on the situation.\n\nWe already used a TextBlock control in the \"Hello, WPF!\" article, but for now, let's have a look at the TextBlock in its simplest form:\n\nThat's as simple as it comes and if you have read the previous chapters of this tutorial, then there should be nothing new here. The text between the TextBlock is simply a shortcut for setting the Text property of the TextBlock.\n\nFor the next example, let's try a longer text to show how the TextBlock deals with that. I've also added a bit of margin, to make it look just a bit better:\n\nAs you will soon realize from the screenshot, the TextBlock is perfectly capable of dealing with long, multiline texts, but it will not do anything by default. In this case the text is too long to be rendered inside the window, so WPF renders as much of the text as possible and then just stops.\n\nFortunately, there are several ways of dealing with this. In the next example I'll show you all of them, and then I'll explain each of them afterwards:\n\nSo, we have three TextBlock controls, each with a different color (using the Foreground property) for an easier overview. They all handle the fact that their text content is too long in different ways:\n\nThe red TextBlock uses a LineBreak tag to manually break the line at a designated location. This gives you absolute control over where you want the text to break onto a new line, but it's not very flexible for most situations. If the user makes the window bigger, the text will still wrap at the same position, even though there may now be room enough to fit the entire text onto one line.\n\nThe green TextBlock uses the TextTrimming property with the value CharacterEllipsis to make the TextBlock show an ellipsis (...) when it can't fit any more text into the control. This is a common way of showing that there's more text, but not enough room to show it. This is great when you have text that might be too long but you absolutely don't want it to use more than one line. As an alternative to CharacterEllipsis you may use WordEllipsis, which will trim the text at the end of the last possible word instead of the last possible character, preventing that a word is only shown in part.\n\nThe blue TextBlock uses the TextWrapping property with the value Wrap, to make the TextBlock wrap to the next line whenever it can't fit anymore text into the previous line. Contrary to the first TextBlock, where we manually define where to wrap the text, this happens completely automatic and even better: It's also automatically adjusted as soon as the TextBlock get more or less space available. Try making the window in the example bigger or smaller and you will see how the wrapping is updated to match the situation.\n\nThis was all about dealing with simple strings in the TextBlock. In the next chapter, we'll look into some of the more advanced functionality of the TextBlock, which allows us to create text of various styles within the TextBlock and much more."
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/desktop/wpf/controls/how-to-create-and-use-a-canvas?view=netframeworkdesktop-4.8",
        "document": "How to: Create and Use a Canvas\n\nThis example shows how to create and use an instance of Canvas.\n\nThe following example explicitly positions two TextBlock elements by using the SetTop and SetLeft methods of Canvas. The example also assigns a Background color of to the Canvas."
    },
    {
        "link": "https://stackoverflow.com/questions/13374270/dynamic-data-display-wpf-need-to-add-text-to-canvas-c-sharp",
        "document": "I am using the dynamic data display WPF chart. I have a requirement to display a label next to every point on the curves plotted on the chart.\n\nThe exact functionality is as follows:\n• None Every curve has a an object that holds its data and a description that inculdes color, marker shape etc. It also tell me whether the labels must be visible for that particular curve.\n• None There is also an option using a checkbox to hide/show the labels for all points on all the curves on the plot.\n• None There is a third option where a user can left click on the marker and see a label next to it.\n\nNow, I previously implemented it by adding labels along with the ElementMarkerPointGraph for each point and setting the visibility of the labels. I know there is a massive performance hit with this approach.\n\nI am now looking to create a solution where I can render text directly to the canvas at a location that I provide. I also need help with the removing the text from the canvas.\n\nIs there a way of adding text natively to the canvas? What is the most efficient way to do so?\n\nEDIT: I need to move the text around as the plotter zooms. I already know when the plotter zooms, I need to be able to move the text to the appropriate location."
    },
    {
        "link": "https://stackoverflow.com/questions/60437382/wpf-xaml-how-to-add-textblock-to-canvas-with-existing-items-source",
        "document": "I am making a spectrogram program that displays the spectrogram as an image onto a canvas. I currently have the axis as well as other lines linked to the itemControl using binding. I want to be able to add text blocks to my canvas so that I can add values to the notches of the axis."
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/desktop/wpf/advanced/layout?view=netframeworkdesktop-4.8",
        "document": "This topic describes the Windows Presentation Foundation (WPF) layout system. Understanding how and when layout calculations occur is essential for creating user interfaces in WPF.\n\nThis topic contains the following sections:\n\nWhen thinking about layout in WPF, it is important to understand the bounding box that surrounds all elements. Each FrameworkElement consumed by the layout system can be thought of as a rectangle that is slotted into the layout. The LayoutInformation class returns the boundaries of an element's layout allocation, or slot. The size of the rectangle is determined by calculating the available screen space, the size of any constraints, layout-specific properties (such as margin and padding), and the individual behavior of the parent Panel element. Processing this data, the layout system is able to calculate the position of all the children of a particular Panel. It is important to remember that sizing characteristics defined on the parent element, such as a Border, affect its children.\n\nThis layout can be achieved by using the following XAML.\n\nA single TextBlock element is hosted within a Grid. While the text fills only the upper-left corner of the first column, the allocated space for the TextBlock is actually much larger. The bounding box of any FrameworkElement can be retrieved by using the GetLayoutSlot method. The following illustration shows the bounding box for the TextBlock element.\n\nAs shown by the yellow rectangle, the allocated space for the TextBlock element is actually much larger than it appears. As additional elements are added to the Grid, this allocation could shrink or expand, depending on the type and size of elements that are added.\n\nThe layout slot of the TextBlock is translated into a Path by using the GetLayoutSlot method. This technique can be useful for displaying the bounding box of an element.\n\nAt its simplest, layout is a recursive system that leads to an element being sized, positioned, and drawn. More specifically, layout describes the process of measuring and arranging the members of a Panel element's Children collection. Layout is an intensive process. The larger the Children collection, the greater the number of calculations that must be made. Complexity can also be introduced based on the layout behavior defined by the Panel element that owns the collection. A relatively simple Panel, such as Canvas, can have significantly better performance than a more complex Panel, such as Grid.\n\nEach time that a child UIElement changes its position, it has the potential to trigger a new pass by the layout system. Therefore, it is important to understand the events that can invoke the layout system, as unnecessary invocation can lead to poor application performance. The following describes the process that occurs when the layout system is invoked.\n• None A child UIElement begins the layout process by first having its core properties measured.\n• None Sizing properties defined on FrameworkElement are evaluated, such as Width, Height, and Margin.\n• None Panel-specific logic is applied, such as Dock direction or stacking Orientation.\n• None Content is arranged after all children have been measured.\n• None The Children collection is drawn on the screen.\n• None The process is invoked again if additional Children are added to the collection, a LayoutTransform is applied, or the UpdateLayout method is called.\n\nThis process and how it is invoked are defined in more detail in the following sections.\n\nThe layout system completes two passes for each member of the Children collection, a measure pass and an arrange pass. Each child Panel provides its own MeasureOverride and ArrangeOverride methods to achieve its own specific layout behavior.\n\nDuring the measure pass, each member of the Children collection is evaluated. The process begins with a call to the Measure method. This method is called within the implementation of the parent Panel element, and does not have to be called explicitly for layout to occur.\n\nFirst, native size properties of the UIElement are evaluated, such as Clip and Visibility. This generates a value named that is passed to MeasureCore.\n\nSecondly, framework properties defined on FrameworkElement are processed, which affects the value of . These properties generally describe the sizing characteristics of the underlying UIElement, such as its Height, Width, Margin, and Style. Each of these properties can change the space that is necessary to display the element. MeasureOverride is then called with as a parameter.\n\nThere is a difference between the properties of Height and Width and ActualHeight and ActualWidth. For example, the ActualHeight property is a calculated value based on other height inputs and the layout system. The value is set by the layout system itself, based on an actual rendering pass, and may therefore lag slightly behind the set value of properties, such as Height, that are the basis of the input change. Because ActualHeight is a calculated value, you should be aware that there could be multiple or incremental reported changes to it as a result of various operations by the layout system. The layout system may be calculating required measure space for child elements, constraints by the parent element, and so on.\n\nThe ultimate goal of the measure pass is for the child to determine its DesiredSize, which occurs during the MeasureCore call. The DesiredSize value is stored by Measure for use during the content arrange pass.\n\nThe arrange pass begins with a call to the Arrange method. During the arrange pass, the parent Panel element generates a rectangle that represents the bounds of the child. This value is passed to the ArrangeCore method for processing.\n\nThe ArrangeCore method evaluates the DesiredSize of the child and evaluates any additional margins that may affect the rendered size of the element. ArrangeCore generates an , which is passed to the ArrangeOverride method of the Panel as a parameter. ArrangeOverride generates the of the child. Finally, the ArrangeCore method does a final evaluation of offset properties, such as margin and alignment, and puts the child within its layout slot. The child does not have to (and frequently does not) fill the entire allocated space. Control is then returned to the parent Panel and the layout process is complete.\n\nWPF includes a group of elements that derive from Panel. These Panel elements enable many complex layouts. For example, stacking elements can easily be achieved by using the StackPanel element, while more complex and free flowing layouts are possible by using a Canvas.\n\nThe following table summarizes the available layout Panel elements.\n\nFor applications that require a layout that is not possible by using any of the predefined Panel elements, custom layout behaviors can be achieved by inheriting from Panel and overriding the MeasureOverride and ArrangeOverride methods.\n\nLayout is a recursive process. Each child element in a Children collection gets processed during each invocation of the layout system. As a result, triggering the layout system should be avoided when it is not necessary. The following considerations can help you achieve better performance.\n• None Be aware of which property value changes will force a recursive update by the layout system. Dependency properties whose values can cause the layout system to be initialized are marked with public flags. AffectsMeasure and AffectsArrange provide useful clues as to which property value changes will force a recursive update by the layout system. In general, any property that can affect the size of an element's bounding box should have a AffectsMeasure flag set to true. For more information, see Dependency Properties Overview.\n• None When possible, use a RenderTransform instead of a LayoutTransform. A LayoutTransform can be a very useful way to affect the content of a user interface (UI). However, if the effect of the transform does not have to impact the position of other elements, it is best to use a RenderTransform instead, because RenderTransform does not invoke the layout system. LayoutTransform applies its transformation and forces a recursive layout update to account for the new position of the affected element.\n• The UpdateLayout method forces a recursive layout update, and is frequently not necessary. Unless you are sure that a full update is required, rely on the layout system to call this method for you.\n• None When working with a large Children collection, consider using a VirtualizingStackPanel instead of a regular StackPanel. By virtualizing the child collection, the VirtualizingStackPanel only keeps objects in memory that are currently within the parent's ViewPort. As a result, performance is substantially improved in most scenarios.\n\nThe WPF graphics system uses device-independent units to enable resolution and device independence. Each device independent pixel automatically scales with the system's dots per inch (dpi) setting. This provides WPF applications proper scaling for different dpi settings and makes the application automatically dpi-aware.\n\nHowever, this dpi independence can create irregular edge rendering because of anti-aliasing. These artifacts, typically seen as blurry or semi-transparent edges, can occur when the location of an edge falls in the middle of a device pixel instead of between device pixels. The layout system provides a way to adjust for this with layout rounding. Layout rounding is where the layout system rounds any non-integral pixel values during the layout pass.\n\nLayout rounding is disabled by default. To enable layout rounding, set the UseLayoutRounding property to on any FrameworkElement. Because it is a dependency property, the value will propagate to all the children in the visual tree. To enable layout rounding for the entire UI, set UseLayoutRounding to on the root container. For an example, see UseLayoutRounding.\n\nUnderstanding how elements are measured and arranged is the first step in understanding layout. For more information about the available Panel elements, see Panels Overview. To better understand the various positioning properties that can affect layout, see Alignment, Margins, and Padding Overview. When you are ready to put it all together in a lightweight application, see Walkthrough: My first WPF desktop application."
    },
    {
        "link": "https://wpf-tutorial.com/basic-controls/the-textblock-control",
        "document": "TextBlock is not a control, per se, since it doesn't inherit from the Control class, but it's used much like any other control in the WPF framework, so we'll call it a control to keep things simple.\n\nThe TextBlock control is one of the most fundamental controls in WPF, yet it's very useful. It allows you to put text on the screen, much like a Label control does, but in a simpler and less resource demanding way. A common understanding is that a Label is for short, one-line texts (but may include e.g. an image), while the TextBlock works very well for multiline strings as well, but can only contain text (strings). Both the Label and the TextBlock offers their own unique advantages, so what you should use very much depends on the situation.\n\nWe already used a TextBlock control in the \"Hello, WPF!\" article, but for now, let's have a look at the TextBlock in its simplest form:\n\nThat's as simple as it comes and if you have read the previous chapters of this tutorial, then there should be nothing new here. The text between the TextBlock is simply a shortcut for setting the Text property of the TextBlock.\n\nFor the next example, let's try a longer text to show how the TextBlock deals with that. I've also added a bit of margin, to make it look just a bit better:\n\nAs you will soon realize from the screenshot, the TextBlock is perfectly capable of dealing with long, multiline texts, but it will not do anything by default. In this case the text is too long to be rendered inside the window, so WPF renders as much of the text as possible and then just stops.\n\nFortunately, there are several ways of dealing with this. In the next example I'll show you all of them, and then I'll explain each of them afterwards:\n\nSo, we have three TextBlock controls, each with a different color (using the Foreground property) for an easier overview. They all handle the fact that their text content is too long in different ways:\n\nThe red TextBlock uses a LineBreak tag to manually break the line at a designated location. This gives you absolute control over where you want the text to break onto a new line, but it's not very flexible for most situations. If the user makes the window bigger, the text will still wrap at the same position, even though there may now be room enough to fit the entire text onto one line.\n\nThe green TextBlock uses the TextTrimming property with the value CharacterEllipsis to make the TextBlock show an ellipsis (...) when it can't fit any more text into the control. This is a common way of showing that there's more text, but not enough room to show it. This is great when you have text that might be too long but you absolutely don't want it to use more than one line. As an alternative to CharacterEllipsis you may use WordEllipsis, which will trim the text at the end of the last possible word instead of the last possible character, preventing that a word is only shown in part.\n\nThe blue TextBlock uses the TextWrapping property with the value Wrap, to make the TextBlock wrap to the next line whenever it can't fit anymore text into the previous line. Contrary to the first TextBlock, where we manually define where to wrap the text, this happens completely automatic and even better: It's also automatically adjusted as soon as the TextBlock get more or less space available. Try making the window in the example bigger or smaller and you will see how the wrapping is updated to match the situation.\n\nThis was all about dealing with simple strings in the TextBlock. In the next chapter, we'll look into some of the more advanced functionality of the TextBlock, which allows us to create text of various styles within the TextBlock and much more."
    }
]