[
    {
        "link": "https://restack.io/p/cycle-detection-algorithms-in-topological-sort-answer",
        "document": "Explore cycle detection algorithms in topological sorting using C#. Understand their importance and implementation in graph theory."
    },
    {
        "link": "https://stackoverflow.com/questions/6424808/simple-implementation-for-detecting-cycles-in-a-directed-graph-in-c-sharp",
        "document": "I wonder if you could help me with a simple implementation for detecting cycles in a directed graph in C#.\n\nI've read about the algorithms but I'd like to find something already implemented, very simple and short.\n\nI don't care about the performance because the data size is limited."
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/standard/collections",
        "document": "Similar data can often be handled more efficiently when stored and manipulated as a collection. You can use the System.Array class or the classes in the System.Collections, System.Collections.Generic, System.Collections.Concurrent, and System.Collections.Immutable namespaces to add, remove, and modify either individual elements or a range of elements in a collection.\n\nThere are two main types of collections; generic collections and non-generic collections. Generic collections are type-safe at compile time. Because of this, generic collections typically offer better performance. Generic collections accept a type parameter when they're constructed. They don't require that you cast to and from the Object type when you add or remove items from the collection. In addition, most generic collections are supported in Windows Store apps. Non-generic collections store items as Object, require casting, and most aren't supported for Windows Store app development. However, you might see non-generic collections in older code.\n\nIn .NET Framework 4 and later versions, the collections in the System.Collections.Concurrent namespace provide efficient thread-safe operations for accessing collection items from multiple threads. The immutable collection classes in the System.Collections.Immutable namespace (NuGet package) are inherently thread-safe because operations are performed on a copy of the original collection, and the original collection can't be modified.\n\nAll collections provide methods for adding, removing, or finding items in the collection. In addition, all collections that directly or indirectly implement the ICollection interface or the ICollection<T> interface share these features:\n• None The ability to enumerate the collection .NET collections either implement System.Collections.IEnumerable or System.Collections.Generic.IEnumerable<T> to enable the collection to be iterated through. An enumerator can be thought of as a movable pointer to any element in the collection. The foreach, in statement and the For Each...Next Statement use the enumerator exposed by the GetEnumerator method and hide the complexity of manipulating the enumerator. In addition, any collection that implements System.Collections.Generic.IEnumerable<T> is considered a queryable type and can be queried with LINQ. LINQ queries provide a common pattern for accessing data. They're typically more concise and readable than standard loops and provide filtering, ordering, and grouping capabilities. LINQ queries can also improve performance. For more information, see LINQ to Objects (C#), LINQ to Objects (Visual Basic), Parallel LINQ (PLINQ), Introduction to LINQ Queries (C#), and Basic Query Operations (Visual Basic).\n• None The ability to copy the collection contents to an array All collections can be copied to an array using the method. However, the order of the elements in the new array is based on the sequence in which the enumerator returns them. The resulting array is always one-dimensional with a lower bound of zero.\n\nIn addition, many collection classes contain the following features:\n• The capacity of a collection is the number of elements it can contain. The count of a collection is the number of elements it actually contains. Some collections hide the capacity or the count or both. Most collections automatically expand in capacity when the current capacity is reached. The memory is reallocated, and the elements are copied from the old collection to the new one. This design reduces the code required to use the collection. However, the performance of the collection might be negatively affected. For example, for List<T>, if Count is less than Capacity, adding an item is an O(1) operation. If the capacity needs to be increased to accommodate the new element, adding an item becomes an O( ) operation, where is Count. The best way to avoid poor performance caused by multiple reallocations is to set the initial capacity to be the estimated size of the collection. A BitArray is a special case; its capacity is the same as its length, which is the same as its count.\n• The lower bound of a collection is the index of its first element. All indexed collections in the System.Collections namespaces have a lower bound of zero, meaning they're 0-indexed. Array has a lower bound of zero by default, but a different lower bound can be defined when creating an instance of the Array class using Array.CreateInstance.\n• None Synchronization for access from multiple threads (System.Collections classes only). Non-generic collection types in the System.Collections namespace provide some thread safety with synchronization; typically exposed through the SyncRoot and IsSynchronized members. These collections aren't thread-safe by default. If you require scalable and efficient multi-threaded access to a collection, use one of the classes in the System.Collections.Concurrent namespace or consider using an immutable collection. For more information, see Thread-Safe Collections.\n\nIn general, you should use generic collections. The following table describes some common collection scenarios and the collection classes you can use for those scenarios. If you're new to generic collections, the following table will help you choose the generic collection that works best for your task:\n\nWhen choosing a collection class, it's worth considering potential tradeoffs in performance. Use the following table to reference how various mutable collection types compare in algorithmic complexity to their corresponding immutable counterparts. Often immutable collection types are less performant but provide immutability - which is often a valid comparative benefit.\n\nA can be efficiently enumerated using either a loop or a loop. An , however, does a poor job inside a loop, due to the O(log ) time for its indexer. Enumerating an using a loop is efficient because uses a binary tree to store its data instead of an array like uses. An array can be quickly indexed into, whereas a binary tree must be walked down until the node with the desired index is found.\n\nAdditionally, has the same complexity as because they both use binary trees. The significant difference is that uses an immutable binary tree. Since also offers a System.Collections.Immutable.ImmutableSortedSet<T>.Builder class that allows mutation, you can have both immutability and performance."
    },
    {
        "link": "https://stackoverflow.com/questions/65989277/graph-is-cycle-search",
        "document": "In my API , I need to check if a list which contains relations between objects IDs has a circle before it is saved in the database.\n\nThe information that is gives to me is something like this below:\n\nAs a result , I need to check either the form of the relationship and cycle or not.\n\nNotes:\n\n The language I need to use is C#. The program must be the fastest as possible and I don't have access to the database to create any functions there. Also, I don't need to get all the possible circles.I need just one and it will be enough in order to return either or .\n\nCould anyone give me some advice?"
    },
    {
        "link": "https://geeksforgeeks.org/graph-data-structure-and-algorithms",
        "document": "Graph algorithms are methods used to manipulate and analyze graphs, solving various range of problems like finding the shortest path, cycles detection.\n\nIf you are looking for difficulty-wise list of problems, please refer to Graph Data Structure.\n• None Cycles of length n in an undirected and connected graph\n• None Union By Rank and Path Compression in Union-Find Algorithm\n• None Difference between Prim’s and Kruskal’s algorithm for MST\n• None Maximum edges that can be added to DAG so that is remains DAG\n• None Topological Sort of a graph using departure time of vertex\n• None Find Itinerary from a given list of tickets\n• None Count all possible walks from a source to a destination with exactly k edges\n• None Length of shortest chain to reach the target word\n• None Find if an array of strings can be chained to form a circle\n• None Paths to travel each nodes using each edge (Seven Bridges of Königsberg)\n• None Find maximum number of edge disjoint paths between two vertices\n\nSome must do Problems\n• None Find length of the largest region in Boolean Matrix\n• None Check whether a given graph is Bipartite or not\n• None Boggle (Find all possible words in a board of characters)\n• None Construct a graph from given degrees of all vertices\n• None Two Clique Problem (Check if Graph can be divided in two Cliques)"
    },
    {
        "link": "https://geeksforgeeks.org/depth-first-search-or-dfs-for-a-graph",
        "document": "Depth First Search or DFS for a Graph\n\nIn Depth First Search (or DFS) for a graph, we traverse all adjacent vertices one by one. When we traverse an adjacent vertex, we completely finish the traversal of all vertices reachable through that adjacent vertex. This is similar to a tree, where we first completely traverse the left subtree and then move to the right subtree. The key difference is that, unlike trees, graphs may contain cycles (a node may be visited more than once). To avoid processing a node multiple times, we use a boolean visited array.\n\nNote : There can be multiple DFS traversals of a graph according to the order in which we pick adjacent vertices. Here we pick vertices as per the insertion order. Output: 1 0 2 3 4\n\nExplanation: The source vertex s is 1. We visit it first, then we visit an adjacent. \n\nStart at 1: Mark as visited. Output: 1\n\nMove to 0: Mark as visited. Output: 0 (backtrack to 1)\n\nMove to 2: Mark as visited. Output: 2 (backtrack to 0)\n\nMove to 3: Mark as visited. Output: 3 (backtrack to 2)\n\nMove to 4: Mark as visited. Output: 4 (backtrack to 2) Not that there can be more than one DFS Traversals of a Graph. For example, after 1, we may pick adjacent 2 instead of 0 and get a different DFS. Here we pick in the insertion order. Start at 0: Mark as visited. Output: 0\n\nMove to 2: Mark as visited. Output: 2\n\nMove to 4: Mark as visited. Output: 4 (backtrack to 2, then backtrack to 0)\n\nMove to 3: Mark as visited. Output: 3 (backtrack to 0)\n\nMove to 1: Mark as visited. Output: 1\n\nDFS from a Given Source of Undirected Graph:\n\nThe algorithm starts from a given source and explores all reachable vertices from the given source. It is similar to Preorder Tree Traversal where we visit the root, then recur for its children. In a graph, there might be loops. So we use an extra visited array to make sure that we do not process a vertex again.\n\nLet us understand the working of Depth First Search with the help of the following illustration: for the source as 0.\n\nBelow is the implementation of the above approach:\n\n// that are not visited yet // To add an edge in an undirected graph // Traverse all adjacent vertices that are not visited yet // Function to add an edge to the adjacency list // Define the edges of the graph // Recursively visit all adjacent vertices that are // Function to add an edge to the adjacency list // Number of vertices in the graph // Create an adjacency list for the graph // Define the edges of the graph # that are not visited yet # Create an adjacency list for the graph # Define the edges of the graph // that are not visited yet // Create an adjacency list for the graph // Define the edges of the graph // Recursively visit all adjacent vertices that are not // Number of vertices in the graph // Create an adjacency list for the graph // Define the edges of the graph\n\nTime complexity: O(V + E), where V is the number of vertices and E is the number of edges in the graph.\n\nAuxiliary Space: O(V + E), since an extra visited array of size V is required, And stack size for recursive calls to DFSRec function.\n\nPlease refer Complexity Analysis of Depth First Search: for details.\n\nThe above implementation takes a source as an input and prints only those vertices that are reachable from the source and would not print all vertices in case of disconnected graph. Let us now talk about the algorithm that prints all vertices without any source and the graph maybe disconnected.\n\nThe idea is simple, instead of calling DFS for a single vertex, we call the above implemented DFS for all all non-visited vertices one by one.\n\n// Recursively visit all adjacent vertices that are not visited yet // Main DFS function to perform DFS for the entire graph // Loop through all vertices to handle disconnected graph // If vertex i has not been visited, // Create an adjacency list for the graph // Define the edges of the graph // Function to add an edge to the adjacency list // Add edge from t to s (for undirected graph) // Traverse all adjacent vertices that are not visited yet // Main DFS function to perform DFS for the entire graph // Loop through all vertices to handle disconnected graph // If vertex i has not been visited, // Define the edges of the graph // Function to add an edge to the adjacency list // Recursively visit all adjacent vertices that are // Main DFS function to perform DFS for the entire graph // Loop through all vertices to handle disconnected // Create an adjacency list for the graph // Define the edges of the graph # that are not visited yet # Loop through all vertices to handle disconnected # Define the edges of the graph // Function to add an edge to the adjacency list // that are not visited yet // Main DFS function to perform DFS for the entire graph // Loop through all vertices to handle // If vertex i has not been visited, // Create an adjacency list for the graph // Define the edges of the graph using tuples // Recursively visit all adjacent vertices that are not // Main DFS function to perform DFS for the entire graph // Loop through all vertices to handle disconnected // Create an adjacency list for the graph // Define the edges of the graph\n\nTime complexity: O(V + E). Note that the time complexity is same here because we visit every vertex at most once and every edge is traversed at most once (in directed) and twice in undirected.\n\nAuxiliary Space: O(V + E), since an extra visited array of size V is required, And stack size for recursive calls to DFSRec function.\n• None Depth First Search or DFS on Directed Graph\n• None Breadth First Search or BFS for a Graph"
    },
    {
        "link": "https://stackoverflow.com/questions/19113189/detecting-cycles-in-a-graph-using-dfs-2-different-approaches-and-whats-the-dif",
        "document": "The graph has a cycle if and only if there exists a back edge. A back edge is an edge that is from a node to itself (selfloop) or one of its ancestor in the tree produced by DFS forming a cycle.\n\nBoth approaches above actually mean the same. However, this method can be applied only to undirected graphs.\n\nThe reason why this algorithm doesn't work for directed graphs is that in a directed graph 2 different paths to the same vertex don't make a cycle. For example: A-->B, B-->C, A-->C - don't make a cycle whereas in undirected ones: A--B, B--C, C--A does.\n\nAn undirected graph has a cycle if and only if a depth-first search (DFS) finds an edge that points to an already-visited vertex (a back edge).\n\nIn addition to visited vertices we need to keep track of vertices currently in recursion stack of function for DFS traversal. If we reach a vertex that is already in the recursion stack, then there is a cycle in the tree.\n\nUpdate: Working code is in the question section above."
    },
    {
        "link": "https://geeksforgeeks.org/detect-cycle-in-a-graph",
        "document": "Given the root of a Directed graph , The task is to check whether the graph contains a cycle or not.\n\nThe problem can be solved based on the following idea:\n\nTo find cycle in a directed graph we can use the Depth First Traversal (DFS) technique. It is based on the idea that there is a cycle in a graph only if there is a back edge [i.e., a node points to one of its ancestors in a DFS tree] present in the graph. To detect a back edge, we need to keep track of the visited nodes that are in the current recursion stack [i.e., the current path that we are visiting]. Please note that all ancestors of a node are present in recursion call stack during DFS. So if there is an edge to an ancestor in DFS, then this is a back edge. Note: If the graph is disconnected then get the DFS forest and check for a cycle in individual graphs by checking back edges.\n\nTo keep track of vertices that are in recursion call stack, we use a boolean array where we use vertex number as an index. Whenever we begin recursive call for a vertex, we mark its entry as true and whenever the recursion call is about to end, we mark false.\n\nBelow is the graph showing how to detect cycle in a graph using DFS:\n\n\n\nBelow is the implementation of the above approach:\n\n// If already present in the recursion call // stack, then there is a cycle // Recur for all the vertices adjacent // If already present in the recursion call // stack, then there is a cycle # If already present in the recursion call # stack, then there is a cycle # Recur for all the vertices adjacent // If already present in the recursion call // stack, then there is a cycle // If already present in the recursion call // stack, then there is a cycle // Recur for all the vertices adjacent\n\nTime Complexity: O(V + E), the Time Complexity of this method is the same as the time complexity of DFS traversal which is O(V+E). \n\nAuxiliary Space: O(V). To store the visited and recursion stack O(V) space is needed.\n\nIn the below article, another O(V + E) method is discussed : \n\nDetect Cycle in a direct graph using colors\n\nHere we are using Kahn’s algorithm for topological sorting, if it successfully removes all vertices from the graph, it’s a DAG with no cycles. If there are remaining vertices with in-degrees greater than 0 , it indicates the presence of at least one cycle in the graph. Hence, if we are not able to get all the vertices in topological sorting then there must be at least one cycle.\n\nBelow is the implementation of the above approach:\n\n// Function to add an edge to the adjacency list // If in-degree becomes 0, enqueue it // If not all vertices are visited, cycle // Function to add an edge to the adjacency list // If in-degree becomes 0, enqueue it // If not all vertices are visited, cycle # Function to add an edge to the adjacency list # If in-degree becomes 0, enqueue it # If not all vertices are visited, cycle // Function to add an edge to the adjacency list // If in-degree becomes 0, enqueue it // If not all vertices are visited, cycle // Function to add an edge to the adjacency list // If in-degree becomes 0, enqueue it // If not all vertices are visited, cycle\n\nTime Complexity: O(V + E), the time complexity of this method is the same as the time complexity of BFS traversal which is O(V+E). \n\nAuxiliary Space: O(V)"
    },
    {
        "link": "https://medium.com/@hanxuyang0826/mastering-dfs-and-bfs-in-c-techniques-implementations-and-leetcode-examples-57dbe66a140c",
        "document": "In this blog post, we will explore two fundamental graph traversal algorithms: Depth-First Search (DFS) and Breadth-First Search (BFS). These algorithms are essential tools for solving many programming problems that involve traversing or searching through data structures such as trees and graphs. Both DFS and BFS have distinct ways of exploring nodes and edges, making them suitable for different types of problems, from finding the shortest path in a maze to counting connected components in a network.\n\nWe will cover the core concepts behind DFS and BFS, how they work, and the scenarios where one is preferred over the other. Additionally, we will implement these algorithms in C# and dive into real-world applications, particularly in geometry and pathfinding. We will also look at common problems on platforms like LeetCode, where DFS and BFS can be used to effectively solve challenges such as traversing matrices, finding islands in grids, and solving puzzles. Understanding how and when to use these algorithms will help improve both your problem-solving skills and code efficiency."
    },
    {
        "link": "https://programiz.com/dsa/graph-dfs",
        "document": "Depth first Search or Depth first traversal is a recursive algorithm for searching all the vertices of a graph or tree data structure. Traversal means visiting all the nodes of a graph.\n\nA standard DFS implementation puts each vertex of the graph into one of two categories:\n\nThe purpose of the algorithm is to mark each vertex as visited while avoiding cycles.\n\nThe DFS algorithm works as follows:\n• Start by putting any one of the graph's vertices on top of a stack.\n• Take the top item of the stack and add it to the visited list.\n• Create a list of that vertex's adjacent nodes. Add the ones which aren't in the visited list to the top of the stack.\n• Keep repeating steps 2 and 3 until the stack is empty.\n\nLet's see how the Depth First Search algorithm works with an example. We use an undirected graph with 5 vertices.\n\nWe start from vertex 0, the DFS algorithm starts by putting it in the Visited list and putting all its adjacent vertices in the stack.\n\nNext, we visit the element at the top of stack i.e. 1 and go to its adjacent nodes. Since 0 has already been visited, we visit 2 instead.\n\nVertex 2 has an unvisited adjacent vertex in 4, so we add that to the top of the stack and visit it.\n\nAfter we visit the last element 3, it doesn't have any unvisited adjacent nodes, so we have completed the Depth First Traversal of the graph.\n\nThe pseudocode for DFS is shown below. In the init() function, notice that we run the DFS function on every node. This is because the graph might have two different disconnected parts so to make sure that we cover every vertex, we can also run the DFS algorithm on every node.\n\nThe code for the Depth First Search Algorithm with an example is shown below. The code has been simplified so that we can focus on the algorithm rather than other details.\n\nThe time complexity of the DFS algorithm is represented in the form of , where is the number of nodes and is the number of edges.\n\nThe space complexity of the algorithm is .\n• To test if the graph is bipartite\n• For finding the strongly connected components of a graph"
    }
]