[
    {
        "link": "https://en.cppreference.com/w/cpp/algorithm",
        "document": "The algorithms library defines functions for a variety of purposes (e.g. searching, sorting, counting, manipulating) that operate on ranges of elements. Note that a range is defined as first last where last refers to the element past the last element to inspect or modify.\n\nC++20 provides constrained versions of most algorithms in the namespace . In these algorithms, a range can be specified as either an iterator-sentinel pair or as a single argument, and projections and pointer-to-member callables are supported. Additionally, the return types of most algorithms have been changed to return all potentially useful information computed during the execution of the algorithm.\n\nMost algorithms have overloads that accept execution policies. The standard library algorithms support several execution policies, and the library provides corresponding execution policy types and objects. Users may select an execution policy statically by invoking a parallel algorithm with an execution policy object of the corresponding type.\n\nStandard library implementations (but not the users) may define additional execution policies as an extension. The semantics of parallel algorithms invoked with an execution policy object of implementation-defined type is implementation-defined.\n\nParallel version of algorithms (except for std::for_each and std::for_each_n) are allowed to make arbitrary copies of elements from ranges, as long as both std::is_trivially_copy_constructible_v<T> and std::is_trivially_destructible_v<T> are true, where is the type of elements.\n\nSome algorithms require the sequence represented by the arguments to be “sorted” or “partitioned”. The behavior is undefined if the requirement is not met.\n\nA sequence is sorted with respect to a comparator comp if for every iterator iter pointing to the sequence and every non-negative integer n such that iter + n[1] is a valid iterator pointing to an element of the sequence, comp(*(iter + n), *iter) == false[1]. A sequence is sorted with respect to comp and proj for a comparator comp and projection proj if for every iterator iter pointing to the sequence and every non-negative integer n such that iter + n[1] is a valid iterator pointing to an element of the sequence, bool(std::invoke(comp, std::invoke(proj, *(iter + n)),\n\n std::invoke(proj, *iter)))[1] is false. A sequence is sorted with respect to a comparator comp if the sequence is sorted with respect to comp and std::identity{} (the identity projection).\n\nA sequence start finish is partitioned with respect to an expression f(e) if there exists an integer n such that for all i in ​0​ std::distance(start, finish) , f(*(start + i))[1] is true if and only if i < n.\n• simply means “the result of being incremented times”, regardless of whether is a random access iterator.\n\nA heap can be created by std::make_heap and ranges::make_heap(since C++20).\n\nFor more properties of heap, see max heap.\n\ncopies a range of objects to an uninitialized area of memory \n\n copies a range of objects to an uninitialized area of memory\n\n copies a number of objects to an uninitialized area of memory \n\n copies a number of objects to an uninitialized area of memory\n\n copies an object to an uninitialized area of memory, defined by a range \n\n copies an object to an uninitialized area of memory, defined by a range\n\n copies an object to an uninitialized area of memory, defined by a start and a count \n\n copies an object to an uninitialized area of memory, defined by a start and a count\n\n moves a range of objects to an uninitialized area of memory \n\n moves a range of objects to an uninitialized area of memory\n\n moves a number of objects to an uninitialized area of memory \n\n moves a number of objects to an uninitialized area of memory\n\n constructs objects by default-initialization in an uninitialized area of memory, defined by a range \n\n constructs objects by default-initialization in an uninitialized area of memory, defined by a range\n\n constructs objects by default-initialization in an uninitialized area of memory, defined by a start and a count \n\n constructs objects by default-initialization in an uninitialized area of memory, defined by a start and count\n\n constructs objects by value-initialization in an uninitialized area of memory, defined by a range \n\n constructs objects by value-initialization in an uninitialized area of memory, defined by a range\n\n constructs objects by value-initialization in an uninitialized area of memory, defined by a start and a count \n\n constructs objects by value-initialization in an uninitialized area of memory, defined by a start and a count\n\n destroys an object at a given address \n\n destroys an object at a given address\n\n creates an object at a given address \n\n creates an object at a given address\n\n\n\nThe following behavior-changing defect reports were applied retroactively to previously published C++ standards."
    },
    {
        "link": "https://geeksforgeeks.org/sort-algorithms-the-c-standard-template-library-stl",
        "document": "Sorting is one of the most basic operations applied to data. It means arranging the data in a particular order, which can be increasing, decreasing or any other order. In this article, we will discuss various ways of sorting in C++.\n\nC++ provides a built-in function in C++ STL called sort() as the part of <algorithm> library for sorting the containers such as arrays, vectors, deque, etc.\n• first : The beginning of the range to be sorted.\n• last : The end of the range to be sorted.\n• comp optional ): A custom comparison function to define sorting order. By default, it is ascending order.\n\nLet’s take a look at an example that sorts the given vector in ascending order:\n\nThe sort() function implements the introsort sorting algorithm which is a combination of insertion sort, quick sort and heap sort. It automatically determines which algorithm to use according to the dataset.\n\nOther Sorting Algorithms in C++\n\nUnfortunately, C++ does not provide implementation of any other sorting algorithm than Introsort and we can also not instruct to execute a particular algorithm to sort method. So, if we need a different sorting algorithm such as counting sort, we have to implement it by ourselves.\n\nBubble Sort is a comparison-based sorting algorithm. It works by repeatedly swapping adjacent elements if they are in the wrong order, placing one element to its correct position in each iteration. Let’s take a look at its implementation:\n\nCounting Sort is a non-comparison-based sorting algorithm. It works by counting the frequency of each distinct element in the input and use that information to place the elements in their correct sorted positions. Let’s take a look at its implementation:\n\nIn a similar way, we can implement any sorting algorithm of our choice and need.\n\nAs told earlier, sorting is one of the frequently used operations on data. It is used in solving a lot of programming problems. The below examples demonstrate the use of sort() in different problems:\n\nFind the Kth Largest Element in an Array\n\nFind the Pair with the Minimum Difference"
    },
    {
        "link": "https://geeksforgeeks.org/the-c-standard-template-library-stl",
        "document": "The C++ Standard Template Library (STL) is a set of template classes and functions that provides the implementation of common data structures and algorithms such as lists, stacks, arrays, sorting, searching, etc. It also provides the iterators and functors which makes it easier to work with algorithms and containers.\n\nSTL was originally designed by Alexander Stepanov and was later accepted as the part of C++ standard in C++ 98. It is a generalized library so we can use it with almost every data type without repeating the implementation code.\n\nThe components of STL are the features provided by Standard Template Library (STL) in C++ that can be classified into 4 types:\n\nThese components are designed to be efficient, flexible, and reusable, making them an integral part of modern C++ programming.\n\nContainers are the data structures used to store objects and data according to the requirement. Each container is implemented as a template class that also contains the methods to perform basic operations on it. Every STL container is defined inside its own header file.\n\nContainers can be further classified into 4 types:\n\nIf you want to dive deep into STL and understand its full potential, our Complete C++ Course offers a complete guide to mastering containers, iterators, and algorithms provided by STL.\n\nSequence containers store the data in the linear manner. They are also used to implement container adaptors.\n\nThere are 5 sequence containers in C++ STL:\n• Arrays : The STL array is an implementation of a compile time non-resizable array. It contains various method for common array operations.\n• Vector : An STL vector can be defined as the dynamic sized array which can be resized automatically when new elements are added or removed.\n• Deque : Deque or Double-Ended Queue is sequence containers with the feature of expansion and contraction on both ends. It means we can add and remove the data to and from both ends.\n• Lists : List container stores data in non-contiguous memory unlike vectors and only provide sequential access to the stored data. It basically implements the doubly linked list.\n• Forward Lists: Forward lists also store the data in a sequential manner like lists, but with the difference that forward list stores the location of only the next elements in the sequence. It implements the singly linked list.\n\nThe container adapters are the type of STL containers that adapt existing container classes to suit specific needs or requirements.\n\nThere are 3 container adaptors in C++ STL:\n• Stack: STL Stack follows the Last In First Out (LIFO) principle of element insertion and deletion. Also, these operations are performed only at one end of the stack.\n• Queue: STL Queue follows the First In First Out (FIFO) principle, means the element are inserted first are removed first and the elements inserted last are removed at last. It uses deque container by default.\n• Priority Queue: STL Priority Queue does not follow any of the FIFO or LIFO principle, but the deletion of elements is done on the basis of its priority. So, the element with the highest (by default) is always removed first. By default, it uses vector as underlying container.\n\nAssociative containers are the type of containers that store the elements in a sorted order based on keys rather than their insertion order.\n\nThere are 4 associative containers in C++ STL:\n• Sets : STL Set is a type of associative container in which each element has to be unique because the value of the element identifies it. By default, the values are stored in ascending order.\n• Maps : STL Maps are associative containers that store elements in the form of a key-value pair. The keys have to be unique and the container is sorted on the basis of the values of the keys.\n• Multisets : STL Multiset is similar to the set container except that it can store duplicate values.\n• Multimaps : STL Multimap is similar to a map container but allows multiple mapped values to have same keys.\n\nUnordered associative containers store the data in no particular order, but they allow the fastest insertion, deletion and search operations among all the container types in STL.\n\nThere are 4 unordered associative containers in C++ STL:\n• Unordered Set : STL Unordered Set stores the unique keys in the form of hash table. The order is randomized but insertion, deletion and search are fast.\n• Unordered Multiset : STL Unordered Multiset works similarly to an unordered set but can store multiple copies of the same key.\n• Unordered Map : STL Unordered Map stores the key-value pair in a hash table, where key is hashed to find the storage place.\n• Unordered Multimap : STL Unordered Multimap container is similar to unordered map, but it allows multiple values mapped to the same key.\n\nSTL algorithms offer a wide range of functions to perform common operations on data (mainly containers). These functions implement the most efficient version of the algorithm for tasks such as sorting, searching, modifying and manipulating data in containers, etc. All STL algorithms are defined inside the <algorithm> and <numeric> header file.\n\nThere is no formal classification of STL algorithms, but we can group them into two types based on the type of operations they perform:\n\nManipulative algorithms perform operations that modifies the elements of the given container or rearrange their order.\n\nSome of the common manipulative algorithm includes:\n• copy : Copies a specific number of elements from one range to another.\n• fill : Assigns a specified value to all elements in a range.\n• transform : Applies a function to each element in a range and stores the result in another range.\n• replace : Replaces all occurrences of a specific value in a range with a new value.\n• swap : Exchanges the values of two variables.\n• reverse : Reverses the order of elements in a range.\n• rotate : Rotates the elements in a range such that a specific element becomes the first.\n• remove : Removes all elements with a specified value from a range but does not reduce the container size.\n\nNon-manipulating algorithms are the type of algorithms provided by the Standard Template Library (STL) that operate on elements in a range without altering their values or the order of the elements.\n\nThe below are the few examples of the STL’s non-manipulative algorithms:\n• max_element : Find the maximum element in the given range.\n• min_element : To find the minimum element in the given range.\n• accumulate : Finds the sum of the elements of the given range.\n• count : Counts the occurrences of given element in the range.\n• find : Returns an iterator to the first occurrence of an element in the range.\n• is_permutation : Checks if one range is a permutation of another.\n• is_sorted : Checks if the elements in a range are sorted in non-decreasing order.\n• partial_sum : Computes the cumulative sum of elements in a range.\n\nIterators are the pointer like objects that are used to point to the memory addresses of STL containers. They are one of the most important components that contributes the most in connecting the STL algorithms with the containers. Iterators are defined inside the <iterator> header file.\n\nIn C++ STL, iterators are of 5 types:\n• Input Iterators : Input Iterators can be used to read values from a sequence once and only move forward.\n• Output Iterators : Output Iterators can be used to write values into a sequence once and only move forward.\n• Forward Iterators : Forward Iterators combine the features of both input and output iterators.\n• Bidirectional Iterators : Bidirectional Iterators support all operations of forward iterators and additionally can move backward.\n• Random Access Iterators : Random Access Iterators support all operations of bidirectional iterators and additionally provide efficient random access to elements.\n\nFunctors are objects that can be treated as though they are a function. Functors are most commonly used along with STL algorithms. It overloads the function-call operator and allows us to use an object like a function. There are many predefined functors in C++ STL that are defined inside the <functional> header file.\n\nFunctors can be classified into multiple types based on the type of operator they perform:\n• plus – Returns the sum of two parameters.\n• minus – Returns the difference of two parameters.\n• multiplies – Returns the product of two parameters.\n• divides – Returns the result after dividing two parameters.\n• modulus – Returns the remainder after dividing two parameters.\n• negate – Returns the negated value of a parameter.\n• equal_to – Returns true if the two parameters are equal.\n• not_equal_to – Returns true if the two parameters are not equal.\n• greater – Returns true if the first parameter is greater than the second.\n• greater_equal – Returns true if the first parameter is greater than or equal to the second.\n• less – Returns true if the first parameter is less than the second.\n• less_equal – Returns true if the first parameter is less than or equal to the second.\n• logical_and – Returns the result of Logical AND operation of two parameters.\n• logical_or – Returns the result of Logical OR operation of two parameters.\n• logical_not – Returns the result of Logical NOT operation of the parameters.\n• bit_and – Returns the result of Bitwise AND operation of two parameters.\n• bit_or – Returns the result of Bitwise OR operation of two parameters.\n• bit_xor – Returns the result of Bitwise XOR operation of two parameters.\n\nThe Utility Library is a collection of utility components provided by the Standard Template Library (STL) that does not fall in the above categories. It offers various features such as pairs, tuples, etc.\n\nThe memory library contains the function that helps users to efficiently manage the memory such as std::move, smart pointers, etc.\n• Move Semantics : It allows the transfer of resources from one object to another without copying.\n• Smart Pointers : They are a wrapper over the raw pointers and helps in avoiding errors associated with pointers.\n• Utility Functions : Utility functions in C++ provide important operations like std::forward to facilitate efficient, generic and safe code manipulation.\n• Integer Sequence : Enable compile-time generation of integer sequences, useful in metaprogramming.\n\nThe key benefit of the STL is that it provides a way to write generic, reusable code and tested code that can be applied to different data types. This means you can write an algorithm once and then use it with other types of data without having to write separate code for each type.\n\nOther benefits include:\n• None STL provides flexibility through customizable templates, functors, and lambdas.\n• None Pre-implemented tools let you focus on problem-solving rather than low-level coding.\n\nThe major limitation of the C++ Standard Template Library (STL) is Performance Overheads. While STL is highly optimized for general use cases, its generic nature can lead to less efficient memory usage and execution time compared to custom and specialized solutions.\n\nOther limitations can be:\n\nDespite these limitations, STL remains an invaluable part of C++ programming, offering a wide range of powerful and flexible tools."
    },
    {
        "link": "https://digitalocean.com/community/tutorials/sort-in-c-plus-plus",
        "document": "Hey there! Today we are going to discuss the sort() function in the std library in C++.\n\nFor basics, Sorting is any process of ordering items systematically. These items could be elements of a sequence or any data structure.\n\nIn C++, the standard library provides a pre-defined and ready to use function to carry out this sorting operation. So let’s get right into it.\n\nThe std::sort() Function in C++\n\nThe function in C++ is a built-in function that is used to sort any form of data structure in a particular order. It is defined in the header file. The function prototype is given below.\n\nHere, the function does not return anything. It just updates the elements/items from the up to the iterables or positions. The third parameter(optional) has to be a function that determines the order in which the elements are going to be sorted. When not specified, the sorting takes place in ascending order considering it to be the function by default.\n\nThe function uses a 3 fold hybrid sorting technique named Introsort. It is a combination of Quick Sort, Heap Sort, and Insertion Sort.\n\nSorting data using the sort() Function in C++\n\nNow that we have gone through the basics of the function, let us use it in our C++ program to sort some data structures(for example arrays).\n\nAs mentioned earlier, by default the function sorts a set of items in ascending order when parameter is not mentioned.\n\nSo for the example below, we have passed just the (starting) and (ending) iterables to sort an array in ascending order.\n\nHere, is the address of the first element and is the address of the last element of the given array. Hence considering comp as function by default, the sort() function sorts the array in ascending order.\n\nNote: the function compares two arguments and returns True or False on the basis of whether the first one is less than the other.\n\nWe can also sort a data structure using the function in descending order by manipulating its third parameter. Let us see how.\n\nIn the code below we have used the function which acts exactly the opposite way the function does. It compares its two arguments and returns True when the first one is greater than the other. Or else returns False.\n\nWe can also use a lambda function as the third parameter for the sort() function as shown below.\n\nBoth the above examples generate the same output as given below. And sort the array in descending order successfully.\n\nThe third parameter(comp) for the function can also be a user-defined function that defines the order or sorting.\n\nOne should note that this function must return a boolean value( / ).\n\nFor example in the code snippet below, we have tried to sort the elements of an array on the basis of the remainders they produce when divided by 10(using ‘ ’ operator).\n\nAs we can see from the above output, the array has been sorted successfully on the basis of ( ) factor. With the help of our function.\n\nComplexity of std::sort() in C++\n\nThe function performs Nlog(N) comparisons for sorting N items. And hence for the worst-case scenario, it has an O(Nlog(N)) complexity.\n\nSo that’s it for this one. Today we understood the use and working of the function in C++ standard library. Hope you had a clear understanding.\n\nPlease note that the sort() function can be used for data structures other than arrays too, like vectors, etc… For this tutorial, we have considered arrays for better understanding.\n\nWe recommend going through our C++ Tutorial.\n\nFor any further questions, feel free to use the comment below."
    },
    {
        "link": "https://learncpp.com/cpp-tutorial/introduction-to-standard-library-algorithms",
        "document": "New programmers typically spend a lot of time writing custom loops to perform relatively simple tasks, such as sorting or counting or searching arrays. These loops can be problematic, both in terms of how easy it is to make an error, and in terms of overall maintainability, as loops can be hard to understand.\n\nBecause searching, counting, and sorting are such common operations to do, the C++ standard library comes with a bunch of functions to do these things in just a few lines of code. Additionally, these standard library functions come pre-tested, are efficient, work on a variety of different container types, and many support parallelization (the ability to devote multiple CPU threads to the same task in order to complete it faster).\n\nThe functionality provided in the algorithms library generally fall into one of three categories:\n• Inspectors -- Used to view (but not modify) data in a container. Examples include searching and counting.\n• Mutators -- Used to modify data in a container. Examples include sorting and shuffling.\n• Facilitators -- Used to generate a result based on values of the data members. Examples include objects that multiply values, or objects that determine what order pairs of elements should be sorted in.\n\nThese algorithms live in the algorithms library. In this lesson, we’ll explore some of the more common algorithms -- but there are many more, and we encourage you to read through the linked reference to see everything that’s available!\n\nNote: All of these make use of iterators, so if you’re not familiar with basic iterators, please review lesson 18.2 -- Introduction to iterators.\n\nUsing std::find to find an element by value\n\nsearches for the first occurrence of a value in a container. takes 3 parameters: an iterator to the starting element in the sequence, an iterator to the ending element in the sequence, and a value to search for. It returns an iterator pointing to the element (if it is found) or the end of the container (if the element is not found).\n\nSample run when the element is found\n\nUsing std::find_if to find an element that matches some condition\n\nSometimes we want to see if there is a value in a container that matches some condition (e.g. a string that contains a specific substring) rather than an exact value. In such cases, is perfect.\n\nThe function works similarly to , but instead of passing in a specific value to search for, we pass in a callable object, such as a function pointer (or a lambda, which we’ll cover later). For each element being iterated over, will call this function (passing the element as an argument to the function), and the function can return if a match is found, or otherwise.\n\nHere’s an example where we use to check if any elements contain the substring “nut”:\n\nIf you were to write the above example by hand, you’d need at least three loops (one to loop through the array, and two to match the substring). The standard library functions allow us to do the same thing in just a few lines of code!\n\nUsing std::count and std::count_if to count how many occurrences there are\n\nand search for all occurrences of an element or an element fulfilling a condition.\n\nIn the following example, we’ll count how many elements contain the substring “nut”:\n\nWe previously used to sort an array in ascending order, but std::sort can do more than that. There’s a version of that takes a function as its third parameter that allows us to sort however we like. The function takes two parameters to compare, and returns true if the first argument should be ordered before the second. By default, sorts the elements in ascending order.\n\nLet’s use to sort an array in reverse order using a custom comparison function named :\n\nOnce again, instead of writing our own custom loop functions, we can sort our array however we like in just a few lines of code!\n\nOur function needs 2 arguments, but we’re not passing it any, so where do they come from? When we use a function without parentheses (), it’s only a function pointer, not a call. You might remember this from when we tried to print a function without parentheses and printed “1”. uses this pointer and calls the actual function with any 2 elements of the array. We don’t know which elements will be called with, because it’s not defined which sorting algorithm is using under the hood. We talk more about function pointers in a later chapter.\n\nTo further explain how uses the comparison function, we’ll have to take a step back to a modified version of the selection sort example from lesson 18.1 -- Sorting an array using selection sort. #include <iostream> #include <iterator> #include <utility> void sort(int* begin, int* end) { for (auto startElement{ begin }; startElement != end-1; ++startElement) { auto smallestElement{ startElement }; // std::next returns a pointer to the next element, just like (startElement + 1) would. for (auto currentElement{ std::next(startElement) }; currentElement != end; ++currentElement) { if (*currentElement < *smallestElement) { smallestElement = currentElement; } } std::swap(*startElement, *smallestElement); } } int main() { int array[]{ 2, 1, 9, 4, 5 }; sort(std::begin(array), std::end(array)); for (auto i : array) { std::cout << i << ' '; } std::cout << '\n\n'; return 0; } So far, this is nothing new and always sorts elements from low to high. To add a comparison function, we have to use a new type, , to store a function that takes 2 int parameters and returns a bool. Treat this type as magic for now, we will explain it in chapter 20. We can now pass a comparison function like to , but how does use it? All we need to do is replace the line Now the caller of can choose how to compare two elements. #include <functional> // std::function #include <iostream> #include <iterator> #include <utility> // sort accepts a comparison function void sort(int* begin, int* end, std::function<bool(int, int)> compare) { for (auto startElement{ begin }; startElement != end-1; ++startElement) { auto smallestElement{ startElement }; for (auto currentElement{ std::next(startElement) }; currentElement != end; ++currentElement) { // the comparison function is used to check if the current element should be ordered // before the currently \"smallest\" element. if (compare(*currentElement, *smallestElement)) { smallestElement = currentElement; } } std::swap(*startElement, *smallestElement); } } int main() { int array[]{ 2, 1, 9, 4, 5 }; // use std::greater to sort in descending order // (We have to use the global namespace selector to prevent a collision // between our sort function and std::sort.) ::sort(std::begin(array), std::end(array), std::greater{}); for (auto i : array) { std::cout << i << ' '; } std::cout << '\n\n'; return 0; }\n\nUsing std::for_each to do something to all elements of a container\n\ntakes a list as input and applies a custom function to every element. This is useful when we want to perform the same operation to every element in a list.\n\nHere’s an example where we use to double all the numbers in an array:\n\nThis often seems like the most unnecessary algorithm to new developers, because equivalent code with a range-based for-loop is shorter and easier. But there are benefits to . Let’s compare to a range-based for-loop.\n\nWith , our intentions are clear. Call with each element of . In the range-based for-loop, we have to add a new variable, . This leads to several mistakes that a programmer could do when they’re tired or not paying attention. For one, there could be an implicit conversion if we don’t use . We could forget the ampersand, and wouldn’t affect the array. We could accidentally pass a variable other than to . These mistakes cannot happen with .\n\nAdditionally, can skip elements at the beginning or end of a container, for example to skip the first element of , can be used to advance begin to the next element.\n\nThis isn’t possible with a range-based for-loop.\n\nLike many algorithms, can be parallelized to achieve faster processing, making it better suited for large projects and big data than a range-based for-loop.\n\nMany of the algorithms in the algorithms library make some kind of guarantee about how they will execute. Typically these are either performance guarantees, or guarantees about the order in which they will execute. For example, guarantees that each element will only be accessed once, and that the elements will be accessed in forwards sequential order.\n\nWhile most algorithms provide some kind of performance guarantee, fewer have order of execution guarantees. For such algorithms, we need to be careful not to make assumptions about the order in which elements will be accessed or processed.\n\nFor example, if we were using a standard library algorithm to multiply the first value by 1, the second value by 2, the third by 3, etc… we’d want to avoid using any algorithms that didn’t guarantee a forwards sequential execution order!\n\nThe following algorithms guarantee sequential execution: , , , , and . Many other algorithms (particular those that use a forward iterator) are implicitly sequential due to the forward iterator requirement.\n\nHaving to explicitly pass and to every algorithm is a bit annoying. But fear not -- C++20 adds ranges, which allow us to simply pass . This will make our code even shorter and more readable.\n\nThe algorithms library has a ton of useful functionality that can make your code simpler and more robust. We only cover a small subset in this lesson, but because most of these functions work very similarly, once you know how a few work, you can make use of most of them."
    },
    {
        "link": "https://geeksforgeeks.org/binary-insertion-sort",
        "document": "Binary insertion sort is a sorting algorithm which is similar to the insertion sort, but instead of using linear search to find the location where an element should be inserted, we use binary search. Thus, we reduce the comparative value of inserting a single element from O (N) to O (log N).\n\nIt is a flexible algorithm, which means it works faster when the same given members are already heavily sorted, i.e., the current location of the feature is closer to its actual location in the sorted list.\n\nIt is a stable filtering algorithm – elements with the same values ??appear in the same sequence in the last order as they were in the first list.\n• Binary insertion sort works best when the array has a lower number of items.\n• When doing quick sort or merge sort, when the subarray size becomes smaller (say <= 25 elements), it is best to use a binary insertion sort.\n• This algorithm also works when the cost of comparisons between keys is high enough. For example, if we want to filter multiple strings, the comparison performance of two strings will be higher.\n• In the binary insertion sort mode, we divide the same members into two subarrays – filtered and unfiltered. The first element of the same members is in the organized subarray, and all other elements are unplanned.\n• Then we iterate from the second element to the last. In the repetition of the i-th, we make the current object our “key”. This key is a feature that we should add to our existing list below.\n• In order to do this, we first use a binary search on the sorted subarray below to find the location of an element larger than our key. Let’s call this position “pos.” We then right shift all the elements from pos to 1 and created Array[pos] = key.\n• We can note that in every i-th multiplication, the left part of the array till (i – 1) is already sorted.\n• Iterate the array from the second element to the last element.\n• Find the position of the element just greater than A[i] in the subarray from A[0] to A[i-1] using binary search. Say this element is at index pos.\n• Shift all the elements from index pos to i-1 towards the right.\n\nBelow is the implementation for the above approach:\n\nTime Complexity: The algorithm as a whole still has a running worst-case running time of O(n2) because of the series of swaps required for each insertion.\n\nAnother approach: Following is an iterative implementation of the above recursive code"
    },
    {
        "link": "https://geeksforgeeks.org/insertion-sort-algorithm",
        "document": "Insertion sort is a simple sorting algorithm that works by iteratively inserting each element of an unsorted list into its correct position in a sorted portion of the list. It is like sorting playing cards in your hands. You split the cards into two groups: the sorted cards and the unsorted cards. Then, you pick a card from the unsorted group and put it in the right place in the sorted group.\n• None We start with second element of the array as first element in the array is assumed to be sorted.\n• None Compare second element with the first element and check if the second element is smaller then swap them.\n• None Move to the third element and compare it with the first two elements and put at its correct position\n• None Repeat until the entire array is sorted.\n\n// C++ program for implementation of Insertion Sort /* Move elements of arr[0..i-1], that are greater than key, to one position ahead /* This code is contributed by Hritik Shah. */ // C program for implementation of Insertion Sort /* Move elements of arr[0..i-1], that are greater than key, to one position ahead /* This code is contributed by Hritik Shah. */ /* Move elements of arr[0..i-1], that are greater than key, to one position ahead /* This code is contributed by Hritik Shah. */ # Move elements of arr[0..i-1], that are # greater than key, to one position ahead # This code is contributed by Hritik Shah. // C# program for implementation of Insertion Sort /* Move elements of arr[0..i-1], that are greater than key, to one position ahead /* This code is contributed by Hritik Shah. */ /* Move elements of arr[0..i-1], that are greater than key, to one position ahead // This code is contributed by Hritik Shah. // Function to sort an array using insertion sort // that are greater than key, to // one position ahead of their // A utility function to print an array of size n // This code is contributed by Hritik Shah.\n• Best case: O(n) , If the list is already sorted, where n is the number of elements in the list.\n• Average case: O(n2) , If the list is randomly ordered\n• Worst case: O(n2) , If the list is in reverse order\n\nPlease refer Complexity Analysis of Insertion Sort for details.\n• None Efficient for small lists and nearly sorted lists.\n• None Space-efficient as it is an in-place algorithm.\n• None is directly proportional to number of swaps. For example, no swapping happens for a sorted array and it takes O(n) time only.\n• None Not as efficient as other sorting algorithms (e.g., merge sort, quick sort) for most cases.\n\nInsertion sort is commonly used in situations where:\n• None The list is small or nearly sorted.\n• None Used as a subroutine in\n• None Can be useful when array is already almost sorted (very few\n• None Since Insertion sort is suitable for small sized arrays, it is used in along with other efficient algorithms like Quick Sort and Merge Sort. When the subarray size becomes small, we switch to insertion sort in these recursive algorithms. For example\n\nQ1. What are the Boundary Cases of the Insertion Sort algorithm?\n\nQ2. What is the Algorithmic Paradigm of the Insertion Sort algorithm?\n\nQ5. When is the Insertion Sort algorithm used?"
    },
    {
        "link": "https://stackoverflow.com/questions/18022192/insertion-sort-with-binary-search",
        "document": "If the cost of comparisons exceeds the cost of swaps, as is the case for example with string keys stored by reference or with human interaction (such as choosing one of a pair displayed side-by-side), then using binary insertion sort may yield better performance. Binary insertion sort employs a binary search to determine the correct location to insert new elements, and therefore performs ⌈log2(n)⌉ comparisons in the worst case, which is O(n log n). The algorithm as a whole still has a running time of O(n2) on average because of the series of swaps required for each insertion.\n\nHere is an example:\n\nWell, if you know insertion sort and binary search already, then its pretty straight forward. When you insert a piece in insertion sort, you must compare to all previous pieces. Say you want to move this [2] to the correct place, you would have to compare to 7 pieces before you find the right place.\n\nHowever, if you start the comparison at the half way point (like a binary search), then you'll only compare to 4 pieces! You can do this because you know the left pieces are already in order (you can only do binary search if pieces are in order!).\n\nNow imagine if you had thousands of pieces (or even millions), this would save you a lot of time. I hope this helps. |=^)"
    },
    {
        "link": "https://interviewkickstart.com/blogs/learn/binary-insertion-sort",
        "document": "Software engineering interviews revolve around tweaking well-known algorithms so that they can be used to solve complex coding problems. Binary insertion sort is one such topic that involves tweaking the well-known insertion sort algorithm. This article is dedicated to analyzing this. We’ll cover:\n\nIn a simple insertion sort algorithm, we maintain a sorted and an unsorted subarray of the given array. In each iteration, one value from the unsorted part is picked and is inserted in its correct position in the sorted part. To achieve this, for every element, we iterate over the sorted part of the array to find the position to insert the element.\n\nSo, it takes O(N) comparisons and O(N) swaps for inserting one element in the worst case (last element). How can we optimize it?\n\nBinary insertion sort is a sorting algorithm similar to insertion sort, but instead of using linear search to find the position where the element should be inserted, we use binary search. Thus, we reduce the number of comparisons for inserting one element from O(N) to O(log N).\n\nIt is an adaptive algorithm, which means that it works faster when the given array is already substantially sorted, i.e., the current position of the element is near its actual position in the sorted array.\n\nIt is a stable sorting algorithm — the elements with the same values appear in the same order in the final array as they were in the initial array.\n\nBinary insertion sort works efficiently when the array has a low number of elements.\n\nWhile performing quicksort or merge sort, when the subarray’s size becomes small (say <=25 elements), it’s more efficient to use binary insertion sort.\n\nThis algorithm is also efficient when the cost of comparison between keys is sufficiently high. For example, if we want to sort an array of strings, the comparison operation of two strings will be high.\n\nIn binary insertion sort, we divide the array into two subarrays — sorted and unsorted. The first element of the array is in the sorted subarray, and the rest of the elements are in the unsorted one.\n\nWe then iterate from the second element to the last element. For the i-th iteration, we make the current element our “key.” This key is the element that we have to add to our existing sorted subarray.\n\nTo do this, we first use binary search on the sorted subarray to find the position of the element that is just greater than our key. Let’s call this position “pos.” We then right shift all elements from position pos to i-1 and then make Array[pos] = key.\n\nWe can note that for every i-th iteration, the left part of the array till (i-1) is always sorted.\n\nSuppose we need to sort the following array:\n• We assume that the first element is already sorted.\n• We take the second element and store it in a variable (key).\n• Now, we use binary search to find the element on the left of the current element, which is just greater than it.\n• In this case, we have only one element, 8, and it is greater than 6. So, we shift 8 one index towards the right and place 6 at its position.\n\nThe array now looks like this:\n• Now, we take the third element, 1. Note that all the elements before the current element are sorted.\n• We store 1 in key and find the element just greater than 1 in the sorted part using binary search.\n• Here, the required element is 6. So, we shift 6 and 8 one index towards the right and place 1 at the position of 6 before shifting.\n\nThe array now looks like this:\n• We now take the 4th element, 5, and store it in key.\n• Using binary search, we find the element just greater than 5 in the sorted part. In this case, the required element is 6.\n• Again, we shift 6 and 8 one index towards the right and place 5 at the position of 6 before shifting.\n\nThe array now looks like this:\n• We now take the last (5th) element, which is 3, and find the element just greater than it in the sorted part.\n• The required element is 5. We shift 5, 6, and 8 one index towards the right and place 3 at the position of 5 before shifting.\n\nWe have sorted the given array using binary insertion sort.\n• Step 1: Iterate the array from the second element to the last element.\n• Step 3: Find the position of the element just greater than A[i] in the subarray from A[0] to A[i-1] using binary search. Say this element is at index pos.\n• Step 4: Shift all the elements from index pos to i-1 towards the right.\n\nFor inserting the i-th element in its correct position in the sorted, finding the position (pos) will take O(log i) steps. However, to insert the element, we need to shift all the elements from pos to i-1. This will take i steps in the worst case (when we have to insert at the starting position).\n\nWe make a total of N insertions — so, the worst-case time complexity of binary insertion sort is O(N^2).\n\nThis occurs when the array is initially sorted in descending order.\n\nThe best case will be when the element is already in its sorted position. In this case, we don’t have to shift any of the elements; we can insert the element in O(1).\n\nBut we are using binary search to find the position where we need to insert. If the element is already in its sorted position, binary search will take (log i) steps. Thus, for the i-th element, we make (log i) operations, so its best-case time complexity is ?(N log N).\n\nThis occurs when the array is initially sorted in ascending order.\n\nFor average-case time complexity, we assume that the elements of the array are jumbled. Thus, on average, we will need O(i /2) steps for inserting the i-th element, so the average time complexity of binary insertion sort is ?(N^2).\n\nBinary insertion sort is an in-place sorting algorithm. This means that it only requires a constant amount of additional space. We sort the given array by shifting and inserting the elements.\n\nTherefore, the space complexity of this algorithm is O(1) if we use iterative binary search. It will be O(logN) if we use recursive binary search because of O(log N) recursive calls.\n\nBinary insertion sort works efficiently for smaller arrays (<= 25 elements). This algorithm also works well for almost-sorted arrays, where the elements are near their position in the sorted array.\n\nHowever, when the size of the array is large, the binary insertion sort doesn’t perform well. We can use other sorting algorithms like merge sort or quicksort in such cases.\n\nMaking fewer comparisons is also one of the strengths of this sorting algorithm; therefore, it is efficient to use it when the cost of comparison is high.\n\nAs stated earlier, binary insertion sort is an improvement of insertion sort. We reduce the number of comparisons in insertion sort by using binary search instead of linear search.\n\nAnswer: Yes, binary insertion sort is a stable sorting algorithm. This means that two different elements with the same value will appear in the same order in the final sorted array as they appeared in the initial array.\n\nIn each iteration, we find the element’s position just greater than our current element in the sorted subarray and insert it there. Thus, if there were any other elements with the same value before our current element in the initial array, they will be present before it in the final sorted array.\n\nQuestion 2. Which sorting algorithm between binary insertion sort and bubble sort uses fewer swaps?\n\nAnswer: Both binary insertion sort and bubble sort use the same number of swaps. For an element at index “i” in the initial array, if its position in the sorted array is “j,” both the algorithms will take abs(i-j) swaps to place it in its sorted position. The total number of swaps used in both the algorithms is equal to the inversion count of the array.\n\nQuestion 3. How many maximum comparisons will be made in binary insertion sort in one iteration?\n\nAnswer: O(Log N). This will happen when we are in the n-th iteration, and the position where the current element should be inserted is such that the binary search takes O(log N) steps.\n\nAre You Ready to Nail Your Next Coding Interview?\n\nSorting algorithms interview questions feature in almost every coding interview for software developers. If you’re looking for guidance and help to nail these questions and more, sign up for our free webinar.\n\nAs pioneers in the field of technical interview prep, we have trained thousands of software engineers to crack the toughest coding interviews and land their dream jobs at Google, Facebook, Apple, Netflix, Amazon, and other Tier-1 tech companies."
    },
    {
        "link": "https://stackoverflow.com/questions/9467731/improving-worst-case-running-time-of-insertion-sort-using-binary-search",
        "document": "insertion sort pushes the elements of the array in order to free a space to the next element in line. \n\n so if you find where to enter the new element using binary search, you will still need to push all the elements after that index one step forward (to the right). \n\n so given an array sorted backwards: 10,9,8,7,6,5,4,3,2,1 \n\n you will need to make i-1 pushes to the right in order to insert the i'th element (even if you use binary search) - worst case time: O(n^2) \n\n if you could insert the elements, one by one, to a list you wouldn't have to push the elements, but you will have to \"pay\" for the search of the proper location in the list (so in this implementation W.C.T is O(n^2)). \n\n\n\na solution to this problem will be with some kind of synergy between lists and arrays so you could reach the i'th element in O(1) time (as in arrays) and could push a new element to a given location (say after the index j) in O(1) time (as in lists) - if you succeed, I believe you will win eternal glory!"
    }
]