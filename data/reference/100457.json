[
    {
        "link": "https://chipverify.com/verilog/verilog-modules",
        "document": "A is a block of Verilog code that implements a certain functionality. Modules can be embedded within other modules and a higher level module can communicate with its lower level modules using their input and output ports.\n\nA module should be enclosed within and keywords. Name of the module should be given right after the keyword and an optional list of ports may be declared as well. Note that ports declared in the list of port declarations cannot be redeclared within the body of the module.\n\nAll variable declarations, dataflow statements, functions or tasks and lower module instances if any, must be defined within the and keywords. There can be multiple modules with different names in the same file and can be defined in any order.\n\nThe module dff represents a D flip flop which has three input ports d , clk , rstn and one output port q . Contents of the module describe how a D flip flop should behave for different combinations of inputs. Here, input d is always assigned to output q at positive edge of clock if rstn is high because it is an active low reset.\n\nThis module will be converted into the following digital circuit during synthesis.\n\nNote that you cannot have any code written outside a module !\n\nWhat is the purpose of a module ?\n\nA module represents a design unit that implements certain behavioral characteristics and will get converted into a digital circuit during synthesis. Any combination of inputs can be given to the module and it will provide a corresponding output. This allows the same module to be reused to form bigger modules that implement more complex hardware.\n\nFor example, the DFF shown above can be chained to form a shift register.\n\nNote that the dff instances are connected together with wires as described by the Verilog RTL module.\n\nInstead of building up from smaller blocks to form bigger design blocks, the reverse can also be done. Consider the breakdown of a simple GPU engine into smaller components such that each can be represented as a module that implements a specific feature. The GPU engine shown below can be divided into five different sub-blocks where each perform a specific functionality. The bus interface unit gets data from outside into the design, which gets processed by another unit to extract instructions. Other units down the line process data provided by previous unit.\n\nEach sub-block can be represented as a with a certain set of input and output signals for communication with other modules and each sub-block can be further divided into more finer blocks as required.\n\nA top-level module is one which contains all other modules. A top-level module is not instantiated within any other module.\n\nFor example, design modules are normally instantiated within top level testbench modules so that simulation can be run by providing input stimulus. But, the testbench is not instantiated within any other module because it is a block that encapsulates everything else and hence is the top-level module.\n\nThe design code shown below has a top-level module called design. This is because it contains all other sub-modules requried to make the design complete. The submodules can have more nested sub-modules like mod3 inside mod1 and mod4 inside mod2. Anyhow, all these are included into the top level module when mod1 and mod2 are instantiated. So this makes the design complete and is the top-level module for the design.\n\nThe testbench module contains stimulus to check functionality of the design and is primarily used for functional verification using simulation tools. Hence the design is instantiated and called d0 inside the testbench module. From a simulator perspective, testbench is the top level module.\n\nA hierarchical structure is formed when modules can be instantiated inside one another, and hence the top level module is called the root. Since each lower module instantiations within a given module is required to have different identifier names, there will not be any ambiguity in accessing signals. A hierarchical name is constructed by a list of these identifiers separated by dots for each level of the hierarchy. Any signal can be accessed within any module using the hierarchical path to that particular signal."
    },
    {
        "link": "https://chipverify.com/tutorials/verilog",
        "document": "Verilog is a hardware description language (HDL) that is used to describe digital systems and circuits in the form of code. It was developed by Gateway Design Automation in the mid-1980s and later acquired by Cadence Design Systems.\n\nVerilog is widely used for design and verification of digital and mixed-signal systems, including both application-specific integrated circuits (ASICs) and field-programmable gate arrays (FPGAs). It supports a range of levels of abstraction, from structural to behavioral, and is used for both simulation-based design and synthesis-based design.\n\nThe language is used to describe digital circuits hierarchically, starting with the most basic elements such as logic gates and flip-flops and building up to more complex functional blocks and systems. It also supports a range of modeling techniques, including gate-level, RTL-level, and behavioral-level modeling.\n\nWhat was used before Verilog ?\n\nBefore the development of Verilog, the primary hardware description language (HDL) used for digital circuit design and verification was VHDL (VHSIC Hardware Description Language). VHDL was developed in the 1980s by the U.S. Department of Defense as part of the Very High-Speed Integrated Circuit (VHSIC) program to design and test high-speed digital circuits.\n\nVHDL is a complex language that enables designers to describe digital systems using a range of abstraction levels, from the low-level transistor and gate levels up to complex hierarchical systems. It was designed to be more descriptive and flexible than earlier HDLs, such as ABEL (Advanced Boolean Expression Language), ISP (Integrated System Synthesis Procedure), and CUPL (Compiler for Universal Programmable Logic).\n\nDespite the development of Verilog and its increasing popularity since the 1980s, VHDL remains a widely used HDL, particularly in Europe and in the military and aerospace industries. Today, both Verilog and VHDL are widely used in digital circuit design and verification, with many companies and organizations using a combination of the two languages.\n\nWhy is Verilog better than its predecessor languages ?\n\nVerilog introduced several important improvements over its predecessor languages, which helped make it a more popular and effective HDL for digital circuit design and verification. Here are a few reasons why Verilog is considered better than its predecessor HDLs:\n• Simpler syntax: Verilog has a simpler syntax compared to VHDL, which allows designers to write code more quickly and with fewer errors.\n• Better support for behavioral modeling: Verilog provides better support for describing the behavior and functionality of digital designs. It supports a range of modeling techniques, from gate-level to behavioral-level modeling, which makes it easier to describe the behavior of complex digital circuits.\n• Higher level of abstraction: Verilog provides a higher level of abstraction than its predecessor languages. It enables designers to describe digital circuits using concepts such as modules and ports, which makes the design process more efficient.\n• Better tool support: Due to its increasing popularity, Verilog has better tool support than its predecessor languages. Verilog has a range of integrated development environments (IDEs) and simulation tools available, which makes it easier to design and verify digital circuits.\n\nHow is Verilog useful ?\n\nVerilog creates a level of abstraction that helps hide away the details of its implementation and technology.\n\nFor example, the design of a D flip-flop would require the knowledge of how the transistors need to be arranged to achieve a positive-edge triggered FF and what the rise, fall and clk-Q times required to latch the value onto a flop among many other technology oriented details. Power dissipation, timing and the ability to drive nets and other flops would also require a more thorough understanding of the physical characteristics of a transistor.\n\nVerilog helps us to focus on the behavior and leave the rest to be sorted out later.\n\nThe following Verilog code describes the behavior of a counter. The counter counts up if the up_down signal is 1, and down if its value is 0. It also resets the counter if the signal rstn becomes 0, making it an active-low reset.\n\nThe simple example shown above illustrates how all the physical implementation details (interconnection of underlying logic gates like NAND and NOR) have been hidden while still providing a clear idea of how the counter functions.\n\nctr is a that represents an up/down counter, and it is possible to choose the actual physical implementation of the design from a wide variety of different styles of flops optimized for area, power and performance. They are usually compiled into libraries and will be available for us to select within EDA tools at a later stage in the design process.\n\nHow is Verilog different from software languages like C and Java ?\n\nVerilog is a hardware description language (HDL) used to describe digital circuits and systems, while C and Java are software programming languages used to write code that runs on general-purpose computers. Here are some of the main differences between Verilog and programming languages like C and Java:\n• Purpose: Verilog is used to describe digital circuits and systems, while C and Java are used to write software programs that run on computers.\n• Syntax: Verilog has a different syntax than C and Java, as it is designed to describe the behavior of digital circuits rather than the execution of software instructions. For example, Verilog describes the properties of wires, registers, and logic gates, while C and Java define variables, functions, and control loops.\n• Execution: Verilog is used to describe how digital circuits should behave, but it doesn't directly execute code. Instead, the Verilog code is compiled into a hardware configuration that can be implemented in a physical circuit or FPGA. C and Java code, on the other hand, is compiled into machine code that can be executed directly by a computer processor.\n• Testing and Verification: Verilog is typically used to simulate the behavior of digital systems before they are physically implemented, while C and Java programs are usually tested and verified through software-based simulations or code reviews.\n• Nesting of Design: In Verilog, the designs can be created as modules and can be reused which is not in the case of programming languages like C and Java where the code is written for a specific purpose.\n\nOverall, Verilog is a specialized language designed specifically for digital circuit design and isn't used for general-purpose programming like C and Java. While there are some similarities in syntax and programming concepts between these languages, the primary focus and application of Verilog is on the design, simulation, and implementation of digital circuits and systems.\n\nWhat may replace Verilog in the future ?\n\nIt's difficult to predict exactly what may replace Verilog in the future, but there are several emerging technologies and languages that may have an impact on the future of digital system design and verification.\n\nOne technology that may affect the future of digital system design is High-Level Synthesis (HLS), which is a technique for automatically generating hardware designs from high-level descriptions in languages like C, C++, and SystemC. HLS allows designers to express their design intents and functionality at a higher level of abstraction, rather than specifying the details of logic gates and register transfers in Verilog or VHDL. This could enable more efficient and rapid design of digital systems, and allow designers to explore more design space in a shorter period of time.\n\nAnother technology that may impact the future of digital system design is machine learning and artificial intelligence (AI), which have the potential to significantly streamline the design and verification process of digital systems. For example, machine learning algorithms can be used to automatically optimize and generate hardware designs, reducing the need for manual design efforts.\n\nThere are also emerging HDLs that are trying to address some of the limitations of Verilog and VHDL, such as Chisel and MyHDL, which are based on more modern programming concepts and provide higher-level abstractions."
    },
    {
        "link": "https://vlsiweb.com/syntax-of-verilog",
        "document": "Welcome to our comprehensive guide on the syntax and structure of Verilog. In this article, we will explore the fundamental aspects of Verilog, including its syntax, structure, and basic principles. Understanding these basics is crucial for anyone looking to master hardware design and simulation using Verilog.\n\nVerilog is a hardware description language used for designing and modeling digital systems. It provides a concise and powerful way to describe complex hardware behavior and interconnections. With Verilog, you can design everything from simple logic gates to advanced processors and complex systems.\n\nBefore diving into Verilog modules and other advanced concepts, it is important to have a solid grasp of the language’s syntax and structure. This foundation will serve as a building block for your future Verilog designs.\n\nThroughout this article, we will cover various topics, starting with the basic syntax of Verilog. We will discuss how Verilog code is structured, the different components it consists of, and the rules you need to follow to ensure correct syntax. By mastering the syntax, you will be able to write clean and efficient Verilog code.\n\nNext, we will move on to Verilog modules and their hierarchical structure. We will explore how to define modules, instantiate them, and establish a hierarchical design to create complex systems. This understanding will allow you to break down your designs into manageable modules while maintaining the overall system integrity.\n\nWe will then delve into Verilog data types and variables. Understanding and effectively using data types and variables in Verilog is crucial for implementing the desired functionality in your hardware designs. We will explore the different data types available and learn how to declare and use variables effectively.\n\nAnother important aspect we will cover is Verilog procedural blocks and control statements. These constructs enable you to implement decision-making and repetitive behaviors in your Verilog designs. We will discuss how to use if-else statements, for loops, and other control structures to create dynamic and responsive systems.\n\nIn conclusion, this article aims to provide you with a solid understanding of the basic syntax and structure of Verilog. By familiarizing yourself with Verilog modules, data types, variables, procedural blocks, and control statements, you will be well-equipped to design and simulate hardware systems using Verilog. Let’s embark on this Verilog journey together and unlock the potential of hardware design!\n\nIn this section, we will explore the concept of Verilog modules and their hierarchical structure. Understanding how to define and use Verilog modules is crucial for creating complex hardware systems. By leveraging module instantiation and establishing a hierarchical design, we can effectively organize our Verilog code and enhance the scalability and reusability of our hardware designs.\n\nVerilog modules are blocks of code that encapsulate a specific functionality or component within a hardware system. These modules serve as building blocks for our designs, allowing us to break down complex systems into smaller, more manageable components. By modularizing our code, we can improve readability, maintainability, and ease of debugging.\n\nTo define a Verilog module, we use the keyword, followed by the module name and a list of input and output ports. Each port is associated with a specific signal or data connection that allows communication between different modules or components of the system.\n\nOnce we have defined a Verilog module, we can instantiate it within another module or at the top level of our design. This process involves creating an instance of the module and connecting the input and output ports to the appropriate signals or data paths.\n\nModule instantiation allows for a hierarchical design approach, where we can build complex systems by connecting and interconnecting different modules. This hierarchical structure promotes modularity, reusability, and efficient design organization.\n\nIn Verilog, a hierarchical design refers to the arrangement of modules in a structured and organized manner. By breaking down a system into smaller, self-contained modules, we can create a hierarchical structure that reflects the system’s functional hierarchy.\n\nThis hierarchical design approach offers several advantages. It enables parallel development of different modules by different team members, promotes code reuse, simplifies debugging and testing, and facilitates system integration.\n\nBy carefully designing and structuring our Verilog code using modules and establishing a hierarchical structure, we can achieve highly efficient and scalable hardware designs. This approach enhances code readability, minimizes complexity, and allows for seamless collaboration within a team working on the same project.\n\nIn Verilog, data types and variables play a crucial role in designing and modeling hardware systems. Understanding how to declare and use variables effectively is essential to the success of your Verilog projects. In this section, we will explore the various Verilog data types and learn how to work with variables.\n\nVerilog provides several data types that allow you to represent different kinds of information in your hardware designs. These data types include:\n• Array – represents a collection of elements of the same data type.\n\nEach data type has its own purpose and usage in Verilog, allowing you to model and simulate hardware systems with precision and accuracy.\n\nTo use data types effectively, you need to declare variables in Verilog. Variable declaration allows you to allocate memory and define the properties of the variable, such as its name, data type, and initial value.\n\nHere’s an example of declaring a variable in Verilog:\n\nBy declaring variables, you can store and manipulate data within your Verilog designs. Variables allow you to represent and simulate real-world behavior, making your hardware models more dynamic and versatile.\n\nNow that we understand the importance of data types and variable declaration in Verilog, let’s put them into practice in our hardware designs.\n\nIn this section, we will explore the powerful features of Verilog procedural blocks and control statements that enable us to implement decision-making and repetitive behaviors in our designs.\n\nVerilog allows us to define procedural blocks within our code to group related statements together. Procedural blocks provide a structured way to control the flow of execution based on specific conditions or events. The most commonly used procedural block in Verilog is the always block, which executes its statements whenever certain conditions are met or events occur.\n\nConsider the following example:\n\nIn this code snippet, the always @(posedge clk) block is triggered on the positive edge of the clock signal. Inside the block, we use an if-else statement to increment the counter variable by 1 if the reset signal is not active. Otherwise, we reset the counter to 0.\n\nVerilog provides several control statements that allow us to structure our code and control the flow of execution based on specific conditions. These control statements include the if-else statement, the for loop, and the case statement.\n\nThe if-else statement allows us to make decisions and execute different sets of statements based on certain conditions. Here’s an example:\n\nThe for loop allows us to repeat a set of statements for a specified number of iterations. Here’s an example:\n\nThe case statement allows us to select a set of statements to execute based on the value of a variable or an expression. Here’s an example:\n\nBy utilizing these Verilog control statements, we can create complex decision-making and repetitive behaviors that are essential for designing efficient and functional hardware systems.\n\nIn conclusion, we have explored the basic syntax and structure of Verilog, an essential language for hardware design. By understanding the Verilog modules, data types, variables, procedural blocks, and control statements, you will have gained the necessary knowledge to design and simulate complex hardware systems effectively.\n\nMastering Verilog syntax is crucial for hardware designers as it forms the foundation for creating robust and efficient designs. With Verilog’s hierarchical structure, you can build complex systems by dividing them into smaller modules, enabling easier design reuse and maintenance.\n\nMoreover, by utilizing Verilog’s wide range of data types and variables, you can create flexible and adaptive designs that meet the specific requirements of your hardware projects. Verilog’s procedural blocks, along with control statements like if-else and for loop, allow you to implement decision-making logic and repetitive behaviors, adding dynamic capabilities to your designs.\n\nIn summary, a solid understanding of Verilog syntax and structure is crucial for successful hardware design. By using Verilog effectively, you can create efficient and reliable hardware designs, ensuring optimal performance in various electronic systems."
    },
    {
        "link": "https://singhcoder.github.io/Icarus_Verilog/Lab1/Lab1_Sheet.pdf",
        "document": ""
    },
    {
        "link": "https://digikey.com/en/maker/blogs/2024/mastering-verilog-syntax-and-data-types-part-4-of-our-verilog-journey",
        "document": "Welcome to our guide on Verilog syntax and data types. Whether you're new to digital design or a seasoned pro, this blog will unlock the power of Verilog's language, from intricate digital logic to complex hardware modeling. Let's embark on this journey to Verilog mastery!\n\nIn Verilog, syntax refers to the set of rules and conventions that govern how you write and structure your Verilog code. It defines the correct way to represent digital logic, describe hardware components, and specify the behavior of a digital system. Understanding and adhering to Verilog syntax is essential for creating valid and functional designs. Here are some key aspects of Verilog syntax:\n\nModule Declaration: A Verilog design typically starts with the declaration of one or more modules. Modules encapsulate different parts of the design and define their inputs, outputs, and internal logic.\n• Data Types: Verilog supports various data types, including wire, reg, and integer, among others. These data types define how signals are stored and manipulated within the design.\n• Operators: Verilog provides a range of operators for performing logical, arithmetic, and bitwise operations. These operators are used to define the behavior of digital circuits.\n• Statements and Blocks: Verilog code consists of statements and blocks. Statements represent actions or operations, while blocks group statements together. Common blocks include always and begin/end blocks.\n• Conditional and Looping Constructs: Verilog includes if-else statements and loop constructs like for and while for conditional logic and iteration.\n• Comments: Comments in Verilog are used to provide explanations and descriptions within the code. They are preceded by double slashes (//) for single-line comments or enclosed within /* */ for multi-line comments.\n• Hierarchy: Verilog allows for hierarchical design, where modules can be instantiated within other modules to create complex systems. This is achieved using instantiation statements.\n\nUnderstanding and following Verilog syntax is crucial to writing valid and functional digital designs. It ensures that your code accurately represents the desired behavior of the digital circuit and can be synthesized into actual hardware.\n\nVerilog is a hardware description language (HDL) used for modeling and designing digital circuits. While Verilog doesn't have traditional \"keywords\" in the same way that programming languages do, it does have a set of reserved words and system tasks/functions that have specific meanings within the language. These words and tasks/functions are essential for writing Verilog code correctly.\n\nHere are some of the most commonly used reserved words and system tasks/functions in Verilog:\n\nIn Verilog, data types define how data is stored and manipulated within the design. They determine the behavior of signals, registers, and variables in the digital circuit. Verilog provides several data types to accommodate different types of data and hardware modeling requirements. Here are some common Verilog data types:\n• wire: Wires are continuous signals that represent connections between different parts of the circuit. They are used for data flow and interconnecting gates. Wires cannot store values.\n• reg: Registers are used to store and represent data in sequential logic elements, such as flip-flops. They can store values and are primarily used for state-holding elements.\n• integer: Integer data types are used to represent signed integer values. They are commonly used for indexing and loop counters.\n• real: Real data types are used to represent real (floating-point) values. They are less common in hardware modeling but may be used for certain calculations or simulations.\n• time: Time data types represent time values in simulation. They are used for specifying delays, timing constraints, and simulation durations.\n• parameter: Parameters are constants that can be defined at the module level. They allow you to set configurable values for the design.\n• Enums allow you to define a set of symbolic values, which can make the code more readable and maintainable.\n• Verilog supports arrays for organizing data elements of the same type into a collection. Arrays can be one-dimensional or multi-dimensional.\n\nThese are some of the common data types used in Verilog. The choice of datatype depends on the specific requirements of your digital design, including whether you need continuous signals (wires), registers for sequential logic, or other data types for specialized purposes."
    },
    {
        "link": "https://chipverify.com/verilog/verilog-operators",
        "document": "Data that cannot be processed is quite useless, there'll always be some form of calculation required in digital circuits and computer systems. Let's look at some of the operators in Verilog that would enable synthesis tools realize appropriate hardware elements.\n\nIf the second operand of a division or modulus operator is zero, then the result will be X. If either operand of the power operator is real, then the result will also be real. The result will be 1 if the second operand of a power operator is 0 (a0).\n\nAn example of how arithmetic operators are used is given below.\n\nAn expression with the relational operator will result in a 1 if the expression is evaluated to be true, and 0 if it is false. If either of the operands is X or Z, then the result will be X. Relational operators have a lower precedence than arithmetic operators and all relational operators have the same precedence.\n\nEquality operators have the same precedence amongst them and are lower in precedence than relational operators. The result is 1 if true, and 0 if false. If either of the operands of logical-equality (==) or logical-inequality (!=) is X or Z, then the result will be X. You may use case-equality operator (===) or case-inequality operator (!==) to match including X and Z and will always have a known value.\n\nThe result of a logical and (&&) is 1 or true when both its operands are true or non-zero. The result of a logical or (||) is 1 or true when either of its operands are true or non-zero. If either of the operands is X, then the result will be X as well. The logical negation (!) operator will convert a non-zero or true operand into 0 and a zero or false operand into 1, while an X will remain as an X.\n\nThis operator will combine a bit in one operand with its corresponding bit in the other operand to calculate a single bit result.\n\nThere are two kinds of shift operators:"
    },
    {
        "link": "https://chipverify.com/verilog/verilog-combinational-logic-assign",
        "document": "The verilog assign statement is typically used to continuously drive a signal of datatype and gets synthesized as combinational logic. Here are some more design examples using the statement.\n\nThe code shown below implements a simple digital combinational logic which has an output wire z that is driven continuously with an statement to realize the digital equation.\n\nThe module combo gets elaborated into the following hardware schematic using synthesis tools and can be seen that the combinational logic is implemented with digital gates.\n\nThe testbench is a platform for simulating the design to ensure that the design does behave as expected. All combinations of inputs are driven to the design module using a loop with a delay statement of 10 time units so that the new value is applied to the inputs after some time.\n\nThe half adder module accepts two scalar inputs a and b and uses combinational logic to assign the outputs sum and carry bit cout . The sum is driven by an XOR between a and b while the carry bit is obtained by an AND between the two inputs.\n\nA full adder can be built using the half adder module shown above or the entire combinational logic can be applied as is with statements to drive the outputs sum and cout .\n\nThe simple 2x1 multiplexer uses a ternary operator to decide which input should be assigned to the output c . If sel is 1, output is driven by a and if sel is 0 output is driven by b .\n\nThe demultiplexer uses a combination of sel and f inputs to drive the different output signals. Each output signal is driven by a separate statement. Note that the same signal is generally not recommended to be driven by different statements."
    },
    {
        "link": "https://allaboutcircuits.com/technical-articles/describing-combinational-circuits-in-verilog",
        "document": "This article introduces the techniques for describing combinational circuits in Verilog by examining how to use the conditional operator to describe combinational truth tables. It also shows how to utilize the Verilog “always” block for describing combinational circuits—an “always” block can provide us with an even easier solution to describe a digital circuit.\n\nIn a previous article, we discussed the use of the Verilog “assign” keyword to perform a continuous assignment. Such assignments are always active and can be used to acquire a gate-level description of digital circuits. For example, in the following code, which describes an AND gate, the right-hand side is continuously evaluated and the result is put on the out1 net:\n\nVerilog has a conditional operator (?:) which allows us to check a condition before making such assignments. The syntax is given below:\n\nThe “conditional_expression” is evaluated. If it’s true, “value_if_true” is assigned to “signal_name”. If it’s not true, “signal_name” gets “value_if_false”. As an example, consider the following code:\n\nIf “sel” is true, a&b will be assigned to “out1”. If it’s not true, “out1” will get a|b. Hence, the above code implements the functionality of a 2-to-1 multiplexer. The conceptual implementation of this code can be as shown in Figure 1 below.\n\nThe conditional assignment allows us to have a more abstract description of certain circuits because it has the functionality of an “if” statement found in traditional computer programming languages. The conditional operator can be used in a nested form to implement more complex circuits. Example 1 discusses these details.\n\nUse the conditional operator (?:) to describe a 4-to-2 priority encoder with the following truth table:\n\nThe Verilog code for this priority encoder is given below:\n\nAside from lines 7 through 10, the code contains the basic language elements discussed in our previous article. So let’s take a look at these lines.\n\nThe terms 2’b11, 2’b10, 2’b01 refer to the Verilog notations that represent two-bit binary numbers. In general, the first number (before ‘b) specifies the number of bits. The letter b specifies that the numbers are binary. The digits after ‘b give the value of the number. Hence, 2’b01 is the Verilog notation to represent a two-bit binary number with value 01 and 3’b100 denotes a three-bit binary number with value 100.\n\nLine 7 checks the MSB of the input, x[3], in a conditional operator. If x[3]=1, the condition is evaluated as true and 2’b11 is assigned to y (the assigned value is taken from the truth table). If x[3]=0, the condition is evaluated as false and the expression after the colon (:) will be assigned to y. The expression after the colon is the code in Line 8 which is itself another conditional operator.\n\nThe second conditional operator in Line 8 examines the second most significant bit of the input, x[2], to determine whether 2’b10 should be assigned to y or the expression after the colon which is again another conditional operator (Line 9) should be evaluated. You can verify that the values assigned to y match the given truth table.\n\nThe valid output (v) of the truth table will be logic high if at least one bit of the input is logic high. Line 11 shows this description by applying the bitwise OR operator (|) to the bits of the input. A Xilinx ISE simulation of the above code is shown in Figure 2.\n\nFigure 2. A Xilinx ISE simulation from the above code.\n\nIt’s important to note that the conditional expressions are evaluated successively until a true expression is found. The assignment corresponding to this true expression will be performed. As a result, the expressions evaluated earlier have a higher priority in comparison to the next ones. This means that, theoretically, a conditional operator is more suitable for implementing a priority network (Figure 3) rather than a balanced structure such as a multiplexer (Figure 4).\n\nFigure 4. An n-to-1 multiplexer wherein there’s no priority between the inputs.\n\nWe can pull apart any combinational circuit into a few basic logic gates (AND, OR, NOT, etc.) and use the “assign” statement to describe these gates (a gate-level description). We can also use the conditional operator discussed in the previous section to have a more abstract way of describing some combinational circuits (similar to the “if” statement of computer programming languages). However, there’s still a more powerful solution: using the Verilog “always” block.\n\nInside an “always” block, we can have procedural statements that are executed in sequence. Moreover, the “always” block supports abstract language constructs such as “if” and “case” statements.\n\nThe sequential execution feature along with the abstract language constructs available within an “always” block allows us to more easily describe the functionality of a circuit, due to the fact that human reasoning has a sequential nature and relies on abstract descriptions. We usually think in an algorithmic high-level fashion rather than in terms of low-level logic gates. An “always” block can provide us with an easier solution to describe a digital circuit. For more details about why HDLs support descriptions based on sequential statements, please see my article Introduction to Sequential VHDL Statements.\n\nThe simplified syntax of an “always” block is given below:\n\nThe sensitivity_list specifies when the sequential statements inside the “always” block should be executed. For example, consider using the “always” block to describe the circuit in Figure 5.\n\nWhen either a or b changes the output may change, which means both a and b should be in the sensitivity list of the “always” block. In general, for a combinational circuit, all the input signals should be included in the sensitivity list.\n\nNow, we can use the bitwise AND operator to describe the functionality of the circuit (a&b) and assign the result to the output. Within an “always” block, there are two different types of assignments: the blocking assignment (=) and the non-blocking assignment (<=). Using the blocking assignment, we obtain the following code:\n\nWhat’s the difference between a blocking assignment and a non-blocking assignment?\n\nWith a blocking assignment, the right-hand side is evaluated and immediately assigned to out1. Hence, when Line 3 is executed, out1 gets immediately updated before we go to the next line of the code. The name “blocking assignment” emphasizes that the upcoming lines are blocked until the left-hand side gets updated.\n\nWith a non-blocking assignment, the right-hand expression is evaluated but it’s not applied to the left-hand variable until we reach the end of the “always” block. The choice of blocking or non-blocking assignment can be confusing for a beginner and improper use of them can lead to an undesired functionality. For example, using blocking assignments to infer flip-flops may introduce a race condition.\n\nFor this introductory article, we won’t further go into details and we’ll only stick to one simple guideline to avoid potential pitfalls: Use the blocking assignments when writing the code for a combinational circuit. Hence, the “always” block in Listing 1 will be used to describe an AND gate.\n\nIn a previous article, we got familiar with the Verilog “wire” data type. This data type represents a physical wire in our FPGA design. Within an “always” block, the Verilog standard doesn’t allow us to assign a value to a “wire”. Instead, we use the “reg” data type. The name “reg” is somewhat confusing, but note that a “reg” may or may not lead to a physical storage element in your design. The following code is the Verilog description of Figure 5 using an “always” block. Note that the output data type should be “reg” because it gets its value from a procedural assignment.\n\nIn this article, we got familiar with the Verilog conditional operator. We used the nested form of this operator to describe a priority encoder. Then, we touched on a more powerful language construct, the “always” block, to describe combinational circuits. In future articles, we’ll examine the use of the “always” block to implement sequential circuits."
    },
    {
        "link": "https://vlsiverify.com/verilog/verilog-operators",
        "document": "The Verilog operators are similar to the C programming language operator that is used to produce results based on the required operation. Verilog provides different categories of operators\n\nThe equality and inequality operator compares two operands bit by bit and results to 1 or 0 if true or false respectively. They will return value as ‘x’ if either operand has x or z bits. The case equality and case inequality compares two operands bit by bit even for x and z bits and results in 1 or 0 if true or false respectively. They perform an exact bit-by-bit comparison. If any of the bits is not matched, the result will be 0 (false).\n• None For unequal length in operands, it fills zeroes at MSB, and a comparison is performed.\n• None The key difference between equality and case equality is in terms of producing results. The case equality never produces an ‘x’ result whereas equality will produce an ‘x’ result if any of the operands has ‘x’ bits.\n\nThe relational operation is performed on two operands to returns 1 if the expression is true, otherwise returns 0 if the expression is false. Note: The ‘z’ is treated as ‘x’ in a relational operation.\n\nThe bitwise operator performs bit by bit operation on one operand and a corresponding bit on the other operand. For any mismatch in length, extra zeros are appended.\n• None The ‘z’ is treated as ‘x’ in a bitwise operation. The bitwise operator follows the below truth table in an operation.\n\nThe <conditional_expression> is evaluated first. If the result is\n• None X (ambiguous ) then both <true_expression> and <false_expression> are evaluated and their results are compared bit by bit. Each bit position of outcome is returned as \n\na. bit value if both bits are the same. \n\nb.\n\nLogical shift: Logical shift operators shift a vector to left or right by a specified number of bits and fill vacant bit positions with zeros. Arithmetic shift: Arithmetic shift operators shift a vector to left or right by a specified number of bits and fill vacant bit positions with sign bit if an expression is signed, otherwise with zeros. Note: Shift operators do not wrap around."
    },
    {
        "link": "https://users.wpi.edu/~rjduck/Verilog%20for%20synthesis%20-%20combinational%20rev%20a.pdf",
        "document": ""
    }
]