[
    {
        "link": "https://vuejs.org/guide/reusability/custom-directives",
        "document": "In addition to the default set of directives shipped in core (like or ), Vue also allows you to register your own custom directives.\n\nWe have introduced two forms of code reuse in Vue: components and composables. Components are the main building blocks, while composables are focused on reusing stateful logic. Custom directives, on the other hand, are mainly intended for reusing logic that involves low-level DOM access on plain elements.\n\nA custom directive is defined as an object containing lifecycle hooks similar to those of a component. The hooks receive the element the directive is bound to. Here is an example of a directive that adds a class to an element when it is inserted into the DOM by Vue:\n\nIn , any camelCase variable that starts with the prefix can be used as a custom directive. In the example above, can be used in the template as . If you are not using , custom directives can be registered using the option:\n\nIt is also common to globally register custom directives at the app level:\n\nWhen to use custom directives ​\n\nCustom directives should only be used when the desired functionality can only be achieved via direct DOM manipulation.\n\nA common example of this is a custom directive that brings an element into focus.\n\nThis directive is more useful than the attribute because it works not just on page load - it also works when the element is dynamically inserted by Vue!\n\nDeclarative templating with built-in directives such as is recommended when possible because they are more efficient and server-rendering friendly.\n\nA directive definition object can provide several hook functions (all optional):\n\n// see below for details on arguments // called right before the element is inserted into the DOM. // and all its children are mounted. // called before the parent component is updated // called after the parent component and // all of its children have updated // called before the parent component is unmounted // called when the parent component is unmounted\n• None : the element the directive is bound to. This can be used to directly manipulate the DOM.\n• None : an object containing the following properties.\n• : The value passed to the directive. For example in , the value would be .\n• : The previous value, only available in and . It is available whether or not the value has changed.\n• : The argument passed to the directive, if any. For example in , the arg would be .\n• : An object containing modifiers, if any. For example in , the modifiers object would be .\n• : The instance of the component where the directive is used.\n• None : the VNode representing the bound element from the previous render. Only available in the and hooks.\n\nAs an example, consider the following directive usage:\n\nThe argument would be an object in the shape of:\n\nSimilar to built-in directives, custom directive arguments can be dynamic. For example:\n\nHere the directive argument will be reactively updated based on property in our component state.\n\nIt's common for a custom directive to have the same behavior for and , with no need for the other hooks. In such cases we can define the directive as a function:\n\nIf your directive needs multiple values, you can also pass in a JavaScript object literal. Remember, directives can take any valid JavaScript expression.\n\nWhen used on components, custom directives will always apply to a component's root node, similar to Fallthrough Attributes.\n\nNote that components can potentially have more than one root node. When applied to a multi-root component, a directive will be ignored and a warning will be thrown. Unlike attributes, directives can't be passed to a different element with ."
    },
    {
        "link": "https://dev.to/sucodelarangela/vue3-directives-cheat-sheet-built-in-and-custom-en-35mh",
        "document": "One of the advantages of Vue is the ease of manipulating the through special attributes called Directives. In addition to having several built-in directives, Vue also allows us to create custom ones.\n\nIf you're tired of using 's and 's, then this article is for you!\n\nDirectives are nothing more than template-manipulating attributes used in HTML tags. With them, we can dynamically alter our DOM, adding or omitting information and elements (Leonardo Vilarinho in Front-end com Vue.js: Da teoria à prática sem complicações).\n\nVue has a large number of built-in directives. To better understand how to use them, we'll walk through some practical examples for each one (you can also directly access some examples in Vue’s documentation).\n\nThe directive is used to and works exactly the same as mustache interpolation ( ). The difference in usage between them is that will replace the entire of the element, while interpolation allows you to replace only parts of the content.\n\nThe directive is used to (equivalent to using in JavaScript). It's a directive that should be used with caution, as it can allow for XSS (Cross-site Scripting) attacks, where malicious code can be injected into your application's DOM.\n\nThe directive dynamically changes the element's property based on the received value. In the example above, when the state is , the paragraph receives (the default display of a element). Clicking the button changes the state to and assigns to the paragraph.\n\nConsidered as some of the most used directives in Vue, , , and , are used for and follow the same logic as , , and in vanilla JavaScript. In the example, if is , we render a paragraph; however, if it's , we render an anchor; and in any other case, we render a component called .\n\nThe directive renders a list of elements or components by iterating over an array or object, similar to a . In our example:\n• we have an array of objects called ;\n• using the directive, we iterate over this array using the syntax to access each element of the iteration;\n• each will be an object from our array. Thus, we will have two , resulting in two paragraphs;\n• each paragraph will render the value of the key of each .\n\nAn important point about is that we need to provide a special attribute, which must receive a unique value. This value can be derived directly from our or we can use the of our array (which is not recommended if you need to manipulate the items in the array, as it can result in errors).\n\n\n\nThe directive (or simply as a shorthand) similar to what we would do with JavaScript's .\n\nAny standard JavaScript event can be used with the directive, which also accepts behavior modifiers and/or key modifiers.\n\nIn the code block above, we have some examples of events, such as (or ) and (or ), and we also show some events with modifiers, like (referring to ) and (which identifies the \"Enter\" key for the event).\n\nThe directive is used to create/bind dynamic HTML attributes to elements or to pass props to child components. The directive can be abbreviated to just as a shorthand.\n\nIn our examples, we have:\n• An state used as the attribute of an image, as well as a state used as a dynamic class;\n• The shortened form , for when the variable name is the same as the attribute name;\n• An example of dynamically assigning a \"myClass\" class if the state is truthy;\n• An example of a prop being passed to a child component.\n\nThe directive creates two-way data bindings, making it easy to synchronize states between inputs, selects, and components.\n\nIn the example above, the state is bound to an via , so when you type in the input, the value of is automatically updated with what was typed. Similarly, if we have a function that changes the value of , for example, the input will reflect that change.\n\nWe can also use to create this two-way binding from parent to child component:\n\n\n\nThe directive is used to define and use slots in components. Slots are a way to pass content to a child component more flexibly than through props and can be named or unnamed, helping you insert elements into the child component in the correct places.\n\nIn the example above, we have a ChildComponent consisting of a that encompasses two named slots: and . When using the child component, we pass two elements ( and ) to it through templates that use the directive with the name of the slot we want each element to receive. The directive can be abbreviated with the symbol.\n\nThe directive ignores the compilation of the element it's used on, as well as all its child elements, rendering the content that would be dynamic as plain text (the first paragraph will render while the second paragraph will render ).\n\nThe directive helps with performance by rendering the content of an element only once, making it static thereafter. Above, the paragraph will render the state only once and will remain static even if the value of changes later.\n\nThe directive is somewhat similar to , but it limits the re-rendering of the element or component to changes in one or more states, which must be passed as dependencies of the directive. In our example, we have a function whose result should be rendered inside the . However, this re-rendering should only occur if the value of is updated, as it is referenced in the directive as a dependency.\n\nThis directive is used for micro-optimizations of rendering, used more commonly in more complex components. However, if your component's logic is following best practices, the need to use becomes almost nonexistent.\n\nFor example, if were a computed property, we wouldn't need , as computed properties do exactly what the directive does: they cache values and only update them again when dependencies change:\n\n\n\nThe directive prevents uncompiled content from being rendered on the screen until Vue finishes its initialization (which typically happens when creating a Vue application directly in an HTML file via CDN). In the example above, the directive will hide the paragraph until the state is initialized and the component is fully mounted.\n\nCustom directives allow you to bind Vue states to HTML elements, manipulating them according to your application's business rules. This way, you'll have greater control over the application's layout.\n\nThese directives are defined as an object that contains lifecycle hooks (the same ones we use in components), and each hook receives the element on which the directive will be used. The Vue documentation offers very easy-to-understand examples.\n\nHere we have a local custom directive called that automatically focuses on an input when the component is mounted. With the Options API, we need to declare our directive inside the object, but in the Composition API, we simply create a variable (which must start with 'v').\n\nImagine that you need to use the directive in multiple components. This would generate a lot of repeated code in your application, as you would have to redeclare the directive in every component where you intend to use it, right?\n\nTo avoid this repetition, we can extract the logic of our new directive to a file in the directives folder:\n\n\n\nNow, just import the directive into the desired component and use it:\n\n\n\nIf you need to use a particular custom directive very often, a more suitable solution might be to declare it globally in your or file:\n\n\n\nSo far, we've learned how to create simple custom directives. But what if you want a more complex directive that has action modifiers, like ?\n\nA directive can have up to four types of attributes that can be used in its declaration, with the most important (and our focus in this article) being the following:\n• : The element on which the directive is being used (as we saw in ); and\n• : Object containing various properties that we can use in our directives, such as (the value passed in the directive) and , which is what we will use to create our modifiers.\n\nFor example, if we have the directive , our object would be:\n\n\n\nLet's see how to create a directive to format text in uppercase, lowercase, or capitalized letters.\n\n1. We create the initial structure of the directive, which will execute actions when the element is mounted in the component. Note that we are using and as parameters of our hook:\n\n\n\n2. We'll create a variable that will identify the modifier used in the directive. When we use a modifier in a directive, they are saved in a object within the object. So, if we use , will be and the value of the variable will be :\n\n\n\n3. Now we'll create the variable, which contains the text formatting functions for our directive. We'll capture the of the element the directive will be used on and format it to uppercase, lowercase, or capitalized:\n\n\n\n4. Finally, let's identify the modifier and execute the function that corresponds to it:\n\n\n\nGreat! Our directive is complete and ready to be used in a component. Let's see an example:\n\n\n\nHow about seeing how this directive would be with the Options API?\n\n\n\nUsing the directive in a component:\n\n\n\nAnd always remember that you can also register the directive globally in the file:\n\n\n\nPhew! I think we've seen enough...\n\nCreating custom directives which are more complet may seem a bit confusing at first, but nothing that practice can't solve!\n\nKnowing how to use Vue's built-in directives will be essential for your Vue application to always have great performance when dealing with component rendering and DOM manipulation, as well as being great for your developer experience, making your work easier and your code more elegant.\n\nHowever, never say never, my young Padawan. In more complex situations, you may realize that a can still be a lifesaver from time to time!\n\nI hope this article is helpful. See you next time!"
    },
    {
        "link": "https://vuejs.org/guide/essentials/list",
        "document": "We can use the directive to render a list of items based on an array. The directive requires a special syntax in the form of , where is the source data array and is an alias for the array element being iterated on:\n\nInside the scope, template expressions have access to all parent scope properties. In addition, also supports an optional second alias for the index of the current item:\n\nThe variable scoping of is similar to the following JavaScript:\n\nNotice how the value matches the function signature of the callback. In fact, you can use destructuring on the item alias similar to destructuring function arguments:\n\nFor nested , scoping also works similar to nested functions. Each scope has access to parent scopes:\n\nYou can also use as the delimiter instead of , so that it is closer to JavaScript's syntax for iterators:\n\nYou can also use to iterate through the properties of an object. The iteration order will be based on the result of calling on the object:\n\nYou can also provide a second alias for the property's name (a.k.a. key):\n\nAnd another for the index:\n\ncan also take an integer. In this case it will repeat the template that many times, based on a range of .\n\nNote here starts with an initial value of instead of .\n\nSimilar to template , you can also use a tag with to render a block of multiple elements. For example:\n\nWhen they exist on the same node, has a higher priority than . That means the condition will not have access to variables from the scope of the :\n\nThis can be fixed by moving to a wrapping tag (which is also more explicit):\n\nWhen Vue is updating a list of elements rendered with , by default it uses an \"in-place patch\" strategy. If the order of the data items has changed, instead of moving the DOM elements to match the order of the items, Vue will patch each element in-place and make sure it reflects what should be rendered at that particular index.\n\nThis default mode is efficient, but only suitable when your list render output does not rely on child component state or temporary DOM state (e.g. form input values).\n\nTo give Vue a hint so that it can track each node's identity, and thus reuse and reorder existing elements, you need to provide a unique attribute for each item:\n\nWhen using , the should be placed on the container:\n\nIt is recommended to provide a attribute with whenever possible, unless the iterated DOM content is simple (i.e. contains no components or stateful DOM elements), or you are intentionally relying on the default behavior for performance gains.\n\nThe binding expects primitive values - i.e. strings and numbers. Do not use objects as keys. For detailed usage of the attribute, please see the API documentation.\n\nYou can directly use on a component, like any normal element (don't forget to provide a ):\n\nHowever, this won't automatically pass any data to the component, because components have isolated scopes of their own. In order to pass the iterated data into the component, we should also use props:\n\nThe reason for not automatically injecting into the component is because that makes the component tightly coupled to how works. Being explicit about where its data comes from makes the component reusable in other situations.\n\nVue is able to detect when a reactive array's mutation methods are called and trigger necessary updates. These mutation methods are:\n\nMutation methods, as the name suggests, mutate the original array they are called on. In comparison, there are also non-mutating methods, e.g. , and , which do not mutate the original array but always return a new array. When working with non-mutating methods, we should replace the old array with the new one:\n\nYou might think this will cause Vue to throw away the existing DOM and re-render the entire list - luckily, that is not the case. Vue implements some smart heuristics to maximize DOM element reuse, so replacing an array with another array containing overlapping objects is a very efficient operation.\n\nSometimes we want to display a filtered or sorted version of an array without actually mutating or resetting the original data. In this case, you can create a computed property that returns the filtered or sorted array.\n\nIn situations where computed properties are not feasible (e.g. inside nested loops), you can use a method:\n\nBe careful with and in a computed property! These two methods will mutate the original array, which should be avoided in computed getters. Create a copy of the original array before calling these methods:"
    },
    {
        "link": "https://stackoverflow.com/questions/73872293/how-can-i-use-vnode-or-binding-directive-to-call-a-component-method-in-vue-3",
        "document": "I created a directive, and I need to make that directive call a function that exists inside the component that has the directive.\n\nIn VUE 2 that was achievable by using vnode.context, but in VUE 3 it seems like I can only access methods from the parent component with binding.instance.\n\nSo, is there a way to use el, binding or vnode, after the component is mounte to call a method? So far just saw the props in vnode, no methods or reactive data."
    },
    {
        "link": "https://dev.to/jacobandrewsky/christmas-guide-to-custom-directives-in-vue-47hj",
        "document": "How to Use Provide/Inject in Vue\n\nTop 10 Vue.js libraries you should be using in 2025\n\nVue.js, one of the most popular JavaScript frameworks, offers developers powerful tools to build user interfaces efficiently. Among its many features, directives stand out as a means to directly manipulate the DOM.\n\nWhile Vue provides a suite of built-in directives like , , and , there are times when you need to implement functionality that isn’t covered by these defaults. This is where custom directives come into play. In Vue 3, the API for creating custom directives remains intuitive yet powerful.\n\nThis festive article explores what custom directives are, how to create them, and when to use them—all with a sprinkle of holiday cheer!\n\n🤔 What Are Directives in Vue?\n\nDirectives in Vue are special markers in the DOM that extend HTML’s capabilities. They allow you to bind dynamic behavior to elements declaratively. For example, the directive conditionally renders an element, and dynamically binds an attribute to an expression.\n\nCustom directives enable developers to encapsulate reusable DOM-manipulation logic, making your code more modular and maintainable.\n\nVue 3 custom directives provide several lifecycle hooks that correspond to different stages of a directive’s lifecycle:\n• created(el, binding, vnode, prevVnode): Called once when the directive is bound to the element.\n• beforeMount(el, binding, vnode, prevVnode): Called before the element is inserted into the DOM.\n• mounted(el, binding, vnode, prevVnode): Called when the element is inserted into the DOM.\n• beforeUpdate(el, binding, vnode, prevVnode): Called before the element’s containing component is updated.\n• updated(el, binding, vnode, prevVnode): Called after the element’s containing component and children are updated.\n• beforeUnmount(el, binding, vnode, prevVnode): Called before the directive’s element is unmounted.\n• unmounted(el, binding, vnode, prevVnode): Called after the directive’s element is unmounted.\n\nEach hook provides access to the directive’s object, which contains useful properties like:\n• value: The current value of the directive.\n• arg: An argument passed to the directive (e.g., ).\n\nIn Vue 3, you can register custom directives either globally or locally.\n\nTo register a directive globally, use the method:\n\n\n\nIn this example, the directive focuses the input element whenever it is mounted to the DOM.\n\nFor local registration, you define the directive within the option of a component:\n\n\n\nCustom directives shine in scenarios that require direct DOM manipulation, especially when such logic doesn’t belong in components or composables. Let's take a look at the following example of a directive to add a snowflake effect on hover:\n\n\n\nThis directive sprinkles your elements with snowflakes, adding a touch of Christmas magic to your app.\n• Direct DOM Manipulation is Needed: For operations like focusing elements or integrating third-party libraries.\n• Reusability is Required: Encapsulate common DOM logic into a directive for consistency across components.\n• Avoiding Component Overhead: Use directives instead of components for simple DOM-related behavior, reducing boilerplate.\n\nHowever, for more complex or state-driven logic, consider using composables or Vue components instead, as they integrate more naturally into Vue’s reactive system.\n\nIf you would like to learn more about Vue, Nuxt, JavaScript or other useful technologies, checkout VueSchool by clicking this link or by clicking the image below:\n\nIt covers most important concepts while building modern Vue or Nuxt applications that can help you in your daily work or side projects 😉\n\nWell done! Vue 3’s custom directives provide a concise way to encapsulate and reuse DOM manipulation logic. They complement Vue’s declarative programming paradigm, enabling developers to handle edge cases and extend functionality effortlessly. By understanding how and when to use them, you can enhance your applications with clean and maintainable code.\n\nTake care and see you next time! And Merry Christmas! 🎄\n\nAnd happy coding as always 🖥️"
    },
    {
        "link": "https://github.com/eligrey/FileSaver.js",
        "document": "If you need to save really large files bigger than the blob's size limitation or don't have enough RAM, then have a look at the more advanced StreamSaver.js that can save data directly to the hard drive asynchronously with the power of the new streams API. That will have support for progress, cancelation and knowing when it's done writing\n\nFileSaver.js is the solution to saving files on the client-side, and is perfect for web apps that generates files on the client, However if the file is coming from the server we recommend you to first try to use Content-Disposition attachment response header as it has more cross-browser compatiblity.\n\nLooking for for saving canvases? Check out canvas-toBlob.js for a cross-browser implementation.\n\nIt is possible to save text files in IE < 10 without Flash-based polyfills. See ChenWenBrian and koffsyrup's for more details.\n\nBlobs may be opened instead of saved sometimes—you may have to direct your Safari users to manually press + to save the file after it is opened. Using the MIME type to force downloads can cause issues in Safari.\n\nsaveAs must be run within a user interaction event such as onTouchDown or onClick; setTimeout will prevent saveAs from triggering. Due to restrictions in iOS saveAs opens in a new window instead of downloading, if you want this fixed please tell Apple how this WebKit bug is affecting you.\n\nPass if you want FileSaver.js to automatically provide Unicode text encoding hints (see: byte order mark). Note that this is only done if your blob type has set.\n\nUsing URLs within the same origin will just use . Otherwise, it will first check if it supports cors header with a synchronous head request. If it does, it will download the data and save using blob URLs. If not, it will try to download it using .\n\nThe standard W3C File API interface is not available in all browsers. Blob.js is a cross-browser implementation that solves this.\n\nNote: The standard HTML5 method is not available in all browsers. canvas-toBlob.js is a cross-browser that polyfills this.\n\nYou can save a File constructor without specifying a filename. If the file itself already contains a name, there is a hand full of ways to get a file instance (from storage, file input, new constructor, clipboard event). If you still want to change the name, then you can change it in the 2nd argument.\n\nAdditionally, TypeScript definitions can be installed via:"
    },
    {
        "link": "https://npmjs.com/package/file-saver",
        "document": "If you need to save really large files bigger than the blob's size limitation or don't have enough RAM, then have a look at the more advanced StreamSaver.js that can save data directly to the hard drive asynchronously with the power of the new streams API. That will have support for progress, cancelation and knowing when it's done writing\n\nFileSaver.js is the solution to saving files on the client-side, and is perfect for web apps that generates files on the client, However if the file is coming from the server we recommend you to first try to use Content-Disposition attachment response header as it has more cross-browser compatiblity.\n\nLooking for for saving canvases? Check out canvas-toBlob.js for a cross-browser implementation.\n\nIt is possible to save text files in IE < 10 without Flash-based polyfills. See ChenWenBrian and koffsyrup's for more details.\n\nBlobs may be opened instead of saved sometimes—you may have to direct your Safari users to manually press ⌘+S to save the file after it is opened. Using the MIME type to force downloads can cause issues in Safari.\n\nsaveAs must be run within a user interaction event such as onTouchDown or onClick; setTimeout will prevent saveAs from triggering. Due to restrictions in iOS saveAs opens in a new window instead of downloading, if you want this fixed please tell Apple how this WebKit bug is affecting you.\n\nPass if you want FileSaver.js to automatically provide Unicode text encoding hints (see: byte order mark). Note that this is only done if your blob type has set.\n\nUsing URLs within the same origin will just use . Otherwise, it will first check if it supports cors header with a synchronous head request. If it does, it will download the data and save using blob URLs. If not, it will try to download it using .\n\nThe standard W3C File API interface is not available in all browsers. Blob.js is a cross-browser implementation that solves this.\n\nNote: The standard HTML5 method is not available in all browsers. canvas-toBlob.js is a cross-browser that polyfills this.\n\nYou can save a File constructor without specifying a filename. If the file itself already contains a name, there is a hand full of ways to get a file instance (from storage, file input, new constructor, clipboard event). If you still want to change the name, then you can change it in the 2nd argument.\n\nAdditionally, TypeScript definitions can be installed via:"
    },
    {
        "link": "https://github.com/eligrey/FileSaver.js/blob/master/README.md",
        "document": "If you need to save really large files bigger than the blob's size limitation or don't have enough RAM, then have a look at the more advanced StreamSaver.js that can save data directly to the hard drive asynchronously with the power of the new streams API. That will have support for progress, cancelation and knowing when it's done writing\n\nFileSaver.js is the solution to saving files on the client-side, and is perfect for web apps that generates files on the client, However if the file is coming from the server we recommend you to first try to use Content-Disposition attachment response header as it has more cross-browser compatiblity.\n\nLooking for for saving canvases? Check out canvas-toBlob.js for a cross-browser implementation.\n\nIt is possible to save text files in IE < 10 without Flash-based polyfills. See ChenWenBrian and koffsyrup's for more details.\n\nBlobs may be opened instead of saved sometimes—you may have to direct your Safari users to manually press + to save the file after it is opened. Using the MIME type to force downloads can cause issues in Safari.\n\nsaveAs must be run within a user interaction event such as onTouchDown or onClick; setTimeout will prevent saveAs from triggering. Due to restrictions in iOS saveAs opens in a new window instead of downloading, if you want this fixed please tell Apple how this WebKit bug is affecting you.\n\nPass if you want FileSaver.js to automatically provide Unicode text encoding hints (see: byte order mark). Note that this is only done if your blob type has set.\n\nUsing URLs within the same origin will just use . Otherwise, it will first check if it supports cors header with a synchronous head request. If it does, it will download the data and save using blob URLs. If not, it will try to download it using .\n\nThe standard W3C File API interface is not available in all browsers. Blob.js is a cross-browser implementation that solves this.\n\nNote: The standard HTML5 method is not available in all browsers. canvas-toBlob.js is a cross-browser that polyfills this.\n\nYou can save a File constructor without specifying a filename. If the file itself already contains a name, there is a hand full of ways to get a file instance (from storage, file input, new constructor, clipboard event). If you still want to change the name, then you can change it in the 2nd argument.\n\nAdditionally, TypeScript definitions can be installed via:"
    },
    {
        "link": "https://stackoverflow.com/questions/50126062/how-to-use-filesaver-js-to-save-text-files",
        "document": "I downloaded the FilSaver.js on github and tried to test it for future purposes.I made a simple html file that accepts an input and when a button is clicked a function is triggered and that function will save the file using the FileSaver.js.\n\nInsinde the folder ofI only have the FileSaver.js and the HTML file.\n\nhere is my code.\n\n-Uncaught SyntaxError: Unexpected token export on this line of code inside the FileSaver.js var saveAs = saveAs || (function(view) { -lol.html:15 Uncaught ReferenceError: saveAs is not defined on this line of code inside the html file saveAs(blob, \"hello world.txt\");}"
    },
    {
        "link": "https://bestofjs.org/projects/filesaverjs",
        "document": "If you need to save really large files bigger than the blob's size limitation or don't have enough RAM, then have a look at the more advanced StreamSaver.js that can save data directly to the hard drive asynchronously with the power of the new streams API. That will have support for progress, cancelation and knowing when it's done writing\n\nFileSaver.js is the solution to saving files on the client-side, and is perfect for web apps that generates files on the client, However if the file is coming from the server we recommend you to first try to use Content-Disposition attachment response header as it has more cross-browser compatiblity.\n\nLooking for for saving canvases? Check out canvas-toBlob.js for a cross-browser implementation.\n\nIt is possible to save text files in IE < 10 without Flash-based polyfills. See ChenWenBrian and koffsyrup's for more details.\n\nBlobs may be opened instead of saved sometimes—you may have to direct your Safari users to manually press + to save the file after it is opened. Using the MIME type to force downloads can cause issues in Safari.\n\nsaveAs must be run within a user interaction event such as onTouchDown or onClick; setTimeout will prevent saveAs from triggering. Due to restrictions in iOS saveAs opens in a new window instead of downloading, if you want this fixed please tell Apple how this WebKit bug is affecting you.\n\nPass if you want FileSaver.js to automatically provide Unicode text encoding hints (see: byte order mark). Note that this is only done if your blob type has set.\n\nUsing URLs within the same origin will just use . Otherwise, it will first check if it supports cors header with a synchronous head request. If it does, it will download the data and save using blob URLs. If not, it will try to download it using .\n\nThe standard W3C File API interface is not available in all browsers. Blob.js is a cross-browser implementation that solves this.\n\nNote: The standard HTML5 method is not available in all browsers. canvas-toBlob.js is a cross-browser that polyfills this.\n\nYou can save a File constructor without specifying a filename. If the file itself already contains a name, there is a hand full of ways to get a file instance (from storage, file input, new constructor, clipboard event). If you still want to change the name, then you can change it in the 2nd argument.\n\nAdditionally, TypeScript definitions can be installed via:"
    },
    {
        "link": "https://docs.sheetjs.com/docs/getting-started/examples/export",
        "document": "Many modern data sources provide an API to download data in JSON format. Many users prefer to work in spreadsheet software. SheetJS libraries help bridge the gap by translating programmer-friendly JSON to user-friendly workbooks.\n\nThe goal of this example is to generate a XLSX workbook of US President names and birthdates. We will download and wrangle a JSON dataset using standard JavaScript functions. Once we have a simple list of names and birthdates, we will use SheetJS API functions to build a workbook object and export to XLSX.\n\nThe \"Live Demo\" section includes a working demo in this page! \"Run the Demo Locally\" shows how to run the workflow in iOS / Android apps, desktop apps, NodeJS scripts and other environments.\n\nThe following sequence diagram shows the process:\n\nThe raw data is available in JSON form1. It has been mirrored at https://docs.sheetjs.com/executive.json\n\nAcquiring the data is straightforward with :\n\nis a low-level API for downloading data from an endpoint. It separates the network step from the response parsing step. returns a representing the network request. The browser will attempt to download data from the URL. If the network request succeeded, the will \"return\" with a object. Using modern syntax, inside an function, code should the fetch: If the file is not available, the will still succeed. The status code, stored in the property of the object, is a standard HTTP status code number. Code should check the result. Typically servers will return status \"File not Found\" if the file is not available. A successful request should have status \"OK\". will try to parse the data using . Like , the method returns a that must be -ed: The object has other useful methods. will return the raw data as an , suitable for parsing workbook files. Functions can test each part independently and report different errors:\n\nThe raw data is an Array of objects2. For this discussion, the relevant data for John Adams is shown below:\n\nThe dataset includes Aaron Burr, a Vice President who was never President!\n\nThe field of each object is an array of terms. A term is a Presidential term if the property is . We are interested in Presidents that served at least one term. The following line creates an array of Presidents:\n\nThe dataset is sorted in chronological order by the first presidential or vice presidential term. The Vice President and President in a given term are sorted alphabetically.\n\nBarack Obama became President and Joseph Biden became Vice President in 2009. Since \"Biden\" is alphabetically before \"Obama\", Biden's data appears first.\n\nThe goal is to sort the presidents in order of their initial presidential term.\n\nThe first step is adding the first presidential term start date to the dataset. The following code looks at each president and creates a property that represents the start of the first presidential term.\n\nAt this point, each row in the array has a property. Since the properties are strings, the following line sorts the array:\n\nFor this example, the name will be the first name combined with the last name ( ) and the birthday will be available at . Using , the dataset can be massaged in one call:\n\nThe result is an array of \"simple\" objects with no nesting:\n\n4 creates a new workbook and 5 appends a worksheet to the workbook. The new worksheet will be called \"Dates\":\n\nThe data is in the workbook and can be exported.\n\nThere are multiple opportunities for improvement: the headers can be renamed and the column widths can be adjusted.\n\nAfter cleanup, the generated workbook looks like the screenshot below:\n\n8 creates a spreadsheet file and tries to write it to the system. In the browser, it will try to prompt the user to download the file. In NodeJS, it will write to the local directory.\n\nThis demo runs in the web browser! Click \"Click to Generate File!\" and the browser should try to create\n\nhttps://sheetjs.com/pres.html is a hosted version of this demo.\n\nSave the following script to : After saving the file, run a local web server in the folder with the HTML file. For example, if NodeJS is installed: The server process will display a URL (typically ). Open in your browser. Save the following script to : After saving the script, run the script: This script will write a new file in the same folder. Native support was added in NodeJS 18. For older versions of NodeJS, the script will throw an error . A third-party library like presents a similar API for fetching data: Example using axios (click to show) Save the following script to (differences are highlighted): After saving the script, run the script: This script will write a new file in the same folder. Save the following script to : After saving the script, run the script: This script will write a new file in the same folder. Save the following script to : Save the following to : The app will show a save dialog. After selecting a path, it will write the file. Follow the Environment Setup of the React Native documentation before testing the demo. There are a number of potential pitfalls. The React Native demo lists some issues encountered in previous test runs and potential resolutions. Please reach out to the SheetJS chat if there are any issues not mentioned in the demo page. Create a new project by running the following commands in the Terminal: Save the following to in the project: The Android demo has been tested in Windows, Arch Linux (Steam Deck) and macOS. Test the app in the Android simulator: Once Metro is ready, it will display the commands: Press to run on Android. The app will launch in the emulator. After clicking \"Press to Export\", the app will show an alert with the location to the generated file ( ) In the Android simulator, pulling the file requires additional steps: This command generates which can be opened. \"Running on Device\" in the React Native docs covers device configuration. To summarize:\n• Connect the Android device to the computer with a USB cable. will be copied to the folder. The file is visible in the Files app and can be opened with the Google Sheets app. This demo worked on multiple local Android devices in local tests. It is not guaranteed to run on every Android device or Android version. The React Native demo lists some issues encountered in previous test runs and potential resolutions. Please reach out to the SheetJS chat if there are any issues not mentioned in the demo page. This demo runs in iOS and requires a Macintosh computer with Xcode installed. The native component must be linked: Test the app in the iOS simulator: After clicking \"Press to Export\", the app will show an alert with the location to the generated file. \"Running on Device\" in the React Native docs covers device configuration. The and entitlements are required for iOS to show the generated files in the \"Files\" app. The highlighted lines should be added to the iOS project just before the last tag: After adding the settings and rebuilding the app, the file will be visible in the \"Files\" app. Under \"On My iPhone\", there will be a folder . Within the folder there will be a file named . Touch the file to see a preview of the data. The Numbers app can open the file."
    },
    {
        "link": "https://npmjs.com/package/xlsx",
        "document": "The SheetJS Community Edition offers battle-tested open-source solutions for extracting useful data from almost any complex spreadsheet and generating new spreadsheets that will work with legacy and modern software alike.\n\nSheetJS Pro offers solutions beyond data processing: Edit complex templates with ease; let out your inner Picasso with styling; make custom sheets with images/graphs/PivotTables; evaluate formula expressions and port calculations to web apps; automate common spreadsheet tasks, and much more!\n\nThe complete browser standalone build is saved to and can be directly added to a page with a tag:\n\nThe ECMAScript Module build is saved to and can be directly added to a page with a tag using :\n\nThe npm package also exposes the module with the parameter, supported in Angular and other projects:\n\ncan be imported in Deno. It is available from :\n\nThe module also ships with for use with :\n\nis an ExtendScript build for Photoshop and InDesign that is included in the package. It can be directly referenced with a directive:\n\nMost scenarios involving spreadsheets and data can be broken into 5 parts:\n• Acquire Data: Data may be stored anywhere: local or remote files, databases, HTML TABLE, or even generated programmatically in the web browser.\n• Extract Data: For spreadsheet files, this involves parsing raw bytes to read the cell data. For general JS data, this involves reshaping the data.\n• Process Data: From generating summary statistics to cleaning data records, this step is the heart of the problem.\n• Package Data: This can involve making a new spreadsheet or serializing with or writing XML or simply flattening data for UI tools.\n• Release Data: Spreadsheet files can be uploaded to a server or written locally. Data can be presented to users in an HTML TABLE or data grid.\n\nA common problem involves generating a valid spreadsheet export from data stored in an HTML table. In this example, an HTML TABLE on the page will be scraped, a row will be added to the bottom with the date of the report, and a new file will be generated and downloaded locally. takes care of packaging the data and attempting a local download:\n\nThis library tries to simplify steps 2 and 4 with functions to extract useful data from spreadsheet files ( / ) and generate new spreadsheet files from data ( / ). Additional utility functions like work with other common data sources like HTML tables.\n\nThis documentation and various demo projects cover a number of common scenarios and approaches for steps 1 and 5.\n\n\"Utility Functions\" details utility functions for translating JSON Arrays and other common JS structures into worksheet objects.\n\nData processing should fit in any workflow\n\nThe library does not impose a separate lifecycle. It fits nicely in websites and apps built using any framework. The plain JS data objects play nice with Web Workers and future APIs.\n\nThe \"Common Spreadsheet Format\" is a simple object representation of the core concepts of a workbook. The various functions in the library provide low-level tools for working with the object.\n\nFor friendly JS processing, there are utility functions for converting parts of a worksheet to/from an Array of Arrays. The following example combines powerful JS Array methods with a network request library to download data, select the information we want and create a workbook file:\n\nThe parser covers a wide gamut of common spreadsheet file formats to ensure that \"HTML-saved-as-XLS\" files work as well as actual XLS or XLSX files.\n\nThe writer supports a number of common output formats for broad compatibility with the data ecosystem.\n\nTo the greatest extent possible, data processing code should not have to worry about the specific file formats involved.\n\nOther examples are included in the showcase.\n\nhttps://sheetjs.com/demos/modify.html shows a complete example of reading, modifying, and writing files.\n\nhttps://github.com/SheetJS/sheetjs/blob/HEAD/bin/xlsx.njs is the command-line tool included with node installations, reading spreadsheet files and exporting the contents in various formats.\n\nThe method can extract data from spreadsheet bytes stored in a JS string, \"binary string\", NodeJS buffer or typed array ( or ).\n\nThe method attempts to read a spreadsheet file at the supplied path. Browsers generally do not allow reading files in this way (it is deemed a security risk), and attempts to read files in this way will throw an error.\n\nThe second argument is optional. \"Parsing Options\" covers the supported properties and behaviors.\n\nHere are a few common scenarios (click on each subtitle to see the code):\n\nMore detailed examples are covered in the included demos\n\nJSON and JS data tend to represent single worksheets. This section will use a few utility functions to generate workbooks.\n\nThe utility function creates an empty workbook with no worksheets.\n\nSpreadsheet software generally require at least one worksheet and enforce the requirement in the user interface. This library enforces the requirement at write time, throwing errors if an empty workbook is passed to write functions.\n\nCreate a worksheet from an array of arrays of JS values\n\nThe utility function walks an \"array of arrays\" in row-major order, generating a worksheet object. The following snippet generates a sheet with cell set to the string , cell set to , etc:\n\n\"Array of Arrays Input\" describes the function and the optional argument in more detail.\n\nCreate a worksheet from an array of JS objects\n\nThe utility function walks an array of JS objects in order, generating a worksheet object. By default, it will generate a header row and one row per object in the array. The optional argument has settings to control the column order and header output.\n\n\"Array of Objects Input\" describes the function and the optional argument in more detail.\n\n\"Zen of SheetJS\" contains a detailed example \"Get Data from a JSON Endpoint and Generate a Workbook\"\n\nis an interactive data grid for previewing and modifying structured data in the web browser. The demo includes a sample script with the function for converting from x-spreadsheet data object to a workbook. https://oss.sheetjs.com/sheetjs/x-spreadsheet is a live demo.\n\nCreate a worksheet by scraping an HTML TABLE in the page\n\nThe utility function takes a DOM TABLE element and iterates through the rows to generate a worksheet. The argument is optional. \"HTML Table Input\" describes the function in more detail.\n\nCreate a workbook by scraping an HTML TABLE in the page\n\nThe utility function follows the same logic as . After generating a worksheet, it creates a blank workbook and appends the spreadsheet.\n\nThe options argument supports the same options as , with the addition of a property to control the worksheet name. If the property is missing or no options are specified, the default name is used.\n\nHere are a few common scenarios (click on each subtitle to see the code):\n\nThe \"Common Spreadsheet Format\" is a simple object representation of the core concepts of a workbook. The utility functions work with the object representation and are intended to handle common use cases.\n\nThe utility function appends a worksheet to the workbook. The third argument specifies the desired worksheet name. Multiple worksheets can be added to a workbook by calling the function multiple times. If the worksheet name is already used in the workbook, it will throw an error.\n\nAppend a Worksheet to a Workbook and find a unique name\n\nIf the fourth argument is , the function will start with the specified worksheet name. If the sheet name exists in the workbook, a new worksheet name will be chosen by finding the name stem and incrementing the counter:\n\nThe property of the workbook object is a list of the worksheet names in \"tab order\". API functions will look at this array.\n\nThe property of the workbook object is an object whose keys are names and whose values are worksheet objects. By reassigning to a property of the object, the worksheet object can be changed without disrupting the rest of the worksheet structure.\n\nThe utility function modifies cell values in a worksheet. The first argument is the worksheet object. The second argument is an array of arrays of values. The key of the third argument controls where cells will be written. The following snippet sets and :\n\n\"Array of Arrays Input\" describes the function and the optional argument in more detail.\n\nThe \"Common Spreadsheet Format\" section describes the object structures in greater detail.\n\nThe method attempts to package data from the workbook into a file in memory. By default, XLSX files are generated, but that can be controlled with the property of the argument. Based on the option, the data can be stored as a \"binary string\", JS string, or Buffer.\n\nThe second argument is required. \"Writing Options\" covers the supported properties and behaviors.\n\nThe method packages the data and attempts to save the new file. The export file format is determined by the extension of ( signals XLSX export, signals XLSB export, etc).\n\nThe method uses platform-specific APIs to initiate the file save. In NodeJS, can create a file. In the web browser, a download is attempted using the HTML5 attribute, with fallbacks for IE.\n\nGenerate and attempt to save an XLSX file\n\nThe method embeds a number of different export functions. This is great for developer experience but not amenable to tree shaking using the current developer tools. When only XLSX exports are needed, this method avoids referencing the other export functions.\n\nThe second argument is optional. \"Writing Options\" covers the supported properties and behaviors.\n\nThe included demos cover mobile apps and other special deployments.\n\nThe streaming write functions are available in the object. They take the same arguments as the normal write functions but return a NodeJS Readable Stream.\n• is the streaming version of .\n• is the streaming version of .\n• is the streaming version of .\n\nJSON and JS data tend to represent single worksheets. The utility functions in this section work with single worksheets.\n\nThe \"Common Spreadsheet Format\" section describes the object structure in more detail. is an ordered list of the worksheet names. is an object whose keys are sheet names and whose values are worksheet objects.\n\nThe \"first worksheet\" is stored at .\n\nCreate an array of JS objects from a worksheet\n\nCreate an array of arrays of JS values from a worksheet\n\nThe utility function walks a workbook in row-major order, generating an array of objects. The second argument controls a number of export decisions including the type of values (JS values or formatted text). The \"JSON\" section describes the argument in more detail.\n\nBy default, scans the first row and uses the values as headers. With the option, the function exports an array of arrays of values.\n\nis an interactive data grid for previewing and modifying structured data in the web browser. The demo includes a sample script with the function for converting from a workbook to x-spreadsheet data object. https://oss.sheetjs.com/sheetjs/x-spreadsheet is a live demo.\n\nThe utility function generates HTML code based on the worksheet data. Each cell in the worksheet is mapped to a element. Merged cells in the worksheet are serialized by setting and attributes.\n\nThe utility function generates HTML code that can be added to any DOM element by setting the :\n\nCombining with , constructing a site from a workbook is straightforward:\n\nThis snapshot is designed to replicate the \"CSV UTF8 ( )\" output type. \"Delimiter-Separated Output\" describes the function and the optional argument in more detail.\n\nThis snapshot is designed to replicate the \"UTF16 Text ( )\" output type. \"Delimiter-Separated Output\" describes the function and the optional argument in more detail.\n\nThis snapshot generates an array of entries representing the embedded formulae. Array formulae are rendered in the form while plain cells are rendered in the form . String literals are prefixed with an apostrophe , consistent with Excel's formula bar display.\n\n\"Formulae Output\" describes the function in more detail.\n\nis the exposed variable in the browser and the exported node variable\n\nis the version of the library (added by the build script).\n\nis an embedded version of the format library.\n\nParse options are described in the Parsing Options section.\n\nattempts to write to . In browser-based environments, it will attempt to force a client-side download.\n\nattempts to write to . If is omitted, the writer will use the third argument as the callback.\n\nWrite options are described in the Writing Options section.\n\nUtilities are available in the object and are described in the Utility Functions section:\n• converts an array of arrays of JS data to a worksheet.\n• converts an array of JS objects to a worksheet.\n• adds an array of arrays of JS data to an existing worksheet.\n• adds an array of JS objects to an existing worksheet.\n• converts a worksheet object to an array of JSON objects.\n• generates a list of the formulae (with value fallbacks).\n• generates the text value for a cell (using number formats).\n\nCell address objects are stored as where and are 0-indexed column and row numbers, respectively. For example, the cell address is represented by the object .\n\nCell range objects are stored as where is the first cell and is the last cell in the range. The ranges are inclusive. For example, the range is represented by the object . Utility functions perform a row-major order walk traversal of a sheet range:\n\nCell objects are plain JS objects with keys and values following the convention:\n\nBuilt-in export utilities (such as the CSV exporter) will use the text if it is available. To change a value, be sure to delete (or set it to ) before attempting to export. The utilities will regenerate the text from the number format ( ) and the raw value if possible.\n\nThe actual array formula is stored in the field of the first cell in the array range. Other cells in the range will omit the field.\n\nThe raw value is stored in the value property, interpreted based on the type property. This separation allows for representation of numbers as well as numeric text. There are 6 valid cell types:\n\nType is the Number type. This includes all forms of data that Excel stores as numbers, such as dates/times and Boolean fields. Excel exclusively uses data that can be fit in an IEEE754 floating point number, just like JS Number, so the field holds the raw number. The field holds formatted text. Dates are stored as numbers by default and converted with .\n\nType is the Date type, generated only when the option is passed. Since JSON does not have a natural Date type, parsers are generally expected to store ISO 8601 Date strings like you would get from . On the other hand, writers and exporters should be able to handle date strings and JS Date objects. Note that Excel disregards timezone modifiers and treats all dates in the local timezone. The library does not correct for this error.\n\nType is the String type. Values are explicitly stored as text. Excel will interpret these cells as \"number stored as text\". Generated Excel files automatically suppress that class of error, but other formats may elicit errors.\n\nType represents blank stub cells. They are generated in cases where cells have no assigned value but hold comments or other metadata. They are ignored by the core library data processing utility functions. By default these cells are not generated; the parser option must be set to .\n\nEach key that does not start with maps to a cell (using notation)\n\nreturns the cell object for the specified address.\n\nSpecial sheet keys (accessible as , each starting with ):\n• : A-1 based range representing the sheet range. Functions that work with sheets should use this parameter to determine the range. Cells that are assigned outside of the range are not processed. In particular, when writing a sheet by hand, cells outside of the range are not included Functions that handle sheets should test for the presence of field. If the is omitted or is not a valid range, functions are free to treat the sheet as empty or attempt to guess the range. The standard utilities that ship with this library treat sheets as empty (for example, the CSV output is empty string). When reading a worksheet with the property set, the ref parameter will use the restricted range. The original range is set at\n• : Object representing the page margins. The default values follow Excel's \"normal\" preset. Excel also has a \"wide\" and a \"narrow\" preset but they are stored as raw measurements. The main properties are listed below:\n\nIn addition to the base sheet keys, worksheets also add:\n• : array of column properties objects. Column widths are actually stored in files in a normalized manner, measured in terms of the \"Maximum Digit Width\" (the largest width of the rendered digits 0-9, in pixels). When parsed, the column objects store the pixel width in the field, character width in the field, and the maximum digit width in the field.\n• : array of row properties objects as explained later in the docs. Each row object encodes properties including row height and visibility.\n• : array of range objects corresponding to the merged cells in the worksheet. Plain text formats do not support merge cells. CSV export will write all cells in the merge range if they exist, so be sure that only the first cell (upper-left) in the range is set.\n• : configure how outlines should behave. Options default to the default settings in Excel 2019:\n• : object of write sheet protection properties. The key specifies the password for formats that support password-protected sheets (XLSX/XLSB/XLS). The writer uses the XOR obfuscation method. The following keys control the sheet protection -- set to to enable a feature when sheet is locked or set to to disable a feature:\n\nChartsheets are represented as standard sheets. They are distinguished with the property set to .\n\nThe underlying data and refer to the cached data in the chartsheet. The first row of the chartsheet is the underlying header.\n\nMacrosheets are represented as standard sheets. They are distinguished with the property set to .\n\nDialogsheets are represented as standard sheets. They are distinguished with the property set to .\n\nis an ordered list of the sheets in the workbook\n\nis an object storing the standard properties. stores custom properties. Since the XLS standard properties deviate from the XLSX standard, XLS parsing stores core properties in both places.\n\nThe various file formats use different internal names for file properties. The workbook object normalizes the names:\n\nFor example, to set the workbook title property:\n\nCustom properties are added in the workbook object:\n\nWriters will process the key of the options object:\n\nis an array of defined name objects which have the keys:\n\nExcel allows two sheet-scoped defined names to share the same name. However, a sheet-scoped name cannot collide with a workbook-scope name. Workbook writers may not enforce this constraint.\n\nis an array of workbook view objects which have the keys:\n\nEven for basic features like date storage, the official Excel formats store the same content in different ways. The parsers are expected to convert from the underlying file format representation to the Common Spreadsheet Format. Writers are expected to convert from CSF back to the underlying file format.\n\nThe A1-style formula string is stored in the field. Even though different file formats store the formulae in different ways, the formats are translated. Even though some formats store formulae with a leading equal sign, CSF formulae do not start with .\n\nFor simple formulae, the key of the desired cell can be set to the actual formula text. This worksheet represents , , and :\n\nUtilities like will accept cell objects in lieu of values:\n\nCells with formula entries but no value will be serialized in a way that Excel and other spreadsheet tools will recognize. This library will not automatically compute formula results! For example, the following worksheet will include the function but the result will not be available in JavaScript:\n\nIf the actual results are needed in JS, SheetJS Pro offers a formula calculator component for evaluating expressions, updating values and dependent cells, and refreshing entire workbooks.\n\nArray formulae are stored in the top-left cell of the array block. All cells of an array formula have a field corresponding to the range. A single-cell formula can be distinguished from a plain formula by the presence of field.\n\nFor example, setting the cell to the array formula :\n\nFor a multi-cell array formula, every cell has the same array range but only the first cell specifies the formula. Consider :\n\nUtilities and writers are expected to check for the presence of a field and ignore any possible formula element in cells other than the starting cell. They are not expected to perform validation of the formulae!\n\nReleased in 2020, Dynamic Array Formulae are supported in the XLSX/XLSM and XLSB file formats. They are represented like normal array formulae but have special cell metadata indicating that the formula should be allowed to adjust the range.\n\nAn array formula can be marked as dynamic by setting the cell's property to true. The range is expected but can be the set to the current cell:\n\nSheetJS operates at the file level. Excel stores formula expressions using the English (United States) function names. For non-English users, Excel uses a localized set of function names.\n\nFor example, when the computer language and region is set to French (France), Excel interprets as if is the function. However, in the actual file, Excel stores .\n\nFunctions introduced in newer versions of Excel are prefixed with when stored in files. When writing formula expressions using these functions, the prefix is required for maximal compatibility:\n\nWhen reading a file, the option preserves the prefixes.\n\nRow and Column properties are not extracted by default when reading from a file and are not persisted by default when writing to a file. The option must be passed to the relevant read or write function.\n\nThe array in each worksheet, if present, is a collection of objects which have the following properties:\n\nThe array in each worksheet, if present, is a collection of objects which have the following properties:\n\nThe Excel UI displays the base outline level as and the max level as . Following JS conventions, SheetJS uses 0-indexed outline levels wherein the base outline level is and the max level is .\n\nThe formatted text for each cell is produced from and format. If the format is not specified, the Excel format is used. The format can either be specified as a string or as an index into the format table. Parsers are expected to populate with the number format table. Writers are expected to serialize the table.\n\nCustom tools should ensure that the local table has each used format string somewhere in the table. Excel convention mandates that the custom formats start at index 164. The following example creates a custom format from scratch:\n\nThe rules are slightly different from how Excel displays custom number formats. In particular, literal characters must be wrapped in double quotes or preceded by a backslash. For more info, see the Excel documentation article or ECMA-376 18.8.31 (Number Formats)\n\nFormat 14 ( ) is localized by Excel: even though the file specifies that number format, it will be drawn differently based on system settings. It makes sense when the producer and consumer of files are in the same locale, but that is not always the case over the Internet. To get around this ambiguity, parse functions accept the option to override the interpretation of that specific format string.\n\nHyperlinks are stored in the key of cell objects. The field of the hyperlink object is the target of the link, including the URI fragment. Tooltips are stored in the field and are displayed when you move your mouse over the text.\n\nFor example, the following snippet creates a link from cell to https://sheetjs.com with the tip :\n\nNote that Excel does not automatically style hyperlinks -- they will generally be displayed as normal text.\n\nHTTP / HTTPS links can be used directly:\n\nLinks to absolute paths should use the URI scheme:\n\nLinks to relative paths can be specified without a scheme:\n\nRelative Paths have undefined behavior in the SpreadsheetML 2003 format. Excel 2019 will treat a parent mark as two levels up.\n\nLinks where the target is a cell or range or defined name in the same workbook (\"Internal Links\") are marked with a leading hash character:\n\nCell comments are objects stored in the array of cell objects. The actual contents of the comment are split into blocks based on the comment author. The field of each comment object is the author of the comment and the field is the plain text representation.\n\nFor example, the following snippet appends a cell comment into cell :\n\nNote: XLSB enforces a 54 character limit on the Author name. Names longer than 54 characters may cause issues with other formats.\n\nTo mark a comment as normally hidden, set the property:\n\nIntroduced in Excel 365, threaded comments are plain text comment snippets with author metadata and parent references. They are supported in XLSX and XLSB.\n\nTo mark a comment as threaded, each comment part must have a true property:\n\nThere is no Active Directory or Office 365 metadata associated with authors in a thread.\n\nExcel enables hiding sheets in the lower tab bar. The sheet data is stored in the file but the UI does not readily make it available. Standard hidden sheets are revealed in the \"Unhide\" menu. Excel also has \"very hidden\" sheets which cannot be revealed in the menu. It is only accessible in the VB Editor!\n\nThe visibility setting is stored in the property of sheet props array.\n\nVBA Macros are stored in a special data blob that is exposed in the property of the workbook object when the option is . They are supported in , , and formats. The supported format writers automatically insert the data blobs if it is present in the workbook and associate with the worksheet names.\n\nThe exported and functions accept an options argument:\n• Even if is false, formatted text will be generated and saved to\n• In some cases, sheets may be parsed even if is false.\n• Excel aggressively tries to interpret values from CSV and other plain text. This leads to surprising behavior! The option suppresses value parsing.\n• and combine to give both sets of information\n• will be an empty object if is false\n• behavior depends on file type:\n• array (paths in the ZIP) for ZIP-based formats\n• hash (mapping paths to objects representing the files) for ZIP\n• rows will be generated when looking at the JSON object output (since the header row is counted as a row when parsing the data)\n• By default all worksheets are parsed. restricts based on input type:\n• number: zero-based index of worksheet to parse ( is first worksheet)\n• string: name of worksheet to parse (case insensitive)\n• array of numbers and strings to select multiple worksheets.\n• merely exposes the raw VBA CFB object. It does not parse the data. XLSM and XLSB store the VBA CFB object in . BIFF8 XLS mixes the VBA entries alongside the core Workbook entry, so the library generates a new XLSB-compatible blob from the XLS CFB container.\n• is applied to BIFF2 - BIFF5 files without records and to CSV files without BOM in . BIFF8 XLS always defaults to 1200.\n• Currently only XOR encryption is supported. Unsupported error will be thrown for files employing other encryption methods.\n• Newer Excel functions are serialized with the prefix, hidden from the user. SheetJS will strip normally. The option preserves them.\n• WTF is mainly for development. By default, the parser will suppress read errors on single worksheets, allowing you to read from the worksheets that do parse properly. Setting forces those errors to be thrown.\n\nStrings can be interpreted in multiple ways. The parameter for tells the library how to parse the data argument:\n\nThe exported and functions accept an options argument:\n• is slower and more memory intensive, but has better compatibility with older versions of iOS Numbers\n• The raw data is the only thing guaranteed to be saved. Features not described in this README may not be serialized.\n• only applies to XLSX output and is not guaranteed to work with third-party readers. Excel itself does not usually write cells with type so non-Excel tools may ignore the data or error in the presence of dates.\n• is an object mirroring the workbook field. See the table from the Workbook File Properties section.\n• if specified, the string from will be saved as the primary theme for XLSX/XLSB/XLSM files (to in the ZIP)\n• Due to a bug in the program, some features like \"Text to Columns\" will crash Excel on worksheets where error conditions are ignored. The writer will mark files to ignore the error by default. Set to to suppress.\n• Due to the size of the data, the NUMBERS data is not included by default. The included and scripts include the data.\n\nFor broad compatibility with third-party tools, this library supports many output formats. The specific file type is controlled with option:\n• only applies to formats with ZIP containers.\n• Formats that only support a single sheet require a option specifying the worksheet. If the string is empty, the first worksheet is used.\n• will automatically guess the output file format based on the file extension if is not specified. It will choose the first format in the aforementioned table that matches the extension.\n\nThe argument for mirrors the argument for :\n• For compatibility with Excel, output will always include the UTF-8 byte order mark.\n\nThe functions accept a worksheet and an optional options object.\n\nThe functions accept a data object and an optional options object.\n\nThe examples are based on the following worksheet:\n\ntakes an array of arrays of JS values and returns a worksheet resembling the input data. Numbers, Booleans and Strings are stored as the corresponding styles. Dates are stored as date or numbers. Array holes and explicit values are skipped. values may be stubbed. All other values are stored as strings. The function takes an options argument:\n\ntakes an array of arrays of JS values and updates an existing worksheet object. It follows the same process as and accepts an options argument:\n\nis expected to be one of:\n\ntakes an array of objects and returns a worksheet with automatically-generated \"headers\" based on the keys of the objects. The default column order is determined by the first appearance of the field using . The function accepts an options argument:\n• All fields from each row will be written. If is an array and it does not contain a particular field, the key will be appended to the array.\n• Cell types are deduced from the type of each value. For example, a object will generate a Date cell, while a string will generate a Text cell.\n• Null values will be skipped by default. If is true, an error cell corresponding to will be written to the worksheet.\n\ntakes an array of objects and updates an existing worksheet object. It follows the same process as and accepts an options argument:\n\nis expected to be one of:\n\ntakes a table DOM element and returns a worksheet resembling the input table. Numbers are parsed. All other data will be stored as strings.\n\ntakes a table DOM element and updates an existing worksheet object. It follows the same process as and accepts an options argument:\n\nis expected to be one of:\n\ngenerates an array of commands that represent how a person would enter data into an application. Each entry is of the form . String literals are prefixed with a in accordance with Excel.\n\nAs an alternative to the CSV type, also produces CSV output. The function takes an options argument:\n• will remove trailing commas from each line under default\n• must be set to to skip blank lines.\n• Fields containing the record or field separator will automatically be wrapped in double quotes; forces all cells to be wrapped in quotes.\n• with type will always prepend the UTF-8 byte-order mark for Excel compatibility. returns a JS string and omits the mark. Using with type will also skip the mark.\n\nThe output type uses the tab character as the field separator. If the library is available (included in full distribution but not core), the output will be encoded in and the BOM will be prepended.\n\ntakes the same arguments as .\n\nAs an alternative to the HTML type, also produces HTML output. The function takes an options argument:\n\ngenerates different types of JS objects. The function takes an options argument:\n• only affects cells which have a format code ( ) field or a formatted text ( ) field.\n• If is specified, the first row is considered a data row; if is not specified, the first row is the header row and not considered data.\n• When is not specified, the conversion will automatically disambiguate header entries by affixing and a count starting at . For example, if three columns have header the output fields are , ,\n• values are returned when is true but are skipped when false.\n• If is not specified, null and undefined values are skipped normally. If specified, all null and undefined points will be filled with\n• When is , the default is to generate blank rows. must be set to to skip blank rows.\n• When is not , the default is to skip blank rows. must be true to generate blank rows\n\nis expected to be one of:\n\nis expected to be one of:\n• If header is not , the row object will contain the non-enumerable property that represents the row of the sheet corresponding to the entry.\n• If header is an array, the keys will not be disambiguated. This can lead to unexpected results if the array values are not unique!\n\nDespite the library name , it supports numerous spreadsheet file formats:\n\nFeatures not supported by a given file format will not be written. Formats with range limits will be silently truncated:\n\nExcel 2003 SpreadsheetML range limits are governed by the version of Excel and are not enforced by the writer.\n\nXLSX and XLSM files are ZIP containers containing a series of XML files in accordance with the Open Packaging Conventions (OPC). The XLSM format, almost identical to XLSX, is used for files containing macros. The format is standardized in ECMA-376 and later in ISO/IEC 29500. Excel does not follow the specification, and there are additional documents discussing how Excel deviates from the specification. BIFF 2/3 XLS are single-sheet streams of binary records. Excel 4 introduced the concept of a workbook ( files) but also had single-sheet format. The structure is largely similar to the Lotus 1-2-3 file formats. BIFF5/8/12 extended the format in various ways but largely stuck to the same record format. There is no official specification for any of these formats. Excel 95 can write files in these formats, so record lengths and fields were determined by writing in all of the supported formats and comparing files. Excel 2016 can generate BIFF5 files, enabling a full suite of file tests starting from XLSX or BIFF2. BIFF8 exclusively uses the Compound File Binary container format, splitting some content into streams within the file. At its core, it still uses an extended version of the binary record format from older versions of BIFF. The specification covers the basics of the file format, and other specifications expand on serialization of features like properties. Predating XLSX, SpreadsheetML files are simple XML files. There is no official and comprehensive specification, although MS has released documentation on the format. Since Excel 2016 can generate SpreadsheetML files, mapping features is pretty straightforward. Introduced in parallel with XLSX, the XLSB format combines the BIFF architecture with the content separation and ZIP container of XLSX. For the most part nodes in an XLSX sub-file can be mapped to XLSB records in a corresponding sub-file. The specification covers the basics of the file format, and other specifications expand on serialization of features like properties. Excel CSV deviates from RFC4180 in a number of important ways. The generated CSV files should generally work in Excel although they may not work in RFC4180 compatible readers. The parser should generally understand Excel CSV. The writer proactively generates cells for formulae if values are unavailable. Excel TXT uses tab as the delimiter and code page 1200. Like in Excel, files starting with are treated as Symbolic Link files. Unlike Excel, if the file does not have a valid SYLK header, it will be proactively reinterpreted as CSV. There are some files with semicolon delimiter that align with a valid SYLK file. For the broadest compatibility, all cells with the value of are automatically wrapped in double-quotes. Support for other formats is generally far behind XLS/XLSB/XLSX support, due in part to a lack of publicly available documentation. Test files were produced in the respective apps and compared to their XLS exports to determine structure. The main focus is data extraction. The Lotus formats consist of binary records similar to the BIFF structure. Lotus did release a specification decades ago covering the original WK1 format. Other features were deduced by producing files and comparing to Excel support. Generated WK1 worksheets are compatible with Lotus 1-2-3 R2 and Excel 5.0. Generated WK3 workbooks are compatible with Lotus 1-2-3 R9 and Excel 5.0. The Quattro Pro formats use binary records in the same way as BIFF and Lotus. Some of the newer formats (namely WB3 and QPW) use a CFB enclosure just like BIFF8 XLS. All versions of Works were limited to a single worksheet. Works for DOS 1.x - 3.x and Works for Windows 2.x extends the Lotus WKS format with additional record types. Works for Windows 3.x - 5.x uses the same format and WKS extension. The BOF record has type Works for Windows 6.x - 9.x use the XLR format. XLR is nearly identical to BIFF8 XLS: it uses the CFB container with a Workbook stream. Works 9 saves the exact Workbook stream for the XLR and the 97-2003 XLS export. Works 6 XLS includes two empty worksheets but the main worksheet has an identical encoding. XLR also includes a stream similar to Lotus FM3/FMT files. iWork 2013 (Numbers 3.0 / Pages 5.0 / Keynote 6.0) switched from a proprietary XML-based format to the current file format based on the iWork Archive (IWA). This format has been used up through the current release (Numbers 11.2). The parser focuses on extracting raw data from tables. Numbers technically supports multiple tables in a logical worksheet, including custom titles. This parser will generate one worksheet per Numbers table. The writer currently exports a small range from the first worksheet. ODS is an XML-in-ZIP format akin to XLSX while FODS is an XML format akin to SpreadsheetML. Both are detailed in the OASIS standard, but tools like LO/OO add undocumented extensions. The parsers and writers do not implement the full standard, instead focusing on parts necessary to extract and store raw data. UOS is a very similar format, and it comes in 2 varieties corresponding to ODS and FODS respectively. For the most part, the difference between the formats is in the names of tags and attributes. Many older formats supported only one worksheet: DBF is really a typed table format: each column can only hold one data type and each record omits type information. The parser generates a header row and inserts records starting at the second row of the worksheet. The writer makes files compatible with Visual FoxPro extensions. Multi-file extensions like external memos and tables are currently unsupported, limited by the general ability to read arbitrary files in the web browser. The reader understands DBF Level 7 extensions like DATETIME. There is no real documentation. All knowledge was gathered by saving files in various versions of Excel to deduce the meaning of fields. Notes:\n• Plain formulae are stored in the RC form. There is no real documentation, and in fact Excel treats PRN as an output-only file format. Nevertheless we can guess the column widths and reverse-engineer the original layout. Excel's 240 character width limitation is not enforced. There is no unified definition. Visicalc DIF differs from Lotus DIF, and both differ from Excel DIF. Where ambiguous, the parser/writer follows the expected behavior from Excel. In particular, Excel extends DIF in incompatible ways:\n• Since Excel automatically converts numbers-as-strings to numbers, numeric string constants are converted to formulae:\n• DIF technically expects numeric cells to hold the raw numeric data, but Excel permits formatted numbers (including dates)\n• DIF technically has no support for formulae, but Excel will automatically convert plain formulae. Array formulae are not preserved. Excel HTML worksheets include special metadata encoded in styles. For example, is a localized string containing the number format. Despite the metadata the output is valid HTML, although it does accept bare symbols. The writer adds type metadata to the TD elements via the tag. The parser looks for those tags and overrides the default interpretation. For example, text like will be parsed as numbers but will be parsed as text. Excel RTF worksheets are stored in clipboard when copying cells or ranges from a worksheet. The supported codes are a subset of the Word RTF support. Ethercalc is an open source web spreadsheet powered by a record format reminiscent of SYLK wrapped in a MIME multi-part message.\n\nTest files are housed in another repo.\n\nRunning will refresh the submodule and get the files. Note that this requires , , and other commands that may not be available. If fails, please download the latest version of the test files snapshot from the repo\n\nDue to the precarious nature of the Open Specifications Promise, it is very important to ensure code is cleanroom. Contribution Notes\n\nAfter cloning the repo, running will display a list of commands.\n\nPlease consult the attached LICENSE file for details. All rights not explicitly granted by the Apache 2.0 License are reserved by the Original Author."
    },
    {
        "link": "https://docs.aspose.com/cells/java/convert-json-to-excel",
        "document": "No need to wonder how to convert JSON to Excel file, because Aspose.Cells Java library has best decision. The Aspose.Cells Java API provides support for converting JSON format to spreadsheets. You can use JsonLoadOptions class to specify additional settings for importing JSON to Workbook.\n\nThe following code example demonstrates importing JSON to Excel Workbook. Please see the code to convert source file to the xlsx file generated by the code for reference.\n\nThe following code example which uses JsonLoadOptions class to specify additional settings demonstrates importing JSON to Excel Workbook. Please see the code to convert source file to the xlsx file generated by the code for reference.\n\nThe following code example demonstrates importing JSON string to Excel Workbook. You can also specify the location of the layout when importing JSON. Please see the code to convert JSON string to to the xlsx file generated by the code for reference."
    },
    {
        "link": "https://stackoverflow.com/questions/75014871/how-to-convert-json-data-into-excel-file-using-xlsx-library-in-nodejs",
        "document": "I have a big JSON file that has data structure like this below:\n\nSO here I have to compare of every id with the sort_title of arrays available in field.I have 3 arrays inside this field , and .If it is similar to those then i want to add those into the excel file.\n\nBelow is my code:\n\nBut after processing for a sometime its throwing error saying\n\nSomeone let me know how can I get the desired result."
    },
    {
        "link": "https://geeksforgeeks.org/how-to-convert-json-to-excel-in-javascript",
        "document": "How to Convert JSON to Excel in JavaScript?\n\nIt is often necessary to export or download JSON data in the form of Excel spreadsheets when developing web applications, any web developer would be able to go through this article as it provides a useful function of converting JSON files to Excel format using SheetsJS through JavaScript.\n\nThese are the following ways:\n\nSheetJS is one of those libraries, which specializes in all the operations such as reading, writing, or modifying the files containing spreadsheets, the library includes the support of a number of different formats including the Excel format (XLSX).\n\nYou can also install library via npm:\n\nAlternatively you can also include the library directly in your HTML:\n\nExample: This example shows the use of SheetJs to convert JSON to Excel.\n\nExcelJS is also a powerful library which provides ability to create new Excel spreadsheets or modify existing ones from within JavaScript and apply some style.\n\nYou can also install library via npm:\n\nAlternatively you can also include library directly in your HTML:\n\nExample: This example shows the use of ExcelJS to convert JSON to Excel.\n\nConverting the JSON into a CSV file format and then providing this as a downloadable file which can be opened as excel exported well this approach works too, this is a simple solution if you don’t want all the overhead that comes with using the Microsoft excel file format.\n\nYou can also install library via npm:\n\nAlternatively you can also include library directly in your HTML:\n\nExample: This example shows the use of FileSaver.js to convert JSON to Excel."
    }
]