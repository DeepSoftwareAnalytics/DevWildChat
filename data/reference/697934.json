[
    {
        "link": "https://php.net/manual/en/book.mysqli.php",
        "document": "and to navigate\n• to select\n• to close\n\nPress without selection to search using Google"
    },
    {
        "link": "https://php.net/manual/en/mysqli.error.php",
        "document": "information at saunderswebsolutions dot com ¶ The mysqli_sql_exception class is not available to PHP 5.05\n\n\n\nI used this code to catch errors \n\n The problem with this is that valid values for $res are: a mysqli_result object , true or false\n\nThis doesn't tell us that there has been an error with the sql used.\n\nIf you pass an update statement, false is a valid result if the update fails.\n\n\n\nSo, a better way is:\n\n \n\nThis would output something like:\n\nUnexpected PHP error [mysqli::query() [<a href='function.query'>function.query</a>]: (42S22/1054): Unknown column 'XXname' in 'field list'] severity [E_WARNING] in [G:\\database.php] line [249]\n\n\n\nVery frustrating as I wanted to also catch the sql error and print out the stack trace. \n\n\n\nA better way is:\n\n\n\n Prints out something like:\n\nError No: 1054\n\nUnknown column 'XXname' in 'field list'\n\nQuery: \n\nSELECT XXname FROM customer_table\n\n\n\n#0 G:\\\\database.php(251): database->dbError('Unknown column ...', 1054, 'getQuery()', 'SELECT XXname F...')\n\n#1 G:\\data\\WorkSites\\1framework5\\tests\\dbtest.php(29): database->getString('SELECT XXname F...')\n\n#2 c:\\PHP\\includes\\simpletest\\runner.php(58): testOfDB->testGetVal()\n\n#3 c:\\PHP\\includes\\simpletest\\runner.php(96): SimpleInvoker->invoke('testGetVal')\n\n#4 c:\\PHP\\includes\\simpletest\\runner.php(125): SimpleInvokerDecorator->invoke('testGetVal')\n\n#5 c:\\PHP\\includes\\simpletest\\runner.php(183): SimpleErrorTrappingInvoker->invoke('testGetVal')\n\n#6 c:\\PHP\\includes\\simpletest\\simple_test.php(90): SimpleRunner->run()\n\n#7 c:\\PHP\\includes\\simpletest\\simple_test.php(498): SimpleTestCase->run(Object(HtmlReporter))\n\n#8 c:\\PHP\\includes\\simpletest\\simple_test.php(500): GroupTest->run(Object(HtmlReporter))\n\n#9 G:\\all_tests.php(16): GroupTest->run(Object(HtmlReporter))\n\n\n\nThis will actually print out the error, a stack trace and the offending sql statement. Much more helpful when the sql statement is generated somewhere else in the code.\n\nse (at) brainbits (dot) net ¶ The decription \"mysqli_error -- Returns a string description of the LAST error\" is not exactly that what you get from mysqli_error. You get the error description from the last mysqli-function, not from the last mysql-error.\n\n\n\nIf you have the following situation\n\n\n\nif (!$mysqli->query(\"SET a=1\")) {\n\n $mysqli->query(\"ROLLBACK;\")\n\n printf(\"Errormessage: %s\n\n\", $mysqli->error);\n\n}\n\n\n\nyou don't get an error-message, if the ROLLBACK-Query didn't failed, too. In order to get the right error-message you have to write:\n\n\n\nif (!$mysqli->query(\"SET a=1\")) {\n\n printf(\"Errormessage: %s\n\n\", $mysqli->error);\n\n $mysqli->query(\"ROLLBACK;\")\n\n}\n\ncallforeach at gmail dot com ¶ I had to set mysqli_report(MYSQLI_REPORT_ALL) at the begin of my script to be able to catch mysqli errors within the catch block of my php code.\n\n\n\nInitially, I used the below code to throw and subsequent catch mysqli exceptions\n\n\n\n I realized the exception was being thrown before the actual block was not being called 'm able to trap all mysqli errors\n\nasmith16 at littlesvr dot ca ¶ Please note that the string returned may contain data initially provided by the user, possibly making your code vulnerable to XSS. \n\n\n\nSo even if you escape everything in your SQL query using mysqli_real_escape_string(), make sure that if you plan to display the string returned by mysqli_error() you run that string through htmlspecialchars().\n\n\n\nAs far as I can tell the two escape functions don't escape the same characters, which is why you need both (the first for SQL and the second for HTML/JS)."
    },
    {
        "link": "https://php.net/manual/en/mysqli.connect-error.php",
        "document": "/* @ is used to suppress warnings */\n\n /* Use your preferred error logging method here */"
    },
    {
        "link": "https://w3schools.com/php/php_ref_mysqli.asp",
        "document": "The MySQLi functions allows you to access MySQL database servers.\n\nNote: The MySQLi extension is designed to work with MySQL version 4.1.13 or newer.\n\nFor the MySQLi functions to be available, you must compile PHP with support for the MySQLi extension.\n\nThe MySQLi extension was introduced with PHP version 5.0.0. The MySQL Native Driver was included in PHP version 5.3.0.\n\nFor installation details, go to: http://php.net/manual/en/mysqli.installation.php\n\nFor runtime configuration details, go to: http://php.net/manual/en/mysqli.configuration.php"
    },
    {
        "link": "https://stackoverflow.com/questions/45474141/php-mysqli-connection-and-query-error-handling-how",
        "document": "The following PHP code works. I just don't seem to be able to handle its errors in a custom way.\n\nFor example, when I intentionally misspell anything in the connection string to return code \"3\" for database down, my AJAX script just hangs in beforeSend forever...\n\nThis is what I got:\n\nAlright. After some research I have found that this works. It appears that you need to tell mysqli to throw exceptions.. For some reason this is different than just trying to handle an error the \"IF\" way. Any suggestions for improvement?\n\nHere's is the final tested and working PHP solution for all to see."
    },
    {
        "link": "https://stackoverflow.com/questions/20011555/fastest-way-to-dynamically-update-the-style-of-millions-of-dom-elements",
        "document": "I've built Conway's Game of Life in the browser just using the DOM. Nothing speical, it's been done before. My goal is to optimize it as best as I can. My actual Game of Life code works fine, and is fast enough for my liking. The bottleneck occurs in updating the screen state. With hundreds of thousands or millions of DOM elements on the screen, you can imagine that this can be quite slow (although faster than I first thought). My question is:\n\nWorking with upwards of a million DOM elements on the screen at a time, what is the fastest way to iterate through a list of DOM elements and individually change their style?\n\nI'm using a class to keep track of styles, would it be better to dynamically change their instead of ? I'm keeping all these elements in a multidimensional array, would it be better to iterate through another way (the loop itself is not a bottleneck, there are many such loops in my code that run fast enough for me)? I don't really know anything about \"reflows\" or how the browser renders things when elements change. Could these ideas be leveraged in a way that increases performance?\n\nHere is my current code:\n\nwith the class style being:"
    },
    {
        "link": "https://freecodecamp.org/news/dom-manipulation-best-practices",
        "document": "In JavaScript, you can manipulate the content of a web page using the Document Object Model (DOM). But how do you write code that is readable, easy to maintain, and not prone to performance issues?\n\nThat's what we'll cover in this article. I'll discuss some important best practices so that you can manipulate the DOM with confidence.\n\nThe event is fired when the HTML document is fully loaded. Using this event ensures that your DOM manipulation code runs only after the document is fully loaded.\n\nTo use the , add an event listener to the document and listen for the event. This helps prevent any issues that may come up when you try to manipulate elements that are yet to be rendered.\n\nWhen you have frequently used elements, querying the DOM for the same element anytime over and over is inefficient. It's better to query the DOM once and store the result in variables.\n\nThis way you can reference the variables anytime you want to use them. This helps improve performance as it reduces unnecessary work.\n\nWhen you cache an element, you can also query it to select any of its descendants. This can help improve performance because it limits the scope of the query and reduces the number of times the entire document is queried.\n\nIn the example above is a simple markup containing a div and paragraph. Then there are two options for selecting the child element.\n\nTechnically, both options are correct and will select the same element. But the difference is in the scope of the query.\n\nExample 1 queries (or searches) the entire document to find and select the child. This is less performant and not even necessary because the parent of the element you intend to select is already cached.\n\nExample 2 narrows the scope of the query (or search) by querying only the parent element and not the whole document. That's why it's preferred because it's more performant – especially when the document is large.\n\nAlso, note that the method used for querying the parent is . Using to query the parent won't work and will result in an error.\n\nIt's best to use CSS classes to style elements instead of using inline styles. Classes are easy to maintain compared to inline styles which can be hard to manage.\n\nThe property has useful properties like add, remove, toggle, and others that makes it easy to modify styles.\n\nThis example uses the property of to add the to the element. Assuming you wanted to remove the class from the element, you can easily do so using the property in place of add.\n\nThe property reads and parses HTML markup that you pass to it. This means it can read and run code in a script tag passed to it. And this can pose a security risk to your application.\n\nWhere possible, use the or property to render strings. But if you need to use , be sure you're using it to insert content from trusted sources. Or sanitize and validate the provided content with a library like DOMPurify.\n\nYou can read this freeCodeCamp article to learn more about .\n\nOften you will pass two arguments to event listeners. The first is the event you're listening to and the second is the event handler (the function that fires when the event occurs).\n\nTo make your code easy to read and maintain, you can define the event handler function outside of the event listener. Then you can call it within the even listener, like in example 1 below:\n\nBoth are technically correct and will do the same thing. But example 1 is preferred because it's easier to read. Also, you can reuse the function if you need to. This helps you observe the DRY (Don't Repeat Yourself) principle.\n\nEvent delegation is when you attach an event listener on a parent element to listen to events on its descendants. With this technique, you can reduce the number of event listeners to include in your code.\n\nFor example, assume you have five buttons inside a parent div:\n\nYou can add an event listener to each of the five buttons to listen to a click. Or using event delegation, you can a single event on only the parent div:\n\nIn this example, the event to delegated to the parent element. And we're using to get the actual button the user clicked. If you are curious, you can run the code on Stackblitz to see how it works.\n\nEvent delegation help saves time improve performance. Imagine how this technique can come in handy when dealing with a large amount of dynamic content.\n\nFrequent updates to the DOM can affect the performance of your application. Try to reduce the number of updates where possible.\n\nA useful feature you can use to batch updates is the property. It allows you to group multiple updates before inserting them into the document. This reduces reflows and makes your code more effecient.\n\nThis code updates with each iteration of the loop. That means the DOM will be update 1,000 times. There is a more efficient way of doing this with the code below that uses fragment.\n\nThe code above appends the to the with each iteration of the loop. It only appends the child to the element after the loop is done running. This means the DOM is updated only once instead of 1,000 times like before.\n\nThe method controls the flow of events in the DOM. By default, when an event occurs on an element, it bubbles (propagates) through its ancestors.\n\nThis event propagating behaviour can sometimes lead to unintended results. The method provides a way to stop the event from propagating to the parent and other ancestors.\n\nLet's take a situation where you have a button inside a parent div. And you want to handle a click event on the button without registering the click on the div:\n\nWithout using the method, a click event on the button will also trigger a click event on the parent div. This means both event handlers will run.\n\nBut the line in the code will prevent the function from running when a user clicks the button.\n\nYou can run the code on Stackblitz to see how it works. Comment out the line with the method and see the difference.\n\nWhen you write tests, you create scenarios that mimic user interactions or application states. You also verify that your application gives you the expected outcomes.\n\nTesting your DOM manipulation code is a best practice because it will make your code reliable and easy to maintain. It also gives you confidence that your code behaves as expected, even as it evolves over time when you make changes and add features.\n\nYou can use testing frameworks and libraries available for JavaScript, such as Jest, Mocha, Jasmine, and others to automate testing your apps.\n\nThe following example uses the Jest framework to test DOM Manipulation code for adding a class to an element.\n\nAdding the class is expected to change the text color to red. If the test passes, it means your DOM manipulation code works as expected. If not, you will need to figure out what figure out what's wrong and fix the issue.\n\nIn this article you've learned ten best practices to keep in mind when working with the DOM. Some of them are general while others are situation specific. By using these best practices in your workflow, you will be building your web applications with a code base that is easy to maintain.\n\nIf you want to dive deep into DOM manipulation, I wrote a whole handbook that covers the subject in depth.\n\nThanks for reading. And happy coding! For more in-depth tutorials, feel free to subscribe to my YouTube channel"
    },
    {
        "link": "https://stackoverflow.com/questions/37039667/executing-multiple-dom-updates-with-javascript-efficiently",
        "document": "You aren't real specific about exactly what you're doing so about the best we can do here is to give you general advice about a bunch of relevant areas.\n\nYou don't quite fill in all the details of what you're trying to do, but here are a bunch of things to take into consideration when optimizing how your code works:\n• None Reflows are already queued. The browser already attempts to minimize reflows so if you do four dom modifications in one sequential piece of Javascript, the browser will wait for that piece of Javascript to finish running and then do one reflow and one repaint.\n• None Requesting certain properties can trigger an immediate reflow. There are exceptions to the above rule that you want to make sure you avoid. For example if you request certain DOM properties that require proper layout for the property value to be accurately reported and there is a pending layout from a prior modification, then the browser may relayout the document synchronously before returning the property you requested. These type of properties usually involve things like screen position and other properties that would obviously be affected by the layout of the document. There are many articles on this topic if you want to find further details. In many cases your code won't be using these properties anyway, but if so, the usual workaround is to request all the needed properties first before making any changes to the DOM.\n• None Batch up all your DOM changes at once. The worst thing to do is to make a DOM change, wait a few ms with a timer, make another DOM change, wait a few ms with a timer and so on because you will have DOM change, reflow, repaint, DOM change, reflow, repaint, etc... Instead, make sure you're doing all pending DOM changes at once in one synchronous piece of Javascript. This will then allow the browser to queue the reflow and repaint and do it only once after you've made all your DOM changes. If you want to get even smarter about the batching, you will collapse modifications to the same element so that it is only processed once with the final value. So, if elementA was first given a new value of 3 and then later in the same batch was given a value of 4, when processing the batch of data, you want to skip the 3 and just process the 4.\n• None DOM modifications can sometimes be optimized. You don't give us any specifics on how you are modifying the DOM, but if you are modifying complex objects (like adding many table rows or changing lots of table cells), then it is sometimes better to create a set of DOM elements that are not currently inserted in the DOM, make all your modifications to them and then with one operation, insert them into the DOM. This is because modifying DOM elements that are currently inserted in the DOM forces the browser to figure out which other DOM elements are affected by this change so it can queue the appropriate reflows or repaints. But modifying off-screen DOM elements does not have to do any of that work until the one last step where one larger object is inserted into the DOM. There is no useful generic rules here because how you take advantage of this optimization depends entirely upon what DOM modifications you are doing. We could help you with this, but only when we could see both the HTML you have and exactly what changes you're making to it.\n\nNow, as for the timing of things, you mentioned up to 250 times per second. That's kind of fast (4ms per operation) for a user viewable thing. If you do that, your browser is basically going to be constantly reflowing and repainting with only occasional pauses to process other user events. Since no user can actually see something happen at 4ms, 8ms and 12ms from now, there's really no need to update status on screen that often.\n\nSo, if you really have changes coming in that fast or often, you may want to batch them by accumulating them into a local data structure and then just updating the screen every 100-500ms or so. You'd have to experiment with what the long interval you could use and not really notice any delay.\n\nThere are several implementation strategies for batching the updates. The simplest I can think of if your modifications are always streaming in constantly is to just put the modifications into a local array as they come in and then just have an interval timer set for your update interval that checks the array and if there's anything in it, it process all the items in the array into a DOM update.\n\nGetting Changes From Server\n\nYou don't mention how the browser Javascript is getting the new data. There are generally two options, repeated Ajax requests or create a webSocket and the server can directly send you data at any time.\n\nIf your updates are regularly and shortly spaced, the webSocket connection is clearly the most efficient. It's one constant connection and the server can just send each client new data whenever the server has new data to send.\n\nIf you're going to be polling with Ajax, then I'd strongly suggest you lengthen out the polling interval. A very short polling interval will both really load your server and eat the battery on the client.\n\nIf this app is intended to run for long periods of time on a battery powered device, then getting a steady stream of data real-time (e.g. every few ms like you mentioned) from any server is going to eat battery because the radio (WiFi or Cellular) will be active nearly all the time and the CPU is going to be running a lot too."
    },
    {
        "link": "https://medium.com/@rabailzaheer/javascript-dom-manipulation-how-to-create-modify-and-remove-elements-efficiently-866ab4ac3c10",
        "document": "Have you ever clicked a button on a webpage and magically seen new content appear? Or delete an item from your to-do list without refreshing the page? That’s not magic — it’s DOM manipulation in action!\n\nWhether you’re building interactive forms, dynamic lists, or real-time updates, knowing how to efficiently create, modify, and remove elements is a must-have skill for any JavaScript developer. But here’s the catch — doing it the wrong way can slow down your website, cause unexpected bugs, or make your code messy.\n\nBefore we dive into mastering DOM manipulation, make sure you understand the Document Object Model (DOM) itself — JavaScript’s Document Object Model is a great place to start. Also, knowing how to select elements properly will make your life easier, so check out Selecting and Styling Elements — A DOM Guide.\n\nAlright! Now that we understand the DOM and how to select elements from previous blogs, let’s learn how to create new elements in JavaScript. Imagine you’re building something with LEGO blocks — JavaScript lets you add new blocks (HTML elements) to your webpage, whenever you want!\n\nHow to Create a New Element?"
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Learn_web_development/Core/Scripting/DOM_scripting",
        "document": "When writing web pages and apps, one of the most common things you'll want to do is change the document structure in some way. This is usually done by manipulating the Document Object Model (DOM) via a set of built-in browser APIs for controlling HTML and styling information. In this article we'll introduce you to DOM scripting. An understanding of HTML and the fundamentals of CSS, familiarity with JavaScript basics as covered in previous lessons.\n• What the DOM is — the browser's internal representation of the document's HTML structure as a hierarchy of objects.\n• The important parts of a web browser as represented in JavaScript — , , and .\n• How DOM nodes exist relative to each other in the DOM tree — root, parent, child, sibling, and descendant.\n• Getting references to DOM nodes, creating new nodes, adding and removing nodes and attributes.\n\nWeb browsers are very complicated pieces of software with a lot of moving parts, many of which can't be controlled or manipulated by a web developer using JavaScript. You might think that such limitations are a bad thing, but browsers are locked down for good reasons, mostly centering around security. Imagine if a website could get access to your stored passwords or other sensitive information, and log into websites as if it were you? Despite the limitations, Web APIs still give us access to a lot of functionality that enable us to do a great many things with web pages. There are a few really obvious bits you'll reference regularly in your code — consider the following diagram, which represents the main parts of a browser directly involved in viewing web pages:\n• The window is the browser tab that a web page is loaded into; this is represented in JavaScript by the object. Using methods available on this object you can do things like return the window's size (see and ), manipulate the document loaded into that window, store data specific to that document on the client-side (for example using a local database or other storage mechanism), attach an event handler to the current window, and more.\n• The navigator represents the state and identity of the browser (i.e. the user-agent) as it exists on the web. In JavaScript, this is represented by the object. You can use this object to retrieve things like the user's preferred language, a media stream from the user's webcam, etc.\n• The document (represented by the DOM in browsers) is the actual page loaded into the window, and is represented in JavaScript by the object. You can use this object to return and manipulate information on the HTML and CSS that comprises the document, for example get a reference to an element in the DOM, change its text content, apply new styles to it, create new elements and add them to the current element as children, or even delete it altogether. In this article we'll focus mostly on manipulating the document, but we'll show a few other useful bits besides.\n\nLet's provide a brief recap on the Document Object Model (DOM), which we also looked at earlier in the course. The document currently loaded in each one of your browser tabs is represented by a DOM. This is a \"tree structure\" representation created by the browser that enables the HTML structure to be easily accessed by programming languages — for example the browser itself uses it to apply styling and other information to the correct elements as it renders a page, and developers like you can manipulate the DOM with JavaScript after the page has been rendered. We have created an example page at dom-example.html (see it live also). Try opening this up in your browser — it is a very simple page containing a element inside which you can find an image, and a paragraph with a link inside. The HTML source code looks like this: <!doctype html> <html lang=\"en-US\"> <head> <meta charset=\"utf-8\" /> <title>Simple DOM example</title> </head> <body> <section> <img src=\"dinosaur.png\" alt=\"A red Tyrannosaurus Rex: A two legged dinosaur standing upright like a human, with small arms, and a large head with lots of sharp teeth.\" /> <p> Here we will add a link to the <a href=\"https://www.mozilla.org/\">Mozilla homepage</a> </p> </section> </body> </html> The DOM on the other hand looks like this: Note: This DOM tree diagram was created using Ian Hickson's Live DOM viewer. Each entry in the tree is called a node. You can see in the diagram above that some nodes represent elements (identified as , , and so on) and others represent text (identified as ). There are other types of nodes as well, but these are the main ones you'll encounter. Nodes are also referred to by their position in the tree relative to other nodes:\n• Root node: The top node in the tree, which in the case of HTML is always the node (other markup vocabularies like SVG and custom XML will have different root elements).\n• Child node: A node directly inside another node. For example, is a child of in the above example.\n• Descendant node: A node anywhere inside another node. For example, is a child of in the above example, and it is also a descendant. is not a child of , as it is two levels below it in the tree, but it is a descendant of .\n• Parent node: A node which has another node inside it. For example, is the parent node of in the above example.\n• Sibling nodes: Nodes that sit on the same level under the same parent node in the DOM tree. For example, and are siblings in the above example. It is useful to familiarize yourself with this terminology before working with the DOM, as a number of the code terms you'll come across make use of them. You'll also come across them in CSS (e.g. descendant selector, child selector).\n\nTo start learning about DOM manipulation, let's begin with a practical example.\n• Take a local copy of the dom-example.html page and the image that goes along with it.\n• Add a element just above the closing tag.\n• To manipulate an element inside the DOM, you first need to select it and store a reference to it inside a variable. Inside your script element, add the following line:\n• Now we have the element reference stored in a variable, we can start to manipulate it using properties and methods available to it (these are defined on interfaces like in the case of element, its more general parent interface , and — which represents all nodes in a DOM). First of all, let's change the text inside the link by updating the value of the property. Add the following line below the previous one:\n• We should also change the URL the link is pointing to, so that it doesn't go to the wrong place when it is clicked on. Add the following line, again at the bottom: Note that, as with many things in JavaScript, there are many ways to select an element and store a reference to it in a variable. is the recommended modern approach. It is convenient because it allows you to select elements using CSS selectors. The above call will match the first element that appears in the document. If you wanted to match and do things to multiple elements, you could use , which matches every element in the document that matches the selector, and stores references to them in an array-like object called a . There are older methods available for grabbing element references, such as:\n• , which selects an element with a given attribute value, e.g. . The ID is passed to the function as a parameter, i.e. .\n• , which returns an array-like object containing all the elements on the page of a given type, for example s, s, etc. The element type is passed to the function as a parameter, i.e. . These two work better in older browsers than the modern methods like , but are not as convenient. Have a look and see what others you can find!\n\nThe above has given you a little taste of what you can do, but let's go further and look at how we can create new elements.\n• Going back to the current example, let's start by grabbing a reference to our element — add the following code at the bottom of your existing script (do the same with the other lines too):\n• Now let's create a new paragraph using and give it some text content in the same way as before: const para = document.createElement(\"p\"); para.textContent = \"We hope you enjoyed the ride.\";\n• You can now append the new paragraph at the end of the section using :\n• Finally for this part, let's add a text node to the paragraph the link sits inside, to round off the sentence nicely. First we will create the text node using :\n• Now we'll grab a reference to the paragraph the link is inside, and append the text node to it: That's most of what you need for adding nodes to the DOM — you'll make a lot of use of these methods when building dynamic interfaces (we'll look at some examples later).\n\nThere may be times when you want to move nodes, or delete them from the DOM altogether. This is perfectly possible. If we wanted to move the paragraph with the link inside it to the bottom of the section, we could do this: This moves the paragraph down to the bottom of the section. You might have thought it would make a second copy of it, but this is not the case — is a reference to the one and only copy of that paragraph. If you wanted to make a copy and add that as well, you'd need to use instead. Removing a node is pretty simple as well, at least when you have a reference to the node to be removed and its parent. In our current case, we just use , like this: When you want to remove a node based only on a reference to itself, which is fairly common, you can use : This method is not supported in older browsers. They have no method to tell a node to remove itself, so you'd have to do the following: Have a go at adding the above lines to your code.\n\nIt is possible to manipulate CSS styles via JavaScript in a variety of ways. To start with, you can get a list of all the stylesheets attached to a document using , which returns an array-like object with objects. You can then add/remove styles as wished. However, we're not going to expand on those features because they are a somewhat archaic and difficult way to manipulate style. There are much easier ways. The first way is to add inline styles directly onto elements you want to dynamically style. This is done with the property, which contains inline styling information for each element in the document. You can set properties of this object to directly update element styles.\n• As an example, try adding these lines to our ongoing example:\n• Reload the page and you'll see that the styles have been applied to the paragraph. If you look at that paragraph in your browser's Page Inspector/DOM inspector, you'll see that these lines are indeed adding inline styles to the document: <p style=\"color: white; background-color: black; padding: 10px; width: 250px; text-align: center;\"> We hope you enjoyed the ride. </p> Note: Notice how the JavaScript property versions of the CSS styles are written in lower camel case whereas the CSS versions are hyphenated (kebab-case) (e.g. versus ). Make sure you don't get these mixed up, otherwise it won't work. There is another common way to dynamically manipulate styles on your document, which we'll look at now.\n• Delete the previous five lines you added to the JavaScript.\n• Add the following inside your HTML :\n• Now we'll turn to a very useful method for general HTML manipulation — — this takes two arguments, the attribute you want to set on the element, and the value you want to set it to. In this case we will set a class name of highlight on our paragraph:\n• Refresh your page, and you'll see no change — the CSS is still applied to the paragraph, but this time by giving it a class that is selected by our CSS rule, not as inline CSS styles. Which method you choose is up to you; both have their advantages and disadvantages. The first method takes less setup and is good for simple uses, whereas the second method is more purist (no mixing CSS and JavaScript, no inline styles, which are seen as a bad practice). As you start building larger and more involved apps, you will probably start using the second method more, but it is really up to you. At this point, we haven't really done anything useful! There is no point using JavaScript to create static content — you might as well just write it into your HTML and not use JavaScript. It is more complex than HTML, and creating your content with JavaScript also has other issues attached to it (such as not being readable by search engines). In the next section we will look at a more practical use of DOM APIs. Note: You can find our finished version of the dom-example.html demo on GitHub (see it live also)."
    }
]