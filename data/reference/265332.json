[
    {
        "link": "https://tanstack.com/query/v3/docs",
        "document": "React Query is often described as the missing data-fetching library for React, but in more technical terms, it makes fetching, caching, synchronizing and updating server state in your React applications a breeze.\n\nOut of the box, React applications do not come with an opinionated way of fetching or updating data from your components so developers end up building their own ways of fetching data. This usually means cobbling together component-based state and effect using React hooks, or using more general purpose state management libraries to store and provide asynchronous data throughout their apps.\n\nWhile most traditional state management libraries are great for working with client state, they are not so great at working with async or server state. This is because server state is totally different. For starters, server state:\n• Is persisted remotely in a location you do not control or own\n• Implies shared ownership and can be changed by other people without your knowledge\n• Can potentially become \"out of date\" in your applications if you're not careful\n\nOnce you grasp the nature of server state in your application, even more challenges will arise as you go, for example:\n• Caching... (possibly the hardest thing to do in programming)\n• Deduping multiple requests for the same data into a single request\n• Updating \"out of date\" data in the background\n• Knowing when data is \"out of date\"\n• Reflecting updates to data as quickly as possible\n\nIf you're not overwhelmed by that list, then that must mean that you've probably solved all of your server state problems already and deserve an award. However, if you are like a vast majority of people, you either have yet to tackle all or most of these challenges and we're only scratching the surface!\n\nReact Query is hands down one of the best libraries for managing server state. It works amazingly well out-of-the-box, with zero-config, and can be customized to your liking as your application grows.\n\nReact Query allows you to defeat and overcome the tricky challenges and hurdles of server state and control your app data before it starts to control you.\n\nOn a more technical note, React Query will likely:\n• Help you remove many lines of complicated and misunderstood code from your application and replace with just a handful of lines of React Query logic.\n• Make your application more maintainable and easier to build new features without worrying about wiring up new server state data sources\n• Have a direct impact on your end-users by making your application feel faster and more responsive than ever before.\n• Potentially help you save on bandwidth and increase memory performance\n\nIn the example below, you can see React Query in its most basic and simple form being used to fetch the GitHub stats for the React Query GitHub project itself:\n• Consider taking the official React Query Course (or buying it for your whole team!)\n• Learn React Query at your own pace with our amazingly thorough Walkthrough Guide and API Reference"
    },
    {
        "link": "https://legacy.reactjs.org/docs/hooks-reference.html",
        "document": "Hooks are a new addition in React 16.8. They let you use state and other React features without writing a class.\n\nThis page describes the APIs for the built-in Hooks in React.\n\nIf you’re new to Hooks, you might want to check out the overview first. You may also find useful information in the frequently asked questions section.\n\nReturns a stateful value, and a function to update it.\n\nDuring the initial render, the returned state ( ) is the same as the value passed as the first argument ( ).\n\nThe function is used to update the state. It accepts a new state value and enqueues a re-render of the component.\n\nDuring subsequent re-renders, the first value returned by will always be the most recent state after applying updates.\n\nIf the new state is computed using the previous state, you can pass a function to . The function will receive the previous value, and return an updated value. Here’s an example of a counter component that uses both forms of :\n\nThe ”+” and ”-” buttons use the functional form, because the updated value is based on the previous value. But the “Reset” button uses the normal form, because it always sets the count back to the initial value.\n\nIf your update function returns the exact same value as the current state, the subsequent rerender will be skipped completely.\n\nThe argument is the state used during the initial render. In subsequent renders, it is disregarded. If the initial state is the result of an expensive computation, you may provide a function instead, which will be executed only on the initial render:\n\nIf you update a State Hook to the same value as the current state, React will bail out without rendering the children or firing effects. (React uses the comparison algorithm.)\n\nNote that React may still need to render that specific component again before bailing out. That shouldn’t be a concern because React won’t unnecessarily go “deeper” into the tree. If you’re doing expensive calculations while rendering, you can optimize them with .\n\nReact may group several state updates into a single re-render to improve performance. Normally, this improves performance and shouldn’t affect your application’s behavior.\n\nBefore React 18, only updates inside React event handlers were batched. Starting with React 18, batching is enabled for all updates by default. Note that React makes sure that updates from several different user-initiated events — for example, clicking a button twice — are always processed separately and do not get batched. This prevents logical mistakes.\n\nIn the rare case that you need to force the DOM update to be applied synchronously, you may wrap it in . However, this can hurt performance so do this only where needed.\n\nMutations, subscriptions, timers, logging, and other side effects are not allowed inside the main body of a function component (referred to as React’s render phase). Doing so will lead to confusing bugs and inconsistencies in the UI.\n\nInstead, use . The function passed to will run after the render is committed to the screen. Think of effects as an escape hatch from React’s purely functional world into the imperative world.\n\nBy default, effects run after every completed render, but you can choose to fire them only when certain values have changed.\n\nOften, effects create resources that need to be cleaned up before the component leaves the screen, such as a subscription or timer ID. To do this, the function passed to may return a clean-up function. For example, to create a subscription:\n\nThe clean-up function runs before the component is removed from the UI to prevent memory leaks. Additionally, if a component renders multiple times (as they typically do), the previous effect is cleaned up before executing the next effect. In our example, this means a new subscription is created on every update. To avoid firing an effect on every update, refer to the next section.\n\nUnlike and , the function passed to fires after layout and paint, during a deferred event. This makes it suitable for the many common side effects, like setting up subscriptions and event handlers, because most types of work shouldn’t block the browser from updating the screen.\n\nHowever, not all effects can be deferred. For example, a DOM mutation that is visible to the user must fire synchronously before the next paint so that the user does not perceive a visual inconsistency. (The distinction is conceptually similar to passive versus active event listeners.) For these types of effects, React provides one additional Hook called . It has the same signature as , and only differs in when it is fired.\n\nAdditionally, starting in React 18, the function passed to will fire synchronously before layout and paint when it’s the result of a discrete user input such as a click, or when it’s the result of an update wrapped in . This behavior allows the result of the effect to be observed by the event system, or by the caller of .\n\nEven in cases where is deferred until after the browser has painted, it’s guaranteed to fire before any new renders. React will always flush a previous render’s effects before starting a new update.\n\nThe default behavior for effects is to fire the effect after every completed render. That way an effect is always recreated if one of its dependencies changes.\n\nHowever, this may be overkill in some cases, like the subscription example from the previous section. We don’t need to create a new subscription on every update, only if the prop has changed.\n\nTo implement this, pass a second argument to that is the array of values that the effect depends on. Our updated example now looks like this:\n\nNow the subscription will only be recreated when changes.\n\nThe array of dependencies is not passed as arguments to the effect function. Conceptually, though, that’s what they represent: every value referenced inside the effect function should also appear in the dependencies array. In the future, a sufficiently advanced compiler could create this array automatically.\n\nAccepts a context object (the value returned from ) and returns the current context value for that context. The current context value is determined by the prop of the nearest above the calling component in the tree.\n\nWhen the nearest above the component updates, this Hook will trigger a rerender with the latest context passed to that provider. Even if an ancestor uses or , a rerender will still happen starting at the component itself using .\n\nDon’t forget that the argument to must be the context object itself:\n\nA component calling will always re-render when the context value changes. If re-rendering the component is expensive, you can optimize it by using memoization.\n\nPutting it together with Context.Provider\n\nThis example is modified for hooks from a previous example in the Context Advanced Guide, where you can find more information about when and how to use Context.\n\nThe following Hooks are either variants of the basic ones from the previous section, or only needed for specific edge cases. Don’t stress about learning them up front.\n\nAn alternative to . Accepts a reducer of type , and returns the current state paired with a method. (If you’re familiar with Redux, you already know how this works.)\n\nis usually preferable to when you have complex state logic that involves multiple sub-values or when the next state depends on the previous one. also lets you optimize performance for components that trigger deep updates because you can pass down instead of callbacks.\n\nHere’s the counter example from the section, rewritten to use a reducer:\n\nThere are two different ways to initialize state. You may choose either one depending on the use case. The simplest way is to pass the initial state as a second argument:\n\nYou can also create the initial state lazily. To do this, you can pass an function as the third argument. The initial state will be set to .\n\nIt lets you extract the logic for calculating the initial state outside the reducer. This is also handy for resetting the state later in response to an action:\n\nIf you return the same value from a Reducer Hook as the current state, React will bail out without rendering the children or firing effects. (React uses the comparison algorithm.)\n\nNote that React may still need to render that specific component again before bailing out. That shouldn’t be a concern because React won’t unnecessarily go “deeper” into the tree. If you’re doing expensive calculations while rendering, you can optimize them with .\n\nPass an inline callback and an array of dependencies. will return a memoized version of the callback that only changes if one of the dependencies has changed. This is useful when passing callbacks to optimized child components that rely on reference equality to prevent unnecessary renders (e.g. ).\n\nPass a “create” function and an array of dependencies. will only recompute the memoized value when one of the dependencies has changed. This optimization helps to avoid expensive calculations on every render.\n\nRemember that the function passed to runs during rendering. Don’t do anything there that you wouldn’t normally do while rendering. For example, side effects belong in , not .\n\nIf no array is provided, a new value will be computed on every render.\n\nYou may rely on as a performance optimization, not as a semantic guarantee. In the future, React may choose to “forget” some previously memoized values and recalculate them on next render, e.g. to free memory for offscreen components. Write your code so that it still works without — and then add it to optimize performance.\n\nreturns a mutable ref object whose property is initialized to the passed argument ( ). The returned object will persist for the full lifetime of the component.\n\nA common use case is to access a child imperatively:\n\nEssentially, is like a “box” that can hold a mutable value in its property.\n\nYou might be familiar with refs primarily as a way to access the DOM. If you pass a ref object to React with , React will set its property to the corresponding DOM node whenever that node changes.\n\nHowever, is useful for more than the attribute. It’s handy for keeping any mutable value around similar to how you’d use instance fields in classes.\n\nThis works because creates a plain JavaScript object. The only difference between and creating a object yourself is that will give you the same ref object on every render.\n\nKeep in mind that doesn’t notify you when its content changes. Mutating the property doesn’t cause a re-render. If you want to run some code when React attaches or detaches a ref to a DOM node, you may want to use a callback ref instead.\n\ncustomizes the instance value that is exposed to parent components when using . As always, imperative code using refs should be avoided in most cases. should be used with :\n\nIn this example, a parent component that renders would be able to call .\n\nThe signature is identical to , but it fires synchronously after all DOM mutations. Use this to read layout from the DOM and synchronously re-render. Updates scheduled inside will be flushed synchronously, before the browser has a chance to paint.\n\nPrefer the standard when possible to avoid blocking visual updates.\n\ncan be used to display a label for custom hooks in React DevTools.\n\nFor example, consider the custom Hook described in “Building Your Own Hooks”:\n\nIn some cases formatting a value for display might be an expensive operation. It’s also unnecessary unless a Hook is actually inspected.\n\nFor this reason accepts a formatting function as an optional second parameter. This function is only called if the Hooks are inspected. It receives the debug value as a parameter and should return a formatted display value.\n\nFor example a custom Hook that returned a value could avoid calling the function unnecessarily by passing the following formatter:\n\naccepts a value and returns a new copy of the value that will defer to more urgent updates. If the current render is the result of an urgent update, like user input, React will return the previous value and then render the new value after the urgent render has completed.\n\nThis hook is similar to user-space hooks which use debouncing or throttling to defer updates. The benefits to using is that React will work on the update as soon as other work finishes (instead of waiting for an arbitrary amount of time), and like , deferred values can suspend without triggering an unexpected fallback for existing content.\n\nonly defers the value that you pass to it. If you want to prevent a child component from re-rendering during an urgent update, you must also memoize that component with or :\n\nMemoizing the children tells React that it only needs to re-render them when changes and not when changes. This caveat is not unique to , and it’s the same pattern you would use with similar hooks that use debouncing or throttling.\n\nReturns a stateful value for the pending state of the transition, and a function to start it.\n\nlets you mark updates in the provided callback as transitions:\n\nindicates when a transition is active to show a pending state:\n\nis a hook for generating unique IDs that are stable across the server and client, while avoiding hydration mismatches.\n\nFor a basic example, pass the directly to the elements that need it:\n\nFor multiple IDs in the same component, append a suffix using the same :\n\nThe following Hooks are provided for library authors to integrate libraries deeply into the React model, and are not typically used in application code.\n\nis a hook recommended for reading and subscribing from external data sources in a way that’s compatible with concurrent rendering features like selective hydration and time slicing.\n\nThis method returns the value of the store and accepts three arguments:\n• : function to register a callback that is called whenever the store changes.\n• : function that returns the current value of the store.\n• : function that returns the snapshot used during server rendering.\n\nThe most basic example simply subscribes to the entire store:\n\nHowever, you can also subscribe to a specific field:\n\nWhen server rendering, you must serialize the store value used on the server, and provide it to . React will use this snapshot during hydration to prevent server mismatches:\n\nThe signature is identical to , but it fires synchronously before all DOM mutations. Use this to inject styles into the DOM before reading layout in . Since this hook is limited in scope, this hook does not have access to refs and cannot schedule updates."
    },
    {
        "link": "https://tanstack.com/query/latest/docs/framework/react/reference/useQuery",
        "document": "Does this replace [Redux, MobX, etc]?"
    },
    {
        "link": "https://refine.dev/blog/react-query-guide",
        "document": "This article was last updated on November 28, 2024 to add clear introduction to React query post.\n\nReact Query is a powerful library for fetching data and managing state in React applications. This library simplifies the interaction with APIs by providing caching, synchronization, and server state management out of the box. Some key features are as follows:\n• Data Caching: It will store the fetched data automatically and use it to avoid redundant API calls.\n• State Management: Does not require using manually maintained state handling like useEffect.\n\nImprove performance, develop responsive designs, and provide seamless user experiences without headaches with React Query.\n\nStep into the world of web development, where loading server data, handling errors, and keeping clients and servers in sync are all part of the exciting puzzle. But wait, there's more! Picture a scenario where poor internet connections add another layer of complexity. It's enough to make any developer's head spin.\n\nNow, imagine a solution that takes these challenges and turns them into a breeze. React Query as a solution helps in caching and server state management. Whether you're a seasoned developer or just starting your coding journey, React Query is a great option to try.\n\nThis beginner's guide aims to introduce you to React Query, its core concepts, and how to use it effectively in your projects. Whether you are new to React or an experienced developer looking to enhance your data fetching capabilities, this guide will provide you with a solid foundation to get started with React Query.\n\nCertain requirements must be met to follow up on this article;\n• React Query and Axios Installed on your computer\n\nIn the course of this article, we used Jsonplaceholder as our API endpoint, React Query and Axios to fetch, and handle server state data; below is a demonstration of how to install and set up React Query.\n\nNavigate to a React project and run the following in your terminal:\n\nNavigate to your file and paste the code below:\n\nWith this, your application is set to go!\n\nAt this point, you will wonder what exactly Google has got to do with React Query. React Query's core functionality revolves around fetching and caching data from an API and handling state management, while search engines like Google allow us to query and retrieve relevant information from an extensive database. Both React Query and Google aim to optimize data retrieval and improve user experiences.\n\nThe analogy between Google and React Query helps us understand how React Query works. When we query Google for information, it retrieves the best available information from its database. Similarly, React Query fetches data from an API endpoint like Google fetches information from its database.\n\nReact Query manages the state of this fetched data, similar to how Google handles the information it retrieves. React Query caches API responses, which stores the fetched data locally to reduce the need for subsequent fetches.\n\nLikewise, search engines like Google cache web pages to reduce latency when displaying search results. This caching mechanism improves performance and reduces the time to display the requested information.\n\nThis refers to the process of requesting specific information from a database or dataset using a query language. Queries are used to extract, filter, and manipulate data based on specific conditions and criteria.\n\nBy submitting a query, you can search for data that meets certain requirements. Now we see why there is a \"Query\" in \"React Query\" because this library is in charge of handling and making queries a breeze. Since we know what querying data means, let us perform basic data fetch with React Query.\n\nThe dominance of React Query over traditional state management tools like and others is that React Query comes with built-in query caching, which means, once data is fetched, it can be stored in a cache and reused later without making redundant API calls.\n\nReact Query also handles the state management of queries automatically, reducing the need for developers to write and maintain complex state management logic. It provides built-in error-handling capabilities, allowing developers to handle API errors gracefully.\n\nSince we now know why we should use React Query we can go further to know how to perform a basic data fetch with this library.\n\nReact Query has a way of handling server states, and it does that using the useQuery hook. This hook is used to fetch data from your API. It returns an object that contains the status of the query (loading, error, or success), the data returned from the query, and functions to refetch the data.\n\nTo see how this works we will be fetching a list of post titles from Jsonplaceholder API. Here's a basic example of how you might use React Query to fetch and manage server data:\n\nIn this example, fetches the posts. The hook is used to fetch data and handle loading and error states. The function fetches the data using Axios. If data is loading or an error occurs, a message is displayed. Otherwise, the posts are rendered as a list.\n\nWe can also notice caching is handled by the hook. When you call and pass it a key (in this case, 'postsData') and a fetch function ( ), React Query performs the fetch and then stores the result in a cache.\n\nThe key you provide ('postsData') is used as the identifier for this cache. If is called again with the same key while the data is still in the cache, React Query will return the cached data instead of performing a new fetch.\n\nWhen you run this on your browser you will get the list of post titles displayed.\n\nMutating data simply means we are changing something in the database, we could be posting, creating, or deleting something, whatever we choose to do we are still mutating.\n\nThis is what makes React Query a beautiful tool as it can be used to perform CRUD( Create, Read, Update, and Delete) operations. While the hook is used for \"read\" operations (fetching data), React Query provides the useMutation hook for \"write\" operations (creating, updating, and deleting data).\n\nUsing the hook for CRUD operation we need to note that the Json placeholder API doesn't actually store the created, updated, or deleted data. But to be sure the operation were made, it will either return a success statement or an error statement.\n\nCreate To Create a post using . Create a component and name it then you can paste the code below:\n\nIn the code above, is used to post new data to the Json Placeholder API. The function passed to is the mutation function. When is called with the new post data, the mutation is performed.\n\nThis is what it looks like in a Chrome browser:\n\nAfter feeling the options, click submit and wait for the response:\n\nUpdate We can go further to update posts. To do that, create a component named , then paste the code below:\n\nIn this code, We changed the call in the hook to to make a PUT request instead of a POST request.\n\nWe have also changed the URL to include the ID of the post to update (\"https://jsonplaceholder.typicode.com/posts/1\"). The rest of the code stays the same, and with this, we were able to update a post.\n\nDelete To be able to delete an already created post, a component named needs to be created. Fill free to copy the code below:\n\nIn order to delete a post we changed the call in the hook to to make a DELETE request instead of a POST request.\n\nWe also changed the URL to include the ID of the post to delete (\"https://jsonplaceholder.typicode.com/posts/1\").\n\nFollowing the steps above illustrates how best to use the hook and we can agree it makes the job much easier.\n\nReact-based framework like Refine has extended versions of the hooks provided by React Query. Refine extends the functionality of React Query's hooks, adding extra features and customization options to better suit data-intensive applications. These hooks include useUpdate and useList.\n\nThe hook in Refine is an extended version of the hook from React Query. This hook is used when you want to update a record. It uses the method as the mutation function from the that is passed to Refine.\n\nOn the other hand, the hook in Refine is an extended version of the hook from React Query. It is used when you need to fetch data according to sort, filter, pagination, etc., from a .\n\nIf you are in search of a framework that utilizes the power React query has got, Refine is an absolutely great choice as it solves issues concerning data querying and server state management complexity.\n\nLet's walk through some advanced querying techniques with React Query that can help us manage more complex data-fetching scenarios in our apps. These will allow us to handle cases such as pagination, infinite scrolling, and dependent queries more efficiently.\n\nPagination is a fundamental necessity for huge datasets. Paginating with React Query is very easy. We can query many pages of data from our server in the following way: we are passing in a query key while creating the query with the page number, meaning each page will be cached independently by React Query, and it will only be fetched when another request with a new page number comes for the data that is wanted.\n\nWe can define the option , which keeps the page's previous data while loading the new one.\n\nBy default, the infinite scrolling feature fetches more data as a user scrolls toward the end of the page. It works really well for social media feeds or item lists. Implementing the same in React Query by using the hook is rather simple. Our call with will be to fetch and append additional pages of data each time the user scrolls. This initializes our call, which will determine when to fire another fetch, in order to load more information onto those infinite pages.\n\nQueries become dependent when one query should be run based on data being fetched from another. React Query empowers us to do the same with the help of the configuration field. Now we can conditionally run our queries based on the results of others.\n\nFor instance, first fetching a user's detail before retrieving posts belonging to this user will have a query dependent upon the other one. This will make it fetch in the right order.\n\nSometimes we need to run multiple queries at the same time, even if they are not dependent on each other. It makes the process of performing parallel queries really simple, with little configuration being utilized when needing to do this with React Query. This allows us to run multiple queries at the same time for different sets of data, managing their loading and error states individually.\n\nReact Query enables us to do all the automatic behind-the-scenes refetching of data and then update the UI—so the user is never without the information, knowing that it's not in real time. In such a case, we could do things like small tweaks around the implementation with so our data remains fresh whenever a user focuses back into our window. This becomes very helpful for any applications for which there is key functionality needed for data consistency.\n\nIn this beginner's guide, we explored the world of React Query and its core concepts. We learned that React Query is a powerful tool for handling data fetching, caching, and state management in React applications.\n\nFrameworks like Refine extend the capabilities of React Query, offering a comprehensive solution for data-intensive applications. By leveraging React Query, developers can enhance the efficiency and user experience of their React projects. Thank you for reading!"
    },
    {
        "link": "https://github.com/TanStack/query/discussions/1558",
        "document": "To see all available qualifiers, see our documentation .\n\nSaved searches Use saved searches to filter your results more quickly\n\nWe read every piece of feedback, and take your input very seriously.\n\nYou signed in with another tab or window. Reload to refresh your session.\n\nYou signed out in another tab or window. Reload to refresh your session.\n\nYou switched accounts on another tab or window. Reload to refresh your session."
    },
    {
        "link": "https://tanstack.com/query/v4/docs/react/overview",
        "document": "TanStack Query (FKA React Query) is often described as the missing data-fetching library for web applications, but in more technical terms, it makes fetching, caching, synchronizing and updating server state in your web applications a breeze.\n\nMost core web frameworks do not come with an opinionated way of fetching or updating data in a holistic way. Because of this developers end up building either meta-frameworks which encapsulate strict opinions about data-fetching, or they invent their own ways of fetching data. This usually means cobbling together component-based state and side-effects, or using more general purpose state management libraries to store and provide asynchronous data throughout their apps.\n\nWhile most traditional state management libraries are great for working with client state, they are not so great at working with async or server state. This is because server state is totally different. For starters, server state:\n• Is persisted remotely in a location you do not control or own\n• Implies shared ownership and can be changed by other people without your knowledge\n• Can potentially become \"out of date\" in your applications if you're not careful\n\nOnce you grasp the nature of server state in your application, even more challenges will arise as you go, for example:\n• Caching... (possibly the hardest thing to do in programming)\n• Deduping multiple requests for the same data into a single request\n• Updating \"out of date\" data in the background\n• Knowing when data is \"out of date\"\n• Reflecting updates to data as quickly as possible\n\nIf you're not overwhelmed by that list, then that must mean that you've probably solved all of your server state problems already and deserve an award. However, if you are like a vast majority of people, you either have yet to tackle all or most of these challenges and we're only scratching the surface!\n\nReact Query is hands down one of the best libraries for managing server state. It works amazingly well out-of-the-box, with zero-config, and can be customized to your liking as your application grows.\n\nReact Query allows you to defeat and overcome the tricky challenges and hurdles of server state and control your app data before it starts to control you.\n\nOn a more technical note, React Query will likely:\n• Help you remove many lines of complicated and misunderstood code from your application and replace with just a handful of lines of React Query logic.\n• Make your application more maintainable and easier to build new features without worrying about wiring up new server state data sources\n• Have a direct impact on your end-users by making your application feel faster and more responsive than ever before.\n• Potentially help you save on bandwidth and increase memory performance\n\nIn the example below, you can see React Query in its most basic and simple form being used to fetch the GitHub stats for the React Query GitHub project itself:\n• Consider taking the official React Query Course (or buying it for your whole team!)\n• Learn React Query at your own pace with our amazingly thorough Walkthrough Guide and API Reference"
    },
    {
        "link": "https://daily.dev/blog/usequery-react-for-efficient-data-fetching",
        "document": "If you're diving into React and looking to manage data fetching efficiently, from React Query is a game-changer. It simplifies data fetching, caching, and synchronization, making your app responsive and up-to-date. Here's a quick rundown:\n• Background Updates: Keeps your app's data fresh without user intervention.\n• Developer Tools: Offers tools for debugging and optimizing your data fetching strategies.\n\nTo get started, install react-query, set up a QueryClient, and wrap your app with QueryClientProvider. Use in your components with a unique key and a fetch function. The hook handles the rest, from loading states to caching and updating the data.\n\nWhether you're fetching a todo list from an API or implementing a dynamic search feature, handles the heavy lifting, letting you focus on building a great user experience. It's perfect for apps that need real-time data without the hassle of manual data management.\n\nThe hook needs two main things to work:\n• queryKey (required): Think of this as a unique label for your query. It can be a simple string or an array. This label helps the system remember and reuse your query efficiently.\n• queryFn (required): This is the function that actually goes and gets your data. It should be an async function that fetches data and returns it.\n\nIn this example, is the unique label, and the function fetches data for user ID 5.\n\nYou can also tweak how works with a few options:\n• cacheTime: How long to keep data fresh even if it's not being used. Helps to not fetch data too often.\n• staleTime: How long before the fetched data is considered old. If it's old, it might fetch it again in the background.\n• refetchOnWindowFocus: Whether to get fresh data automatically when you come back to the window. Keeps data up-to-date.\n\ngives back an object with helpful info:\n• status: Tells you if it's loading, if there was an error, or if it's successful\n• isFetching: True if it's currently fetching data\n\nThis setup lets you manage loading screens, errors, and how to show your data in a simple way.\n\nHere's a simple way to get a list of tasks (todos) from an online service using in your React app. This example also shows how to deal with waiting for the data to load and handling any errors that might pop up:\n\nThis code neatly covers getting the data, showing a message while waiting, and dealing with errors. Once the data is fetched, it's ready to be shown.\n\nThis example shows how to set up a search feature in your React app where automatically looks for results based on what the user types:\n\nIn this setup, the search starts only when there's something typed in. The query updates and fetches new results whenever the search term changes.\n\nis really good at remembering data it has fetched before. So, if you ask for something it has already gotten, like a list of items, it won’t ask the server again but will give you the saved version. This makes your app quick for users.\n\nBut, if you always want the latest info, offers some cool features:\n• : This tells to get fresh data every few seconds.\n• : This makes get new data when someone comes back to the app after looking at something else.\n\nYou can also ask for new data whenever you want with .\n\nHere’s how you can set it to get new data every five minutes:\n\nThe cool thing is, does all this without making your app slow or showing loading screens all the time.\n\nYour app stays quick and keeps data up to date without users noticing much.\n\nWhen you need to show data in chunks, like a few items at a time, can help. Here’s a simple way to do it:\n• Your page number is part of the query key.\n• lets you keep seeing the old data until the new data is ready.\n• You can switch between the latest and the previously fetched data.\n\nThis makes handling pages simple without needing to juggle too much code.\n\nTo make your code easier to handle as your React app gets bigger, it's a good idea to sort your queries in a way that makes sense. You could start your user-related queries with \"user\", and ones about posts with \"post\", and so on. This method helps keep things tidy and makes your code easier to read. It also helps React Query do its job better in managing when to grab or refresh data.\n\nHere are some tips:\n• When naming your queries, using arrays can help you add more details like IDs.\n• Try to keep the names short but clear.\n• Make sure you're consistent in how you name them across your React JS project.\n\nDeciding how long to keep data and when to get new data is about finding a balance. You want your app to have the latest info without slowing it down. Here's what you can do:\n\nFor data that changes a lot, like stock prices:\n\nThis way, your app gets updates without you having to do much.\n\nFor data that doesn't change much, like blog posts:\n• You can keep it in the cache longer by increasing\n• Set a longer so it doesn't check for updates too often\n\nThis reduces the number of times your app needs to ask for data, which can help it run smoother.\n\nFor data that's different for each user, like profiles:\n• Use shorter times for both and\n\nThis means the app will check for updates when someone comes back to it, keeping things fresh.\n\nUsing React Query Devtools to watch how your queries work can help you adjust these settings for each type of data. Getting this right can make your app faster and ensure it always has up-to-date information.\n\nWhen you're working with React Query in your React applications, sometimes things don't go as planned. Here's how you can figure out what's going wrong and fix it.\n\nReact Query Devtools are super helpful for seeing what's happening with your queries:\n• Query Inspection: You can see all sorts of details like what queries are running, if they're working or stuck, and what data you're getting back. This is great for spotting problems.\n• Query Profiling: This feature lets you see how fast your queries are running and how much data they're using. It's useful for finding queries that are slowing things down.\n• Mutation Tracking: It also shows you how changes (mutations) in your data affect your queries, like causing them to fetch data again.\n\nAdding Devtools to your project early on can really help you keep an eye on your queries and fix issues fast.\n\nAnother way to figure out what's going wrong is by adding logs to your queries. Here's an example:\n• will print out errors if something goes wrong.\n• tells you when the query has finished, regardless of whether it was successful or not.\n• You can also add logs in your components to see what's happening when data is loading or when there's an error.\n\nAdding these logs helps you see exactly where things are going off track, without making your code complicated.\n\nThe hook from React Query makes fetching data in React apps a lot easier. This article covered how it helps automatically handle data fetching, caching, and updating. Let's quickly go over the main points:\n• Setting up queries: It's about telling what data you need by giving each query a unique name and a way to fetch that data.\n• Dealing with data: makes it simple to manage loading, errors, and displaying the fetched data.\n\nWe looked at examples like getting a todo list from an API and creating a search feature that reacts to user input. These show how can handle different data fetching needs.\n\nalso has advanced features for better performance, like smart caching and updating data in the background. Adjusting these settings helps make your app faster and keeps the data fresh.\n\nFor more complicated tasks, supports things like loading data in pages or based on other queries. Plus, its Devtools help you spot and fix problems by showing you how your queries are doing in real-time.\n\nWhile does a lot of the heavy lifting, it's still important to organize your queries well and use the right settings for caching and updating data. This ensures your app works smoothly.\n\nIn short, is a great tool for any React developer. It simplifies dealing with data, so you can focus more on building cool features for your app. As apps get more interactive and data-driven, is becoming a key tool for creating better user experiences with less hassle.\n\nHow do you optimize data fetching in react?\n\nUsing React 18 for Better Data Fetching\n\nReact 18 lets your components start getting data without stopping the rest of your app from working. This means users can still use your app while it's fetching new data.\n\nHere are some smart ways to fetch data in React apps:\n• Use tools like React Query or SWR for smart data saving and updating.\n• Turn on Concurrent Mode and Suspense with React 18.\n• Only load parts of your app when needed to avoid asking for too much data at once.\n• Break down data requests into smaller parts instead of getting everything at once.\n• Wait a bit before making search requests or similar actions to prevent asking for the same thing multiple times.\n• Get data ready ahead of time if you know you'll need it soon.\n\nWhat is the best way to fetch data in react JS?\n\nHere's how to get data in React:\n• React Query or SWR - These tools help manage data saving, avoid asking for the same data too much, and update data quietly.\n• useEffect hook - Use this to get data after your component is ready and keep it in the app's state.\n• Custom Hooks - Make your own hooks to reuse the data-fetching logic.\n• React Suspense + Fetch - Use Suspense to handle loading or errors when fetching data.\n• Axios - A handy tool for making web requests from your app or browser.\n\nReact Query and SWR are becoming popular, while useEffect and Suspense give you more control.\n\nHow do you use react query for fetching data?\n\nGetting data with React Query is easy. Here's a quick guide:\n• Data is ready in the 'data' variable.\n• Components update by themselves when data changes.\n\nThis tool takes care of the tricky parts of getting data, so you can focus on your app's look.\n\nWhen should we use useQuery?\n\nUse the useQuery hook from React Query for:\n• Saving data - Automatically saves data to avoid asking for it again.\n• Updating data in the background - Keeps your data fresh without interrupting the user.\n• Sharing data between components - Uses a central place to keep data so every part of your app can access it.\n• Showing loading and error messages - Tells you when it's getting data or if something went wrong.\n• Getting data ready before you need it - Starts fetching data before it's actually needed.\n\nIn short, useQuery is a helpful tool for dealing with web data in React apps, making things simpler for you.\n• React 19: Everything you need to know in one place"
    },
    {
        "link": "https://tanstack.com/query/latest/docs/framework/react/overview",
        "document": "TanStack Query (FKA React Query) is often described as the missing data-fetching library for web applications, but in more technical terms, it makes fetching, caching, synchronizing and updating server state in your web applications a breeze.\n\nMost core web frameworks do not come with an opinionated way of fetching or updating data in a holistic way. Because of this developers end up building either meta-frameworks which encapsulate strict opinions about data-fetching, or they invent their own ways of fetching data. This usually means cobbling together component-based state and side-effects, or using more general purpose state management libraries to store and provide asynchronous data throughout their apps.\n\nWhile most traditional state management libraries are great for working with client state, they are not so great at working with async or server state. This is because server state is totally different. For starters, server state:\n• Is persisted remotely in a location you may not control or own\n• Implies shared ownership and can be changed by other people without your knowledge\n• Can potentially become \"out of date\" in your applications if you're not careful\n\nOnce you grasp the nature of server state in your application, even more challenges will arise as you go, for example:\n• Caching... (possibly the hardest thing to do in programming)\n• Deduping multiple requests for the same data into a single request\n• Updating \"out of date\" data in the background\n• Knowing when data is \"out of date\"\n• Reflecting updates to data as quickly as possible\n\nIf you're not overwhelmed by that list, then that must mean that you've probably solved all of your server state problems already and deserve an award. However, if you are like a vast majority of people, you either have yet to tackle all or most of these challenges and we're only scratching the surface!\n\nReact Query is hands down one of the best libraries for managing server state. It works amazingly well out-of-the-box, with zero-config, and can be customized to your liking as your application grows.\n\nReact Query allows you to defeat and overcome the tricky challenges and hurdles of server state and control your app data before it starts to control you.\n\nOn a more technical note, React Query will likely:\n• Help you remove many lines of complicated and misunderstood code from your application and replace with just a handful of lines of React Query logic.\n• Make your application more maintainable and easier to build new features without worrying about wiring up new server state data sources\n• Have a direct impact on your end-users by making your application feel faster and more responsive than ever before.\n• Potentially help you save on bandwidth and increase memory performance\n\nIn the example below, you can see React Query in its most basic and simple form being used to fetch the GitHub stats for the React Query GitHub project itself:\n• Consider taking the official React Query Course (or buying it for your whole team!)\n• Learn React Query at your own pace with our amazingly thorough Walkthrough Guide and API Reference"
    },
    {
        "link": "https://refine.dev/blog/react-query-guide",
        "document": "This article was last updated on November 28, 2024 to add clear introduction to React query post.\n\nReact Query is a powerful library for fetching data and managing state in React applications. This library simplifies the interaction with APIs by providing caching, synchronization, and server state management out of the box. Some key features are as follows:\n• Data Caching: It will store the fetched data automatically and use it to avoid redundant API calls.\n• State Management: Does not require using manually maintained state handling like useEffect.\n\nImprove performance, develop responsive designs, and provide seamless user experiences without headaches with React Query.\n\nStep into the world of web development, where loading server data, handling errors, and keeping clients and servers in sync are all part of the exciting puzzle. But wait, there's more! Picture a scenario where poor internet connections add another layer of complexity. It's enough to make any developer's head spin.\n\nNow, imagine a solution that takes these challenges and turns them into a breeze. React Query as a solution helps in caching and server state management. Whether you're a seasoned developer or just starting your coding journey, React Query is a great option to try.\n\nThis beginner's guide aims to introduce you to React Query, its core concepts, and how to use it effectively in your projects. Whether you are new to React or an experienced developer looking to enhance your data fetching capabilities, this guide will provide you with a solid foundation to get started with React Query.\n\nCertain requirements must be met to follow up on this article;\n• React Query and Axios Installed on your computer\n\nIn the course of this article, we used Jsonplaceholder as our API endpoint, React Query and Axios to fetch, and handle server state data; below is a demonstration of how to install and set up React Query.\n\nNavigate to a React project and run the following in your terminal:\n\nNavigate to your file and paste the code below:\n\nWith this, your application is set to go!\n\nAt this point, you will wonder what exactly Google has got to do with React Query. React Query's core functionality revolves around fetching and caching data from an API and handling state management, while search engines like Google allow us to query and retrieve relevant information from an extensive database. Both React Query and Google aim to optimize data retrieval and improve user experiences.\n\nThe analogy between Google and React Query helps us understand how React Query works. When we query Google for information, it retrieves the best available information from its database. Similarly, React Query fetches data from an API endpoint like Google fetches information from its database.\n\nReact Query manages the state of this fetched data, similar to how Google handles the information it retrieves. React Query caches API responses, which stores the fetched data locally to reduce the need for subsequent fetches.\n\nLikewise, search engines like Google cache web pages to reduce latency when displaying search results. This caching mechanism improves performance and reduces the time to display the requested information.\n\nThis refers to the process of requesting specific information from a database or dataset using a query language. Queries are used to extract, filter, and manipulate data based on specific conditions and criteria.\n\nBy submitting a query, you can search for data that meets certain requirements. Now we see why there is a \"Query\" in \"React Query\" because this library is in charge of handling and making queries a breeze. Since we know what querying data means, let us perform basic data fetch with React Query.\n\nThe dominance of React Query over traditional state management tools like and others is that React Query comes with built-in query caching, which means, once data is fetched, it can be stored in a cache and reused later without making redundant API calls.\n\nReact Query also handles the state management of queries automatically, reducing the need for developers to write and maintain complex state management logic. It provides built-in error-handling capabilities, allowing developers to handle API errors gracefully.\n\nSince we now know why we should use React Query we can go further to know how to perform a basic data fetch with this library.\n\nReact Query has a way of handling server states, and it does that using the useQuery hook. This hook is used to fetch data from your API. It returns an object that contains the status of the query (loading, error, or success), the data returned from the query, and functions to refetch the data.\n\nTo see how this works we will be fetching a list of post titles from Jsonplaceholder API. Here's a basic example of how you might use React Query to fetch and manage server data:\n\nIn this example, fetches the posts. The hook is used to fetch data and handle loading and error states. The function fetches the data using Axios. If data is loading or an error occurs, a message is displayed. Otherwise, the posts are rendered as a list.\n\nWe can also notice caching is handled by the hook. When you call and pass it a key (in this case, 'postsData') and a fetch function ( ), React Query performs the fetch and then stores the result in a cache.\n\nThe key you provide ('postsData') is used as the identifier for this cache. If is called again with the same key while the data is still in the cache, React Query will return the cached data instead of performing a new fetch.\n\nWhen you run this on your browser you will get the list of post titles displayed.\n\nMutating data simply means we are changing something in the database, we could be posting, creating, or deleting something, whatever we choose to do we are still mutating.\n\nThis is what makes React Query a beautiful tool as it can be used to perform CRUD( Create, Read, Update, and Delete) operations. While the hook is used for \"read\" operations (fetching data), React Query provides the useMutation hook for \"write\" operations (creating, updating, and deleting data).\n\nUsing the hook for CRUD operation we need to note that the Json placeholder API doesn't actually store the created, updated, or deleted data. But to be sure the operation were made, it will either return a success statement or an error statement.\n\nCreate To Create a post using . Create a component and name it then you can paste the code below:\n\nIn the code above, is used to post new data to the Json Placeholder API. The function passed to is the mutation function. When is called with the new post data, the mutation is performed.\n\nThis is what it looks like in a Chrome browser:\n\nAfter feeling the options, click submit and wait for the response:\n\nUpdate We can go further to update posts. To do that, create a component named , then paste the code below:\n\nIn this code, We changed the call in the hook to to make a PUT request instead of a POST request.\n\nWe have also changed the URL to include the ID of the post to update (\"https://jsonplaceholder.typicode.com/posts/1\"). The rest of the code stays the same, and with this, we were able to update a post.\n\nDelete To be able to delete an already created post, a component named needs to be created. Fill free to copy the code below:\n\nIn order to delete a post we changed the call in the hook to to make a DELETE request instead of a POST request.\n\nWe also changed the URL to include the ID of the post to delete (\"https://jsonplaceholder.typicode.com/posts/1\").\n\nFollowing the steps above illustrates how best to use the hook and we can agree it makes the job much easier.\n\nReact-based framework like Refine has extended versions of the hooks provided by React Query. Refine extends the functionality of React Query's hooks, adding extra features and customization options to better suit data-intensive applications. These hooks include useUpdate and useList.\n\nThe hook in Refine is an extended version of the hook from React Query. This hook is used when you want to update a record. It uses the method as the mutation function from the that is passed to Refine.\n\nOn the other hand, the hook in Refine is an extended version of the hook from React Query. It is used when you need to fetch data according to sort, filter, pagination, etc., from a .\n\nIf you are in search of a framework that utilizes the power React query has got, Refine is an absolutely great choice as it solves issues concerning data querying and server state management complexity.\n\nLet's walk through some advanced querying techniques with React Query that can help us manage more complex data-fetching scenarios in our apps. These will allow us to handle cases such as pagination, infinite scrolling, and dependent queries more efficiently.\n\nPagination is a fundamental necessity for huge datasets. Paginating with React Query is very easy. We can query many pages of data from our server in the following way: we are passing in a query key while creating the query with the page number, meaning each page will be cached independently by React Query, and it will only be fetched when another request with a new page number comes for the data that is wanted.\n\nWe can define the option , which keeps the page's previous data while loading the new one.\n\nBy default, the infinite scrolling feature fetches more data as a user scrolls toward the end of the page. It works really well for social media feeds or item lists. Implementing the same in React Query by using the hook is rather simple. Our call with will be to fetch and append additional pages of data each time the user scrolls. This initializes our call, which will determine when to fire another fetch, in order to load more information onto those infinite pages.\n\nQueries become dependent when one query should be run based on data being fetched from another. React Query empowers us to do the same with the help of the configuration field. Now we can conditionally run our queries based on the results of others.\n\nFor instance, first fetching a user's detail before retrieving posts belonging to this user will have a query dependent upon the other one. This will make it fetch in the right order.\n\nSometimes we need to run multiple queries at the same time, even if they are not dependent on each other. It makes the process of performing parallel queries really simple, with little configuration being utilized when needing to do this with React Query. This allows us to run multiple queries at the same time for different sets of data, managing their loading and error states individually.\n\nReact Query enables us to do all the automatic behind-the-scenes refetching of data and then update the UI—so the user is never without the information, knowing that it's not in real time. In such a case, we could do things like small tweaks around the implementation with so our data remains fresh whenever a user focuses back into our window. This becomes very helpful for any applications for which there is key functionality needed for data consistency.\n\nIn this beginner's guide, we explored the world of React Query and its core concepts. We learned that React Query is a powerful tool for handling data fetching, caching, and state management in React applications.\n\nFrameworks like Refine extend the capabilities of React Query, offering a comprehensive solution for data-intensive applications. By leveraging React Query, developers can enhance the efficiency and user experience of their React projects. Thank you for reading!"
    },
    {
        "link": "https://builtin.com/software-engineering-perspectives/use-query-react",
        "document": "React Query, or TanStack Query, is a library that gives React JS the state management ability for any kind of asynchronous data. According to its official documentation, “React Query is often described as the missing data-fetching library for web applications, but in more technical terms, it makes fetching, caching, synchronizing and updating server state in your web applications a breeze.”\n\nis a custom hook within React Query used to fetch data in a React application. Under the hood, these hooks manage lots of things such as caching data after the initial fetch, re-fetching data in the background, etc.\n\nIn this article, I’m going to show you how to fetch data using the hook. To do so, I’ll be using a JSON placeholder as an API endpoint to fetch data.\n\nLet’s start with creating a new React JS project using Create React App and install the :\n\nThen, we’ll clean the App.js and write the function to fetch data from the API. I’m using , but we can use Axios or other methods, as well.\n\nNow, import the from .\n\nMore on Software Engineering: Starting Out in Software Engineering? Don’t Bother Learning React JS.\n\nHow to Fetch Data With UseQuery\n\nAnd now we can use hook to manage the data fetching, as below:\n\nA hook requires two arguments. The first one is a key for the query. I’m using the string for that. We can also put an array as the first argument. If an array is passed, each item will be serialized into a stable query key. The second one is a function to fetch the data. I put the asynchronous function I created earlier. We can also pass an object as the third argument for different options, but that’s optional.\n\nThe response useQuery returns is really important. It contains the following properties.\n\nis the actual data we fetched, and status will either be , , or , according to the response. And all these properties have different uses. Refer to the official documentation for more information about the useQuery hook.\n\nFor example, let’s use only the and properties. So we’ll deconstruct the useQuery response:\n\nNow, we can use to display them in the browser. Here is the complete code:\n\nWhat we’ve done here is checked the status and displayed the data. This is a simple explanation of how we can use the React Query hook. There are many other hooks as well.\n\nMore on Software Engineering: JSON vs. YAML: A Dive Into 2 Popular Data Serialization Languages\n\nI used to use Redux or Context API for the state management in a React JS project. But React Query is more powerful and popular among the developer community. I recommend all React developers to try it."
    }
]