[
    {
        "link": "https://stackoverflow.com/questions/15941996/dump-json-into-yaml",
        "document": "I got a file (named it ) like this:\n\nI would like to convert it to a file (named it ) like :\n\nWhat I have done was :\n\nBut sadly, what I got is following:"
    },
    {
        "link": "https://crumb.sh/CjAnBJVynyU",
        "document": "If you need to convert JSON to YAML, you can simply parse the JSON with the built-in JSON library. In the next step, you can use the PyYAML module to convert the object to YAML. In this example, we open a JSON-based configuration file, parse it with the library, and then write it to a YAML file with the PyYAML module. Finally, I added a load and print to prove everything worked. Edit and run this Python 3 example code This code is editable and runnable. You can run \"Convert JSON to YAML using Python\" by pressing the run button. It will be executed in our backend and the result ( and ) is displayed in addition tabs.\n\nShare this crumb (Convert JSON to YAML using Python) with your friends and colleagues to help them learn more about Python 3 programming. On Twitter, Facebook, and LinkedIn, simply paste the URL in your post and watch the magic unfold. If you want to embed the crumb in an iframe, use the following code: We support oEmbed, but most sites use allowlisting. On WordPress, oEmbed is supported out of the box, but see the note below. If you plan to use crumb.sh heavily on Wordpress, you can use the following PHP code to allowlist our site and unlock all the functionalities of our crumbs: \n\n Embed.ly is a service that allows you to embed content from other sites. We will request to be added to the list of trusted sites once we're out of beta."
    },
    {
        "link": "https://stackoverflow.com/questions/55808945/json-to-yaml-in-python-how-to-get-correct-string-manipulation",
        "document": "I'm using the PyYAML library to convert json to yaml. But quotation marks are removed from string values when they should not be. They should only be removed from keys.\n\nI have used the default_flow_style option with the yaml dump function as illustrated below :\n\nWhen the desired result is :"
    },
    {
        "link": "https://python.land/data-processing/python-yaml",
        "document": "YAML, a recursive acronym for “YAML Ain’t Markup Language,” is a human-readable data serialization language. It is often used for configuration files but also for data exchange. The most used python YAML parser is PyYAML, a library that allows you to load, parse, and write YAML, much like Python’s JSON library helps you to work with JSON.\n\nThis article teaches you how to load, read, and write YAML files with PyYAML. In addition, you’ll learn how to install it on your system and how YAML compares to alternatives like JSON.\n\nAccording to the official site(1), YAML is a human-friendly data serialization language for all programming languages. YAML is most often used for configuration files, but it’s also used for data exchange.\n\nYAML is easy to write and read for humans, even for non-programmers. At the same time, it’s also easy to parse YAML, especially with Python and the PyYAML library! Its human-friendliness and readability is YAML’s biggest advantage over other formats, like JSON and XML.\n\nThese are the most prominent features of YAML:\n• You can use comments in YAML files\n• You can store multiple documents in one YAML file with the separator. A feature often used in Kubernetes definitions.\n\n1) Fun fact: the official YAML website is written as valid YAML files.\n\nWhy use YAML with Python?\n\nIf you ask me, YAML is perfect for configuration files. That’s exactly how I, and many other developers, use it the most. Others seem to agree, as many large projects, like Docker and Kubernetes, use YAML to define deployments. It has a richer syntax than the often used alternative, .ini files, but is still nice on the eyes and simple to write and parse.\n\nThere are some downsides to using YAML with Python, too:\n• YAML is not part of the standard Python library, while XML and JSON are\n• Its dependence on indentation is frustrating sometimes (however, Python developers are used to that, right?)\n• It’s perhaps too versatile for simple use cases, like data exchange of simple objects.\n\nIf you’re looking for a suitable data format for data exchange and storage, I recommend JSON, XML, or other more efficient formats like protocol buffers and Avro.\n\nMultiple Python packages can parse YAML data. However, PyYAML is the most prevalent and complete implementation for parsing YAML. PyYAML is not part of the standard Python library, meaning you must install it with Pip. Use the following command to install PyYAML, preferably in a virtual environment:\n\nOn some systems, you need to use pip3:\n\nTo use PyYAML in your scripts, import the module as follows. Note that you don’t import , but simply :\n\nOnce we have the YAML parser imported, we can load a YAML file and parse it. YAML files usually carry the extension or . Let’s work with the following example YAML file called :\n\nLoading, parsing, and using this configuration file is similar to loading JSON with the Python JSON library. First, we open the file. Next, we parse it with the function. Please note that I changed the output a little to make it more readable for you:\n\nThe YAML parser returns a regular Python object that best fits the data. In this case, it’s a Python dictionary. This means all the regular dictionary features can be used, like using with a default value.\n\nHere’s the same example, but interactive, so you can experiment with this for yourself:\n\nYou can use to parse all kinds of valid YAML strings. Here’s an example that parses a simple list of items into a Python list:\n\nYAML allows you to define multiple documents in one file, separating them with a triple dash ( ). PyYAML will happily parse such files and return a list of documents. You can do so by using the yaml.safe_load_all() function. This function returns a generator that in turn will return all documents one by one.\n\nNote that the file needs to be opened as long as you’re reading documents from the YAML, so you must process the file within the clause. Here’s an interactive example that demonstrates this function:\n\nAlthough most will only read YAML as a configuration file, it can also be very handy to write YAML as well. Example use cases could be:\n• Create an initial configuration file with current settings for your user\n• To save state of your program in an easy to read file (instead of using something like Pickle)\n\nIn the following example, we’ll:\n• Create a list with names as we did before\n• Save the names to a YAML formatted file with\n• Read and print the file, as proof that everything worked as expected\n\nHere you go:\n\nHere’s the same code as a non-interactive example:\n\nIf you need to convert YAML to JSON, you can parse the YAML as we did above. In the next step, you can use the JSON module to convert the object to JSON.\n\nIn this example, we open a YAML-based configuration file, parse it with PyYAML, and then write it to a JSON file with the JSON module:\n\nHere’s the same code as a non-interactive example:\n\nFor the sake of completeness, let’s do the reverse, too: convert JSON to YAML:\n\nYou will encounter many examples of PyYAML usage where is used instead of . I intentionally didn’t tell you about the function until now. Since most people have a job to do and tend to copy-paste some example code quickly, I wanted them to use the safest method of parsing YAML with Python.\n\nHowever, if you’re curious about the difference between these two, here’s the summary: is a dangerously powerful function, just like pickle, if you know that function. Both are insecure methods because they allow an attacker to execute arbitrary code. PyYAML’s load function allows you to serialize and deserialize complete Python objects and even execute Python code, including calls to the library, which can execute any command on your system.\n\nIn recent PyYAML versions, the function is deprecated and will issue a big fat warning when you use it in an insecure way.\n\nIf you’re parsing regular YAML files, like 99% of us do, you should always use , since it only contains a subset of the load function. All the scary, arbitrary code execution type of stuff is stripped out.\n\nHere are some resources that you might want to continue with:\n• How to open, read, and write files with Python"
    },
    {
        "link": "https://pythonforbeginners.com/basics/convert-json-to-yaml-in-python",
        "document": "Different software uses different file formats for storing and transmitting data. Hence, we often need to convert data from one format to another. This article will discuss how we can convert JSON to YAML in python.\n\nJSON (JavaScript Object Notation) is a lightweight data interchange format. It is easy for humans to read and write and for machines to parse and generate. The JSON format is based on a subset of the JavaScript Programming Language, Standard ECMA-262 3rd Edition – December 1999.\n\nIn JSON, attributes and their values are represented as key-value pairs just like a python dictionary. The keys and values are separated by a colon and enclosed in curly braces. Nested attributes are represented as nested key-value pairs. The data structure is easy to read and understand, making JSON a popular format for data exchange and storage.\n\nA simple JSON file with nested attributes looks as follows.\n\nIn this example, the employee attribute has several nested attributes, such as name, age, job, and address. The job attribute has further nested attributes, including title, department, and years_of_experience.\n\nYAML (Yet Another Markup Language) is a human-readable data serialization language used to store and transmit data. It is commonly used for configuration files, data exchange between languages and platforms, and software development.\n\nWe can represent the JSON data shown in the previous example using YAML as shown below.\n\nThe YAML syntax uses indentation to show the relationship between the attributes, making it easy to understand the structure of the data.\n\nTo convert a JSON string to a YAML string, we will first convert the json string to a python dictionary using the method defined in the json module. The method takes a json string as its input argument and returns a python dictionary after execution.\n\nOnce we get the dictionary, we can convert it to a YAML string using the method defined in the yaml module. The method takes the python dictionary as its input argument and returns the YAML string as shown in the following example.\n\nYou can also convert a JSON string to a YAML file. For this, you can use the method defined in the yaml module as shown below.\n\nIn this example, we first opened a YAML file in write mode. Then, we passed the file pointer to the method as its second input argument. Hence, the method saves the data into the files instead of returning a string.\n\nAfter execution of the above code, the output file looks as follows.\n\nTo convert a JSON file to YAML, we will use the following steps.\n• First, we will open the JSON file in read mode using the function. The function takes the file name of the json file as its input argument and returns a file pointer.\n• Next, we will load the json file to a python dictionary using the method defined in the json module. The method takes the file pointer of the json file as its input argument and returns a python dictionary.\n• Once we get the dictionary, we can convert it to a YAML string using the method defined in the yaml module. The method takes the python dictionary as its input argument and returns the YAML string.\n\nYou can observe this in the following example.\n\nTo convert a JSON file to a YAML file, you can use the method as shown below.\n\nTo convert JSON to YAML online, you can use jsontoyaml.com.\n\nIn this article, we have discussed different ways to convert a JSON file or string to YAML in python. To learn more about python programming, you can read this article on how to convert a dictionary to json in Python. You might also like this article on working with JSON files in Python.\n\nI hope you enjoyed reading this article. Stay tuned for more informative articles."
    },
    {
        "link": "https://pyyaml.org/wiki/PyYAMLDocumentation",
        "document": "PyYAML is a YAML parser and emitter for Python.\n\nTo install from source, download the source package PyYAML-5.1.tar.gz and unpack it. Go to the directory PyYAML-5.1 and run:\n\nIf you want to use LibYAML bindings, which are much faster than the pure Python version, you need to download and install LibYAML. Then you may build and install the bindings by executing\n\nIn order to use LibYAML based parser and emitter, use the classes and . For instance,\n\nNote that there are some subtle (but not really significant) differences between pure Python and LibYAML based parsers and emitters.\n\nDictionaries without nested collections are not dumped correctly\n\nIt’s a correct output despite the fact that the style of the nested mapping is different.\n\nBy default, PyYAML chooses the style of a collection depending on whether it has nested collections. If a collection has nested collections, it will be assigned the block style. Otherwise it will have the flow style.\n\nIf you want collections to be always serialized in the block style, set the parameter of to . For instance,\n\nStarting from the 3.08 release, PyYAML and LibYAML bindings provide a complete support for Python 3. This is a short outline of differences in PyYAML API between Python 2 and Python 3 versions.\n• objects are converted into , or nodes depending on whether the object is an ASCII, UTF-8 or binary string.\n• objects are converted into or nodes depending on whether the object is an ASCII string or not.\n• produces a object in the specified encoding.\n• For compatibility reasons, and tags are still supported and the corresponding nodes are converted to objects.\n• produces a object in the specified encoding.\n\nWarning: It is not safe to call with any data received from an untrusted source! is as powerful as and so may call any Python function. Check the function though.\n\naccepts a byte string, a Unicode string, an open binary file object, or an open text file object. A byte string or a file must be encoded with utf-8, utf-16-be or utf-16-le encoding. detects the encoding by checking the BOM (byte order mark) sequence at the beginning of the string/file. If no BOM is present, the utf-8 encoding is assumed.\n\nIf a string or a file contains several documents, you may load them all with the function.\n\nPyYAML allows you to construct a Python object of any type.\n\nEven instances of Python classes can be constructed using the tag.\n\nNote that the ability to construct an arbitrary Python object may be dangerous if you receive a YAML document from an untrusted source such as the Internet. The function limits this ability to simple Python objects like integers or lists.\n\nA python object can be marked as safe and thus be recognized by . To do this, derive it from (as explained in section Constructors, representers, resolvers) and explicitly set its class property to .\n\naccepts the second optional argument, which must be an open text or binary file. In this case, will write the produced YAML document into the file. Otherwise, returns the produced document.\n\nIf you need to dump several YAML documents to a single stream, use the function . accepts a list or a generator producing\n\nPython objects to be serialized into a YAML document. The second optional argument is an open file.\n\nYou may even dump instances of Python classes.\n\nsupports a number of keyword arguments that specify formatting details for the emitter. For instance, you may set the preferred intendation and width, use the canonical YAML format or force preferred style for scalars and collections.\n\nYou may define your own application-specific tags. The easiest way to do it is to define a subclass of :\n\nThe above definition is enough to automatically load and dump objects:\n\nuses metaclass magic to register a constructor, which transforms a YAML node to a class instance, and a representer, which serializes a class instance to a YAML node.\n\nIf you don’t want to use metaclasses, you may register your constructors and representers using the functions and . For instance, you may want to add a constructor and a representer for the following class:\n\nThe default representation for objects is not pretty:\n\nSuppose you want a object to represented as in YAML:\n\nFirst we define a representer that converts a dice object to a scalar node with the tag , then we register it.\n\nNow you may dump an instance of the object:\n\nLet us add the code to construct a Dice object:\n\nThen you may load a object as well:\n\nYou might not want to specify the tag everywhere. There is a way to teach PyYAML that any untagged plain scalar which looks like XdY has the implicit tag . Use :\n\nNow you don’t have to specify the tag to define a object:\n\nA good introduction to the YAML syntax is Chapter 2 of the YAML specification.\n\nYou may also check the YAML cookbook. Note that it is focused on a Ruby implementation and uses the old YAML 1.0 syntax.\n\nHere we present most common YAML constructs together with the corresponding Python objects.\n\nYAML stream is a collection of zero or more documents. An empty stream contains no documents. Documents are separated with . Documents may optionally end with . A single document may or may not be marked with .\n\nExample of an implicit document:\n\nExample of an explicit document:\n\nExample of several documents in the same stream:\n\nIn the block context, sequence entries are denoted by (dash then space):\n\nIt’s not necessary to start a nested sequence with a new line:\n\nA block sequence may be nested to a block mapping. Note that in this case it is not necessary to indent the sequence.\n\nIn the block context, keys and values of mappings are separated by (colon then space):\n\nComplex keys are denoted with (question mark then space):\n\nA block mapping may be nested in a block sequence:\n\nThe syntax of flow collections in YAML is very close to the syntax of list and dictionary constructors in Python:\n\nThere are 5 styles of scalars in YAML: plain, single-quoted, double-quoted, literal, and folded:\n\nEach style has its own quirks. A plain scalar does not use indicators to denote its start and end, therefore it’s the most restricted style. Its natural applications are names of attributes and parameters.\n\nUsing single-quoted scalars, you may express any value that does not contain special characters. No escaping occurs for single quoted scalars except that a pair of adjacent quotes is replaced with a lone single quote .\n\nDouble-quoted is the most powerful style and the only style that can express any scalar value. Double-quoted scalars allow escaping. Using escaping sequences and , you may express any ASCII or Unicode character.\n\nThere are two kind of block scalar styles: literal and folded. The literal style is the most suitable style for large block of text such as source code. The folded style is similar to the literal style, but two adjacent non-empty lines are joined to a single line separated by a space character.\n\nNote that PyYAML does not yet support recursive objects.\n\nUsing YAML you may represent objects of arbitrary graph-like structures. If you want to refer to the same object from different parts of a document, you need to use anchors and aliases.\n\nAnchors are denoted by the indicator while aliases are denoted by ``. For instance, the document\n\nexpresses the idea of a hero holding a heavy sword in both hands.\n\nPyYAML now fully supports recursive objects. For instance, the document\n\nwill produce a list object containing a reference to itself.\n\nTags are used to denote the type of a YAML node. Standard YAML tags are defined at http://yaml.org/type/index.html.\n\nPlain scalars without explicitly defined tags are subject to implicit tag resolution. The scalar value is checked against a set of regular expressions and if one of them matches, the corresponding tag is assigned to the scalar. PyYAML allows an application to add custom implicit tag resolvers.\n\nThe following table describes how nodes with different tags are converted to Python objects.\n\nThere are four tags that are converted to and values: , , , and .\n\n-tagged scalars are converted to objects if its value is ASCII. Otherwise it is converted to . -tagged scalars are converted to objects with its value decoded using the base64 encoding. scalars are converted to objects encoded with utf-8 encoding. scalars are converted to objects.\n\nConversely, a object is converted to 1. a scalar if its value is ASCII. 2. a scalar if its value is a correct utf-8 sequence. 3. a scalar otherwise.\n\nA object is converted to 1. a scalar if its value is ASCII. 2. a scalar otherwise.\n\nIn Python 3, objects are converted to scalars and objects to scalars. For compatibility reasons, tags and are still supported and converted to objects.\n\nIn order to represent static Python objects like functions or classes, you need to use a complex tag. For instance, the function can be represented as\n\nSimilarly, modules are represented using the tag :\n\nAny pickleable object can be serialized using the tag:\n\nIn order to support the pickle protocol, two additional forms of the tag are provided:\n\nIf only the field is non-empty, the above records can be shortened:\n\nscans the given and produces a sequence of tokens.\n\nparses the given and produces a sequence of parsing events.\n\nserializes the given sequence of parsing and writes them to the . if is , it returns the produced stream.\n\nparses the given and returns the root of the representation graph for the first document in the stream. If there are no documents in the stream, it returns .\n\nparses the given and returns a sequence of representation graphs corresponding to the documents in the stream.\n\nserializes the given representation graph into the . If is , it returns the produced stream.\n\nserializes the given sequence of representation graphs into the given . If is , it returns the produced stream.\n\nparses the given and returns a Python object constructed from for the first document in the stream. If there are no documents in the stream, it returns .\n\nparses the given and returns a sequence of Python objects corresponding to the documents in the stream.\n\nparses the given and returns a Python object constructed from for the first document in the stream. If there are no documents in the stream, it returns . recognizes only standard YAML tags and cannot construct an arbitrary Python object.\n\nA python object can be marked as safe and thus be recognized by . To do this, derive it from (as explained in section Constructors, representers, resolvers) and explicitly set its class property to .\n\nparses the given and returns a sequence of Python objects corresponding to the documents in the stream. recognizes only standard YAML tags and cannot construct an arbitrary Python object.\n\nserializes the given Python object into the . If is , it returns the produced stream.\n\nserializes the given sequence of Python objects into the given . If is , it returns the produced stream. Each object is represented as a YAML document.\n\nserializes the given Python object into the . If is , it returns the produced stream. produces only standard YAML tags and cannot represent an arbitrary Python object.\n\nserializes the given sequence of Python objects into the given . If is , it returns the produced stream. Each object is represented as a YAML document. produces only standard YAML tags and cannot represent an arbitrary Python object.\n\nspecifies a for the given . A constructor is a function that converts a node of a YAML representation graph to a native Python object. A constructor accepts an instance of and a node and returns a Python object.\n\nspecifies a for the given . A multi-constructor is a function that converts a node of a YAML representation graph to a native Python object. A multi-constructor accepts an instance of , the suffix of the node tag, and a node and returns a Python object.\n\nspecifies a for Python objects of the given . A representer is a function that converts a native Python object to a node of a YAML representation graph. A representer accepts an instance of and an object and returns a node.\n\nspecifies a for Python objects of the given or any of its subclasses. A multi-representer is a function that converts a native Python object to a node of a YAML representation graph. A multi-representer accepts an instance of and an object and returns a node.\n\nadds an implicit tag resolver for plain scalars. If the scalar value is matched the given , it is assigned the . is a list of possible initial characters or .\n\nadds a path-based implicit tag resolver. A is a list of keys that form a path to a node in the representation graph. Paths elements can be string values, integers, or . The of a node can be , , , or .\n\nAn instance of points to a certain position in the input stream. is the name of the stream, for instance it may be the filename if the input stream is a file. and is the line and column of the position (starting from 0). , when it is not , is a part of the input stream that contain the position and refers to the position in the .\n\nIf the YAML parser encounters an error condition, it raises an exception which is an instance of or of its subclass. An application may catch this exception and warn a user.\n\nAn exception produced by the YAML processor may point to the problematic position.\n\nTokens are produced by a YAML scanner. They are not really useful except for low-level YAML applications such as syntax highlighting.\n\nThe PyYAML scanner produces the following types of tokens:\n\nand denote the beginning and the end of a token.\n\nEvents are used by the low-level Parser and Emitter interfaces, which are similar to the SAX API. While the Parser parses a YAML stream and produces a sequence of events, the Emitter accepts a sequence of events and emits a YAML stream.\n\nThe following events are defined:\n\nThe flag indicates if a collection is block or flow. The possible values are , , . The flag of a scalar event indicates the style of the scalar. Possible values are , , , , , . The flag of a collection start event indicates if the tag may be omitted when the collection is emitted. The flag of a scalar event is a pair of boolean values that indicate if the tag may be omitted when the scalar is emitted in a plain and non-plain style correspondingly.\n\nNodes are entities in the YAML informational model. There are three kinds of nodes: scalar, sequence, and mapping. In PyYAML, nodes are produced by Composer and can be serialized to a YAML stream by Serializer.\n\nThe and flags have the same meaning as for events. The value of a scalar node must be a unicode string. The value of a sequence node is a list of nodes. The value of a mapping node is a list of pairs consisting of key and value nodes.\n\nis the most common of the above classes and should be used in most cases. is an input YAML stream. It can be a string, a Unicode string, an open file, an open Unicode file.\n\nsupports all predefined tags and may construct an arbitrary Python object. Therefore it is not safe to use to load a document received from an untrusted source. By default, the functions , , , , and others use .\n\nsupports only standard YAML tags and thus it does not construct class instances and probably safe to use with documents received from an untrusted source. The functions and use to parse a stream.\n\ndoes not resolve or support any tags and construct only basic Python objects: lists, dictionaries and Unicode strings.\n\n, , are versions of the above classes written in C using the LibYAML library.\n\nreturns if the next token in the stream is an instance of one of the given . Otherwise it returns .\n\nreturns the next token in the stream, but does not remove it from the internal token queue. The function returns at the end of the stream.\n\nreturns the next token in the stream and removes it from the internal token queue. The function returns at the end of the stream.\n\nreturns if the next event in the stream is an instance of one of the given . Otherwise it returns .\n\nreturns the next event in the stream, but does not remove it from the internal event queue. The function returns at the end of the stream.\n\nreturns the next event in the stream and removes it from the internal event queue. The function returns at the end of the stream.\n\nreturns is there are more documents available in the stream. Otherwise it returns .\n\nconstruct the representation graph of the next document in the stream and returns its root node.\n\nreturns is there are more documents available in the stream. Otherwise it returns .\n\nconstructs and returns a Python object corresponding to the next document in the stream.\n\nchecks that the given is a scalar and returns its value. This function is intended to be used in constructors.\n\nchecks that the given is a sequence and returns a list of Python objects corresponding to the node items. This function is intended to be used in constructors.\n\nchecks that the given is a mapping and returns a dictionary of Python objects corresponding to the node keys and values. This function is intended to be used in constructors.\n\nis the most common of the above classes and should be used in most cases. is an output YAML stream. It can be an open file or an open Unicode file.\n\nsupports all predefined tags and may represent an arbitrary Python object. Therefore it may produce a document that cannot be loaded by other YAML processors. By default, the functions , , , and others use .\n\nproduces only standard YAML tags and thus cannot represent class instances and probably more compatible with other YAML processors. The functions and use to produce a YAML document.\n\ndoes not support any tags and is useful only for subclassing.\n\n, , are versions of the above classes written in C using the LibYAML library.\n\nserializes the given and writes it to the output stream.\n\nserializes the given representation graph into the output stream.\n\nserializes the given Python object to the output YAML stream.\n\nreturns a scalar node with the given , , and . This function is intended to be used in representers.\n\nreturn a sequence node with the given and subnodes generated from the items of the given .\n\nreturn a mapping node with the given and subnodes generated from the keys and values of the given .\n\nSubclassing is an easy way to define tags, constructors, and representers for your classes. You only need to override the attribute. If you want to define your custom constructor and representer, redefine the and method correspondingly.\n\nneed to update this section\n• rules for tabs in YAML are confusing. We are close, but not there yet. Perhaps both the spec and the parser should be fixed. Anyway, the best rule for tabs in YAML is to not use them at all.\n• Byte order mark. The initial BOM is stripped, but BOMs inside the stream are considered as parts of the content. It can be fixed, but it’s not really important now.\n• None Empty plain scalars are not allowed if alias or tag is specified. This is done to prevent anomalities like [ !tag, value], which can be interpreted both as [ !<!tag,> value ] and [ !<!tag> \"“,”value\" ]. The spec should be fixed.\n• None Indentation of flow collections. The spec requires them to be indented more than their block parent node. Unfortunately this rule renders many intuitively correct constructs invalid, for instance, block: { } # this is indentation violation according to the spec.\n• None ‘:’ is not allowed for plain scalars in the flow mode."
    },
    {
        "link": "https://python.land/data-processing/python-yaml",
        "document": "YAML, a recursive acronym for “YAML Ain’t Markup Language,” is a human-readable data serialization language. It is often used for configuration files but also for data exchange. The most used python YAML parser is PyYAML, a library that allows you to load, parse, and write YAML, much like Python’s JSON library helps you to work with JSON.\n\nThis article teaches you how to load, read, and write YAML files with PyYAML. In addition, you’ll learn how to install it on your system and how YAML compares to alternatives like JSON.\n\nAccording to the official site(1), YAML is a human-friendly data serialization language for all programming languages. YAML is most often used for configuration files, but it’s also used for data exchange.\n\nYAML is easy to write and read for humans, even for non-programmers. At the same time, it’s also easy to parse YAML, especially with Python and the PyYAML library! Its human-friendliness and readability is YAML’s biggest advantage over other formats, like JSON and XML.\n\nThese are the most prominent features of YAML:\n• You can use comments in YAML files\n• You can store multiple documents in one YAML file with the separator. A feature often used in Kubernetes definitions.\n\n1) Fun fact: the official YAML website is written as valid YAML files.\n\nWhy use YAML with Python?\n\nIf you ask me, YAML is perfect for configuration files. That’s exactly how I, and many other developers, use it the most. Others seem to agree, as many large projects, like Docker and Kubernetes, use YAML to define deployments. It has a richer syntax than the often used alternative, .ini files, but is still nice on the eyes and simple to write and parse.\n\nThere are some downsides to using YAML with Python, too:\n• YAML is not part of the standard Python library, while XML and JSON are\n• Its dependence on indentation is frustrating sometimes (however, Python developers are used to that, right?)\n• It’s perhaps too versatile for simple use cases, like data exchange of simple objects.\n\nIf you’re looking for a suitable data format for data exchange and storage, I recommend JSON, XML, or other more efficient formats like protocol buffers and Avro.\n\nMultiple Python packages can parse YAML data. However, PyYAML is the most prevalent and complete implementation for parsing YAML. PyYAML is not part of the standard Python library, meaning you must install it with Pip. Use the following command to install PyYAML, preferably in a virtual environment:\n\nOn some systems, you need to use pip3:\n\nTo use PyYAML in your scripts, import the module as follows. Note that you don’t import , but simply :\n\nOnce we have the YAML parser imported, we can load a YAML file and parse it. YAML files usually carry the extension or . Let’s work with the following example YAML file called :\n\nLoading, parsing, and using this configuration file is similar to loading JSON with the Python JSON library. First, we open the file. Next, we parse it with the function. Please note that I changed the output a little to make it more readable for you:\n\nThe YAML parser returns a regular Python object that best fits the data. In this case, it’s a Python dictionary. This means all the regular dictionary features can be used, like using with a default value.\n\nHere’s the same example, but interactive, so you can experiment with this for yourself:\n\nYou can use to parse all kinds of valid YAML strings. Here’s an example that parses a simple list of items into a Python list:\n\nYAML allows you to define multiple documents in one file, separating them with a triple dash ( ). PyYAML will happily parse such files and return a list of documents. You can do so by using the yaml.safe_load_all() function. This function returns a generator that in turn will return all documents one by one.\n\nNote that the file needs to be opened as long as you’re reading documents from the YAML, so you must process the file within the clause. Here’s an interactive example that demonstrates this function:\n\nAlthough most will only read YAML as a configuration file, it can also be very handy to write YAML as well. Example use cases could be:\n• Create an initial configuration file with current settings for your user\n• To save state of your program in an easy to read file (instead of using something like Pickle)\n\nIn the following example, we’ll:\n• Create a list with names as we did before\n• Save the names to a YAML formatted file with\n• Read and print the file, as proof that everything worked as expected\n\nHere you go:\n\nHere’s the same code as a non-interactive example:\n\nIf you need to convert YAML to JSON, you can parse the YAML as we did above. In the next step, you can use the JSON module to convert the object to JSON.\n\nIn this example, we open a YAML-based configuration file, parse it with PyYAML, and then write it to a JSON file with the JSON module:\n\nHere’s the same code as a non-interactive example:\n\nFor the sake of completeness, let’s do the reverse, too: convert JSON to YAML:\n\nYou will encounter many examples of PyYAML usage where is used instead of . I intentionally didn’t tell you about the function until now. Since most people have a job to do and tend to copy-paste some example code quickly, I wanted them to use the safest method of parsing YAML with Python.\n\nHowever, if you’re curious about the difference between these two, here’s the summary: is a dangerously powerful function, just like pickle, if you know that function. Both are insecure methods because they allow an attacker to execute arbitrary code. PyYAML’s load function allows you to serialize and deserialize complete Python objects and even execute Python code, including calls to the library, which can execute any command on your system.\n\nIn recent PyYAML versions, the function is deprecated and will issue a big fat warning when you use it in an insecure way.\n\nIf you’re parsing regular YAML files, like 99% of us do, you should always use , since it only contains a subset of the load function. All the scary, arbitrary code execution type of stuff is stripped out.\n\nHere are some resources that you might want to continue with:\n• How to open, read, and write files with Python"
    },
    {
        "link": "https://pyyaml.org/wiki/PyYAML",
        "document": "PyYAML is a YAML parser and emitter for Python.\n\nYAML is a data serialization format designed for human readability and interaction with scripting languages.\n\nPyYAML is a YAML parser and emitter for the Python programming language.\n• a complete YAML 1.1 parser. In particular, PyYAML can parse all examples from the specification. The parsing algorithm is simple enough to be a reference for YAML parser implementors.\n• high-level API for serializing and deserializing native Python objects (like DOM or pickle).\n• support for all types from the YAML types repository. A simple extension API is provided.\n• both pure-Python and fast LibYAML-based parsers and emitters.\n\nUnpack the archive and install the package by executing\n\nIf you want to use LibYAML bindings, you need to download and install LibYAML. Then you may install the bindings by executing\n\nThe source distribution includes a comprehensive test suite. To run the tests, type\n\nQuick example (see documentation for loading multiple documents):\n\nFor more details, please check PyYAML Documentation.\n• #290 – Use instead of equality for comparing with\n• #358 – Allow calling with None\n• #285 – Add use of function in README\n• #360 – Enable certain unicode tests when maxunicode not > 0xffff\n• #359 – Use in yaml-highlight example\n• #244 – Document that PyYAML is implemented with Cython\n• #163 – Create timezone-aware datetimes when parsed as such\n• Repair incompatibilities introduced with 5.1. The default Loader was changed, but several methods like add_constructor still used the old default #279 – A more flexible fix for custom tag constructors #287 – Change default loader for yaml.add_constructor #305 – Change default loader for add_implicit_resolver, add_path_resolver\n• Make FullLoader safer by removing python/object/apply from the default FullLoader #347 – Move constructor for object/apply to UnsafeConstructor\n• Fix bug introduced in 5.1 where quoting went wrong on systems with sys.maxunicode <= 0xffff #276 – Fix logic for quoting special characters\n• Other PRs: #280 – Update CHANGES for 5.1\n• #45 – Allow colon in a plain scalar in a flow context\n• #254 – Allow to turn off sorting keys in Dumper\n• #35 – Some modernization of the test running\n• #261 – Skip certain unicode tests when maxunicode not > 0xffff\n• Adding an implicit resolver to a derived loader should not affect the base loader (fixes issue #57).\n• Uniform representation for OrderedDict across different versions of Python (fixes issue #61).\n• Source and binary distributions are rebuilt against the latest versions of Cython and LibYAML.\n• Do not try to build LibYAML bindings on platforms other than CPython; this fixed installation under Jython (Thank to olt(at)bogosoft(dot)com).\n• Clear cyclic references in the parser and the emitter (Thank to kristjan(at)ccpgames(dot)com).\n• LibYAML bindings are rebuilt with the latest version of Cython.\n• Dropped support for Python 2.3 and 2.4; currently supported versions are 2.5 to 3.2.\n• Fixed use of uninitialized memory when emitting anchors with LibYAML bindings (Thank to cegner(at)yahoo-inc(dot)com).\n• Fixed emitting incorrect BOM characters for UTF-16 (Thank to Valentin Nechayev)\n• Fixed the emitter for folded scalars not respecting the preferred line width (Thank to Ingy).\n• Fixed a subtle ordering issue with emitting directives (Thank to Andrey Somov).\n• Use Cython instead of Pyrex to build LibYAML bindings.\n• The emitter learned to use an optional indentation indicator for block scalar; thus scalars with leading whitespaces could now be represented in a literal or folded style.\n• The test suite is now included in the source distribution. To run the tests, type .\n• Refactored the test suite: dropped in favor of a custom test appliance.\n• Forced an explicit document end indicator when there is a possibility of parsing ambiguity.\n• More improvements: the package should be usable when any combination of , and is installed.\n• Minor typos and corrections. Thank to Ingy dot Net and Andrey Somov.\n• setup.py checks whether LibYAML is installed and if so, builds and installs LibYAML bindings. To force or disable installation of LibYAML bindings, use or respectively (partially fixes #34).\n• raises an exception if the input stream contains more than one YAML document (fixed #54).\n• Windows binary packages are built against the LibYAML stable branch.\n• Allow for immutable subclasses of YAMLObject. Fixed #53.\n• Make the encoding of the unicode->str conversion explicit; fixed #52.\n• Fixed a problem when the event is not emitted until the beginning of the next document is available. Fixed #51. Thanks edward(at)sweetbytes.net for the bug report.\n• Fix the bug when the path in contains boolean values. Fixed #43 (thanks to jstroud(at)mbi.ucla.edu for reporting and pointing to the cause).\n• Use the types module instead of constructing type objects by hand. Fixed #41. Thanks to v.haisman(at)sh.cvut.cz for the patch.\n• Fix loss of microsecond precision in datetime.datetime constructor (fix #30). Thanks to edemaine(at)mit.edu for the bug report and the patch.\n• Sort dictionary keys (close #23). Mapping node values are now represented as lists of pairs instead of dictionaries. Do not check for duplicate mapping keys as it didn’t work correctly anyway.\n• Fix invalid output of single-quoted scalars in cases when a single quote is not escaped when preceeded by whitespaces or line breaks (close #17).\n• To make porting easier, rewrite Parser not using generators.\n• Fix a bug in : was not correctly handled.\n• Fix a bug when a block scalar is incorrectly emitted in the simple key context.\n• Hold references to the objects being represented (close #22).\n• Make Representer not try to guess when a list is represented.\n• Fix the ‘N’ plain scalar being incorrectly recognized as (close #26).\n• Fix win32 installer. Apparently bdist_wininst does not work well under Linux.\n• Add the yaml-highlight example. Try to run on a color terminal: .\n• Initial release. The version number reflects the codename of the project (PyYAML 3000) and differenciates it from the abandoned PyYaml module.\n\nThe PyYAML module was written by Kirill Simonov. It is now maintained by the YAML community.\n\nPyYAML is released under the MIT license."
    },
    {
        "link": "https://realpython.com/python-yaml",
        "document": "YAML is a portable and widely used data serialization format. Unlike the more compact JSON or verbose XML formats, YAML emphasizes human readability with block indentation, which should be familiar to most Python programmers.\n\nWhile Python comes with batteries included, it lacks built-in support for YAML. Still, you can read and write YAML documents in Python by installing a third-party library, such as PyYAML.\n\nBy the end of this tutorial, you’ll understand that:\n• YAML stands for YAML Ain’t Markup Language, emphasizing its focus on data representation rather than document markup.\n• YAML is often used for configuration and serialization due to its human-readable syntax.\n• Python doesn’t support YAML natively, unlike the JSON and XML formats. You need to install a third-party library to work with YAML in Python programs.\n• PyYAML is arguably the most popular YAML library for Python due to its simplicity.\n• Alternatives to PyYAML include ruamel.yaml and StrictYAML, which offer more features.\n\nTo get the most out of this tutorial, you should be familiar with object-oriented programming in Python and know how to create a class. If you’re ready to jump in, then you can follow the link below to get the source code for the examples that you’ll code in this tutorial:\n\nGetting Started With YAML in Python As you learned in the introduction, working with YAML in Python requires a few extra steps because the language doesn’t support this data format out of the box. You’re going to need a third-party library to serialize Python objects into YAML and the other way around. In addition to this, you might find it useful to install these command-line tools with pip into your virtual environment to help with debugging:\n• yamllint: A linter for YAML, which can check the syntax and more These are all Python tools, but there’s also a widespread Go implementation of yq, which has a slightly different command-line interface. If you can’t or don’t want to install those programs, then you can always use one of the tools available online, such as: Note that you’ll need some of those tools in the following subsection only, while you’ll get your feet wet with YAML in pure Python for the rest of this tutorial. Even though Python doesn’t provide a dedicated YAML parser or serializer, you can sidestep this problem to some extent with the help of the built-in module. After all, you’ve learned that YAML is a superset of JSON, so you could dump your data to a regular JSON format in Python and expect external YAML parsers to accept it. First, make a sample Python script to print out JSON on the standard output: You create a dictionary and then call on it to dump a string. The parameter specifies a function to call when Python can’t serialize an object to JSON, which is the case with the date of birth in this example. The built-in function will convert a object to an ISO 8601 string. Now, run your script and feed its output to one of the command-line YAML parsers mentioned before, such as or , through a Unix pipeline ( ): Nice! Both parsers formatted your data in a more canonical YAML format without complaining. However, because is a thin wrapper around JSON’s , you must request that it do the transcoding with the option and a trailing dot as a filtering expression. Also, notice a slight difference in the resulting indentation between and . Note: To use , you must first install in your operating system if it’s not already available. Okay, that felt like cheating, and it works only one way, as you can’t read a YAML file back into Python using the module. Thankfully, there are ways to do that. Python’s most popular third-party YAML library by far is PyYAML, which is consistently one of the top packages downloaded from PyPI. It has an interface that looks somewhat similar to the built-in JSON module, it’s actively maintained, and it has the blessing of the official YAML website, which lists it alongside a few less popular contenders. To install PyYAML into your active virtual environment, type the following command in your terminal: The library is self-contained and doesn’t require any further dependencies because it’s written in pure Python. However, most distributions bundle a compiled C binding for the LibYAML library, which makes PyYAML run much faster. To confirm if your PyYAML installation comes with a C binding, open the interactive Python interpreter and run this code snippet: Even though PyYAML is the name of the library you’ve installed, you’ll be importing the package in Python code. Also, note that you need to explicitly request that PyYAML take advantage of the noticeably faster shared C library, or else it’ll fall back to its default of pure Python. Read on to find out how to change this default behavior. Despite its popularity, PyYAML has some drawbacks. For example, if you need to use features introduced in YAML 1.2, such as full JSON compliance or safer literals, then you’re better off using the ruamel.yaml library, which is derived from an older PyYAML version. As a bonus, it can do round-trip parsing to preserve the comments and original formatting when needed. On the other hand, if type safety is your main concern or you’d like to validate YAML documents against a schema, then have a look at StrictYAML, which intentionally restricts the YAML specification by disregarding its most risky features. Just keep in mind that it won’t run as quickly as the other two libraries. For now, you’re going to stick with PyYAML for the rest of this tutorial because it’s the standard choice for most Python projects. Note that the tools listed earlier—yamllint, yq, and shyaml—use PyYAML under the surface! Read and Write Your First YAML Document Suppose you want to read and parse a hypothetical email message that’s been serialized to the YAML format and stored in a string variable in Python: The quickest way of deserializing such a piece of YAML into a Python dictionary would be through the function: Calling is currently the recommended way of handling content received from untrusted sources, which could contain malicious code. YAML has an expressive syntax full of convenient features, which unfortunately open the door to a host of vulnerabilities. You’ll learn more about exploiting YAML’s weaknesses later. Note: Before version 6.0 of the PyYAML library, the default way of parsing YAML documents had always been the function, which defaulted to using an unsafe parser. With the latest release, you can still use this function, but it requires you to explicitly specify a particular loader class as a second parameter. Introducing this additional parameter was a breaking change that resulted in many complaints from people maintaining software dependent on PyYAML. There’s still a pinned issue on the library’s GitHub repository about this backward incompatibility. At the time of writing this tutorial, the official PyYAML documentation as well as the bundled docstrings haven’t been updated to reflect the current code base, and they contain examples that don’t work anymore. The function is one of several shorthand functions that encapsulate the use of various YAML loader classes under the hood. In this case, that single function call translates to the following more explicit yet equivalent code snippet: One thing to remember when using the shorthand functions is that they hard-code the pure Python implementation. If you’d like to use the faster C implementation, then you must write a little bit of boilerplate code yourself: First, you try importing one of the loader classes prefixed with the letter C to denote the use of the C library binding. If that fails, then you import a corresponding class implemented in Python. Unfortunately, this makes your code look more verbose and prevents you from using the mentioned shortcut functions. Note: Had your YAML contained multiple documents, then or its wrappers would raise an exception. You’ve already serialized a Python object to YAML before by abusing the built-in module, but the result wasn’t a canonical form of YAML. Now, you’ll take advantage of the installed third-party PyYAML library to fix this. There’s a corresponding function, which takes a Python object and turns it into a string. You can feed it the output of in order to reverse the parsing process: The result is a string object with your email message serialized to YAML again. However, it’s not quite the same YAML that you originally started with. As you can see, sorted the dictionary keys for you, quoted the multiline strings, and used a slightly different indentation. You can change some of this and apply more tweaks to the formatting through several keyword arguments that you’ll explore in one of the upcoming sections.\n\nLoading YAML boils down to reading a piece of text and parsing it according to the data format’s grammar. PyYAML can make this confusing due to the plethora of functions and classes to choose from. Plus, the library’s documentation doesn’t reliably clearly explain their differences and valid use cases. To save you from debugging the underlying code, you’ll find the most important facts about loading documents with PyYAML in this section. If you want the best possible parsing performance, then you’ll need to manually import the suitable loader class and pass it to the generic function, as shown before. But which one should you choose? To find out, take a look at this high-level overview of the loaders at your disposal. The brief descriptions should give you a general idea about the available choices: Doesn’t resolve or support any tags and constructs only basic Python objects ( , , ) Kept for backward compatibility but otherwise the same as Supports all standard, library, and custom tags and may construct an arbitrary Python object Supports only standard YAML tags like and doesn’t construct class instances Should be able to load almost all YAML safely The three loaders that you’re most likely to use have corresponding shorthand functions, which you can call instead of passing a loader class to the generic function. Remember, these are all written in Python, so for improved performance, you’ll need to import a suitable loader class prefixed with the letter C, such as , and call anyway. For a more detailed breakdown of the features supported by the individual loader classes, check out the table below: supports all available features and allows arbitrary code execution. is similar except for the code execution and the ability to deserialize custom Python classes, which cause a parsing error. additionally errors out on Python-specific tags provided by PyYAML, such as . On the other hand, remains agnostic about most features by ignoring them. Below, you’ll get a quick demonstration of the features mentioned above. First, import the module and check out an anchors and aliases example: You define an anchor, , near the shipping address and then reuse the same address for the invoice with the help of an alias, . As a result, you only had to specify the address once. This feature works with all loader types. The next example shows one of the standard YAML tags in action: Numeric literals such as are treated as floats by default, but you can request a type conversion to string with the tag. Almost all loaders respect standard YAML tags. The only exception is the class, which represents scalars with strings whether you tag them or not. To leverage PyYAML tags, which are provided by the library, use either or because they’re the only loaders that can handle Python-specific tags: The tag in the example above converts an inline list into a Python tuple. Head over to PyYAML documentation for a complete list of supported tags, but be sure to cross-check with the source code on GitHub, as the documentation might not be up to date. Most loaders are smart about deserializing scalars into auxiliary types, which are more specific than a basic string, list, or dictionary: Here, you have a mix of types, including a , a , a instance, an , and a . Again, is the only loader class that treats all scalars as strings at all times. Suppose you’d like to deserialize a custom class from YAML, make a function call in your Python code, or even execute a shell command while parsing YAML. In that case, your only option is the , which accepts a few special library tags. The other loaders either raise an exception or ignore those tags. You’ll learn more about the PyYAML tags now. PyYAML lets you serialize and deserialize any picklable Python object by tapping into its interface. Bear in mind that this allows for arbitrary code execution, as you’ll soon find out. However, if you don’t care about compromising your application’s security, then this capability can be pretty convenient. The library provides a couple of YAML tags recognized by to accomplish object creation: They all must be followed by a fully qualified name of the class to instantiate, which includes the package and module names. The first tag expects a mapping of key-value pairs, in either the flow or block style. Here’s an example: The other two tags are more complicated, as each one comes in two flavors. However, the two tags are almost identical because delegates processing to . The only difference is that calls a special method, , on the specified class without calling , while invokes the class itself, which is what you’ll want in most cases. One flavor of the syntax allows for setting the object’s initial state through a list of positional arguments, like so: Both styles achieve a similar effect by calling the method in the class with the two values passed as positional arguments. Alternatively, you can use a slightly more verbose syntax that allows you to mix positional and keyword arguments, among a few more advanced tricks glossed over for brevity: This would still call on your class, but one of the arguments would be passed as a keyword argument. In any case, you could define the class manually or by taking advantage of data classes in Python: This concise syntax will make Python generate the class initializer as well as a few other methods that you’d have to code yourself. Note that you can use against any callable object, including regular functions, and specify the arguments to pass. This lets you execute one of the built-in functions, a custom function, or even a module-level function, which PyYAML will happily import for you. That’s a huge security hole! Imagine using the or module to run a shell command that retrieves your private SSH key if you’ve defined one: It’s not hard to make an HTTP request with the stolen data through the network when the object gets created. A bad actor could use this information to access sensitive resources using your identity. Sometimes, these tags bypass the normal object creation path, which is typical of object serialization mechanisms in general. Say you wanted to load a user object from YAML and make it an instance of the following class: You place the class in a separate source file named to keep things organized. User objects have only one attribute—the name. By using just one attribute and implementing the initializer explicitly, you’ll be able to observe the way PyYAML calls the individual methods. When you decide to use the tag in YAML, then the library calls without any arguments and never calls . Instead, it directly manipulates the attribute of your newly created object, which can have some undesired effects: : 'User' object has no attribute 'name' While you’ve undoubtedly created a new instance, it wasn’t initialized properly, because the attribute was missing. However, it does have an unexpected , which is nowhere to be found in the class body. You can fix this by adding a declaration to your class, which forbids adding or removing attributes dynamically once the object exists in memory: Now, your user objects won’t have the attribute at all. Because there’s no inherent , the library falls back to calling for each key-value pair on the blank object. This ensures that only attributes listed in will pass through. This is all great, but what if the class accepted a password argument? To mitigate data leaks, you most definitely don’t want to serialize passwords in plaintext. And how about serializing stateful attributes, such as file descriptors or database connections? Well, if restoring your object’s state requires some code to run, then you can customize the serialization process with the special method in your class: You decode the persisted username using a primitive ROT-13 cipher, which rotates characters by thirteen places in the alphabet. For serious encryption, though, you’ll have to look beyond the standard library. Note that you could also use a hashing algorithm from the built-in module if you wanted to store a password securely. Here’s one way of loading your encoded state from YAML: As long as you’ve defined the method, it’ll always take precedence and give you control over setting an object’s state. That’s why you’re able to restore the original name, , from the encoded text above. Before moving on, it’s worth noting that PyYAML provides two more insecure tags: The first one lets you load a reference to a Python object, such as a class, a function, or a variable, in your code. The second tag allows for referencing a given Python module. In the next section, you’ll take a look at different data sources that PyYAML lets you load documents from. Once you choose the loader class or use one of the shorthand functions, you’re not limited to parsing only strings. The and other functions exposed by PyYAML accept a single argument, which is a universal stream of characters or bytes. The most common examples of such streams are strings and Python objects: According to the YAML 1.2 specification, parsers should support Unicode encoded with UTF-8, UTF-16, or UTF-32 for compatibility with JSON. However, because the PyYAML library supports only YAML 1.1, your only options are UTF-8 and UTF-16: If you try loading YAML from a text encoded with UTF-32, then you’ll get an error. However, that’s hardly a problem in practice because UTF-32 isn’t a common encoding. In any case, you can always do the appropriate transcoding yourself using Python’s and methods before loading YAML. Alternatively, you could try one of the other YAML parsing libraries mentioned earlier. You can also read YAML content straight from a file. Go ahead and create a file with sample YAML content in it and load it into Python using PyYAML: You create a local file named in your current working directory and write fourteen bytes representing a sample YAML document. Next, you open that file for reading and use to get a corresponding dictionary. The file can be open in either text or binary mode. In fact, you may pass any file-like stream of characters or bytes such as the in-memory io.StringIO text buffer or the binary io.BytesIO stream: As you can see, the loading functions in PyYAML are quite versatile. Compare this with the module, which provides different functions depending on the type of your input argument. However, PyYAML bundles yet another set of functions that may help you read more than one document from a stream. You’ll learn about those functions now. All four loading functions in PyYAML have their iterable counterparts, which can read multiple YAML documents from a single stream. They still expect exactly one argument, but instead of immediately parsing it into a Python object, they wrap it with a generator iterator that you can iterate over: The individual documents must start with a triple dash ( ) and can optionally end with three dots ( ). In this section, you learned about the high-level functions available in PyYAML to load documents with. Unfortunately, they try to read the entire stream eagerly in one go, which isn’t always feasible. Reading huge files in such a way can take too long or even fail due to limited memory. If you’d like to process YAML in a streaming fashion similar to the SAX interface in XML, then you have to use the low-level API provided by PyYAML.\n\nIf you’ve worked with JSON in Python before, then serializing or “dumping” Python objects to YAML will look more familiar than loading them. The PyYAML library has an interface that’s somewhat similar to the built-in module. It also provides fewer dumper classes and wrapper functions than loaders to choose from, so you don’t have to juggle that many options. The all-around YAML serialization function in PyYAML is , which takes an optional dumper class as an argument. If you don’t specify one during a function call, then it falls back to using the most feature-rich . Other choices are as follows: Doesn’t support any tags and is useful only for subclassing Produces only standard YAML tags like and can’t represent class instances, making it more compatible with other YAML parsers Supports all standard, library, and custom tags and can serialize an arbitrary Python object, so it may produce a document that other YAML parsers won’t load In practice, the real choice you have is going to be between and since is only intended as a base class for subclasses to extend. Generally, you’ll want to stick with the default in most cases unless you need to produce portable YAML without Python-specific quirks. Again, remember to import the corresponding dumper class prefixed with the letter C for the best serialization performance, and keep in mind that there might be slight differences between the Python and C implementations: For example, the pure Python dumper appends optional dots at the end of a YAML document, while a similar wrapper class for the LibYAML library doesn’t. However, these are cosmetic differences that have no real impact on serialized or deserialized data. Serializing JSON in Python requires you to choose between calling or depending on where you want the content to be dumped. On the other hand, PyYAML provides a two-in-one dumping function, which behaves differently depending on how you call it: When called with a single argument, the function returns a string representing the serialized object. However, you can optionally pass a second argument to specify the target stream to write to. It can be a file or any file-like object. When you pass this optional argument, the function returns , and you need to extract data from the stream as necessary. If you want to dump your YAML into a file, then be sure to open the file in write mode. Additionally, you must specify the character encoding through an optional keyword argument to the function when the file is open in binary mode: When you open a file in text mode, then it’s always a good practice to explicitly set the character encoding. Otherwise, Python will assume your platform’s default encoding, which might be less portable. Character encoding has no meaning in binary mode, which deals with bytes that are already encoded. Still, you should set the encoding through the function, which accepts many more optional parameters, which you’ll learn about soon. The two YAML-dumping functions in PyYAML, and , have no way of knowing whether you mean to serialize multiple separate documents or a single document comprising an element sequence: They always assume the latter, dumping a single YAML document with a list of elements. To dump multiple documents, use either or : Now you get a string containing more than one YAML document separated with the triple dash ( ). Note that is the only function used under the hood because all the other ones, including and , delegate processing to it. So, regardless of which function you call, they will all have the same list of formal parameters. The dumping functions in PyYAML accept a few positional arguments and a number of optional keyword arguments, which let you control the output’s formatting. The only required parameter is the Python object or a sequence of objects to serialize, passed as the first argument in all dumping functions. You’ll take a closer look at the available parameters in this section. The three wrappers that delegate to have the following function signatures, which reveal their positional arguments: The first function expects between one and three positional arguments since two of them have optional values. On the other hand, the second and the third function listed above expect only two positional arguments because they both use a predefined . To find the available keyword arguments, you have to look at the function’s signature. You can use the same keyword arguments across all four dumping functions. They’re all optional because they have default values equal to either or , except for the argument, which has a default value of . In total, there are six Boolean flags that you can turn on and off to change the look of the resulting YAML: End each document with the triple dot ( ). Start each document with the triple dash ( ). Sort the output of dictionaries by key. There are also several parameters of other data types that give you more freedom: Block indent level, which must be greater than 1 and less than 10 Line width, which must be bigger than twice the indent Scalar quotation style, which must be one of the following: , , or Character encoding, which produces instead of when set Newline character, which must be one of the following: , , or Major and minor YAML version, such as for version 1.2 Most of them are self-explanatory. However, the argument must be a dictionary that maps custom tag handles to valid URI prefixes recognized by a YAML parser: Specifying such a mapping will add a relevant tag directive into your dumped document. Tag handles always begin and end with an exclamation point. They’re a shorthand notation for full tag names. For example, these are all equivalent ways of using the same tag in a YAML document: By using a directive above the YAML document, you declare a custom tag handle called , which gets expanded into the following prefix. The double exclamation point ( ) is a built-in shortcut for the default namespace corresponding to the prefix. You can experiment with the available keyword arguments by changing their values and rerunning your code to see the result. However, this sounds like a tedious task. The supporting materials for this tutorial come with an interactive app that will let you test different combinations of arguments and their values in a web browser: It’s a dynamic web page that uses JavaScript to communicate over the network with a minimal HTTP server written in FastAPI. The server expects a JSON object with all but the keyword argument and calls against the following test object: The sample object above is a dictionary comprising integer and string fields, which contain Unicode characters. To run the server, you must first install the FastAPI library and an ASGI web server such as uvicorn into your virtual environment, where you had installed PyYAML before: To run the server, you must provide the module name followed by a colon and the name of the ASGI-compatible callable in that module. The details of implementing such a server and a client are far beyond the scope of this tutorial, but feel free to download the sample materials to study on your own: Get Your Code: Click here to download the free sample code you’ll use to work with YAML in Python. Next up, you’ll learn more about dumping custom classes with PyYAML. As you already know, at this point, you can use one of the Python-specific tags provided by PyYAML to serialize and deserialize objects of your custom data types, such as classes. You also know that those tags are only recognized by the unsafe loaders and dumpers, which explicitly allow potentially dangerous code execution. The library will refuse to serialize a Python-specific type like a complex number unless you choose the unsafe dumper class: In the first case, the safe dumper doesn’t know how to represent your complex number in YAML. On the other hand, calling implicitly uses the unsafe class behind the scenes, which takes advantage of the tag. It’s a similar story when you try to dump a custom class: Your only option is the unsafe . However, it’s possible to mark your classes as safe to parse so that even the safe loader will be able to handle them later. To do that, you must make a few changes to your class: First, let the class inherit from . Then specify two class attributes. One attribute will represent a custom YAML tag tied to your class, while the second one will be the loader class to use. Now, when you dump a object to YAML, you’ll be able to load it back with : The Walrus operator ( ) lets you define a variable and use it as an argument to the function in one step. Marking classes as safe is a nice compromise, allowing you to make exceptions to some of your classes by shrugging off security and letting them in. Naturally, you must be absolutely sure that there’s nothing suspicious about them before you try loading the associated YAML.\n\nThe classes and a few wrapper functions that you’ve used so far constitute a high-level PyYAML interface, which hides the implementation details of working with YAML documents. This covers most of the use cases and allows you to focus on the data rather than its presentation. However, sometimes you might want more control over the parsing and serialization processes. In those rare cases, the library exposes its inner workings to you through several low-level functions. There are four ways to read a YAML stream: All of these functions accept a stream and an optional loader class, which defaults to . In addition to this, most of them return a generator object, letting you process YAML in a streaming fashion, which wasn’t possible up to this point. You’ll learn about the differences between tokens, events, and nodes a bit later. There are also a few counterpart functions for writing YAML to a stream: Note that whatever function you choose, you’ll probably have more work to do than before. For example, handling YAML tags or interpreting string values as the correct native data type will be in your court now. Some of these steps may be unnecessary, though, depending on your use case. In this section, you’ll implement three hands-on examples of these low-level functions in PyYAML. Remember that you can download their source code by following the link below: Get Your Code: Click here to download the free sample code you’ll use to work with YAML in Python. You’ll get the most granular control by scanning a YAML document to obtain a stream of tokens. Each token has a unique meaning and tells you where it starts and where it ends, including the exact line and column number, as well as the offset from the beginning of the document: The token’s and attributes contain all the relevant information. That’s perfect if you want to implement a YAML syntax highlighter plugin for your favorite code editor, for example. In fact, why don’t you go ahead and build a bare-bones command-line tool for printing YAML content in color? First, you need to narrow down the token types, as you’ll only be interested in coloring scalar values, mapping keys, and YAML tags. Create a new file named and place the following function in it: It’s a thin wrapper around PyYAML’s function, which generates tuples comprising the start index, the end index, and a token instance. Here’s a more detailed breakdown:\n• Line 4 defines a variable to hold the last token instance. Only the scalar and tag tokens contain a value, so you must remember their context somewhere to choose the right color later. The initial value accounts for when the document contains only a scalar without any context.\n• Lines 6 and 7 extract the token’s position within the text from the index markers available on all tokens. The token’s position is delimited with and .\n• Lines 8 to 11 check the current token type and yield the indices and a token instance. If the token is a tag, then it gets yielded. If the token is a scalar, then is yielded because scalars can appear in different contexts, and you need to know what the current context is to select the appropriate color.\n• Lines 12 and 13 update the context if the current token is either a mapping key or a value. Other token types get ignored, as they don’t have a meaningful visual representation. When you import your function into an interactive Python interpreter session, then you should be able to start iterating over the subset of tokens with their relevant indices: Neat! You can take advantage of these tuples to annotate tokens in the original text using a third-party library or ANSI escape sequences as long as your terminal supports them. Here are a few sample colors with their escape sequences: For example, keys could become blue, values might be cyan, and YAML tags could turn red. Remember that you can’t modify a sequence of elements while iterating over them, because that would shift their indices. What you can do, however, is start the iteration from the other end. That way, inserting the escape sequences won’t affect the remaining part of the text. Return to your code editor now and add another function to the Python source file: This new function iterates over a tokenized text in reverse and inserts escape code sequences where indicated by and . Note that it’s not the most efficient way of doing this, because you essentially end up making lots of text copies due to slicing and concatenating. The final piece of the puzzle is taking YAML from the standard input and presenting it onto the standard output stream: You import the module from Python’s standard library and pass the reference to the function that you just created. Now, you may run your script in the terminal and enjoy color-coded YAML tokens: Note that the command isn’t available on Windows. If that’s your operating system, then use its counterpart, and make sure to run the command through the Terminal application instead of the Command Prompt ( ) or Windows PowerShell to have the ANSI escape code support enabled by default. Expand the collapsible section below for the complete source code of your script: Tokenizing was great for implementing a syntax highlighter, which must be able to reference symbols in the source YAML file. However, it may be a little too low-level for other applications that don’t care about the exact layout of your input data. Next up, you’ll learn about an alternative way to process YAML, which also involves streaming. Another low-level interface provided by PyYAML is an event-driven streaming API, which works similarly to SAX in XML. It translates YAML into a flat sequence of events triggered by the individual elements. The events are evaluated lazily without loading the entire document into memory. You can think of it as peeking through a moving window. This can help bypass memory limitations that you might face when trying to read a huge file. It can also considerably speed up searching for a very specific piece of information in the ocean of noise. Apart from that, streaming makes it possible to incrementally build an alternative representation for your data. In this section, you’ll create an HTML builder to visualize YAML in a crude way. When you parse a document with PyYAML, the library yields a sequence of events: As you can see, there are various types of events that correspond to different elements in a YAML document. Some of those events expose additional attributes, which you can inspect to learn more about the element at hand. You can imagine how these events could naturally translate to opening and closing tags in a hierarchical markup language like HTML. For example, you might represent the structure above with the following markup snippet: A single list item gets wrapped between the and tags, while a key-value mapping takes advantage of the description list ( ), which contains alternating terms ( ) and definitions ( ). This is the tricky part because it requires counting the subsequent YAML events on a given nesting level to determine whether an event should become a term or a definition in HTML. Ultimately, you want to design an class to help you with parsing multiple YAML documents from a stream in a lazy manner. Assuming you’ve already defined such a class, you can create the following helper function in a file named : The code loops over a sequence of parser events and hands them over to your class, which translates YAML to HTML by incrementally building its representation. Once the function detects the end of a YAML document in a stream, it yields an HTML fragment and creates a new empty builder to start over. That avoids blocking during the processing of a potentially infinitely long stream of YAML documents, which might arrive over the wire: The example above demonstrates a stream consisting of three YAML documents, which the helper function turns into separate HTML fragments. Now that you understand the expected behavior, it’s time to implement the class. The initializer method in your builder class will define two private fields to keep track of the current context and the HTML content built so far: The context is a stack implemented as a Python list, which stores the number of key-value pairs on the given level processed so far. The stack can also contain list markers that indicate a state between and . The other field is a list of HTML tags and their content, joined by a public class property. There’s a handful of YAML events that you’ll want to process: You start processing an event by checking if there are any open tags on the stack pending some action. You delegate this check to another helper method, , which you’ll add later. Then, you append the HTML tag corresponding to the current event and again update the context. Here’s a quick line-by-line rundown of the snippet above:\n• Lines 3 to 9 import the needed event types from PyYAML.\n• Lines 11 and 12 specify the event types corresponding to HTML opening and closing tags.\n• Lines 22 to 35 append the corresponding HTML tag and update the stack as necessary.\n• Lines 19, 20, 37, and 38 open or close pending tags on the stack and optionally update the number of key-value pairs processed. The missing part is the helper method responsible for opening and closing matching tags when necessary: If there’s something on the stack already, then you check the last item pushed onto it. If it was a list, then you open or close a list item. Otherwise, depending on the parity of the number of key-value mappings, it’s time to open or close a term or definition from a description list. You can optionally turn your Python module into an executable script by adding the idiom at the bottom: It’ll let you preview the visual representation of YAML in your terminal when you pipe the HTML output to a text-based web browser like Lynx or the html2text converter: The command should work on all major operating systems. It prints a piece of text in the terminal, which you can hook up to another command pipeline using the vertical bar character ( ). In this case, you process a short YAML document with your script and then convert the resulting HTML to a simplified textual form that you can preview in the terminal without starting a full-fledged web browser. Click the collapsible section below to reveal the complete source code: Great job! You can now visualize YAML in your web browser. However, the presentation is static. Wouldn’t it be nice to spice it up with a little bit of interactivity? Next up, you’ll use a different approach to parsing YAML, which will allow just that! Sometimes you do need to have the entire document held in memory to look ahead and make an informed decision based on what comes next. PyYAML can build an object representation of the YAML element hierarchy that resembles the DOM in XML. By calling , you’ll get the root node of an element tree: The root is traversable through the square brackets syntax. You can reach for any descendant element in the tree using node’s attribute and subscripts: Because there are only three kinds of nodes ( , , and ), you might automate their traversal with a recursive function: Place this function in a Python script named , as you’ll be developing the code. The function takes a single node and, depending on its type, returns its value or enters a relevant subtree. Note that mapping keys must also be visited, because they can be non-scalar values in YAML. Then, import your function in an interactive Python interpreter session and give it a test drive against the root element that you created before: You get a Python list as a result, but the individual scalar values contained in it are all strings. PyYAML detects the data type associated with a scalar value and stores it in the node’s attribute, but you have to do the typecasting yourself. The types are encoded using YAML global tags, such as , so you may extract the last bit after the second colon ( ). Modify your function by wrapping the return value of a scalar with a call to a new function: You can leverage the new and keywords introduced in Python 3.10 with the structural pattern matching syntax, or you can rewrite this example using a plain old statement. The bottom line is that you should now be getting values of native Python types when you reload the module in your interactive interpreter session: You’re all set to generate an HTML string instead of a Python object. Replace the return values in with calls to even more helper functions: Both helper functions take a node instance and return a piece of HTML string. The function expects a iterated over with a generator expression, while iterates over keys and values of a . This is where knowing the entire tree structure in advance helps. If the mapping value is a , then you replace it with a element. Other node types get wrapped in a collapsible tag. Because you’ll produce HTML output, you may streamline the typecasting function by returning only plain strings. At the same time, you can return an HTML element for the Base64-encoded data and display that element instead of showing raw bytes. Other than that, regular scalars could be wrapped in either a or an appropriately styled element depending on if they contain single or multiline content: The attribute of an HTML element recognizes the encoded data. Note that you don’t need the or the imports anymore, so go ahead and remove them from the top of the file. As always, you want to make your script runnable by reading content from the standard input. You also wrap the generated HTML body with some boilerplate in a new function: This HTML uses an embedded Google Font for a more pleasant look. The inline CSS styling removes bullet points from regular unordered lists because you use bullet points for key-value mappings. However, lists explicitly marked as sequences use a dash in front of every item. Mapping keys are displayed in bold font, and multiline strings preserve the whitespace. When you run the script against some test data, then it’ll output a piece of HTML code that you can redirect to a local file, which you can open with your default web browser: The resulting page will let you expand and collapse the individual key-value pairs interactively when previewed in a web browser: Notice how the web browser renders the Base64-encoded image depicting a smiley face. You’ll find the final code in the collapsible section below: All right, that’s all when it comes to parsing YAML documents at a low level using the PyYAML library. The corresponding and functions work the other way around by taking a sequence of events or the root node, respectively, and turning them into a YAML representation. But you’ll rarely need to use them."
    },
    {
        "link": "https://pypi.org/project/PyYAML",
        "document": "A required part of this site couldn’t load. This may be due to a browser extension, network issues, or browser settings. Please check your connection, disable any ad blockers, or try using a different browser."
    }
]