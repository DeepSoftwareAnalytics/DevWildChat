[
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/HTML/Element/fieldset",
        "document": "There are several special styling considerations for .\n\nIts value is by default, and it establishes a block formatting context. If the is styled with an inline-level value, it will behave as , otherwise it will behave as . By default there is a border surrounding the contents, and a small amount of default padding. The element has by default.\n\nIf a is present, it is placed over the border. The shrink-wraps, and also establishes a formatting context. The value is blockified. (For example, behaves as .)\n\nThere will be an anonymous box holding the contents of the , which inherits certain properties from the . If the is styled with or , then the anonymous box will be a grid formatting context. If the is styled with or , then the anonymous box will be a flex formatting context. Otherwise, it establishes a block formatting context.\n\nYou can feel free to style the and in any way you want to suit your page design."
    },
    {
        "link": "https://swimm.io/learn/code-documentation/code-documentation-javascript-methods-and-best-practices",
        "document": "JavaScript code documentation is a detailed explanation of JavaScript code that helps developers understand its functionality and how to use or modify it. It could range from simple inline comments explaining a complex piece of code to comprehensive guides detailing how an entire JavaScript library works.\n\nCode documentation is an important part of a JavaScript codebase. Without adequate documentation, it becomes challenging to understand the code, especially when working on large projects or when the original developer is not available.\n\nThere are several methods to document Javascript code, including inline comments, JSDoc comments, which can be used to auto-generate code documentation, and README files.\n\nWhen a new developer joins a project, they often spend a significant amount of time understanding the codebase. Clear, concise, and comprehensive JavaScript code documentation can expedite this process, making it easier for new team members to understand the codebase and start contributing quickly.\n\nOn a team project, it’s not uncommon to have multiple developers working on different parts of the codebase simultaneously. Clear and consistent JavaScript code documentation ensures that everyone on the team can understand the code, regardless of who wrote it. JavaScript code documentation serves as a highly effective communication tool within teams.\n\nJavaScript code documentation also plays a critical role in quality assurance, testing, and debugging. Good documentation provides insight into what the code is supposed to do, which can help identify discrepancies between the intended and actual behavior of the code.\n\nDuring testing and debugging, well-documented code makes it easier to understand the logic and functionality that’s being tested.\n\nInline comments are one of the simplest forms of JavaScript code documentation. These are notes written directly in the code, usually above or beside the code they’re explaining. These comments are invaluable for explaining complex or tricky parts of the code.\n\nHere are two ways to create inline comments in JavaScript code:\n\nJSDoc is a popular documentation standard for JavaScript. It allows developers to write documentation directly in their code using a special syntax that can be parsed by documentation generation tools.\n\nJSDoc comments start with /** and end with */. They can include tags that provide additional information about the code, such as @param to describe function parameters, or @return to explain the return value of a function. For example:\n\nIn this example, we have a function called add() that takes two parameters a and b and returns their sum. You can see that the JSDoc comment block starts with /** and ends with */.\n\nREADME files and external guides are other forms of JavaScript code documentation. A README file usually provides a high-level overview of the project, including the purpose of the code, how to install and run it, and examples of usage.\n\nExternal guides, on the other hand, can be more comprehensive and detailed. They can explain the architecture of the code, provide walkthroughs and tutorials, and offer in-depth explanations of complex features.\n\nFunctions and methods are the building blocks of any JavaScript application. Therefore, they should be documented thoroughly. Each function or method’s documentation should explain what it does, its input parameters, its return value, and any side effects it might have.\n\nJavaScript is well-known for its asynchronous features, like promises and callbacks. However, these can sometimes be tricky to understand. Therefore, it’s essential to clearly document the behavior of any asynchronous function, Promise, or callback in your code, including when and how they resolve or reject.\n\nMarkdown is a lightweight markup language that can be used to format text, making it more readable and engaging. It’s particularly useful in README files and external guides, where you can use it to create headings, lists, links, and code snippets.\n\nConsistency is key when it comes to JavaScript code documentation. By following a consistent style guide, you ensure that all documentation in the project is uniform and easy to understand. This could include rules about the use of language, code examples, and the structure of the documentation.\n\nThere are several tools available that can help automate the process of generating JavaScript code documentation. These tools can parse your code and its associated comments to generate beautiful, easy-to-navigate documentation. Examples include JSDoc, ESDoc, and Docco.\n\nRelated content: Read our guide to code documentation best practices\n\nJavaScript code documentation plays a pivotal role in ensuring codebase clarity, team collaboration, and quality assurance. It serves as a vital resource for onboarding new developers, facilitating team coordination, and aiding in the testing and debugging processes. To effectively document JavaScript code, developers have various methods at their disposal, including inline comments, JSDoc comments, and README files.\n\nSwimm’s automation capabilities can further enhance the documentation process, providing an efficient way to create and maintain JavaScript code documentation. Swimm’s code-coupled documentation ensures that documentation remains up to date as code changes, simplifying the task of keeping documentation accurate and useful for both new and experienced developers."
    },
    {
        "link": "https://developer.wordpress.org/coding-standards/inline-documentation-standards/javascript",
        "document": "WordPress follows the JSDoc 3 standard for inline JavaScript documentation.\n\nWhat Should Be Documented\n\nJavaScript documentation in WordPress takes the form of either formatted blocks of documentation or inline comments.\n\nThe following is a list of what should be documented in WordPress JavaScript files:\n\nShort descriptions should be clear, simple, and brief. Document “what” and “when” – “why” should rarely need to be included. The “why” can go in the long description if needed. For example:\n\nFunctions and closures are third-person singular elements, meaning third-person singular verbs should be used to describe what each does.\n\nFunctions: What does the function do?\n\n: The recommended tool to use when searching for the version something was added to WordPress is .\n\nIf, after using these tools, the version number cannot be determined, use .\n\nCode Refactoring: Do not refactor code in the file when changes to the documentation.\n\nDescriptive elements should be written as complete sentences. The one exception to this standard is file header summaries, which are intended as file “titles” more than sentences.\n\nThe serial (Oxford) comma should be used when listing elements in summaries, descriptions, and parameter or return descriptions.\n\nThe following guidelines should be followed to ensure that the content of the doc blocks can be parsed properly for inclusion in the code reference.\n\nShort descriptions should be a single sentence and contain no markup of any kind. If the description refers to an HTML element or tag, then it should be written as “link tag”, not “<a>”. For example: “Fires when printing the link tag in the header”.\n\nMarkdown can be used, if needed, in a long description.\n\nNo HTML or markdown is permitted in the descriptions for these tags. HTML elements and tags should be written as “audio element” or “link tag”.\n\nDocBlock text should wrap to the next line after 80 characters of text. If the DocBlock itself is indented on the left 20 character positions, the wrap could occur at position 100, but should not extend beyond a total of 120 characters wide.\n\nRelated comments should be spaced so that they align to make them more easily readable.\n\nFunctions should be formatted as follows:\n• Summary: A brief, one line explanation of the purpose of the function. Use a period at the end.\n• Description: A supplement to the summary, providing a more detailed description. Use a period at the end.\n• : Only use for deprecated functions, and provide the version the function was deprecated which should always be 3-digit (e.g. ), and the function to use instead.\n• : Should be 3-digit for initial introduction (e.g. ). If significant changes are made, additional tags, versions, and descriptions should be added to serve as a changelog.\n• : Only use for functions if private. If the function is private, it is intended for internal use only, and there will be no documentation for it in the code reference.\n• : List mixins that are mixed into the object.\n• : If this function is first assigned to a temporary variable this allows you to change the name it’s documented under.\n• : Namespace that this function is contained within if JSDoc is unable to resolve this automatically.\n• : For classes, used to mark that a function is a static method on the class constructor.\n• : URL that provides more information.\n• : Event fired by the function. Events tied to a specific class should list the class name.\n• : Events this function listens for. An event must be prefixed with the event namespace. Events tied to a specific class should list the class name.\n• : Marks this function as a global function to be included in the global namespace.\n• : Give a brief description of the variable; denote particulars (e.g. if the variable is optional, its default) with JSDoc syntax. Use a period at the end.\n• : For generator functions, a description of the values expected to be yielded from this function. As with other descriptions, include a period at the end.\n• : Note the period after the description.\n\nBackbone’s calls should be formatted as follows:\n• This tag will allow JSDoc to recognize the function from Backbone as a class definition. This should be placed right before the Object that contains the class definition.\n\nBackbone’s functions should be formatted as follows:\n• Summary: A brief, one line explanation of the purpose of the function. Use a period at the end.\n• Description: A supplement to the summary, providing a more detailed description. Use a period at the end.\n• : Only use for deprecated classes, and provide the version the class was deprecated which should always be 3-digit (e.g. ), and the class to use instead.\n• : Should be 3-digit for initial introduction (e.g. ). If significant changes are made, additional tags, versions, and descriptions should be added to serve as a changelog.\n• : Marks this function as the constructor of this class.\n• : List mixins that are mixed into the class.\n• : Lists modules that this class requires. Multiple tags can be used.\n• : If this class is first assigned to a temporary variable this allows you to change the name it’s documented under.\n• : Namespace that this class is contained within if JSDoc is unable to resolve this automatically.\n• : For classes, used to mark that a function is a static method on the class constructor.\n• : URL that provides more information.\n• : Event fired by the constructor. Should list the class name.\n• : Document the arguments passed to the constructor even if not explicitly listed in . Use a period at the end.\n\nIf a Backbone class does not have an initialize function it should be documented by using as follows:\n\nAt times functions will be assigned to a local variable before being assigned as a class member.\n\n Such functions should be marked as inner functions of the namespace that uses them using .\n\n The functions should be formatted as follows:\n\nAt times classes will have Ancestors that are only assigned to a local variable. Such classes should be assigned to the namespace their children are and be made inner classes using .\n\nClass members should be formatted as follows:\n• Short description: Use a period at the end.\n• : Should be 3-digit for initial introduction (e.g. ). If significant changes are made, additional tags, versions, and descriptions should be added to serve as a changelog.\n• : If the members is private, protected or public. Private members are intended for internal use only.\n• : List the type of the class member.\n• List all properties this object has in case it’s an Object. Use a period at the end.\n• : Optionally use this to override JSDoc’s member detection in place of to force a class member.\n• : Optionally use this to override what class this is a member of.\n\nNamespaces should be formatted as follows:\n• Short description: Use a period at the end.\n• : Marks this symbol as a namespace, optionally provide a name as an override.\n• : Should be 3-digit for initial introduction (e.g. ). If significant changes are made, additional tags, versions, and descriptions should be added to serve as a changelog.\n• : Namespace that this namespace is contained in.\n• : Properties that this namespace exposes. Use a period at the end.\n\nInline comments inside methods and functions should be formatted as follows:\n\nImportant note: Multi-line comments must not begin with (double asterisk). Use (single asterisk) instead.\n\nThe JSDoc file header block is used to give an overview of what is contained in the file.\n\nWhenever possible, all WordPress JavaScript files should contain a header block.\n\nWordPress uses JSHint for general code quality testing. Any inline configuration options should be placed at the end of the header block."
    },
    {
        "link": "https://github.com/cancerberoSgx/javascript-documentation-examples/blob/master/examples/typedoc-tutorial-basic/docs/tutorial.md",
        "document": "In this tutorial you will learn how to document your TypeScript projects using TypeDoc, a tool that will extract descriptions from your TypeScript source comments and generate a well organized and pretty HTML documentation.\n\nIt is required that you know the basics of TypeScript, but besides that, this tutorial will start from scratch.\n\nThis section is oriented to those with no experience with any JsDoc-like technology. If you are familiar with JsDoc, javadoc or related technology, skip it and proceed to next section.\n\nTypeDoc is an API documentation generator for TypeScript projects, similar to JsDoc or javadoc.\n\nBasically, you add documentation comments directly to your source code, right alongside the code itself. The TypeDoc tool will scan your source code and generate an HTML documentation website for you.\n\nIn general you will be documenting entities like classes, interfaces, methods, functions, etc.\n\nAlthough configurable, TypeDoc will generate documentation of everything in your source, even things that are not documented like their names, types and relationships.\n\nUnlike JsDoc, with TypeDoc you only take care of descriptions and you never document types, names member modifiers or any other data that is already expressed in the TypeScript code: that work is automatically performed by the TypeDoc tool.\n\nFor adding a description to some entity in the code you must use special comments that must be placed immediately before the code being documented.\n\nEach comment must start with a sequence in order to be recognized by TypeDoc. Comments beginning with , , , or more than 3 stars will be ignored. Example:\n\nHere you can see the output generated by TypeDoc: classes/fruit.\n\nTypeDoc will format descriptions with MarkDown, in concrete it uses the Marked markdown parser and HighlightJS to highlight code blocks within markdown sections. In the following example, notice how we use markdown to write multiple paragraphs, bold text and an example code snippet:\n\nHere you can see the output generated by TypeDoc: globals.html#minify.\n\nTypeDoc will extract the information of entities found in TypeScript source code such as classes, methods, functions, names, types, etc, and will associating the comment descriptions, if any, to each entity. But sometimes, we want to describe more than one entity in a comment, or often, a high level concept that the TypeScript language simply doesn't support as we will see. In those cases we use what we call comment (also known as comment annotations).\n\nTags are special words in comment descriptions that start with . For example, when describing a function, we must describe its subparts like parameters and return value and for doing that in the same comment, we use tags for identify each subpart, for example:\n\nHere you can see the output generated by TypeDoc: globals.html#startapplication.\n\nAs you can see, we described the entire method declaration in a single comment, starting with the method description, its parameters and last the return value. We needed to use tags and to indicate which part of the method each description is documenting.\n\nThe complete list of tags supported by TypeDoc is here: list of tags.\n\nIn the following example we focus only on classes and interfaces, later we will see properties and methods documentation in detail. It declares an interface which is generic and a class implementing it.\n\nThis is the output of the interface: interfaces/shape and this is the output of the class: classes/mycustomrectangle\n\nSome details about what we just did:\n• We used the double star comment ( ) just before the interface declaration\n• The first line of the comment is the interface description\n• We documented the interface's generic type using the tag then the name of the type parameter followed by its description.\n\nTIP: classes vs interfaces in documentation . If you are working with interfaces (hiding implementation details from your users), then you should only document interfaces instead of classes. Document classes only to give details about the implementation, if that's what you want, but make sure you don't repeat information that's already in the interface\n\nYou can describe properties of classes, interfaces, objects, enums, etc by adding a comment just before the property declaration. The same for variables declared with , or .\n\nIn the following example we document properties of several entities, including , , , and variable declarations:\n• We didn't document types, names or modifiers of the properties, typedoc will do that automatically.\n• We even added descriptions to property which type is an object literal. Is unlikely you want to document the properties of object literals like that (you probably want to define interfaces) but just in case it's supported. ee how it looks in the output: interfaces/gameunit.html#status\n• Property accessors are documented like a property and is not necessary to document both the setter and the getter, is enough to document only one of them: classes/game.html#currenttime\n• At the end of the example we documented a global variable, although is unlikely to document variables, it's also possible : globals.html#gamecontainer .\n\nMethods and Functions could be the most complex parts of document, because thy imply parameters and return values. For these, you will be using two tags: and or respectively.\n\nBecause documenting methods and functions is the same thing, here we will say just \"methods\" but everything applies to both.\n\nThe syntax of a method or function TypeDoc comment is as follows: first the method description and then the rest. The order of parameters is not important.\n\nLet's go straight to an example that shows a lot of combinations regarding this:\n• The class defines a constructor which is not documented but the output still is generated: classes/file.html#constructor\n• The static method that is generic and has a parameter with a default value. Notice how we document the generic type using : classes/file.html#create\n• And last but not least, the function which shows how to document the complex parameter object and has a generic parameter : globals.html#listfiles\n\nImportant: Again, as with anynthing in TypeDoc we never describe information already defined in the TypeScript code, like names, types and modifiers like if a parameter is optional, default parameter values, if a method is private or static, etc.\n\nAs with anything in TypeDoc documenting parameters is optional. For describing a parameter we use the syntax where `PARAMETER_NAME``must match with one of the names of the parameters in the method or function signature.\n\nUnfortunately the TypeScript compiler won't validate this so we must careful when renaming parameters.\n\nTIP: if you use the \"Rename\" refactor tool of typescript for renaming a parameter, the @param will be also renamed so make sure you always use that tool instead of renaming manually.\n\nFor return values, you can use or and then the description of what is returned when the method or function is invoked.\n\nTIP: Make sure and descriptions add value. Don't write them just because of the sake of writing. If you choose well your methods and parameter names descriptions often arenot needed. If you omit documenting a parameter or return type, its documentation will be still generated by TypeDoc (even if its type is or )\n\nIn the previous example, the interface overrides the method of its parent interface and declare two signatures. Take moment to see how TypeDoc generates the output for this case: interfaces/fileemitter.html#on\n\nTL;DR : Three techniques to represent and document events with TypeDoc are presented in this section, each of them with its own pros and cons. If you want to play safe and do what the majority of TypeScript developers are doing, then use technique 1. If you want to represent your events optimally then go technique 3.\n\nFirst of all sorry for the long section, but really I don't think there is A way of declaring and documenting events today so I needed to be detailed here.\n\nJavaScript and TypeScript programming languages don't support the concept of events. Nevertheless, events usually they are an important part of APIs. This is why many technologies oriented to documentation, like TypeDoc, JsDoc, YuiDoc, EsDoc, support the concept of events using tags like , , , , etc.\n\nOne common pattern to semantically define events in these technologies, is treating events as methods, where then the event is a member of the emitter, the event name acts as member name and the listener signature is the method signature. But again, this is not written in stone and there are several ways of represent events, depending on the scenario and the technology, as we will see.\n\nLet's agree on the objective. The tags , or are, BTW missleading. What we really want to declare and document when we talk about \"events\" is the relationship that exists between an event name, an emitter and the protocol used to emit: the listener signature. The objectvie is to document the relationship that exists between those three things (not just an event name).\n\nWe will present three different ways of accomplish this, trying to describe objects that emit two events and ' and extends node.js (Our example is a simplified fragment of the official node.js type declaration :\n\nThis technique is just adding the tag to each signature:\n\nThis is the output interfaces/readable1.html . As you can see our interface shows now, instead of a method, an event.\n\nIt's relevant to note that this technique takes advantage of explicit method overloading done by TypeScript developers, to ensure method calls match signatures exactly. Since there is a signature for each event name (with a parameter default value being the event name) this more or less describe the event names and corresponding listener signatures. The tag just mark the methods visually so we know those signatures contain information about events.\n\nThis is the output classes/readable2.html.\n\nDeclare event names as constants static properties. Add the tag to them. We keep overloading the method to force typechecking when calling it and the trick for it to work declare the type of the constants and parameters as a string literal: this together with this: .\n\nEvents are still encapsulated as member of the class and the relationship between event names and listener signatures is sill maintained and visible.\n\nTypeDoc documentation uses a technique similar to this one.\n\nThis technique is my favorite IMO represents events optimally in typedoc output, but also it could be a little bit hard to accomplish. Is similar to technique 1 but we don't add the @event tag to methods (which is confusing) but to listener type declarations that are outside the class.\n\nSee the output: This is the output interfaces/readable3.html.\n\nWhy do I consider 3 better than 1 and 2:\n• It doesn't pollute (or force me to) the members of the class/interface. Technique 1 transform the method to an event. The method disappear and the event named `addListener doesn't make any sense. Technique 2 force me to create event name static properties\n• But most important I think, 1 and 2 fail because relationship between event names and listener signature is hidden inside a method method overriding.The event names appear all stacked, as parameter types, all stacked below sommething called \"addListener\" which is very confusing. This 3rd technique outputs individual events with their correct names together with the listener signature all in an individual event member desattached from\n• Also it allows me to declare all this information using interfaces. I've also realized also that encapsulating listener type in a declaration is a good idea to enforce typecheking when there are lots of events with complex different listener signatures\n\nI will briefly explain it. The objectives are not contimate our classes with artificial entities ,maintain the relationship between event names and listener signatures and enforce types on addListener call\n\nUnfortunately it requires the TypeDoc plugin as-member-of. Basically what we are doing is declaring the listener signature outside the class as a function type and then instructing the plugin to move as a member of the interface. Because it has the @event tag it will be converted to an event member of the interface. More details in the plugin page.\n\nWhen we are describing an entity sometimes we want to reference another entity. For example, when describing the method I want to write a link that points to the class so users can quickly navigate while reading its description. That's what we call referencing.\n\nWith TypeDoc is very easy to achieve this, you just put the name of the referenced entity between double squared brackets. In the previous example would be [[Ocean]].\n\nYou can reference any entity that has a comment like classes, interfaces, methods, functions, properties, etc. You cannot reference a method parameter because it doesn't contain its own comment: the parameter description is inside a method or function comment.\n\nAlso take in account that a name can be repeated, for example, two classes can contain methods with the same name, or two modules contain classes with the same name. In those cases, the closest entity will takes precedence if we need to reference the external reference we need to use absolute names. Example:\n• In method's description, we just used since that property is in the same class: interfaces/car.html#start\n• But in property description, for referencing the 's property, we needed to use its absolute name since already has a property with that name: interfaces/car.html#engine\n\nif you use a lot of references, you can run the command line tool with the argument:\n\nIf we don't want some class method or other entity to appear at all in TypeDoc output we use the tag.\n\nImportant: Put at the very top of the comment related to the entity you want to ignore.\n\nYou can ignore any entity that can be documented with its own comment, for example classes, methods, properties, etc. But you can't ignore parameters or return values because these doesn't have its own comment.\n\nIn the following example, the output will only contain but not `method1()``:\n\nHere you can see the output generated by TypeDoc: interfaces/somethingsareignored.\n\nThe following example makes TypeDoc to ignore the whole class:\n\nHere you can see the output generated by TypeDoc: classes/classtotallyignored.\n\nYou can also configure TypeDoc tool to ignore all entities that are not public or all entities that are not exported. For that you must use the configuration options:\n• all options should be in http://typedoc.org/guides/usage/\n\nInstead of passing all configuration as command line arguments, you can create a or file (the name is not important) with the configuration properties in it and then call . Example of file:\n\nSince configuration is declared as JavaScript / TypeScript file it's easy to implement extends. For example, this configuration extends previous one and will use typedoc-plugin-markdown to generate Markdown output:\n\nTypedoc is an extensible framework which support easy implementation of plugins that can analyze and transform the input, AST or output. Plugins can extend TypeDoc in several ways, from supporting new tags, parsing comments differently, to generating output in different formats, etc. We will detail how to install and use a TypeDoc plugin, in this case typedoc-plugin-markdown which allow typedoc tool to generate markdown output instead of HTML.\n\nInstalled plugins are loaded automatically by typedoc tool so installing a plugin is all you need to do in order to use it. In other words, after installing a plugin, tool will load them out of the box when executed so you don't have to do anything special. If you want to prevent plugins to execute or execute just one plugin from all currently installed you use the plugin option:\n\n- Specify the npm plugins that should be loaded. Omit to load all installed plugins, set to 'none' to load no plugins.\n\nIn the particular case of this plugin, as indicated in its documentation we must use to generate Markdown output. But that's it, as said before we don't need to use since it's loaded automatically:\n\nSee generated markdown output for this tutorial code."
    },
    {
        "link": "https://medium.com/@bdunn313/documenting-javascript-projects-f72429da2eea",
        "document": "We all (hopefully) know how important good documentation and reference material is to a successful software project. Without good documentation, a particular library may be next to impossible to use. Without a reference to how different components and methods work in isolation, let alone examples of how all the different pieces of a project fit together with each other, we are left to interpret the original intention of the author merely by reading the original source code, or if we are lucky, reaching for StackOverflow and googling random error messages. If this is an in-house or small project, you are probably completely screwed. Enter the copy-pasta black magic voodoo approach and hope that everything works as intended!\n\nContrast this with well-established projects that have great documentation, and the experience is quite the opposite. Stripe’s API documentation, for example, is not only clean and pleasing to look at, but easy to navigate, and is completely annotated with examples in 8 separate languages in how to properly interact with their developer API. Want to know how to create a new customer? Sure! Which language do you want to write the code in?\n\nThis level of robustness becomes necessary with huge, publicly consumed projects such as Stripe payments, but may not be necessary for your in-house or smaller projects. This doesn’t meant that you get to skimp on documentation! It just means that our goal for documenting our personal projects should be to get the most bang for our buck. The way we can do this is by properly commenting our code and leveraging existing tools in the Javascript community to give us nice, useful documentation with the least effort required.\n\nIn this article, we will be going over how to use two different tools, namely JSDoc and Documentation.js, to get nice, coherent API-level documentation for your Javascript code with minimal effort. At 4Thought Studios, we’re a big fan of using Flow, so we will throw that in too to make things even smoother. In an effort to be as useful and brief as possible, we will not dive into the full syntax of JSDoc, but its worth saying that THEIR documentation (although not pretty to look at) is very readable and worth spending the 20 minutes or so to read through at least once.\n\nJSDoc is a standardized way of writing comments in your code to describe functions, classes, methods, and variables in your codebase. If you are familiar with JavaDocs, or any derivative (like those available in the PHP world) then JSDocs will be familiar to you. The ideas is that we describe how our code works with a few special keywords and formatting conventions, and we can use a parser to run through all of our commented code and generate nice, readable documentation based off of the comments we write.\n\nWhat does this look like in practice? Here’s a short example:\n\nSo what’s going on in this example? Well, we first signify we are about to write a special JSDoc comment by starting the comment with . Starting with just one star, or adding a third star tells JSDoc to ignore the comment entirely — so pay attention to the number of stars!\n\nNext, we write out a brief description for the function we are documenting in plain English, so someone reading through our code or API documentation understands the function’s purpose in the codebase. Finally, we annotate our two parameters as a number, as well as annotating our return as a number. And… that’s basically it!\n\nWe could get a bit fancier with a more complicated example, but generally speaking, this is as much work that you have to do when documenting your code. You could take things further and add an annotation, giving even more context to how this code should be used. But at the end of the day, this is as far as you need to go while documenting your codebase.\n\nOnce your codebase is sufficiently documented, it’s time to reach for a tool that will help you generate documentation based on all the nice comments you just wrote. At 4thought Studios we use the fantastic Documentation.js project, but there are several more options out there if you prefer another route. All of these projects achieve the same thing — they translate your carefully written JSDoc code comments into readable html or markdown documentation.\n\nDocumentation.js is a node package designed to parse JSDoc and output your documentation in several different formats. We use Markdown so that we can link to the API documentation directly in our project wiki, but it might make more sense for you to output the docs as a fully-functioning website. Whichever approach you choose, you’ll have to introduce Documentation.js as either a system-wide or project-level dependency:\n\nThen we can reference Documentation.js’s documentation (say that 5 times fast) to figure out how to parse our javascript files into readable documentation (I’m sorry for being repetitive — I don’t think that there’s any other way to say ‘documentation’).\n\nWe use the package to documentation from the source file(s) specified, and format it as html with the flag. We could instead output the documentation as markdown, and to do this we would change the above command to:\n\nI know what you are thinking right now — this is all great, but does that mean I have to parse my files one at a time? This isn’t time saving at all!\n\nHold your horses — of course you don’t have to parse files one at a time! Let’s say that all of your javascript files exist in a folder in your project. You can parse everything in one fell swoop:\n\nThis will parse all of your javascript files in the src folder, and subdirectories, format it as html, and output the results to a directory. Pretty neat!\n\nFor bonus points, once you have the above command working as you want it to, include it as an additional script in your package.json folder to make your life easier in the future:\n\nAnd now you can refresh your docs by running:\n\nIf you utilize flow like we do at 4Thought Studios, we can make life even easier when it comes to documentation. Why re-write the type information of your parameters when you are already writing out all of your parameter and return types in your code?\n\nWith Documentation.js’s Flow integration we can change our original example to this:\n\nAnd we will still get the same results when it comes time to build our documentation!"
    },
    {
        "link": "https://stackoverflow.com/questions/26104525/best-practices-for-where-to-add-event-listeners",
        "document": "Short answer: definitely do it the first way. Event delegation is way more performant, but requires extra conditionals in your code, so it's basically a complexity versus performance tradeoff.\n\nLonger Answer: For a small number of elements, adding individual event handlers works fine. However, as you add more and more event handlers, the browser's performance begins to degrade. The reason is that listening for events is memory intensive.\n\nHowever, in the DOM, events \"bubble up\" from the most specific target to the most general triggering any event handlers along the way. Here's an example:\n\nIf you clicked on the tag, that click event would fire any event handlers in this order:\n\nEvent delegation is the technique of listening to a parent (say ) for a bunch of event handlers instead of the specific element you care about (say ). The event object will have a target property which points to the specific dom element from which the event originated (in this case ).\n\nYour code for event delegation might look something like this:\n\nFor more information checkout Dave Walsh's blog post on Event Delegation or duckduckgo \"event delegation\".\n\nNOTE ON CODE SAMPLE IN OP: In the first example, means that the specific thing clicked on must have the class editable for the if block to execute. As one of the commenters pointed out, that's probably not what you want. You might want to try something along these lines instead:\n• - anything that on the page that was clicked converted to jQuery\n• - find all the ancestors of the element clicked, then filter to only include ones with the class \"editable\"\n• - this should be an integer. If 0, this means there are no parents with \"editable\" class"
    },
    {
        "link": "https://medium.com/@francesco.saviano87/mastering-javascript-events-how-to-handle-user-actions-with-ease-9c50f29816b8",
        "document": "JavaScript events are the backbone of making modern websites interactive. They allow developers to capture user actions like clicking a button, scrolling through a page, or submitting a form. Mastering event handling is key to creating responsive web applications that enhance user experience. Whether you’re building a simple form validation or a complex web game, understanding how events work will save you time and allow you to build dynamic, engaging user interfaces.\n\nIn this post, we’ll dive into JavaScript events — what they are, how to use them, and why they’re crucial for modern web development. You’ll learn the different types of events, how to capture them, and best practices for handling user actions. This guide is perfect for beginner developers looking to take their JavaScript skills to the next level.\n\nBy the end, you’ll be confident in using events to build more interactive and engaging web applications.\n\nPlease note that this content was crafted with the assistance of ChatGPT, an artificial intelligence language model developed by OpenAI. The author has overseen and refined AI’s contributions to ensure adherence to editorial standards and the accurate reflection of the intended messaging.\n\nWhat Are JavaScript Events and Why Do They Matter?\n\nAt the heart of every interactive web application are JavaScript events. These events are actions or occurrences — like clicking a button, typing into a form, or resizing a window — that happen in the browser and are detected by JavaScript. By responding to these events, you can create dynamic websites that provide instant feedback to users.\n\nIn JavaScript, events can be triggered by both users and the browser itself. For example, a user may trigger a mouse event by clicking on a button, or the browser might trigger a window event when a page finishes loading. JavaScript events make it possible to capture these actions and execute code that modifies the page without needing to reload it.\n\nThe significance of events lies in their ability to make web pages feel more responsive. Without event handling, websites would function as static documents where every interaction requires a full page reload — much like the web of the late 90s. By learning how to handle events in JavaScript, you can dramatically enhance the user experience, making your web applications more fluid and engaging.\n\nHow Do You Listen for Events in JavaScript?\n\nIn JavaScript, the most common way to interact with events is by listening for them. Listening for an event means waiting for a specific action to occur, like a button click, a keypress, or a mouse hover, and then executing a function in response. There are two main methods for adding event listeners in JavaScript:\n\nInline event handlers involve embedding the event-handling function directly in the HTML element. For example, you might use the attribute to trigger an event when a button is clicked:\n\nWhile this method is simple and easy to understand, it has several drawbacks. Inline event handlers mix HTML and JavaScript code, which can make your code harder to maintain and debug as your project grows. Additionally, inline event handlers are less flexible, as you can only bind one event handler per element.\n\nThe recommended and more flexible approach to event handling is using the method. This method allows you to attach multiple event handlers to a single element and keeps your JavaScript code separate from your HTML.\n\nHere’s an example using :\n\nWith , you can attach as many event listeners as you need to any element, making it ideal for complex, interactive web applications. It also provides better control over when and how events are triggered, and allows for more efficient event delegation, which we’ll cover later in this post.\n\nDifferent Types of Events You Can Handle\n\nJavaScript events come in various forms, each triggered by different user actions or browser behaviors. Understanding these event types is essential for crafting dynamic web applications that can react to anything the user does. Let’s dive into some of the most common categories of events and what they represent:\n\nMouse events are some of the most frequently used in web development. They are triggered by actions like clicking, hovering, or dragging with the mouse. Examples include:\n• : Fired when a user clicks on an element.\n• : Occurs when the mouse pointer moves over an element.\n• : Fires when the pointer leaves an element.\n\nThese events are invaluable for creating interactive UI components like buttons, image galleries, and navigation menus.\n\nKeyboard events are triggered when a user interacts with their keyboard. These are especially useful for handling form inputs or creating keyboard shortcuts:\n• : Fires when a key is pressed down.\n• : Deprecated, but was used to detect keypresses.\n\nWith keyboard events, you can create rich interactions like form validation, shortcuts, or even entire games controlled by keyboard input.\n\nForm elements like input fields, text areas, and select boxes often need special attention. Form events are used to capture and respond to changes in these elements:\n• : Triggered when the value of an input element changes.\n• : Fires when an element gains focus (e.g., when a user clicks on a text box).\n\nForm events make it easy to create interactive forms that validate data on the fly, ensuring that user input meets your application’s requirements before submission.\n\nWindow events are triggered by actions that involve the browser window or document. These are particularly useful when building responsive layouts or when detecting user actions like resizing or scrolling:\n• : Fired when the entire page has finished loading.\n• : Triggered when the browser window is resized.\n• : Fired when the user scrolls within the document.\n\nWindow events are crucial for implementing features like lazy loading of images, sticky headers, or infinite scrolling.\n\nEach of these event categories offers unique ways to interact with users, enabling you to make your web applications more dynamic and responsive.\n\nHow to Use Event Listeners: The Method\n\nThe method is the most powerful and flexible way to handle events in JavaScript. It allows you to attach one or more event handlers to any DOM element without mixing JavaScript directly into your HTML. Unlike inline event handlers, which only allow one function per event, lets you assign multiple functions to a single event, making it the preferred choice for modern web development.\n\nThe basic syntax of is:\n• : The type of event to listen for, like , , or .\n• : The function to execute when the event is triggered.\n• (optional): A boolean that defines whether the event should be captured or bubbled. We’ll discuss this more in the event propagation section.\n\nHere’s a simple example where an event listener is added to a button element:\n\nIn this example, when the button is clicked, the event triggers the anonymous function, which displays an alert message.\n\nWhy Use Over Inline Handlers?\n\nThere are several advantages to using over older methods like inline event handlers:\n• Multiple Event Handlers: With , you can attach several event listeners to the same element and event type. For example, you could log a message in the console and change a button’s color with two different functions.\n\n2. Separation of Concerns: By keeping your JavaScript and HTML separate, your code becomes easier to read, maintain, and debug. This approach is more scalable for larger applications.\n\n3. Capturing and Bubbling Phases: You can control when the event is triggered during its propagation through the DOM. More on this when we discuss event propagation.\n\nUsing is considered a best practice because it keeps your HTML clean, allows for multiple handlers, and provides greater control over how events are processed in your application.\n\nWhen you click on an element in a web page, the event doesn’t just stop there — it can travel through multiple elements. This movement of an event through different layers of the DOM is known as event propagation. In JavaScript, event propagation occurs in two main phases: bubbling and capturing. Understanding these phases is crucial for managing event behavior in complex layouts or nested elements.\n\nBy default, most events in JavaScript follow the bubbling phase, which means the event starts from the target element (the one that was clicked or interacted with) and “bubbles up” through its parent elements, all the way to the root of the document.\n\nFor instance, if you have a button inside a , and the button is clicked, the event will first be handled by the button, then by its parent , and eventually by the of the document.\n\nIf you click on the button, both the button’s and the div’s event listeners will trigger, logging messages to the console in that order. This is because the event bubbles from the button to the parent .\n\nThe capturing phase, also known as trickle-down, occurs before the bubbling phase. During this phase, the event starts at the document’s root and moves down toward the target element. By default, JavaScript events don’t use the capturing phase unless explicitly specified.\n\nYou can enable capturing by passing a third argument ( ) to :\n\nIn this case, the would catch the event before the button does, because the event is captured as it \"trickles down\" through the DOM.\n\nLet’s demonstrate the difference with both phases enabled:\n\nWhen you click the button, the console will log:\n\nThis shows how the event travels down the DOM during the capturing phase and then bubbles up after reaching the target.\n\nWhen to Use Bubbling and Capturing\n\nEvent bubbling is generally used more often because it’s the default behavior, and it works well for most cases. However, event capturing can be useful when you need more control over how events are processed, especially in complex layouts or when dealing with nested elements.\n\nIn many cases, when a user triggers an event — like submitting a form or clicking a link — the browser will automatically carry out a default action. For instance, submitting a form refreshes the page, and clicking a link takes the user to a new URL. However, there are situations where you want to stop these default behaviors from happening. That’s where comes in handy.\n\nWhat Does Do?\n\nThe method is used to stop the browser’s default action for a specific event. Instead of allowing the form to submit or a link to follow its attribute, this method cancels the default action, giving you full control over what happens next.\n\nLet’s say you have a form, and you want to validate the user’s input before submitting it. Using allows you to stop the form from submitting until the validation is successful:\n\nIn this example, if the input field is empty, the form will not submit, and an alert will prompt the user to fill out the required field. Without , the form would submit and refresh the page, making it harder for the user to correct their mistake.\n\nImagine you want to prevent a link from navigating to a new page under certain conditions. For example, you might want to warn the user before they leave the current page:\n\nIn this scenario, if the user clicks “Cancel” in the confirmation dialog, the link won’t be followed, allowing them to stay on the current page. Without , the browser would follow the link immediately after the click.\n• Form Validation: To prevent form submissions when inputs are incomplete or invalid.\n• Link Overrides: To control when and how links are followed, especially in single-page applications (SPAs).\n• Context Menus: To prevent the browser’s default context menu from appearing on right-click.\n\ngives developers more flexibility and control, making it essential for handling advanced event behaviors and improving user experience.\n\nWhen an event is triggered in JavaScript, it creates an event object that contains important information about the event. This object is automatically passed to the event handler function, allowing developers to access properties like the event type, the element that triggered the event, and even the mouse coordinates at the time of the event. By utilizing this information, you can create more interactive and dynamic user experiences.\n\nHere are some of the most commonly used properties of the event object:\n• : This property returns the type of event that was triggered (e.g., , ). It's useful for determining what action took place.\n• : This property provides a reference to the element that triggered the event. You can use to modify the element that was clicked or interacted with.\n• and : These properties return the X and Y coordinates of the mouse pointer when the event was triggered. This is useful for detecting where on the page a user clicked.\n• , , and : These boolean properties return if the Alt, Ctrl, or Shift key was pressed during the event. They can be used to detect keyboard modifiers in conjunction with other events.\n\nExample: Accessing the Event Object in a Click Event\n\nLet’s walk through a practical example where we capture several properties from the event object when a button is clicked:\n\nIn this example:\n• will log , since that’s the event being listened for.\n• will refer to the button that was clicked.\n• and will return the exact mouse coordinates at the time of the click, which can be useful in scenarios like creating custom tooltips or menus that appear at the click location.\n\nUsing the Event Object to Modify Elements\n\nThe event object can also be used to directly modify the appearance or behavior of elements based on user interactions. For example, you could change the background color of a clicked button:\n\nIn this case, the property refers to the button that was clicked, and the property is used to change its color dynamically.\n\nYou can also use the event object to detect whether a modifier key (e.g., Alt, Ctrl, Shift) was pressed during the event. For example, you can modify the behavior of a click event when the Alt key is held:\n\nThis allows you to add custom behavior for keyboard modifiers, which can be useful for creating shortcuts or enhancing accessibility features.\n\nUsing Event Delegation for Better Performance\n\nAs your web applications grow, you may find yourself attaching event listeners to multiple elements. While this works, it can lead to performance issues, especially if your page has many elements or dynamically generated content. This is where event delegation comes in — a technique that lets you handle events efficiently by attaching a single event listener to a parent element instead of each individual child element.\n\nEvent delegation leverages event bubbling, a process where an event triggered on a child element propagates up to its parent elements. Instead of adding separate event listeners to every child, you can attach one listener to the parent element, which will handle events for all its children. This technique is particularly useful when dealing with lists, tables, or dynamically created elements.\n\nLet’s say you have a list of items, and you want to handle click events for each item. Without event delegation, you would need to attach a listener to each list item like this:\n\nWhile this works, it becomes inefficient if the list contains many items. Instead, you can attach the event listener to the parent element:\n\nIn this example, the click event bubbles up from the clicked list item to the parent . By checking if the event’s target is a element, you ensure that the click event is only handled when a list item is clicked.\n• Performance Improvement: Instead of adding multiple event listeners, you can reduce memory usage by attaching just one listener to a parent element. This is especially useful in scenarios where elements are dynamically added or removed.\n• Simpler Code: With event delegation, you don’t have to worry about attaching or removing event listeners for dynamically created elements. The single parent listener handles it all.\n• Scalability: Whether you’re working with a few elements or thousands, event delegation scales well because the number of event listeners remains constant.\n\nImagine a to-do list where users can add new tasks. Instead of attaching event listeners to each task item when it’s created, you can delegate the event to the parent list:\n\nIn this example, the parent manages all clicks on its child elements, even for new items added dynamically. This demonstrates how event delegation simplifies event management and improves scalability.\n\nUnlock your JavaScript potential with ’50 Real-World JavaScript Apps for Beginners and Intermediates.’ Now available for download on both Gumroad and Ko-fi! Start building amazing projects today!\n\nWhile adding event listeners is essential for handling user interactions, it’s equally important to know how to remove them. Attaching too many event listeners or forgetting to remove them when they are no longer needed can lead to memory leaks and performance issues. Fortunately, JavaScript provides the method, which allows you to remove specific event listeners that were added via .\n\nThe syntax for removing an event listener is nearly identical to adding one:\n• : The event type you want to remove (e.g., ).\n• : The exact function that was initially passed to . This must be the same, meaning you cannot remove anonymous functions.\n• : The same value (either or ) that was used when attaching the event listener, specifying whether the listener was added in the capturing or bubbling phase.\n\nConsider the following example where a click event is added to a button and then removed after it is triggered once:\n\nIn this case, the function is passed to both and . As a result, the button will no longer respond to click events once the listener is removed.\n\nOne limitation of is that it requires the exact reference to the function used in . This means if you attached an event using an anonymous function, you won’t be able to remove it:\n\nIn the example above, even though the anonymous functions look identical, they are different in memory, so cannot match them.\n• Store Functions in Variables: To avoid issues with anonymous functions, store your event-handling functions in variables so you can remove them when needed.\n\n2. Remove Unnecessary Event Listeners: It’s a good practice to remove event listeners when they are no longer needed. For instance, in single-page applications, you may want to remove listeners when navigating away from a specific page.\n\n3. Use Option: If you only need an event to trigger once, consider using the option in :\n\nThis automatically removes the event listener after the first trigger, so you don’t need to manually remove it.\n\nFailing to remove unused event listeners can lead to memory leaks, especially when listeners are added to elements that are later removed from the DOM. Always remember to remove event listeners when they are no longer necessary, particularly in long-running applications.\n\nis a critical tool for managing the lifecycle of event listeners in your application. By efficiently adding and removing listeners, you can avoid performance bottlenecks and ensure your web applications run smoothly.\n\nAs you become more comfortable with JavaScript event handling, it’s important to adopt best practices to ensure that your code is efficient, scalable, and maintainable. Poor event handling can lead to performance issues, memory leaks, or hard-to-maintain code, especially as your projects grow in complexity. By following a few key practices, you can prevent these problems and build more robust web applications.\n\nWhile inline event handlers (e.g., using directly in HTML) might seem simple, they mix HTML and JavaScript, leading to less maintainable code. It’s generally best to keep your JavaScript logic separate from your HTML to ensure better organization and easier debugging. Here’s an example of an inline handler you should avoid:\n\nInstead, opt for the method in your JavaScript:\n\nThis approach allows you to keep your HTML clean and your JavaScript in one place, making your code easier to manage and understand.\n\n2. Use Event Delegation When Appropriate\n\nAs we discussed earlier, event delegation allows you to handle events efficiently by attaching a single event listener to a parent element rather than individual listeners to every child element. This not only reduces the number of event listeners in your application but also allows you to handle dynamically added elements without extra code.\n\nThis technique is especially useful when dealing with large datasets or when your page structure is complex. For instance, managing events for a long list of items is much more efficient when using event delegation rather than individual event listeners for each item.\n\nOne of the most common issues with JavaScript event handling is memory leaks caused by forgotten or unnecessary event listeners. If your web application adds a lot of event listeners, it’s crucial to remove them when they’re no longer needed — especially for elements that are removed from the DOM. This ensures that your application doesn’t hold onto memory unnecessarily, which can slow down performance over time.\n\nUse to clean up unused event listeners, particularly when navigating between different views in a single-page application (SPA) or when removing elements dynamically.\n\n4. Use Passive Event Listeners for Scroll and Touch Events\n\nScroll and touch events are fired frequently and can cause performance bottlenecks, especially on mobile devices. By using passive event listeners, you inform the browser that the event handler will not call , allowing the browser to optimize scrolling performance.\n\nHere’s how you can use a passive event listener:\n\nThis small change can result in smoother scrolling and better performance, particularly in mobile browsers.\n\nAccessing the DOM (Document Object Model) is relatively slow, so it’s best to minimize how often you query the DOM inside event handlers. Instead, try caching elements outside the event handler and reusing them:\n\nBy reducing repeated DOM access, you can improve the overall performance of your application, especially if the event handler is triggered frequently, such as with scroll or mouse movement events.\n\n6. Use Throttling or Debouncing for High-Frequency Events\n\nFor events that trigger frequently — such as scroll, resize, or mousemove — it’s best to use throttling or debouncing to limit how often your event handler runs. This ensures that the handler doesn’t run too often, which can affect the performance of your page.\n• Debouncing delays the execution of the event handler until the event stops firing.\n\nIn this example, the event handler only fires 200 milliseconds after the user has finished resizing the window.\n\nBy following these best practices, you’ll write more efficient and maintainable event-driven JavaScript applications. Proper use of , event delegation, and performance optimization techniques will ensure that your code scales effectively as your projects grow in complexity.\n\nJavaScript events are the foundation of creating dynamic and responsive web applications. By mastering event handling, you’ll be able to create interactive user experiences, improve your code efficiency, and ensure scalability in your projects. From understanding event propagation to utilizing event delegation, applying best practices will elevate your development skills.\n\nTo further expand your knowledge on JavaScript events and front-end development, here are some excellent resources:\n• Udemy Web Development Bootcamp: A full-stack course that covers everything from JavaScript to building complete web applications.\n\nWith these tools, you’ll be well-equipped to build robust, interactive web applications. Keep exploring and experimenting with event handling, and you’ll find countless ways to enhance your projects."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Learn_web_development/Core/Scripting/Events",
        "document": "Events are things that happen in the system you are programming, which the system tells you about so your code can react to them. For example, if the user clicks a button on a webpage, you might want to react to that action by displaying an information box. In this article, we discuss some important concepts surrounding events, and look at the fundamentals of how they work in browsers. An understanding of HTML and the fundamentals of CSS, familiarity with JavaScript basics as covered in previous lessons.\n• What events are — a signal fired by the browser when something significant happens, which the developer can run some code in response to.\n• Setting up event handlers using (and ) and event handler properties.\n• Inline event handler attributes, and why you shouldn't use them.\n\nWhat is an event? Events are things that happen in the system you are programming — the system produces (or \"fires\") a signal of some kind when an event occurs, and provides a mechanism by which an action can be automatically taken (that is, some code running) when the event occurs. Events are fired inside the browser window, and tend to be attached to a specific item that resides in it. This might be a single element, a set of elements, the HTML document loaded in the current tab, or the entire browser window. There are many different types of events that can occur.\n• The user selects, clicks, or hovers the cursor over a certain element.\n• The user presses a key on the keyboard.\n• The user resizes or closes the browser window. You can gather from this (and from glancing at the MDN event reference) that there are a lot of events that can be fired. To react to an event, you attach an event handler to it. This is a block of code (usually a JavaScript function that you as a programmer create) that runs when the event fires. When such a block of code is defined to run in response to an event, we say we are registering an event handler. Note: Event handlers are sometimes called event listeners — they are pretty much interchangeable for our purposes, although strictly speaking, they work together. The listener listens out for the event happening, and the handler is the code that runs in response to it happening. Note: Web events are not part of the core JavaScript language — they are defined as part of the APIs built into the browser.\n\nIn the following example, we have a single in the page: Then we have some JavaScript. We'll look at this in more detail in the next section, but for now we can just say: it adds an event handler to the button's event, and the handler reacts to the event by setting the page background to a random color: The example output is as follows. Try clicking the button:\n\nIf you've added an event handler using , you can remove it again using the method. For example, this would remove the event handler: Event handlers can also be removed by passing an to and then later calling on the controller owning the . For example, to add an event handler that we can remove with an : const controller = new AbortController(); btn.addEventListener(\"click\", () => { const rndCol = `rgb(${random(255)} ${random(255)} ${random(255)})`; document.body.style.backgroundColor = rndCol; }, { signal: controller.signal } // pass an AbortSignal to this handler ); Then the event handler created by the code above can be removed like this: controller.abort(); // removes any/all event handlers associated with this controller For simple, small programs, cleaning up old, unused event handlers isn't necessary, but for larger, more complex programs, it can improve efficiency. Also, the ability to remove event handlers allows you to have the same button performing different actions in different circumstances: all you have to do is add or remove handlers.\n\nObjects (such as buttons) that can fire events also usually have properties whose name is followed by the name of the event. For example, elements have a property . This is called an event handler property. To listen for the event, you can assign the handler function to the property. For example, we could rewrite the random-color example like this: You can also set the handler property to a named function: With event handler properties, you can't add more than one handler for a single event. For example, you can call on an element multiple times, with different functions specified in the second argument: This is impossible with event handler properties because any subsequent attempts to set the property will overwrite earlier ones:\n\nYou might also see a pattern like this in your code: The earliest method of registering event handlers found on the Web involved event handler HTML attributes (or inline event handlers) like the one shown above — the attribute value is literally the JavaScript code you want to run when the event occurs. The above example invokes a function defined inside a element on the same page, but you could also insert JavaScript directly inside the attribute, for example: <button onclick=\"alert('Hello, this is my old-fashioned event handler!');\"> Press me </button> You can find HTML attribute equivalents for many of the event handler properties; however, you shouldn't use these — they are considered bad practice. It might seem easy to use an event handler attribute if you are doing something really quick, but they quickly become unmanageable and inefficient. For a start, it is not a good idea to mix up your HTML and your JavaScript, as it becomes hard to read. Keeping your JavaScript separate is a good practice, and if it is in a separate file you can apply it to multiple HTML documents. Even in a single file, inline event handlers are not a good idea. One button is OK, but what if you had 100 buttons? You'd have to add 100 attributes to the file; it would quickly turn into a maintenance nightmare. With JavaScript, you could easily add an event handler function to all the buttons on the page no matter how many there were, using something like this: Finally, many common server configurations will disallow inline JavaScript, as a security measure. You should never use the HTML event handler attributes — those are outdated, and using them is bad practice.\n\nSometimes, inside an event handler function, you'll see a parameter specified with a name such as , , or . This is called the event object, and it is automatically passed to event handlers to provide extra features and information. For example, let's rewrite our random color example again slightly: Note: You can find the full source code for this example on GitHub (also see it running live). Here you can see we are including an event object, e, in the function, and in the function setting a background color style on — which is the button itself. The property of the event object is always a reference to the element the event occurred upon. So, in this example, we are setting a random background color on the button, not the page. Note: You can use any name you like for the event object — you just need to choose a name that you can then use to reference it inside the event handler function. / / is most commonly used by developers because they are short and easy to remember. It's always good to be consistent — with yourself, and with others if possible.\n\nSometimes, you'll come across a situation where you want to prevent an event from doing what it does by default. The most common example is that of a web form, for example, a custom registration form. When you fill in the details and click the submit button, the natural behavior is for the data to be submitted to a specified page on the server for processing, and the browser to be redirected to a \"success message\" page of some kind (or the same page, if another is not specified). The trouble comes when the user has not submitted the data correctly — as a developer, you want to prevent the submission to the server and give an error message saying what's wrong and what needs to be done to put things right. Some browsers support automatic form data validation features, but since many don't, you are advised to not rely on those and implement your own validation checks. Let's look at an example. First, a simple HTML form that requires you to enter your first and last name: Now some JavaScript — here we implement a very simple check inside a handler for the event (the submit event is fired on a form when it is submitted) that tests whether the text fields are empty. If they are, we call the function on the event object — which stops the form submission — and then display an error message in the paragraph below our form to tell the user what's wrong: const form = document.querySelector(\"form\"); const fname = document.getElementById(\"fname\"); const lname = document.getElementById(\"lname\"); const para = document.querySelector(\"p\"); form.addEventListener(\"submit\", (e) => { if (fname.value === \"\" || lname.value === \"\") { e.preventDefault(); para.textContent = \"You need to fill in both names!\"; } }); Obviously, this is pretty weak form validation — it wouldn't stop the user from validating the form with spaces or numbers entered into the fields, for example — but it is OK for example purposes. The output is as follows: Note: For the full source code, see preventdefault-validation.html (also see it running live here)."
    },
    {
        "link": "https://sencha.com/blog/event-handling-in-javascript-a-practical-guide-with-examples",
        "document": "Back in the day, websites used to be static, meaning users could only view the content but not interact with it. However, we can now create highly interactive user interfaces thanks to JavaScript and JS frameworks. Specifically, event handlers in JavaScript are what allow us to build dynamic web pages and deliver interactive experiences. In the modern web development landscape, events are essentially user actions that occur as a result of user interaction with the web page, such as submitting a form, clicking a button, playing a video on the web page, minimizing the browser window, etc. Event handling allows developers to verify and handle these actions to deliver a more responsive and engaging user experience.\n\nHence, understanding how events work and how to handle them efficiently is essential for every developer looking to create modern web applications. This article will discuss all the ins and outs of event handling in JavaScript. We’ll also briefly discuss how a good JavaScript framework like Ext JS handles events.\n\nEvents are essentially the actions that occur on a web app due to user interaction, such as clicking a button. In JavaScript, when an event occurs, the app fires the event, which is kind of a signal that an event has occurred. The app then automatically responds to the user in the form of output, thanks to event handlers in JavaScript. An event handler is essentially a function with a block of code that is executed or triggered when a specific event fires.\n\nSometimes, when an event occurs, it triggers multiple events. This is because web elements in an app are often nested. This is where event propagation comes in. Event propagation involves capturing and bubbling phases as the event travels across the DOM hierarchy. We’ll discuss these phases later in the article.\n\nThere are common types of events:\n• Keyboard/touch events: Occur when a user presses or releases a key on the keyboard or performs an action with a touch-enabled smartphone, laptop or tablet.\n• Click events: Fires when a user clicks on a button or other such web element.\n• Mouse hover events: These events are fired when a user performs an action with the mouse, such as scrolling a page or moving the cursor.\n• Form/submit events: Triggered when a user submits a form, modifies it, or resets it.\n• Drag and drop events: Occurs when a user drags and drops an element on the web page, such as dragging and dropping an image on a file uploader.\n\nAn event listener is essentially a JavaScript function that waits for a specific event to occur and then executes a callback function to respond to that event. Event listeners and event handlers are often considered the same thing. However, in essence, they work together to respond to an event. As the name suggests, the listener listens for the event, and the handler is the code that is executed in response to that event.\n\nThere are two common built-in event listener methods in JavaScript: addEventListener and removeEventListener. The addEventListener() method enables us to attach an event handler to an element. We can also add multiple event handlers to an element. removeEventListener() allows us to remove an event listener/handler from a specific element.\n\nWhen an event occurs, it belongs to a specific event object. The event object is essentially the argument passed into the callback/event handler function. It provides information about the event, such as the target element, the type of event, etc. It also contains additional properties for the specific event type.\n• target: Represents the element that fired the event.\n• type: Tells about the specific type of the event, such as click or submit\n• keyCode: Used for keyboard events. It contains the Unicode value of the key pressed by the user\n\nHere is an example code demonstrating the use of the event object (Click event):\n\nBased on the concepts we discussed in the previous sections, here is an example for creating a simple button-click event:\n\nHere is a basic example demonstrating how to handle form submissions:\n\nWeb browsers often have a default behavior for certain events. When such an event occurs, the browser’s default behavior is triggered in response to that event. preventDefault() provides us with a way to stop or prevent this default behavior.\n\nFor instance, when a user submits a form, the browser automatically initializes a request to the server. This results in page reload or navigation to a new page, affecting the user experience. Developers can use preventDefault() to stop this default behavior and handle form submission asynchronously without causing a page to reload. For example, in the above code, we’ve used preventDefault() to stop or prevent the default form submission behavior.\n\nEvent delegation in JavaScript is an advanced technique for handling events more efficiently. In event delegation, we add or attach an event listener/listeners to a common parent element. This way, we don’t have to attach the event listener to each element separately. Events are processed and monitored as they traverse the DOM hierarchy. Event delegation is common in popular javascript frameworks\n\nHere is an example of event delegation:\n\nHandling keyboard events, such as key down and key up, allows us to:\n• Respond to user interactions/inputs with the keyboard\n\nKey Down and Key Up are two main types of mouse events. A key-down event occurs when a user presses a key on the keyboard. A key-up event is triggered when a user releases the key after it is pressed down.\n\nHere is an example code for handling a key-down event:\n\nHere is an example code for handling a key-up event:\n\nHandling touch and mobile events to create a responsive and touch-friendly design, providing an intuitive way to interact with the web app.\n\nHere is an example code for Touchstart, Touchmove, and Touchend:\n• Gesture events, such as gesturestart, gesturechange, and gestureend. These events are used for gestures like pinch-zoom.\n• orientationchange event used for detecting changes in device orientation.\n\nAlso Read: Angular vs Ext JS: Which JavaScript Framework Should You Use?\n\nAs aforementioned, event bubbling and capturing are a part of the event propagation process. In event bubbling, the event starts from the same target element that fired the event. It then bubbles up or propagates through its parent and ancestor elements in the DOM till it reaches the root element. This allows you to handle the event in a parent element instead of the target element. Event bubbling is the default event behaviour on elements.\n\nIn event capturing, the event traverses from the outermost parent or ancestor element to the target element. It is also called event trickling.\n\nJavaScript also allows you to create and dispatch custom events designed to meet your specific application needs. For instance, you can create custom events for cross-component state management.\n\nHere is how to create a custom event:\n\nHere is how to dispatch the event:\n• Combine multiple events that trigger similar actions into one event listener.\n• Use event capturing only when needed. Otherwise, use bubbling.\n\nExt JS is a leading Javascript framework for creating high-performance web and mobile applications. It offers over 140+ pre-built components and supports MVVM architecture and two-way data binding. Events are a core concept in the Ext JS framework that enables your code to react to changes in your app. Here is an example code for button-click event in Ext JS:\n\nYou can learn more about handling events in Ext JS here.\n\nTransform your digital landscape with Sencha: Master JavaScript frameworks for unrivalled web development excellence\n\nIn the web development process, events refer to user actions, such as such as clicking a button, minimizing the browser window, or submitting a form. Event handling in JavaScript and JavaScript frameworks allows us to respond to user actions and interactions and create dynamic and interactive websites. This article explores various concerts related to event handling in JavaScript with examples.\n\nWhat is event handling in JavaScript?\n\nEvent handling in JS refers to using event listeners to wait for an event to occur on an element and responding to that event using event handlers or callback functions.\n\nHow do I attach an event listener to an element?\n\nYou can use JavaScript’s built-in addEventListener() method to attach an event to an element.\n\nWhat is the event object in JavaScript?\n\nThe event object in JS is essentially the argument passed into the callback/event handler function. It provides valuable information about the event, such as the target element, the type of event, etc.\n\nWhat are the most popular JavaScript frameworks?\n\nBest JavaScript frameworks and JavaScript libraries include Ext JS, React and Angular. Ext JS offers 140+ high-performance pre-built components for developing web applications quickly. React is another popular JavaScript framework known for creating customized and reusable elements and virtual DOM. Angular is another open-source JavaScript framework that utilizes component-based architecture and allows developers to build high-performance single-page applications."
    },
    {
        "link": "https://blog.webdevsimplified.com/2022-01/event-listeners",
        "document": "Whether you are completely new to JavaScript or have been programming for decades you will need to use event listeners with pretty much any project you create. These event listeners seem simple at first, but there are tons of lesser known features of event listeners like bubbling, capture, delegation, and more. Understanding these features is crucial to becoming an expert JavaScript developer so no matter where you are on your programming journey this article will have something for you.\n\nNow if you already understand how to create an event listener you can skip this section as it will only cover the most basic features of defining event listeners.\n\nAn event listener in JavaScript is a way that you can wait for user interaction like a click or keypress and then run some code whenever that action happens. One common use case for event listeners is listening for click events on a button.\n\nTo set up an event listener you just need to have a variable that references an element and then call the function on that element. This function takes a minimum of two parameters.\n\nThe first parameter is just a string which is the name of the event to listen to. There are hundreds of events that you can listen to such as , , and . This is a complete list of events, but you will really only use a handful of these events so don’t bother memorizing them all.\n\nThe second parameter is a function that has one single argument which is the event argument, commonly called . This function is called every time the event occurs and the event object contains information about the event. Depending on what event you listen for the event object will have different properties that are important, but pretty much every event will have a property. This property represents the element the event is occurring on which is important for more advanced uses of event listeners that we will cover later in this article.\n\nIt is also important to note that if you have multiple event listeners on an element for the same event they will all fire in the order they were added to the element.\n\nNow you can get pretty far with just basic event listeners, but when you start to create more advanced projects you will need to understand how these events are triggered and how they propagate through the DOM. This is where the bubble and capture phases come in.\n\nImagine we have the following HTML and JavaScript.\n\nIf we click inside of the child element you probably think it will log , but in actuality it will log both and in that order. The reason for this is bubbling.\n\nWhen an event is triggered on an element it will bubble that event up the document tree to all the elements the element is inside of. In our example when the child is clicked it will also trigger a click event listener on the parent element since the child is inside the parent element. This even goes one step further and triggers a click event listener on the document itself as well. We will take advantage of this fact when we deal with event delegation.\n\nNow everything I explained above has to do with the bubble phase which is the default phase where event listeners fire, but events also have another phase called the capture phase which happens first. The capture phase is just like the bubble phase but the event starts at the top level element, in our case the document, and works its way inward. This means in our example if we click on the child element we will trigger a capture event listener for the document, then the parent, then the child. We will then enter the bubble phase and trigger bubble event listeners for the child, then the parent, then the document.\n\nSo far we have only covered how to setup event listeners for the bubble phase, but if you want to have a capture event listener you need to use the third parameter of the function. This third parameter is an options object that has a property which when set to true will label this event as a capture event.\n\nWith the above code if we click on the child it will log out the following.\n\nAs you can see all the capture event listeners we created fire first and then the bubble event listeners fire next.\n\nIt may seem strange to have these two phases of events but the reason for this is so that you can respond to events in the order you need. One common use case for using a capture event is to catch an event before it gets to the children and actually stop it.\n\nBy using the method on the event object we are able to stop the event from continuing its capturing and bubbling which means if there are any other event listeners in the chain that would fire they do not. In the above example only will be logged since we stop the event from propagating after the parent capture event listener.\n\nAnother method, is available on the event object and this works a bit differently. If you use the then the event will not only stop propagation to the child/parent elements through the bubble and capture phases, but it will also stop other events on the element from triggering as well.\n\nIn the above example we stopped propagation in the first parent capture event listener which prevents the event from propagating to the other elements through the capture/bubble phases. Also, since we used all other click event listeners on the parent element will not trigger as well. It is important to note that the event listeners on the same element will trigger in the order they are defined so if you want to stop other event listeners from firing with this method they must be defined after the listener that stops propagation.\n\nOne important thing to know about event bubbling is that not all events bubble up. Events like the event which fire when an element receives focus do not bubble up. Generally events that do not bubble make sense not to bubble since they only pertain to the individual element the event fires on such as the event.\n\nIt is great to know how to add an event listener but eventually you will need to remove the listeners you add. The easiest way to do this is with the function, but there are also two more advanced ways to do so that we will talk about as well.\n\nThe function is a simple function that you can call on an element to remove an event listener that was previously added with .\n\nThe above code adds a listener on click that calls the function and then immediately removes it. It is important to note that when adding/removing event listeners you need to make sure the function is exactly the same. If I were instead to write my code as the following it would not actually remove the event listener since these are two different functions even though they contain the same code.\n\nIf you are unfamiliar with why this is you should check out my complete reference vs value guide which explains this exact concept.\n\nIt is common practice to need to run an event only one time and doing so with is a bit of a pain and not always accurate. This is why the third options parameter to has a property called that when set to true will ensure your event listener only runs one time.\n\nNo matter how many times I click the above button it will only log one time since the event listener automatically removes itself after running once.\n\nThe final way to remove an event listener is the least common method, but can be incredibly useful. This technique involves using an . If you wanted to create an event listener that works until a certain condition is met this may be the perfect option for you.\n\nThe above code looks a bit confusing, but I will try to explain what is going on. First we are creating a new . We then take that and pass the property of it to the property of the options object for our function. This connects our event listener to that so if we abort it will remove the event listener. Then finally in our code we are calling the method on our when the count is greater than or equal to 3 which will remove the event listener.\n\nEssentially, the way an works is you pass the signal portion to the function and then at anytime in the future you can call on the and it will remove the event listener for you.\n\nAll of the concepts we have covered so far have led up to the final topic of this article which is about event delegation. In my opinion understanding how this works is the most important concept in this article.\n\nIn the above code we are selecting all the buttons on our page and adding an event listener to listen for a click on those buttons. Then after all that we are adding a brand new button to the page. This new button does NOT have any click event listener attached to it since it was added to the page after our event listeners were added.\n\nThis is a common mistake new developer make since they think this new button will have the event listener but since it was added after the event listener was added it does not. In order to get around this issue you either need to manually add the event listener to your new elements each time they are created or you need to use event delegation.\n\nWith event delegation you set up your event listener on a parent element, such as the document, and then inside that parent element you check to see if the event was fired by the elements you care about before running your event code.\n\nSince the click event bubbles up to the parent elements we know that eventually any click event on our page will make it to the document. We are then checking in the document to see if the target of the event matches the selector . This selector we pass to is just a CSS selector similar to what you pass to .\n\nBy writing our code like this we ensure that any button on our page, even newly added buttons, will work properly when clicked. If we click on something that is not a button, though, the code will return false which means nothing will be logged.\n\nEssentially, anytime you are dealing with adding elements to a page dynamically it pays to write an event listener on the parent to delegate that event when the correct criteria is met. This is actually such a common use case I have a simple helper function I use to do this.\n\nWhile event listeners may seem simple on the surface, there is actually a surprising amount of depth to them. Understanding this depth will elevate your programming skills to the next level."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/checkbox",
        "document": "elements of type are rendered by default as boxes that are checked (ticked) when activated, like you might see in an official government paper form. The exact appearance depends upon the operating system configuration under which the browser is running. Generally this is a square but it may have rounded corners. A checkbox allows you to select single values for submission in a form (or not).\n\nA string representing the value of the checkbox. This is not displayed on the client-side, but on the server this is the given to the data submitted with the checkbox's . Take the following example: In this example, we've got a name of , and a value of . When the form is submitted, the data name/value pair will be . If the attribute was omitted, the default value for the checkbox is , so the submitted data in that case would be . Note: If a checkbox is unchecked when its form is submitted, neither the name nor the value is submitted to the server. There is no HTML-only method of representing a checkbox's unchecked state (e.g. ). If you wanted to submit a default value for the checkbox when it is unchecked, you could include JavaScript to create a <input type=\"hidden\"> within the form with a value indicating an unchecked state.\n\nIn addition to the common attributes shared by all elements, inputs support the following attributes. A boolean attribute indicating whether this checkbox is checked by default (when the page loads). It does not indicate whether this checkbox is currently checked: if the checkbox's state is changed, this content attribute does not reflect the change. (Only the 's IDL attribute is updated.) Note: Unlike other input controls, a checkbox's value is only included in the submitted data if the checkbox is currently . If it is, then the value of the checkbox's attribute is reported as the input's value, or if no is set. Unlike other browsers, Firefox by default persists the dynamic checked state of an across page loads. Use the attribute to control this feature. The attribute is one which all s share; however, it serves a special purpose for inputs of type : when a form is submitted, only checkboxes which are currently checked are submitted to the server, and the reported value is the value of the attribute. If the is not otherwise specified, it is the string by default. This is demonstrated in the section Value above.\n\nThe example we saw above only contained one checkbox; in real-world situations you'll be likely to encounter multiple checkboxes. If they are completely unrelated, then you can just deal with them all separately, as shown above. However, if they're all related, things are not quite so simple. For example, in the following demo we include multiple checkboxes to allow the user to select their interests (see the full version in the Examples section). In this example you will see that we've given each checkbox the same . If both checkboxes are checked and then the form is submitted, you'll get a string of name/value pairs submitted like this: . When this string reaches the server, you need to parse it other than as an associative array, so all values, not only the last value, of are captured. For one technique used with Python, see Handle Multiple Checkboxes with a Single Serverside Variable, for example.\n\nIn the above examples, you may have noticed that you can toggle a checkbox by clicking on its associated element as well as on the checkbox itself. This is a really useful feature of HTML form labels that makes it easier to click the option you want, especially on small-screen devices like smartphones. Beyond accessibility, this is another good reason to properly set up elements on your forms.\n\nA checkbox can be in an indeterminate state. This is set using the object's property via JavaScript (it cannot be set using an HTML attribute): When is , the checkbox has a horizontal line in the box (it looks somewhat like a hyphen or minus sign) instead of a check/tick in most browsers. Note: This is purely a visual change. It has no impact on whether the checkbox's is used in a form submission. That is decided by the state, regardless of the state. There are not many use cases for this property. The most common is when a checkbox is available that \"owns\" a number of sub-options (which are also checkboxes). If all of the sub-options are checked, the owning checkbox is also checked, and if they're all unchecked, the owning checkbox is unchecked. If any one or more of the sub-options have a different state than the others, the owning checkbox is in the indeterminate state. This can be seen in the below example (thanks to CSS Tricks for the inspiration). In this example we keep track of the ingredients we are collecting for a recipe. When you check or uncheck an ingredient's checkbox, a JavaScript function checks the total number of checked ingredients:\n• If none are checked, the recipe name's checkbox is set to unchecked.\n• If one or two are checked, the recipe name's checkbox is set to .\n• If all three are checked, the recipe name's checkbox is set to . So in this case the state is used to state that collecting the ingredients has started, but the recipe is not yet complete. const overall = document.querySelector(\"#enchantment\"); const ingredients = document.querySelectorAll(\"ul input\"); overall.addEventListener(\"click\", (e) => { e.preventDefault(); }); for (const ingredient of ingredients) { ingredient.addEventListener(\"click\", updateDisplay); } function updateDisplay() { let checkedCount = 0; for (const ingredient of ingredients) { if (ingredient.checked) { checkedCount++; } } if (checkedCount === 0) { overall.checked = false; overall.indeterminate = false; } else if (checkedCount === ingredients.length) { overall.checked = true; overall.indeterminate = false; } else { overall.checked = false; overall.indeterminate = true; } }"
    },
    {
        "link": "https://w3schools.com/jsref/dom_obj_checkbox.asp",
        "document": "The Input Checkbox object represents an HTML <input> element with type=\"checkbox\".\n\nYou can access an <input> element with type=\"checkbox\" by using getElementById():\n\nTip: You can also access <input type=\"checkbox\"> by searching through the elements collection of a form.\n\nYou can create an <input> element with type=\"checkbox\" by using the document.createElement() method:\n\nThe Input Checkbox object also supports the standard properties and events."
    },
    {
        "link": "https://stackoverflow.com/questions/60734068/how-do-i-develop-a-checkbox-form-using-javascript-and-html",
        "document": "I am currently developing an order form with JavaScript and HTML and need to have a radio box checked for a \"build your own\" option. Following that, I need to have 6 checkboxes with options of different fruits to choose from. Would I use the switch statement for the checkboxes? This is what I have so far:\n\nI am a beginner coder (as you can see lol) if you can help in any way it would be greatly appreciated."
    },
    {
        "link": "https://stackoverflow.com/questions/76172825/handling-forms-with-javascript-checkbox-validation",
        "document": "I'm currently studying JavaScript and still in beginner level. So, I referred given code from a certain Open Learning Platform. Its intention was to validate whether the checkbox is checked or not (that's how it was said in there). but it won't output any message. Could you help me with it.\n\nI tried refer some external resources as such and as far as my knowledge I cannot find where the error stands."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input",
        "document": "The element is so powerful because of its attributes; the attribute, described with examples above, being the most important. Since every element, regardless of type, is based on the interface, they technically share the exact same set of attributes. However, in reality, most attributes have an effect on only a specific subset of input types. In addition, the way some attributes impact an input depends on the input type, impacting different input types in different ways. This section provides a table listing all the attributes with a brief description. This table is followed by a list describing each attribute in greater detail, along with which input types they are associated with. Those that are common to most or all input types are defined in greater detail below. Attributes that are unique to particular input types—or attributes which are common to all input types but have special behaviors when used on a given input type—are instead documented on those types' pages. Attributes for the element include the global HTML attributes and additionally: alt attribute for the image type. Required for accessibility all except , , and all except , , and buttons Whether the command or control is checked Name of form field to use for sending the element's directionality in form submission Whether the form control is disabled URL to use for form submission Form data set encoding type to use for form submission HTTP method to use for form submission Same as height attribute for ; vertical dimension all except , , , , and buttons Value of the id attribute of the of autocomplete options Boolean. Whether to allow multiple values Name of the form control. Submitted with the form as part of a name/value pair Pattern the must match to be valid Text that appears in the form control when it has no value set Designates an as a control for a popover element Specifies the action that a popover control should perform all except , , , , , and buttons Boolean. The value is not editable all except , , , and buttons Boolean. A value is required or must be checked for the form to be submittable Same as attribute for ; address of image resource The value of the control. When specified in the HTML, corresponds to the initial value Same as attribute for A few additional non-standard attributes are listed following the descriptions of the standard attributes.\n\nLabels are needed to associate assistive text with an . The element provides explanatory information about a form field that is always appropriate (aside from any layout concerns you have). It's never a bad idea to use a to explain what should be entered into an or . The semantic pairing of and elements is useful for assistive technologies such as screen readers. By pairing them using the 's attribute, you bond the label to the input in a way that lets screen readers describe inputs to users more precisely. It does not suffice to have plain text adjacent to the element. Rather, usability and accessibility requires the inclusion of either implicit or explicit : <!-- inaccessible --> <p>Enter your name: <input id=\"name\" type=\"text\" size=\"30\" /></p> <!-- implicit label --> <p> <label>Enter your name: <input id=\"name\" type=\"text\" size=\"30\" /></label> </p> <!-- explicit label --> <p> <label for=\"name\">Enter your name: </label> <input id=\"name\" type=\"text\" size=\"30\" /> </p> The first example is inaccessible: no relationship exists between the prompt and the element. In addition to an accessible name, the label provides a larger 'hit' area for mouse and touch screen users to click on or touch. By pairing a with an , clicking on either one will focus the . If you use plain text to \"label\" your input, this won't happen. Having the prompt part of the activation area for the input is helpful for people with motor control conditions. As web developers, it's important that we never assume that people will know all the things that we know. The diversity of people using the web—and by extension your website—practically guarantees that some of your site's visitors will have some variation in thought processes and/or circumstances that leads them to interpret your forms very differently from you without clear and properly-presented labels. The attribute lets you specify text that appears within the element's content area itself when it is empty. The placeholder should never be required to understand your forms. It is not a label, and should not be used as a substitute, because it isn't. The placeholder is used to provide a hint as to what an inputted value should look like, not an explanation or prompt. Not only is the placeholder not accessible to screen readers, but once the user enters any text into the form control, or if the form control already has a value, the placeholder disappears. Browsers with automatic page translation features may skip over attributes when translating, meaning the may not get translated. Note: Don't use the attribute if you can avoid it. If you need to label an element, use the element.\n\nWarning: Client-side validation is useful, but it does not guarantee that the server will receive valid data. If the data must be in a specific format, always verify it also on the server-side, and return a HTTP response if the format is invalid. In addition to using CSS to style inputs based on the or UI states based on the current state of each input, as noted in the UI pseudo-classes section above, the browser provides for client-side validation on (attempted) form submission. On form submission, if there is a form control that fails constraint validation, supporting browsers will display an error message on the first invalid form control; displaying a default message based on the error type, or a message set by you. Some input types and other attributes place limits on what values are valid for a given input. For example, means only the number 2, 4, 6, 8, or 10 are valid. Several errors could occur, including a error if the value is less than 2, if greater than 10, if the value is a number between 2 and 10, but not an even integer (does not match the requirements of the attribute), or if the value is not a number. For the input types whose domain of possible values is periodic (that is, at the highest possible value, the values wrap back around to the beginning rather than ending), it's possible for the values of the and properties to be reversed, which indicates that the range of permitted values starts at , wraps around to the lowest possible value, then continues on until is reached. This is particularly useful for dates and times, such as when you want to allow the range to be from 8 PM to 8 AM: Specific attributes and their values can lead to a specific error : Validity object errors depend on the attributes and their values: Occurs when the value is greater than the maximum value as defined by the attribute Occurs when the number of characters is greater than the number allowed by the property Occurs when the value is less than the minimum value as defined by the attribute Occurs when the number of characters is less than the number required by the property Occurs when a pattern attribute is included with a valid regular expression and the does not match it. Occurs when the attribute is present but the value is or radio or checkbox is not checked. The value doesn't match the step increment. Increment default is , so only integers are valid on is step is not included. will never throw this error. Occurs when the value is not of the correct type, for example an email does not contain an or a url doesn't contain a protocol. If a form control doesn't have the attribute, no value, or an empty string, is not invalid. Even if the above attributes are present, with the exception of , an empty string will not lead to an error. We can set limits on what values we accept, and supporting browsers will natively validate these form values and alert the user if there is a mistake when the form is submitted. In addition to the errors described in the table above, the interface contains the , , and boolean readonly properties. The validity object includes: For each of these Boolean properties, a value of indicates that the specified reason validation may have failed is true, with the exception of the property, which is if the element's value obeys all constraints. If there is an error, supporting browsers will both alert the user and prevent the form from being submitted. A word of caution: if a custom error is set to a truthy value (anything other than the empty string or ), the form will be prevented from being submitted. If there is no custom error message, and none of the other properties return true, will be true, and the form can be submitted. function validate(input) { let validityState_object = input.validity; if (validityState_object.valueMissing) { input.setCustomValidity(\"A value is required\"); } else if (validityState_object.rangeUnderflow) { input.setCustomValidity(\"Your value is too low\"); } else if (validityState_object.rangeOverflow) { input.setCustomValidity(\"Your value is too high\"); } else { input.setCustomValidity(\"\"); } } The last line, setting the custom validity message to the empty string is vital. If the user makes an error, and the validity is set, it will fail to submit, even if all the values are valid, until the message is . If you want to present a custom error message when a field fails to validate, you need to use the Constraint Validation API available on (and related) elements. Take the following form: The basic HTML form validation features will cause this to produce a default error message if you try to submit the form with either no valid filled in, or a value that does not match the . If you wanted to instead display custom error messages, you could use JavaScript like the following: const nameInput = document.querySelector(\"input\"); nameInput.addEventListener(\"input\", () => { nameInput.setCustomValidity(\"\"); nameInput.checkValidity(); }); nameInput.addEventListener(\"invalid\", () => { if (nameInput.value === \"\") { nameInput.setCustomValidity(\"Enter your username!\"); } else { nameInput.setCustomValidity( \"Usernames can only contain upper and lowercase letters. Try again!\", ); } }); The example renders like so:\n• We check the valid state of the input element every time its value is changed by running the method via the event handler.\n• If the value is invalid, an event is raised, and the event handler function is run. Inside this function we work out whether the value is invalid because it is empty, or because it doesn't match the pattern, using an block, and set a custom validity error message.\n• As a result, if the input value is invalid when the submit button is pressed, one of the custom error messages will be shown.\n• If it is valid, it will submit as you'd expect. For this to happen, the custom validity has to be cancelled, by invoking with an empty string value. We therefore do this every time the event is raised. If you don't do this, and a custom validity was previously set, the input will register as invalid, even if it currently contains a valid value on submission. Note: Always validate input constraints both client side and server side. Constraint validation doesn't remove the need for validation on the server side. Invalid values can still be sent by older browsers or by bad actors. Note: Firefox supported a proprietary error attribute — — for many versions, which allowed you set custom error messages in a similar way. This has been removed as of version 66 (see Firefox bug 1513890)."
    }
]