[
    {
        "link": "https://typescriptlang.org/docs/handbook/typescript-in-5-minutes.html",
        "document": "TypeScript stands in an unusual relationship to JavaScript. TypeScript offers all of JavaScript’s features, and an additional layer on top of these: TypeScript’s type system.\n\nFor example, JavaScript provides language primitives like and , but it doesn’t check that you’ve consistently assigned these. TypeScript does.\n\nThis means that your existing working JavaScript code is also TypeScript code. The main benefit of TypeScript is that it can highlight unexpected behavior in your code, lowering the chance of bugs.\n\nThis tutorial provides a brief overview of TypeScript, focusing on its type system.\n\nTypeScript knows the JavaScript language and will generate types for you in many cases. For example in creating a variable and assigning it to a particular value, TypeScript will use the value as its type.\n\nBy understanding how JavaScript works, TypeScript can build a type-system that accepts JavaScript code but has types. This offers a type-system without needing to add extra characters to make types explicit in your code. That’s how TypeScript knows that is a in the above example.\n\nYou may have written JavaScript in Visual Studio Code, and had editor auto-completion. Visual Studio Code uses TypeScript under the hood to make it easier to work with JavaScript.\n\nYou can use a wide variety of design patterns in JavaScript. However, some design patterns make it difficult for types to be inferred automatically (for example, patterns that use dynamic programming). To cover these cases, TypeScript supports an extension of the JavaScript language, which offers places for you to tell TypeScript what the types should be.\n\nFor example, to create an object with an inferred type which includes and , you can write:\n\nYou can explicitly describe this object’s shape using an declaration:\n\nYou can then declare that a JavaScript object conforms to the shape of your new by using syntax like after a variable declaration:\n\nIf you provide an object that doesn’t match the interface you have provided, TypeScript will warn you:\n\nSince JavaScript supports classes and object-oriented programming, so does TypeScript. You can use an interface declaration with classes:\n\nYou can use interfaces to annotate parameters and return values to functions:\n\nThere is already a small set of primitive types available in JavaScript: , , , , , , and , which you can use in an interface. TypeScript extends this list with a few more, such as (allow anything), (ensure someone using this type declares what the type is), (it’s not possible that this type could happen), and (a function which returns or has no return value).\n\nYou’ll see that there are two syntaxes for building types: Interfaces and Types. You should prefer . Use when you need specific features.\n\nWith TypeScript, you can create complex types by combining simple ones. There are two popular ways to do so: unions and generics.\n\nWith a union, you can declare that a type could be one of many types. For example, you can describe a type as being either or :\n\nNote: If you hover over above, you’ll see that it is classed as . That’s a property of the Structural Type System. More on this below.\n\nA popular use-case for union types is to describe the set of or literals that a value is allowed to be:\n\nUnions provide a way to handle different types too. For example, you may have a function that takes an or a :\n\nTo learn the type of a variable, use :\n\nFor example, you can make a function return different values depending on whether it is passed a string or an array:\n\nGenerics provide variables to types. A common example is an array. An array without generics could contain anything. An array with generics can describe the values that the array contains.\n\nYou can declare your own types that use generics:\n\nOne of TypeScript’s core principles is that type checking focuses on the shape that values have. This is sometimes called “duck typing” or “structural typing”.\n\nIn a structural type system, if two objects have the same shape, they are considered to be of the same type.\n\nThe variable is never declared to be a type. However, TypeScript compares the shape of to the shape of in the type-check. They have the same shape, so the code passes.\n\nThe shape-matching only requires a subset of the object’s fields to match.\n\nThere is no difference between how classes and objects conform to shapes:\n\nIf the object or class has all the required properties, TypeScript will say they match, regardless of the implementation details.\n\nThis was a brief overview of the syntax and tools used in everyday TypeScript. From here, you can:\n• Read the full Handbook from start to finish"
    },
    {
        "link": "https://typescriptlang.org/docs/handbook/classes.html",
        "document": "Traditional JavaScript uses functions and prototype-based inheritance to build up reusable components, but this may feel a bit awkward to programmers more comfortable with an object-oriented approach, where classes inherit functionality and objects are built from these classes. Starting with ECMAScript 2015, also known as ECMAScript 6, JavaScript programmers can build their applications using this object-oriented class-based approach. In TypeScript, we allow developers to use these techniques now, and compile them down to JavaScript that works across all major browsers and platforms, without having to wait for the next version of JavaScript.\n\nLet’s take a look at a simple class-based example:\n\nThe syntax should look familiar if you’ve used C# or Java before. We declare a new class . This class has three members: a property called , a constructor, and a method .\n\nYou’ll notice that in the class when we refer to one of the members of the class we prepend . This denotes that it’s a member access.\n\nIn the last line we construct an instance of the class using . This calls into the constructor we defined earlier, creating a new object with the shape, and running the constructor to initialize it.\n\nIn TypeScript, we can use common object-oriented patterns. One of the most fundamental patterns in class-based programming is being able to extend existing classes to create new ones using inheritance.\n\nLet’s take a look at an example:\n\nThis example shows the most basic inheritance feature: classes inherit properties and methods from base classes. Here, is a derived class that derives from the base class using the keyword. Derived classes are often called subclasses, and base classes are often called superclasses.\n\nBecause extends the functionality from , we were able to create an instance of that could both and .\n\nLet’s now look at a more complex example.\n\nThis example covers a few other features we didn’t previously mention. Again, we see the keywords used to create two new subclasses of : and .\n\nOne difference from the prior example is that each derived class that contains a constructor function must call which will execute the constructor of the base class. What’s more, before we ever access a property on in a constructor body, we have to call . This is an important rule that TypeScript will enforce.\n\nThe example also shows how to override methods in the base class with methods that are specialized for the subclass. Here both and create a method that overrides the from , giving it functionality specific to each class. Note that even though is declared as an , since its value is a , calling will call the overriding method in :\n\nIn our examples, we’ve been able to freely access the members that we declared throughout our programs. If you’re familiar with classes in other languages, you may have noticed in the above examples we haven’t had to use the word to accomplish this; for instance, C# requires that each member be explicitly labeled to be visible. In TypeScript, each member is by default.\n\nYou may still mark a member explicitly. We could have written the class from the previous section in the following way:\n\nWith TypeScript 3.8, TypeScript supports the new JavaScript syntax for private fields:\n\nThis syntax is built into the JavaScript runtime and can have better guarantees about the isolation of each private field. Right now, the best documentation for these private fields is in the TypeScript 3.8 release notes.\n\nTypeScript also has its own way to declare a member as being marked , it cannot be accessed from outside of its containing class. For example:\n\nTypeScript is a structural type system. When we compare two different types, regardless of where they came from, if the types of all members are compatible, then we say the types themselves are compatible.\n\nHowever, when comparing types that have and members, we treat these types differently. For two types to be considered compatible, if one of them has a member, then the other must have a member that originated in the same declaration. The same applies to members.\n\nLet’s look at an example to better see how this plays out in practice:\n\nIn this example, we have an and a , with being a subclass of . We also have a new class that looks identical to in terms of shape. We create some instances of these classes and then try to assign them to each other to see what will happen. Because and share the side of their shape from the same declaration of in , they are compatible. However, this is not the case for . When we try to assign from an to we get an error that these types are not compatible. Even though also has a member called , it’s not the one we declared in .\n\nThe modifier acts much like the modifier with the exception that members declared can also be accessed within deriving classes. For example,\n\nNotice that while we can’t use from outside of , we can still use it from within an instance method of because derives from .\n\nA constructor may also be marked . This means that the class cannot be instantiated outside of its containing class, but can be extended. For example,\n\nYou can make properties readonly by using the keyword. Readonly properties must be initialized at their declaration or in the constructor.\n\nIn our last example, we had to declare a readonly member and a constructor parameter in the class. This is needed in order to have the value of accessible after the constructor is executed. Parameter properties let you create and initialize a member in one place. Here’s a further revision of the previous class using a parameter property:\n\nNotice how we dropped altogether and just use the shortened parameter on the constructor to create and initialize the member. We’ve consolidated the declarations and assignment into one location.\n\nParameter properties are declared by prefixing a constructor parameter with an accessibility modifier or , or both. Using for a parameter property declares and initializes a private member; likewise, the same is done for , , and .\n\nTypeScript supports getters/setters as a way of intercepting accesses to a member of an object. This gives you a way of having finer-grained control over how a member is accessed on each object.\n\nLet’s convert a simple class to use and . First, let’s start with an example without getters and setters.\n\nWhile allowing people to randomly set directly is pretty handy, we may also want enforce some constraints when is set.\n\nIn this version, we add a setter that checks the length of the to make sure it’s compatible with the max-length of our backing database field. If it isn’t we throw an error notifying client code that something went wrong.\n\nTo preserve existing functionality, we also add a simple getter that retrieves unmodified.\n\nTo prove to ourselves that our accessor is now checking the length of values, we can attempt to assign a name longer than 10 characters and verify that we get an error.\n\nA couple of things to note about accessors:\n\nFirst, accessors require you to set the compiler to output ECMAScript 5 or higher. Downleveling to ECMAScript 3 is not supported. Second, accessors with a and no are automatically inferred to be . This is helpful when generating a file from your code, because users of your property can see that they can’t change it.\n\nUp to this point, we’ve only talked about the instance members of the class, those that show up on the object when it’s instantiated. We can also create static members of a class, those that are visible on the class itself rather than on the instances. In this example, we use on the origin, as it’s a general value for all grids. Each instance accesses this value through prepending the name of the class. Similarly to prepending in front of instance accesses, here we prepend in front of static accesses.\n\nAbstract classes are base classes from which other classes may be derived. They may not be instantiated directly. Unlike an interface, an abstract class may contain implementation details for its members. The keyword is used to define abstract classes as well as abstract methods within an abstract class.\n\nMethods within an abstract class that are marked as abstract do not contain an implementation and must be implemented in derived classes. Abstract methods share a similar syntax to interface methods. Both define the signature of a method without including a method body. However, abstract methods must include the keyword and may optionally include access modifiers.\n\nWhen you declare a class in TypeScript, you are actually creating multiple declarations at the same time. The first is the type of the instance of the class.\n\nHere, when we say , we’re using as the type of instances of the class . This is almost second nature to programmers from other object-oriented languages.\n\nWe’re also creating another value that we call the constructor function. This is the function that is called when we up instances of the class. To see what this looks like in practice, let’s take a look at the JavaScript created by the above example:\n\nHere, is going to be assigned the constructor function. When we call and run this function, we get an instance of the class. The constructor function also contains all of the static members of the class. Another way to think of each class is that there is an instance side and a static side.\n\nLet’s modify the example a bit to show this difference:\n\nIn this example, works similarly to before. We instantiate the class, and use this object. This we have seen before.\n\nNext, we then use the class directly. Here we create a new variable called . This variable will hold the class itself, or said another way its constructor function. Here we use , that is “give me the type of the class itself” rather than the instance type. Or, more precisely, “give me the type of the symbol called ,” which is the type of the constructor function. This type will contain all of the static members of Greeter along with the constructor that creates instances of the class. We show this by using on , creating new instances of and invoking them as before. It is also good to mention that changing static property is frowned upon, here has instead of on .\n\nUsing a class as an interface\n\nAs we said in the previous section, a class declaration creates two things: a type representing instances of the class and a constructor function. Because classes create types, you can use them in the same places you would be able to use interfaces."
    },
    {
        "link": "https://docs.relewise.com/docs/examples/ts",
        "document": "Here is an overview of all our examples for TS/JS."
    },
    {
        "link": "https://blog.chainsafe.io/documenting-typescript-finding-the-right-tools-for-your-project",
        "document": "TypeScript (TS) is becoming increasingly popular in the JavaScript (JS) ecosystem. Many popular libraries, like LibP2P, DiscordJS, Node-Postgres, and Selenium Driver, have already started rewriting their JavaScript codebase in TypeScript, with many others following their lead.\n\nAs the use of TypeScript grows, so does the need for documentation. So, we created this resource to help developers find the right documentation tools for their TypeScript projects.\n\nCompared to legacy versions of JavaScript, TypeScript documentation has much room for improvement. One of the main differences between the two is the type of safety brought in by TypeScript at compile time. However, during compile time, TypeScript is converted to vanilla dynamically typed JavaScript, so it becomes essential to provide accurate documentation about \"types\" to users, ensuring they always benefit from type safety at both compile time and runtime.\n\nThe documentation needs for a commercial, user-facing product are different from the needs of a library or developer tool.\n\nA project with a user base of other developers should share information about \"types.\" A commercial product needs to document business flows, with occasional reference to some code. While, for a developer tool, users need API documentation. The abovementioned examples require two forms of documentation, one \"static\" and one \"live,\" and directly generated from the source code.\n\nFor static documentation it's about what the developer is proficient with and what resources they have at their disposal. It could be plain text files, Google docs, Markdown docs, a locally hosted content management system, or any combination of the above.\n\nOn the other hand, a few standards are laid out below for documenting source code. These standards provide more compatibility across the different tools using the output. One example is IntelliSense which is provided by the integrated development environment (IDEs) and helps introduce a consistent pattern and methodology across projects.\n\nThe JSDoc standard is old, coming from JavaScript, but still valid and used for TypeScript. JSDoc was introduced in 2011 and was extended by the JavaDoc standard. It has a large ecosystem of templates and tools for developers to use. JSDoc has evolved, currently in its third iteration, into a stable and widely used standard.\n\nA newer standard, introduced by the authors of TypeScript - TSDoc - is loosely based on JSDoc and tries to standardize the loose ends found in JSDoc. Historically, different tools based on JSDoc treated the JSDoc comments differently, resulting in compatibility issues across the tools. By adhering to already established practices, TSDoc fixes this issue.\n\nDue to their similar grammar, average users wouldn't notice a significant difference between TSDoc and JSDoc. The TS developers intentionally modeled TSDoc's grammar after JSDoc's so users could easily bridge knowledge between the two.\n\nThese documentation standards are not only helpful for generating documentation but are also useful in a variety of use cases. Linting tools have to follow a standard to lint docs. IntelliSense tools also have to follow a standard to provide instant feedback.\n\nFinding the right balance of static and live documentation support for your needs is essential. We compiled a list to find the balance that most documentation requires.\n\nDocumentation tools must be compatible with the version of TypeScript in use. Otherwise, the documentation can suffer.\n\nIt's essential to know what documentation standard the tools use. This step is necessary so that developers can share the tool's knowledge with the team while also allowing the setup of some tools to validate and lint the project, ensuring consistent documentation.\n\nWhile it's not necessary to have TSDoc support, it would be helpful if the tool supports it for compatibility's sake. As an emerging standard, there's enormous potential that, in the future, TSDoc will become the de facto standard for the TS codebase. So, if the tool already supports it, that's a significant plus.\n\nLinting is a critical step in the source code life cycle. As not everyone in a given team will have the same programming approach, enforced linting rules can help keep a codebase consistent.\n\nFor example, if one developer uses the iterator and another uses the loop, linting rules will give feedback to team members, ensuring they follow a uniform pattern. The same applies to documenting the source code, so it's essential to check that the tools have linting support.\n\nThe output of the source document must be in some human-readable form, whether these are HTML pages, a PDF, or any other format. Every project needs to have a unique user experience in its documentation. Having theme support or some ways to customize the output is a significant benefit.\n\nDocumenting source code brings with it the utmost importance of accessibility. Users should be able to directly jump to the source code from the documentation to explore or understand it. Having a tool capable of generating code permalinks is vital.\n\nSometimes developers don't want to expose all of their source code functionality in the documentation. Sometimes developers don't want to list a specific function in a class. Having the ability to exclude some files helps ensure clarity.\n\nDocumentation needs can differ, so static and live documentation is often the most thorough approach. Using a tool that supports static content, such as tutorials and guides, in addition to generated content, ensures your project's needs are met.\n\nRemember, documentation standards may provide some tags but don't enforce mixed static content. It's the parsing tools or documentation generators which provide these features.\n\nThese days, large JS or TS projects follow Monorepo to structure their packages. So, resolving the cross-package references to generate documentation becomes more complex but necessary. This complexity makes Monorepo support an essential feature to look for while searching for documentation tools.\n\nThe final output of any documentation must be in a human-readable format. So it's crucial to consider which export formats a tool will support. I think HTML and Markdown are necessities.\n\nDocumentation tools are just as crucial as packages or libraries in a developer's dependencies list. Looking for the community behind those tools is extremely important. A strong community can provide users with support at critical times.\n\nLicenses are equally essential to look into while searching for documentation tools. These must match with the legal bounds of the project so that no one gets into any future trouble.\n\nThe Rushstack toolchain from Microsoft, the API-Extractor and API-Documenter, is the most extensive toolchain to consider, along with the TSDoc parser. The toolchain developers thought of not just the documentation but also the complete process involved in it.\n\nFor example, the API-Extractor is responsible for extracting the public-facing API from a user's library. It generates two kinds of outputs, one for using tools like the API-Documenter, and one to be used during a future run of the API-Extractor (so developers can identify what API changes are involved with code changes).\n\nUsers can implement this step into their CI/CD and code review process, which will be tremendously helpful in identifying API changes. The negative impact of that process is performance degradation. If users add this step to the version control such that each team member pushes the validated code, it will slow down the local commit process.\n\nThe ultimate breaking point with these tools, right now, is the unavailability of code permalinks and lack of support for a mixup of static content. As of now, TypeDoc is the best tool we've used, providing excellent utility and well-presented code documentation. Users can also mix in static content, covering the needs for custom tutorials, guides, or any business process. It also has a vast community and an extensive list of plugins to extend the functionality.\n\nWe also use Docusaurus. Docusaurus provides the most modern utilities for all static documentation needs. In addition, users can inject a live documentation section into Docusaurus. This combination of both static and live content makes the documentation process futureproof.\n\nThere is an excellent package for those interested that makes this integration seamless. Our latest TS rewrite of web3.js comes included with new documentation that will follow the same approach. Get a chance to see how it looks once the new documentation has gone live!\n\nChainSafe is a leading blockchain research and development firm specializing in infrastructure solutions for web3. Alongside its contributions to major ecosystems such as Ethereum, Polkadot, Filecoin, Mina, and more, ChainSafe creates solutions for developers and teams across the web3 space utilizing our expertise in gaming, bridging, NFTs and decentralized storage.\n\n As part of its mission to build innovative products for users and improved tooling for developers, ChainSafe embodies an open source and community-oriented ethos to advance the future of the internet. To learn more, click here."
    },
    {
        "link": "https://typescriptlang.org/docs/handbook/jsdoc-supported-types.html",
        "document": ""
    },
    {
        "link": "https://reddit.com/r/typescript/comments/15lxqsh/json_to_object_best_practices",
        "document": "Let's say I have JSON from some source, like a web request or local storage. For the sake of simplicity let's say it's , , and data.\n\nRight now the JSON for these gets pulled in and referenced via interface definitions. However, suppose I'd like each to have a method that knows the correct way to deep copy the object. Given the relationships between various data in the system the copy operation for a given object will be more nuanced than a JSON serialize/parse, so it feels like that functionality should live in the same class as the property data so it's easy to do something like . But there are also arguments against it.\n\nIs there a best practice for something like this? I've found a few different approaches, but the discussions are all a bit dated and it's unclear what today's preferred method is. Here are the main options I'm aware of:\n• Keep all the data as interfaces and create utility classes that operate on them to deliver the specialized functionality.\n• Keep all the data as interfaces but create wrapper classes that proxy access to the interface data itself and exposes methods as needed.\n• Migrate the interfaces to classes and have them accept the JSON via constructor or factory parameter so that they only live as classes. This is like the previous option except that you manually map properties and throw away the parameter.\n• Migrate the interfaces to classes and use or other automapper to populate the fields.\n• I've also seen recommended as an option but have never looked into it. The consensus seems to be to not use it."
    }
]