[
    {
        "link": "https://expressjs.com/en/resources/middleware/cors.html",
        "document": "CORS is a node.js package for providing a Connect/Express middleware that can be used to enable CORS with various options.\n\nThis is a Node.js module available through the npm registry. Installation is done using the command:\n\nThis module supports validating the origin dynamically using a function provided to the option. This function will be passed a string that is the origin (or if the request has no origin), and a with the signature .\n\nThe argument to the callback can be any value allowed for the option of the middleware, except a function. See the configuration options section for more information on all the possible value types.\n\nThis function is designed to allow the dynamic loading of allowed origin(s) from a backing datasource, like a database.\n\nCertain CORS requests are considered ‚Äòcomplex‚Äô and require an initial request (called the ‚Äúpre-flight request‚Äù). An example of a ‚Äòcomplex‚Äô CORS request is one that uses an HTTP verb other than GET/HEAD/POST (such as DELETE) or that uses custom headers. To enable pre-flighting, you must add a new OPTIONS handler for the route you want to support:\n\nYou can also enable pre-flight across-the-board like so:\n\nNOTE: When using this middleware as an application level middleware (for example, ), pre-flight requests are already handled for all routes.\n‚Ä¢ : Configures the Access-Control-Allow-Origin CORS header. Possible values:\n‚Ä¢ - set to to reflect the request origin, as defined by , or set it to to disable CORS.\n‚Ä¢ - set to a specific origin. For example if you set it to only requests from ‚Äúhttp://example.com‚Äù will be allowed.\n‚Ä¢ - set to a regular expression pattern which will be used to test the request origin. If it‚Äôs a match, the request origin will be reflected. For example the pattern will reflect any request that is coming from an origin ending with ‚Äúexample.com‚Äù.\n‚Ä¢ - set to an array of valid origins. Each origin can be a or a . For example will accept any request from ‚Äúhttp://example1.com‚Äù or from a subdomain of ‚Äúexample2.com‚Äù.\n‚Ä¢ - set to a function implementing some custom logic. The function takes the request origin as the first parameter and a callback (called as , where is a non-function value of the option) as the second.\n‚Ä¢ : Configures the Access-Control-Allow-Methods CORS header. Expects a comma-delimited string (ex: ‚ÄòGET,PUT,POST‚Äô) or an array (ex: ).\n‚Ä¢ : Configures the Access-Control-Allow-Headers CORS header. Expects a comma-delimited string (ex: ‚ÄòContent-Type,Authorization‚Äô) or an array (ex: ). If not specified, defaults to reflecting the headers specified in the request‚Äôs Access-Control-Request-Headers header.\n‚Ä¢ : Configures the Access-Control-Expose-Headers CORS header. Expects a comma-delimited string (ex: ‚ÄòContent-Range,X-Content-Range‚Äô) or an array (ex: ). If not specified, no custom headers are exposed.\n‚Ä¢ : Configures the Access-Control-Allow-Credentials CORS header. Set to to pass the header, otherwise it is omitted.\n‚Ä¢ : Configures the Access-Control-Max-Age CORS header. Set to an integer to pass the header, otherwise it is omitted.\n‚Ä¢ : Pass the CORS preflight response to the next handler.\n‚Ä¢ : Provides a status code to use for successful requests, since some legacy browsers (IE11, various SmartTVs) choke on .\n\nThe default configuration is the equivalent of:\n\nFor details on the effect of each CORS header, read this article on web.dev.\n\nA demo that illustrates CORS working (and not working) using React is available here: https://node-cors-client.netlify.com\n\nCode for that demo can be found here:"
    },
    {
        "link": "https://stackhawk.com/blog/nodejs-cors-guide-what-it-is-and-how-to-enable-it",
        "document": "Web browsers prevent unknown websites from accessing your application programming interfaces and services. This way, your server shares its resources only with clients that are on the same domain. However, there are situations where you want to lift this guard or get more fine-grained control over which websites access your server's resources. In such cases, you implement on your server.\n\nIn this post, I'll talk about what CORS is and why it's useful. I'll then walk you through how you can enable CORS in your NodeJS application. You can also learn more about the basics of CORS here .\n\nLet's say your server runs on https://domain1.com. You could serve images, fonts, or have simple web services that send back some data. Now imagine there's another website that runs on https://domain2.com that wants to access your services and get some data from your server. To do so, this website makes an HTTP request to one of your API endpoints.\n\nEvery HTTP request comes with request headers that contain information about the request. So in our example, when https://domain2.com sends an HTTP request to your server, it also sends an origin property inside the request's header. This origin property specifies the domain of the source that has made the request.\n\nThe browser on which domain2 sends a request to domain1 implements a same-origin policy. Because of this policy, the browser blocks all requests sent from one origin to another. Therefore, web browsers by default don't allow cross-origin resource sharing.\n\nThis built-in mechanism acts as a safety blanket for web servers. It protects unknown websites from accessing their resources.\n\nWhy Would You Want to Implement CORS?\n\nFrom a security standpoint, browsers assume that your server doesn't want to share resources with websites it doesn't know. However, there are many situations where you explicitly want to enable CORS on your server.\n\nA lot of times, you want other developers to access your APIs. Developer-specific tools, Software as a Service companies, and so on have open APIs that anyone can use on their website.\n\nFor instance, you may want to create an API service that allows developers to check the SEO scores of their websites. In that case, you'd have to keep an open API that anyone can conveniently access.\n\nFree, open, and public APIs are very popular today and are used in many businesses and side projects. that have CORS enabled so any website can make a request to them.\n\nAllow Access to Multiple Environments of the Same Project\n\nLet's say you're pushing out a revamped version of your website. Before you push your code to production, you usually test it first in a test environment. In this case, you test your front end against different environments. You could first test it at a staging environment, then a pre-production environment, and so on. In this case, your different front ends may fail to communicate with your server if you don't have CORS enabled.\n\nWhat a CORS Error Looks Like\n\nEnough theory. Let's see CORS in action!\n\nWe'll create a simple server that returns some JSON data, plus a minimal front end in React that consumes that data.\n\nThen install Express, a lightweight framework for creating server-side applications in NodeJS:\n\nInside the root directory, create a new file called app.js with the following code:\n\nThe above code creates a simple NodeJS + Express server that runs on .\n\nNext, let's create an endpoint /colors that returns some JSON data. For sample data, we can create a JSON file called colors.json inside the root directory with the following data that I found .\n\n{\"colors\":[\n\n {\n\n \"color\": \"red\",\n\n \"value\": \"#f00\"\n\n },\n\n {\n\n \"color\": \"green\",\n\n \"value\": \"#0f0\"\n\n },\n\n {\n\n \"color\": \"blue\",\n\n \"value\": \"#00f\"\n\n },\n\n {\n\n \"color\": \"cyan\",\n\n \"value\": \"#0ff\"\n\n },\n\n {\n\n \"color\": \"magenta\",\n\n \"value\": \"#f0f\"\n\n },\n\n {\n\n \"color\": \"yellow\",\n\n \"value\": \"#ff0\"\n\n },\n\n {\n\n \"color\": \"black\",\n\n \"value\": \"#000\"\n\n }\n\n]\n\n}\n\nInside the app.js file, add the following endpoint:\n\nRemember to import the colors object at the top from the colors.json file, as shown below:\n\nIf you now visit http://localhost:5000/colors, you should get back the following JSON data:\n\nGreat! Let's try to request this API from our front-end application.\n\nCreate a new React app by running the following command:\n\nInside the App.js file, add the following code:\n\nreturn (\n\n <div className=\"App\">\n\n <header className=\"App-header\">\n\n <p>\n\n Welcome to the <b>colors app! üåà</b>\n\n </p>\n\n <button\n\n onClick={getColors}\n\n >\n\n Get Colors!\n\n </button>\n\n <p>\n\n {\n\n colors && JSON.stringify(colors)\n\n }\n\n </p>\n\n </header>\n\n </div>\n\n );\n\n}\n\nThe above code renders a button on the page that fires a function when clicked. Inside that function, we simply make an API call to the endpoint http://localhost:5000/colors and display that data on the page. I also added some simple styles for the button inside the index.css file:\n\nIf you now run the npm start command, you should see the following page:\n\nAwesome! Let's click the button to see what happens.\n\nWe were supposed to get some data rendered on the page, right? But that didn't happen. If you open your browser's console, you'll see an error like this:\n\nAs we saw earlier, the browser blocked our request because our front end and back end are of different origins. You can further verify this by going to the network tab and inspecting the particular network request.\n\nDifferent origins of front end and back end.\n\nNow that you know what a typical CORS error looks like, let's see how we can enable CORS on our server.\n\nHow to Enable CORS on a Server\n\nThere's more than one way to enable CORS on the server. In this section, we'll explore two popular methods.\n\nWe can allow certain or all origins to request a resource from our APIs by sending back a property in the response. This property, called Access-Control-Allow-Origin, can be configured on the headers of our response inside the request handler.\n\nYou can specify the value of this property to be * for any origin or website to access the API. As a result, when the browser sees this value, it allows the website to access the resource from the API regardless of its domain or origin.\n\nIf you click the Get Colors! button on the front end, the request should proceed, and you should see the JSON data on the front end:\n\nAlternately, if you want only users from a certain origin to access your APIs, you can set a specific value to this property. This approach is more suited for the use case where you want to enable CORS for different environments.\n\nThe effect should be the same. If you click the Get Colors! button, you should see the data rendered on the page.\n\nThe npm module provides middleware that you can use in your request handlers. It's simple to use, so let's get started by installing it in our project first:\n\nImport this module at the top:\n\nNext, invoke this middleware in our Express app:\n\nNow all requests received by the server will have cors enabled in them. You can also customize this by passing an options object inside the cors() method. Inside that object, you can specify the origin property, similar to how you set Access-Control-Allow-Origin in the response header previously.\n\nYou can also specify more than one origin by passing an array to the origin property inside your options object:\n\nThe above isn't possible when you manually set the Access-Control-Allow-Origin property on the response header. If you pass more than one origin, the API would have cors disabled, and the error message would tell you to use only a single origin property.\n\nIf you want to specifically enable CORS for a particular request, you can call it inside the request handler:\n\nThis will enable CORS for the /colors API endpoint only.\n\nA lot of times, your front end needs to access some third-party APIs that have CORS disabled. Since you don't have access to the back-end code of those third-party APIs, it's not possible to implement the solutions discussed above. In this case, a proxy server comes in handy. It allows your front end to access resources from a CORS-disabled server.\n\nYou can create a proxy server by using your front end application's module bundler. I have a detailed guide on how you can achieve this in React .\n\nThe other method is creating your own custom proxy server. Let's see how we can implement one.\n\nLet's create another simple NodeJS + Express server with a single endpoint that returns some JSON data.\n\nInside the project, create an index.js file with the following code:\n\nconst express=require('express');\n\n\n\nconst app=express();\n\n\n\napp.get('/user',(req,res)=>{\n\n res.send({\n\n 'name':'FuzzySid',\n\n 'age':'22'\n\n })\n\n})\n\n\n\napp.listen('8080',()=>console.log('CORS Disabled Server is Up and Running...'))\n\nLet's try to use the http://localhost:8080/user endpoint inside our previously made colors-app:\n\nreturn (\n\n <div className=\"App\">\n\n <header className=\"App-header\">\n\n <p>\n\n Welcome to the <b>colors app! üåà</b>\n\n </p>\n\n <button\n\n onClick={getColors}\n\n >\n\n Get Colors!\n\n </button>\n\n <br/>\n\n <button\n\n onClick={getUser}\n\n >\n\n Get User\n\n </button>\n\n <p>\n\n {\n\n colors && JSON.stringify(colors)\n\n }\n\n </p>\n\n </header>\n\n </div>\n\n );\n\n}\n\nWe now have another button that makes a request to our third-party API running at http://locahost:8080/user. Since we don't have CORS enabled on this endpoint, the browser will throw a CORS error when you click the button:\n\nLet's use our other NodeJS + Express app (colors-server) as a proxy server. We'll use that to make a request to the third-party user API and then use our own endpoint to send that data back to our front end. For that, we'll first install to make an HTTP request inside our NodeJS application:\n\nAnd add the following request handler:\n\nNow, we'll make a request to this endpoint‚Äîthat is, http://localhost:5000/user instead of http://localhost:8080/user. Since we have CORS enabled on our own server, we use it as a proxy server to fetch data from the server that our front end can't directly access.\n\nLet's update the getUser() function inside our React application to change the endpoint:\n\nAnd now if we click the Get User button, we should get back the JSON data:\n\nThis is how you can enable CORS on third-party APIs using a custom proxy server.\n\nThis was all about CORS from a server-side perspective. I hope you got the hang of it and will be able to enable it for your NodeJS application using the methods discussed. You can find lots more information on . You can or .\n\nThis post was written by Siddhant Varma. is a full stack JavaScript developer with expertise in frontend engineering. He‚Äôs worked with scaling multiple startups in India and has experience building products in the Ed-Tech and healthcare industries. Siddhant has a passion for teaching and a knack for writing. He's also taught programming to many graduates, helping them become better future developers."
    },
    {
        "link": "https://medium.com/zero-equals-false/using-cors-in-express-cac7e29b005b",
        "document": "Cross-origin resource sharing (CORS) allows AJAX requests to skip the Same-origin policy and access resources from remote hosts.\n\nIn this post I will show you how to enable CORS support in Express. I will also provide some tips to handle common use cases that come up when working with Single Page Applications, like exposing HTTP sessions and custom headers.\n\nThe easiest way to get CORS working in Express is by using the cors npm module.\n\nYou can simply add it as a dependency:\n\nAnd then use it as middleware:\n\nThat‚Äôs it. CORS is now enabled.\n\nIf you make a request to your app, you will notice a new header being returned:\n\nThe Access-Control-Allow-Origin header determines which origins are allowed to access server resources over CORS (the wildcard allows access from any origin).\n\nIf you want to restrict AJAX access to a single origin, you can use the option:\n\nIf you would rather have a list of allowed origins, you can use a function instead of a string as the value:\n\nIf you make a new request to the server, you will notice the header now returns the value of the origin making the request:\n\nBy default, only 6 response headers are exposed over CORS:\n\nIf you want to expose other headers, you can use the option:\n\nYou will notice your server responses now include an additional Access-Control-Expose-Headers header:\n\nHTTP sessions are a tried and true mechanism to deal with authentication on the web. However, HTTP Sessions rely on cookies, which are not sent by default over CORS.\n\nTo enable HTTP cookies over CORS, we need to follow two steps:\n\nThis will make the response include an additional Access-Control-Allow-Credentials header:\n\n2. When making the AJAX request, make sure to set the withCredentials property to .\n\nAdding CORS support in Express is fast and easy, especially if we use the cors library.\n\n** Note: you can find an example express app with CORS support here."
    },
    {
        "link": "https://dev.to/speaklouder/how-to-configure-cors-in-nodejs-with-express-11h",
        "document": "In the dynamic world of web development, ensuring secure and seamless communication between a client and a server is paramount. One crucial aspect of this communication is Cross-Origin Resource Sharing (CORS), which can pose challenges without proper configuration. In this comprehensive guide, we'll delve into the intricacies of configuring CORS in Node.js with Express, offering solutions and insights that cater to both beginners and seasoned developers.\n\nHow to Configure CORS in Node.js With Express\n\nNow, let's address the core of this guide ‚Äì configuring CORS in a Node.js environment using Express. Follow these steps for a robust implementation:\n‚Ä¢ \n‚Ä¢ Begin by installing the middleware using npm:\n‚Ä¢ \n‚Ä¢ Import the module in your Express application.\n\nTo ensure a seamless CORS configuration, consider the following tips:\n‚Ä¢ Keep Origins Secure: Limit cross-origin requests to trusted domains for enhanced security.\n‚Ä¢ Fine-Tune CORS Options: Adjust CORS options according to your application's needs.\n‚Ä¢ Regularly Update Dependencies: Stay updated with the latest versions of CORS middleware and other dependencies for improved security and performance.\n\nConfiguring CORS in Node.js with Express is a fundamental step towards a secure and efficient web application. By following this guide, you've equipped yourself with the knowledge to seamlessly integrate CORS, enhancing the user experience and fortifying your application's security.\n\nYour support will help me continue to bring new content. Love Coding! üíª\n\nComment your thoughts, feedback, and more below! For additional insights on Node.js, Express.js, and system design, visit Nilesh's Blog."
    },
    {
        "link": "https://github.com/expressjs/cors",
        "document": "CORS is a node.js package for providing a Connect/Express middleware that can be used to enable CORS with various options.\n\nThis is a Node.js module available through the npm registry. Installation is done using the command:\n\nThis module supports validating the origin dynamically using a function provided to the option. This function will be passed a string that is the origin (or if the request has no origin), and a with the signature .\n\nThe argument to the callback can be any value allowed for the option of the middleware, except a function. See the configuration options section for more information on all the possible value types.\n\nThis function is designed to allow the dynamic loading of allowed origin(s) from a backing datasource, like a database.\n\nCertain CORS requests are considered 'complex' and require an initial request (called the \"pre-flight request\"). An example of a 'complex' CORS request is one that uses an HTTP verb other than GET/HEAD/POST (such as DELETE) or that uses custom headers. To enable pre-flighting, you must add a new OPTIONS handler for the route you want to support:\n\nYou can also enable pre-flight across-the-board like so:\n\nNOTE: When using this middleware as an application level middleware (for example, ), pre-flight requests are already handled for all routes.\n‚Ä¢ : Configures the Access-Control-Allow-Origin CORS header. Possible values:\n‚Ä¢ - set to to reflect the request origin, as defined by , or set it to to disable CORS.\n‚Ä¢ - set to a specific origin. For example if you set it to only requests from \"http://example.com\" will be allowed.\n‚Ä¢ - set to a regular expression pattern which will be used to test the request origin. If it's a match, the request origin will be reflected. For example the pattern will reflect any request that is coming from an origin ending with \"example.com\".\n‚Ä¢ - set to an array of valid origins. Each origin can be a or a . For example will accept any request from \"http://example1.com\" or from a subdomain of \"example2.com\".\n‚Ä¢ - set to a function implementing some custom logic. The function takes the request origin as the first parameter and a callback (called as , where is a non-function value of the option) as the second.\n‚Ä¢ : Configures the Access-Control-Allow-Methods CORS header. Expects a comma-delimited string (ex: 'GET,PUT,POST') or an array (ex: ).\n‚Ä¢ : Configures the Access-Control-Allow-Headers CORS header. Expects a comma-delimited string (ex: 'Content-Type,Authorization') or an array (ex: ). If not specified, defaults to reflecting the headers specified in the request's Access-Control-Request-Headers header.\n‚Ä¢ : Configures the Access-Control-Expose-Headers CORS header. Expects a comma-delimited string (ex: 'Content-Range,X-Content-Range') or an array (ex: ). If not specified, no custom headers are exposed.\n‚Ä¢ : Configures the Access-Control-Allow-Credentials CORS header. Set to to pass the header, otherwise it is omitted.\n‚Ä¢ : Configures the Access-Control-Max-Age CORS header. Set to an integer to pass the header, otherwise it is omitted.\n‚Ä¢ : Pass the CORS preflight response to the next handler.\n‚Ä¢ : Provides a status code to use for successful requests, since some legacy browsers (IE11, various SmartTVs) choke on .\n\nThe default configuration is the equivalent of:\n\nFor details on the effect of each CORS header, read this article on web.dev.\n\nA demo that illustrates CORS working (and not working) using React is available here: https://node-cors-client.netlify.com\n\nCode for that demo can be found here:"
    },
    {
        "link": "https://axios-http.com/docs/handling_errors",
        "document": "Using the config option, you can define HTTP code(s) that should throw an error.\n\nUsing you get an object with more information about the HTTP error."
    },
    {
        "link": "https://axios-http.com/docs/intro",
        "document": "Promise based HTTP client for the browser and node.js\n\nAxios is a promise-based HTTP Client for and the browser. It is isomorphic (= it can run in the browser and nodejs with the same codebase). On the server-side it uses the native node.js module, while on the client (browser) it uses XMLHttpRequests.\n‚Ä¢ Progress capturing for browsers and node.js with extra info (speed rate, remaining time)\n\nPrebuilt CommonJS modules for direct importing with require (if your module bundler failed to resolve them automatically)"
    },
    {
        "link": "https://dev.to/mperon/axios-error-handling-like-a-boss-333d",
        "document": "I really love the problem/solution. approach. We see some problem, and then, a really nice solution. But for this talking, i think we need some introduction as well.\n\nWhen you develop an web application, you generally want's to separate the frontend and backend. Fo that, you need something that makes the communication between these guys.\n\nTo illustrate, you can build a frontend (commonly named as GUI or user interface) using vanilla HTML, CSS and Javascript, or, frequently, using several frameworks like Vue, React and so many more avaliable online. I marked Vue because it's my personal preference.\n\nWhy? I really don't study the others so deeply that i can't assure to you that Vue is the best, but i liked the way he works, the syntax, and so on. It's like your crush, it's a personal choice.\n\nBut, beside that, any framework you use, you will face the same problem:_ How to communicate with you backend_ (that can be written in so many languages, that i will not dare mention some. My current crush? Python an Flask).\n\nOne solution is to use AJAX (What is AJAX? Asynchronous JavaScript And XML). You can use XMLHttpRequest directly, to make requests to backend and get the data you need, but the downside is that the code is verbose. You can use Fetch API that will make an abstraction on top of , with a powerfull set of tools. Other great change is that will use Promises, avoiding the callbacks from (preventing the callback hell).\n\nAlternatively, we have a awesome library named Axios, that have a nice API (for curiosity purposes, under the hood, uses , giving a very wide browser support). The Axios API wraps the into , different from . Beside that, nowadays is well supported by the browsers engines available, and have polyfills for older browsers. I will not discuss which one is better because i really think is personal preference, like any other library or framework around. If you dont't have an opinion, i suggest that you seek some comparisons and dive deep articles. Has a nice article that i will mention to you written by Faraz Kelhini.\n\nMy personal choice is because have a nice API, has Response timeout, automatic JSON transformation, and Interceptors (we will use them in the proposal solution), and so much more. Nothing that cannot be accomplished by , but has another approach.\n\nTalking about , a simple GET HTTP request can be made with these lines of code:\n\n\n\nWe've used Typescript (interfaces, and generics), ES6 Modules, Promises, Axios and Arrow Functions. We will not touch them deeply, and will presume that you already know about them.\n\nSo, in the above code, if everything goes well, aka: the server is online, the network is working perfectly, so on, when you run this code you will see the list of users on console. The real life isn't always perfect.\n\nSo, when something is go bad, we need to use all the efforts in ours hands to resolve the problem ourselves, without the user even notice, and, when nothing more can be done, we have the obligation to show them a really nice message explaining what goes wrong, to easy theirs souls.\n\nlike uses to handle asynchronous calls and avoid the callbacks that we mention before. are a really nice API and not to difficult to understand. We can chain actions ( ) and error handlers ( ) one after another, and the API will call them in order. If an Error occurs in the Promise, the nearest is found and executed.\n\nSo, the code above with basic error handler will become:\n\n\n\nOk, and what is the problem then? Well, we have a hundred errors that, in every API call, the solution/message is the same. For curiosity, Axios show us a little list of them: . We have the HTTP Status Codes, where we found so many errors, like (Page Not Found), and so on. You get the picture. We have too much common errors to elegantly handle in every API request.\n\nOne very ugly solution that we can think of, is to write one big ass function that we increment every new error we found. Besides the ugliness of this approach, it will work, if you and your team remember to call the function in every API request.\n\n\n\nWith our magical badass function in place, we can use it like that:\n\n\n\nWe have to remember to add this in every API call, and, for every new error that we can graciously handle, we need to increase our nasty with some more code and ugly .\n\nOther problem we have with this approach, besides ugliness and lack of mantenability, is that, if in one, only single one API call, i desire to handle different from global approach, i cannot do.\n\nThe function will grow exponentially as the problems that came together. This solution will not scale right!\n\nWhen we work as a team, to make them remember the slickness of every piece of software is hard, very hard. Team members, come and go, and i do not know any documentation good enough to surpass this issue.\n\nIn other hand, if the code itself can handle these problems on a generic way, do-it! The developers cannot make mistakes if they need do nothing!\n\nBefore we jump into code (that is what we expect from this article), i have the need to speak some stuff to you understand what the codes do.\n\nAxios allow we to use something called that will be executed in every request you make. It's a awesome way of checking permission, add some header that need to be present, like a token, and preprocess responses, reducing the amount of boilerplate code.\n\nWe have two types of . Before (request) and After (response) an AJAX Call.\n\nIt's use is simple as that:\n\n\n\nBut, in this article, we will use the response interceptor, because is where we want to deal with errors. Nothing stops you to extend the solution to handle request errors as well.\n\nAn simple use of response interceptor, is to call ours big ugly function to handle all sort of errors.\n\nAs every form of automatic handler, we need a way to bypass this (disable), when we want. We are gonna extend the interface and add two optional options and . If is set to , we are gonna do nothing. is there to mute notifications that we show when dealing with global errors.\n\n\n\nNext step is to create a class that we will throw every time we want to inform the error handler to assume the problem.\n\n\n\nWell, we do not need to remember our magical badass function in every ajax call we made. And, we can disable when we want, just passing to request config.\n\n\n\nOk, this is a nice solution, but, this bad-ass ugly function will grow so much, that we cannot see the end. The function will become so big, that anyone will want to maintain.\n\nCan we improve more? Oh yeahhh.\n\nWe are gonna develop an class, using Registry Design Pattern. The class will allow you to register error handling by an key (we will deep dive in this in a moment) and a action, that can be an string (message), an object (that can do some nasty things) or an function, that will be executed when the error matches the key. The registry will have parent that can be placed to allow you override keys to custom handle scenarios.\n\nHere are some types that we will use througth the code:\n\n\n\nSo, with types done, let's see the class implementation. We are gonna use an Map to store object/keys and a parent, that we will seek if the key is not found in the current class. If parent is null, the search will end. On construction, we can pass an parent,and optionally, an instance of , to register some handlers.\n\n\n\nLet's deep dive the code. We choose to use as an identifier to select the best handler for error. When you look at the code, you see that has an order that will be searched in the registry. The rule is, search for the most specific to the most generic.\n\n\n\nThis is an example of an error sent by API:\n\n\n\nOther example, as well:\n\n\n\nSo, as an example, we can now register ours generic error handling:\n\n\n\nWe can register error handler in any place we like, group the most generic in one typescript file, and specific ones inline. You choose. But, to this work, we need to attach to ours axios instance. This is done like this:\n\n\n\nNow, we can make ajax requests, and the error handler will work as expected:\n\n\n\nThe code above will show a Notify ballon on the user screen, because will fire the error status code, that we registered before.\n\nThe solution doesn't end here. Let's assume that, in one, only one http request, you want to handle differently, but just . For that, we create the function below:\n\n\n\nThis function uses the parent to personalize one key, but for all others, use the global handlers (if you wanted that, is there to force not).\n\nSo, we can write code like this:\n\n\n\nAll this explanation is nice, but code, ah, the code, is so much better. So, i've created an github repository with all code from this article organized to you try out, improve and customize.\n‚Ä¢ Click here to access the repo in github.\n‚Ä¢ This post became so much bigger than a first realize, but i love to share my thoughts.\n‚Ä¢ If you have some improvement to the code, please let me know in the comments.\n‚Ä¢ If you see something wrong, please, fix-me!"
    },
    {
        "link": "https://github.com/axios/axios",
        "document": "Promise based HTTP client for the browser and node.js\n\nOnce the package is installed, you can import the library using or approach:\n\nYou can also use the default export, since the named export is just a re-export from the Axios factory:\n\nIf you use for importing, only default export is available:\n\nFor some bundlers and some ES6 linters you may need to do the following:\n\nFor cases where something went wrong when trying to import a module into a custom or legacy environment, you can try importing the module package directly:\n\nRequests can be made by passing the relevant config to .\n\nFor convenience, aliases have been provided for all common request methods.\n\nWhen using the alias methods , , and properties don't need to be specified in config.\n\nPlease use to replace the below functions.\n\nYou can create a new instance of axios with a custom config.\n\nThe available instance methods are listed below. The specified config will be merged with the instance config.\n\nThese are the available config options for making requests. Only the is required. Requests will default to if is not specified.\n\n// `url` is the server URL that will be used for the request : // `method` is the request method to be used when making the request : // `baseURL` will be prepended to `url` unless `url` is absolute and option `allowAbsoluteUrls` is set to true. // It can be convenient to set `baseURL` for an instance of axios to pass relative URLs // to methods of that instance. : // `allowAbsoluteUrls` determines whether or not absolute URLs will override a configured `baseUrl`. // When set to true (default), absolute values for `url` will override `baseUrl`. // When set to false, absolute values for `url` will always be prepended by `baseUrl`. : // `transformRequest` allows changes to the request data before it is sent to the server // This is only applicable for request methods 'PUT', 'POST', 'PATCH' and 'DELETE' // The last function in the array must return a string or an instance of Buffer, ArrayBuffer, // You may modify the headers object. : // Do whatever you want to transform the data // `transformResponse` allows changes to the response data to be made before // it is passed to then/catch : // Do whatever you want to transform the data // `headers` are custom headers to be sent : : // `params` are the URL parameters to be sent with the request // Must be a plain object or a URLSearchParams object : : // `paramsSerializer` is an optional config that allows you to customize serializing `params`. : // Custom encoder function which sends key/value pairs in an iterative fashion. ?: : : /* Do custom operations here and return transformed string */ // Custom serializer function for the entire parameter. Allows user to mimic pre 1.x behaviour. ?: : any ?: // Configuration for formatting array indexes in the params. : // Three available options: (1) indexes: null (leads to no brackets), (2) (default) indexes: false (leads to empty brackets), (3) indexes: true (leads to brackets with indexes). // `data` is the data to be sent as the request body // Only applicable for request methods 'PUT', 'POST', 'DELETE , and 'PATCH' // When no `transformRequest` is set, must be of one of the following types: : : // syntax alternative to send data into the body // only the value is sent, not the key : // `timeout` specifies the number of milliseconds before the request times out. // If the request takes longer than `timeout`, the request will be aborted. : // `withCredentials` indicates whether or not cross-site Access-Control requests // should be made using credentials : // `adapter` allows custom handling of requests which makes testing easier. : // Also, you can set the name of the built-in adapter, or provide an array with their names // to choose the first available in the environment : // `auth` indicates that HTTP Basic auth should be used, and supplies credentials. // This will set an `Authorization` header, overwriting any existing // `Authorization` custom headers you have set using `headers`. // Please note that only HTTP Basic auth is configurable through this parameter. // For Bearer tokens and such, use `Authorization` custom headers instead. : : : // `responseType` indicates the type of data that the server will respond with : // `responseEncoding` indicates encoding to use for decoding responses (Node.js only) // Note: Ignored for `responseType` of 'stream' or client-side requests : // `xsrfCookieName` is the name of the cookie to use as a value for xsrf token : // `xsrfHeaderName` is the name of the http header that carries the xsrf token value : // `undefined` (default) - set XSRF header only for the same origin requests : : // `onUploadProgress` allows handling of progress events for uploads : loaded total progress bytes estimated rate upload // Do whatever you want with the Axios progress event // `onDownloadProgress` allows handling of progress events for downloads : loaded total progress bytes estimated rate download // Do whatever you want with the Axios progress event // `maxContentLength` defines the max size of the http response content in bytes allowed in node.js : // `maxBodyLength` (Node only option) defines the max size of the http request content in bytes allowed : // `validateStatus` defines whether to resolve or reject the promise for a given // HTTP response status code. If `validateStatus` returns `true` (or is set to `null` // or `undefined`), the promise will be resolved; otherwise, the promise will be : // `maxRedirects` defines the maximum number of redirects to follow in node.js. // If set to 0, no redirects will be followed. : // `beforeRedirect` defines a function that will be called before redirect. // Use this to adjust the request options upon redirecting, // or to cancel the request by throwing an error // If maxRedirects is set to 0, `beforeRedirect` is not used. : headers // `socketPath` defines a UNIX Socket to be used in node.js. // e.g. '/var/run/docker.sock' to send requests to the docker daemon. // Only either `socketPath` or `proxy` can be specified. // If both are specified, `socketPath` is used. : // `transport` determines the transport method that will be used to make the request. // If defined, it will be used. Otherwise, if `maxRedirects` is 0, // the default `http` or `https` library will be used, depending on the protocol specified in `protocol`. // Otherwise, the `httpFollow` or `httpsFollow` library will be used, again depending on the protocol, : // `httpAgent` and `httpsAgent` define a custom agent to be used when performing http // and https requests, respectively, in node.js. This allows options to be added like // `keepAlive` that are not enabled by default. : : : : // `proxy` defines the hostname, port, and protocol of the proxy server. // You can also define your proxy using the conventional `http_proxy` and // `https_proxy` environment variables. If you are using environment variables // for your proxy configuration, you can also define a `no_proxy` environment // variable as a comma-separated list of domains that should not be proxied. // `auth` indicates that HTTP Basic auth should be used to connect to the proxy, and // This will set an `Proxy-Authorization` header, overwriting any existing // `Proxy-Authorization` custom headers you have set using `headers`. // If the proxy server uses HTTPS, then you must set the protocol to `https`. : : : // hostname: '127.0.0.1' // Takes precedence over 'host' if both are defined : : : : // `cancelToken` specifies a cancel token that can be used to cancel the request // (see Cancellation section below for details) : // an alternative way to cancel Axios requests using AbortController : // `decompress` indicates whether or not the response body should be decompressed // automatically. If set to `true` will also remove the 'content-encoding' header // from the responses objects of all decompressed responses // - Node only (XHR cannot turn off decompression) : // Indicates where to use an insecure HTTP parser that accepts invalid HTTP headers. // This may allow interoperability with non-conformant HTTP implementations. // Using the insecure parser should be avoided. : // transitional options for backward compatibility that may be removed in the newer versions : // `true` - ignore JSON parsing errors and set response.data to null if parsing failed (old behaviour) // `false` - throw SyntaxError if JSON parsing failed (Note: responseType must be set to 'json') : // default value for the current Axios version // try to parse the response string as JSON even if `responseType` is not 'json' : // throw ETIMEDOUT error instead of generic ECONNABORTED on request timeouts : : // The FormData class to be used to automatically serialize the payload into a FormData object : : : : // use dots instead of brackets format : // keep special endings like {} in parameter key : :\n\nThe response for a request contains the following information.\n\nWhen using , you will receive the response as follows:\n\nWhen using , or passing a rejection callback as second parameter of , the response will be available through the object as explained in the Handling Errors section.\n\nYou can specify config defaults that will be applied to every request.\n\nConfig will be merged with an order of precedence. The order is library defaults found in lib/defaults/index.js, then property of the instance, and finally argument for the request. The latter will take precedence over the former. Here's an example.\n\nYou can intercept requests or responses before they are handled by or .\n\nIf you need to remove an interceptor later you can.\n\nYou can also clear all interceptors for requests or responses.\n\nYou can add interceptors to a custom instance of axios.\n\nWhen you add request interceptors, they are presumed to be asynchronous by default. This can cause a delay in the execution of your axios request when the main thread is blocked (a promise is created under the hood for the interceptor and your request gets put on the bottom of the call stack). If your request interceptors are synchronous you can add a flag to the options object that will tell axios to run the code synchronously and avoid any delays in request execution.\n\nIf you want to execute a particular interceptor based on a runtime check, you can add a function to the options object. The request interceptor will not be executed if and only if the return of is . The function will be called with the config object (don't forget that you can bind your own arguments to it as well.) This can be handy when you have an asynchronous request interceptor that only needs to run at certain times.\n\nGiven you add multiple response interceptors and when the response was fulfilled\n‚Ä¢ then each interceptor is executed\n‚Ä¢ then they are executed in the order they were added\n‚Ä¢ then only the last interceptor's result is returned\n‚Ä¢ then every interceptor receives the result of its predecessor\n‚Ä¢ and when the fulfillment-interceptor throws\n‚Ä¢ then the following fulfillment-interceptor is not called\n‚Ä¢ then the following rejection-interceptor is called\n‚Ä¢ once caught, another following fulfill-interceptor is called again (just like in a promise chain).\n\nRead the interceptor tests for seeing all this in code.\n\nThere are many different axios error messages that can appear that can provide basic information about the specifics of the error and where opportunities may lie in debugging.\n\nThe general structure of axios errors is as follows:\n\nBelow is a list of potential axios identified error:\n\nthe default behavior is to reject every response that returns with a status code that falls out of the range of 2xx and treat it as an error.\n\nUsing the config option, you can override the default condition (status >= 200 && status < 300) and define HTTP code(s) that should throw an error.\n\nUsing you get an object with more information about the HTTP error.\n\nStarting from Axios supports AbortController to cancel requests in fetch API way:\n\nYou can also cancel a request using a CancelToken.\n\nYou can create a cancel token using the factory as shown below:\n\nYou can also create a cancel token by passing an executor function to the constructor:\n\nBy default, axios serializes JavaScript objects to . To send data in the format instead, you can use the API, which is supported in the vast majority of browsers,and Node starting with v10 (released in 2018).\n\nFor compatibility with very old browsers, there is a polyfill available (make sure to polyfill the global environment).\n\nAlternatively, you can encode data using the library:\n\nOr in another way (ES6),\n\nFor older Node.js engines, you can use the module as follows:\n\nYou can also use the library.\n\nAxios will automatically serialize the data object to urlencoded format if the content-type header is set to \"application/x-www-form-urlencoded\".\n\nThe server will handle it as:\n\nIf your backend body-parser (like of ) supports nested objects decoding, you will get the same object on the server-side automatically\n\nTo send the data as a you need to pass a formData instance as a payload. Setting the header is not required as Axios guesses it based on the payload type.\n\nIn node.js, you can use the library as follows:\n\nStarting from , Axios supports automatic object serialization to a FormData object if the request header is set to .\n\nThe following request will submit the data in a FormData format (Browser & Node.js):\n\nIn the build, the ( ) polyfill is used by default.\n\nYou can overload the FormData class by setting the config variable, but you probably won't need it in most cases:\n\nAxios FormData serializer supports some special endings to perform the following operations:\n‚Ä¢ - serialize the value with JSON.stringify\n‚Ä¢ - unwrap the array-like object as separate fields with the same key\n‚Ä¢ - user-defined visitor function that will be called recursively to serialize the data object to a object by following custom rules.\n‚Ä¢ - use dot notation instead of brackets to serialize arrays and objects;\n‚Ä¢ - add the special ending (e.g ) in the FormData key. The back-end body-parser could potentially use this meta-information to automatically parse the value as JSON.\n‚Ä¢ - controls how indexes will be added to unwrapped keys of array-like objects.\n\nLet's say we have an object like this one:\n\nThe following steps will be executed by the Axios serializer internally:\n\nAxios supports the following shortcut methods: , , which are just the corresponding http methods with the header preset to .\n\nAll files will be sent with the same field names: .\n\nPass HTML Form element as a payload to submit it as content.\n\nand objects can also be posted as by explicitly setting the header to :\n\nFor example, the Form\n\nwill be submitted as the following JSON object:\n\nSending / as JSON ( ) is not currently supported.\n\nAxios supports both browser and node environments to capture request upload/download progress. The frequency of progress events is forced to be limited to times per second.\n\nYou can also track stream upload/download progress in node.js:\n\nDownload and upload rate limits can only be set for the http adapter (node.js):\n\nAxios has its own class to manipulate headers using a Map-like API that guarantees caseless work. Although HTTP is case-insensitive in headers, Axios will retain the case of the original header for stylistic reasons and for a workaround when servers mistakenly consider the header's case. The old approach of directly manipulating headers object is still available, but deprecated and not recommended for future usage.\n\nAn AxiosHeaders object instance can contain different types of internal values. that control setting and merging logic. The final headers object with string values is obtained by Axios by calling the method.\n\nThe header value can be one of the following types:\n‚Ä¢ - normal string value that will be sent to the server\n‚Ä¢ - skip header when rendering to JSON, additionally indicates that method must be called with option set to to overwrite this value (Axios uses this internally to allow users to opt out of installing certain headers like or )\n‚Ä¢ - value is not set\n\nThe headers object is always initialized inside interceptors and transformers:\n\nYou can iterate over an instance using a statement:\n\nIf the headers object is a string, it will be parsed as RAW HTTP headers.\n‚Ä¢ - do not overwrite if header's value is set (is not )\n‚Ä¢ (default) - overwrite the header unless its value is set to\n\nThe option can also accept a user-defined function that determines whether the value should be overwritten or not.\n\nReturns the internal value of the header. It can take an extra argument to parse the header's value with , matcher function or internal key-value parser.\n\nReturns the value of the header.\n\nReturns if the header is set (has no value).\n\nReturns if at least one header has been removed.\n\nRemoves all headers. Unlike the method matcher, this optional matcher will be used to match against the header name rather than the value.\n\nReturns if at least one header has been cleared.\n\nIf the headers object was changed directly, it can have duplicates with the same name but in different cases. This method normalizes the headers object by combining duplicate keys into one. Axios uses this method internally after calling each interceptor. Set to true for converting headers name to lowercase and capitalize the initial letters ( => )\n\nMerges the instance with targets into a new instance. If the target is a string, it will be parsed as RAW HTTP headers.\n\nResolve all internal headers values into a new null prototype object. Set to true to resolve arrays as a string containing all elements, separated by commas.\n\nReturns a new instance created from the raw headers passed in, or simply returns the given headers object if it's an instance.\n\nReturns a new instance created by merging the target objects.\n\nThe following shortcuts are available:\n\nFetch adapter was introduced in . By default, it will be used if and adapters are not available in the build, or not supported by the environment. To use it by default, it must be selected explicitly:\n\nYou can create a separate instance for this:\n\nThe adapter supports the same functionality as adapter, including upload and download progress capturing. Also, it supports additional response types such as and (if supported by the environment).\n\nUntil axios reaches a release, breaking changes will be released with a new minor version. For example , and will have the same API, but will have breaking changes.\n\naxios depends on a native ES6 Promise implementation to be supported. If your environment doesn't support ES6 Promises, you can polyfill.\n\nBecause axios dual publishes with an ESM default export and a CJS , there are some caveats. The recommended setting is to use (this is implied by ). Note that this requires TypeScript 4.7 or greater. If use ESM, your settings should be fine. If you compile TypeScript to CJS and you can‚Äôt use , you have to enable . If you use TypeScript to type check CJS JavaScript code, your only option is to use .\n\nYou can use Gitpod, an online IDE(which is free for Open Source) for contributing or running the examples online.\n\naxios is heavily inspired by the $http service provided in AngularJS. Ultimately axios is an effort to provide a standalone -like service for use outside of AngularJS."
    },
    {
        "link": "https://stackoverflow.com/questions/49967779/axios-handling-errors",
        "document": "I'm trying to understand javascript promises better with Axios. What I pretend is to handle all errors in Request.js and only call the request function from anywhere without having to use . In this example, the response to the request will be 400 with an error message in JSON. This is the error I'm getting: The only solution I find is to add in Somewhere.js but I'm trying to avoid having to do that. Is it possible?"
    }
]