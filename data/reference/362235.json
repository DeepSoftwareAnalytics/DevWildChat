[
    {
        "link": "https://create.roblox.com/docs/scripting",
        "document": "Scripts are plain text files that let you add custom, dynamic behavior to your experiences. You can use scripts to trigger in-game events, respond to player input, save player data, create leaderboards, spawn enemies, control NPC behavior, and much, much more.\n\nThis section is for creators with some coding experience who want to know the specifics of scripting in Roblox. If you've never written code before and want an introduction to programming, see Coding fundamentals, which covers concepts like variables, functions, conditionals, loops, and arrays. For a more guided, step-by-step approach, see the Basic gameplay tutorial.\n\nRoblox scripts use the Luau programming language, which is derived from Lua 5.1.\n• None Compared to Lua 5.1, Luau adds performance enhancements and many useful features, including an optional typing system, string interpolation, and generalized iteration for tables.\n• None All valid Lua 5.1 code is valid Luau code, but the opposite is not true.\n\nMost books and online resources for Lua are still broadly applicable to Luau. For a detailed summary of differences, see Compatibility in the Luau documentation. For language syntax, see the Luau reference.\n\nLuau is gradually typed, so you don't need to specify a type when you create a variable. You can use type() to check object type:\n\nLuau has global and local scopes, but it's almost always better to declare variables and functions locally with the local keyword:\n\nLua uses nil to represent nonexistence or nothingness, which evaluates as false in conditional statements:\n\nAs you might have noticed, -- starts a one-line comment. --[[]] creates a block comment:\n\nTables are the generic term for arrays and dictionaries. Arrays are one-based rather than zero-based, so the first item is [1]. You declare arrays and dictionaries with a single set of curly braces:\n\nYou can iterate over tables using for loops with the ipairs() function for arrays and the pairs() function for dictionaries, but Luau also lets you omit these functions for cleaner syntax:\n• None In Roblox Studio, hover over ServerScriptService in the Explorer window and click +.\n• None Right-click the script and rename it to HelloScript.\n• None Double-click the script to open it in the Script Editor.\n• None Add the following code to the file:\n• None Ensure that the Output window is open.\n\nA big part of adapting to a new development environment is configuring it to meet your needs and understanding the tools at your disposal:\n• None The section of lets you adjust quality of life features like font, colors, indentation, autocomplete, brackets, and tooltips. You might also want to enable dark mode in the section.\n• None or and clicking on a function or variable takes you to its declaration in your codebase (or its online documentation). Using Holdingorand clicking on a function or variable takes you to its declaration in your codebase (or its online documentation). Using can help you navigate larger projects.\n• None menu to enable and . The window is the most basic tool for understanding the behavior of your scripts. Use themenu to enableand\n• None The window shows a summary of errors and warnings, but you might find its utility limited; the Script Editor already highlights these issues as you type.\n• None or . Use and . Logging capabilities are minimal, with no concept of log levels likeor. Useand\n\nFor more information about configuring Studio for scripting, see Script Editor. For information on using your favorite text editor and version control system, see External tools.\n• None In Roblox Studio, add a script to ReplicatedStorage in the Explorer window and rename it to OhNo.\n• None Add the following code to the file:\n• None Note how the output is no different than when you ran your first script.\n\nTo understand why the script didn't run, see Script Types and Locations."
    },
    {
        "link": "https://create.roblox.com/docs/tutorials/use-case-tutorials/scripting/basic-scripting/intro-to-scripting",
        "document": "In Introduction to Roblox Studio, you learned how to create and manipulate parts in Roblox Studio. In this tutorial, you'll learn how to apply a script to parts to make a platform appear and disappear. You can use this in a platforming experience to span a gap, challenging users to time their jumps carefully to get to the other side.\n\nFirst off, you need a Part to act as the platform. Making and moving parts should be familiar to you from Introduction to Roblox Studio. You don't need a complicated world aside from the platform — you just need a gap that your users can't easily jump across.\n• None Insert a Part and rename it to DisappearingPlatform.\n• None Resize it to large enough for a user to jump on.\n• None Move it to a proper location so that you can reach it and jump on it when testing your experience.\n• None Set the Anchored property to true in the Properties window.\n\nCode in Roblox is written in a language called Luau which you can put in scripts within various containers in the Explorer. If you put a script under a Part, Roblox will run the script's code when the part is loaded into the game.\n• None Hover over the DisappearingPlatform part in the Explorer window and click the + button to insert a new script into the platform. Rename your new script as Disappear.\n\nIt's a good idea to start off your script by making a variable for the platform. A variable is a name associated with a value. Once a variable is created, it can be used again and again. You can change the value as needed.\n\nIn Luau, a variable is created as follows: local variableName = variableValue.\n\nThe term local means that the variable is only going to be used in the block of the script where it's declared. The = sign is used to set the value of the variable. Names for variables are typically written in camel case. This is lowercase with every word following the first being capitalized, justLikeThis.\n\nCopy the following code to create a variable for the platform called platform, where the value is script.Parent.\n\nTime to make the platform disappear. It's always best to group code for achieving a specific action into a function. A function is a named block of code that helps you organize your code and use it in multiple places without writing it again. Create a function in the script and call it disappear.\n\nThe first new line declares the function — it indicates the start of the function and names it as disappear. The code for a function goes between the first line and end.\n\nThe parentheses are for including additional information as needed. You'll learn more about passing information to functions in a later course.\n\nWhen the platform disappears, it needs to be invisible and users need to fall through it — but you can't just destroy the platform since it needs to reappear later.\n\nParts have various properties that can be used here. Remember that you can see a part's properties if you select it and look at the Properties window.\n\nA part can be made invisible by changing the Transparency property. Transparency can be a value between 0 and 1, where 1 is fully transparent and therefore invisible.\n\nThe CanCollide property determines if other parts (and users) can pass right through the part. If you set it to false, users will fall through the platform.\n\nJust like script.Parent, properties are accessed using a dot. Values are assigned using an equals sign.\n• None In the disappear function, set the CanCollide property of the platform to false.\n• None On the line following, set the Transparency property to 1.\n\nOnce you've declared a function, you can run it by writing its name with parentheses next to it. For example, disappear() will run the disappear function. This is known as calling a function.\n• None Call the disappear function at the end of the script.\n• None Test the code by pressing the Play button. If your code works, the platform should have disappeared by the time the user spawns into the game.\n\nYou can easily make the platform reappear by writing a function that does the exact opposite of the disappear function.\n• None Delete the disappear() line from the script.\n• None In the function body, set the CanCollide property to true and the Transparency property to 0.\n\nThe platform should be constantly disappearing and reappearing, with a few seconds between each change. It's impossible to write an infinite number of function calls — fortunately, with a while loop, you don't have to.\n\nA while loop runs the code inside it for as long as the statement after while remains true. This particular loop needs to run forever, so the statement should just be true. Create a while true loop at the end of your script.\n\nIn the while loop, you need to write code to wait a few seconds between the platform disappearing and reappearing.\n\nThe built-in function task.wait() can be used for this. In the parentheses the number of seconds to wait is needed: for example task.wait(3).\n\nThree seconds is a sensible starting point for the length of time between each platform state.\n• None In the while loop, call the function with in the parentheses.\n• None Call the function again with in the parentheses.\n\nThe code for the platform is now complete! Test your code now and you should find that the platform disappears after three seconds and reappears three seconds later in a loop.\n\nYou could duplicate this platform to cover a wider gap, but you need to change the wait times in each script. Otherwise, the platforms will all disappear at the same time and users will never be able to cross."
    },
    {
        "link": "https://create.roblox.com/docs/workspace",
        "document": "Workspace is a container service that holds objects that you want the Roblox Engine to render in the 3D world. You typically will add these objects to the workspace:\n• None objects, which includes both and objects.\n• None objects, which you can attach to special effect generators like a , UI objects like a , physical , and more. objects, which you can attach to special effect generators like a, UI objects like a, physical, and more.\n• None objects that are parented by other objects in the workspace. Scripts aren't rendered but can affect another object's rendering. objects that are parented by other objects in the workspace. Scripts aren't rendered but can affect another object's rendering.\n\nPart objects represent the primitive building blocks in Roblox. By default, all parts have their physics simulated and are rendered if they appear in the 3D workspace. Parts can take the shape of blocks, spheres, cylinders, wedges, or corner wedges. In addition, TrussPart acts as a truss beam that characters can climb like a ladder.\n\nYou can also apply solid modeling operations to parts, such as union or negate, to combine them into something more complex like bowls or hollow pipes.\n\nA MeshPart is an object that represents a mesh (a collection of vertices, edges, and faces that make up a 3D object). You typically create meshes using third-party software such as Blender or Maya, then import them as a MeshPart using Studio.\n\nMeshes can include far more detail than any solid modeling you can do in Studio. They can also have internal rigs and textures, allowing you to create lifelike objects that you can pose and animate.\n\nThe Terrain object allows you to generate and sculpt detailed and realistic terrain environments, such as mountains, bodies of water, grass-covered hills, or a flat desert. Using the Terrain Editor, you can easily generate and alter large regions of terrain.\n\nA Model is a container object for geometric groupings, such as BasePart, Motor6D objects, and other models. Models can be simple groupings or you can set a primary part within the model, so that it functions as an assembly, which the physics engine treats as a single rigid body. Models can also contain scripts that act on the individual objects of the model.\n\nWithin a script, you can access a place's Workspace in three different ways, all of which are valid.\n\nFrom there, you can carry out a large set of use cases to script logic for your experiences and create dynamic worlds and interactions. For example:\n• None Obtain a reference to any object in the workspace to change its properties during runtime.\n• None object to Obtain a reference to a user'sobject to of the workspace.\n• None Listen for events on objects in the workspace to carry out logic at specific times, such as when a user's playable character"
    },
    {
        "link": "https://devforum.roblox.com/t/lua-scripting-starter-guide/394618",
        "document": "Picking up programming and learning it for the first time works just like any other hobby–art, music, sports, photography, etc.–although, it may be difficult to know where to start as a beginner, especially if you’ve never had experience with it up until now. When I was younger, it was very difficult for me to get into programming as tutorials for a younger, completely unexperienced audience was rare. Although there was plenty of content available, I still had a hard time understanding the material or just got lost in the sea of information that was given to me. There are still plenty of places on either Youtube or other parts of the internet where beginners can learn, but I’ve specifically compiled this list so that you have a neat, simple page you can refer to if you feel lost, or don’t know where to go after searching for tutorials. Becoming an experienced programmer from scratch will not be easy, it will take a lot of effort and more importantly time to become an expert. I say this because many developers I’ve personally known, whether rookies or professionals, tend to bail halfway through their project or goal. Do not lose hope when things don’t come as quickly as you expected, patience is crucial. What sets poor and excellent students isn’t necessarily intelligence, but their willingness to put in work and always seeking new ways to become better at what they do. Think of this article as a legend for Lua, similar to the page in a large book that highlight specific terms or character in the book that the reader might not recognize. When you finish this guide, your ability to code things will be limited, but you should have a much easier time understanding tutorials on more advanced topics. Ultimately, I hope this article can help you get started, or at least guide you through your journey through programming.\n\nP.S. I’ve tried to make this tutorial as kid-friendly as possible, if it is still difficult to read or understand, please DM me on any platform and I’ll try my best fix it. Specific examples are appreciated.\n\nChances are, if you’ve ever played a game, you’ve wondered how it was made. How does a sword go from unequipped to swinging in just a matter of seconds? Why? How is this app able to stream the movies I select? How is the website we’re currently on even able to operate?\n\nComputer programming is an essential part of modern life, as it determines and allows for many technologies we use on a daily basis to operate. However, all code is not written in the same way, rather, there are distinct languages, or ways of writing code. In fact, you might already be familiar with the names of various programming languages, including but not limited to JavaScript or Python.\n\nIn this tutorial, we’ll be covering Lua, the official language of Roblox which can be used to create a variety of different games for users to play.\n\nIn this tutorial, we’ll be using a specific format to write, input, and receive the result of our script. To use a format identical to mine, click on View in the upper left side of your screen, then make sure you have selected and have the following settings:\n\nYour screen should look something similar to this\n\nScripts can be inserted almost everywhere, for the sake of keeping this tutorial short, head over to Model on the top panel and browse to the far left and click on Script, which will generate a script that we can use for our tutorial.\n\nPrint is a built-in function which prints out whatever statement you decide to give it. This can be either number or strings, which we’ll cover in this section. You’ll notice that once you launch a script, there is already a print function automatically typed out for you. This code always comes with your scripts, so we’ll erase it to continue with the next step.\n\nType out print in all lowercase letters. If print is typed incorrectly or typed with any capitals, the program will not recognize the command and will not run it. Add a pair of parenthesis after, studio should automatically add the second one. Make sure there is no space in between print and the parenthesis otherwise Lua will not be able to read it.\n\nNext, we need to add a string in-between the parenthesis so that we don’t just print empty space. A string is any character or words inside of a pair of quotes, such as “Hello World!” For our tutorial, we’ll be adding the string “YellowNoobs!” for the program to print.\n\nYou may replace \"YellowNoobs\" with any other text you wish as long as it is in-between the parenthesis (\"\"), the end result should look something like this,\n\nIf you want to include quotation marks in your quote, you can also use a pair of single quotes (’’) and put the double parenthesis, or vice-versa for single quotes to be printed.\n\nPrint also works for numbers and equations, which it’ll automatically simplify in the output. But before we write out our problem, we need to find the symbols needed to get the right answer.\n\nArithmetic operators are basically all the tools we use in programming to indicate a relationship between numbers. This sounds complicated, but it’s just what we call the symbols we use to add, subtract, multiply, and divide numbers.\n\nHere are the Arithmetic Operators used in Lua:\n\nNow, we’ll write our equation in-between the parenthesis, and paste it into the command bar once we’re ready to get the output. Feel free to mess around with the operators to get the hang of it.\n\nIf we put our code into the command bar we’ll get 81 instead. This is the answer to the equation, and Lua does this because it’s a simplified version, or answer to the problem we originally printed. An important thing to keep in mind is that Lua completes the math using the Order of Operations, meaning it starts with exponents, then division and multiplication, and finally addition and subtraction.\n\nTake this piece of code for example,\n\nWhile you may be tempted to say the answer is 12, since you add 1 + 5, getting 6 and multiplying it by 2, this is wrong. Instead, you multiply 5 and 2 first, then add 1, getting 11. This is a rule of both math and programming, so practice the concept until you can avoid printing the wrong number.\n\nIn order to combine two or more separate values together, you can use concatenation in the print function. We’ll still use the same format, but will add two periods or dots after each string. Do not place this inside of the string, otherwise Lua will interpret it as part of the string and produce an error.\n\nIf we paste this into the command bar, the output will show us a full statement as if it was a single string, meaning the concatenation was successful.\n\nNow that you’ve learned how to make a script, you’ll learn what variables are and how to make your own. Variables are considered vital because they save a lot of time and save you time and make your scripts simpler to review. They can be booleans, numbers, strings, or practically anything you want to assign a name to.\n\nIf you’re struggling to understand the concept of a variable, you can compare it to a nickname you might give someone who’s name may be too tedious to pronounce. Although it is not their birthname, calling them by their nickname will still get their attention as they’ve been given and called by it before.\n\nBelow, I’ve given an example of a variable. The term “variable” will be used interchangeably with the string “YellowNoobs!” whenever we use it in the script. If we put the variable inside of the print command, it will print the text assigned to it. Since the variable is identical to the string we assigned it, we do not need any quotes around the variable name. If you put quotes around a variable name, Lua will interpret it as a string, and print the actual name rather than the value.\n\nIf we copy and paste the code into the input, the output will print our statement.\n\nIt is necessary that you define your variables before using them in your code. Since Lua reads code from top to bottom, it will not know what the variable stands for when it executes the print function. If we paste the code into our command bar, we’ll get the output nil, which means nothing or no data.\n\nWhenever we define the variable, its scope covers all of the code below in the script. Variable scope is just another word for when the variable can be accessed in your script.\n\nThere are two types of variables which you’ll hear about, local and global. The variables we’ve made in this tutorial so far have been global variables, which means they can be accessed in all code below inside the script. Local variables will be covered later in this tutorial, but in simplest terms, they have a much more limited scope.\n\nVariables do not only have to be named “variable” when assigned to a given piece of code. In fact, your variables have to be different names in order for the program to recognize which variable you want it to use in the script.\n\nWhile you can almost freely name your variables, there are a few restrictions that exist inside Lua.\n\nYou can use:\n\nYou can not use:\n• Capital letters as the first letter of the variable (Not required, but common practice)\n• Numbers as the first letter of the variable\n\nComments are a simple green text that organize and give context to your lines of code, which can be a useful tool for yourself or others if you plan on sharing it.\n\nCreating comments is extremely easy, add - - and then your text after you are finished. It should appear something like this.\n\nIf you want your comment to cover more than one line, insert brackets, with your text inside.\n\nAny text attached to the comment will not be executed by the program, and will only be seen by the reader. This green text is helpful in case you want to find a specific piece of code in your script. Comments are also crucial if you plan on sharing your scripts and want the reader to understand what certain commands do. Besides context, you can use comments to credit yourself for your script, or write out directions that the user who uses your script might want to see.\n\nIf you want to change the settings (such as the transparency, or invisibility) of an object in the workspace, you have to write down the specifics before Lua knows what you want it to do.\n\nSo, if we want to change the transparency of the baseplate, we first need to define that the baseplate is inside game.Workspace, with game being the game we’re working on and workspace being the place where baseplate and the rest of our parts are stored. Then, we write the object we’ll be changing (baseplate) and the setting that we want to change (its transparency), and then assign a value to it. If we want it to be fully invisible, we’ll set the value to one, lowering this amount will make it so that it’s semi-transparent.\n\nIn the end, this should make the baseplate completely invisible if we run the code or play the game. Keep in mind that we can change the properties of object in Studio as long as you define it correctly in the code.\n\nWhen you’re writing a sequence of code that needs to be repeated, it may be a little tedious and also messy to write it out several times. Functions are a tool in Lua that we can use to put lines of different code in, which can be repeated and manipulated a lot easier by us. The functions in this segment are not to be confused with the built-in functions of Lua, such as print.\n\nTo define a function, we need to write function and then assign it a name. Then, add a pair of parenthesis after your function name without any spacing in-between, and press enter. I’ll be naming my function printStuff, but you can name yours differently.\n\nNow, we need to write our code for our function to actually execute it. You’ll notice that when you press enter after writing your function, you’ll automatically get end. This statement is here so that you can end, or close off your function, otherwise Lua would get an error.\n\nI want to print several strings, so I’ll insert the several sequences of code inside my function.\n\nWe now have our function, however, nothing will be happen since we haven’t written the command to execute it. We need to type the function name on the next line, and Lua will print our strings.\n\nNow, Lua will execute our code. If we paste all of the content into the command bar, we’ll see that our function is successful. It’s important to note that just like variables, functions need to defined before we actually execute them in our code, otherwise we’ll just get nil.\n\nWhen we covered local variables previously in our tutorial, I mentioned that the scope of it was much more limited. Whereas global variables can be accessed anywhere in our script after being defined, local variables are limited to a block.\n\nSo what is a code block? An example is basically the indented sequence of code that we see in our function. I’ll attach comments to the parts that are a part of the block of code for a visual demonstration.\n\nYou can also tell if something is a block by the small arrow that appears to the left. If you look closely, the arrow facing down next to function is indicating that the block is being shown, and when it is facing up, it means it is closed.\n\nIf we try to print the local variable outside the block, we’ll get nil since the variable can’t be accessed.\n\nA handy feature of functions is the ability to manipulate the variables with ease. You might’ve already noticed the pair of parenthesis when we define the function, and the two other parenthesis when we execute it. These are the spaces where we put our arguments and parameters.\n\nEvery time we execute a function, we might want to change certain parts of the code each time. Parameters are used to tell Lua which variables (and thus any information) inside the function you want to change. They are established when we first define our function, and are placed in-between the first pair of parenthesis on the same line. Make sure to not define the variable you’ll be changing inside of your function, otherwise the parameter will not work.\n\nNow that we’ve defined the parameter, we need to write an argument for the function to be properly executed. An argument is the value we assign the code when executing it. It comes inside our next pair of parenthesis, and can be changed every time we execute the function separately. We’ll print a string and a number, and the program should treat the argument as the variable in the function.\n\nNow if we put it in the output, the two values should be successfully printed.\n\nArguments and parameters aren’t just limited to a single pair, in fact there can be as many as you want. In order to add another pair, separate each parameter and argument by a comma with the next one you want in your function.\n\nNow if we paste it into our command bar, the output should print both statements in the order we gave them. It is important that you put the arguments and parameters in the same order or you will assign the wrong value to the variable. Also, you always have to define your parameters when you execute your function, otherwise Lua will not know what to assign to the variables.\n\nYou might’ve already noticed that below the option to create a script, there is something called a local script. This tutorial won’t go too in-depth about them, but offer a broad summary about its purpose.\n\nLocal scripts are scripts that only affect the user’s client rather than the server. A user’s client is basically what they see, rather than the whole server. So whereas you might be seeing something, your friend playing the same game as you might see something completely different. In comparison, scripts that affect the server are seen by everyone, and not just the individual’s client.\n\nThe concept is a bit difficult to describe by text, and I still can’t do it justice by talking about it in depth, so I urge you to look at this video by TheDevKing to get a better idea of what local scripts are capable of.\n\nYou might’ve heard this word in math class and it is related. Booleans in scripting are the conditions true or false.\n\nWhen comparing values you’ll get a Boolean as well, although you can simply write true or false too.\n\nRelational operators are the operators used to compare values with one another.\n• Equal to, not to be confused with equal which simply assigns something rather than comparing two values: ==\n• Not equal to, which is true if the values are not equal: ~=\n• Greater than or equal to: >=\n• Less than or equal to: <=\n\nNow, let’s take a look at some numbers and see if they represent a true or false boolean\n\nThe first one is false, since the value can only be greater than, and not equal to the other. The next one is true as the values are equal to one another. The last is clearly false, since 8 is not less than the number 2.\n\nIf statements make it so that specific commands only happen if the condition is met, it will execute the code.\n\nFor example, if 5 > 1 the Output will print “Congratulations” since 5 > 1 is true. If the script said 5 < 1 then the script will not print “Congratulations” in Output.\n\nThis is equivalent to saying true instead and will still print our string.\n\nSometimes, our code needs to be repeated in order to produce an outcome we’re looking for. Loops are statements that allow us to repeat code multiple times. They come in several different forms, which we’ll cover in this section of the tutorial.\n\nWhile loops repeat sequences of code while the statement is true. However, when the condition is false, it will not execute the code block. For example, while a variable is less than a certain value, it will continue to print out a string we decide to give it. This is just one of countless things you can do with a while loop, so feel free to get creative if you’re feeling ambitious.\n\nFor our while loop, we’ll assign a number to our variable, x. Afterwards, we go on the next line and write while. This helps Lua understand that it is a while loop, so that when the condition is true, it’ll execute the code block. The do you see after our boolean is simply telling Lua to execute the block of code that is part of the loop when the condition is true.\n\nIn this code, I defined my variable as 10 and made it so that the while loop would continue to run until it was no longer less than a 100. Each time it runs the code, I made it so that it would add 10 to the variable, meaning that once it ran several times, it would no longer execute the code since the condition is false.\n\nNotice the string being printed after the loop. This is not executed until the loop is finished, so not attaching it to the loop can be used to tell us when the loop is finished.\n\nFor loops are able to loop as many times as the user wants. First, we define a variable for the loop, and assign it to a starting and ending value. The loop will continue to repeat until the starting value reaches the end value. While the amount the starting value increases is by 1, you can change it by adding a comma after the end value. Below, is an example of a for loop.\n\nOur loop will now print 1, 6, 11, 16 all the way until 21 where it will stop since it can not go past 25.\n\nHere is the format for the for loop.\n\nA repeat loop repeats the statements assigned to it until a following condition is true.\n\nUnlike a while loop, it runs the statements first before checking if the condition is true.\n\nWriting break at the end of a loop will end the loop if a condition is true. In the example below, break is used to break out of an infinite loop that otherwise keeps running because it is always true.\n\nThis could also work if instead of true we wrote while x < 200 do. The result would be that the loop would end early, ending when x reaches 100 rather than 200.\n\nYou may also hear the term nested loop, which is used to describe a loop with another loop inside of it.\n\nTables are used for storing large sets of data that you might use while creating your script. With tables, you can access and manipulate the data easy, which can come in handy later on. In this section, you’ll be learning about just a single type of tables, arrays.\n\nArrays are simply a list of values compiled in a table. This can include strings, numbers, booleans, functions–pretty much anything that can be used outside the script. To make an array, start by assigning a name of your own to the table.\n\nAfter this first step, you need to assign the data to the table. Assign the table to the data by adding an “=” in between, and write a pair of curly brackets (the second bracket will be automatically typed for you).\n\nNext, you can place all of your values inside of the array. For this tutorial, we’ll place a few strings and numbers together, but you can add more variety to your table if you’re following along. Make sure to separate each value by adding commas in-between them.\n\nIf we want to print specific parts of our array, we can use the index to get what we want. Each value in our array has an index, or number assigned to it. The first value is 1, second value is 2, third value is 3, etc. To print a specific part of our array, we put our table name in the print function, then follow it up with the index of the value, in-between brackets ([]).\n\nIn the end, this should print out our first string, “Hello World” in the output.\n\nWhere Else Can I Learn About Scripting?\n\nThere are many other places to learn, but the sources listed above have helped me with learning or adapting to Lua.\n\nWhat is the Difference Between Input and Output?\n\nInput is the code given to the engine, while output is the received/finished command. For example, print(“YellowNoobs!”) is a input while YellowNoobs is the output.\n\nStopping exploiters isn’t a beginner issue, it is a little more advanced than what we’ve discussed so far. Throughout your scripting career, you’ll realize that the main reason for exploits is due to poor and weak scripts that hackers are able to bypass.\n\nOne feature that Roblox automatically now applies to all games is FilteringEnabled, which prevents hackers from messing with the server itself. To learn more about how it works, you can watch the following video by AlvinBlox,\n\nWhy does Studio Automatically Indent for me?\n\nTechnically, indenting is not necessary, but it is extremely helpful and keeps your code organized. For example, through indents, you can see where your code blocks are. Not only that, but it looks much cleaner. Writing without proper indentation would give both you and the programmers reviewing your code a headache to read.\n\nHow do I become better?\n\nPractice, practice makes perfect, no exceptions. Learning to program unique things by yourself is always something you should strive to achieve as a developer.\n\nThat’s it, the basic tutorial is now finally finished! Hopefully, now you’ll have a far easier time being able to understand new concepts and can use this as a reference whenever you feel stuck.\n\nIf you have any other questions or feedback, please reply in the comments below, good luck!"
    },
    {
        "link": "https://create.roblox.com/docs",
        "document": "Studio is the tool that lets you create experiences on Roblox"
    },
    {
        "link": "https://devforum.roblox.com/t/best-practices-handbook/2593598",
        "document": "Hey, my name is Jack. I’ve collaborated with several prominent Roblox groups and have accumulated a plethora of knowledge to share with you all. In this handbook, I’ll be covering the best practices for general programming and specific Lua related challenges.\n\nI wish I had this resource when I was learning.\n\nClick To See More Do you know what this variable stands for? Well I certainty wouldn’t know what it meant.\n\n Let’s try this again: This is much better. Using ineffective variables names will not only hurt your co-workers but will eventually confuse you.\n\nClick To See More Guard clauses are conditionals that exit a function/loop with a return/break/continue statement. Here’s an example of nested conditionals that can be replaced with guard clauses. function checkUsernameStatus(userNameValid : boolean, premiumSubscription : boolean) if premiumSubscription then if userNameValid then return \"Username is valid\" end end end function checkUsernameStatus(userNameValid : boolean, premiumSubscription : boolean) if not userNameValid or not premiumSubscription then return end return \"Username is valid\" end Notice how the code no longer has nested if statements. In large systems, guard clauses will come in handy when dealing with a multitude of conditionals.\n\nClick To See More Module Scripts are arguably the most useful script object in Roblox. Module scripts allow you to create clean and reusable code. Repetitive code is a thing of the past once you have harnessed the power of module scripts. Some popular frameworks employ the use of module scripts instead of scripts and localscripts (e.g. Knit Framework). Why rewrite code when you can just reference a single function or class? This is a basic example of module scripts. However when combined with OOP, module scripts go to the next level. I’ll leave a tutorial to OOP below as well.\n\nClick To See More Type Checking is extremely useful, even more so when working with bigger projects.\n\n In fact, if you have ever used a roblox service, you have seen typechecking. For example, let’s take a look at tween service:\n\n \n\n In this picture I am creating a new tween, and you can see it showing a typechecking UI when I’m filling out the parameters. The orange underlines resemble variables while the red underlines resemble the type.\n\n This is useful information because you now know what the method’s parameters are looking for.\n\n You can typecheck variables, parameters, and function returns. Now let’s make our own method using type checking: Now, string1 and string2 expect a type of string. And the function expects to return a string.\n\nClick To See More Duplicating your code in multiple places will ultimately lead to confusing code and impossible changes. function findClosestPlayer(plr) local distance = nil local nearPlayer = nil for i, v in pairs(players:GetPlayers()) do local distanceBetween = v:DistanceFromCharacter(plr.Character.HumanoidRootPart.Position) if not v.Character or (distance and distanceBetween >= distance) or v.Name == plr.Name then continue end distance = distanceBetween nearPlayer = v end end Now imagine if this was not a function and you duplicated this code 10 times throughout your script.\n\n First of all, this will cause readability to decrease. Let’s say I need to change part of this code. Looks like we have to change all 10 occurrences of this code. However, If this code was in a function, you could change the code in the function and you would be all good.\n\nClick To See More Documenting your code is important when working on projects with a team or just your self. Imagine you write a complex system. Three months later, you need to make some changes to your code. However, you don’t know how everything works in your system. If your code was documented, it would have saved a couple hours of confusion. Also, did you know that the word “TODO” is a keyword? In studio, the word “TODO” will be bolded.\n\nClick To See More A lot of newer-intermediate programmers will often make the mistake of making memory leaks by having a misinterpretation of connections and memory. Let’s look at the following code: Let’s say you only need this code to run once. After the first time this code runs, it will be useless to you. And, this connection will still be in memory. It’s only until the part get’s deleted will the connection get garbage collected. Let’s go ahead and fix this problem: Now, this touched event is only in memory until the first time it’s touched. For an alternative solution, you can use Event:Once(). This will make sure the event only fires once and is garbage collected:\n\nClick To See More Instance.new is already performance heavy, so utilize this best practice.\n\n Do not use the second argument of instance.new to set the parent of an object. The following code is the worst way you can use Instance.new. It uses the second argument of Instance.new. In this case, it takes Roblox ten performance expensive steps to execute the code. This code queues useless replication changes which is heavy on CPU and bandwidth usage. -- What not to do local newPart = Instance.new(\"Part\", workspace) newPart.Position = Vector3.new(1,1,1) newPart.Size = Vector3.new(1,1,1) Instead, you should always set the parent property last: -- What to do local newPart = Instance.new(\"Part\") newPart.Position = Vector3.new(1,1,1) newPart.Size = Vector3.new(1,1,1) newPart.Parent = workspace This code only takes Roblox five steps. This is the most optimal solution. This code’s property updates are extremely fast. When the object is inserted into the game, it’s in it’s final state. If you don’t set the parent argument last, you will not get the desired performance. In fact, most Roblox core scripts and tools use this bad practice… Set up Instance.new in the following order:\n\n A. Instance.new\n\n B. Assign properties\n\n C. Assign Parent\n\n D. Connect signals For more information:\n\n PSA: Don't use Instance.new() with parent argument\n\nGetService instead of referring to services"
    },
    {
        "link": "https://devforum.roblox.com/t/efficient-object-oriented-programming-tutorial/1061153",
        "document": "This tutorial will not be explaining what OOP (aka Object Oriented Programming) is.\n\nI’ll be showing how to create an efficient and organized OOP System.\n• Note: I start to create the efficient OOP system at the “what do we do now?” section below\n\nAll module scripts in this tutorial will be parented to ServerStorage\n\nThe scripts that we will test module scripts with will be parented to ServerScriptService\n\n \n\n\n\nThings you should know before continuing this tutorial\n• vs function calls | example: vs\n\nThere are lots of tutorials on OOP in Roblox Lua. However, there seems to be key issues consisting of some combination of the following:\n• Lack of using DRY method (Do not repeat yourself)\n\nI’ve been developing Lua OOP systems for a couple years now. They’re not easy to conceptualize. I’ve scrapped countless ideas either having issues with inheritance, memory leaks, or just not liking the structure or looks of the system.\n\nThe best post I could find about OOP was a post first written in… 2014. (edited in 2020 Jul.)\n\nI would advise you to look it over first since it’s much better at explaining the concepts of OOP.\n\nHere’s an example of a very simple Person class represented inside a module script:\n\nThis is what I normally see when people try to implement OOP. in this example, we have a Person class, which creates an object through a function called new.\n• function which lets the person shout in the output bar called shout.\n\nFirst thing I want to make clear is that this OOP system does work. It’s great for beginners since it’s simple and easy to read.\n\nHowever, it sacrifices one thing: Memory usage\n\nWhy is that?\n\nThe issue at hand is that we have created a function inside the object itself.\n\nLet’s say we create two objects. That means both objects have its own shout function.\n\nTwo functions that do exactly the same thing\n\nThis uses up memory that could otherwise be avoided.\n\nHere’s what we want:\n• To be able to call the function from the object\n• Not have the function located directly inside the object\n• Only create one function that is used by all objects\n• Still is easy to read and execute (in a perfect world)\n\nHow do we solve this?\n\nMetatables are awesome, but they can get pretty confusing quickly. I hope you already have a basic understanding with the concept of metatables and metamethods.\n\nInstead of adding the function into the Person object, we’ll add them to the Person class, which is the same place the function is located. In this example, that would be .\n\nNotice how the shout function is outside of the function.\n\nAlso note how the shout function includes self as a parameter. The self lets us target a specific object that calls the function. However, there’s a better way to write it.\n\nThis does the exact same thing as the shout function in the above example:\n\nWe replace the with a in the function definition. This passes self as the first parameter without needing to write it. And when we call the function from our object, well use as well\n\nYou might notice with the above example we have no way to call the function directly from a Person object, since the function is located inside the Person class. You would be correct.\n\nNow it’s time to play with metatables.\n\nLike I said before, I’m not here to explain how metatables work. So i’m just going to provide a working scenario here with an updated Person module script\n\nHere are the changes:\n• returns after setting the Person class as its metatable.\n\nTo sum it up, whenever you try to access a field that the Person object does not have, it will look inside the Person class to see if it has it.\n\nBut is it good enough?\n\nNow we can access the class functions from our objects! And when we create multiple objects, it does not create more functions, reducing the amount of memory we use!\n\nThis is very similar to the OOP tutorial I listed above, with a little of my personal coding style mixed in. This system is a great option for developers with larger games, since the metatables save us memory.\n\nWe can add inheritance to this system, however, the features of this system are lacking. Here’s problems with this system:\n• If you want to add metamethods to classes, you will have to create one in every class.\n• The new function (the new function should not be located directly inside the class)\n• The inability to use functions of the class inside the new function through\n• Just not cool enough\n\nWhat do we do now?\n\nHere’s where the real tutorial starts. If you got through here, good job.\n\nIf you jumped here without reading the above, I hope you understand basic OOP systems in Lua.\n\n \n\n\n\nWe are now going to scrap everything we just made\n\nLets add a function called class to the module script with the following logic inside:\n\nNotice how the function receives a parameter called newClass. This is where we receive default values for a class. I’ll explain it more in detail later on. The function also sets Rcade as the metatable. Finally it returns\n\nNow we need to add a metamethod to Rcade. First, we will add a metamethod to Rcade. This will allow us to call a table like it’s a function. In this case, the table would be the class. We are using to replace the function\n\nHere is Rcade with a metamethod added:\n\nInstead of creating an object by calling\n\nWe will now do it by calling\n\nYou might be confused about the code inside the metamethod.\n\nHere’s a step by step on what it does:\n• It receives a variable amount of parameters indicated by the\n• It creates a table which is our object\n• Sets the object’s metatable to be its class.\n• Looks to see if the object’s class has a function called and if it does then it runs it, passing the object and the variable amount of parameters.\n\nBut where did this function come from? It’s not a metamethod recognized by Lua.\n\n It’s a function you will define inside each class yourself. The function is where we set an object’s properties.\n\nLets create an example class called “Person” again that uses Rcade.\n\nNotice how when I called the class function inside Rcade, I did\n\ninstead of - curly brackets vs parenthesis\n\nIn other words, It passes a table as the first parameter. Just less code to write and easier to read, though either way is fine.\n\nNow let’s actually create an object as an example that it works.\n\nLet’s create a new Script. Lets place the script inside ServerScriptService\n\n with the following code inside:\n\nNow we need to add inheritance. With inheritance, we can have a class inherit properties and functions of another class.\n\nTo help explain what it means, here’s an example:\n• Let’s say we have a class called “Person”\n• Let’s say we have another class called “Student” that inherits from Person.\n\nA Student is a Person, but a Person is not always a Student\n\nA Student should have every property and function that a Person has.\n\nHowever, a Student may also have properties or functions that a Person doesn’t have.\n\nSo how do we add Inheritance?\n\nThe first step to do this is by adding a property to classes that inherit from another class. (__super refers to the class it inherits from)\n\nLets create a new class called Student, mimicking the example from before.\n\nHere’s our student class that will inherit from our Person class\n\nHere’s what’s different from the Person class:\n• Added __super property to the class which points to what it inherits from\n• Inside __init we call the superclass’ __init, passing the object and the Person parameters.\n• Added a new parameter to the function called “id” and set it inside the object.\n• No functions were defined under the Student class\n\nWith a student object, we can index:\n• , which is inherited from the Person class\n• which is defined inside the Student class\n\nHowever, we’re not done yet. As of right now, if we have a student object and try to call , the script will error out since there is no shout function inside the Student object.\n\nWe want our Student class to look inside our Person class to find the shout function.\n\nSince Rcade is the metatable to all classes we create, we need to add an metamethod to Rcade.\n\nHere is the metamethod\n\nWhen we call __super on classes, This checks to see if our class has a __super property, and if it does it will return the superclass. If not it will return nil.\n\nSo the current full Rcade script will look like this:\n\nNow it wont error out when we try\n\nThe cool thing with this system is that we can define metamethods for objects directly inside the class, while looking very clean.\n\nIf we try to print out a student object, it gives us a string that points to the memory location holding the table.\n• With the new output bar in Roblox Studio, you can now see what’s inside a table when you print it. However, I still don’t like it.\n\nWhat if we want to have a custom output when you print an object?\n\nAll we have to do is add a function inside the object’s class.\n\nHere’s an example of the Person class that has a custom print output for Person objects.\n\nNow when we print a Person object, it will print it’s name and age.\n\nHere’s an example of printing a Person object and its output using a script inside ServerScriptService:\n\nIf we try to print out a Student, which inherits from our Person class, it won’t use our metamethod. It will give us that useless memory location string again.\n\nWe need a way to have metamethods also be inherited.\n\nFirst I want to make clear that this section is purely optional. The way I’m going to show you will increase memory usage. I have yet to figure out a way to cleanly do this. However, it works and is not as bad as the first examples of OOP I showed you.\n\nTo do this, we will need to edit Rcade once more.\n\nWe will change Rcade’s function to this:\n\nWhat we added in steps:\n• added a check to see if the class in question had a __super property.\n• If it does have __super, loop through every property the __super class has\n• If the property has “__” as the first two characters (our metamethods) and is not and , then add it to the class we are creating.\n\nNow our classes inherit metamethods as well!\n\nNow for the final aspect of this OOP system. Listeners. What if we want a certain function of a class to fire for a specific event? Like when a player joins, or a character dies.\n\nFirst let’s add a blank module script to Rcade. I’m going to name it “Utility”\n\nUtility will be a child of Rcade in the Explorer tab, as shown here:\n\nInside utility we will add three different functions, as well as retrieve the service “RunService” as shown here:\n\nI won’t even begin to explain what’s happening here. All you need to know is how to use it at this point.\n\nSo let’s use it\n\nFirst we need to go inside Rcade AGAIN and add a property. So at the top of Rcade, we’ll insert it as such:\n\nWhich results in the complete and final version of Rcade:\n\nIt’s going to include functions called , , and .\n\nHere’s the basic layout of our Server class:\n\nIn this example, we will make it so:\n• when a player joins, the function will fire, with the player being the parameter.\n• When a player leaves, the function will fire with the player being the parameter\n• When the server requests to shut down, the function will fire\n\nTo do this, we will add code to the function as such:\n• The first parameter is self (the object)\n• The second parameter is the event you want to listen to.\n• The third parameter is the name of the method you want to fire represented as a string.\n\nIt’s the same for remoteListener\n\nhowever with bindToClose it only needs self and the method name. (2 parameters)\n\nNow our Server class should do exactly what we planned it to do.\n\nCreate a script inside ServerScriptService that contains the following code:\n\nIt should print something when you join, leave and when the server closes now. Here’s what my output prints out when I join and leave in Roblox Studio:\n\nSometimes we might not want to input every parameter a class has. Let’s take a look at our Person class once more.\n\nLet’s say we create an object without giving the person an age. The issue here is that if we were to try to have the person shout, it would error since you can’t concatenate nil with a string.\n\nHow can we fix this? The normal way would look something like this\n\nThe issue is that if we nil the value inside the object later, then the value would be nil when we index it.\n\nI recommend a different method, one that works really well with the system we have set up:\n\nWhen we create a class through Rcade, inside the table we pass to Rcade, you can add default values for your objects. So for our Person class example, the default values could instead be created via the code:\n\nThe default values are located at the top of the script where we create the Person class\n\nNow if we don’t give an age parameter when creating an object, indexing it will return -1 no matter what unless a name property is added to the object. Even if we do it will still return -1 when indexed.\n\n \n\n\n\nIf you add a roblox object as a property of an object, you need to nil the property inside the object in order for the object to be cleaned by the garbage collector.\n\nAs an example, if we created an object every time a player joins the game, and the object contains the player as a property, we must nil out the value when the player leaves to stop memory leaks from occurring. I don’t know why. Just nil the property when you’re done with them. I usually add a destroy function to objects to easily clean them up.\n\nAnd we’re done! This was a very long tutorial, And I know I’m not a good teacher. For those of you who got to the end, here’s a reward (even scrolling here took an effort):\n\nTake this and edit it however you want! Just make sure you understand what is happening. Leads to a better user friendly experience.\n\nSoon I’ll be creating a plugin that makes it very fast and simple to create a basic template for a class.\n\n I’ll also likely create a tutorial on how to create an obby with this system."
    },
    {
        "link": "https://devforum.roblox.com/t/a-guide-on-creating-classes-in-lua/2128194",
        "document": "Before we start, I would like to state that Lua is not meant to be an OOP language. Instead we implement custom classes with metatables.\n\nHey! You probably came here because you saw some developers talking about ‘OOP’ or ‘Classes’ or even ‘Objects’. O.O.P. stands for Object Oriented Programming. A lot of programming languages use OOP as it is extremely useful in a lot of cases.\n\nWhat are they, and what do they do?\n\nClasses can be useful when you need data that does not persist throughout the running environment. Usually, you will have your script that makes local variables like this:\n\nBut sometimes, this behavior of persisting variables is not always desired. This is where functions come in. Functions can take parameters (arguments) which are basically like variables but they get passed into the function for use like this:\n\nNow this works, but it can start to be annoying to supply the same parameter every time for the same thing, especially if your module is open sourced. This is where classes/objects come in. Now, you are probably familiar with Roblox’s objects, for example, or . Each one of these objects have properties and extra functions connected to them. In Luau, you can create your own custom objects with code (quite easily actually). Now, lets get to the main point of this tutorial: learn how to make classes.\n\nHow do I make them?\n\nMaking classes is quite simple actually, and the possibilities are almost endless. I will be covering more advanced topics at a different time, but here are the basics.\n\nFirst to create a class, you need to insert a via a plugin or the object explorer.\n\nIn your module, you first need to create a new function.\n\nNow, this is where come in. They are what make classes actually work.\n\nNow, we need to add our :\n\nBasically, have these things called , which are basically functions that run when said thing has happened to the table. In classes, we use the metamethod , which fires whenever you try to index anything from the table. Here, we have it returning the when we attempt to index it.\n\nNow you can add properties to your object, just like how Roblox has a property on every object. Here is how can add them:\n\nNow, if we call this function in our module, we can do this:\n\nPretty cool right? Well, the next part is even cooler!\n\nSo now we how to add properties to our classes, but how do we attach functions like Roblox does with their objects? Here’s how: So in Lua, there’s this variable called . It is basically they keyword that we use to access properties in our classes from functions that are attached to them. All we need to do is add another function!\n\nNow, if we call that function we should be able to print the property - but it doesn’t, and instead it errors. Why? This is because you must supply self as a parameter or else the function won’t know what object to look for. You can add it by doing this:\n\nNow try doing this in your script:\n\nBut, this can start to be annoying when you have a lot of methods. How can we fix this? Well, you simply call the function with a colon in your module like this:\n\nNow, you no longer need to supply self/the object because when using a colon, self is automatically supplied as an invisible parameter, and you no longer need to worry about supplying it yourself.\n\nSo, if we do this in our script:\n\nWe should still get the same result as if we were doing the other method. Of course, you can add as many properties and methods as you want.\n\nBut sometimes, maybe you want to have different properties for each object. We can still use parameters as before with regular functions. Here is an example where we use parameters, and other methods to create a ‘People’ class with each object being a ‘Person’.\n\nHere is one last piece of advice: always make sure to type check parameters to ensure safety. Type checking is basically doing this: .\n\n What happens is if is not a number, the script will yell at you telling you it should be a number.\n\nHere’s an example of it in a function:\n\nYou can do way more things with classes than I have mentioned here. Go checkout other tutorials about OOP and maybe you’ll learn.\n\nAnyways, I hope you have learned something, and thanks for taking the time out of your day for reading my post!\n\nComment on what I can improve or what you liked about the tutorial."
    },
    {
        "link": "https://devforum.roblox.com/t/kurdiez-scripting-4-object-oriented-programming-in-lua/135192",
        "document": "This tutorial is all about coding up some OOP in Lua. Let’s get right into it.\n\nThere are many ways to do OOP in Lua. I won’t claim one specific way is the right way to do it. One way I have fallen in love with is writing classes using Luke’s CreateClass library. I met Luke while streaming on twitch and he saw me how I was inefficiently writing classes because I don’t know Lua all that well. Soon we began collaborating with him writing what is now become the CreateClass library and me beta testing it in my game everywhere. You do not have to follow this approach as I said, there are many other ways to do OOP in Lua.\n\nLet’s write some simple classes to simulate creating of NPCs and dealing damage, putting buffs/debuffs and healing.\n\n1. Write down the requirements first\n\n I always write down what needs to be coded before starting to code them. These don’t need to be in particular order. Just need to cover everything that you want to see happen.\n• Be able to print their individual current states (name, health, armor, etc)\n• Be able to calculate raw damage output\n• Be able to take damage after applying armor value\n• Be able to buff base armor values\n• Be able to debuff base armor values\n• Be able to heal health\n• Be able to do everything above in class-specific ways where applicable (warrior and rogue)\n\n2. Class design\n\n We have two character types in this simulation. Warrior and Rogue. Warrior will have higher armor value and Rogue will be able to do random critical damage (x2 regular damage) with 30% proc chance. Aside from these differences, there are also common features they share between the character types such as being able to buff/debuff armor and healing health. We want to have these common logics shared in one class while having the differences in two separate classes. By doing step 1, we were able to sort these out which most developers often skip.\n\nCharacter class will be our parent class which will have all the default values and behaviors. This is where all the commonly shared features all across different character types will be coded. Warrior and Rogue classes are the children of the Character class and they implement their specific features. Warrior class will calculate taking damage differently as it will have additional bonus armor due to warriors being tankier. Rogue class will deal damage differently than others as they are able to do critical damage at a 30% chance. Let’s not worry about the children classes for now and start coding the parent Character class.\n\n3. Coding the Character class and testing it\n\n We begin with saving CreateClass library as a separate module script and put it into ReplicatedStorage. You can just create a new module script and copy and paste the content of it.\n\nUsing this helper library, we can put in a completely empty Character class to start. To do this, create a module script in ServerScriptService called “Character” and type in the following\n\nEach class we write is going to be a single module script on its own. Let’s take a look at this 3 lines of code that defines an empty class.\n• First line imports the CreateClass library by require(). This is a standard way to require a module script in Roblox.\n• Second line defines an empty class using the CreateClass and make Character variable point to it.\n• Third line returns the class pointed by the Character variable.\n\nRemember what was discussed about what it means to be a class in the previous tutorial? Class is nothing but a collection of variables and functions that are related to each other. Let’s start by adding variables that are required in the Character class in order to do what we want.\n\nInside the CreateClass Lua table we introduce a key “__init” that points to a function with 4 parameters. Whatever the function that is pointed by the __init key becomes the “constructor” function of this class. The constructor function is used to literally construct an object out of this class at the time of object instantiation. (See previous tutorial for what all this means). When an object is instantiated out of this class we need to give it some initial values it starts off at its birth. For our simulation purposes, we need three variables that need to be kept track for every NPC we are going to simulate. These are health, baseArmor and damage numbers. I like to test my code bit by bit as I am coding so soon we will test this basic class.\n\nWhen we instantitate an object from this class in our test code, we will be calling the constructor function and pass health, baseArmor and damage numbers. These values are then assigned to their respective self.health, self.baseArmor and self.damage variables. So what is this self variable? Because we are doing self followed by the period “.” we know that this self variable points to some kind of a Lua table and accessing a key in it. Self variable here points to literally the object itself that is being created. What is the English word “self” mean to you? It means its own self right? This means when the object is being instantiated through this constructor it is calling onto itself and creating its own variables health, baseArmor, and damage and setting the initial values with whatever was passed into the constructor as parameters.\n\nLet’s create a Script that will be used as our test script. Create a Script in the ServerScriptService and name it “Test”.\n\nWhen you now run the game, you will see in the output window 3 numbers being printed. How did this happen? Everything else in the Test script is easy to understand except the second line. We call the New() function from the Character class we required above. Although we did not define this New() function anywhere this is given to us by the CreateClass library. So when we call the New() function of this class it calls the constructor function defined to the key __init in the Character class file earlier. Any time you want to instantiate a new object of any class created by the CreateClass library, you simply need to call its New() function. We do not need to pass the first “self” parameter. This is automatically done by the CreateClass again. We only need to worry about the subsequent parameters that are defined in the constructor. In this test example, we are passing the number 100 for health, 10 for armor and 15 for damage to be set as initial values for the object we are instantiating. Once the object is instantiated it is created in the memory of our computer and its address it being pointed to by the “testCharacter” local variable. Since we have a variable pointing to it we can take a look at its object variables as shown by the print statements. Since we are going to be doing a lot of testing using these classes let’s put in default print out function right inside the class.\n\nI have added one more parameter to the constructor “name”. I also added the PrintCurrentState() function and attached it to the Character class. Remember that any variables and functions inside a class are related to each other? Here we see a good example of this inside the PrintCurrentState() function. The goal of this function is to print current object’s health, base armor and damage values, therefore the keyword “self” must be used to refer to myself’s values from the calling object’s point of view. Let’s modify the Test script and see how this new function is used.\n\nWe have to pass the name of this character as well now since we’ve added the new parameter to the constructor. Once you have testCharacter variable point to newly instantiated object, all you have to do is calling the function PrintCurrentState() using the “:” in front of it. You should see a print out in the output window that looks like this.\n\nAt this point it is absolutely critical why the “self” keyword had to be used inside the PrintCurrentState() function. If you don’t understand clearly what this “self” keyword is all about, there is almost no point in moving any further in this tutorial. Take a moment to experiment with the code with and without the self keyword. Ask other programmers on forums or Discord groups for help. Once you’ve understood what self is all about, you are in a good shape to continue to the next part of this tutorial.\n\nIf we scroll back up to the “Class Design” diagram, we are missing so many things in the Character class. Let’s fill in all the gaps.\n\nIf you have understood how the “self” keyword works, you would have no problem understanding what is happening in each on of these added functions. There are bugs in this code but ignore them as I kept implementations of these functions here as simple as possible on purpose. Now let’s go test these added functions one by one by modifying the Test script.\n\nI hope all of these test cases are self explanatory. We have done a lot so let me just summarize what has been done so far. We created a Character class then we instantiated a testCharacter in our Test script using the Character class and performed bunch of actions with it. The real beauty of Object Oriented Programming lies when you start creating more than one objects from the same class. Let’s modify the Test script to the following:\n\nWe have instantiated two distinct characters from one Character class. And we have two distinct variables “testCharacter1” and “testCharacter2” pointing to each created objects. We do a series of different operations on these two characters and when we print their state to see the results, they are affected distinctively. This is how you manage individual NPCs in a game. If a player wants to debuff the armor of one particular enemy character, find the variable that points to the right character object and call its DebuffArmor. Only that NPC will be affected and its aftereffects maintained in the object variable. I want to discuss one last key feature in OOP before I wrap up this tutorial. And that is class inheritance.\n\n4. Warrior child class\n\n Before discussing the inheritance of classes in code, let’s think about inheritance in general in biology. For being a child of our biological parents, we inherit certain traits from our parents. Some things are passed onto the child from the parents. In OOP, something similar can be done virtually. If we create a child class called “Warrior” and mark it as the child of Character class we wrote above, the Warrior class will inherit all the variables and functions that are defined in the Character class for free. Furthermore, you can define additional variables and functions that are specific to the Warrior class and add them inside it. If an object was to be instantiated from the Warrior class, this object will be born with all of the variables defined in Character and Warrior classes as well as the functions likewise. Let’s create the empty Warrior class and mark it as the child of Character class using the CreateClass library.\n\nFor the child Warrior class to work, you need to import two things: CreateClass library and Character parent class. This is done by the two require() lines at the top. In order to “mark” Character class as the parent of the Warrior class, you must set it as the “__super” in the CreateClass library. Once you’ve marked it you also need to take care of the constructor linking. When you instantiate an object of the Warrior class, this object is classified as both a Character (because Warrior class inherits the Character class) and also a Warrior. This means you must satisfy the requirements of the Character class’ constructor as well. We do this as the first line inside the Warrior class’ constructor. Because the Warrior class is very simple for now it simply passes all the parameters right up to its parent class’ constructor, which is the Character class. Let’s see if the object has been created properly by modifying the Test script and testing it.\n\nNotice how we are able to call the PrintCurrentState() without an error from the warrior object. This is because this function is inherited from the Character class. Going way back up to the Class Design diagram again, we see that the Warrior class needs to have its own implementation of Take Damage. Taking less damage than other character types is what makes Warriors different in this simulation. We are going to achieve this by letting the warrior have additional armor and “overriding” the TakeDamage function it inherits from the parent Character class.\n\nWarrior class is modified to take in one additional parameter into its constructor: bonusArmor. Notice how the bonusArmor does not belong to the parent Character class so we do not have to pass it into parent’s constructor. Instead, we declare a new self variable inside the Warrior class and assign it there. Warrior class also implements its own TakeDamage() function and by doing so, you will completely override the parent Character class’ function all together. I don’t think I have to explain the math inside the TakeDamage() function as it is simple enough. Let’s test the new Warrior class in the Test script.\n\nOnce the script is run, you will find that the health was only deducted by 5 because this warrior object has 10 base armor and 5 bonus armor for being an object of the Warrior class. I will leave the Rogue class implementation as a fun exercise for everyone to do.\n\nConclusion\n\n You write class once and instantiate as many objects as the host computer memory allows. Once objects are instantiated their states such as health, armor, damage, etc are all managed individually. Anytime a class function refers to a variable using the “self” keyword, it is referring to the invoked object itself. You can also design a class hierarchy and inherit all the parent class’ variables and functions as the child. I have only covered the most basics of the OOP. Please take the time to research the internet and learn about many more features provided by the OOP style of coding.\n\nContact\n\n You can find out more about my discord and any other contact information about me on my twitch channel."
    },
    {
        "link": "https://reddit.com/r/robloxgamedev/comments/u7puki/best_practices_around_oop_in_roblox",
        "document": "I am new to Lua/Roblox, but not to programming in OOP languages. I am a bit confused about how to best think OOP in Roblox.\n\nSpecifically, I have an object in the world which I want to contain a variable. Thee object also has functions that use this variable. I want other objects/events in the game be able to call functions/change the variable.\n\nIn other languages you would get the object, and then call functions in that object that are accessible to the outside. Like for example having a function that is called addOne() which then adds one to the variable (or more complicated scripts which does things with that object and its variables)\n\nHowever, as far as I understand you cannot really call functions in other object scripts? I know you could put functions in _G but global functions are not really OOP, and I think it is kind of messy.\n\nHow are you supposed to think about this?"
    }
]