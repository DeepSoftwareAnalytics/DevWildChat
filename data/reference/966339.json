[
    {
        "link": "https://w3schools.com/python/ref_list_insert.asp",
        "document": "W3Schools offers a wide range of services and products for beginners and professionals, helping millions of people everyday to learn and master new skills."
    },
    {
        "link": "https://geeksforgeeks.org/python-list-insert",
        "document": "Python List insert() method inserts an item at a specific index in a list.\n\nDefinition and Use of List insert() Method\n\nList insert() method in Python is very useful to insert an element in a list. What makes it different from append() is that the list insert() function can add the value at any position in a list, whereas the append function is limited to adding values at the end.\n\nIt is used in editing lists with huge amount of data, as inserting any missed value in that list is made very easy with this Python function.\n• index: the index at which the element has to be inserted.\n• element: the element to be inserted in the list.\n\nReturn : The method returns . It only updates the current list.\n\nHow to Insert into Python List at Index?\n\nUsing Python list insert() function you can easily insert an item to a given index in Python list.\n\nHere is another examples to depict Python list insert at index 0:\n\nLet’s see some of the scenarios with the python list insert() function to clearly understand the workings of the insert() function.\n\n1. Inserting an Element to a specific index into the List\n\nHere, we are inserting 10 at the 5th position (4th index) in a Python list.\n\nHere, we are inserting 1 at the 10th position in a Python list, we will get an error if we try to insert anything in a string because the string doesn’t have attribute insert().\n\n3. Insertion in a List Before any Element\n\nIn the parse of Python List Insert here, we are inserting 13 at the 3rd position before 3 in a Python list.\n\nHere we are inserting a tuple in a list using the insert() function in Python.\n\n5. Insert an Element to the Beginning of a List\n\nIn this example, we are inserting the “orange” string at the 0 index of the fruits list.\n\n6. Inserting an Element at the end of the List\n\nIn this example, we are inserting the “cherry” at the end of the list.\n\nHere we are inserting a dictionary in a list using the insert() function in Python.\n\nHere we are inserting a list in a list using the insert() function in Python.\n\n9. Insert elements of a set to a list in Python\n\nHere we are inserting a set in a list using the insert() function in Python.\n\nGo to the below articles to get more details information about Python Insert() Function\n• None Python program to insert an element into sorted list\n\nIn the above article, we have discussed the Python list insert() method and its parameters with suitable examples. Python insert() function is very useful when dealing with big data.\n\nWe hope this article taught you about how to use insert() in Python.\n\n\n\n What is the\n\nWhat is the Difference Between\n\nWhat is the Use of\n\nWhat is the Difference Between"
    },
    {
        "link": "https://programiz.com/python-programming/methods/list/insert",
        "document": "The method inserts an element to the list at the specified index.\n\nThe syntax of the method is\n\nHere, is inserted to the list at the index. All the elements after are shifted to the right.\n• index - the index where the element needs to be inserted\n• element - this is the element to be inserted in the list\n\nThe method doesn't return anything; returns . It only updates the current list.\n\nExample 1: Inserting an Element to the List\n\nExample 2: Inserting a Tuple (as an Element) to the List"
    },
    {
        "link": "https://docs.python.org/3/tutorial/datastructures.html",
        "document": "This chapter describes some things you’ve learned about already in more detail, and adds some new things as well.\n\nThe list data type has some more methods. Here are all of the methods of list objects: Add an item to the end of the list. Similar to . Extend the list by appending all the items from the iterable. Similar to . Insert an item at a given position. The first argument is the index of the element before which to insert, so inserts at the front of the list, and is equivalent to . Remove the first item from the list whose value is equal to x. It raises a if there is no such item. Remove the item at the given position in the list, and return it. If no index is specified, removes and returns the last item in the list. It raises an if the list is empty or the index is outside the list range. Remove all items from the list. Similar to . Return zero-based index in the list of the first item whose value is equal to x. Raises a if there is no such item. The optional arguments start and end are interpreted as in the slice notation and are used to limit the search to a particular subsequence of the list. The returned index is computed relative to the beginning of the full sequence rather than the start argument. Return the number of times x appears in the list. Sort the items of the list in place (the arguments can be used for sort customization, see for their explanation). Reverse the elements of the list in place. Return a shallow copy of the list. Similar to . An example that uses most of the list methods: You might have noticed that methods like , or that only modify the list have no return value printed – they return the default . This is a design principle for all mutable data structures in Python. Another thing you might notice is that not all data can be sorted or compared. For instance, doesn’t sort because integers can’t be compared to strings and can’t be compared to other types. Also, there are some types that don’t have a defined ordering relation. For example, isn’t a valid comparison. The list methods make it very easy to use a list as a stack, where the last element added is the first element retrieved (“last-in, first-out”). To add an item to the top of the stack, use . To retrieve an item from the top of the stack, use without an explicit index. For example: It is also possible to use a list as a queue, where the first element added is the first element retrieved (“first-in, first-out”); however, lists are not efficient for this purpose. While appends and pops from the end of list are fast, doing inserts or pops from the beginning of a list is slow (because all of the other elements have to be shifted by one). To implement a queue, use which was designed to have fast appends and pops from both ends. For example: # The first to arrive now leaves # The second to arrive now leaves List comprehensions provide a concise way to create lists. Common applications are to make new lists where each element is the result of some operations applied to each member of another sequence or iterable, or to create a subsequence of those elements that satisfy a certain condition. For example, assume we want to create a list of squares, like: Note that this creates (or overwrites) a variable named that still exists after the loop completes. We can calculate the list of squares without any side effects using: which is more concise and readable. A list comprehension consists of brackets containing an expression followed by a clause, then zero or more or clauses. The result will be a new list resulting from evaluating the expression in the context of the and clauses which follow it. For example, this listcomp combines the elements of two lists if they are not equal: Note how the order of the and statements is the same in both these snippets. If the expression is a tuple (e.g. the in the previous example), it must be parenthesized. # create a new list with the values doubled # apply a function to all the elements # the tuple must be parenthesized, otherwise an error is raised File , line : did you forget parentheses around the comprehension target? # flatten a list using a listcomp with two 'for' List comprehensions can contain complex expressions and nested functions: The initial expression in a list comprehension can be any arbitrary expression, including another list comprehension. Consider the following example of a 3x4 matrix implemented as a list of 3 lists of length 4: The following list comprehension will transpose rows and columns: As we saw in the previous section, the inner list comprehension is evaluated in the context of the that follows it, so this example is equivalent to: which, in turn, is the same as: # the following 3 lines implement the nested listcomp In the real world, you should prefer built-in functions to complex flow statements. The function would do a great job for this use case: See Unpacking Argument Lists for details on the asterisk in this line.\n\nWe saw that lists and strings have many common properties, such as indexing and slicing operations. They are two examples of sequence data types (see Sequence Types — list, tuple, range). Since Python is an evolving language, other sequence data types may be added. There is also another standard sequence data type: the tuple. A tuple consists of a number of values separated by commas, for instance: File , line , in : # but they can contain mutable objects: As you see, on output tuples are always enclosed in parentheses, so that nested tuples are interpreted correctly; they may be input with or without surrounding parentheses, although often parentheses are necessary anyway (if the tuple is part of a larger expression). It is not possible to assign to the individual items of a tuple, however it is possible to create tuples which contain mutable objects, such as lists. Though tuples may seem similar to lists, they are often used in different situations and for different purposes. Tuples are immutable, and usually contain a heterogeneous sequence of elements that are accessed via unpacking (see later in this section) or indexing (or even by attribute in the case of ). Lists are mutable, and their elements are usually homogeneous and are accessed by iterating over the list. A special problem is the construction of tuples containing 0 or 1 items: the syntax has some extra quirks to accommodate these. Empty tuples are constructed by an empty pair of parentheses; a tuple with one item is constructed by following a value with a comma (it is not sufficient to enclose a single value in parentheses). Ugly, but effective. For example: The statement is an example of tuple packing: the values , and are packed together in a tuple. The reverse operation is also possible: This is called, appropriately enough, sequence unpacking and works for any sequence on the right-hand side. Sequence unpacking requires that there are as many variables on the left side of the equals sign as there are elements in the sequence. Note that multiple assignment is really just a combination of tuple packing and sequence unpacking.\n\nPython also includes a data type for sets. A set is an unordered collection with no duplicate elements. Basic uses include membership testing and eliminating duplicate entries. Set objects also support mathematical operations like union, intersection, difference, and symmetric difference. Curly braces or the function can be used to create sets. Note: to create an empty set you have to use , not ; the latter creates an empty dictionary, a data structure that we discuss in the next section. Here is a brief demonstration: # show that duplicates have been removed # Demonstrate set operations on unique letters from two words # letters in a but not in b # letters in a or b or both # letters in both a and b # letters in a or b but not both Similarly to list comprehensions, set comprehensions are also supported:\n\nAnother useful data type built into Python is the dictionary (see Mapping Types — dict). Dictionaries are sometimes found in other languages as “associative memories” or “associative arrays”. Unlike sequences, which are indexed by a range of numbers, dictionaries are indexed by keys, which can be any immutable type; strings and numbers can always be keys. Tuples can be used as keys if they contain only strings, numbers, or tuples; if a tuple contains any mutable object either directly or indirectly, it cannot be used as a key. You can’t use lists as keys, since lists can be modified in place using index assignments, slice assignments, or methods like and . It is best to think of a dictionary as a set of key: value pairs, with the requirement that the keys are unique (within one dictionary). A pair of braces creates an empty dictionary: . Placing a comma-separated list of key:value pairs within the braces adds initial key:value pairs to the dictionary; this is also the way dictionaries are written on output. The main operations on a dictionary are storing a value with some key and extracting the value given the key. It is also possible to delete a key:value pair with . If you store using a key that is already in use, the old value associated with that key is forgotten. It is an error to extract a value using a non-existent key. Performing on a dictionary returns a list of all the keys used in the dictionary, in insertion order (if you want it sorted, just use instead). To check whether a single key is in the dictionary, use the keyword. Here is a small example using a dictionary: The constructor builds dictionaries directly from sequences of key-value pairs: In addition, dict comprehensions can be used to create dictionaries from arbitrary key and value expressions: When the keys are simple strings, it is sometimes easier to specify pairs using keyword arguments:\n\nWhen looping through dictionaries, the key and corresponding value can be retrieved at the same time using the method. When looping through a sequence, the position index and corresponding value can be retrieved at the same time using the function. To loop over two or more sequences at the same time, the entries can be paired with the function. What is your name? It is lancelot. What is your quest? It is the holy grail. What is your favorite color? It is blue. To loop over a sequence in reverse, first specify the sequence in a forward direction and then call the function. To loop over a sequence in sorted order, use the function which returns a new sorted list while leaving the source unaltered. Using on a sequence eliminates duplicate elements. The use of in combination with over a sequence is an idiomatic way to loop over unique elements of the sequence in sorted order. It is sometimes tempting to change a list while you are looping over it; however, it is often simpler and safer to create a new list instead.\n\nThe conditions used in and statements can contain any operators, not just comparisons. The comparison operators and are membership tests that determine whether a value is in (or not in) a container. The operators and compare whether two objects are really the same object. All comparison operators have the same priority, which is lower than that of all numerical operators. Comparisons can be chained. For example, tests whether is less than and moreover equals . Comparisons may be combined using the Boolean operators and , and the outcome of a comparison (or of any other Boolean expression) may be negated with . These have lower priorities than comparison operators; between them, has the highest priority and the lowest, so that A and not B or C is equivalent to (A and (not B)) or C . As always, parentheses can be used to express the desired composition. The Boolean operators and are so-called short-circuit operators: their arguments are evaluated from left to right, and evaluation stops as soon as the outcome is determined. For example, if and are true but is false, A and B and C does not evaluate the expression . When used as a general value and not as a Boolean, the return value of a short-circuit operator is the last evaluated argument. It is possible to assign the result of a comparison or other Boolean expression to a variable. For example, Note that in Python, unlike C, assignment inside expressions must be done explicitly with the walrus operator . This avoids a common class of problems encountered in C programs: typing in an expression when was intended.\n\nSequence objects typically may be compared to other objects with the same sequence type. The comparison uses lexicographical ordering: first the first two items are compared, and if they differ this determines the outcome of the comparison; if they are equal, the next two items are compared, and so on, until either sequence is exhausted. If two items to be compared are themselves sequences of the same type, the lexicographical comparison is carried out recursively. If all items of two sequences compare equal, the sequences are considered equal. If one sequence is an initial sub-sequence of the other, the shorter sequence is the smaller (lesser) one. Lexicographical ordering for strings uses the Unicode code point number to order individual characters. Some examples of comparisons between sequences of the same type: Note that comparing objects of different types with or is legal provided that the objects have appropriate comparison methods. For example, mixed numeric types are compared according to their numeric value, so 0 equals 0.0, etc. Otherwise, rather than providing an arbitrary ordering, the interpreter will raise a exception."
    },
    {
        "link": "https://mimo.org/glossary/python/insert()",
        "document": "In Python, is a list method that allows you to add a single element to a specific position in the list. modifies the list without creating a new list.\n\nHow to Use insert() in Python Lists\n\nAs a list method, requires a list to insert the element into and two parameters. The parameters specify the index at which to insert the element and the element to insert.\n\nHere's the basic syntax of using the method with a Python list:\n\nWhen to Use insert() in Python Lists\n\nUnlike , which adds to the end of the list, lets you add elements anywhere within the list. Therefore, gives you more control over a list’s structure.\n\nInsert an Item at the Beginning\n\nis particularly useful for adding elements at the beginning of a list. For example, consider scenarios where you need to grow or maintain a list in reverse order.\n\nExamples of Using insert() in Python Lists\n\nIn e-commerce platforms, can manage product displays where featured products get a top position in the list.\n\nAnother example is task management, where the order of tasks is important. can adjust priorities by inserting items at specific positions based on their priority level.\n\nIn finance, can help to insert stock data in a time-series dataset at the correct chronological position.\n\nLearn More About the Python List insert() Method\n\nWhile allows you to add an element at any position, adds it only at the end of the list. When working with large lists, is significantly faster.\n\nThe method concatenates another list to the end of the list. , on the other hand, only adds a single item at a specified position.\n\nUsing with an out-of-range index doesn't raise an error in Python. Instead, Python places the item at the end of the list if the index exceeds the list length. This behavior prevents an that could disrupt program flow. Nonetheless, inserting into a list at an out-of-range index can lead to unintended behavior.\n\nIn applications like data processing or game development, managing multidimensional lists is common. can modify these lists by adding rows or columns efficiently.\n\nInserting elements into a list, especially in the middle, can have significant memory and performance implications. Python needs to shift elements to make space for the new element. Such shifts might involve reallocating the entire array to fit the new size. For large lists, this operation can lead to performance issues.\n\nFor large-scale insertions, consider alternative data structures like linked lists or . Such data structures allow for more efficient appends and pops from both ends."
    },
    {
        "link": "https://realpython.com/python-del-statement",
        "document": "Python’s statement will allow you to remove names and references from different namespaces. It’ll also allow you to delete unneeded items from your lists and keys from your dictionaries. If you want to learn how to use in your Python code, then this tutorial is for you. The statement empowers you to better manage memory resources in your code, making your programs more efficient.\n\nIn this tutorial, you’ll learn how to:\n• Write and use statements in Python\n• Take advantage of to remove names from different scopes\n• Use for removing list items and dictionary keys\n\nTo get the most out of this tutorial, you should be familiar with Python’s built-in data types, specifically lists and dictionaries. You should also know the basics of classes and object-oriented programming in Python.\n\nGetting to Know Python’s Statement Python’s statement allows you to remove references to objects from a given namespace or container type. It performs an operation that’s the opposite of what an assignment statement does. It’s sort of an unassignment statement that allows you to unbind one or more names from their referenced objects. This is a natural feature to have in Python. If you can create a variable by writing , then you must have the option to undo this operation by deleting . That’s where comes on the scene. The statement can come in handy in different coding situations, such as:\n• Preventing accidental use of variables and names Of course, this list is incomplete. You may find some other appropriate use cases for this statement. In this tutorial, you’ll learn how the statement works and how to use it in your code. To kick things off, you’ll start by learning the general syntax of in Python. A Python statement consists of the keyword, followed by a comma-separated series of references. Note: In this tutorial, you’ll use the term reference to generically designate names or identifiers that can hold references to objects in Python. Here’s the general syntax of the statement in Python: The statement allows you to remove one or more references from a given namespace. It also lets you delete data from mutable container types, such as lists and dictionaries. You’ll often use this statement with a single argument. However, it also supports a series of arguments separated by commas. In the above construct, represents any kind of identifier that can hold references to concrete objects stored in memory. In practice, these references can include:\n• Identifiers, such as variables and names of functions, classes, modules, and packages\n• Indices of mutable sequences, such as\n• Members of classes and objects, such as attributes and methods You can use any of these references as arguments to . If you use a comma-separated series of arguments, then keep in mind that operates on every argument sequentially from left to right. This behavior can be risky when you’re removing items from lists, as you’ll learn later in this tutorial. Here’s a quick example of using to remove a variable: : name 'greeting' is not defined Once you’ve run the statement, the variable is no longer available. If you try to access , then you get a because that variable doesn’t exist anymore. Removing reference holders like variables is the primary goal of . This statement doesn’t remove objects. In the following section, you’ll dive deeper into the actual and immediate effects of running a statement. As you’ve learned, Python’s statement deletes references from namespaces or data containers. It doesn’t remove concrete objects. For example, you can’t remove literals of built-in types using : In these examples, note that you can’t use the statement directly on objects. You must use it with variables, names, and other identifiers, as you already learned: However, running like in this example doesn’t mean that you’re removing the number from memory. It only removes the name from your current namespace or scope. When you pass an identifier—like a variable, class, function, or method name—as an argument to , the statement unbinds the identifier from the referenced object and removes the identifier from its containing namespace. However, the referenced object may not be deleted from your computer’s memory immediately. Similarly, when you use a list index, slice, or dictionary key as an argument to , you remove the reference to the target item, slice, or key from the containing data structure. This may not imply the immediate removal of the referenced object from your computer’s memory. In short, doesn’t remove objects from memory and free up the used space. It only removes references to objects. This behavior may raise a question. If doesn’t remove objects from memory, then how can you use to release memory resources during your code’s execution? To answer this question, you need to understand how Python manages the removal of objects from memory. In the following section, you’ll learn about Python’s garbage collection system and how it relates to using for freeing up memory in your programs. Python has a garbage collection system that takes care of removing unused objects from memory and freeing up resources for later use. In Python’s CPython implementation, the reference count is the primary indicator that triggers garbage collection. Essentially, Python keeps track of how many identifiers hold references to each object at any given time. The number of identifiers pointing to a given object is known as the object’s reference count. If there’s at least one active reference to an object, then the object will remain accessible to you, occupying memory on your computer. If you use to remove this single reference, then the object is ready for garbage collection, which will remove the object and free the memory. On the other hand, if you have several active references to an object and you use to remove some of these references but not all of them, then the garbage collection system won’t be able to remove the object and free up the memory. In short, removes references, while garbage collection removes objects and frees up memory. According to this behavior, you can conclude that only allows you to reduce your code’s memory consumption when it removes the last reference to an object, which prepares the object to be garbage-collected. It’s important to note that Python’s garbage collection system doesn’t free the memory used by an object immediately after you remove the last reference to that object, bringing the reference count down to zero. Instead, Python’s garbage collector periodically scans the memory for unreferenced objects and frees them. Note: The statement isn’t the only tool that you can use to lower the reference count of a given object. If you make an existing reference point to another object, then you implicitly remove one reference to the original object. Another action that lowers the reference count is making a given reference go out of scope, implicitly removing the reference. When an object’s reference count reaches zero, the garbage collector may proceed to remove that object from memory. At that moment, the special method comes into play. Python automatically calls when a given object is about to be destroyed. This call allows the object to release external resources and clean itself up. It’s important to note that the statement doesn’t trigger the method. You won’t need to implement the method in your own classes very often. The proper use of is rather tricky. If you ever need to write this method in one of your classes, then make sure you carefully read its documentation page. Assigning to a reference is an operation that’s often compared to using a statement. But this operation doesn’t remove the reference like does. It only reassigns the reference to point to : Reassigning the variable to point to makes the reference count of object go down to zero. Because of this, Python can garbage-collect the object, freeing the corresponding memory. However, this assignment doesn’t remove the variable name from your current scope like a statement would do. Because is a singleton object that’s built into Python, this assignment doesn’t allocate or use new memory but keeps your variable alive and available in your current scope. The approach may be useful when you want to prevent the exception that happens when you attempt to delete a name or reference holder that doesn’t exist in your current namespace. In this case, Python will silently create a new variable and assign as its initial value.\n\nRemoving a name from a given scope is the first use case of that you’ll learn about in this tutorial. The scope of a given name or identifier is the area of a program where you can unambiguously access that name. In Python, you’ll find at most four scopes: The statement can remove names from some of these scopes. As you’ve seen in previous examples, you can use to remove one or more variables from the global scope: : name 'color' is not defined : name 'fruit' is not defined : name 'pet' is not defined In this example, you create three global variables. Then you use the statement to remove these variables from your global scope, which is where they live. Remember that has the effect of an unassignment statement. Note: You can inspect all the names that live in your global and built-in scopes using the built-in function. Similarly, you can access the names in your current local scope using the function. Both functions return dictionary objects mapping names to objects in their target scopes. You can also remove names from the local and enclosed scopes within your custom functions using in the same way. However, you can’t remove names from the built-in scope: : name 'list' is not defined : name 'dict' is not defined : name 'max' is not defined If you try to remove any built-in name using a statement, then you get a . The error message may seem confusing because you can access all these names as if they were in the global scope. However, these names live in the built-in scope, which isn’t directly accessible with . Even though you can’t delete built-in names, you can override or shadow them at any moment in your code. Python has many built-in names. Some of them may fit your naming needs in some situations. For example, when you’re beginning with Python, lists may be one of the first built-in data types that you learn about. Say that you’re learning about lists and run the following code: In this example, you’ve used as the name for a object containing some numbers. Reassigning a built-in name, as you did in this code snippet, shadows the original object behind the name, which prevents you from using it in your code: Now calling fails because you’ve overridden the name in your previous code. A quick fix to this issue is to use the statement to remove the fake built-in name and recover the original name: # Now the original name is available again If you accidentally reassign a built-in name in an interactive session, then you can run a quick statement to remove the redefinition from your scope and restore the original built-in name in your working scope.\n\nRemoving items from mutable collections like lists or dictionaries is arguably the most common use case of Python’s statement. Even though these built-in data types provide methods that you can use to remove items by index or key, can produce slightly different results or be appropriate in different scenarios. You can also use the statement to remove several items from a list in one go. To do this, you can use the slice syntax. For this specific use case, you won’t find a method that performs the task. So, is your way to go. In the following sections, you’ll learn how to use to remove items from existing lists. You’ll also learn how to remove key-value pairs from dictionaries using . With these skills, you’ll be able to make your code more efficient by letting Python’s garbage collection system free up the memory resources that your lists and dictionaries won’t need any longer. You’ve already learned that the list-indexing syntax, , allows you to access individual items in a list. This syntax provides an identifier that holds a reference to the item at the target index. If you need to delete an item from an existing list, then you can use the statement along with the indexing operator. The general syntax is: This statement will remove the item that lives at the position defined by in . Here’s an example so you can experience how this works in practice: In this code snippet, you create a list containing some computer parts. Then you use to remove , the item at index . Finally, you remove the last item in the list, using the negative index . Note: The statement fails to remove items from immutable sequence types, such as strings, bytes, and tuples: Deleting an item from this tuple would imply an in-place mutation, which isn’t allowed in immutable collection types. Be careful when using the extended syntax of to remove multiple items from a list. You may end up removing the wrong items or even getting an . For example, say that you need to remove the items containing in a sample of numeric data so that you can use the data in some computations. Then you may think of using the following statement: What just happened? You didn’t remove the second but instead removed the number . The problem is that acts on its arguments sequentially from left to right. In this example, first removes the second item from . Then it removes the fourth item, , from the modified list. To get the desired result, you need to consider that the target list changes after every removal. A possible work-around is to remove items from right to left: In this example, you’ve deleted the items in reverse order starting from the greatest index and going back to the smallest one. This technique allows you to safely remove multiple items from lists using a single statement. When you use a list index as an argument to , Python falls back to calling the special method, which takes care of the actual removal. Here’s an example that illustrates this behavior: In this example, you subclass the built-in class and override its method. Inside the method, you print a message to show that the method is called automatically. Then you use to call the original implementation of in the parent class, . Note: To learn more about subclassing the built-in type, check out Custom Python Lists: Inheriting From vs . Speaking of methods, Python lists have the and methods, which allow you to remove an item by value or index, respectively: In the call to , you delete the item from your list. This method call is equivalent to running . Using vs will depend on what you’re trying to do. If want to remove items based on their index, without knowing their content, then is the solution because it operates on item indices. On the other hand, if you want to remove list items with known content, then can be more readable and explicit. It’ll clearly communicate that you want to delete that specific value. Then you use to delete the item at index . Apart from removing the target item, also returns it. That’s why you get on the screen. Finally, calling without a target index removes and returns the final item from the target list. Using vs depends even more on your specific needs. In this case, both options operate with item indices. The distinctive feature is the return value. If you don’t care about the return value, then go for . If you need the return value for further computations, then you must use . Removing a slice of items from an existing list is another everyday use case of the statement. You won’t find any method that performs a similar task, so might be your way to go. To remove a slice from a list, you need to use the following syntax: The slicing syntax accepts up to three colon-separated arguments: , , and . They define the index that starts the slice, the index at which the slicing must stop retrieving values, and the step between values. Here are some examples of using the above construct to remove slices from lists: In the first example, you remove all the items from index to . Note that the slicing interval is open at , which means that the item at index isn’t included in the removal. In other words, the slicing operation stops when it reaches the index without including the item at that index. In the second example, you use no value for , which means that you want to start the deletion from the first item in the list. Finally, you don’t use a value in the third example. This means that you want to remove all the items from to the end of the list. You can also use to define how many items you want to jump through during the slicing. Consider the following example: In this example, you use a of to delete every other item from . This is a neat trick that removes the odd numbers from your list. You can use a object instead of the slicing operator to delete items from your lists: In this example, you use the built-in class to create a slice object. The class constructor takes the three arguments , , and . They have the same meaning as the equivalent indices in the slicing operator. This specific slice object retrieves items starting from up to the end of the list, which you accomplish by setting the argument to . The argument takes a value of . This slice removes every other item from the target list. Interestingly enough, deleting a slice of items from an existing list has the same effect as assigning an empty list to the same slice: Assigning an empty list to a given slice has the same effect as removing the target slice using a statement. This example is equivalent to its first version at the beginning of this section. Removing unnecessary items from your lists may save some memory in your programs. You typically don’t keep additional references to list items, so if you remove several items from a list, then the objects stored in those items become available for garbage collection, which may lead to releasing some memory. Removing key-value pairs from a dictionary is another common use case of . For this to work, you need to specify the key that you want to remove as an argument to . Here’s the general syntax for that: This statement removes , and its associated value, from the containing dictionary, . To see this construct in action, go ahead and run the following example: Here you use to remove the , , and keys from your dictionary. In the case of dictionaries, it’s completely safe to remove multiple keys in a single line using the extended syntax of because keys are unique. You can also use some methods to remove keys from a dictionary. For example, you can use the and methods: In the first example, you use to remove the key and its associated value, , from your dictionary. You must call with an existing key as an argument. In the second example, you call to delete the most recently added item from . Even though these methods remove keys from existing dictionaries, they work slightly differently from . Besides removing the target key, returns the value associated with that key. Similarly, removes the key and returns the corresponding key-value pair as a tuple. The statement doesn’t return the removed value. Python automatically calls the special method when you use to remove a key from a dictionary. Here’s an example that illustrates this behavior: In this example, you override the method in the class, which inherits from the built-in class. Running the statement with a key of as an argument triggers your custom implementation, which prints a message that provides information about the removed item. To learn more about how to safely subclass the built-in type in Python, check out Custom Python Dictionaries: Inheriting From vs . Sometimes, you may need to nest mutable types, such as lists and dictionaries, in outer lists, tuples, and dictionaries. Once you’ve created one of these nested structures, you can access individual items on different levels of nesting using the indices or keys of those items. The leftmost indices or keys will retrieve the outer sequences or dictionaries, while the rightmost indices will retrieve the most deeply nested objects. The possibility of accessing nested items allows you to use to remove them using the following syntax: To access and delete objects from nested mutable collections, you must use the indexing operator, providing appropriate indices from left to right. Count how many levels of nesting you’ll need to walk through to reach the target item. That’s how many indices you must provide. Here’s an example of how to remove nested items from a list of lists: In this example, you’ve used to remove nested items in your list. Specifically, you’ve removed the last value from every matrix row. Using descriptive names for the indices allows you to improve the readability of your code, making it easier to reason about. As you can see, represents the index of a nested list in , while represents the index of the target item in the nested list. That’s how you access nested items. Even though Python tuples are immutable data types that don’t allow direct deletions, they can store lists, dictionaries, and other mutable types that do allow deletions. So, you can also use on nested mutable objects in your tuples. To illustrate this behavior, say you’re working with colors in the RGB color model. To represent each color, you use a tuple because colors should be constant. You decide to create your color objects by providing a name in uppercase and a list of RGB values: These colors look great. They have a name and a list of RBG values. You can’t delete first-level items in these tuples because tuples are immutable. However, you can delete items from the nested lists holding the RGB values: Tuples are completely immutable when all their items are immutable too. If one or more items in a tuple are mutable, then you can delete values from them using nested indexing, as you did in the above example. Another common practice in Python is to nest lists in dictionaries. This type of construct appears often when you’re working with JSON files, which provide a clear and readable format for exchanging information. Consider the following example of a dictionary that stores products by class: To remove an item from the inner lists in your dictionary, you first use the dictionary key and then the index of the target item in the nested list. You can store objects of any data type in the values of a Python dictionary. You can store strings, tuples, lists, other dictionaries, classes, functions, and even user-defined objects. If the object in a given value is mutable, then you can remove items from it using . Here’s another example. This time, you have a list of dictionaries. Each nested dictionary contains another dictionary: To remove an item from the most deeply nested dictionary, you need to use the index of the containing list, then the key of the second-level dictionary, and finally, the key of the item that you want to remove. Note that you can use other index-key combinations to delete other items, depending on their nesting level.\n\nWhen it comes to user-defined classes, you can remove both class and instance attributes using the statement. You can also use to remove methods from your classes. Deleting members of classes and instances might be only rarely useful, but it’s possible in Python. The general syntax for removing class members with is as follows: To pass the target member as an argument to , you need to use dot notation on either the class or one of its instances, depending on what type of member you need to remove. In the following sections, you’ll code examples of how all this works in practice. To illustrate how the syntax for removing class members works, go ahead and write the following class in your Python interactive REPL: In this code snippet, you create a sample class with a class attribute, an instance attribute, and a method. The highlighted lines show how these members live in the class and instance attributes, which store the class and instance attributes, respectively. Now go ahead and run the following statements to delete the members of this class and its object: Using an instance of a given class, you can only remove instance attributes. If you try to remove class attributes and methods, then you get an exception. You can only remove class attributes and methods through the class itself, as you can confirm in the final two examples. When would be useful for removing instance attributes? When you need to reduce your object’s memory footprint by preparing temporary instance attributes for Python’s garbage collection system, which can result in freeing up valuable memory resources on your computer. For example, say that you want to write a class to represent the factorial of a number. The class constructor must take a number as an argument and create an instance with two read-only attributes, and . The class should use caching as an optimization to avoid any unnecessary repetition of intermediate computations. It should also be memory-efficient and remove the cache after computing the factorial. Here’s a possible implementation for your class: Wow! There’s a lot happening in this code. Here’s a breakdown of the most relevant lines:\n• Line 4 defines the initializer, which takes your input number as an argument.\n• Line 6 defines another instance attribute called that’ll work as a cache for intermediate computation. Initially, this attribute holds the factorial of and .\n• Line 7 defines the attribute to hold the factorial of the input number. Note that this attribute gets its value from a call to .\n• Line 8 uses to remove the cached data. This removal will allow you to free up memory for later use and make your instances more lightweight and your code more memory-efficient.\n• Lines 10 to 15 define the method, which calculates the factorial of your input number, using to store the already-computed values.\n• Lines 17 to 23 define two properties to manage the and attributes. Note that these properties don’t have setter methods, which makes the underlying attributes read-only.\n• Lines 25 to 26 define a method that returns a user-friendly string representation for your instances.\n• Lines 28 to 29 define a method that returns a developer-friendly string representation of objects. Here’s how your class works in practice: : property 'factorial' of 'Factorial' object has no setter : In the first example, you run a loop that creates five instances of and prints them to the screen. Note how the method works by printing the instance using the mathematical factorial notation. Then you create another instance of with as the input number. Note how you can access the and attributes but can’t reassign them because they’re read-only. Finally, if you try to access the non-public attribute, then you get an because you already removed this attribute in the method. Deleting the attribute after the factorial computation makes the instances of memory-efficient. To illustrate this, go ahead and add the Pympler library by installing with . This library will allow you to measure the memory footprint of your instances. Then execute the following code: Here, you use the function to calculate the combined size in bytes of a instance. As you can see, this specific instance of occupies 600 bytes in your computer’s memory. Now get back to your file and comment out line 8, which contains the statement that removes . With this change in place, go ahead and run the above function call again: Now the size of your instance is more than 23 times greater than before. That’s the impact of removing vs keeping the unnecessary cached data once the instance is complete.\n\nIn Python, you can write your classes in a way that prevents the removal of instance attributes. You’ll find a bunch of techniques to do this. In this section, you’ll learn about two of these techniques: To kick things off, you’ll start by overriding the special method with a custom implementation. Under the hood, Python automatically calls this method when you use a given instance attribute as an argument to the statement. As an example of how to create a class that prevents you from removing its instance attribute, consider the following toy class: In this class, you override the special method. Your implementation raises an exception whenever a user tries to remove any attribute, like the , using a statement. Here’s an example of how your class behaves in practice: Whenever you try to remove the attribute of any instance of , you get an exception that comes from your custom implementation of . This technique provides a quick solution for those situations where you need to prevent instance attribute deletion. Another common, quick technique for preventing instance attribute deletions is to turn your target attribute into a property and provide a suitable deleter method. For example, say that you want to code a class that prevents users from deleting its attribute: In this example, has a attribute that you implement through a property. The attribute has a getter method that returns the value of , which is the regular attribute that stores the data. The setter method takes a new value for the attributes, converts it into a string, and transforms it into uppercase letters. Finally, the deleter method raises an to signal that the attribute isn’t deletable. Python calls this method automatically when you use the attribute as an argument in a statement: Your class works as expected. You can access its attribute and update it with new values while uppercasing the input value every time. The deleter method of your property at the end of the class definition ensures that your users can’t delete the attribute."
    },
    {
        "link": "https://stackoverflow.com/questions/23331419/is-the-use-of-del-bad",
        "document": "The other answers are looking at it from a technical point of view (i.e. what's the best way to modify a list), but I would say the (much) more important reason people recommend, for example, slicing, is that it doesn't modify the original list.\n\nThe reason for this in turn is that usually, the list came from somewhere. If you modify it, you can unknowningly cause serious and hard-to-detect side effects, which can cause bugs elsewhere in the program. Or even if you don't cause a bug immediately, you'll make your program overall harder to understand and reason about, and debug.\n\nFor example, list comprehensions/generator expressions are nice in that they never mutate the \"source\" list they are passed:\n\nThis is of course often more expensive (memory wise) because it creates a new list but a program that uses this approach is mathematically purer and easier to reason about. And with lazy lists (generators and generator expressions), even the memory overhead will disappear, and computations are only executed on demand; see http://www.dabeaz.com/generators/ for an awesome introduction. And you should not think too much about optimization when designing your program (see https://softwareengineering.stackexchange.com/questions/80084/is-premature-optimization-really-the-root-of-all-evil). Also, removing an item from a list is quite expensive, unless it's a linked list (which Python's isn't; for linked list, see ).\n\nIn fact, side-effect free functions and immutable data structures are the basis of Functional Programming, a very powerful programming paradigm.\n\nHowever, under certain circumstances, it's OK to modify a data structure in place (even in FP, if the language allows it), such as when it's a locally created one, or copied from the function's input:\n\n— this function appears to be a pure function from the outside because it doesn't modify its inputs (and also only depends on its arguments and nothing else (i.e. it has no (global) state), which is another requirement for something to be a Pure Function).\n\nSo as long as you know what you're doing, is by no means bad; but use any sort of data mutation with extreme care and only when you have to. Always start out with a possibly less efficient but more correct and mathematically elegant code.\n\nP.S. note that can also be used to delete local variables and thus eliminate references to objects in memory, which is often useful for whatever GC related purposes.\n\nAnswer to your second question:\n\nAs to the second part of your question about removing objects completely — that's not the case: in fact in Python, it is not even possible to tell the interpreter/VM to remove an object from memory because Python is a garbage collected language (like Java, C#, Ruby, Haskell etc) and it's the runtime that decides what to remove and when.\n\nInstead, what does when called on a variable (as opposed to a dictionary key or list item) like this:\n\nis that it only removes the local (or global) variable and not what the variable points to (every variable in Python holds a pointer/reference to its contents not the content itself). In fact, since locals and globals are stored as a dictionary under the hood (see and ), is equivalent to:\n\nor when applied to a global.\n\nso if you have:\n\nyou're making a list, storing a reference to it in and then making another copy of that reference and storing it into without copying/touching the list object itself. Therefore, these two calls affect one and the same object:\n\nwhereas deleting is in no way related to touching what points to:\n\nAlso, even when you call on an object attribute (e.g. ), you're still actually modifying a dictionary just like you are actually modifying / when you do .\n\nP.S. as Sven Marcnah has pointed out that does not actually delete the local variable when inside a function, which is correct. This is probably due to returning a copy of the actual locals. However, the answer is still generally valid."
    },
    {
        "link": "https://docs.python.org/3/tutorial/datastructures.html",
        "document": "This chapter describes some things you’ve learned about already in more detail, and adds some new things as well.\n\nThe list data type has some more methods. Here are all of the methods of list objects: Add an item to the end of the list. Similar to . Extend the list by appending all the items from the iterable. Similar to . Insert an item at a given position. The first argument is the index of the element before which to insert, so inserts at the front of the list, and is equivalent to . Remove the first item from the list whose value is equal to x. It raises a if there is no such item. Remove the item at the given position in the list, and return it. If no index is specified, removes and returns the last item in the list. It raises an if the list is empty or the index is outside the list range. Remove all items from the list. Similar to . Return zero-based index in the list of the first item whose value is equal to x. Raises a if there is no such item. The optional arguments start and end are interpreted as in the slice notation and are used to limit the search to a particular subsequence of the list. The returned index is computed relative to the beginning of the full sequence rather than the start argument. Return the number of times x appears in the list. Sort the items of the list in place (the arguments can be used for sort customization, see for their explanation). Reverse the elements of the list in place. Return a shallow copy of the list. Similar to . An example that uses most of the list methods: You might have noticed that methods like , or that only modify the list have no return value printed – they return the default . This is a design principle for all mutable data structures in Python. Another thing you might notice is that not all data can be sorted or compared. For instance, doesn’t sort because integers can’t be compared to strings and can’t be compared to other types. Also, there are some types that don’t have a defined ordering relation. For example, isn’t a valid comparison. The list methods make it very easy to use a list as a stack, where the last element added is the first element retrieved (“last-in, first-out”). To add an item to the top of the stack, use . To retrieve an item from the top of the stack, use without an explicit index. For example: It is also possible to use a list as a queue, where the first element added is the first element retrieved (“first-in, first-out”); however, lists are not efficient for this purpose. While appends and pops from the end of list are fast, doing inserts or pops from the beginning of a list is slow (because all of the other elements have to be shifted by one). To implement a queue, use which was designed to have fast appends and pops from both ends. For example: # The first to arrive now leaves # The second to arrive now leaves List comprehensions provide a concise way to create lists. Common applications are to make new lists where each element is the result of some operations applied to each member of another sequence or iterable, or to create a subsequence of those elements that satisfy a certain condition. For example, assume we want to create a list of squares, like: Note that this creates (or overwrites) a variable named that still exists after the loop completes. We can calculate the list of squares without any side effects using: which is more concise and readable. A list comprehension consists of brackets containing an expression followed by a clause, then zero or more or clauses. The result will be a new list resulting from evaluating the expression in the context of the and clauses which follow it. For example, this listcomp combines the elements of two lists if they are not equal: Note how the order of the and statements is the same in both these snippets. If the expression is a tuple (e.g. the in the previous example), it must be parenthesized. # create a new list with the values doubled # apply a function to all the elements # the tuple must be parenthesized, otherwise an error is raised File , line : did you forget parentheses around the comprehension target? # flatten a list using a listcomp with two 'for' List comprehensions can contain complex expressions and nested functions: The initial expression in a list comprehension can be any arbitrary expression, including another list comprehension. Consider the following example of a 3x4 matrix implemented as a list of 3 lists of length 4: The following list comprehension will transpose rows and columns: As we saw in the previous section, the inner list comprehension is evaluated in the context of the that follows it, so this example is equivalent to: which, in turn, is the same as: # the following 3 lines implement the nested listcomp In the real world, you should prefer built-in functions to complex flow statements. The function would do a great job for this use case: See Unpacking Argument Lists for details on the asterisk in this line.\n\nWe saw that lists and strings have many common properties, such as indexing and slicing operations. They are two examples of sequence data types (see Sequence Types — list, tuple, range). Since Python is an evolving language, other sequence data types may be added. There is also another standard sequence data type: the tuple. A tuple consists of a number of values separated by commas, for instance: File , line , in : # but they can contain mutable objects: As you see, on output tuples are always enclosed in parentheses, so that nested tuples are interpreted correctly; they may be input with or without surrounding parentheses, although often parentheses are necessary anyway (if the tuple is part of a larger expression). It is not possible to assign to the individual items of a tuple, however it is possible to create tuples which contain mutable objects, such as lists. Though tuples may seem similar to lists, they are often used in different situations and for different purposes. Tuples are immutable, and usually contain a heterogeneous sequence of elements that are accessed via unpacking (see later in this section) or indexing (or even by attribute in the case of ). Lists are mutable, and their elements are usually homogeneous and are accessed by iterating over the list. A special problem is the construction of tuples containing 0 or 1 items: the syntax has some extra quirks to accommodate these. Empty tuples are constructed by an empty pair of parentheses; a tuple with one item is constructed by following a value with a comma (it is not sufficient to enclose a single value in parentheses). Ugly, but effective. For example: The statement is an example of tuple packing: the values , and are packed together in a tuple. The reverse operation is also possible: This is called, appropriately enough, sequence unpacking and works for any sequence on the right-hand side. Sequence unpacking requires that there are as many variables on the left side of the equals sign as there are elements in the sequence. Note that multiple assignment is really just a combination of tuple packing and sequence unpacking.\n\nPython also includes a data type for sets. A set is an unordered collection with no duplicate elements. Basic uses include membership testing and eliminating duplicate entries. Set objects also support mathematical operations like union, intersection, difference, and symmetric difference. Curly braces or the function can be used to create sets. Note: to create an empty set you have to use , not ; the latter creates an empty dictionary, a data structure that we discuss in the next section. Here is a brief demonstration: # show that duplicates have been removed # Demonstrate set operations on unique letters from two words # letters in a but not in b # letters in a or b or both # letters in both a and b # letters in a or b but not both Similarly to list comprehensions, set comprehensions are also supported:\n\nAnother useful data type built into Python is the dictionary (see Mapping Types — dict). Dictionaries are sometimes found in other languages as “associative memories” or “associative arrays”. Unlike sequences, which are indexed by a range of numbers, dictionaries are indexed by keys, which can be any immutable type; strings and numbers can always be keys. Tuples can be used as keys if they contain only strings, numbers, or tuples; if a tuple contains any mutable object either directly or indirectly, it cannot be used as a key. You can’t use lists as keys, since lists can be modified in place using index assignments, slice assignments, or methods like and . It is best to think of a dictionary as a set of key: value pairs, with the requirement that the keys are unique (within one dictionary). A pair of braces creates an empty dictionary: . Placing a comma-separated list of key:value pairs within the braces adds initial key:value pairs to the dictionary; this is also the way dictionaries are written on output. The main operations on a dictionary are storing a value with some key and extracting the value given the key. It is also possible to delete a key:value pair with . If you store using a key that is already in use, the old value associated with that key is forgotten. It is an error to extract a value using a non-existent key. Performing on a dictionary returns a list of all the keys used in the dictionary, in insertion order (if you want it sorted, just use instead). To check whether a single key is in the dictionary, use the keyword. Here is a small example using a dictionary: The constructor builds dictionaries directly from sequences of key-value pairs: In addition, dict comprehensions can be used to create dictionaries from arbitrary key and value expressions: When the keys are simple strings, it is sometimes easier to specify pairs using keyword arguments:\n\nWhen looping through dictionaries, the key and corresponding value can be retrieved at the same time using the method. When looping through a sequence, the position index and corresponding value can be retrieved at the same time using the function. To loop over two or more sequences at the same time, the entries can be paired with the function. What is your name? It is lancelot. What is your quest? It is the holy grail. What is your favorite color? It is blue. To loop over a sequence in reverse, first specify the sequence in a forward direction and then call the function. To loop over a sequence in sorted order, use the function which returns a new sorted list while leaving the source unaltered. Using on a sequence eliminates duplicate elements. The use of in combination with over a sequence is an idiomatic way to loop over unique elements of the sequence in sorted order. It is sometimes tempting to change a list while you are looping over it; however, it is often simpler and safer to create a new list instead.\n\nThe conditions used in and statements can contain any operators, not just comparisons. The comparison operators and are membership tests that determine whether a value is in (or not in) a container. The operators and compare whether two objects are really the same object. All comparison operators have the same priority, which is lower than that of all numerical operators. Comparisons can be chained. For example, tests whether is less than and moreover equals . Comparisons may be combined using the Boolean operators and , and the outcome of a comparison (or of any other Boolean expression) may be negated with . These have lower priorities than comparison operators; between them, has the highest priority and the lowest, so that A and not B or C is equivalent to (A and (not B)) or C . As always, parentheses can be used to express the desired composition. The Boolean operators and are so-called short-circuit operators: their arguments are evaluated from left to right, and evaluation stops as soon as the outcome is determined. For example, if and are true but is false, A and B and C does not evaluate the expression . When used as a general value and not as a Boolean, the return value of a short-circuit operator is the last evaluated argument. It is possible to assign the result of a comparison or other Boolean expression to a variable. For example, Note that in Python, unlike C, assignment inside expressions must be done explicitly with the walrus operator . This avoids a common class of problems encountered in C programs: typing in an expression when was intended.\n\nSequence objects typically may be compared to other objects with the same sequence type. The comparison uses lexicographical ordering: first the first two items are compared, and if they differ this determines the outcome of the comparison; if they are equal, the next two items are compared, and so on, until either sequence is exhausted. If two items to be compared are themselves sequences of the same type, the lexicographical comparison is carried out recursively. If all items of two sequences compare equal, the sequences are considered equal. If one sequence is an initial sub-sequence of the other, the shorter sequence is the smaller (lesser) one. Lexicographical ordering for strings uses the Unicode code point number to order individual characters. Some examples of comparisons between sequences of the same type: Note that comparing objects of different types with or is legal provided that the objects have appropriate comparison methods. For example, mixed numeric types are compared according to their numeric value, so 0 equals 0.0, etc. Otherwise, rather than providing an arbitrary ordering, the interpreter will raise a exception."
    },
    {
        "link": "https://stackoverflow.com/questions/6146963/when-is-del-useful-in-python",
        "document": "Is there a reason to keep del in Python, or is it a vestige of Python's pre-garbage collection days?\n\nI can't really think of any reason why Python needs the del keyword (and most languages seem to not have a similar keyword). For instance, rather than deleting a variable, one could just assign None to it. And when deleting from a dictionary, a del method could be added.\n\nFirstly, you can del other things besides local variables Both of which should be clearly useful. Secondly, using on a local variable makes the intent clearer. Compare: I know in the case of that the intent is to remove the variable from scope. It's not clear that is doing that. If somebody just assigned I might think it was dead code. But I instantly know what somebody who codes was trying to do.\n\nDeleting a variable is different than setting it to None Deleting variable names with is probably something used rarely, but it is something that could not trivially be achieved without a keyword. If you can create a variable name by writing , it is nice that you can theoretically undo this by deleting a. It can make debugging easier in some cases as trying to access a deleted variable will raise an NameError. Python lets you write something like: If you choose to dynamically add attributes to a class instance, you certainly want to be able to undo it by writing\n\nThere is a specific example of when you should use (there may be others, but I know about this one off hand) when you are using to inspect an exception. This function returns a tuple, the type of exception that was raised, the message, and a traceback. The first two values are usually sufficient to diagnose an error and act on it, but the third contains the entire call stack between where the exception was raised and where the the exception is caught. In particular, if you do something like try: do_evil() except: exc_type, exc_value, tb = sys.exc_info() if something(exc_value): raise the traceback, ends up in the locals of the call stack, creating a circular reference that cannot be garbage collected. Thus, it is important to do: try: do_evil() except: exc_type, exc_value, tb = sys.exc_info() del tb if something(exc_value): raise to break the circular reference. In many cases where you would want to call , like with metaclass magic, the traceback is useful, so you have to make sure that you clean it up before you can possibly leave the exception handler. If you don't need the traceback, you should delete it immediately, or just do: To avoid it all together.\n\nAs an example of what can be used for, I find it useful i situations like this: def f(a, b, c=3): return '{} {} {}'.format(a, b, c) def g(**kwargs): if 'c' in kwargs and kwargs['c'] is None: del kwargs['c'] return f(**kwargs) # g(a=1, b=2, c=None) === '1 2 3' # g(a=1, b=2) === '1 2 3' # g(a=1, b=2, c=4) === '1 2 4' These two functions can be in different packages/modules and the programmer doesn't need to know what default value argument in actually have. So by using kwargs in combination with del you can say \"I want the default value on c\" by setting it to None (or in this case also leave it). You could do the same thing with something like: def g(a, b, c=None): kwargs = {'a': a, 'b': b} if c is not None: kwargs['c'] = c return f(**kwargs) However I find the previous example more DRY and elegant."
    },
    {
        "link": "https://stratascratch.com/blog/adding-and-removing-list-elements-with-python",
        "document": "Explore the versatile techniques of adding and removing elements in Python lists to enhance data manipulation and streamline your coding workflow.\n\nEver wondered how to handle better lists in Python? Lists manipulation is an integral part of any Python programmer.\n\nIn this guide, we will explore how to manipulate data by adding and removing elements from lists.\n\nWhat is list manipulation in Python programming?\n\nList manipulation uses the same specific operations as transforming a list's contents in Python. Lists are very dynamic, and you can easily add, remove, or change their data, making them a very useful tool for dealing with data in Python.\n• Elements to be added: Methods like append(), insert(), and extend() can be used to add elements to a list.\n• Deleting Elements: You can delete elements from a list using methods such as remove(), pop(), and the del statement.\n\nBut let’s mention lists as another feature before starting.\n\nExplanation of lists as ordered collections of items in Python\n\nA list can have items with different data types, integers, floats, strings, and lists.Each element in a list is ordered, meaning it has a specific position. This is important for indexing and slicing operations.\n\nTake, for example, the following list with a mix of data types.\n\nCheck this one about Python lists to discover it in depth.\n\nTo add elements to a list, we can use append(), insert(), and extend() methods.\n\nThe append() method in Python adds a single element to the end of a list. This method is especially useful when you need to dynamically build a list by adding new elements one at a time.\n\nConsider the following question to understand this concept better.\n\n\n\nIn this question, we are asked to find the cumulative sum of energy consumption data points and store these values in a list using Python's append() method.\n\nHere is the link to this question: https://platform.stratascratch.com/coding/10084-cum-sum-energy-consumption\n\nNow, let’s see the steps to solve this question.\n• Combine DataFrames: Merge DataFrames with energy consumption data using the append () method.\n• Group by Date: In this final section, group the merged DataFrame by date to get an aggregate consumption based on Date.\n• Cumulative Sum: Using the cumsum() method to calculate the sum of total consumption\n• Calculate The consumption percentage of the total.\n• Pre-process data: Drop the columns not used in this case and format the date column.\n\n\n\nThe resulting DataFrame df will contain the cumulative sums of the energy data points and the percentage of total consumption for each date:\n\n\n\nThis demonstrates how the append() method dynamically merges data from different sources to build a cumulative summary.\n\nThis is helpful when adding elements to an ordered list at specific positions. So, I want to delve into that concept with the following question:\n\n\n\nAirbnb asked this question, and they want us to write the code to insert guest activity data at a specific position in a ranking list with the insert() in Python.\n\nFollow this link for the question: https://platform.stratascratch.com/coding/10159-ranking-most-active-guests\n• Group By Guest ID and Sum Messages: Count all messages a guest sends.\n• Value Counts: Count the messages per guest ID, then sort and reset their index.\n• Rank Users: Give each user a placement carrying the messages they have sent.\n• Insert Ranking Column: To add a ranking column at the start of DataFrame, use the insert() method.\n\nThe resulting DataFrame df will show the guests ranked by their activity (number of messages), with the ranking inserted as the first column:\n\nThis showcases the insert() method's ability to precisely place elements (columns) within a DataFrame while maintaining a specific order.\n\nYou can check these python interview questions to know more about python and prepare an interview at the same time.\n\nextend() Method: Adding List Elements from Another List in Python\n\nThe extend() method adds multiple elements to the end of a list. It comes in handy when you combine two lists or insert a collection of elements into an existing list.\n\nSuppose you have the region-wise sales data for multiple products, and you have to merge these lists and analyze the consolidated list of the combined sales data.\n• Load Data: Two lists that contain data on sales region-wise.\n• Append Both Lists together: Using the extend() method, add elements from the second List into the first List.\n• Process the Combined Data: This is the stage where you may analyze the data further in-depth using other methods, such as calculating total sales or the top-selling product.\n\nHere is the code.\n\nThe output list region1_sales will now contain all elements from both lists.\n\nThis highlights how the extend() method efficiently merges two lists into one. Check this one to learn more about Python list methods.\n\nTo do that, we’ll use three different methods: remove(), pop(), and del. Let’s start with remove!\n\nremove() Method: Removing List Elements by Value in Python\n\nIn Python, the remove() method removes the first occurrence of the specified value from the list. This method is helpful when you want to delete a selected element by its value.\n\nNow, consider a scenario where you have a list of product names and must delete a discontinued product.\n• Find The Element: The name of the product to be removed.\n• Remove The Element: Remove the product from a list at the specified location using remove().\n\n\n\nThe output list will show the list after the specified product has been removed:\n\npop() method: Removing List Elements from the End in Python\n\nPop() removes and returns the final element without regard to the index.\n\nLet’s say you have a dataset consisting of customer orders. You wish to remove the last item on this list of client orders.\n• Initialize the list: This will start with the list of customers or orders.\n• Describe where it is: if not the last, tell in which position this element is.\n• Remove and Get the Element: Remove and get the element from the list, which can be done using the pop() method.\n\nThe output list customer_orders will show the list after the last order has been processed and removed, and the removed order ID will be displayed:\n\nThis demonstrates how the pop() method retrieves and removes the last element from the list.\n\nPython uses a del statement—which removes objects from a list based on their locations or whole variables.\n\nAssume you have a product list and wish to exclude specific items by indicating their indices.\n• Creating List: An initialization of the list of products needs to be made.\n• Positions: Find the products to be deleted.\n\nHere is the code.\n\n\n\nThe output list products will show the list after the specified products have been removed:\n\n\n\nThis demonstrates how the del statement deletes elements from a list by their index.\n\nBest Practices tips to prevent bugs and enhance code readability\n\nWhen working with Python, careful list handling can help to save a great deal of future trouble. Let us consider some instances, then.\n• Name Clearly: For a variable storing data, say sales_data instead of sd using a meaningful name.\n• Use List Comprehensions: List comprehensions make your code neat and simple; hence, you should always choose them if you are building a list.\n• Notes Your Code: Comments clarifying intricate processes' goals will help you grasp your code.\n• Formatting Consistently: Keep indentation and formatting consistent in your code to make it easier to read.\n• Avoid Modifying Lists in Place: Modify lists in place only when required, and be cautious, as this can create undesired side effects. Let's start a new list instead.\n\nTo summarize, add and remove the elements to the lists in Python in the best way, use append(), insert(), extend(), remove(), pop(), del insertions, and deletions in Python.\n\nFurther exploration and practice with these methods will enhance your Python programming skills. StrataScratch provides a wealth of resources and real-world problems to practice these."
    }
]