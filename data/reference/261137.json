[
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/API/Window/load_event",
        "document": "This feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015 .\n\nThe event is fired when the whole page has loaded, including all dependent resources such as stylesheets, scripts, iframes, and images, except those that are loaded lazily. This is in contrast to , which is fired as soon as the page DOM has been loaded, without waiting for resources to finish loading.\n\nThis event is not cancelable and does not bubble.\n\nNote: All events named will not propagate to , even with initialized to . To catch events on the , that event must be dispatched directly to the .\n\nNote: The event that is dispatched when the main document has loaded is dispatched on the , but has two mutated properties: is , and is . These two properties are mutated due to legacy conformance."
    },
    {
        "link": "https://stackoverflow.com/questions/559150/best-practice-for-using-window-onload",
        "document": "works, but as you might have noticed, it allows you to specify only 1 listener.\n\nI'd say the better/newer way of doing this would be to use a framework, or to just to use a simple implementation of the native and (for IE) methods, which allows you to remove the listeners for the events as well.\n\nFor the window.onload case use:\n\nEDIT I'd like to expand my answer by adding precious information that was pointed by others.\n\nThis is about the (Mozilla, Opera and webkit nightlies currently support this) and the (for IE) events which can be applied to the document object to understand when the document is available to be manipulated (without waiting for all the images/stylesheets etc.. to be loaded).\n\nThere are a lot of \"hacky\" implementations for cross-browsers support of this, so I strongly suggest to use a framework for this feature."
    },
    {
        "link": "https://stackoverflow.com/questions/49092746/js-window-onload-usage-vs-document",
        "document": "from my reading sounds like it is loosely interchangeable with but my experience has shown this is incorrect. I've inherited a JS script and I'm not sure how to correct it. I want the JS to execute once the DOM has loaded, not once all resources have been loaded. How can I do this?\n\nwhich just results in the menu not loading. I've also tried removing the line altogether from the JS and just having the DOM execute it via:\n\nthat also resulted in no menu, and in no errors in the console. My JS knowledge is limited, what am I missing here?"
    },
    {
        "link": "https://w3schools.com/jsref/event_onload.asp",
        "document": "W3Schools offers a wide range of services and products for beginners and professionals, helping millions of people everyday to learn and master new skills."
    },
    {
        "link": "https://forum.freecodecamp.org/t/window-onload-function-feasibility/70946",
        "document": "The load event fires after all assets have been loaded, including all images, stylesheets and sub frames. If your code depends on these resources, I’d say using is appropriate. In most cases though, you don’t have to wait that long: just use the event, it fires as soon as the DOM is ready (see MDN).\n\nPersonally, I like to keep the entry function small. It should give others reading your code a top down view of what your program initially does, while hiding the complex details in the functions it calls:\n\nI think it’s a good idea to put function definitions in a wrapper function, because that makes them inaccessible from outside. I’d put them at the bottom of the function to maintain readability. Registering event handlers should be ok, too, however I prefer to have a dedicated function for that.\n\nDeclaring variables, like objects, can be problematic, especially when you put all your functions in the entry function as well. Then all your code can access all data. This may seem easier at first, but when you have/want to change how your code works, you suddenly realize that you created a large web of dependencies that is difficult and super-annoying to change.\n\nIf you had to move somewhere else, how much code would you have to change?\n\n In the first variant, you’d have to change both functions and . In the latter, you only have to adjust the parameter you call with. While this is a trivial example, this only gets worse as your code becomes more complex. Modular code however, has several advantages, like higher flexibility, reusability and readability as well as easier debugging and unit testing.\n\ntl;dr: Being lazy is not always beneficial"
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Learn_web_development/Core/Scripting/DOM_scripting",
        "document": "When writing web pages and apps, one of the most common things you'll want to do is change the document structure in some way. This is usually done by manipulating the Document Object Model (DOM) via a set of built-in browser APIs for controlling HTML and styling information. In this article we'll introduce you to DOM scripting. An understanding of HTML and the fundamentals of CSS, familiarity with JavaScript basics as covered in previous lessons.\n• What the DOM is — the browser's internal representation of the document's HTML structure as a hierarchy of objects.\n• The important parts of a web browser as represented in JavaScript — , , and .\n• How DOM nodes exist relative to each other in the DOM tree — root, parent, child, sibling, and descendant.\n• Getting references to DOM nodes, creating new nodes, adding and removing nodes and attributes.\n\nWeb browsers are very complicated pieces of software with a lot of moving parts, many of which can't be controlled or manipulated by a web developer using JavaScript. You might think that such limitations are a bad thing, but browsers are locked down for good reasons, mostly centering around security. Imagine if a website could get access to your stored passwords or other sensitive information, and log into websites as if it were you? Despite the limitations, Web APIs still give us access to a lot of functionality that enable us to do a great many things with web pages. There are a few really obvious bits you'll reference regularly in your code — consider the following diagram, which represents the main parts of a browser directly involved in viewing web pages:\n• The window is the browser tab that a web page is loaded into; this is represented in JavaScript by the object. Using methods available on this object you can do things like return the window's size (see and ), manipulate the document loaded into that window, store data specific to that document on the client-side (for example using a local database or other storage mechanism), attach an event handler to the current window, and more.\n• The navigator represents the state and identity of the browser (i.e. the user-agent) as it exists on the web. In JavaScript, this is represented by the object. You can use this object to retrieve things like the user's preferred language, a media stream from the user's webcam, etc.\n• The document (represented by the DOM in browsers) is the actual page loaded into the window, and is represented in JavaScript by the object. You can use this object to return and manipulate information on the HTML and CSS that comprises the document, for example get a reference to an element in the DOM, change its text content, apply new styles to it, create new elements and add them to the current element as children, or even delete it altogether. In this article we'll focus mostly on manipulating the document, but we'll show a few other useful bits besides.\n\nLet's provide a brief recap on the Document Object Model (DOM), which we also looked at earlier in the course. The document currently loaded in each one of your browser tabs is represented by a DOM. This is a \"tree structure\" representation created by the browser that enables the HTML structure to be easily accessed by programming languages — for example the browser itself uses it to apply styling and other information to the correct elements as it renders a page, and developers like you can manipulate the DOM with JavaScript after the page has been rendered. We have created an example page at dom-example.html (see it live also). Try opening this up in your browser — it is a very simple page containing a element inside which you can find an image, and a paragraph with a link inside. The HTML source code looks like this: <!doctype html> <html lang=\"en-US\"> <head> <meta charset=\"utf-8\" /> <title>Simple DOM example</title> </head> <body> <section> <img src=\"dinosaur.png\" alt=\"A red Tyrannosaurus Rex: A two legged dinosaur standing upright like a human, with small arms, and a large head with lots of sharp teeth.\" /> <p> Here we will add a link to the <a href=\"https://www.mozilla.org/\">Mozilla homepage</a> </p> </section> </body> </html> The DOM on the other hand looks like this: Note: This DOM tree diagram was created using Ian Hickson's Live DOM viewer. Each entry in the tree is called a node. You can see in the diagram above that some nodes represent elements (identified as , , and so on) and others represent text (identified as ). There are other types of nodes as well, but these are the main ones you'll encounter. Nodes are also referred to by their position in the tree relative to other nodes:\n• Root node: The top node in the tree, which in the case of HTML is always the node (other markup vocabularies like SVG and custom XML will have different root elements).\n• Child node: A node directly inside another node. For example, is a child of in the above example.\n• Descendant node: A node anywhere inside another node. For example, is a child of in the above example, and it is also a descendant. is not a child of , as it is two levels below it in the tree, but it is a descendant of .\n• Parent node: A node which has another node inside it. For example, is the parent node of in the above example.\n• Sibling nodes: Nodes that sit on the same level under the same parent node in the DOM tree. For example, and are siblings in the above example. It is useful to familiarize yourself with this terminology before working with the DOM, as a number of the code terms you'll come across make use of them. You'll also come across them in CSS (e.g. descendant selector, child selector).\n\nTo start learning about DOM manipulation, let's begin with a practical example.\n• Take a local copy of the dom-example.html page and the image that goes along with it.\n• Add a element just above the closing tag.\n• To manipulate an element inside the DOM, you first need to select it and store a reference to it inside a variable. Inside your script element, add the following line:\n• Now we have the element reference stored in a variable, we can start to manipulate it using properties and methods available to it (these are defined on interfaces like in the case of element, its more general parent interface , and — which represents all nodes in a DOM). First of all, let's change the text inside the link by updating the value of the property. Add the following line below the previous one:\n• We should also change the URL the link is pointing to, so that it doesn't go to the wrong place when it is clicked on. Add the following line, again at the bottom: Note that, as with many things in JavaScript, there are many ways to select an element and store a reference to it in a variable. is the recommended modern approach. It is convenient because it allows you to select elements using CSS selectors. The above call will match the first element that appears in the document. If you wanted to match and do things to multiple elements, you could use , which matches every element in the document that matches the selector, and stores references to them in an array-like object called a . There are older methods available for grabbing element references, such as:\n• , which selects an element with a given attribute value, e.g. . The ID is passed to the function as a parameter, i.e. .\n• , which returns an array-like object containing all the elements on the page of a given type, for example s, s, etc. The element type is passed to the function as a parameter, i.e. . These two work better in older browsers than the modern methods like , but are not as convenient. Have a look and see what others you can find!\n\nThe above has given you a little taste of what you can do, but let's go further and look at how we can create new elements.\n• Going back to the current example, let's start by grabbing a reference to our element — add the following code at the bottom of your existing script (do the same with the other lines too):\n• Now let's create a new paragraph using and give it some text content in the same way as before: const para = document.createElement(\"p\"); para.textContent = \"We hope you enjoyed the ride.\";\n• You can now append the new paragraph at the end of the section using :\n• Finally for this part, let's add a text node to the paragraph the link sits inside, to round off the sentence nicely. First we will create the text node using :\n• Now we'll grab a reference to the paragraph the link is inside, and append the text node to it: That's most of what you need for adding nodes to the DOM — you'll make a lot of use of these methods when building dynamic interfaces (we'll look at some examples later).\n\nThere may be times when you want to move nodes, or delete them from the DOM altogether. This is perfectly possible. If we wanted to move the paragraph with the link inside it to the bottom of the section, we could do this: This moves the paragraph down to the bottom of the section. You might have thought it would make a second copy of it, but this is not the case — is a reference to the one and only copy of that paragraph. If you wanted to make a copy and add that as well, you'd need to use instead. Removing a node is pretty simple as well, at least when you have a reference to the node to be removed and its parent. In our current case, we just use , like this: When you want to remove a node based only on a reference to itself, which is fairly common, you can use : This method is not supported in older browsers. They have no method to tell a node to remove itself, so you'd have to do the following: Have a go at adding the above lines to your code.\n\nIt is possible to manipulate CSS styles via JavaScript in a variety of ways. To start with, you can get a list of all the stylesheets attached to a document using , which returns an array-like object with objects. You can then add/remove styles as wished. However, we're not going to expand on those features because they are a somewhat archaic and difficult way to manipulate style. There are much easier ways. The first way is to add inline styles directly onto elements you want to dynamically style. This is done with the property, which contains inline styling information for each element in the document. You can set properties of this object to directly update element styles.\n• As an example, try adding these lines to our ongoing example:\n• Reload the page and you'll see that the styles have been applied to the paragraph. If you look at that paragraph in your browser's Page Inspector/DOM inspector, you'll see that these lines are indeed adding inline styles to the document: <p style=\"color: white; background-color: black; padding: 10px; width: 250px; text-align: center;\"> We hope you enjoyed the ride. </p> Note: Notice how the JavaScript property versions of the CSS styles are written in lower camel case whereas the CSS versions are hyphenated (kebab-case) (e.g. versus ). Make sure you don't get these mixed up, otherwise it won't work. There is another common way to dynamically manipulate styles on your document, which we'll look at now.\n• Delete the previous five lines you added to the JavaScript.\n• Add the following inside your HTML :\n• Now we'll turn to a very useful method for general HTML manipulation — — this takes two arguments, the attribute you want to set on the element, and the value you want to set it to. In this case we will set a class name of highlight on our paragraph:\n• Refresh your page, and you'll see no change — the CSS is still applied to the paragraph, but this time by giving it a class that is selected by our CSS rule, not as inline CSS styles. Which method you choose is up to you; both have their advantages and disadvantages. The first method takes less setup and is good for simple uses, whereas the second method is more purist (no mixing CSS and JavaScript, no inline styles, which are seen as a bad practice). As you start building larger and more involved apps, you will probably start using the second method more, but it is really up to you. At this point, we haven't really done anything useful! There is no point using JavaScript to create static content — you might as well just write it into your HTML and not use JavaScript. It is more complex than HTML, and creating your content with JavaScript also has other issues attached to it (such as not being readable by search engines). In the next section we will look at a more practical use of DOM APIs. Note: You can find our finished version of the dom-example.html demo on GitHub (see it live also)."
    },
    {
        "link": "https://w3schools.com/js/js_dom_examples.asp",
        "document": "W3Schools offers a wide range of services and products for beginners and professionals, helping millions of people everyday to learn and master new skills."
    },
    {
        "link": "https://medium.com/@kaklotarrahul79/step-by-step-guide-to-javascript-dom-manipulation-55b334c0c26b",
        "document": "The Document Object Model (DOM) is a representation of a web page that allows JavaScript to interact with and modify HTML elements dynamically. In this guide, we’ll go step by step to understand how to access, modify, and handle events using the DOM.\n\nWhen a webpage loads, the browser converts the HTML into a DOM tree. Every element in the HTML document becomes a node in this tree, which JavaScript can access and manipulate.\n\nJavaScript provides several methods to select and manipulate elements."
    },
    {
        "link": "https://w3schools.com/js/js_htmldom.asp",
        "document": "W3Schools offers a wide range of services and products for beginners and professionals, helping millions of people everyday to learn and master new skills."
    },
    {
        "link": "https://medium.com/nerd-for-tech/manipulating-the-dom-with-html-javascript-and-css-part-1-25b34ae2f932",
        "document": "Note: This blog has an accompanying video available at my YouTube channel here: . If you are more of an audio and visual learner, or if you just want to see the code as it is written, check it out here. Thanks!\n\nThe main purpose of front end web development is being able to style, control, and manipulate what we see on our device screens. In other words, being able to manipulate the Document Object Model, or DOM. The DOM refers to a programming interface for HTML and XML documents, representing a document as nodes and objects so that programming languages can connect to the page.\n\nPerhaps put more simply, a Web page is a document, so when we refer to Document Object Model, we are just referring to an interface that allows us to manipulate this document with CSS, JavaScript, or whatever scripting language you choose. We will be using JavaScript to interact with and manipulate the DOM with built in methods like querySelector, getElementById, and createElement. But before we get in to manipulating the DOM, let’s set up a basic Web page with HTML so we have something to work with. Today we will be building a single page application that makes an editable ToDo list using only JavaScript, HTML, and CSS.\n\nThe base of any web page is in the HTML or hypertext markup language. This is what will build out the structure of our web page, including its elements, links to scripting languages and styles, and more. Understanding the different elements involved in an HTML document is important to the basics of web development, so create our HTML page and break down its contents.\n\nVisual Studio has features built in that make it quick and easy to generate a boiler plate HTML document. Create a new file called index.html and inside the file on the first line, type an ‘!’. You will notice VS shows a dropdown, and if we hit enter, it will select the first option and automatically fill in the HTML file for us.\n\nI want to briefly discuss some of the tags within an HTML document, what they mean, and what they are used for. If you are already familiar with the basics of HTML, feel free to skip this section. If you are not, I recommend reading this to get a solid base of knowledge. We will use the default template HTML as an example:\n\nAs we can guess, the first line indicates the type of document here will be an HTML, hence DOCTYPE. Then we have our actual <html></html> tags. These enclose the entire HTML document. Next we have the head tag where we will keep any metadata, or data about the the HTML, it is not displayed. Notice the meta tags. The first sets the charset or set of characters to use. The next scales the viewport to equate to the device it is displaying on, then the title, which we can change later if we want.\n\nWe’re going to create some make a few adjustments to the HTML and add a few tags to achieve our desired goal, which is of courses to make a ToDo application. We will add a script, label, input, button, div, and unordered lists tags, as seen below:\n\nThe script tag is used to reference JavaScript. JavaScript can be written directly in the script tag, but here we are linking an external script file. Here the ‘async’ keyword allows the JavaScript to load asynchronously, or in other words while the HTML is loading. This means that the HTML page itself will display before the JavaScript has finished executing. In this SPA, we certainly want this so we can display the outline of our page whether the script has loaded or not(in such a small app like this there will almost certainly be no difference, but it is good practice to add async). Learn more about the async keyword here.\n\nNotice the unordered list of things to do is currently empty, that is because we are going to use DOM manipulation to add our todo items! If we want to see what our application looks like so far, we can go to the terminal and type:\n\nYour HTML page will be displayed in your default browser, but for the sake of this tutorial you should be using Google Chrome. So far, this is what our application looks like\n\nNext we will create the logic that manipulates the DOM and gives our application functionality. Create a file called index.js. Inside this file, we will start by writing some code that will allow us to interact with our HTML. WE can use a built in method called querySelector to reference HTML elements and assign them values in our JavaScript file. We call this on the document object, and pass an argument of a class or id select, determined by a ‘.’ or ‘#’ respectively. Example:\n\nIf we go back to the browser where the HTML is displayed, right click on the page and select ‘inspect’. You will see a side panel pop up with the Elements tab selected. This is Chrome’s Developer Tools, and this is a very useful tool that you will likely use the rest of your developing career. For now, we will focus on the console, so switch tabs from Elements to Console. Click on the ‘Add’ button and note the message in the console.\n\nThis confirms that our button we define in the HTML is linked directly to the JavaScript variable button. Congratulations, we’ve connected to the DOM! This is a great start, but now we will actually do something with this event listener, as well as create a list of todo items. First, we can created a list of todo items to start with by creating an array of strings. We will then iterate or ‘map’ over that array with JavaScript’s built in .map() method to display each one in our unordered list tag from before. In practice, the index.js file should look this:\n\nRefreshing your browser page will now show the list we have created.\n\nNow to enable our input we will set a variable equal to the selected input tag, just as with the other elements. We will also use very similar logic to that in our thingsToDo.map() function by creating a new element, setting the innerText, and appending to the list element.\n\nThe above logic allows us to take the value from our input box and add it to the list of to do items! Note that since we are only adding these items to the DOM element ‘list’ and, and not to our ‘thingsToDo’ array, the new ToDo items will disappear when we refresh the page. Since the JavaScript is loaded every time we refresh the page, the ‘thingsToDo’ array will always reset itself to the hardcoded list. In future blogs I will discuss persisting data, but that is out of the scope of this blog and application.\n\nThere is one more major function that we can include in our application which is deleting a ToDo item once it has been completed. This will be the most tricky action we will perform in this project so I will cover it in depth and as clearly as possible.\n\nBefore we write any code, let’s think logically about how we can complete this. We need a way to select and individual item and choose to delete it, and the easiest way to do this is to add a ‘delete’ button to each ToDo item. In the same way we created our li or ‘list item’ element, we can create a ‘button’ element and append it to the page for each index of our thingsToDo list. By appending the new ‘button’ element we create to the ‘list item’ element, we will have a button that corresponds to each To Do item!\n\nAdding functionality to the button is the tricky part. We will add an eventListener to the delete button that listens for the ‘click’ event, and when it is clicked it calls the built in JavaScript remove() method on the new ToDo item. The remove method simply removes the object from the DOM, allowing us to delete our unwanted To Do Item. All together our code will look like this:\n\nBut something is not quite right with the functionality? If you add a new To Do item, you will notice there is not delete button and therefore no way to delete it. We could fix this by repeating the same logic we did inside the thingsToDo.map() function, but that would not be very DRY. One of the key concepts of programming is making sure you DRY, or Don’t Repeat Yourself. Additionally one of the key concepts of Object Oriented Programming is Abstraction, an example of which would be creating a function for some logic that repeats itself. For more information on OOP, check out one of my previous blogs on The Basics of Object Oriented Programming.\n\nSo to achieve this DRY code, we will take as much of the logic we can that will need to be repeated, and create a separate function for it. Thinking about our code logically, we can tell that in both adding a To Do item and in creating our initial list, we perform a lot of the same logic. This includes, creating an element, setting its text, and adding a delete button with functionality. What if we abstracted all that logic into its own function? We know for each situation, creating our initial list based on the hard coded array, and adding a new To Do item, we work with the same data which is simply a string. By writing a function that takes that new string, we can implement that function both at the load of our application and when we want to add a new To Do item, and only have to write the logic once!\n\nNow we have a fully functioning To Do list, where we can add and delete items! Although it works great, it is not very pretty. In my next blog I will discuss adding some simple CSS to greatly enhance the User Interface or UI of this app, and really bring it to life."
    }
]