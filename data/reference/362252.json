[
    {
        "link": "https://create.roblox.com/docs/characters/pathfinding",
        "document": "Pathfinding is the process of moving a character along a logical path to reach a destination, avoiding obstacles and (optionally) hazardous materials or defined regions.\n\nTo assist with pathfinding layout and debugging, Studio can render a navigation mesh and modifier labels. To enable them, toggle on Navigation mesh and Pathfinding modifiers from the Visualization Options widget in the upper‑right corner of the 3D viewport.\n\nWith Navigation mesh enabled, colored areas show where a character might walk or swim, while non-colored areas are blocked. The small arrows indicate areas that a character will attempt to reach by jumping, assuming you set AgentCanJump to true when creating the path.\n\nWith Pathfinding modifiers enabled, text labels indicate specific materials and regions that are taken into consideration when using pathfinding modifiers.\n\nPathfinding calculations consider only parts within certain vertical boundaries:\n• None Lower Boundary — Parts with a bottom coordinate less than -65,536 studs are ignored.\n• None Upper Boundary — Parts with a top coordinate exceeding 65,536 studs are ignored.\n• None Vertical Span — The vertical distance from the lowest part's bottom coordinate to the highest part's top coordinate must not exceed 65,536 studs; otherwise, the pathfinding system will ignore those parts during the pathfinding computation.\n\nThe direct line-of-sight distance for pathfinding from the start to the finish point must not exceed 3,000 studs. Exceeding this distance will result in a NoPath status.\n\nPathfinding is initiated through PathfindingService and its CreatePath() function.\n\nCreatePath() accepts an optional table of parameters which fine tune how the character (agent) moves along the path.\n\nNote that the agent can climb TrussParts during pathfinding assuming you set AgentCanClimb to true when creating the path and nothing blocks the agent from the truss climbing path. A climbable path has the Climb label and the cost for a climbable path is 1 by default.\n\nThis section uses the following pathfinding script for the player's character. To test while reading:\n• None variable to a destination in your 3D world that the player character can reach. Set thevariable to adestination in your 3D world that the player character can reach.\n• None Proceed through the following sections to learn about path computation and character movement.\n\nAfter you've created a valid path with CreatePath(), it must be computed by calling Path:ComputeAsync() with a Vector3 for both the starting point and destination.\n\nOnce the Path is computed, it will contain a series of waypoints that trace the path from start to end. These points can be gathered with the Path:GetWaypoints() function.\n\nEach waypoint consists of both a position (Vector3) and action (PathWaypointAction). To move a character containing a Humanoid, like a typical Roblox character, the easiest way is to call Humanoid:MoveTo() from waypoint to waypoint, using the MoveToFinished event to detect when the character reaches each waypoint.\n\nMany Roblox worlds are dynamic; parts might move or fall and floors may collapse. This can block a computed path and prevent the character from reaching its destination. To handle this, you can connect the Path.Blocked event and re-compute the path around whatever blocked it.\n\nBy default, Path:ComputeAsync() returns the shortest path between the starting point and destination, with the exception that it attempts to avoid jumps. This looks unnatural in some situations — for instance, a path may go through water rather than over a nearby bridge simply because the path through water is geometrically shorter.\n\nTo optimize pathfinding even further, you can implement pathfinding modifiers to compute smarter paths across various materials, around defined regions, or through obstacles.\n\nWhen working with Terrain and BasePart materials, you can include a Costs table within CreatePath() to make certain materials more traversable than others. All materials have a default cost of 1 and any material can be defined as non-traversable by setting its value to math.huge.\n\nKeys in the Costs table should be string names representing Enum.Material names, for example Water for Enum.Material.Water.\n\nIn some cases, material preference is not enough. For example, you might want characters to avoid a defined region, regardless of the materials underfoot. This can be achieved by adding a PathfindingModifier object to a part.\n• None Create an Anchored part around the dangerous region and set its CanCollide property to false.\n• None Insert a PathfindingModifier instance onto the part, locate its Label property, and assign a meaningful name like DangerZone.\n• None Include a Costs table within CreatePath() containing a matching key and associated numeric value. A modifier can be defined as non-traversable by setting its value to math.huge.\n\nIn some cases, it's useful to pathfind through solid obstacles as if they didn't exist. This lets you compute a path through specific physical blockers, versus the computation failing outright.\n• None Create an Anchored part around the object and set its CanCollide property to false.\n• None Insert a PathfindingModifier instance onto the part and enable its PassThrough property. Now, when a path is computed from the zombie NPC to the player character, the path extends beyond the door and you can prompt the zombie to traverse it. Even if the zombie is unable to open the door, it reacts as if it \"hears\" the character behind the door.\n\nSometimes it's necessary to find a path across a space that cannot be normally traversed, such as across a chasm, and perform a custom action to reach the next waypoint. This can be achieved through the PathfindingLink object.\n\nUsing the island example from above, you can make the agent use a boat instead of walking across all of the bridges.\n\nTo create a PathfindingLink using this example:\n• None To assist with visualization and debugging, toggle on from the To assist with visualization and debugging, toggle onfrom the widget in the upper‑right corner of the 3D viewport.\n• None Create two Attachments, one on the boat's seat and one near the boat's landing point.\n• None Create a PathfindingLink object in the workspace, then assign its Attachment0 and Attachment1 properties to the starting and ending attachments respectively.\n• None Assign a meaningful name like UseBoat to its Label property. This name is used as a flag in the pathfinding script to trigger a custom action when the agent reaches the starting link point.\n• None Include a Costs table within CreatePath() containing both a Water key and a custom key matching the Label property name. Assign the custom key a lower value than Water.\n• None In the event which fires when a waypoint is reached, add a custom check for the Label modifier name and take a different action than Humanoid:MoveTo() — in this case, calling a function to seat the agent in the boat, move the boat across the water, and continue the agent's path upon arrival at the destination island. -- Check if the obstacle is further down the path -- Detect when movement to next waypoint is complete -- Increase waypoint index and move to next waypoint -- Use boat if waypoint label is \"UseBoat\"; otherwise move to next waypoint -- Initially move to second waypoint (first waypoint is path start; skip it) -- Stop boat when next to island\n\nIn-experience instance streaming is a powerful feature that dynamically loads and unloads 3D content as a player's character moves around the world. As they explore the 3D space, new subsets of the space stream to their device and some of the existing subsets might stream out.\n\nConsider the following best practices for using PathfindingService in streaming-enabled experiences:\n• None Streaming can block or unblock a given path as a character moves along it. For example, while a character runs through a forest, a tree might stream in somewhere ahead of them and obstruct the path. To make pathfinding work seamlessly with streaming, it's highly recommended that you use the handling blocked paths technique and re-compute the path when necessary.\n• None A common approach in pathfinding is to use the coordinates of existing objects for computation, such as setting a path destination to the position of an existing TreasureChest model in the world. This approach is fully compatible with server-side Scripts since the server has full view of the world at all times, but LocalScripts and ModuleScripts that run on the client may fail if they attempt to compute a path to an object that's not streamed in. To address this issue, consider setting the destination to the position of a BasePart within a persistent model. Persistent models load soon after the player joins and they never stream out, so a client-side script can connect to the PersistentLoaded event and safely access the model for creating waypoints after the event fires."
    },
    {
        "link": "https://create.roblox.com/docs/reference/engine/classes/PathfindingService",
        "document": "-- This model contains a start, end and three paths between the player can walk on: Snow, Metal and LeafyGrass\n\n-- This will ensure the path created avoids the Snow and Metal paths and guides\n\n-- the user towards the LeafyGrass path\n\n-- For each waypoint, create a part to visualize the path"
    },
    {
        "link": "https://devforum.roblox.com/t/how-to-use-roblox-pathfinding-service-20/1857779",
        "document": "Ladies and gentlemen welcome back to another Roblox scripting tutorial where in today’s tutorial we are going to talk about how you can use Pathfinding service in Roblox!\n\nLet’s see where we left off last time…\n\nIt’s been more than a year since this topic was mentioned on here…\n\nWell, it’s been a year since I said that and everyone was wondering where is it…\n\nWell here it is! I was just being a lazy couch potato and can’t think of new ideas on how to make this more interesting, until some new additions to the pathfinding service, such as the new Pathfinding Modifiers.\n\nSo buckle your seatbelts up everyone. because today we are going to learn:\n• Explaining why my old tutorial about Pathfinding Service is bad\n\nIf this is your first time learning Pathfinding service, you can still read this tutorial as I’ve planned this tutorial to rework on the old one since the old script from the old tutorial is inefficient and buggy… heh. Without any further ado, let’s get rolling!\n\nThis section will cover the nitty-gritty of utilising to its maximum. At the end of this section, you will be able to script a humanoid that can walk to a certain position and smartly create a new path to the position again if it is blocked by another part when traversing through the path.\n• Get a working R6 or R15 dummy model in your game. You can do this by using the Rig Builder plugin provided by Roblox Studio default. im gonna use r15 in this case\n• Most important step, unanchor every single BaseParts in the dummy model. This is to ensure that the model can walk without any anchored parts connecting it to prevent it from walking. You can simply click the model in the explorer tab and unanchor the model.\n• Insert a server script in the model and declare a few variables such as referring Pathfinding service itself, the model, humanoid instance and HumanoidRootPart.\n• Now, we will use function. As its name suggests, it basically creates a instance which we are going to use. Don’t mind the argument in the function. We will cover that later. We are also going to define some constants which is useful for our functions soon. We will also declare a variable named which will be useful soon.\n• Create a function named . This function will be the brain of the operation of this whole thing. Add two parameters, and (determines whether or not to yield the script until the humanoid has reached the destination.) After creating the function, call it with the respective arguments. I have created a base part named under workspace.\n• Now let’s dive into the main part! To create or compute the path between two points, we have to use on the instance we have created through . The first argument of the function is the starting point (I use the root part’s Position) and the second argument is an ending point (targetPosition parameter), both in terms of . This function makes network calls, in other words, this function can fail from time to time due to network errors (or just backend issues that you can’t control), so in order to counter this, we will use along with a retry system. If the function has retried a lot of times and it still fails, then we will not do anything but warn the error message in the output. local function walkTo(targetPosition, yieldable) local RETRY_NUM = 0 local success, errorMessage repeat RETRY_NUM += 1 -- add one retry success, errorMessage = pcall(path.ComputeAsync, path, humanoidRootPart.Position, targetPosition) if not success then -- if it fails, warn the message warn(\"Pathfind compute path error: \"..errorMessage) task.wait(RETRY_COOLDOWN) end until success == true or RETRY_NUM > MAX_RETRIES if success then -- if computing the path has no issues else -- if retry chance is maxed out warn(\"Pathfind compute retry maxed out, error: \"..errorMessage) return end end Notice that I did not use the function like so: This is because it creates another function to do another function, which is unnecessary work. So I just typed out like that to save some spaces. Also notice that I did not use when indexing the . is not suitable to be used here so we use , and then the second argument of that is the instance itself because\n• If the function was successfully called with no issues, then we must check if the function was able to find a path between the two points. If it can compute a path, then will be . Hence, we can get the path’s waypoints, a table consisting of all points the humanoid must traverse through to get to the end goal, and cycle through each waypoint. We will create a variable which tells the humanoid to move to the corresponding waypoints. We will then use to tell the humanoid to walk to that waypoint’s position, which can be accessed by getting the waypoint’s position property shown in the code below. If the waypoint requires the humanoid to jump, we will set to true. if success then if path.Status == Enum.PathStatus.Success then local waypoints = path:GetWaypoints() local currentWaypointIndex = 2 -- not 1, because 1 is the waypoint of the starting position. humanoid:MoveTo(waypoints[currentWaypointIndex].Position) -- move to the nth waypoint if waypoints[currentWaypointIndex].Action == Enum.PathWaypointAction.Jump then -- if it requires the humanoid to jump humanoid.Jump = true end else -- if the path can't be computed between two points, do nothing! return end else -- this only runs IF the function has problems computing the path in its backend, NOT if a path can't be created between two points. warn(\"Pathfind compute retry maxed out, error: \"..errorMessage) return end\n• Awesome! But we only told the humanoid to move one waypoint, so how do we cycle through the whole waypoints? If you think of using , you are right! BUT, for loops are not suitable in this case. I will tell you why later. Instead, we will use an event called . This basically gets fired every time the humanoid has reached a position called by . In this case, this event gets fired every time it has reached a waypoint. When the event fires, we want to check if it has reached the waypoint in time (8 seconds) and has yet to reach the end goal, then we will tell the humanoid to move to the next waypoint. if path.Status == Enum.PathStatus.Success then local waypoints = path:GetWaypoints() local currentWaypointIndex = 2 if not reachedConnection then reachedConnection = humanoid.MoveToFinished:Connect(function(reached) if reached and currentWaypointIndex < #waypoints then currentWaypointIndex += 1 humanoid:MoveTo(waypoints[currentWaypointIndex].Position) if waypoints[currentWaypointIndex].Action == Enum.PathWaypointAction.Jump then humanoid.Jump = true end end end) end humanoid:MoveTo(waypoints[currentWaypointIndex].Position) if waypoints[currentWaypointIndex].Action == Enum.PathWaypointAction.Jump then humanoid.Jump = true end else return And we are done! For now. If your script has no issues and run the game, your humanoid would start walking to its assigned end goal. Works smoothly, but there are some issues you have probably noticed besides the video if you pay attention closely. Firstly in the video, the humanoid model walks to the end goal without playing any idle or running animation. This is because we don’t have a script that handles the animation of the script. To solve this issue, we can script a- “WE DO NOT WANT TO SCRIPT A STUPID ANIMATION SCRIPT” Okay, that’s fine! We have another method which is as shortcut. What we can do is we can “steal” the animation script inside of our character’s player model. All you need to do is run the game with your character, find your character model in Workspace, find a script called Animate, copy it, stop the game and paste it in workspace. You should notice there are also other things parented underneath it, all you need to do is delete the named , and then transfer the whole script into a server script since local scripts don’t work and you are done. Sure, I have uploaded the scripts required to handle the animations. All you need to do is just select the script according to your rig type, place it under your humanoid model and let it do all the magic. Onto the next issue, notice that our connection variable never disconnects. This can cause unnecessary memory leaks when something is no longer needed. Memory leaks can cause your game to use up more memory which is unnecessary and jamming up the performance. So what do we do? That’s right! We have to disconnect the event when the path has been cycled. To do this, we can add an statement inside the connected function where we tell the script to disconnect the event. reachedConnection = humanoid.MoveToFinished:Connect(function(reached) if reached and currentWaypointIndex < #waypoints then currentWaypointIndex += 1 humanoid:MoveTo(waypoints[currentWaypointIndex].Position) if waypoints[currentWaypointIndex].Action == Enum.PathWaypointAction.Jump then humanoid.Jump = true end else reachedConnection:Disconnect() reachedConnection = nil -- you need to manually set this to nil! because calling disconnect function does not make the variable to be nil. end end) Memory leaks is a wide and challenging topic to understand and overcome (at least for me), if you are interested in learning more, you can check out this awesome tutorial. Furthermore, you will notice that our dummy model is unable to handle paths that are blocked, as shown in the video below:\n\n This might not be an issue if your NPC is only moving from one location to another location for only one time and the path is inaccessible by other things, but, for the sake of this tutorial, we will combat all normal and common kinds of issues you have to deal with in . So how do we approach to this issue? Luckily, there’s an event called for every object created through the service. This event, you guessed it, basically fires every time the path is being blocked by a physical part, so all we can do is, every time this event gets fired, we will tell the bot to stop cycling through its currently assigned path, compute a new one with the same arguments, and then cycle that newly created path. But here’s the problem, the event does not know whether the waypoint of the path being blocked has been cycled through by the bot. Thankfully, the connected function of the event provides an argument we can use, that states the number of waypoint that is currently being blocked. For example, if there is a part blocking between the 5th and 6th waypoint, the event will fire and give the number 6 as the argument in the connected function. To take advantage of this, we can check whether the current waypoint index is smaller than this number, and if it is, we will tell the bot to stop cycling through the current path and follow the newly computed one. Otherwise, we will do nothing as that waypoint has been cycled through.\n• Create a new variable called under the variable .\n• In the function right after setting up the connection, set to the event and connect it to a function. Make sure you create a parameter that represents the blocked waypoint index. Go ahead and set up the function with the applied description of it I just have just given. pathBlockedConnection = path.Blocked:Connect(function(waypointNumber) if waypointNumber > currentWaypointIndex then -- blocked path is ahead of the bot reachedConnection:Disconnect() -- disconnect these events to prevent memory leaks pathBlockedConnection:Disconnect() reachedConnection = nil pathBlockedConnection = nil walkTo(workspace.EndGoal.Position, true) -- compute and cycle new path end end) Since also contains an event like how has as well, you have to disconnect it and set it to nil when it is no longer used, so apply this logic also when is unnecessary. if reached and currentWaypointIndex < #waypoints then currentWaypointIndex += 1 humanoid:MoveTo(waypoints[currentWaypointIndex].Position) if waypoints[currentWaypointIndex].Action == Enum.PathWaypointAction.Jump then humanoid.Jump = true end else reachedConnection:Disconnect() pathBlockedConnection:Disconnect() reachedConnection = nil pathBlockedConnection = nil end Give it a test and it should be working!\n\n One thing that I have totally forgotten is the parameter in our function. We are going to need to implement a function for that.\n• At the top of the script where the constant variables lives, creating a new constant variable named , this will contain a boolean value that tells us if the function will yield. This must be in the main scope of the script and not the local scope as re-computations of new paths when the old path is blocked needs to refer it.\n• In the main function after the two setups of the connections, we will use a loop to yield the main thread when the function needs to yield, until becomes true. humanoid:MoveTo(waypoints[currentWaypointIndex].Position) if waypoints[currentWaypointIndex].Action == Enum.PathWaypointAction.Jump then humanoid.Jump = true end if yieldable then YIELDING = true repeat task.wait() until YIELDING == false end else\n• We have to set to false at some part in our script so that it can stop yielding and move onto the next parts of the script, so we have to do that when the path has been fully cycled through. And that’s actually it for the basic usage of service. Here’s the full code. -- SERVICES -- local PathfindingService = game:GetService(\"PathfindingService\") -- CONSTANTS -- local MAX_RETRIES = 5 local RETRY_COOLDOWN = 5 local YIELDING = false local model = script.Parent local humanoid = model.Humanoid local humanoidRootPart = model.HumanoidRootPart local path = PathfindingService:CreatePath() local reachedConnection local pathBlockedConnection local function walkTo(targetPosition, yieldable) local RETRY_NUM = 0 local success, errorMessage repeat RETRY_NUM += 1 success, errorMessage = pcall(path.ComputeAsync, path, humanoidRootPart.Position, targetPosition) if not success then warn(\"Pathfind compute path error: \"..errorMessage) task.wait(RETRY_COOLDOWN) end until success == true or RETRY_NUM > MAX_RETRIES if success then if path.Status == Enum.PathStatus.Success then local waypoints = path:GetWaypoints() local currentWaypointIndex = 2 if not reachedConnection then reachedConnection = humanoid.MoveToFinished:Connect(function(reached) if reached and currentWaypointIndex < #waypoints then currentWaypointIndex += 1 humanoid:MoveTo(waypoints[currentWaypointIndex].Position) if waypoints[currentWaypointIndex].Action == Enum.PathWaypointAction.Jump then humanoid.Jump = true end else reachedConnection:Disconnect() pathBlockedConnection:Disconnect() reachedConnection = nil pathBlockedConnection = nil YIELDING = false end end) end pathBlockedConnection = path.Blocked:Connect(function(waypointNumber) if waypointNumber > currentWaypointIndex then reachedConnection:Disconnect() pathBlockedConnection:Disconnect() reachedConnection = nil pathBlockedConnection = nil walkTo(workspace.EndGoal.Position, true) end end) humanoid:MoveTo(waypoints[currentWaypointIndex].Position) if waypoints[currentWaypointIndex].Action == Enum.PathWaypointAction.Jump then humanoid.Jump = true end if yieldable then YIELDING = true repeat task.wait() until YIELDING == false end else return end else warn(\"Pathfind compute retry maxed out, error: \"..errorMessage) return end end walkTo(workspace.EndGoal.Position, true)\n\nThrough , we are also exposed to some features that allow us to customize our path to make it look more “smarter”. At its most basic form, service only computes a path with the shortest distance as much as possible. It ignores whether or not if the path that is computed is suited for your expectations and preferences. If we were to use our script and make our character model to walk to the red part, it would walk in a straight line like so.\n\n But what if we wanted our character to move along the blue lines?\n\n This is where s come in! They are modifiers that allows to compute paths that suits our preferences. Not only that, we can also adjust some other properties that affects the final path as well. To understand what they are, meet the dictionary. If you look at the developer hub, you’ll find information about it, but I will explain all of its properties simply here:\n• AgentRadius key determines the radius of our character. This is useful if we want to keep up a minimum separation distance between our character and its surrounding obstacles. Default value is 2, which is the default radius value of all rigs in Roblox. Anything higher than the default value will make the character have a minimum separation distance between obstacles with this formula:\n• AgentHeight key is self explanatory. The default value of 5 is the default height for all rigs in Roblox.\n• AgentCanJump key is also self explanatory. Determines whether or not our character can jump. Default value is true.\n• AgentCanClimb key determines whether or not the humanoid can climb (only using Roblox’s truss part, you have to program your own climbing logic and use if you are not using the truss part!) . Default value is false.\n• WaypointSpacing key determines the minimum amount of spacing between waypoints in a straight line(waypoints around a corner does not count). Default value is 4. If set to , it will create the least amount of waypoints whilst still providing the shortest path as much as possible. NOTE that changing this value does not respect the parameter/argument mentioned in the connection. For instance, if you make each waypoints too far away from each other in a path, the value will return even when your humanoid reaches the waypoint in more than 8 seconds. i am unsure if this will increase performance soo lol\n• Costs key contains a dictionary for our . Feel free to mess around with the other keys, since they are easy to learn. This part of the tutorial will mainly focus on the object in the key. When I first learnt about this, I was puzzled. Thankfully, @Hexcede managed to brighten me up! So what do these things do? These things are also known as “multipliers”, meaning that if I set a higher number in this multiplier, it will make the path “harder” to traverse/walk through it. For instance, imagine a path that has a distance of 100 studs before reaching a goal. If I set a cost of multiplier of 5, this will make it so that this path is 5x harder to traverse. It sounds confusing, but the point here is that it stores a multiplier value that decides on how hard is to get to the goal through this goal. You might be asking what is this multiplier value multiplying with? Well, we don’t have a clear answer but according to @Hexcede, costs are somewhat directly proportional to distance traveled. This means, the higher the cost, the harder it is for the humanoid to traverse that path. For example, travelling on 30-studs-long path with a cost value of 10 will cost around 300 to travel on, on the other hand a 100-studs-long path with a cost value of 2 will cost 200 to travel on. In conclusion, would prefer the 100-studs-long path because it costs less than 100 by the 30-studs-long path. This allow us to make our humanoids walk on longer paths with a low cost value over short paths with a high cost of values. Imagine a situation where you wanna force a humanoid to walk on the longer path when it has to choose which path to go, each with different lengths in studs. With the Costs parameter, we can make it so that the shorter path costs more than the longer path to travel, which will make pathfinding service to choose the longer path instead. How is this useful you may ask? Well, just like the problem I have shown earlier, we can make it so that pathfinding service will choose to walk on the Cyan paths by lowering the cost to travel on that part. How do we do that? We can either make it so that the cost of traversing to the goal through the corroded metal part is higher than the cost of the Cyan parts or lower the cost of traversing on the Cyan parts. The way on how we lower the cost is by simply giving it a multiplier value of less than 1, because any number that is multiplied with less than 1 will output a lower number than its original. For instance, . The addition of this is also as simple as how we implement our method to counter blocked paths. It just needs one variable and that’s it! At the beginning of the script, we create a variable named which contains a dictionary to customize our computed path. Inside it, we will add the key which contains another dictionary to store all the costs to traverse on certain parts/materials. In our case, the Cyan part has a metal material, so we would have to name the key as Metal exactly, then its value will be the multiplier cost. I am going to set this lower than 1 so that pathfinding service would likely choose that material to be appeared in our final path more often. local Path:Path local AgentParameters = { WaypointSpacing = 4, Costs = { Metal = 0.1 -- if your material is other than Metal, name that material as the key exactly. -- set it to lower than 1 to make the service more likely to include that material in the path } } Path = PathfindingService:CreatePath(AgentParameters) -- the function receives an optional parameter which contains our AgentParameter dictionary in order to customize our path. In the dictionary, each key inside it can either be the name of a material, terrain material of a unique ID for a object which I will demonstrate later. And that’s actually it! No catches, no strings no nothing. Let’s compare it with a path without the costs. Without the dictionary (all costs are the same)\n\n With the dictionary (Metal material cost is 0.1)\n\n Of course, as I’ve said it is not limited to just BasePart materials, it can also be a terrain material or the object! \n\n the big corroded metal part contains the pathfinding modifier object \n\n \n\n Use the Label property as the name of the key. local AgentParameters = { WaypointSpacing = 4, Costs = { AvoidThis = math.huge -- this will make it so that this part will never be included in the path even though it is the only way to get to the goal } } The object is useful if you want to define a certain region in your game as either traversable or not. To do this, you can define the region using a part, make sure its CanCollide property is false and make it transparent. To define the region as non-traversable, you can set its cost to a higher value according to the Label property of its object. Otherwise, check the PassThrough property and the service will mark the region as traversable. You do not have to set its cost in this case. This is extremely useful if you are making a bot to walk through a hinged door in your game. There is also a object, which is useful if you wanna trigger a custom event through attachments when your humanoid object is heading to a certain waypoint in the path. This is also useful if you want to make the humanoid traverse to waypoints that are impossible to get to without a special function that makes it possible to traverse. You can check out the developer hub as it has already explains it well, but I will just do one example. Let’s say I want this humanoid to jump over the gap to get to the red block:\n\n If we use to compute the path, it fails because it is unable to find a clear path for the humanoid to traverse through. BUT, if we use , this is possible!\n• First, add two attachments and parent them under 2 parts. In this case, I will put one attachment each in the 2 big parts in the photo I have just shown.\n• Then, position both attachments to your desired location. As long as it is logical, it will work. In my case, I have to place it close but not touching to each other like so:\n\n This really depends on where you want your humanoid to utilise these special waypoints, so you have to experiment this a lot to find your sweet spot.\n• Now, add a object. Give it a name. I’ll call mine\n• In the properties panel, assign and to those attachments. The order does not matter .Name the label as the name of your object.\n\n \n\n forgot to name my Label Also just in case if you are wondering, is the reason why the order of the attachments does not matter. If it is false, then is the starting point and is the ending point.\n• Back inside the script, let’s create a dictionary, where inside the dictionary, we will add our label with its respective value. I’ll give it a 2 so that it prefers walking instead of jumping assuming the gap is connected with a part. -- CONSTANTS -- local MAX_RETRIES = 5 local RETRY_COOLDOWN = 5 local YIELDING = false local AGENT_PARAMETERS = { AgentCanClimb = true, -- this does not matter. i just want my humanoid to jump. Costs = { JumpGap = 2 } }\n• To make this easier for you to add and update new objects you may add in the future, we will create a dictionary which stores a key equivalent to a label’s name, and its respective value which is a function that stimulates the logic of that label. In our case, we want the humanoid to jump when it has reached that special waypoint (created by the first attachment), and then move to its connected waypoint (the second attachment). -- SPECIAL WAYPOINTS FUNCTIONS -- local SPECIAL_WAYPOINTS = { JumpGap = function(model, waypoints, currentWaypointIndex) -- every other logic functions may need to use these arguments for their own logic. local humanoid = model:FindFirstChildWhichIsA(\"Humanoid\") if humanoid then humanoid.Jump = true humanoid:MoveTo(waypoints[currentWaypointIndex + 1].Position) end end, } -- remember, key = label, value = its logic function.\n• In the variable which stores the event with its connected function, after we add one to , we will need to check if this next waypoint’s label ( ) can be found in the table, and if such value exists, we will call that function, simple as that! Otherwise, we just tell it to move to the next waypoint. if reached and currentWaypointIndex < #waypoints then currentWaypointIndex += 1 if SPECIAL_WAYPOINTS[waypoints[currentWaypointIndex].Label] ~= nil then SPECIAL_WAYPOINTS[waypoints[currentWaypointIndex].Label](model, waypoints, currentWaypointIndex) else humanoid:MoveTo(waypoints[currentWaypointIndex].Position) end And you are basically done!\n\n This pretty much concludes how you can modify paths for your own liking using some special features offered by PathfindingService`.\n\nI’m sure all of you have at least play a game where you have to escape from a threat before it gets you, take the game Piggy for example. In the game, a bot would spawn and pathfind its way to chase the closest player near to itself and when it touched the player, the player dies. How does this work using pathfinding script? If you’ve dissected a bot AI chasing model, you’ll notice that most of them contains a function that gets the closest player’s character’s torso, and then pathfind it by only making the humanoid walking to either the second or third waypoint of the path. Why is that? Based on my experience, I am sure it is something to do with whatever the bot is trying to get to. The script that I have taught you guys just now isn’t suitable to do such things. Here are a number of reasons:\n• The script itself generally is only used for bots that is going to pathfind a location that’s fixed. If you are going to make a pathfind script for a bot that’s going to constantly chase a player that its position is dynamically changed every few seconds, it’s better if we just don’t make the bot walk through the whole series of the path, instead we want it to only walk to either the second or third waypoint of the path. With this, the bot doesn’t have to wait until it finishes looping through the whole path and start going to another position after that.\n• The script can be severely deoptimized if not used right. The main reason why my previous pathfinding script in my last Pathfinding Service usage tutorial sucks and deoptimized is because of how frequently it is called per second. Previously, I would use a repetitive loop that spawns around 60 threads per second using event. The result? The script ended up calling that same function around 60 times per second and that is not good. To add the salt on the wound, there is a in the function which would be ran around 60 times per second or the same rate as how many times the function was called per second. This ended up making our bot look buggy and stuttering. So how do we solve this? Simple, with the logic I’ve explained in the previous reason, we will need a loop that waits for the humanoid to stop walking to the waypoint before executing the same function over and over again. loop is already good enough as it doesn’t spawns multiple threads per second and it yields if any code inside it has a yielding function.\n• The events (for handling blocked path and waypoint reached) connected inside the script would just add more performance drop in our script, but without it how can we solve such problems? Well, the first reason I’ve stated is already enough to counter this problem. Since the position of the player’s character model is constantly changing, we would compute a new path every time the while loop has done executing the function (when the yield is finished), and when we compute a new path, we would have a new series of waypoints with different positions. By computing a new path everytime our bot has reached to the second/third waypoint of the previous path, the computation of the path would avoid any obstacles and go around it to make our bot get to us without any issues. Now that I’ve explained the reasons why, it’s time to create a new script. The flow of the script is simple. Everytime the while loop runs, it will call a function which tells the script to detect any closest player to the bot itself. If it managed to find one, we will tell the script to compute the path to it, and make our bot to only loop/walk through the second or third waypoint of the path before ending the function. Then this whole sequence would be repeated until our bot touches the player and makes the player die. Simple enough. This part of the tutorial will be out soon.\n\nI hope this tutorial benefits you. If there is any questions, feel free to leave a comment down…"
    },
    {
        "link": "https://devforum.roblox.com/t/how-to-use-pathfinding-service-in-roblox/881628",
        "document": "DISCLAIMER: THIS THREAD IS OLD AND OUTDATED, REFER TO THE NEWEST VERSION OF THIS THREAD: How To Use Roblox Pathfinding Service 2.0\n\nHello everyone! This is my first tutorial. Please correct me anything if I taught something wrong.\n\nIn this post, I will be teaching you guys on how to use the Pathfinding service in Roblox! This tutorial is specially for people who are decent at scripting and new to this service. Anyway without ay further ado...\n\nWhat the heck is Pathfinding service? In Roblox, PathfindingService is a service used to find a clear path between 2 points/destination. Imagine an NPC that can walk with this service. Pretty uninteresting right? Well, with PathfindingService, the NPC will find a clear path to walk to it’s destination without getting stuck at blocking obstacles. This will make the NPC smart enough to get to a specific position.\n\nThis is because, as I’ve stated earlier, PathfindingService allows an NPC to find a clear path between 2 destination points. If you get the idea, a clear path means a path with nothing to block the path. You might be asking, why can’t we just use the MoveTo() function from the humanoid instead? This is because MoveTo() function will ONLY find the fastest path, which is a straight line, from one point to an end point. This makes it hard for the NPC to reach because imagine there’s gaps between the path, blocking obstacles, jumping platforms and even more! With PathfindingService, this issue will be resolved.\n\nHow can we use it? Glad you asked! Follow the steps below.\n• Make sure you use a server script for this, and maybe try to parent it in a NPC model so we can script more easily.\n• Remove the code inside it and get the service of it.\n• Now, let’s create some variables for the NPC’s root part, humanoid and the destination/position we want it to walk to. local pathfinding = game:GetService(\"PathfindingService\") local rootPart = script.Parent:WaitForChild(\"HumanoidRootPart\") or script.Parent:WaitForChild(\"Torso\") local humanoid = script.Parent:WaitForChild(\"Humanoid\") local destination = Vector3.new(30,0,0) -- I'm gonna use vector3 instead.\n• Cool! Now we can start the real stuffs here. We need to create a path so we can tell the NPC to walk to that destination. local pathfinding = game:GetService(\"PathfindingService\") local rootPart = script.Parent:WaitForChild(\"HumanoidRootPart\") or script.Parent:WaitForChild(\"Torso\") local humanoid = script.Parent:WaitForChild(\"Humanoid\") local destination = Vector3.new(30,0,0) -- I'm gonna use vector3 instead. local path = pathfinding:CreatePath()\n• Alright, now we need to give the two points to the path variable so that we will successfully create a path between the starting point and the ending point. Okay, you might be a bit confused. But let me explain. We re calling our path variable and then we use a function called ComputeAsync() which will create a clear path between 2 points. The first parameter of the function is the starting point of our path, in this case we use rootPart.Position as the starting point, then we use destination as our ending point of the path, which is the second argument we need to pass in this function. NOTE: IF YOU'RE NOT USING VECTOR3 AS THE DESTINATION, YOU CAN USE A PART'S POSITION AS THE ENDING POINT. MAKE SURE TO ADD .Position !!! WHICH WILL BE LIKE ComputeAsync(rootPart.Position,part.Position).\n• Now that we have computed the path, it will provide a series of waypoints, which we will tell the NPC to move to each waypoint until it reached it’s destination. local pathfinding = game:GetService(\"PathfindingService\") local rootPart = script.Parent:WaitForChild(\"HumanoidRootPart\") or script.Parent:WaitForChild(\"Torso\") local humanoid = script.Parent:WaitForChild(\"Humanoid\") local destination = Vector3.new(30,0,0) -- I'm gonna use vector3 instead. local path = pathfinding:CreatePath() path:ComputeAsync(rootPart.Position,destination) local waypoints = path:GetWaypoints()\n• Now, we will use a for loop so that we can tell the NPC to move to each waypoint after they’ve reached the previous ones. local pathfinding = game:GetService(\"PathfindingService\") local rootPart = script.Parent:WaitForChild(\"HumanoidRootPart\") or script.Parent:WaitForChild(\"Torso\") local humanoid = script.Parent:WaitForChild(\"Humanoid\") local destination = Vector3.new(30,0,0) -- I'm gonna use vector3 instead. local path = pathfinding:CreatePath() path:ComputeAsync(rootPart.Position,destination) local waypoints = path:GetWaypoints() for i,v in pairs(waypoints) do hum:MoveTo(v.Position) if v.Action == Enum.PathWaypointAction.Jump then hum.Jump = true end hum.MoveToFinished:Wait() end Okay, so what we did is, for every waypoint that’s being iterated in the table of waypoints, we tell the NPC to move to that waypoint using MoveTo(). The gaps between each waypoint is small enough for the NPC to walk to the next waypoint in a straight line. Then, you’ll notice there’s an if statement to it. This checks if whether the NPC reaches a waypoint that needs the humanoid to jump or not. Waypoints have a property called Action and this have 2 values, Jump and Walk. The waypoint will determine whether it’s action is either Jump or Walk. So, we use an if statement to check if the action is jump using an enumeration of PathWaypointAction. If it’s true, we will set the humanoid’s jump to true. And this should work now! Play the game and see the magic happens. Due to my trashy laptop, I’m unable to record it working in Roblox Studio. And there you go! You successfully make a smart NPC!\n\nWait! How can we make it so that when it handles blocked paths? This got me hard when I was trying to find a solution of it. While you can actually use path.Blocked event, I can’t manage to find how to use this event to handle this issue. But, the best thing we can solve this issue is to create a new path and compute it constantly. So for this, we will use RunService.Heartbeat as an alternative way for while true do loop. Then, instead of making a script that’s not good-looking, we will create functions which will do a separate job. So we will create a function that creates a path and returns it, then another function which will tell the NPC to move to each waypoints. The key is to tell the script to constantly create a new path, and compute it, as creating a path and compute it only once only keeps that path forever, so if we do this method, it will create a new clear path constantly. So if you want the full code instead of just trying to create the functions by yourself, here it is. NOTE: I wouldn’t recommend you guys to copy this code. Try to be creative and use your brain instead! local pathfinding = game:GetService(\"PathfindingService\") local run = game:GetService(\"RunService\") local rootPart = script.Parent:WaitForChild(\"HumanoidRootPart\") or script.Parent:WaitForChild(\"Torso\") local hum = script.Parent:WaitForChild(\"Humanoid\") local destination = Vector3.new(30,0,0) -- I'm gonna use vector3 instead. local function GetPath(destination) local path = pathfinding:CreatePath() if typeof(destination) == \"Vector3\" then -- This line is untested yet. Please tell me if it works. path:ComputeAsync(rootPart.Position,destination) else path:ComputeAsync(rootPart.Position,destination.Position) end return path end local function WalkToWaypoints(tableWaypoints) for i,v in pairs(tableWaypoints) do hum:MoveTo(v.Position) if v.Action == Enum.PathWaypointAction.Jump then hum.Jump = true end hum.MoveToFinished:Wait() end end local function WalkTo(destination) local path = GetPath(destination) if path.Status == Enum.PathStatus.Success then -- the path will return either success as true value or nopath as false value if it's computed. WalkToWaypoints(path:GetWaypoints()) end end run.Heartbeat:Connect(function() WalkTo(destination) end)\n\nThank you for reading my post! Again, please leave feedbacks and any mistakes and corrections under this post. I will update the post if I did anything wrong.\n\nEDIT 1: I made a spelling mistake while spelling humanoid in the scripts. I accidentally spell it hum as humanoid. If you wanna change it, you can use Ctrl + H or Cmd + H while typing in the script to change these spellings immediately. Sorry for the mistake!"
    },
    {
        "link": "https://devforum.roblox.com/t/scripting-manual-for-everyone/2344386",
        "document": "Hi, i’m roblox developer for 6 years, i’m started in 2017, first i wan’t to make robux, but it was too hard for me, i’m was a noob, there was nothing on youtube to learn, i don’t know dev forum. Now after this years of passion and learning, i’m wan’t to do something more , i’m started programming in C++ laungage that is better. But before that, i wan’t to share my knowledge to every noob like me 6 years ago, and i wan’t to make real Programmer.\n\nNote: I’m not good at english, i’m from Poland, and i can make a mistakes with times and other things, please don’t mind that, i’m sure you can understand me.\n\nNote: I’m will write this tutorial like book, soo lesson after lesson, and please make sure you know how to use roblox studio , and it’s basics, now, open output, explorer and propertiess, and insert your first script.\n\nTopics: – some of topics are planned, i’m slowly writes this, if you are interested in something there, leave a comment, i will try to write this topics early\n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n 1. Output: Print() and Warn()\n\nOkay, soo after you created script, you see this word, this is the basic function called Print(), it prints text on output after running. Remember that this function is the best debugger for future projects, use it in learning scripts, for finding bugs and for informations.\n\nWarn is printing, but it's make to use when we wan't to show error, i will explain this in the future, you can use warns of course, but prints is better for that.\n\nOn math lessons, you have algebra where you have a letters that are values, this is variables, a letter or text that are value, for example we have number a that is equals to 5 for example.\n\nas you can see we have a lot of variable types, don't worry, this is the easiest ones, now we moving to our first working\n\nThis is everything for today, i’m told that this is beginning of my manual,\n\n if you are more advanced and you wan’t tutorial about some things, you have to wait or\n\n find another tutorial, you can link tutorials in comments, soo everyone can learn from they\n\nThanks you for this lesson. Good luck at making your first steps in scripting.\n\nNow we learn some usefull things like how to delay beetween functions and basic\n\n calculation function.\n\nThis dialogue that have no sense are example of using wait, of course you will use this for almost everything, if you wan't to wait minutes or hours, you need to transform secconds like this:\n\nAs you can see, this is a quick conversion for people who don’t know how to do this\n\nNow it's time for calculation functions, it's the easiest one, and the most important\n\nThis type of functions are common ones, they will help you to sort your code and make calculations, or run something like laser shoot or animation\n\nThank you for today’s lesson, please tell me if i helped you, it’s important for me because i wan’t to help scripters, advanced and beginners\n\nHi, this is day two of my tutorial, firstly i wan’t to talk about what to do for better experience with programming in any enviroment.\n• Make breaks if you bored, or you can’t figure what to do\n• Make things that are graphically fun, and easy to see. Maybe explosion effect?\n• Often go to the park or forest and breathe fresh air, this will help your mind\n• Don’t give up, if you don’t believe in you, you do nothing\n\nOkay, soo now it’s time for our lesson\n\nThats all for today’s lesson, i’m got a tip to write english more correctly, heh soo,\n\n i will try to do that in the future, i’m think you learned something, thanks you for reading\n\n remember to leave a comment, bye!\n\nHi, soo this is fifth topic, now we moving into loops, three basic loops.\n\nWhile loop is replacement for run service, if you wan't to make something look good, but don't like to lag game, this is for you\n\nRepeat loop isn't used as often as while or for, but it's good for people who wan't to do something like automatic shooting or other things, i don't use it personally\n\nSoo, this is everything for today’s lesson, in the next lesson i’ll explain many new things, like conditions and events, soo be patient and read slowly to get as much knowledge as you can, good luck and goodbye!\n\n6. Events: Touched and Changed\n\n Sorry for long time of no responsing. Now it’s time for functions connected to events, let’s start\n\nThis is changed event, good for coin visualization in gui or detecting propertiess change\n\nThis is all, sorry for that content, but i’m tired and it’s hard to write this, i’m hope i’ll do this mission. Thank for your help and motivation. Bye \n\n 7. Arrays\n\n Sorry for long time of no responce, i’m back. Soo this topic is easy, simple and very usefull, let’s dive into it.\n\narrays can be used to make a lot of things easier, this is also data type\n\nNow we can move to loops section of this topic and usefull things to know\n\nSoo, arrays and tables are data type that holds data and variables, you can use it in almost everywhere. This is everything for this lesson, sorry for no responsing, but slowly i’ll make this tutorial and bring it to the finish. See you later, bye!\n\n 8. Making Systems\n\n Note: sorry for that, i have no time and i don’t script in LUA much, this is maybe the last part of manual…\n\nSystems are important, they are integrated scripts that works together making some function inside your game.\n\nThis is more about talking, but i’ll give you some tips\n\nTo make system you should know what you wan’t to do, remember that you should know basics of code, from loops and conditions you can make almost everything, you only must know how!\n\n1 Use module scripts: modules are usefull to store arrays and functions that can be easily accesed from every part of your game, this way you can save time and optimize your code a little to make things required for system's work\n\n2 Optimize your code, this can be done in various ways, for example don't make script in every brick that will make players off, instead get all parts this type into array or tag it and then use .touched event on every. Game now need to load your script once, not 500 times soo this will be 500x less work for server\n\n3 Make research, this includes testing basic use of code, like how to manipulate strings or maybe more advanced data store\n\n4 Plan your systems, make elements of it then combine them together to create a working system\n\n5 Work together, if your friend know how to script, they can make some elements of code, you can make another and then make everything faster\n\n6 if you work with friends, check your mistakes to fix them, this is better than 10 hours of debugging xd\n\nthis is end, i have less time now, this is maybe the last part, sorry.\n\nSoo, this is large skip, if there aren’t any previous topic, please wait.\n\n Why i’m writing this, because this was my nightmare, i figured how to do that, but\n\n you know, basic solution sometimes is pain.\n\nsoo first, what we need?\n• System that checks if number is even or not\n• Remote Event that sends info about our mouse\n\npersonally, every time i’m doing things like this i starts with local side, and then i moving into server, but this time is different, first make raw systems, like function that calculates grid for example values , script that checks if number is even or not and basic correction system. Then try to connect each piece of code into one bigger script.\n\nBecause you can make system relative to certain part, like maybe building zone.\n\n Moreover you can make saving better, of course if you wan’t.\n\nNote:\"i will prepare it for you, wait some time ’"
    },
    {
        "link": "https://devforum.roblox.com/t/how-to-give-npc-a-walking-sound/3194699",
        "document": "I would like to give my NPC footsteps sounds and the current method of implementation I’m using is:\n\nBut when I play the sound it has a weird popping sound artifact right before the next sound is played:\n\nI would like to know if there’s a way to prevent this popping sound from happening, but I would also like to know if there are any better ways to implement footstep sounds."
    },
    {
        "link": "https://devforum.roblox.com/t/how-would-i-use-module-scripts-to-manage-npc-behavior/3272503",
        "document": "The best approach would be using a class system.\n\nEvery NPC would be assigned this class, acting as the “brains” of the character. This will allow you to make changes to the way your NPC’s act, all from a single source.\n\nHere is an in-depth post on using OOP\n\nTo sum it up; you will have a generalized method that will be called on every new NPC.\n\n You can use CollectionService to listen for added NPC’s, then pass them through this method.\n\nI suggest doing this setup on the server, then passing updated values to the client.\n\n Varying on the setup of your ModuleScript, and your goal, you can have a large table consisting of the game’s NPC’s, which can be used to add more functionality.\n\nFor example, if you want them to switch between “wandering” or “attacking” states, you can have a loop which would iterate through either table and applying the relevant methods.\n\nHere’s how I would set it up:\n\n Server-side\n\n Script\n\nIf youre interested in:\n\n More efficient way of “WalkTo” i.e. PathfindingService\n\n setmetatable\n\n .__index\n\n MoveTo\n\nNow all you have to do is insert some new Rig’s with the “Rig Builder” then add the “NPC_TAG” Tag to them. Refer to CollectionService if you’re interested in how Tag’s work.\n\nThis only scratches the surface of what you can do with OOP, even more so with NPC mechanics. The ModuleScript only has them walking around, but you can imagine much more functionality just by adding a few methods then plugging them into your Script’s."
    },
    {
        "link": "https://devforum.roblox.com/t/ideal-way-to-code-a-lot-of-npcs/338882",
        "document": "Your question is going to depend heavily on the goal of the NPC. OOP isn’t necessarily going to solve any problems here, it’s really just one of many techniques for writing reusable code. You’ll want to try to optimize for each case here. Basically the NPCs that roam around the map and do various things are probably going to be more complex and specialized than the ones where you’re doing hundreds of NPCs. In those scenarios you’ll probably want to try to dumb them down as much as possible.\n\nAnother thing you can do is avoid the use of loops, at least in the conventional sense. There are events built into the Humanoid to detect when it has finished moving for example, while you could run a loop that says to move the Humanoid to a point every frame or once a second even. You would be much better off hooking into that event.\n\nAgain it’s going to depend on the use-case for the NPC. I would strongly encourage writing a robust and efficient (likely event driven) behavior tree module. They’re a relatively simple concept and very simple to work with. Of course there are alternatives to this but again, this is simple to understand for almost anyone and they are efficient since they can be entirely event driven and only perform an operation as necessary. If you combine this with some kind of system where you can extend modules then you would seriously benefit from code reuse.\n\nI’ve always preferred OOP but it does come with a memory cost, which generally pays for itself in code reuse… again that depends on your implementation.\n\nAs for your second question, keeping all of the entities in an array will only help depending on how you need to handle working with them. If you’re needing to lookup a specific entity in the list then stick with the GUID approach. You’ll not want to loop through each entity to see if it’s a match when you can do an O(1) lookup on an object instead.\n\nYou might find it useful to create a custom humanoid implementation for certain use cases. You likely won’t be able to do what a humanoid does better (and by better, I mean in the memory/computational department).\n\nYou’re pretty much free to go about this in whatever way you find best. That may require some research.\n\nYou can look into how major game engines handle NPC actions. A lot of them use behavior trees like I had mentioned. I’ve found them to be useful and very simple to work with so that would be my recommendation. That would allow you to curate each type of NPC to be exactly what it needs to be and nothing more."
    },
    {
        "link": "https://hytale.com/news/2019/4/an-introduction-to-building-npc-behaviors",
        "document": "In today’s article, we’re going to give you an overview of how Hytale’s behavior scripting system provides ways to bring NPCs and creatures to life. To do this we’re going to show you some aspects of Trork behavior - how they react to the player, the environment, and each other. Of course, these principles apply to Hytale’s other creatures too - and all of them will be customizable by modders. As ever, all of the screenshots and clips in this post represent work in progress, and details may well change over the course of future development.\n\nAfter a creature has been designed and its model and animations have been created in Hytale Model Maker, the NPC developers are tasked with bringing it to life using the behavior scripting system.\n\nThe system uses JSON scripts that call on modular behavior elements that allow us to specify how an NPC perceives the world and how it reacts in a variety of situations. These scripts can trigger animations, changes in state, and more - a very simple example of this would be a script that determines whether a creature that has been attacked flees, or attempts to defend itself. More sophisticated scripts can send NPCs chasing after players or cause them to seek out things they like, such as campfires or food.\n\n“We use building blocks to create an NPC from the ground up” says developer Ioseff Griffith. “We have sensors that are how an NPC interprets the world around it, and that’s how it decides what it wants to do. Then we have actions and motions, which are how they will then interact with the world or their target or whatever it is that they’re focusing on. We combine these to build up components and templates from which variants can quickly and easily be derived.”\n\nIn this example, you can see a snippet of the script that causes Trorks to spring into action when they see the player. The script handles several elements of this interaction. It triggers an ‘alerted’ animation, which helps the player understand that they’ve been spotted. It also initiates a ‘beacon’ response that causes other Trorks within a certain radius to be alerted to the player’s presence too. The exact details of this interaction can be precisely tweaked, but the overall implementation is grounded in top-level templates that are common to most NPCs.\n\nThis modular approach to behavior makes it easier to implement entirely new NPCs or creatures. “When you script an NPC you don’t need to specify things like ‘swing a sword’ or ‘move X distance to the right’” Ioseff explains. Simply applying an abstract component like ‘flee’ or ‘seek’ is enough - the behavior system then handles the basics of carrying out the desired action.\n\n“At the most basic level, the easiest way to create an NPC is to use existing templates” he says. “These templates are made up of components that we build out of sensors, actions, and motions to make it easy to reuse behaviors across multiple scripts.” One example of a component is sound detection, Ioseff explains. This uses a combination of sensors that allow an NPC to interpret its environment. “When you drop a new NPC into the world it should be able to cope with environments that it hasn’t been specifically scripted for, at least to some degree” he says.\n\n“An important feature of this whole system is high reusability” says developer Eric Reinhart. “It’s easy to modify existing behaviors, replace parts, and it’s also easy to build up something new.”\n\n“For someone who wants to mod things or create content, the advantage is that it’s easy to make simple modifications” Eric continues. “But it also allows modders to change everything down to the smallest detail.”\n\nHere’s an example. By adding a few extra parameters to the Trork hunter’s behavior script, we can add bears to the list of creatures that cause them to enter an ‘alert’ state.\n\nNow we’ve got a Trork hunter who yells at bears! This is purely an example - they won’t necessarily do this in the final game. Even so, this provides an example of how straightforward it is to introduce new details to a creature’s behavior.\n\nOften the behavior set for a new NPC will be mapped out by the design team before it comes to be implemented. Sometimes, this means adding new features to the behavior system that then expand the possibilities of the system further. Occasionally, however, surprises during development will lead to the addition of new behavioral quirks.\n\n“Some small pieces get added during the process” Ioseff explains. “For example, Trorks have a sparring behavior where they start punching each other. When I was implementing this, a defeated Trork would change state. Sometimes they’d immediately switch to a ‘nap’ state - this was funny, because it looked like they’d been knocked out. I implemented it properly, and currently sparring Trorks will knock each other out after a fight.”\n\nThe team’s intent is to create creatures and NPCs that contribute to the immersiveness of the world by acting independently of the player. By learning how each creature reacts, players can then come up with creative ways to interact with them. For example, Trorks have a particular fondness for discarded meat:\n\nHow the player chooses to take advantage of this information is completely up to them!\n\nThe team has found that combining lots of simple behaviors can produce a surprisingly lifelike result. “I’d created a script for a Trork archer, and was trying to test how well the archer fires” Eric says. “This was the first time when we had the possibility for NPCs to switch weapon. It was amazing to try to pursue this archer, and then when you were close enough he would turn around and attack you with a melee weapon. Having these really simple actions combined together was really rewarding.”\n\nIn the clip above, you can see an example of several simple Trork behaviors working together. The Trork is napping outside when it begins to rain. This triggers a change of state from ‘asleep’ to ‘awake’, at which point the Trork decides to seek out somewhere warm. He then moves to the nearby campfire and sits down. Several different elements of the Trork’s behavior script are involved in creating this moment, but taken together they create a sense of the creature’s personality. Our goal with the behavior system is to furnish the player with immersive moments like this, and we’re excited to see what modders can come up with when they get their hands on it!\n\nHere are a few more examples of NPC behaviors that you may encounter as you explore Orbis:\n\nKweebecs don’t need to eat or drink in a normal sense. As plant-people, they’ll seek out bright spots and happily sunbathe to get all the nutrients they need!\n\nGoblins are fond of throwing bombs at a problem. These can destroy blocks and create holes, which is a problem in and of itself. Good job, goblins."
    },
    {
        "link": "https://devforum.roblox.com/t/general-combat-npc-tutorial/1862031",
        "document": "Hello everyone, today I want to update my npc tutorial. This one is going to be much more general and what you should do and not do.\n\nHave you ever wondered how to make a npc that attacks you? Well here’s a tutorial for that! Part 1 - Making the Dummy\n\n First off, let’s create the npcs. For R15 games go to the plugins tab and press this icon in the screenshot to insert a R15 character make sure to un-anchor the root part! Or if you want a R6 character you could insert this model of a R6 character:\n\n https://www.roblox.com/library/8370047840/R6-Dummy-Rig?Category=Models&SortType=Relevance&SortAggregation=AllTime&CreatorId=0&Page=1&Position=7&SearchId=31af5b5c-1b58-4cbb-97ad-2dbca631e70e Part 2 - Scripting Time \n\n Alright scripting time also known as the best time! \n\n So first, create a script inside the dummy/NPC you can name it whatever. So inside the script insert this code. (I won’t be going step by step so I don’t make this to post to long ) -- Follow Script local PathFinding = game:GetService(\"PathfindingService\") local path = PathFinding:CreatePath() local AttackEvent = script.Parent:WaitForChild(\"AttackEvent\") -- Used to attack local debounce = false -- Debounce so it doesn't spam attack local cooldown = 0.5 local maxDistance = 100 -- Max Distance change to your liking local closestPlayer = nil -- Locks to closest player local closestDistance = maxDistance local attackRange = 5 -- Range npc can attack you local Players = game:GetService(\"Players\") local npc = script.Parent local HRP = npc:WaitForChild(\"HumanoidRootPart\") local humanoid = npc:WaitForChild(\"Humanoid\") -- New Path Function function newPath(character) -- Compute the path path:ComputeAsync(HRP.Position, character.HumanoidRootPart.Position) local waypoints = path:GetWaypoints() for i, waypoint in pairs(waypoints) do npc.Humanoid:MoveTo(waypoint.Position + Vector3.new(1, 0, 1)) -- Move to the waypoint position end end -- When damaged move the NPC humanoid:GetPropertyChangedSignal(\"Health\"):Connect(function() while true do for _, player in pairs(Players:GetPlayers()) do local playerRoot = player.Character and player.Character:FindFirstChild(\"HumanoidRootPart\") local playerHumanoid = player.Character and player.Character:FindFirstChild(\"Humanoid\") if playerRoot then if playerHumanoid.Health <= 0 then closestPlayer = nil closestDistance = maxDistance break end if (playerRoot.Position - HRP.Position).Magnitude <= attackRange then AttackEvent:Fire() -- Fire Attacks Event break end if (playerRoot.Position - HRP.Position).Magnitude <= maxDistance then newPath(player.Character) -- Move characters break end end end task.wait() end end) Alright! We got a basic following script! Good job! Now let’s create the attack event! First create a bindable event and put it inside dummy/npc. Call it “AttackEvent.” Now for hit detection. First get the sword it can be a roblox sword or a custom sword it doesn’t matter. So to make it detect the event, instead of the activated just replace it with the event. For example: Also make sure to add an animate script to give the dummy animations. You could get the animate script by searching inside the toolbox. Here’s a video of it in action:\n\n Well this is it hopefully you learned something new. Well, have a nice day and thank you for reading .\n\nNPCs are good for many types of games such as tower defense games, wave games, and much much more. It doesn’t have to be all about fighting NPC. But, in this tutorial I’m going to be talking more about fighting NPC.\n\nSo how should you organize your NPCs? You should always have it in a folder. The more organized the better.\n\nBUT, less is more when scripting them. The less NPC scripts the better. You should always try having only one controller script instead of multiple scripts under each NPC. You can do something like this:\n\nThis is much more efficient since now you have less scripts meaning less lag.\n\nStill lag is still a big problem.\n• I have too much NPCs it’s still lagging!\n\nWhat do you do??? First, I would first recommend Simple Path! It’s easy to use and makes NPCs path find much more smoother.\n\nIf you want more information how it works I recommend checking the github for simple path!\n\nSo perfect! The npc runs smoothly and we have one script controlling all NPCs, perfect! Or is it? we can take it one step farther.\n\nInstead of having all the NPCs run on the server which can be extremely laggy especially if there’s lots of NPCs, why not run it on the client?\n\nInstructions:\n\n Basically copy the whole script and put it in the client. Make sure to move all your modules into Replicated Storage! Modules like Simple Path, Fastcast, and Raycasthitbox works on the client so no worries!\n\nIf you want more information I recommend this awesome video created by @5uphi.\n\nAlso here’s an example if you want. It doesn’t use all the practices, but it shows the differences between client and server npcs.\n\n Place1.rbxl (83.5 KB)\n\nWell that’s all for now! Have fun coding and good luck developers!\n\n – Rapideed/mang"
    }
]