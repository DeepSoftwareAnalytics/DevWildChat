[
    {
        "link": "https://flask.palletsprojects.com",
        "document": "Welcome to Flask’s documentation. Flask is a lightweight WSGI web application framework. It is designed to make getting started quick and easy, with the ability to scale up to complex applications.\n\nGet started with Installation and then get an overview with the Quickstart. There is also a more detailed Tutorial that shows how to create a small but complete application with Flask. Common patterns are described in the Patterns for Flask section. The rest of the docs describe each component of Flask in detail, with a full reference in the API section.\n\nFlask depends on the Werkzeug WSGI toolkit, the Jinja template engine, and the Click CLI toolkit. Be sure to check their documentation as well as Flask’s when looking for information."
    },
    {
        "link": "https://flask.palletsprojects.com/en/stable/quickstart",
        "document": "Eager to get started? This page gives a good introduction to Flask. Follow Installation to set up a project and install Flask first.\n\nA minimal Flask application looks something like this: So what did that code do?\n• None First we imported the class. An instance of this class will be our WSGI application.\n• None Next we create an instance of this class. The first argument is the name of the application’s module or package. is a convenient shortcut for this that is appropriate for most cases. This is needed so that Flask knows where to look for resources such as templates and static files.\n• None We then use the decorator to tell Flask what URL should trigger our function.\n• None The function returns the message we want to display in the user’s browser. The default content type is HTML, so HTML in the string will be rendered by the browser. Save it as or something similar. Make sure to not call your application because this would conflict with Flask itself. To run the application, use the command or . You need to tell the Flask where your application is with the option. $ flask --app hello run * Serving Flask app 'hello' * Running on http://127.0.0.1:5000 (Press CTRL+C to quit) As a shortcut, if the file is named or , you don’t have to use . See Command Line Interface for more details. This launches a very simple builtin server, which is good enough for testing but probably not what you want to use in production. For deployment options see Deploying to Production. Now head over to http://127.0.0.1:5000/, and you should see your hello world greeting. If another program is already using port 5000, you’ll see or when the server tries to start. See Address already in use for how to handle that. If you run the server you will notice that the server is only accessible from your own computer, not from any other in the network. This is the default because in debugging mode a user of the application can execute arbitrary Python code on your computer. If you have the debugger disabled or trust the users on your network, you can make the server publicly available simply by adding to the command line: This tells your operating system to listen on all public IPs.\n\nModern web applications use meaningful URLs to help users. Users are more likely to like a page and come back if the page uses a meaningful URL they can remember and use to directly visit a page. Use the decorator to bind a function to a URL. You can do more! You can make parts of the URL dynamic and attach multiple rules to a function. You can add variable sections to a URL by marking sections with . Your function then receives the as a keyword argument. Optionally, you can use a converter to specify the type of the argument like . # show the user profile for that user # show the post with the given id, the id is an integer like but also accepts slashes The following two rules differ in their use of a trailing slash. The canonical URL for the endpoint has a trailing slash. It’s similar to a folder in a file system. If you access the URL without a trailing slash ( ), Flask redirects you to the canonical URL with the trailing slash ( ). The canonical URL for the endpoint does not have a trailing slash. It’s similar to the pathname of a file. Accessing the URL with a trailing slash ( ) produces a 404 “Not Found” error. This helps keep URLs unique for these resources, which helps search engines avoid indexing the same page twice. To build a URL to a specific function, use the function. It accepts the name of the function as its first argument and any number of keyword arguments, each corresponding to a variable part of the URL rule. Unknown variable parts are appended to the URL as query parameters. Why would you want to build URLs using the URL reversing function instead of hard-coding them into your templates?\n• None Reversing is often more descriptive than hard-coding the URLs.\n• None You can change your URLs in one go instead of needing to remember to manually change hard-coded URLs.\n• None The generated paths are always absolute, avoiding unexpected behavior of relative paths in browsers.\n• None If your application is placed outside the URL root, for example, in instead of , properly handles that for you. For example, here we use the method to try out . tells Flask to behave as though it’s handling a request even while we use a Python shell. See Context Locals. Web applications use different HTTP methods when accessing URLs. You should familiarize yourself with the HTTP methods as you work with Flask. By default, a route only answers to requests. You can use the argument of the decorator to handle different HTTP methods. The example above keeps all methods for the route within one function, which can be useful if each part uses some common data. You can also separate views for different methods into different functions. Flask provides a shortcut for decorating such routes with , , etc. for each common HTTP method. If is present, Flask automatically adds support for the method and handles requests according to the HTTP RFC. Likewise, is automatically implemented for you.\n\nGenerating HTML from within Python is not fun, and actually pretty cumbersome because you have to do the HTML escaping on your own to keep the application secure. Because of that Flask configures the Jinja2 template engine for you automatically. Templates can be used to generate any type of text file. For web applications, you’ll primarily be generating HTML pages, but you can also generate markdown, plain text for emails, and anything else. For a reference to HTML, CSS, and other web APIs, use the MDN Web Docs. To render a template you can use the method. All you have to do is provide the name of the template and the variables you want to pass to the template engine as keyword arguments. Here’s a simple example of how to render a template: Flask will look for templates in the folder. So if your application is a module, this folder is next to that module, if it’s a package it’s actually inside your package: For templates you can use the full power of Jinja2 templates. Head over to the official Jinja2 Template Documentation for more information. Here is an example template: Hello from Flask Hello ! Hello, World! Inside templates you also have access to the , , and objects as well as the and functions. Templates are especially useful if inheritance is used. If you want to know how that works, see Template Inheritance. Basically template inheritance makes it possible to keep certain elements on each page (like header, navigation and footer). Automatic escaping is enabled, so if contains HTML it will be escaped automatically. If you can trust a variable and you know that it will be safe HTML (for example because it came from a module that converts wiki markup to HTML) you can mark it as safe by using the class or by using the filter in the template. Head over to the Jinja 2 documentation for more examples. Here is a basic introduction to how the class works: Changed in version 0.5: Autoescaping is no longer enabled for all templates. The following extensions for templates trigger autoescaping: , , , . Templates loaded from a string will have autoescaping disabled.\n\nFor web applications it’s crucial to react to the data a client sends to the server. In Flask this information is provided by the global object. If you have some experience with Python you might be wondering how that object can be global and how Flask manages to still be threadsafe. The answer is context locals: If you want to understand how that works and how you can implement tests with context locals, read this section, otherwise just skip it. Certain objects in Flask are global objects, but not of the usual kind. These objects are actually proxies to objects that are local to a specific context. What a mouthful. But that is actually quite easy to understand. Imagine the context being the handling thread. A request comes in and the web server decides to spawn a new thread (or something else, the underlying object is capable of dealing with concurrency systems other than threads). When Flask starts its internal request handling it figures out that the current thread is the active context and binds the current application and the WSGI environments to that context (thread). It does that in an intelligent way so that one application can invoke another application without breaking. So what does this mean to you? Basically you can completely ignore that this is the case unless you are doing something like unit testing. You will notice that code which depends on a request object will suddenly break because there is no request object. The solution is creating a request object yourself and binding it to the context. The easiest solution for unit testing is to use the context manager. In combination with the statement it will bind a test request so that you can interact with it. Here is an example: # now you can do something with the request until the # end of the with block, such as basic assertions: The other possibility is passing a whole WSGI environment to the method: The request object is documented in the API section and we will not cover it here in detail (see ). Here is a broad overview of some of the most common operations. First of all you have to import it from the module: The current request method is available by using the attribute. To access form data (data transmitted in a or request) you can use the attribute. Here is a full example of the two attributes mentioned above: # the code below is executed if the request method # was GET or the credentials were invalid What happens if the key does not exist in the attribute? In that case a special is raised. You can catch it like a standard but if you don’t do that, a HTTP 400 Bad Request error page is shown instead. So for many situations you don’t have to deal with that problem. To access parameters submitted in the URL ( ) you can use the attribute: We recommend accessing URL parameters with or by catching the because users might change the URL and presenting them a 400 bad request page in that case is not user friendly. For a full list of methods and attributes of the request object, head over to the documentation. You can handle uploaded files with Flask easily. Just make sure not to forget to set the attribute on your HTML form, otherwise the browser will not transmit your files at all. Uploaded files are stored in memory or at a temporary location on the filesystem. You can access those files by looking at the attribute on the request object. Each uploaded file is stored in that dictionary. It behaves just like a standard Python object, but it also has a method that allows you to store that file on the filesystem of the server. Here is a simple example showing how that works: If you want to know how the file was named on the client before it was uploaded to your application, you can access the attribute. However please keep in mind that this value can be forged so never ever trust that value. If you want to use the filename of the client to store the file on the server, pass it through the function that Werkzeug provides for you: For some better examples, see Uploading Files. To access cookies you can use the attribute. To set cookies you can use the method of response objects. The attribute of request objects is a dictionary with all the cookies the client transmits. If you want to use sessions, do not use the cookies directly but instead use the Sessions in Flask that add some security on top of cookies for you. # use cookies.get(key) instead of cookies[key] to not get a # KeyError if the cookie is missing. Note that cookies are set on response objects. Since you normally just return strings from the view functions Flask will convert them into response objects for you. If you explicitly want to do that you can use the function and then modify it. Sometimes you might want to set a cookie at a point where the response object does not exist yet. This is possible by utilizing the Deferred Request Callbacks pattern. For this also see About Responses.\n\nThe return value from a view function is automatically converted into a response object for you. If the return value is a string it’s converted into a response object with the string as response body, a status code and a text/html mimetype. If the return value is a dict or list, is called to produce a response. The logic that Flask applies to converting return values into response objects is as follows:\n• None If a response object of the correct type is returned it’s directly returned from the view.\n• None If it’s a string, a response object is created with that data and the default parameters.\n• None If it’s an iterator or generator returning strings or bytes, it is treated as a streaming response.\n• None If it’s a dict or list, a response object is created using .\n• None If a tuple is returned the items in the tuple can provide extra information. Such tuples have to be in the form , , or . The value will override the status code and can be a list or dictionary of additional header values.\n• None If none of that works, Flask will assume the return value is a valid WSGI application and convert that into a response object. If you want to get hold of the resulting response object inside the view you can use the function. Imagine you have a view like this: You just need to wrap the return expression with and get the response object to modify it, then return it: A common response format when writing an API is JSON. It’s easy to get started writing such an API with Flask. If you return a or from a view, it will be converted to a JSON response. This is a shortcut to passing the data to the function, which will serialize any supported JSON data type. That means that all the data in the dict or list must be JSON serializable. For complex types such as database models, you’ll want to use a serialization library to convert the data to valid JSON types first. There are many serialization libraries and Flask API extensions maintained by the community that support more complex applications.\n\nSometimes you might be in a situation where you deal with data that should be correct, but actually is not. For example you may have some client-side code that sends an HTTP request to the server but it’s obviously malformed. This might be caused by a user tampering with the data, or the client code failing. Most of the time it’s okay to reply with in that situation, but sometimes that won’t do and the code has to continue working. You may still want to log that something fishy happened. This is where loggers come in handy. As of Flask 0.3 a logger is preconfigured for you to use. Here are some example log calls: The attached is a standard logging , so head over to the official docs for more information."
    },
    {
        "link": "https://flaskx.readthedocs.io/en/latest/quickstart",
        "document": "Eager to get started? This page gives a good introduction to Flask. Follow Installation to set up a project and install Flask first.\n\nA minimal Flask application looks something like this: So what did that code do?\n• None First we imported the class. An instance of this class will be our WSGI application.\n• None Next we create an instance of this class. The first argument is the name of the application’s module or package. is a convenient shortcut for this that is appropriate for most cases. This is needed so that Flask knows where to look for resources such as templates and static files.\n• None We then use the decorator to tell Flask what URL should trigger our function.\n• None The function returns the message we want to display in the user’s browser. The default content type is HTML, so HTML in the string will be rendered by the browser. Save it as or something similar. Make sure to not call your application because this would conflict with Flask itself. To run the application, use the command or . You need to tell the Flask where your application is with the option. $ flask --app hello run * Serving Flask app 'hello' * Running on http://127.0.0.1:5000 (Press CTRL+C to quit) As a shortcut, if the file is named or , you don’t have to use . See Command Line Interface for more details. This launches a very simple builtin server, which is good enough for testing but probably not what you want to use in production. For deployment options see Deploying to Production. Now head over to http://127.0.0.1:5000/, and you should see your hello world greeting. If another program is already using port 5000, you’ll see or when the server tries to start. See Address already in use for how to handle that. If you run the server you will notice that the server is only accessible from your own computer, not from any other in the network. This is the default because in debugging mode a user of the application can execute arbitrary Python code on your computer. If you have the debugger disabled or trust the users on your network, you can make the server publicly available simply by adding to the command line: This tells your operating system to listen on all public IPs.\n\nModern web applications use meaningful URLs to help users. Users are more likely to like a page and come back if the page uses a meaningful URL they can remember and use to directly visit a page. Use the decorator to bind a function to a URL. You can do more! You can make parts of the URL dynamic and attach multiple rules to a function. You can add variable sections to a URL by marking sections with . Your function then receives the as a keyword argument. Optionally, you can use a converter to specify the type of the argument like . # show the user profile for that user # show the post with the given id, the id is an integer like but also accepts slashes The following two rules differ in their use of a trailing slash. The canonical URL for the endpoint has a trailing slash. It’s similar to a folder in a file system. If you access the URL without a trailing slash ( ), Flask redirects you to the canonical URL with the trailing slash ( ). The canonical URL for the endpoint does not have a trailing slash. It’s similar to the pathname of a file. Accessing the URL with a trailing slash ( ) produces a 404 “Not Found” error. This helps keep URLs unique for these resources, which helps search engines avoid indexing the same page twice. To build a URL to a specific function, use the function. It accepts the name of the function as its first argument and any number of keyword arguments, each corresponding to a variable part of the URL rule. Unknown variable parts are appended to the URL as query parameters. Why would you want to build URLs using the URL reversing function instead of hard-coding them into your templates?\n• None Reversing is often more descriptive than hard-coding the URLs.\n• None You can change your URLs in one go instead of needing to remember to manually change hard-coded URLs.\n• None The generated paths are always absolute, avoiding unexpected behavior of relative paths in browsers.\n• None If your application is placed outside the URL root, for example, in instead of , properly handles that for you. For example, here we use the method to try out . tells Flask to behave as though it’s handling a request even while we use a Python shell. See Context Locals. Web applications use different HTTP methods when accessing URLs. You should familiarize yourself with the HTTP methods as you work with Flask. By default, a route only answers to requests. You can use the argument of the decorator to handle different HTTP methods. The example above keeps all methods for the route within one function, which can be useful if each part uses some common data. You can also separate views for different methods into different functions. Flask provides a shortcut for decorating such routes with , , etc. for each common HTTP method. If is present, Flask automatically adds support for the method and handles requests according to the HTTP RFC. Likewise, is automatically implemented for you.\n\nGenerating HTML from within Python is not fun, and actually pretty cumbersome because you have to do the HTML escaping on your own to keep the application secure. Because of that Flask configures the Jinja2 template engine for you automatically. Templates can be used to generate any type of text file. For web applications, you’ll primarily be generating HTML pages, but you can also generate markdown, plain text for emails, any anything else. For a reference to HTML, CSS, and other web APIs, use the MDN Web Docs. To render a template you can use the method. All you have to do is provide the name of the template and the variables you want to pass to the template engine as keyword arguments. Here’s a simple example of how to render a template: Flask will look for templates in the folder. So if your application is a module, this folder is next to that module, if it’s a package it’s actually inside your package: For templates you can use the full power of Jinja2 templates. Head over to the official Jinja2 Template Documentation for more information. Here is an example template: Hello from Flask Hello ! Hello, World! Inside templates you also have access to the , , and objects as well as the and functions. Templates are especially useful if inheritance is used. If you want to know how that works, see Template Inheritance. Basically template inheritance makes it possible to keep certain elements on each page (like header, navigation and footer). Automatic escaping is enabled, so if contains HTML it will be escaped automatically. If you can trust a variable and you know that it will be safe HTML (for example because it came from a module that converts wiki markup to HTML) you can mark it as safe by using the class or by using the filter in the template. Head over to the Jinja 2 documentation for more examples. Here is a basic introduction to how the class works: Changed in version 0.5: Autoescaping is no longer enabled for all templates. The following extensions for templates trigger autoescaping: , , , . Templates loaded from a string will have autoescaping disabled.\n\nFor web applications it’s crucial to react to the data a client sends to the server. In Flask this information is provided by the global object. If you have some experience with Python you might be wondering how that object can be global and how Flask manages to still be threadsafe. The answer is context locals: If you want to understand how that works and how you can implement tests with context locals, read this section, otherwise just skip it. Certain objects in Flask are global objects, but not of the usual kind. These objects are actually proxies to objects that are local to a specific context. What a mouthful. But that is actually quite easy to understand. Imagine the context being the handling thread. A request comes in and the web server decides to spawn a new thread (or something else, the underlying object is capable of dealing with concurrency systems other than threads). When Flask starts its internal request handling it figures out that the current thread is the active context and binds the current application and the WSGI environments to that context (thread). It does that in an intelligent way so that one application can invoke another application without breaking. So what does this mean to you? Basically you can completely ignore that this is the case unless you are doing something like unit testing. You will notice that code which depends on a request object will suddenly break because there is no request object. The solution is creating a request object yourself and binding it to the context. The easiest solution for unit testing is to use the context manager. In combination with the statement it will bind a test request so that you can interact with it. Here is an example: # now you can do something with the request until the # end of the with block, such as basic assertions: The other possibility is passing a whole WSGI environment to the method: The request object is documented in the API section and we will not cover it here in detail (see ). Here is a broad overview of some of the most common operations. First of all you have to import it from the module: The current request method is available by using the attribute. To access form data (data transmitted in a or request) you can use the attribute. Here is a full example of the two attributes mentioned above: # the code below is executed if the request method # was GET or the credentials were invalid What happens if the key does not exist in the attribute? In that case a special is raised. You can catch it like a standard but if you don’t do that, a HTTP 400 Bad Request error page is shown instead. So for many situations you don’t have to deal with that problem. To access parameters submitted in the URL ( ) you can use the attribute: We recommend accessing URL parameters with or by catching the because users might change the URL and presenting them a 400 bad request page in that case is not user friendly. For a full list of methods and attributes of the request object, head over to the documentation. You can handle uploaded files with Flask easily. Just make sure not to forget to set the attribute on your HTML form, otherwise the browser will not transmit your files at all. Uploaded files are stored in memory or at a temporary location on the filesystem. You can access those files by looking at the attribute on the request object. Each uploaded file is stored in that dictionary. It behaves just like a standard Python object, but it also has a method that allows you to store that file on the filesystem of the server. Here is a simple example showing how that works: If you want to know how the file was named on the client before it was uploaded to your application, you can access the attribute. However please keep in mind that this value can be forged so never ever trust that value. If you want to use the filename of the client to store the file on the server, pass it through the function that Werkzeug provides for you: For some better examples, see Uploading Files. To access cookies you can use the attribute. To set cookies you can use the method of response objects. The attribute of request objects is a dictionary with all the cookies the client transmits. If you want to use sessions, do not use the cookies directly but instead use the Sessions in Flask that add some security on top of cookies for you. # use cookies.get(key) instead of cookies[key] to not get a # KeyError if the cookie is missing. Note that cookies are set on response objects. Since you normally just return strings from the view functions Flask will convert them into response objects for you. If you explicitly want to do that you can use the function and then modify it. Sometimes you might want to set a cookie at a point where the response object does not exist yet. This is possible by utilizing the Deferred Request Callbacks pattern. For this also see About Responses.\n\nThe return value from a view function is automatically converted into a response object for you. If the return value is a string it’s converted into a response object with the string as response body, a status code and a text/html mimetype. If the return value is a dict or list, is called to produce a response. The logic that Flask applies to converting return values into response objects is as follows:\n• None If a response object of the correct type is returned it’s directly returned from the view.\n• None If it’s a string, a response object is created with that data and the default parameters.\n• None If it’s an iterator or generator returning strings or bytes, it is treated as a streaming response.\n• None If it’s a dict or list, a response object is created using .\n• None If a tuple is returned the items in the tuple can provide extra information. Such tuples have to be in the form , , or . The value will override the status code and can be a list or dictionary of additional header values.\n• None If none of that works, Flask will assume the return value is a valid WSGI application and convert that into a response object. If you want to get hold of the resulting response object inside the view you can use the function. Imagine you have a view like this: You just need to wrap the return expression with and get the response object to modify it, then return it: A common response format when writing an API is JSON. It’s easy to get started writing such an API with Flask. If you return a or from a view, it will be converted to a JSON response. This is a shortcut to passing the data to the function, which will serialize any supported JSON data type. That means that all the data in the dict or list must be JSON serializable. For complex types such as database models, you’ll want to use a serialization library to convert the data to valid JSON types first. There are many serialization libraries and Flask API extensions maintained by the community that support more complex applications.\n\nSometimes you might be in a situation where you deal with data that should be correct, but actually is not. For example you may have some client-side code that sends an HTTP request to the server but it’s obviously malformed. This might be caused by a user tampering with the data, or the client code failing. Most of the time it’s okay to reply with in that situation, but sometimes that won’t do and the code has to continue working. You may still want to log that something fishy happened. This is where loggers come in handy. As of Flask 0.3 a logger is preconfigured for you to use. Here are some example log calls: The attached is a standard logging , so head over to the official docs for more information."
    },
    {
        "link": "https://flask.palletsprojects.com/en/stable/templating",
        "document": "Flask leverages Jinja2 as its template engine. You are obviously free to use a different template engine, but you still have to install Jinja2 to run Flask itself. This requirement is necessary to enable rich extensions. An extension can depend on Jinja2 being present.\n\nThis section only gives a very quick introduction into how Jinja2 is integrated into Flask. If you want information on the template engine’s syntax itself, head over to the official Jinja2 Template Documentation for more information.\n\nThe following global variables are available within Jinja2 templates by default: Changed in version 0.10: This is now always available, even in imported templates. The current request object ( ). This variable is unavailable if the template was rendered without an active request context. The current session object ( ). This variable is unavailable if the template was rendered without an active request context. The request-bound object for global variables ( ). This variable is unavailable if the template was rendered without an active request context. These variables are added to the context of variables, they are not global variables. The difference is that by default these will not show up in the context of imported templates. This is partially caused by performance considerations, partially to keep things explicit. What does this mean for you? If you have a macro you want to import, that needs to access the request object you have two possibilities:\n• None you explicitly pass the request to the macro as parameter, or the attribute of the request object you are interested in. Importing with context looks like this:\n\nAutoescaping is the concept of automatically escaping special characters for you. Special characters in the sense of HTML (or XML, and thus XHTML) are , , , as well as . Because these characters carry specific meanings in documents on their own you have to replace them by so called “entities” if you want to use them for text. Not doing so would not only cause user frustration by the inability to use these characters in text, but can also lead to security problems. (see Cross-Site Scripting (XSS)) Sometimes however you will need to disable autoescaping in templates. This can be the case if you want to explicitly inject HTML into pages, for example if they come from a system that generates secure HTML like a markdown to HTML converter. There are three ways to accomplish that:\n• None In the Python code, wrap the HTML string in a object before passing it to the template. This is in general the recommended way.\n• None Inside the template, use the filter to explicitly mark a string as safe HTML ( ) To disable the autoescape system in templates, you can use the block: Whenever you do this, please be very cautious about the variables you are using in this block.\n\nIf you want to register your own filters in Jinja2 you have two ways to do that. You can either put them by hand into the of the application or use the decorator. The two following examples work the same and both reverse an object: In case of the decorator the argument is optional if you want to use the function name as name of the filter. Once registered, you can use the filter in your templates in the same way as Jinja2’s builtin filters, for example if you have a Python list in context called :\n\nTo inject new variables automatically into the context of a template, context processors exist in Flask. Context processors run before the template is rendered and have the ability to inject new values into the template context. A context processor is a function that returns a dictionary. The keys and values of this dictionary are then merged with the template context, for all templates in the app: The context processor above makes a variable called available in the template with the value of . This example is not very interesting because is available in templates anyways, but it gives an idea how this works. Variables are not limited to values; a context processor can also make functions available to templates (since Python allows passing around functions): The context processor above makes the function available to all templates: You could also build as a template filter (see Registering Filters), but this demonstrates how to pass functions in a context processor.\n\nIt can be useful to not render the whole template as one complete string, instead render it as a stream, yielding smaller incremental strings. This can be used for streaming HTML in chunks to speed up initial page load, or to save memory when rendering a very large template. The Jinja2 template engine supports rendering a template piece by piece, returning an iterator of strings. Flask provides the and functions to make this easier to use. These functions automatically apply the wrapper if a request is active, so that it remains available in the template."
    },
    {
        "link": "https://devdocs.io/flask~2.0",
        "document": ""
    },
    {
        "link": "https://apidog.com/blog/react-axios-post",
        "document": "Hey there, fellow developers! Today, we're going to dive into the exciting world of posting form data using React and Axios. Yep, you heard me right – we're going to learn how to send that juicy form data from your React application to a server using the awesome HTTP client library, Axios.\n\nAxios makes the process a whole lot smoother and more efficient. It handles things like HTTP requests, responses, and even error handling for you, so you can focus on writing killer code instead of getting bogged down in the nitty-gritty details.\n\nWhen it comes to handling HTTP requests in the JavaScript world, Axios stands out for its simplicity and ease of use. It’s like having a Swiss Army knife for your API interactions – versatile, reliable, and always handy. And when paired with React, it becomes a dynamic duo that can handle any form data challenge thrown its way.\n\nAlright, let's get this party started! First things first, we need to set up our React app and install Axios. If you haven't already created a new React project, you can do so by running the following command in your terminal:\n\nOnce that's done, navigate into your shiny new project directory and install Axios by running:\n\nBoom! You're all set to start using Axios in your React application.\n\nNow that we've got our tools ready, it's time to create a form component. This bad boy will be responsible for collecting all that delicious form data from your users. Let's whip up a new file called and add the following code:\n\nIn this component, we're using the hook to manage the form data state. The function updates the form data state whenever a user types something into one of the input fields. And finally, the function will be responsible for posting the form data to our API (don't worry, we'll get to that part soon!).\n\nAlright, now for the main event! Let's add the code to post our form data using Axios. First, we need to import Axios into our file:\n\nNext, we'll update the function to make a POST request to our API using Axios:\n\nIn this code snippet, we're using the method to send a POST request to our API endpoint ( ). We're passing the object as the request body, which contains the form data we want to submit.\n\nIf the request is successful, we log the response data to the console. If there's an error, we log the error message instead. You can add additional logic here, such as displaying a success or error message to the user.\n\nApidog is an all-in-one collaborative API development platform that provides a comprehensive toolkit for designing, debugging, testing, publishing, and mocking APIs. Apidog enables you to automatically create Axios code for making HTTP requests.\n\nHere's the process for using Apidog to generate Axios code:\n\nStep 2: Enter the URL of the API endpoint you want to send a request to,input any headers or query string parameters you wish to include with the request, then click on the \"Design\" to switch to the design interface of Apidog.\n\nStep 4: Copy the generated Axios code and paste it into your project.\n\nApidog offers several advanced features that further enhance its ability to test HTTP requests. These features allow you to customize your requests and handle more complex scenarios effortlessly.\n\nStep 2: Find or manually input the API details for the POST request you want to make.\n\nStep 3: Fill in the required parameters and any data you want to include in the request body.\n\nRemember, posting form data is just one of the many awesome things you can do with Axios and React. You can also use Axios to make GET, PUT, and DELETE requests, handle headers and interceptors, and so much more.\n\nAnd there you have it! You’re now equipped to handle form submissions in React with Axios like a seasoned developer. Keep experimenting, keep learning, and most importantly, keep coding!"
    },
    {
        "link": "https://stackoverflow.com/questions/47630163/axios-post-request-to-send-form-data",
        "document": "Can anyone explain how to set boundary or how can I send form data using axios.\n\nIf I make the same request in postman it's working fine and sets values to my POJO class.\n\naxios POST request is hitting the url on the controller but setting null values to my POJO class, when I go through developer tools in chrome, the payload contains data. What am I doing wrong?\n\nIn my case I had to add the boundary to the header like the following: This solution is also useful if you're working with React Native.\n\nThings become complicated when you want to post files via , especially multiple binary files. Below is a working example:\n• I use and above, you can change them to plain Promise statements if you don't like them\n• In order to add your own headers, you just Browser's is different from the NPM package 'form-data'. The following code works for me in browser:\n\nBy default, axios serializes JavaScript objects to JSON. To send data in the application/x-www-form-urlencoded format instead, you can use one of the following options. In a browser, you can use the URLSearchParams API as follows: Note that is not supported by all browsers (see caniuse.com), but there is a polyfill available (make sure to polyfill the global environment). Alternatively, you can encode data using the qs library:\n\nA boundary (which is used, by the server, to parse the payload) is set when the request is sent. You can't obtain the boundary before making the request. So, a better way to get this is using from your FormData.\n\nI had the similar issues when using FormData with axios to make calls on https://apps.dev.microsoft.com service and it error-red out with \"The request body must contain the following parameter: 'grant_type'\" After reformatting the data from and the following code worked:\n\nI needed to upload many files at once using axios and I struggled for a while because of the FormData API: // const instance = axios.create(config); let fd = new FormData(); for (const img of images) { // images is an array of File Object fd.append('images', img, img.name); // multiple upload } const response = await instance({ method: 'post', url: '/upload/', data: fd }) I did NOT specify the header!\n\nThe above method worked for me but since it was something I needed often, I used a basic method for flat object. Note, I was also using Vue and not REACT packageData: (data) => { const form = new FormData() for ( const key in data ) { form.append(key, data[key]); } return form } Which worked for me until I ran into more complex data structures with nested objects and files which then let to the following packageData: (obj, form, namespace) => { for(const property in obj) { // if form is passed in through recursion assign otherwise create new const formData = form || new FormData() let formKey if(obj.hasOwnProperty(property)) { if(namespace) { formKey = namespace + '[' + property + ']'; } else { formKey = property; } // if the property is an object, but not a File, use recursion. if(typeof obj[property] === 'object' && !(obj[property] instanceof File)) { packageData(obj[property], formData, property); } else { // if it's a string or a File formData.append(formKey, obj[property]); } } } return formData; }\n\nIn my case, the problem was that the format of the FormData append operation needed the additional \"options\" parameter filling in to define the filename thus: I'm seeing a lot of complaints that axios is broken, but in fact the root cause is not using form-data properly. My versions are: On the receiving end I am processing this with multer, and the original problem was that the file array was not being filled - I was always getting back a request with no files parsed from the stream. In addition, it was necessary to pass the form-data header set in the axios request: My entire function looks like this: The value of the \"fieldName\" is not significant, unless you have some receiving end processing that needs it."
    },
    {
        "link": "https://medium.com/@reactcompany01/how-to-send-form-data-using-axios-post-request-in-react-e9f5e6fe5094",
        "document": "Sending form data from a React application to a server is a common task, and Axios is a popular library for making HTTP requests in React. In this blog post, we’ll walk you through the process of sending form data using an Axios POST request in a React application. We’ll provide you with a practical example to illustrate each step.\n\nBefore we start, ensure you have the following prerequisites in place:\n• Node.js and npm (Node Package Manager) installed on your system.\n\nIf you don’t already have a React project, you can create one using Create React App. Open your terminal and run the following command:\n\nOnce the project is created, navigate to the project directory:\n\nTo use Axios in your React project, you need to install it. Run the following command:\n\nIn your React project, create a new component for the form. You can name it . Here’s a simple example of a form component:\n\nIn this component, we define a form with two input fields (name and email). We use the useState hook to manage the form data, and Axios to make the POST request when the form is submitted.\n\nStep 4: Import and Use the Form Component\n\nImport and use the Form component in your App.js file:\n\nIn the component, replace with the actual endpoint where you want to send the form data.\n\nFinally, run your React application using the following command:\n\nYour React app should now be running, and you can access it in your browser. Fill out the form, click the “Submit” button, and you should see the form data being sent to the specified API endpoint in the browser’s console.\n\nIn this blog post, we’ve demonstrated how to send form data using an Axios POST request in a React application. By following the steps outlined above, you can easily integrate form submissions with server-side endpoints and handle data efficiently in your React projects. Sending data from your React app to a server has never been more straightforward, thanks to Axios.\n\nThe React Company is your trusted resource for all things React. Whether you’re a beginner looking to learn React or an experienced developer seeking solutions to common challenges, we’ve got you covered.\n\nContact us for more details, and let’s collaborate to elevate your React skills to the next level."
    },
    {
        "link": "https://blog.logrocket.com/how-to-use-axios-post-requests",
        "document": "Editor’s note: This guide to understanding Axios POST requests was last updated by Joseph Mawa on 1 July 2024 to cover working with Axios interceptors, including how to set up request and response interceptors, as well as to cover advanced POST request features, such as how to add a request body to an Axios POST request and handling POST request timeouts and cancellations.\n\nSending requests to a web server is one of the things most commonly performed in frontend development. Creating a Facebook post, uploading a new Instagram image, sending a post on X, or signing up on a website all send requests to a server.\n\nAxios is a free and open source promised-based HTTP library that runs both in the browser and Node.js. In this article, you’ll learn how to use the Axios method in vanilla JavaScript and frameworks like React. Before proceeding, you should have an understanding of React and how React form elements work.\n\nAxios is a lightweight HTTP client. You can use it to make asynchronous HTTP requests in the browser and Node.js. Because it’s promise-based, you can use promise chaining as well as JavaScript’s async/await.\n\nAxios is also quite similar to the native JavaScript Fetch API. It offers methods like , , , , , and more. In this article, we will focus on the method. To understand this method, let’s consider the following scenario.\n\nTake logging into Facebook. When we start using the app, it asks us to either sign up or log in if we already have an account. We must fill in the required form details and submit them to the server.\n\nThe server then verifies the information we submitted and loads the main app or responds with an error message if the provided credentials are incorrect. is the Axios method that allows us to do that. Below is what an Axios request looks like:\n\nFrom the code above, the Axios method takes three parameters: , , and . is the server path to which we are sending the request (note that it is a string). , which is an object, contains the request body that we’re sending to the server. Finally, is the third parameter where you can specify the header content type, authorization, and more. It is also in an object format.\n\nNow that we understand what Axios is and its method, let’s see how to use it.\n\nYou might wonder why you should use Axios instead of the native JavaScript Fetch API. Comparatively, Axios has some advantages over Fetch, which we will look at shortly.\n\nFirst, Axios serializes your request body into JSON string out of the box if the header is set to . This differs from the Fetch API, which requires you to first convert the payload to JSON string using , as shown below:\n\nSimilarly, Axios also de-serializes a JSON response out of the box. With the native Fetch API, you need to parse it using .\n\nUnlike the built-in Fetch API, Axios provides convenient methods for each of the HTTP request methods. To perform a request, you use the method, and so on:\n\nOther reasons to use Axios over the Fetch API include the following:\n• Better error handling by throwing a wide range of errors, including network errors\n• The ability to intercept HTTP requests and responses\n• Unlike Fetch, Axios can run in any browser or Node.js version\n• Axios has a built-in feature for protection against cross-site request forgery (XSRF)\n\nEarlier in this article, we explored how to use the Axios method in vanilla JavaScript and React. Let’s start with the former and then proceed to the latter. Keep in mind that this article will focus on React, and we will use the dummy API for our examples.\n\nHow to send an Axios request in vanilla JavaScript\n\nTo use Axios in vanilla JavaScript, we must first add the CDN link in the HTML before using it in the file. Let’s start by creating two files to use: and :\n\nThis HTML file has a simple login form with two input fields, the email and the password fields, and a submit button. At the bottom, just above the link, we also added the Axios CDN.\n\nNext, in the file we created above, we select the form element, and email and password elements using their s. We can then add a event handler to the form element. It is triggered whenever we submit the form:\n\nYou can submit and as the email and password values, respectively. The dummy API will return a response with a status code for a successful POST request:\n\nWe can now perform the same request in a React project. We need to first install Axios using npm or Yarn. Depending on your package manager, install Axios by running one of the commands below:\n\nWith Axios installed, let’s open our file. Unlike in vanilla JavaScript, we need to import Axios before using it. In our function, we will invoke the Axios method just as we did in the vanilla example above:\n\nThe above code illustrates how you can make an Axios POST request in React.\n\nLet’s look at another example where we create a new user or register as a new user. We will use the React Hook to manage state. Next, we set the value of our text inputs to our states ( and ) in our function.\n\nFinally, on , we make our Axios POST request with the data in our state. See the code below:\n\nYou can also create a file and copy the CSS styling below to style the app. It’s nothing fancy, but it improves the look of the UI:\n\nWith that, we have our registration app to use our method:\n\nUsing the async/await syntax with Axios\n\nIn the previous examples, we used promise chaining throughout. Similarly, you can also use the async/await syntax with Axios. When using and , we need to wrap our code in a block as in the example below:\n\nFrom the above example, we are awaiting a response from our request before we can perform an operation on the response. It works like the method we saw in the previous example.\n\nHow to handle POST request errors in Axios\n\nAs previously stated, one of the advantages of using Axios over the native Fetch API is that it allows us to handle response errors better.\n\nWith Axios, you can catch errors in the block and check for certain conditions to establish why the error occurred so that you can handle it appropriately. Let’s see how you can do that below:\n\nIn the condition, we check if there is a response, that is if our request was sent and the server responded with an HTTP status code outside the range. The HTTP status codes we can get here range from a status code telling us the user does not exist or that there are missing credentials, a error code telling us the page was not found, to a error code telling us the page is unavailable, etc.\n\nIn the condition, we checked to see if the request was made, but we received no response. This error is usually due to a network error or being offline.\n\nFinally, if the error received does not fall under the two categories above, then the block catches it and tells us what happened, which is most likely because an error occurred in the process of setting up the POST request. We can also use to make our error response more readable.\n\nThis section is slightly out of the scope of this tutorial, but it covers how to perform multiple requests concurrently using Axios with error handling.\n\nBecause Axios returns a promise, we can perform multiple requests using the static method. takes an iterable of promises as an argument and returns a single promise. It is fulfilled if all the input promises are fulfilled and is rejected immediately if one of the input promises is rejected:\n\nIn the example above, we have an array of user IDs. We mapped through the array and used Axios to initiate requests to our API. fulfills after all the promises have been fulfilled and rejects immediately if one of the promises is rejected.\n\nAdditionally, Axios has the built-in and helper functions for making concurrent requests. They have been deprecated though they may still work. Instead, you should use , as in the example above.\n\nOne of the benefits of using Axios over the built-in Fetch API is that Axios gives you the ability to intercept requests and responses. With Axios interceptors, you can modify requests and responses before handling them in your fulfillment and rejection handlers.\n\nYou can mount an Axios request interceptor to intercept and modify request config objects like so:\n\nYou should be aware that you can only add interceptors to a custom Axios instance, as in the example above.\n\nSimilarly, you can mount a response interceptor to modify response objects like so:\n\nThere are several use cases for Axios request interceptors. One of the main use cases is to authenticate users. Instead of manually adding authentication tokens, such as JWTs, to every request, you can add the token to the config object in the request interceptor.\n\nYou can also use request interceptors to transform request data. You can format the request object or include additional information, such as the request timestamp, to the payload before sending it to the server.\n\nRequest interceptors also come in handy for monitoring and logging purposes. You can log API endpoints, request methods, and any other request data that you can use later for debugging.\n\nThere are several use cases for intercepting responses in Axios. I will highlight some of them below.\n\nThe HTTP response you get from the server may have a payload with a different data type than the data type your application expects, especially when sourcing data from a third-party API. For example, the server response may be in XML format but your frontend code expects JSON. You can intercept the HTTP response and transform the payload into JSON.\n\nSimilarly, the server response may contain more data than your application needs. You can intercept the response and extract only the data your application needs.\n\nYou can also use response interceptors for error handling. You can get different kinds of errors from the server. Instead of having error handlers littered throughout your codebase, you can handle these errors centrally in a response interceptor. You can intercept the HTTP responses, log the errors for debugging, and handle them appropriately.\n\nSuch central error handling ensures your code is organized and maintainable. It will also ensure you provide appropriate client feedback regarding the success and failure of the POST request.\n\nHow to add a request body to an Axios POST request\n\nOrdinarily, when posting a simple object using Axios, you pass a plain JavaScript object to a POST request body, and by default, Axios will serialize your payload to a JSON string as in the code below.\n\nBy default, Axios will set the header to :\n\nYou can also submit an HTML form data as JSON. However, you need to set the header to like so:\n\nDepending on the data you want to transmit via a POST request, sometimes you may want Axios to encode your payload in a different format than JSON, such as when uploading text files, images, audio, videos, and other multimedia files.\n\nFor the latest versions, Axios can encode the request body to multi-part form data out of the box if you explicitly set the header to . It’s the encoding you use when uploading files:\n\nSimilarly, with the latest versions of Axios, you can set the header to if you want Axios to URL encode your payload out of the box:\n\nFor earlier versions of Axios, you will need to URL encode the payload using APIs such as or a third-party npm package before posting it.\n\nFor some reason, the server can sometimes delay responding to user requests or the network connection becomes unavailable. Therefore, you will have to timeout and cancel certain requests.\n\n In Axios, you can set the response to timeout using the property of the config object like so:\n\nIn the above example, Axios aborts the network connection if it fails to get a response from the server within 1.5 seconds. If the error is thrown because of a timeout, Axios will set the error code to .\n\nAlternatively, you can also timeout using the API. is now supported both in the browser and Node.js:\n\nInstead of a timeout, you can use the API to explicitly abort the request. This is useful in situations where a user navigates away from a given page after a network request has been initiated:\n\nAxios is a popular promised-based HTTP library that you can use both in the browser and Node.js. You can use it to make HTTP , , , , and requests both on the client and server side. In this article, our focus was on the method.\n\nUnlike the built-in Fetch API, Axios has several built-in features. With Axios, you can intercept and modify request and response objects. It also provides built-in features for automatic JSON serialization and de-serialization and superior error handling capabilities to the Fetch API.\n\nThough powerful and feature-rich, you should be aware that Axios is a third-party package. Like most third-party packages, Axios has its downsides. You need to consider the extra bundle size, security, licensing requirements, and long-term maintenance before using."
    },
    {
        "link": "https://stackoverflow.com/questions/57041294/how-to-send-post-request-from-react-form-using-axios",
        "document": "Here is something like a CRUD using React and axios. I have some component with form and inputs. The form recieved data from express backend using axios GET method, and semingly there is no problems. But the second task is to change data in inputs and post to the route using axios POST. For some reason it fails to collect the data from all inputs to json for the POST request. Someone tell me what is wrong here?\n\nThe JSON requested from backend looks like this:\n\nHere is the component:"
    },
    {
        "link": "https://gradio.app/guides/getting-started-with-the-python-client",
        "document": "Getting Started with the Gradio Python client\n\nThe Gradio Python client makes it very easy to use any Gradio app as an API. As an example, consider this Hugging Face Space that transcribes audio files that are recorded from the microphone.\n\nUsing the library, we can easily use the Gradio as an API to transcribe audio files programmatically.\n\nHere's the entire code to do it:\n\nThe Gradio client works with any hosted Gradio app! Although the Client is mostly used with apps hosted on Hugging Face Spaces, your app can be hosted anywhere, such as your own server.\n\nPrerequisites: To use the Gradio client, you do not need to know the library in great detail. However, it is helpful to have general familiarity with Gradio's concepts of input and output components.\n\nIf you already have a recent version of , then the is included as a dependency. But note that this documentation reflects the latest version of the , so upgrade if you're not sure!\n\nThe lightweight package can be installed from pip (or pip3) and is tested to work with Python versions 3.10 or higher:\n\nStart by connecting instantiating a object and connecting it to a Gradio app that is running on Hugging Face Spaces.\n\nYou can also connect to private Spaces by passing in your HF token with the parameter. You can get your HF token here: https://huggingface.co/settings/tokens\n\nWhile you can use any public Space as an API, you may get rate limited by Hugging Face if you make too many requests. For unlimited usage of a Space, simply duplicate the Space to create a private Space, and then use it to make as many requests as you'd like!\n\nThe includes a class method: to make this process simple (you'll need to pass in your Hugging Face token or be logged in using the Hugging Face CLI):\n\nIf you have previously duplicated a Space, re-running will not create a new Space. Instead, the Client will attach to the previously-created Space. So it is safe to re-run the method multiple times.\n\nNote: if the original Space uses GPUs, your private Space will as well, and your Hugging Face account will get billed based on the price of the GPU. To minimize charges, your Space will automatically go to sleep after 1 hour of inactivity. You can also set the hardware using the parameter of .\n\nIf your app is running somewhere else, just provide the full URL instead, including the \"http://\" or \"https://\". Here's an example of making predictions to a Gradio app that is running on a share URL:\n\nIf the Gradio application you are connecting to requires a username and password, then provide them as a tuple to the argument of the class:\n\nOnce you have connected to a Gradio app, you can view the APIs that are available to you by calling the method. For the Whisper Space, we see the following:\n\nWe see that we have 1 API endpoint in this space, and shows us how to use the API endpoint to make a prediction: we should call the method (which we will explore below), providing a parameter of type , which is a .\n\nWe should also provide the argument to the method. Although this isn't necessary if a Gradio app has only 1 named endpoint, it does allow us to call different endpoints in a single app if they are available.\n\nAs an alternative to running the method, you can click on the \"Use via API\" link in the footer of the Gradio app, which shows us the same information, along with example usage.\n\nThe View API page also includes an \"API Recorder\" that lets you interact with the Gradio UI normally and converts your interactions into the corresponding code to run with the Python Client.\n\nThe simplest way to make a prediction is simply to call the function with the appropriate arguments:\n\nIf there are multiple parameters, then you should pass them as separate arguments to , like this:\n\nIt is recommended to provide key-word arguments instead of positional arguments:\n\nThis allows you to take advantage of default arguments. For example, this Space includes the default value for the Slider component so you do not need to provide it when accessing it with the client.\n\nThe default value is the initial value of the corresponding Gradio component. If the component does not have an initial value, but if the corresponding argument in the predict function has a default value of , then that parameter is also optional in the client. Of course, if you'd like to override it, you can include it as well:\n\nFor providing files or URLs as inputs, you should pass in the filepath or URL to the file enclosed within . This takes care of uploading the file to the Gradio server and ensures that the file is preprocessed correctly:\n\nOe should note that is a blocking operation as it waits for the operation to complete before returning the prediction.\n\nIn many cases, you may be better off letting the job run in the background until you need the results of the prediction. You can do this by creating a instance using the method, and then later calling on the job to get the result. For example:\n\nAlternatively, one can add one or more callbacks to perform actions after the job has completed running, like this:\n\nThe object also allows you to get the status of the running job by calling the method. This returns a object with the following attributes: (the status code, one of a set of defined strings representing the status. See the class), (the current position of this job in the queue), (the total queue size), (estimated time this job will complete), (a boolean representing whether the job completed successfully), and (the time that the status was generated).\n\nNote: The class also has a instance method which returns a boolean indicating whether the job has completed.\n\nThe class also has a instance method that cancels jobs that have been queued but not started. For example, if you run:\n\nIf the first job has started processing, then it will not be canceled. If the second job has not yet started, it will be successfully canceled and removed from the queue.\n\nSome Gradio API endpoints do not return a single value, rather they return a series of values. You can get the series of values that have been returned at any time from such a generator endpoint by running :\n\nNote that running on a generator endpoint only gives you the first value returned by the endpoint.\n\nThe object is also iterable, which means you can use it to display the results of a generator function as they are returned from the endpoint. Here's the equivalent example using the as a generator:\n\nYou can also cancel jobs that that have iterative outputs, in which case the job will finish as soon as the current iteration finishes running.\n\nGradio demos can include session state, which provides a way for demos to persist information from user interactions within a page session.\n\nFor example, consider the following demo, which maintains a list of words that a user has submitted in a component. When a user submits a new word, it is added to the state, and the number of previous occurrences of that word is displayed:\n\nIf you were to connect this this Gradio app using the Python Client, you would notice that the API information only shows a single input and output:\n\nThat is because the Python client handles state automatically for you -- as you make a series of requests, the returned state from one request is stored internally and automatically supplied for the subsequent request. If you'd like to reset the state, you can do that by calling ."
    },
    {
        "link": "https://modelslab.com/blog/stable-diffusion-api/gradio-stable-diffusion-api",
        "document": ""
    },
    {
        "link": "https://github.com/JacobLinCool/gradio-rs/blob/main/README.md",
        "document": "See the examples directory for more examples.\n\nHere is an example of using model to separate vocals and background music from an audio file.\n\ngradio std env < \"Please provide an audio file path as an argument\" std process args = std env file_path = args file_path client = output = client from_file file_path from_value output clone as_file unwrap url unwrap output clone as_file unwrap url unwrap\n\nSee ./examples/sd3.rs for non-blocking example with method.\n\nTake HF Space as an example:\n\ngr list stabilityai/stable-diffusion-3-medium API Spec stabilityai/stable-diffusion-3-medium: /infer Parameters: prompt ( str ) negative_prompt ( str ) seed ( float ) numeric value between 0 and 2147483647 randomize_seed ( bool ) width ( float ) numeric value between 256 and 1344 height ( float ) numeric value between 256 and 1344 guidance_scale ( float ) numeric value between 0.0 and 10.0 num_inference_steps ( float ) numeric value between 1 and 50 Returns: Result ( filepath ) Seed ( float ) numeric value between 0 and 2147483647 gr run stabilityai/stable-diffusion-3-medium infer 0 1024 1024 5 28 Result: https://stabilityai-stable-diffusion-3-medium.hf.space/file=/tmp/gradio/5735ca7775e05f8d56d929d8f57b099a675c0a01/image.webp Seed: 486085626\n\nFor file input, simply use the file path as the argument:\n\ngr run hf-audio/whisper-large-v3 predict output: Did you know you can try the coolest model on your command line?"
    },
    {
        "link": "https://observablehq.com/@huggingface/hello-gradio-client-js",
        "document": "Experiment and prototype by building visualizations in live JavaScript notebooks. Collaborate with your team and decide which concepts to build out.\n\nUse Observable Framework to build data apps locally. Use data loaders to build in any language or library, including Python, SQL, and R.\n\nSeamlessly deploy to Observable. Test before you ship, use automatic deploy-on-commit, and ensure your projects are always up-to-date."
    },
    {
        "link": "https://platform.stability.ai/docs/api-reference",
        "document": ""
    }
]