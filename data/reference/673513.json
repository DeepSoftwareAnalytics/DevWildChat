[
    {
        "link": "https://wiki.libsdl.org/SDL2/SDL_CreateWindow",
        "document": "Create a window with the specified position, dimensions, and flags.\n\n(SDL_Window *) Returns the that was created or NULL on failure; call SDL_GetError() for more information.\n\nmay be any of the following OR'd together:\n• : window should be created in high-DPI mode if supported (>= SDL 2.0.1)\n\nis ignored by SDL_CreateWindow(). The SDL_Window is implicitly shown if SDL_WINDOW_HIDDEN is not set. may be queried later using SDL_GetWindowFlags().\n\nOn Apple's macOS, you must set the NSHighResolutionCapable Info.plist property to YES, otherwise you will not receive a High-DPI OpenGL canvas.\n\nIf the window is created with the flag, its size in pixels may differ from its size in screen coordinates on platforms with high-DPI support (e.g. iOS and macOS). Use SDL_GetWindowSize() to query the client area's size in screen coordinates, and SDL_GL_GetDrawableSize() or SDL_GetRendererOutputSize() to query the drawable size in pixels. Note that when this flag is set, the drawable size can vary after the window is created and should be queried after major window events such as when the window is resized or moved between displays.\n\nIf the window is set fullscreen, the width and height parameters and will not be used. However, invalid size parameters (e.g. too large) may still fail. Window size is actually limited to 16384 x 16384 for all platforms at window creation.\n\nIf the window is created with any of the SDL_WINDOW_OPENGL or SDL_WINDOW_VULKAN flags, then the corresponding LoadLibrary function (SDL_GL_LoadLibrary or SDL_Vulkan_LoadLibrary) is called and the corresponding UnloadLibrary function is called by SDL_DestroyWindow().\n\nIf SDL_WINDOW_VULKAN is specified and there isn't a working Vulkan driver, SDL_CreateWindow() will fail because SDL_Vulkan_LoadLibrary() will fail.\n\nIf SDL_WINDOW_METAL is specified on an OS that does not support Metal, SDL_CreateWindow() will fail.\n\nOn non-Apple devices, SDL requires you to either not link to the Vulkan loader or link to a dynamic library version. This limitation may be removed in a future version of SDL.\n\nThis function is available since SDL 2.0.0."
    },
    {
        "link": "https://github.com/libsdl-org/SDL/issues/7201",
        "document": "I am using SDL2 (I noticed this on version , then I upgraded to version and it still occurs).\n\n My environment is Microsoft Visual Studio Community 2019 Version 16.11.23 on Windows 10.\n\nAfter calling , then calling with the flag (this issue only occurs when I include this flag), my program gets an Access Violation. It also reports , , and . After pressing continue via the debugger, the program proceeds to hang indefinitely, repeatedly logging and never getting past the line of code:\n\nThe place where the code breaks when this occurs is in the file in the function on the line . This seems to be caused by reading , which was assigned shortly prior via .\n\nWhen compiling without the flag , the program runs/behaves \"normally.\"\n\nI normally have these SDL_GL attributes set between the call to and , though the same issue occurs with all of these removed:\n\nThere is no other code before or between the init and create window calls (other than handling of when it returns something other than 0).\n\nEdit:\n\n I have also tried calling myself, both with / and with the direct path to the opengl dll on my system. The same issue above still occurs (the program gets an Access Violation)."
    },
    {
        "link": "https://wiki.libsdl.org/SDL2/APIByCategory",
        "document": ""
    },
    {
        "link": "https://github.com/libsdl-org/SDL/releases",
        "document": "The SDL development team is focusing efforts on SDL3 and making sdl2-compat a drop-in replacement for SDL2. If you run into issues with SDL2, please consider upgrading to SDL3 or trying out sdl2-compat. We have made significant improvements across all platforms and your issue may already be resolved.\n\nThis is a stable bugfix release, with the following changes:\n• Allow destroying a window and its renderer in either order\n• Added SDL_HINT_APPLE_RWFROMFILE_USE_RESOURCES to control whether SDL tries to open files from the app's resource directory on macOS\n• Fixed input for Thrustmaster PlayStation wheels when hid-tmff2 is installed\n• Enabled direct VRAM access when using the window surface API on PSP"
    },
    {
        "link": "https://hackage.haskell.org/package/sdl2/docs/SDL.html",
        "document": "The SDL module exports a high-level Haskell-like abstraction to use the SDL library. SDL is a cross-platform development library designed to provide low level access to audio, keyboard, mouse, joystick, and graphics hardware via OpenGL and Direct3D.\n\nTo get started, import SDL and begin by initializing the subsystems you need:\n\nNext, you can create a by using\n\nIf you wish to use SDL's 2D graphics API, you can also create a :\n\nThen, we enter our main application loop:\n\nFinally, once our appLoop has returned we destroy the using :\n\nFor the body of your application, we enter a loop. Inside this loop you should begin by collecting all events that have happened - these events will inform you about information such as key presses and mouse movement:\n\nHere is a list of values. For our application we will check if the user pressed the q key, indicating they wish to quit the application\n\nIn our we process events and then update the screen accordingly. Here we simply use the to clear the screen to blue:\n\nIf q was not pressed, we loop again. Otherwise, we exit the loop:\n\nTo recap, here is our full application"
    },
    {
        "link": "https://stackoverflow.com/questions/50975186/new-version-of-sdl-doesnt-allow-me-to-use-sdl-image",
        "document": "I created another 2 projects. One on SDL 2.0.8 and SDL_image 2.0.3. There is code on which I tested that:\n\nOn this setup I wasn't able to run it, I got an error.\n\nSecond project had SDL 2.0.5 and SDL_image 2.0.0 and it worked.\n\nWhy I cant use the newest versions of SDL and SDL_image although SDL_image is compatible with SDL 2.0.8 ?"
    },
    {
        "link": "https://stackoverflow.com/questions/52895444/c-image-loading-with-sdl2-and-sdl-image",
        "document": "I've just finished writing a GUI in SDL. So IMG_Load is the old way to load in SDL images, from SDL 1 i believe. The way it used to work is that you'd have SDL surfaces, and then you'd merge them together and then blit them to the screen, or blit sections of the surfaces to other surfaces, using masks etc. The problem is some stuff - for example drawing lines, now requires a renderer.\n\nRenderers pull in the new features of SDL2. It also means that you can't just blit your surfaces necessarily to a texture without converting it first.\n\nSo, in summary, if you can get away with using IMG_load and using the old SDL features, do so because it's more intuitive. If you are planning to draw any lines at all, or anything that use the SDL renderer, then you'll need to learn how to convert between surfaces and textures!\n\nRegarding your original question, because i realise i'm not answering it very well, normally it's best to use the right function calls, such as IMG_LoadTexture directly, rather than IMG_Load and then convert it to a texture. SDL talks to the hardware directly and has a surprising amount of optimisation. Converting the surface to a texture, presumably involves blitting, which means copying a substantial amount of memory.\n\nHowever, it seems that in this case at the time of writing this, there is absolutely no difference at all. The function IMG_LoadTexture does exactly the same thing.\n\nBut once again, check, you might not need textures at all, if not, you could save yourself some work ;)"
    },
    {
        "link": "https://gamedev.stackexchange.com/questions/177394/could-not-load-png-in-sdl2",
        "document": "Stack Exchange network consists of 183 Q&A communities including Stack Overflow, the largest, most trusted online community for developers to learn, share their knowledge, and build their careers."
    },
    {
        "link": "https://discourse.libsdl.org/t/unable-to-load-using-sdl-image/20213",
        "document": "I am not sure if this is a problem of having both SDL1 and 2 installed. Some people said that it was Img_Load and others said that it was IMG_Load. Boith though get either undefined or non existant. This is on Arch Linux. SDL_Texture* texture; // the new SDL_Texture variable SDL_Rect source_rect; // the first rectangle SDL_Rect dest_rect; // another rectangle Control(std::string titlename, int window_width=0, int window_height=0, bool fullscr=false) : title(titlename), width(window_width), height(window_height), fullscreen(fullscr){ if ( ! init()){ //problem } } ~Control(){ clean(); } void clean(){ SDL_DestroyWindow(window); SDL_DestroyRenderer(renderer); SDL_Quit(); } bool init(){ if (SDL_Init(SDL_INIT_EVERYTHING) == 0){ int flags = 0; if (fullscreen){ flags = SDL_WINDOW_FULLSCREEN_DESKTOP; } window = SDL_CreateWindow(title.c_str(), SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED, width, height, flags); if (window != 0){ renderer = SDL_CreateRenderer(window, -1, 0); } } else{ return false; } //Img_Load IMG_Load SDL_Surface* temp = IMG_Load(\"Pictures/1.png\"); texture = SDL_CreateTextureFromSurface(renderer, temp); SDL_FreeSurface(temp); SDL_QueryTexture(texture, NULL, NULL, &source_rect.w, &source_rect.h); dest_rect.x = source_rect.x = 0; dest_rect.y = source_rect.y = 0; dest_rect.w = source_rect.w; dest_rect.h = source_rect.h; return true; } void events(){ SDL_Event event; if (SDL_PollEvent(&event)){ switch (event.type){ case SDL_QUIT: running = false; break; case SDL_KEYDOWN: running = false; break; default: break; } } } void update(){ } void render(){ SDL_SetRenderDrawColor(renderer, 0, 0, 0, 255); SDL_RenderClear(renderer); SDL_RenderCopy(renderer, texture, &source_rect, &dest_rect); SDL_RenderPresent(renderer); } void run(){ while (running){ events(); update(); render(); } } I did the usual on the downloaded SDL2_image-2.0.0\n\n ./configure\n\n make\n\n make install\n\nYou’re using SDL2. Only link to SDL2 and SDL2 libraries. Don’t let 2.0 (or\n\n 2.1) clash with 1.2. After you do an surface = IMG_Load(), check if surface is NULL (or\n\n nullptr). If it is, check what the IMG_GetError() is.\n\n If the surface isn’t null, the image loaded successfully. After you do an texture = SDL_CreateTextureFromSurface(), check if the\n\n texture is NULL (or nullptr). If it is, check what the SDL_GetError() is.\n\n If the texture isn’t null, the texture was created successfuly.On Sat, Dec 7, 2013 at 12:15 PM, metulburr2 wrote: I am not sure if this is a problem of having both SDL1 and 2 installed.\n\n Some people said that it was Img_Load and others said that it was IMG_Load.\n\n Boith though get either undefined or non existant. This is on Arch Linux. SDL_Texture* texture; // the new SDL_Texture variable SDL_Rect source_rect; // the first rectangle SDL_Rect dest_rect; // another rectangle Control(std::string titlename, int window_width=0, int ~Control(){ clean(); } void clean(){ SDL_DestroyWindow(window); SDL_DestroyRenderer(renderer); SDL_Quit(); } bool init(){ if (SDL_Init(SDL_INIT_EVERYTHING) == 0){ int flags = 0; if (fullscreen){ flags = SDL_WINDOW_FULLSCREEN_DESKTOP; } window = SDL_CreateWindow(title.c_str(), SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED, width, height, flags); if (window != 0){ renderer = SDL_CreateRenderer(window, -1, 0); } } else{ return false; } //Img_Load IMG_Load SDL_Surface* temp = IMG_Load(\"Pictures/1.png\"); texture = SDL_CreateTextureFromSurface(renderer, temp); SDL_FreeSurface(temp); SDL_QueryTexture(texture, NULL, NULL, &source_rect.w, I did the usual on the downloaded SDL2_image-2.0.0\n\n ./configure\n\n make\n\n make install\n\nOnly link to SDL2 and SDL2 libraries. Don’t let 2.0 (or 2.1) clash with 1.2. I am not sure exactly how i am letting 1.2 clash with 2? After you do an surface = IMG_Load(), check if surface is NULL (or nullptr). If it is, check what the IMG_GetError() is. If the surface isn’t null, the image loaded successfully. After you do an texture = SDL_CreateTextureFromSurface(), check if the texture is NULL (or nullptr). If it is, check what the SDL_GetError() is. If the texture isn’t null, the texture was created successfuly. thanks for the info, ill test it as soon as i can compile it.\n\nEDIT:\n\n i changed it to link to SDL2_image but i get the same error as well? Looks like a typo issue. “-L” and “-l” (upper vs lower case) mean two completely different things - the lowercase tells the compiler to use the specified library, while the uppercase version adds a directory to the library search path. So try with “'-lSDL2_image” rather than “-LSDL2_image” and see what happens."
    },
    {
        "link": "https://wiki.libsdl.org/SDL2_image/IMG_Load",
        "document": "Load an image from a filesystem path into a software surface.\n\n(SDL_Surface *) Returns a new SDL surface, or NULL on error.\n\nAn SDL_Surface is a buffer of pixels in memory accessible by the CPU. Use this if you plan to hand the data to something else or manipulate it further in code.\n\nThere are no guarantees about what format the new SDL_Surface data will be; in many cases, SDL_image will attempt to supply a surface that exactly matches the provided image, but in others it might have to convert (either because the image is in a format that SDL doesn't directly support or because it's compressed data that could reasonably uncompress to various formats and SDL_image had to pick one). You can inspect an SDL_Surface for its specifics, and use SDL_ConvertSurface to then migrate to any supported format.\n\nIf the image format supports a transparent pixel, SDL will set the colorkey for the surface. You can enable RLE acceleration on the surface afterwards by calling: SDL_SetColorKey(image, SDL_RLEACCEL, image->format->colorkey);\n\nThere is a separate function to read files from an SDL_RWops, if you need an i/o abstraction to provide data from anywhere instead of a simple filesystem read; that function is IMG_Load_RW().\n\nIf you are using SDL's 2D rendering API, there is an equivalent call to load images directly into an SDL_Texture for use by the GPU without using a software surface: call IMG_LoadTexture() instead.\n\nWhen done with the returned surface, the app should dispose of it with a call to SDL_FreeSurface().\n\nThis function is available since SDL_image 2.0.0."
    },
    {
        "link": "https://gamedev.stackexchange.com/questions/72613/how-can-i-render-a-texture-to-the-screen-in-sdl2",
        "document": "Stack Exchange network consists of 183 Q&A communities including Stack Overflow, the largest, most trusted online community for developers to learn, share their knowledge, and build their careers."
    },
    {
        "link": "https://wiki.libsdl.org/SDL2/SDL_RenderCopy",
        "document": ""
    },
    {
        "link": "https://lazyfoo.net/tutorials/SDL/07_texture_loading_and_rendering/index.php",
        "document": "A major new addition to SDL 2 is the texture rendering API. This gives you fast, flexible hardware based rendering. In this tutorial we'll be using this new rendering technique. A major new addition to SDL 2 is the texture rendering API. This gives you fast, flexible hardware based rendering. In this tutorial we'll be using this new rendering technique.\n\n\n\n \n\n As you can also see we have a new image loading routine with loadTexture and a globally declared texture we're going to load. Textures in SDL have their own data type intuitively called an SDL_Texture . When we deal with SDL textures you need an SDL_Renderer to render it to the screen which is why we declare a global renderer named \"gRenderer\".As you can also see we have a new image loading routine with loadTexture and a globally declared texture we're going to load.\n\n\n\n \n\n After creating the renderer, we want to initialize the rendering color using After we create our window, we have to create a renderer for our window so we can render textures on it. Fortunately this is easily done with a call to SDL_CreateRenderer After creating the renderer, we want to initialize the rendering color using SDL_SetRenderDrawColor . This controls what color is used for various rendering operations.\n\nOur texture loading function looks largely the same as before only now instead of converting the loaded surface to the display format, we create a texture from the loaded surface using SDL_CreateTextureFromSurface . Like before, this function creates a new texture from an existing surface which means like before we have to free the loaded surface and then return the loaded texture.\n\n\n\n \n\n In our clean up function, we have to remember to deallocate our textures using Since texture loading is abstracted with our image loading function, the loadMedia() function works pretty much the same as before.In our clean up function, we have to remember to deallocate our textures using SDL_DestroyTexture\n\n\n\n \n\n With the screen cleared, we render the texture with \n\n \n\n Now, there is a new API call called IMG_LoadTexture. It's not in the official documentation as of this writing but you can find it in the SDL_image header files. It allows you to load a texture without having to create a temporary surface. The reason I haven't gone back and updated the tutorial to use this method is because I don't want to go back an update 40+ tutorials. Even though it is undocumented, it works just fine.\n\n \n\n I recommend giving it a try. Also, get used to having to deal with undocumented code because often times in the professional game development world, documentation is a luxury. In the main loop after the event loop, we call SDL_RenderClear . This function fills the screen with the color that was last set with SDL_SetRenderDrawColor.With the screen cleared, we render the texture with SDL_RenderCopy . With the texture rendered, we still have to update the screen, but since we're not using SDL_Surfaces to render we can't use SDL_UpdateWindowSurface. Instead we have to use SDL_RenderPresent Now, there is a new API call called IMG_LoadTexture. It's not in the official documentation as of this writing but you can find it in the SDL_image header files. It allows you to load a texture without having to create a temporary surface. The reason I haven't gone back and updated the tutorial to use this method is because I don't want to go back an update 40+ tutorials. Even though it is undocumented, it works just fine.I recommend giving it a try. Also, get used to having to deal with undocumented code because often times in the professional game development world, documentation is a luxury."
    },
    {
        "link": "https://discourse.libsdl.org/t/texture-to-texture-rendering-offscreen/233",
        "document": "Hello. I have an idea about developing a game and I hope SDL2 is good tool to help me in game development.\n\n I’m new in SDL and I have some newbie questions about working with SDL. First of all I want to understand working with renderer and textures.\n\n My idea is doing some offscreen rendering from texture to texture. And then render some of this graphics data to window on the screen. I mean 2 separate rendering processes: first offsceen and second to screen.\n\n [list=1:66121f3918][*:66121f3918] I can’t understand why I can create renderer only assigned to window, if I want to use this renderer only to make offscreen rendering from texture to texture? How correctly create renderer to rendering from texture to texture? [*:66121f3918] Can I create 2 separate renderers: first to offscreen rendering (rendercopy from texture to texture) and second to render graphics to window? [*:66121f3918] Can I use 2 renderers in 2 threads: first renderer is working in separate background thread and second renderer is working in main thread? I mean 2 threads don’t share one renderer, but share a texture, and only one thread always write to this texture and other thread only read from this texture. [*:66121f3918] Why I can’t load image from file to texture? I must load it to surface and only from surface to texture. This is not a problem, but this is strange for me: why SDL2 developers don’t implement a function to load image from file to texture without surface in the middle?[/list:o:66121f3918]May be I ask more questions later. Thanks for answers.\n\nWhen you’re creating a SDL window and at the same time creating a SDL Renderer, you’re assigning that renderer to the SDL window. You can of course create multiple windows and multiple renderers if you want / need to. In your case, you only need to create one window and one renderer. If you want to render one texture onto another texture it is done like this:\n• Render Texture1 as usual (with SDL_RenderCopy or SDL_RenderCopyEx). Texture1 has now been rendered onto TargetTexture and won’t be rendered in the window until TargetTexture is rendered.\n• Render TargetTexture as usual (with SDL_RenderCopy or SDL_RenderCopyEx). 3. As far as I understand, you can create one renderer in the main thread and one renderer in another thread, BUT, the only thread that SDL render functions can / should be used in, is in the same thread as the window has been created in (which is usually in the main thread). This mean that the second renderer (which has been created in another thread), will be useless, unless you’ve created a secondary window in that thread of course. 4. There’s no function in SDL2 that takes an image and creates a SDL_Texture from it, but the SDL_Image external library has a function named IMG_LoadTexture though, that takes an image and creates a SDL_Texture from it. I hope this answered your question. Don’t hesitate to ask more if you have more questions.\n\nNaith, many thanks for your answers. I try to explain why I want to use threads to render. In my mind my future game work like this: I create a texture and load an image to this texture (call it “tileset”). Next I create new texture to use it as game map (call it “map”). To draw “map” I copy tiles images from “tileset” to “map”. But “map” is not what user see in window - every time user see only part of map. This all is not interesting \n\n Interesting next: when user see some interaction in window (including animations), this time other (background) renderer make some changes on “map” in parallel. Two rendering processes in parallel (not always parallel, but frequently). May be this is impossible? For example: User see animation in window with frequency about 60 fps (this is not final number, this is only for example). This mean every 1/60 of second image in window must be re-rendered (not very easy work). This animation almost every time. Same time some event in game engine - need to make changes on map (copy some new tiles from “tileset” to “map”). User should not feel this background rendering as lag in animation. This is what I want. I think now: may be not to try share texture between 2 threads with 2 renderers (may be this is impossible). May be create second thread “isolated” - with its own source and target textures. This thread create own copy of “map” and make changes on this copy. And next “map” texture used in main thread is replaced by new version of “map” from second thread.\n\nI think I understand what you want to do and what you want to avoid. I actually don’t think you’ll need another thread and do all that “behind the scenes”-changes on the textures. If you design your game- and code correctly, you won’t see any flickering, lag or other weird artifacts when everything is rendered in the window. I’ve made several tilemap-tests, with tilemap’s that’s being rendered in 1 thread, and I’ve never gotten any lag whatsoever whenever I used an animated tile (for example). One thing that’ve learned is that you shouldn’t use multithreading if it’s not necessary and in your case I don’t think it’s necessary. Sorry if this isn’t as good answer as you would want.\n\nThe problem with SDL is that SDL is not thread safe and SDL render functions (such as SDL_CreateTexture, SDL_RenderCopy and everything else that relies on the SDL window) can’t / shouldn’t be executed from a thread that is not the same thread that created the SDL window. I’m doing just that in my framework I’m using when making games. Because of that, my framework is really buggy and crashes sometimes during startup and it’s because I’m using SDL_CreateTextureFromSurface and such which, like I said, shouldn’t be executed in a thread that is not the same as the thread that created the window. So yeah… I need to change some stuff in my framework. In the code example below, I’m creating a tileset texture containing all the tile types and creating the actual tile map. In each tile (tile struct) there’s a clip quad that handles which part of the tileset texture to render.\n\n I’m also creating a target texture which I render all the tiles to and then I render the actual target texture. I don’t know if it’s the best way to render a tilemap but this is how I usually do it.\n\n Let me know if you’re wondering something. #include \"SDL.h\" #include \"SDL_image.h\" #include <iostream> #include <vector> SDL_Window* m_pWindow = NULL; SDL_Renderer* m_pRenderer = NULL; // The texture containing a tileset for all the tile types SDL_Texture* m_pTilesetTexture = NULL; // The render target texture SDL_Texture* m_pTargetTexture = NULL; SDL_Event m_Event; bool m_Running = true; // A tile struct STile { SDL_Rect TileQuadPosition; SDL_Rect TileClipQuad; int TileType; }; typedef std::vector<STile*> TileList; // The actual tile list TileList m_TileList; int main(int argv, char* args[]) { // Initialize SDL if(SDL_Init(SDL_INIT_EVERYTHING) == -1) { // If SDL for some reason fails to initialize, print out an error message in the console printf(\"Error: failed to initialize SDL\n\n\"); } // Initialize SDL Image if(IMG_Init(IMG_INIT_JPG | IMG_INIT_PNG) == 0) { // If SDL Image for some reason fails to initialize, print out an error message in the console printf(\"Error: Failed to initialize SDL Image\n\n\"); } else { // Create the SDL window m_pWindow = SDL_CreateWindow(\"WindowTitle\", SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED, 800, 600, SDL_WINDOW_SHOWN); // If the SDL window has been successfully created if(m_pWindow) { // Create the SDL renderer (render to texture mode enabled) m_pRenderer = SDL_CreateRenderer(m_pWindow, -1, SDL_RENDERER_ACCELERATED | SDL_RENDERER_TARGETTEXTURE); // If the SDL renderer has been successfully created if(m_pRenderer) { // Set the render draw color SDL_SetRenderDrawColor(m_pRenderer, 0xFF, 0xFF, 0xFF, SDL_ALPHA_OPAQUE); // Create the tileset texture m_pTilesetTexture = IMG_LoadTexture(m_pRenderer, \"Tileset.png\"); // Create an empty texture with render target mode m_pTargetTexture = SDL_CreateTexture(m_pRenderer, SDL_PIXELFORMAT_RGBA8888, SDL_TEXTUREACCESS_TARGET, 800, 600); // Make sure that the tile list is cleared / empty at program start m_TileList.clear(); // Pretend that this function loads a map file, sets the tile type, positions the tile quad and sets the clip quad (see the tile struct above) CreateTileMap(); } } } while(m_Running) { while(SDL_PollEvent(&m_Event)) { switch(m_Event.type) { case SDL_QUIT: { m_Running = false; break; } } } // Only need to render the tile list if a tileset texture has been successfully created if(m_pTilesetTexture) { // Clear the current render target SDL_RenderClear(m_pRenderer); // Set the target texture to be the current render target if(m_pTargetTexture) SDL_SetRenderTarget(m_pRenderer, m_pTargetTexture); TileList::iterator it = m_TileList.begin(); for(; it != m_TileList.end(); ++it) { if((*it)) { // Render each tile SDL_RenderCopy(m_pRenderer, m_pTilesetTexture, &(*it)->TileClipQuad, &(*it)->TileQuadPosition); } } // Reset the render target SDL_SetRenderTarget(m_pRenderer, NULL); // Render the target texture if(m_pTargetTexture) SDL_RenderCopy(m_pRenderer, m_pTargetTexture, NULL, NULL); // Update the screen SDL_RenderPresent(m_pRenderer); } } // Destroy the target texture if(m_pTargetTexture) SDL_DestroyTexture(m_pTargetTexture); // Destroy the tileset texture if(m_pTilesetTexture) SDL_DestroyTexture(m_pTilesetTexture); TileList::iterator it = m_TileList.begin(); // Destroy the tile list for(; it != m_TileList.end(); ++it) { if((*it)) delete (*it); } m_TileList.clear(); // Destroy the SDL renderer if(m_pRenderer) SDL_DestroyRenderer(m_pRenderer); // Destroy the SDL window if(m_pWindow) SDL_DestroyWindow(m_pWindow); // Quit SDL SDL_Quit(); return 0; }\n\nThe number of tiles being rendered is all up to you really but I usually use 32x32 tiles and fill the whole window with them and if I use a window size of 800x600 it’s about 450-500 tiles. Just remember that I don’t need to render the whole tile map every frame. I only need to render the tiles that are visible in the window, even if the tilemap contains 2000-3000 tiles. Let’s say I have a window of 800x600 size. This means that, each frame, the game will render 450-500 tiles to the target texture and then render the target texture. This is made every frame. When I want to check how optimized the code is, and want’s to check how the FPS is during rendering, I always turn of the “check if the tile is visible in the window”-function and checks how much the FPS drops. This means that I render a lot of tiles I don’t need to render but I haven’t had any problems with the FPS. So yeah… I don’t think you need to worry much but that of course depends of what your computer can handle, how many tiles you’re rendering and such. I don’t think 1500 operations is too much. But like I said, you don’t need to render the tiles that are not visible in the window."
    },
    {
        "link": "https://stackoverflow.com/questions/18647592/sdl-render-texture-on-top-of-another-texture",
        "document": "i am having trouble with the following:\n\nI need to render a texture on top of another texture and then render that main texture. For example I have the blue rectangle texture, and I want to draw red rectangles on top of this blue rect. However i want them to restrict the render only on this rectangle. Like the following image:\n\nI read something about texture blit between them or something like that but im not sure if this is posible.\n\nMy code looks like this:\n\nAny one knows about how to do this in SDL 2.0? thats what Im using by the way."
    }
]