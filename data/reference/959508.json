[
    {
        "link": "https://docs.aiogram.dev/en/latest/api/types/inline_keyboard_button.html",
        "document": "This object represents one button of an inline keyboard. Exactly one of the optional fields must be used to specify type of the button.\n\nOptional. HTTP or tg:// URL to be opened when the button is pressed. Links can be used to mention a user by their identifier without using a username, if this is allowed by their privacy settings.\n\nOptional. Description of the Web App that will be launched when the user presses the button. The Web App will be able to send an arbitrary message on behalf of the user using the method . Available only in private chats between a user and the bot. Not supported for messages sent on behalf of a Telegram Business account.\n\nOptional. If set, pressing the button will prompt the user to select one of their chats, open that chat and insert the bot’s username and the specified inline query in the input field. May be empty, in which case just the bot’s username will be inserted. Not supported for messages sent on behalf of a Telegram Business account.\n\nOptional. If set, pressing the button will insert the bot’s username and the specified inline query in the current chat’s input field. May be empty, in which case only the bot’s username will be inserted.\n\nOptional. If set, pressing the button will prompt the user to select one of their chats of the specified type, open that chat and insert the bot’s username and the specified inline query in the input field. Not supported for messages sent on behalf of a Telegram Business account."
    },
    {
        "link": "https://docs.aiogram.dev",
        "document": "# Bot token can be obtained via https://t.me/BotFather # All handlers should be attached to the Router (or Dispatcher) # Most event objects have aliases for API methods that can be called in events' context # For example if you want to answer to incoming message you can use `message.answer(...)` alias # and the target chat will be passed to :ref:`aiogram.methods.send_message.SendMessage` Handler will forward receive a message back to the sender By default, message handler will handle all message types (like a text, photo, sticker etc.) # But not all the types is supported to be copied so need to handle it # Initialize Bot instance with default bot properties which will be passed to all API calls"
    },
    {
        "link": "https://aiogram-birdi7.readthedocs.io/en/latest/_modules/aiogram/types/inline_keyboard.html",
        "document": "[docs] This object represents an inline keyboard that appears right next to the message it belongs to. Note: This will only work in Telegram versions released after 9 April, 2016. [docs] This object represents one button of an inline keyboard. You must use exactly one of the optional fields."
    },
    {
        "link": "https://github.com/python-telegram-bot/python-telegram-bot/issues/1267",
        "document": "The code should send a message to with the text \"text\" and a button \"Test\" with the callback_data set to and so on up to .\n\nNote that the code below works as expected:\n\nThis means that it is indeed possible to send bytes through as the callback_data of a button.\n\n The problem originates from the from\n\nwhere we encode all the data (including the callback_data) using utf-8, which mangles all characters above \\x80 (128). This means that through actually turns into 128 bytes instead of the expected 64 (and therefore the BadRequest)\n\nIs this a bug we even really care about?\n\n I figured I just might as well report it.\n\n One optimal fix would be to allow as the input to InlineKeyboardButton, that would then be excluded from the .encode('utf-8') but I wouldn't even know how to begin implementing that.\n\n We could also just ignore it - I highly doubt this bug really effects anyone tbh.\n\nso we can see the data we send."
    },
    {
        "link": "https://restack.io/p/best-telegram-bot-frameworks-for-ai-answer-aiogram-interactive-menu-cat-ai",
        "document": "To create an interactive menu using Aiogram, you need to leverage the powerful features of the library that allow for dynamic user interactions. The interactive menu can enhance user experience by providing quick access to various functionalities of your bot. Below are the steps and code snippets to help you set up an interactive menu effectively.\n\nFirst, ensure you have Aiogram installed. You can do this using pip:\n\nNext, initialize your bot and dispatcher:\n\nTo create an interactive menu, you can use the or . Here’s how to create a simple inline keyboard:\n\nOnce the user interacts with the menu, you need to handle the callback data:\n\nFinally, run the bot with the following code:\n\nBy following these steps, you can create an interactive menu that enhances user engagement with your Aiogram bot. This setup allows for easy expansion and customization, enabling you to add more options and functionalities as needed. For more detailed information, refer to the official Aiogram documentation at Aiogram Documentation."
    },
    {
        "link": "https://stackoverflow.com/questions/76436100/handling-text-input-exception-instead-of-button-click-in-callback-query-aiogram",
        "document": "Friends, I am learning to create simple bots. And I'm myself looking for a solution to problems on the Internet. But now I can not do without your experience and I hope for help! :)\n• By the start command, we launch the bot.\n• A message appears: \"Hello from the bot!\" and under it there is a button: \"Select a city\"\n• When you press the button: \"Select a city\", the inscription appears: \"Your city:\" and a number of buttons with the names of cities.\n• The user clicks on one of the buttons with the name of the city.\n\n5.After that, the buttons with the cities disappear and the text sent to the chat appears with the name of the city button pressed.\n\n6.TOTAL: In the code variable we get the name of the city.\n\nProblem: After step 3, in addition to clicking on any of the buttons with the city, the user can enter something in the text field. Then the buttons are collapsed, and if something other than the name of the cities indicated on the buttons is entered, the process will stop, since the name of the city is the parameter needed later to send the request.\n\nSolution: Need to catch any text input after the 3rd step, other than the name of the specified buttons, and if the text != the name of one of the buttons => you need:\n• display a message that you need to select a city!\n• display the buttons with the name of the cities again.\n• catch and write to the variable the correct name, obtained either by clicking on the button, or by entering the exact match of the city name in the text field by the user.\n\nRegarding the expected result, everything worked out for me, but I can’t handle the problem - incorrect input or accidental clicking by the user in the text field... I tried wrapping it in a While Loop, but I'm having trouble getting the correct response. Please tell me how can solve this problem?"
    },
    {
        "link": "https://docs.aiogram.dev/en/stable/api/types/callback_query.html",
        "document": "# Bot token can be obtained via https://t.me/BotFather # All handlers should be attached to the Router (or Dispatcher) # Most event objects have aliases for API methods that can be called in events' context # For example if you want to answer to incoming message you can use `message.answer(...)` alias # and the target chat will be passed to :ref:`aiogram.methods.send_message.SendMessage` Handler will forward receive a message back to the sender By default, message handler will handle all message types (like a text, photo, sticker etc.) # But not all the types is supported to be copied so need to handle it # Initialize Bot instance with default bot properties which will be passed to all API calls"
    },
    {
        "link": "https://stackoverflow.com/questions/46166661/telegram-bot-callback-query-of-an-inline-button-in-a-group-chat-redirect-the-u",
        "document": "My bot sends messages to groups with inline button, what I want, is when the button is clicked, chat with the bot page should open, i.e. somehow redirect the user to the private chat with the bot.\n\nWhat I have tried so far is to set a url in answer_callback method, equal to the url of my bot i.e. url=\"https://t.me/my_sample_bot but I keep getting URL_INVALID response from telegram, I tried http(since I read somewhere in the api documentation that the urls should be HTTP), but that did not work either.\n\nMy question is am I doing it right? I mean do I have to set the url in answer_callback method to redirect the user, or I should try another way?"
    },
    {
        "link": "https://docs.aiogram.dev/en/stable/api/methods/answer_callback_query.html",
        "document": "# Bot token can be obtained via https://t.me/BotFather # All handlers should be attached to the Router (or Dispatcher) # Most event objects have aliases for API methods that can be called in events' context # For example if you want to answer to incoming message you can use `message.answer(...)` alias # and the target chat will be passed to :ref:`aiogram.methods.send_message.SendMessage` Handler will forward receive a message back to the sender By default, message handler will handle all message types (like a text, photo, sticker etc.) # But not all the types is supported to be copied so need to handle it # Initialize Bot instance with default bot properties which will be passed to all API calls"
    },
    {
        "link": "https://docs.aiogram.dev/en/v3.18.0/changelog.html",
        "document": "\n• None Checked compatibility with Python 3.13 (added to the CI/CD processes), so now aiogram is totally compatible with it. Dropped compatibility with Python 3.8 due to this version being EOL. In some cases you will need to have the installed compiler (Rust or C++) to install some of the dependencies to compile packages from source on command.\n• None If you are using Windows, you will need to have the Visual Studio installed.\n• None If you are using Linux, you will need to have the package installed.\n• None If you are using macOS, you will need to have the Xcode installed. When developers of this dependencies will release new versions with precompiled wheels for Windows, Linux and macOS, this action will not be necessary anymore until the next version of the Python interpreter.\n• Integrated the attribute into various message manipulation methods, ensuring consistent data handling. This update eliminates the need to pass the as a parameter, instead directly accessing it from the instance attributes. #1586\n• None Add function to all built-in storage implementations, and #1431\n• None Enhanced the inheritance of handlers and actions in Scenes. Refactored to eliminate the copying of previously connected handlers and actions from parent scenes. Now, handlers are dynamically rebuilt based on the current class, properly utilizing class inheritance and enabling handler overrides. That’s mean that you can now override handlers and actions in the child scene, instead of copying and duplicating them. #1583\n• \n• None Added the class and the field in the class , allowing bots to send and receive inline buttons that copy arbitrary text.\n• None Added the parameter to the methods , , , , , , , , , , , , , , , , , and .\n• None Added the class for transactions related to paid broadcasted messages.\n• None Introduced the ability to add media to existing text messages using the method .\n• None Added support for hashtag and cashtag entities with a specified chat username that opens a search for the relevant tag within the specified chat.\n• None Fix PytestDeprecationWarning thrown by pytest-asyncio when running the tests #1584\n• From now UUID will have 32 bytes length instead of 36 bytes (with no separators) in the callback data representation. #1602\n• None Added possibility to use custom events in routers (If router does not support custom event it does not break and passes it to included routers). #1147\n• The strategy can be changed in dispatcher: If you have implemented you own storages you should extend record key generation with new one attribute -\n• None Added a tool to make text formatting flexible and easy. More details on the corresponding documentation page #1172\n• None Made list to revolve automatically in start_polling method if not set explicitly. #1178\n• None Change type of result in InlineQueryResult enum for and to more correct according to documentation. Change regexp for entities parsing to more correct ( ). #1146\n• None Fixed signature of startup/shutdown events to include the as the handler arguments. #1155\n• None Fixed the serialization error associated with nested subtypes like InputMedia, ChatMember, etc. The previously generated code resulted in an invalid schema under pydantic v2, which has stricter type parsing. Hence, subtypes without the specification of all subtype unions were generating an empty object. This has been rectified now. #1213\n• None Removed text filter in due to is planned to remove this filter few versions ago.\n• Note that this issue has breaking changes described in the Bot API changelog, this changes is not breaking in the API but breaking inside aiogram because Beta stage is not finished.\n• Note that arguments switch_pm_parameter and switch_pm_text was deprecated and should be changed to button argument as described in API docs.\n• Be careful, not all libraries is already updated to using V2\n• None Added global defaults and in addition to to the Bot instance, reworked internal request builder mechanism. #1142\n• None Replaced ContextVar’s with a new feature called Validation Context in Pydantic to improve the clarity, usability, and versatility of handling the Bot instance within method shortcuts. Breaking: The ‘bot’ argument now is required in\n\nThis update will break backward compability with Python 3.6 and works only with Python 3.7+: - contextvars (PEP-567); - New syntax for annotations (PEP-563). Changes: - Used contextvars instead of ; - Implemented filters factory; - Implemented new filters mechanism; - Allowed to customize command prefix in CommandsFilter; - Implemented mechanism of passing results from filters (as dicts) as kwargs in handlers (like fixtures in pytest); - Implemented states group feature; - Implemented FSM storage’s proxy; - Changed files uploading mechanism; - Implemented pipe for uploading files from URL; - Implemented I18n Middleware; - Errors handlers now should accept only two arguments (current update and exception); - Used instead of for Socks4/5 proxy; - types.ContentType was divided to and ; - Allowed to use rapidjson instead of ujson/json; - method in bot and dispatcher objects was renamed to ; Full changelog - You can read more details about this release in migration FAQ: https://aiogram.readthedocs.io/en/latest/migration_1_to_2.html"
    },
    {
        "link": "https://restack.io/p/aiogram-buttons-answer-best-telegram-bot-frameworks-for-ai-cat-ai",
        "document": "Explore aiogram buttons and their implementation in the best Telegram bot frameworks for AI, enhancing user interaction."
    },
    {
        "link": "https://stackoverflow.com/questions/36059572/how-do-i-have-my-bot-respond-with-arguments",
        "document": "This is a fairly rudimentary way of creating kwargs from user input.\n\nUnfortunately, it does require the user to be aware of the fields that can be used as parameters, but if you can provide informative response when the user doesnt provide any detectable kwarg style messages then you could probably make a better experience.\n\nAs I say, extremely rudimentary idea, and would probably be achieved faster with the regex filters available. And this would be much more reliable when checking input from the user of the \"pesky\" variety.\n\nThe script relies on delimiter preceeding the command and as is shown will trim any extra characters like new lines and spaces\n\nYou can remove the extra check for as this is provided in order to tell the bot that you want to save your input to the database explicitly."
    },
    {
        "link": "https://hostman.com/tutorials/how-to-create-and-set-up-a-telegram-chatbot",
        "document": "Database Connection in Python, Go, and JavaScript\n\nDatabases are an essential part of almost any project today. Database interactions are especially familiar to system and database administrators, DevOps/SRE professionals, and software developers. While administrators typically deploy one or multiple database instances and configure the necessary connection parameters for applications, developers need to connect directly to the database within their code. This article explores how to connect to databases using different programming languages. Prerequisites We will provide examples for connecting to MySQL, PostgreSQL, Redis, MongoDB, and ClickHouse databases using Python, Go, and JavaScript. To follow this guide, you will need: A database deployed on a server or in the cloud. Installed environments for Python, Go, and JavaScript, depending on your application programming language. Additionally for Python: pip installed. Additionally for JavaScript: Node.js and npm installed. Database Connection in Python MySQL and Python For connecting to MySQL databases, we can use a Python driver called MySQL Connector. Install the driver using pip: pip install mysql-connector-python Initialize a new connection: Import the mysql.connector library and the Error class to handle specific connection errors. Create a function named create_connection, passing the database address (host), user name (user), and user password (password). To establish the connection, define a class called create_connection that receives the variable names containing the database connection details. import mysql.connector from mysql.connector import Error def create_connection(host_name, user_name, user_password): connection = None try: connection = mysql.connector.connect( host=\"91.206.179.29\", user=\"gen_user\", password=\"m-EE6Wm}z@wCKe\" ) print(\"Successfully connected to MySQL Server!\") except Error as e: print(f\"The error '{e}' occurred\") return connection def execute_query(connection, query): cursor = connection.cursor() try: cursor.execute(query) connection.commit() print(\"Query executed successfully\") except Error as e: print(f\"The error '{e}' occurred\") connection = create_connection(\"91.206.179.29\", \"gen_user\", \"m-EE6Wm}z@wCKe\") Run the script. If everything works correctly, you will see the \"Successfully connected to MySQL Server!\" message. If any errors occur, the console will display error code and description. Create a new table: Connect to the database using the connection.database class, specifying the name of the database. Note that the database should already exist. To create a table, initialize a variable create_table_query containing the SQL CREATE TABLE query. For data insertion, initialize another variable insert_data_query with the SQL INSERT INTO query. To execute each query, use the execute_query class, which takes the database connection string and the variable containing the SQL query. connection.database = 'test_db' create_table_query = \"\"\" CREATE TABLE IF NOT EXISTS users ( id INT AUTO_INCREMENT PRIMARY KEY, name VARCHAR(100) NOT NULL, age INT NOT NULL ) \"\"\" execute_query(connection, create_table_query) insert_data_query = \"\"\" INSERT INTO users (name, age) VALUES ('Alice', 30), ('Bob', 25) \"\"\" execute_query(connection, insert_data_query) if connection.is_connected(): connection.close() print(\"Connection closed\") Run the script. PostgreSQL and Python Python offers several plugins for connecting to PostgreSQL, but the most popular one is psycopg2, which we will use here. Psycopg2 is one of the most frequently used Python plugins for PostgreSQL connections. One of its key advantages is its support for multithreading which allows you to maintain the database connection across multiple threads. Install psycopg2 using pip (if not already installed): pip install psycopg2-binary Connect to PostgreSQL. Import the Python psycopg2 package and create a function create_new_conn, using the try block. Establish the connection with the psycopg2.connect function, which requires the database name, user name, password, and database address as input. To initialize the connection, use the create_new_conn() function. Here’s the full code example for connecting to a database: import psycopg2 from psycopg2 import OperationalError def create_new_conn(): conn_to_postgres = None while not conn_to_postgres: try: conn_to_postgres = psycopg2.connect( default_db=\"default_db\", default_user=\"gen_user\", password_for_default_user=\"PasswordForDefautUser9893#\", db_address=\"91.206.179.128\" ) print(\"The connection to PostgreSQL has been successfully established!\") except OperationalError as e: print(e) return conn_to_postgres conn_to_postgres = create_new_conn() Run the script: python3 connect_to_postgres.py If successful, you will see the \"The connection to PostgreSQL has been successfully established!\" message. . Next, create a table named books, which will have three columns. Use the cursor class for SQL expressions, such as creating database objects. If the query involves adding or modifying data, you must call the conn_to_postgres.commit() function afterward to apply the changes. import psycopg2 from psycopg2 import OperationalError def create_new_conn(): conn_to_postgres = None while not conn_to_postgres: try: conn_to_postgres = psycopg2.connect( default_db=\"default_db\", default_user=\"gen_user\", password_for_default_user=\"PasswordForDefautUser9893#\", db_address=\"91.206.179.128\" ) except OperationalError as e: print(e) return conn_to_postgres conn_to_postgres = create_new_conn() cursor = conn_to_postgres.cursor() cursor.execute(\"\"\" CREATE TABLE books ( book_id INT PRIMARY KEY NOT NULL, book_name VARCHAR(255) NOT NULL, book_author VARCHAR(255) NOT NULL ) \"\"\") conn_to_postgres.commit() print(\"Table Created successfully\") Run the script: python3 create_table.py Now, let’s run INSERT INTO to add a new line: cursor.execute(\"\"\" INSERT INTO books (book_id,book_name,book_author) VALUES (1, 'Long Walk to Freedom', 'Nelson_Mandela') \"\"\") The full code is below: import psycopg2 from psycopg2 import OperationalError def create_new_conn(): conn_to_postgres = None while not conn_to_postgres: try: conn_to_postgres = psycopg2.connect( default_db=\"default_db\", default_user=\"gen_user\", password_for_default_user=\"PasswordForDefautUser9893#\", db_address=\"91.206.179.128\" ) except OperationalError as e: print(e) return conn_to_postgres conn_to_postgres = create_new_conn() cursor = conn_to_postgres.cursor() cursor.execute(\"\"\" INSERT INTO books (book_id,book_name,book_author) VALUES (1, 'Long Walk to Freedom', 'Nelson_Mandela') \"\"\") conn_to_postgres.commit() conn_to_postgres.close() print(\"Data inserted successfully\") Run the script: python3 insert-data.py Redis and Python Redis belongs to the class of NoSQL databases, where data is stored in memory rather than on hard drives. It uses a key-value format for data storage. Redis has a wide range of applications, from data storage and caching to serving as a message broker. We will use the redis-py (or simply redis) library for connecting to Redis. Install the Redis library using pip: pip install redis Connecting to a Redis instance: Use a try block structure for connection, specifying the function redis.StrictRedis where you provide the Redis address, port, and user password. import redis try: connect_to_redis_server = redis.StrictRedis( redis_db_host=91.206.179.128, redis_db_port=6379, redis_user_password='PasswordForRedis6379') print connect_to_redis_server connect_to_redis_server.ping() print 'Successfully connected to Redis Server!' except Exception as ex: print 'Error:', ex exit('Failed to connect to Redis server.') Run the script: python3 connect_to_redis.py If successful, you will see a message like \"Successfully connected to Redis Server!\". Unlike relational databases, Redis stores data in a key-value format. The key uniquely identifies the corresponding value. Use the set method to create a new record. The example below creates a record with the key City and the value Berlin: print('Create new record:', connect_to_redis_server.set(\"City\", \"Berlin\")) Use the get method to retrieve the value associated with a key: print('Print record using record key:', connect_to_redis_server.get(\"City\")) Use the delete method to remove a record by its key: print('Delete record with key:', connect_to_redis_server.delete(\"City\")) The complete code fragment is below. import redis try: connect_to_redis_server = redis.StrictRedis( redis_db_host=91.206.179.128, redis_db_port=6379, redis_user_password='PasswordForRedis6379') print ('New record created:', connect_to_redis_server.set(\"City\", \"Berlin\")) print ('Print created record using record key', connect_to_redis_server.get(\"City\")) print ('Delete created record with key :', connect_to_redis_server.delete(\"City\")) except Exception as ex: print ('Error:', ex) MongoDB and Python MongoDB is another widely used NoSQL database that belongs to the document-oriented category. Data is organized as JSON-like documents. To connect to a MongoDB database with Python, the recommended library is PyMongo, which provides a synchronous API. Install the PyMongo plugin: pip3 install pymongo Connect to MongoDB server using the following Python code. Import the pymongo module and use the MongoClient class to specify the database server address. To establish a connection to the MongoDB server, use a try block for error handling: import pymongo connect_to_mongo = pymongo.MongoClient(\"mongodb://91.206.179.29:27017/\") first_db = connect_to_mongo[\"mongo-db1\"] try: first_db.command(\"serverStatus\") except Exception as e: print(e) else: print(\"Successfully connected to MongoDB Server!\") connect_to_mongo.close() Run: python3 connect_mongodb.py If the connection is successfully established, the script will return the message: \"Successfully connected to MongoDB Server!\" Add data to MongoDB. To add data, you need to create a dictionary. Let's create a dictionary named record1, containing three keys: record1 = { \"name\": \"Alex\", \"age\": 25, \"location\": \"London\" } To insert the dictionary data, use the insert_one method in MongoDB. insertrecord = collection1.insert_one(record1) import pymongo connect_to_mongo = pymongo.MongoClient(\"mongodb://91.206.179.29:27017/\") db1 = connect_to_mongo[\"newdb\"] collection1 = db1[\"userdata\"] record1 = { \"name\": \"Alex\", \"age\": 25, \"location\": \"London\" } insertrecord = collection1.insert_one(record1) print(insertrecord) Run the script: python3 connect_mongodb.py ClickHouse and Python ClickHouse is a columnar NoSQL database where data is stored in columns rather than rows. It is widely used for handling analytical queries. Install the ClickHouse driver for Python. There is a dedicated plugin for ClickHouse called clickhouse-driver. Install the driver using the pip package manager: pip install clickhouse-driver Connect to ClickHouse. To initialize a connection with ClickHouse, you need to import the Client class from the clickhouse_driver library. To execute SQL queries, use the client.execute function. You also need to specify the engine. For more details on supported engines in ClickHouse, you can refer to the official documentation. We'll use the default engine, MergeTree. Next, create a new table called users and insert two columns with data. To list the data to be added to the table, use the tuple data type. After executing the necessary queries, make sure to close the connection to the database using the client.disconnect() method. The final code will look like this: from clickhouse_driver import Client client = Client(host=91.206.179.128', user='root', password='P@$$w0rd123', port=9000) client.execute(''' CREATE TABLE IF NOT EXISTS Users ( id UInt32, name String, ) ENGINE = MergeTree() ORDER BY id ''') data = [ (1, 'Alice'), (2, 'Mary') ] client.execute('INSERT INTO Users (id, name) VALUES', data) result = client.execute('SELECT * FROM Users') for row in result: print(row) client.disconnect() Database Connection in Go Go is one of the youngest programming languages, developed in 2009 by Google. It is widely used in developing microservice architectures and network utilities. For example, services like Docker and Kubernetes are written in Go. Go supports integrating all popular databases, including PostgreSQL, Redis, MongoDB, MySQL, ClickHouse, etc. MySQL and Go For working with the MySQL databases in Go, use the go-sql-driver/mysql driver. Create a new directory for storing project files and navigate into it: mkdir mysql-connect && cd mysql-connect Create a go.mod file to store the dependencies: go mod init golang-connect-mysql Download the MySQL driver using the go get command: go get -u github.com/go-sql-driver/mysql Create a new file named main.go. Specify the database connection details in the dsn variable: package main import ( \"database/sql\" \"fmt\" \"log\" _ \"github.com/go-sql-driver/mysql\" ) func main() { dsn := \"root:password@tcp(localhost:3306)/testdb\" db, err := sql.Open(\"mysql\", dsn) if err != nil { log.Fatal(err) } defer db.Close() if err := db.Ping(); err != nil { log.Fatal(err) } fmt.Println(\"Successfully connected to the database!\") query := \"INSERT INTO users (name, age) VALUES (?, ?)\" result, err := db.Exec(query, \"Alex\", 25) if err != nil { log.Fatal(err) } lastInsertID, err := result.LastInsertId() if err != nil { log.Fatal(err) } fmt.Printf(\"Inserted data with ID: %d\n\n\", lastInsertID) } PostgreSQL and Go To connect to PostgreSQL, use the pq driver. Before installing the driver, let's prepare our environment. Create a new directory for storing the project files and navigate into it: mkdir postgres-connect && cd postgres-connect Since we will be working with dependencies, we need to create a go.mod file to store them: go mod init golang-connect-postgres Download the pq driver using the go get command: go get github.com/lib/pq Create a new file named main.go. In addition to importing the pq library, it is necessary to add the database/sql library as Go does not come with official database drivers by default. The database/sql library consists of general, independent interfaces for working with databases. It is also important to note the underscore (empty identifier) when importing the pq module: _ \"github.com/lib/pq\" The empty identifier is used to avoid the \"unused import\" error, as in this case, we only need the driver to be registered in database/sql. The fmt package is required to output data to the standard output stream, for example, to the console. To open a connection to the database, the sql.Open function is used, which takes the connection string (connStr) and the driver name (postgres). The connection string specifies the username, database name, password, and host address: package main import ( \"database/sql\" \"fmt\" \"log\" _ \"github.com/lib/pq\" ) func main() { connStr := \"user=golang dbname=db_for_golang password=Golanguserfordb0206$ host=47.45.249.146 sslmode=disable\" db, err := sql.Open(\"postgres\", connStr) if err != nil { log.Fatal(err) } defer db.Close() err = db.Ping() if err != nil { log.Fatal(err) } fmt.Println(\"Successfully connected to PostgreSQL!\") } Compile and run: go run main.go If everything works correctly, the terminal will display the message Successfully connected to PostgreSQL! Now, let's look at an example of how to insert data into a table. First, we need to create a table in the database. When using Hostman cloud databases, you can copy the PostgreSQL connection string displayed in the \"Connections\" section of the Hostman web interface. Make sure that the postgresql-client utility is installed on your device beforehand. Enter the psql shell and connect to the previously created database: \\c db_for_golang Create a table named Cities with three fields — city_id, city_name, and city_population: CREATE TABLE Cities ( city_id INT PRIMARY KEY, city_name VARCHAR(45) NOT NULL, city_population INT NOT NULL); Grant full privileges to the created table for the user: GRANT ALL PRIVILEGES ON TABLE cities TO golang; The function db.Prepare is used to prepare data. It specifies the query for insertion in advance. To insert data, use the function stmt.Exec. In Go, it's common to use plain SQL without using the ORM (Object-Relational Mapping) approach. stmt, err := db.Prepare(\"INSERT INTO Cities(city_id, city_name, city_population) VALUES($1, $2, $3)\") if err != nil { log.Fatal(err) } defer stmt.Close() _, err = stmt.Exec(1, \"Toronto\", 279435) if err != nil { log.Fatal(err) } fmt.Println(\"Data inserted successfully!\") } If all works correctly, you will see: Data inserted successfully! Redis and Go To connect to Redis, you need to use the go-redis driver. Сreate a new directory: mkdir connect-to-redis && cd connect-to-redis Prepare the dependency file: go mod init golang-connect-redis And optimize them: go mod tidy Download the go-redis module: go get github.com/go-redis/redis/v8 To connect to Redis, use the redis.Options function to specify the address and port of the Redis server. Since Redis does not use authentication by default, you can leave the Password field empty and use the default database (database 0): package main import ( \"context\" \"fmt\" \"log\" \"github.com/go-redis/redis/v8\" ) func main() { rdb := redis.NewClient(&redis.Options{ Addr: \"91.206.179.128:6379\", Password: \"\", DB: 0, }) ctx := context.Background() _, err := rdb.Ping(ctx).Result() if err != nil { log.Fatalf(\"Couldn't connect to Redis: %v\", err) } fmt.Println(\"Successfully connected to Redis!\") } You should see the message «Successfully connected to Redis!» MongoDB and Go To work with MongoDB, we'll use the mongo driver. Create a new directory to store the project structure: mkdir connect-to-mongodb && cd connect-to-mongodb Initialize the dependency file: go mod init golang-connect-mongodb Download the mongo library: go get go.mongodb.org/mongo-driver/mongo Connect to MongoDB using the options.Client().ApplyURI method. It takes a connection string such as mongodb://91.206.179.29:27017, where 91.206.179.29 is the MongoDB server address and 27017 is the port for connecting to MongoDB. The options.Client().ApplyURI string is used only for specifying connection data. To check the connection status, you can use another function, client.Ping, which shows the success or failure of the connection: package main import ( \"context\" \"fmt\" \"log\" \"time\" \"go.mongodb.org/mongo-driver/mongo\" \"go.mongodb.org/mongo-driver/mongo/options\" ) func main() { clientOptions := options.Client().ApplyURI(\"mongodb://91.206.179.29:27017\") client, err := mongo.Connect(context.TODO(), clientOptions) if err != nil { log.Fatalf(\"Couldn't connect to MongoDB server: %v\", err) } fmt.Println(\"successfully connected to MongoDB!\") ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second) defer cancel() err = client.Ping(ctx, nil) if err != nil { log.Fatalf(\"Could not ping MongoDB server: %v\", err) } fmt.Println(\"Ping MongoDB server successfully!\") } You should see the message: successfully connected to MongoDB!Ping MongoDB server successfully MongoDB uses collections to store data. You can create collections using the .Collection function. Below, we will create a database called first-database and a collection called first-collection. The collection will have a new document, containing three keys: user-name, user-age, and user-email. collection := client.Database(\"first-database\").Collection(\"first-collection\") document := map[string]interface{}{ \"user-name\": \"Alice\", \"user-age\": 25, \"user-email\": \"alice@corporate.com\", } insertResult, err := collection.InsertOne(ctx, document) if err != nil { log.Fatalf(\"Couldn't insert new document: %v\", err) } fmt.Printf(\"Inserted new document with ID: %v\n\n\", insertResult.InsertedID) if err := client.Disconnect(ctx); err != nil { log.Fatalf(\"Could not disconnect from MongoDB: %v\", err) } fmt.Println(\"Disconnected from MongoDB!\") } If successful, you will see the Inserted new document message with the document ID. ClickHouse and Go To work with ClickHouse, use the clickhouse-go driver. Create a new directory to store the project files and navigate to it: clickhouse-connect && cd clickhouse-connect Create a go.mod file to store the dependencies: go mod init golang-connect-clickhouse Download the Clickhouse driver using the command: go get github.com/ClickHouse/clickhouse-go/v2 Create a new file named main.go, where you will specify the connection data to ClickHouse. package main import ( \"database/sql\" \"log\" \"github.com/ClickHouse/clickhouse-go/v2\" ) func main() { dsn := \"tcp://localhost:9000?username=user1&password=PasswordForuser175465&database=new_db\" db, err := sql.Open(\"clickhouse\", dsn) if err != nil { log.Fatal(err) } defer db.Close() if err := db.Ping(); err != nil { log.Fatal(err) } log.Println(\"Connected to ClickHouse!\") } Database Connection in JavaScript In JavaScript, all connections to external services are made using the Node.js platform. Make sure that you have Node.js and the npm package manager installed on your device. MySQL and JavaScript To work with MySQL, use the mysql2 driver. Create a directory where we will store the project files: mkdir js-mysql-connect && cd js-mysql-connect Initialize the project: npm init -y Install the mysql2 library: npm install mysql2 Use the following code to connect to MySQL: const mysql = require('mysql2'); const connection_to_mysql = mysql.createConnection({ host: 'localhost', user: 'root', password: 'PasswordForRoot74463', database: db1, }); connection_to_mysql.connect((err) => { if (err) { console.error('Error connecting to MySQL:', err.message); return; } console.log('Successfully connected to MySQL Server!'); connection_to_mysql.end((endErr) => { if (endErr) { console.error('Error closing the connection_to_mysql:', endErr.message); } else { console.log('Connection closed.'); } }); }); PostgreSQL and JavaScript Connecting to PostgreSQL is done using the pg library. Create a directory where we will store the project files: mkdir js-postgres-connect && cd js-postgres-connect Initialize the project: npm init -y Install the pg library: npm install pg To connect to PostgreSQL, first import the pg library. Then, create a constant where you specify variables for the database address, username, password, database name, and port. Use the new pg.Client class to pass the connection data. We will create a table called cities and add two records into it. To do this, we will use the queryDatabase function, which contains the SQL queries. const pg = require('pg'); const config = { postgresql_server_host: '91.206.179.29', postgresql_user: 'gen_user', postgresql_user_password: 'PasswordForGenUser56467$', postgresql_database_name: 'default_db', postgresql_database_port: 5432, }; const client = new pg.Client(config); client.connect(err => { if (err) throw err; else { queryDatabase(); } }); function queryDatabase() { const query = ` DROP TABLE IF EXISTS cities; CREATE TABLE cities (id serial PRIMARY KEY, name VARCHAR(80), population INTEGER); INSERT INTO cities (name, population) VALUES ('Berlin', 3645000); INSERT INTO cities (name, population) VALUES ('Paris', 2161000); `; client .query(query) .then(() => { console.log('Table created successfully!'); client.end(console.log('Closed client connection')); }) .catch(err => console.log(err)) .then(() => { console.log('Finished execution, exiting now'); process.exit(); }); } Use this command to run the code: node connect-to-postgres.js Redis and JavaScript To work with Redis, use the ioredis library. Create a directory to store the project files: mkdir js-redis-connect && cd js-redis-connect Initialize the project: npm init -y Install the ioredis library: npm install ioredis To connect to Redis, import the ioredis library. Then create a constant named redis and specify the Redis server address. Inserting data, i.e., creating key-value objects, is done using an asynchronous function named setData, which takes two values — key and value, corresponding to the data format of the Redis system. const Redis = require('ioredis'); const redis = new Redis({ host: '91.206.179.29', port: 6379, password: 'UY+p8e?Kxmqqfa', }); async function setData(key, value) { try { await redis.set(key, value); console.log('Data successfully set'); } catch (error) { console.error('Error setting data:', error); } } async function getData(key) { try { const value = await redis.get(key); console.log('Data retrieved'); return value; } catch (error) { console.error('Error getting data:', error); } } (async () => { await redis.select(1); await setData('user', 'alex'); await getData('user'); redis.disconnect(); })(); Run: node connect-to-redis.js MongoDB and JavaScript To work with MongoDB, use the mongodb driver. Create a directory for storing the project files: mkdir js-mongodb-connect && cd js-mongodb-connect Initialize the project: npm init -y Install the mongodb library: npm install mongodb To connect to MongoDB, import the mongodb library. Specify the database address in the constant uri and pass the address into the MongoClient class. const { MongoClient } = require('mongodb'); const uri = \"mongodb://91.206.179.29:27017\"; const client = new MongoClient(uri, { useNewUrlParser: true, useUnifiedTopology: true }); async function connectToDatabase() { try { await client.connect(); console.log(\"Successfully connected to MongoDB!\"); const database = client.db(\"myDatabase\"); const collection = database.collection(\"myCollection\"); const documents = await collection.find({}).toArray(); console.log(\"Documents found:\", documents); } catch (error) { console.error(\"Error connecting to MongoDB:\", error); } finally { await client.close(); console.log(\"Connection closed.\"); } } connectToDatabase(); ClickHouse and JavaScript To work with ClickHouse, use the clickhouse/client driver. Create a directory where we will store the project files: mkdir js-clickhouse-connect && cd js-clickhouse-connect Initialize the project: npm init -y Install the @clickhouse/client library: npm install @clickhouse/client To connect to ClickHouse, use the code below where we set the connection details and execute a simple SQL query that will return the first 10 records from the system table named system.tables: const { ClickHouse } = require('@clickhouse/client'); const client = new ClickHouse({ host: 'http://localhost:8123', username: 'default', password: 'PasswordforDefaultUser45435', database: 'default', }); async function connectAndQuery() { try { console.log('Successfully connected to ClickHouse Server!'); const rows = await client.query({ query: 'SELECT * FROM system.tables LIMIT 10', format: 'JSON', }).then((result) => result.json()); console.log('Query results:', rows); } catch (error) { console.error('Error Successfully connected to ClickHouse Server! or running the query:', error); } finally { console.log('Done.'); } } connectAndQuery(); Conclusion In today's article, we thoroughly explored how to connect to PostgreSQL, Redis, MongoDB, MySQL, and ClickHouse databases using Python, Go, and JavaScript. These languages can be used to create both web applications and microservices that utilize databases in their operation."
    },
    {
        "link": "https://docs.aiogram.dev/en/latest/dispatcher/finite_state_machine/scene.html",
        "document": "aiogram’s basics API is easy to use and powerful, allowing the implementation of simple interactions such as triggering a command or message for a response. However, certain tasks require a dialogue between the user and the bot. This is where Scenes come into play.\n\nA Scene in aiogram is like an abstract, isolated namespace or room that a user can be ushered into via the code. When a user is within a Scene, most other global commands or message handlers are bypassed, unless they are specifically designed to function outside of the Scenes. This helps in creating an experience of focused interactions. Scenes provide a structure for more complex interactions, effectively isolating and managing contexts for different stages of the conversation. They allow you to control and manage the flow of the conversation in a more organized manner. Each Scene can be “entered”, “left” or “exited”, allowing for clear transitions between different stages of the conversation. For instance, in a multi-step form filling interaction, each step could be a Scene - the bot guides the user from one Scene to the next as they provide the required information. Scenes have their own hooks which are command or message listeners that only act while the user is within the Scene. These hooks react to user actions while the user is ‘inside’ the Scene, providing the responses or actions appropriate for that context. When the user is ushered from one Scene to another, the actions and responses change accordingly as the user is now interacting with the set of listeners inside the new Scene. These ‘Scene-specific’ hooks or listeners, detached from the global listening context, allow for more streamlined and organized bot-user interactions. Each Scene is like a self-contained world, with interactions defined within the scope of that Scene. As such, only the handlers defined within the specific Scene will react to user’s input during the lifecycle of that Scene. Scenes can help manage more complex interaction workflows and enable more interactive and dynamic dialogs between the user and the bot. This offers great flexibility in handling multi-step interactions or conversations with the users.\n\nHow to use Scenes¶ For example we have a quiz bot, which asks the user a series of questions and then displays the results. Lets start with the data models, in this example simple data models are used to represent the questions and answers, in real life you would probably use a database to store the data. \"\"\"Indicates if the answer is correct\"\"\" Class representing a quiz with a question and a list of answers. # Fake data, in real application you should use a database or something else \"What is the capital of France?\" \"What is the capital of Spain?\" \"What is the capital of Germany?\" \"What is the capital of England?\" \"What is the capital of Italy?\" Then, we need to create a Scene class that will represent the quiz game scene: Keyword argument passed into class definition describes the scene name - is the same as state of the scene. It inherits from Scene class and is associated with the state \"quiz\". It handles the logic and flow of the quiz game. Also we need to define a handler that helps to start the quiz game: Once the scene is defined, we need to register it in the SceneRegistry: # To use scenes, you should create a SceneRegistry and register your scenes there # ... and then register a scene in the registry # by default, Scene will be mounted to the router that passed to the SceneRegistry, # but you can specify the router explicitly using the `router` argument So, now we can implement the quiz game logic, each question is sent to the user one by one, and the user’s answer is checked at the end of all questions. Now we need to write an entry point for the question handler: Method triggered when the user enters the quiz scene. It displays the current question and answer options to the user. :param step: Scene argument, can be passed to the scene using the wizard # This is the first step, so we should greet the user # This error means that the question's list is over Once scene is entered, we should expect the user’s answer, so we need to write a handler for it, this handler should expect the text message, save the answer and retake the question handler for the next question: Method triggered when the user selects an answer. It stores the answer and proceeds to the next question. When user answer with unknown message, we should expect the text message again: Method triggered when the user sends a message that is not a command or an answer. It asks the user to select an answer. :param message: The message received from the user. When all questions are answered, we should show the results to the user, as you can see in the code below, we use to exit from the scene when questions list is over in the handler. Thats means that we need to write an exit handler to show the results to the user: Method triggered when the user exits the quiz scene. It calculates the user's answers, displays the summary, and clears the stored answers. Also we can implement a actions to exit from the quiz game or go back to the previous question: Method triggered when the user selects the \"Exit\" button. Method triggered when the user selects the \"Back\" button. It allows the user to go back to the previous question. # In case when the user tries to go back from the first question, Now we can run the bot and test the quiz game: # Alternatively, you can use aiogram-cli: \"\"\"Indicates if the answer is correct\"\"\" Class representing a quiz with a question and a list of answers. # Fake data, in real application you should use a database or something else \"What is the capital of France?\" \"What is the capital of Spain?\" \"What is the capital of Germany?\" \"What is the capital of England?\" \"What is the capital of Italy?\" It inherits from Scene class and is associated with the state \"quiz\". It handles the logic and flow of the quiz game. Method triggered when the user enters the quiz scene. It displays the current question and answer options to the user. :param step: Scene argument, can be passed to the scene using the wizard # This is the first step, so we should greet the user # This error means that the question's list is over Method triggered when the user exits the quiz scene. It calculates the user's answers, displays the summary, and clears the stored answers. Method triggered when the user selects the \"Back\" button. It allows the user to go back to the previous question. # In case when the user tries to go back from the first question, Method triggered when the user selects the \"Exit\" button. Method triggered when the user selects an answer. It stores the answer and proceeds to the next question. Method triggered when the user sends a message that is not a command or an answer. It asks the user to select an answer. :param message: The message received from the user. \"Hi! This is a quiz bot. To start the quiz, use the /quiz command.\" # To use scenes, you should create a SceneRegistry and register your scenes there # ... and then register a scene in the registry # by default, Scene will be mounted to the router that passed to the SceneRegistry, # but you can specify the router explicitly using the `router` argument # Alternatively, you can use aiogram-cli:\n• None - container for all scenes in the bot, used to register scenes and resolve them by name\n• None - manages scenes for each user, used to enter, leave and resolve current scene for user\n• None - scene wizard, used to interact with user in scene from active scene handler\n• None Markers - marker for scene handlers, used to mark scene handlers A scene is a specific state in a conversation where certain actions can take place. Each scene has a set of filters that determine when it should be triggered, and a set of handlers that define the actions to be executed when the scene is active. This class is not meant to be used directly. Instead, it should be subclassed to define custom scenes. Adds the scene to the given router. Create an entry point handler for the scene, can be used to simplify the handler that starts the scene. A class that represents a registry for scenes in a Telegram bot. This method adds the specified scenes to the registry and optionally registers it to the router. If a scene with the same state already exists in the registry, a SceneException is raised. If the router is not specified, the scenes will not be registered to the router. You will need to include the scenes manually to the router or use the register method.\n• None scenes – A variable length parameter that accepts one or more types of scenes. These scenes are instances of the Scene class.\n• None router – An optional parameter that specifies the router to which the scenes should be added. This method returns the registered Scene object for the specified scene. The scene parameter can be either a Scene object or a string representing the name of the scene. If a Scene object is provided, the state attribute of the SceneConfig object associated with the Scene object will be used as the scene name. If None or an invalid type is provided, a SceneException will be raised. If the specified scene is not registered in the SceneRegistry object, a SceneException will be raised. scene – A Scene object or a string representing the name of the scene. The registered Scene object corresponding to the given scene parameter. Registers one or more scenes to the SceneRegistry. scenes – One or more scene classes to register. The ScenesManager class is responsible for managing scenes in an application. It provides methods for entering and exiting scenes, as well as retrieving the active scene. Close method is used to exit the currently active scene in the ScenesManager.\n• None scene_type – Optional Type[Scene] or str representing the scene type to enter.\n• None _check_active – Optional bool indicating whether to check if there is an active scene to exit before entering the new scene. Defaults to True.\n• None kwargs – Additional keyword arguments to pass to the scene’s wizard.enter() method. This attribute should only be changed when you know what you are doing. A class that represents a wizard for managing scenes in a Telegram bot. Instance of this class is passed to each scene as a parameter. So, you can use it to transition between scenes, get and set data, etc. This class is not meant to be used directly. Instead, it should be used as a parameter in the scene constructor. This method is used to go back to the previous scene. kwargs – Keyword arguments that can be passed to the method. Enter method is used to transition into a scene in the SceneWizard class. It sets the state, clears data and history if specified, and triggers entering event of the scene. Exit the current scene and enter the default scene/state. This method returns the data stored in the current state. A dictionary containing the data stored in the scene state. The method transitions to a new scene. It first calls the method to perform any necessary cleanup in the current scene, then calls the event to enter the specified scene.\n• None scene – The scene to transition to. Can be either a instance or a string representing the scene.\n• None kwargs – Additional keyword arguments to pass to the method of the scene manager. Leaves the current scene. This method is used to exit a scene and transition to the next scene.\n• None _with_history – Whether to include history in the snapshot. Defaults to True. This method allows to re-enter the current scene. kwargs – Additional keyword arguments to pass to the scene. data – A dictionary containing the custom data to be set in the current state. This method updates the data stored in the current state Markers are similar to the Router event registering mechanism, but they are used to mark scene handlers in the Scene class. It can be imported from and should be used as decorator. Each event type can be filtered in the same way as in the Router. Also each event type can be marked as scene entry point, exit point or leave point. If you want to mark the scene can be entered from message or inline query, you should use or marker: Scene has only three points for transitions:\n• None enter point - when user enters to the scene\n• None leave point - when user leaves the scene and the enter another scene\n• None exit point - when user exits from the scene"
    },
    {
        "link": "https://stackoverflow.com/questions/77931811/how-to-implement-a-prompt-when-entering-a-command-in-aiogram-python",
        "document": "How to implement a tooltip when entering a command in aiogram Python?\n\nYou enter a command in a line and a small field is shown as a tooltip, example below.\n\nI've tried googling for information, documentation, but I haven't really found what I'm looking for"
    }
]