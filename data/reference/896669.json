[
    {
        "link": "https://wiki.multitheftauto.com/wiki/Scripting_Introduction",
        "document": "Resources are a key part of MTA. A resource is essentially a folder or zip file that contains a collection of files, plus a \"meta\" file that describes to the server how the resource should be loaded and what files it does contain. A resource can be seen as being partly equivalent to a program running in an operating system - it can be started and stopped, and multiple resources can run at once.\n\nEverything that has to do with scripting happens in resources, what a resource does defines if it is a gamemode, a map, or anything else. MTA comes with resources that you can optionally use in your gamemodes, such as map limits to keep playings within a playing area or death-pickups to create weapon pickups.\n\nWe will first learn how to make a basic script that lets the player walk around in the city, step by step.\n\nWhere are all the scripts?\n\nLet's take a look at the script's file structure. Go to your MTA Server folder, and follow the path below:\n\nYou will see a lot of .zip files, which are the packaged sample scripts shipped with MTA. Each file is a \"resource\", and they will all be unzipped and loaded by the server when it starts. To create your own resource, simply make a folder with your preferred name. We'll use \"myserver\" for this tutorial.\n\nNow you should be under this directory:\n\nIn order to let the server know what's in the resource, a meta.xml file must be created to list the resource's content. It must be located in the resource's root directory, which is the \"myserver\" folder in our case. So create a text file and name it \"meta.xml\", and open it with notepad.\n\nEnter the following codes in the meta.xml file:\n\nIn the <info /> tag, there's a \"type\" field which indicates that the resource is a gamemode instead of a regular include or a map, which will be explained later. A gamemode is what you need to make a stand-alone server.\n\nThe <script /> tag indicates the script files contained in the resource, which we will create next.\n\nNote that in the <script /> tag above, the .lua file is not under another directory. Therefore we'll create the file in the same folder as meta.xml. Now you can copy and paste the following code into script.lua:\n\nThe script will spawn you at the coordinate (x, y, z) specified above when you join the game. Note that the fadeCamera function must be used or the screen will be black. Also, in releases after DP2, you need to set the camera target (otherwise all the players will see is the blue sky).\n\nThe source variable indicates who triggered the event. Since a player has joined when the code is triggered, you use this variable to look which has joined. So it'll spawn that player instead of everyone or a random person.\n\nIf we have a closer look on addEventHandler, you can see 3 things: 'onPlayerJoin', which indicates when it's triggered. getRootElement(), which shows by what/who it can be triggered. (getRootElement() is everything/everyone) And joinHandler, which indicates the function that has to be triggered after the event is triggered. Other details will be explained later in another example, now let's just run the server and try it out!\n\nTo get the server started, simply run the executable under the server/ directory. A list of server stats will be shown first; note the port number, which you'll need when joining the game. Then the server loads all the resources under the mods/deathmatch/resources/ directory, and then \"ready to accept connections!\"\n\nBefore you connect to the server, you must run the gamemode. Type \"start myserver\" and press Enter. The server will start the gamemode you just created, and will also show any errors and warnings from this point on. Now you can start the MTA client, and \"Quick Connect\" using the IP address of your server and the port number you saw earlier. If all goes well, after a few seconds your character will be walking on the streets of Los Santos.\n\nNext, we'll add a command to your script that players can use to spawn a vehicle beside their position. You may skip it and check out more advanced scripting with the Map Manager, which continues this tutorial. Another branch from this tutorial is Introduction to Scripting GUI, you may follow it to see how the Graphical User Interface in MTA is drawn and scripted.\n\nLet's go back to the content of the script.lua file. As mentioned above, we want to provide a command to create a vehicle beside your current position in the game. Firstly we need to create a function we want to call and a command handler that creates the command the player will be able to enter in the console.\n\nNote: Function names are clickable in code examples on the wiki and linked to the functions' documentation.\n\nThe first argument of addCommandHandler is the name of the command the player will be able to enter, the second argument is the function this will call, in this case createVehicleForPlayer.\n\nIf you have already experienced in scripting, you will know that you call a function like this:\n\nIf we have a closer look on the lower example above, we can see argument1 is thePlayer and argument2 the commandName. thePlayer is simply the one who typed the command, so whatever you call it, the variable will contain the player who activated the command. commandName is simply the command they typed. So if they typed \"/greet\", this argument will contain \"greet\". Argument 3 is something extra the player typed, you'll learn it a little bit further in the tutorial. Never forget that the first 2 arguments are standard arguments, but you can name them to anything you want.\n\nWe called the addCommandHandler function this way already and since createVehicleForPlayer is a function too, it can be called that way as well. But we are using a command handler for that, which calls it in a similar manner, internally.\n\nFor example someone types \"createvehicle 468\" in-game in the console to spawn a Sanchez, the command handler calls the createVehicleForPlayer function, as if we would have this line of code in the script:\n\nAs we can see, it provides several parameters: the player who called the command, the command he entered, and whatever text he had after that, in this case, \"468\" as vehicle id for the Sanchez. The first two parameters are the same with all command handlers, which you can read on the addEventHandler page. For this fact, you always have to define at least those two parameters to use any after that (for example to process text that was entered after the command, like in our example the vehicle model id).\n\nNote: You have to add the command handler AFTER you defined the handler function, else it can't find it. The order of execution matters.\n\nIn order to fill the function we created, we need to think about what we have to do:\n• Get the players position, so we know where to spawn the vehicle (we want it to appear right beside the player)\n• Calculate the position we want to spawn the vehicle at (we don't want it to appear in the player)\n• Check if it has been spawned successfully, or output a message\n\nIn order to achieve our goals, we have to use several functions. To find the function we need to use, we should visit the Server Functions List. First, we need a function to get the player's position. Since players are Elements, we first jump to the Element functions where we find the getElementPosition function. By clicking on the function name in the list, you get to the function description. There we can see the syntax, what it returns, and usually an example. The syntax shows us what arguments we can or have to submit.\n\nFor getElementPosition, the syntax is:\n\nThe three float in front of the function name is the return type. In this case, it means the function returns three floating-point numbers. (x, y, and z) Within the parentheses, you can see what arguments you have to submit. In this case, only the element whose position you want to get, which is the player in our example.\n\nNext, we want to ensure that the vehicle won't spawn directly in the player, so we add a few units to the x variable, which will make it spawn east from the player.\n\nNow we need another function, one to spawn a vehicle. We once again search for it on the Server Functions List, this time - since we are talking about vehicles - in the Vehicle functions section, where we will choose createVehicle. In this function's syntax, we only have one return type (which is more common), a vehicle element that points to the vehicle we just created. Also, we see that some arguments are enclosed within [ ] which means that those are optional.\n\nWe already have all arguments we need for createVehicle in our function: The position we just calculated in the x,y,z variables and the model id that we provided through the command (\"createvehicle 468\") and can access in the function as vehicleModel variable.\n\nOf course, this code can be improved in many ways, but at least we want to add a check whether the vehicle was created successfully or not. As we can read on the createVehicle page under Returns, the function returns false when it was unable to create the vehicle. Thus, we check the value of the createVehicle variable.\n\nNow we have our complete script:\n\nAs you can see, we introduced another function with outputChatBox. By now, you should be able to explore the function's documentation page yourself. For more advanced scripting, please check out the Map Manager.\n\nWhat you need to know\n\nYou already read some things about resources, command handlers, and finding functions in the documentation in the first paragraph, but there is much more to learn. This section will give you a rather short overview over some of these things while linking to related pages if possible.\n\nYou may have already noticed these or similar terms (Server/Client) somewhere on this wiki, mostly in conjunction with functions. MTA not only supports scripts that run on the server and provide commands (like the one we wrote above) or other features but also scripts that run on the MTA client the players use to connect to the server. The reason for this is, that some features MTA provides have to be clientside (like a GUI - Graphical User Interface), others should be because they work better and still, others are better off to be serverside or just don't work clientside.\n\nMost scripts you will make (gamemodes, maps) will probably be serverside, like the one we wrote in the first section. If you run into something that can't be solved serverside, you will probably have to make it clientside. For a clientside script, for example, you would create an ordinary script file (for example called client.lua) and specify it in the meta.xml, like this:\n\nThe type attribute defaults to 'server', so you only need to specify it for client-side scripts. When you do this, the clientside script will be downloaded to the player's computer once he connects to the server. Read more about Client side scripts.\n\nThe previous section showed briefly how to add clientside scripts to the resource, but there is also much more possible. As mentioned at the very top of this page, resources can be pretty much everything. Their purpose is defined by what they do. Let's have some theoretical resources, by looking at the files it contains, the meta.xml and what they might do:\n• The commands.lua provides some admin commands, like banning a player, muting or something else that can be used to admin the server\n• The client.lua provides a GUI to be able to perform the mentioned actions easily\n\nThis example might be running all the time (maybe even auto-started when the server starts) as it's useful during the whole gaming experience and also won't interfere with the gameplay, unless an admin decides to take some action of course.\n• The counterstrike.lua contains similar to the following features:\n• Let players choose their team and spawn them\n• Provide them with weapons, targets, and instructions (maybe read from a Map, see below)\n• Define the game's rules, e.g. when does the round end, what happens when a player dies\n• .. and maybe some more\n• The buymenu.lua is a clientside script and creates a menu to buy weapons\n\nThis example can be called a gamemode, since it not only interferes with the gameplay but actually defines the rules of it. The type attribute indicates that this example works with the Map manager, yet another resource that was written by the QA Team to manage gamemodes and map loading. It is highly recommended that you base your gamemodes on the techniques it provides.\n\nThis also means that the gamemode probably won't run without a map. Gamemodes should always be as generic as possible. An example of a map is stated in the next example.\n• The airport.map in an XML file that provides information about the map to the gamemode, these may include:\n• Where the players should spawn, with what weapons, what teams there are\n• What the targets are\n• The airport.lua might contain map-specific features, that may include:\n• Opening some door/make something explode when something specific happens\n• Create or move some custom objects, or manipulate objects that are created through the .map file\n• .. anything else map-specific you can think of\n\nAs you can see, the type attribute changed to 'map', telling the Map manager that this resource is a map, while the gamemodes attribute tells it for which gamemodes this map is valid, in this case, the gamemode from the above example. What may come as a surprise is that there is also a script in the Map resource. Of course, this is not necessarily needed in a map but opens a wide range of possibilities for map makers to create their own world within the rules of the gamemode they create it for.\n\nThe airport.map file might look similiar to this:\n\nWhen a gamemode is started with a map, the map resources are automatically started by the map-manager and the information it contains can be read by the gamemode resource. When the map changes, the current map resource is stopped and the next map resource is started. For a more in-depth explanation and examples of how map resources are utilized in the main script, please visit the Writing Gamemodes page.\n\nEvents are the way MTA tells scripts about things that happen. For example, when a player dies, the onPlayerWasted event is triggered. In order to perform any actions when a player dies, you have to prepare yourself similar to adding a command handler, as shown in the first chapter.\n\nThis example will output a message with the name of the player who died:\n\nInstead of showing what arguments are needed, the documentation page for Events shows what parameters are passed to the handler function, similar to the way a command handler does, just that it is different from event to event. Another important point is the source variable, that exists in handler functions. It doesn't have to be added to the parameter list of the function, but it still exists. It has a different value from event to event, for player events (as in the example above) it is the player element. As another example, you can take a look at the basic spawning player script in the first section to get an idea of how source is used.\n\nWhere to go from here\n\nYou should now be familiar with the most basic aspects of MTA scripting and also a bit with the documentation. The Main Page provides you with links to more information, Tutorials, and References that allow a deeper look into the topics you desire to learn about."
    },
    {
        "link": "https://wiki.multitheftauto.com/wiki/Main_Page",
        "document": "Welcome to the Multi Theft Auto wiki. On this wiki you'll find a wealth of information on using Multi Theft Auto.\n\nThere are many things you can do to help us improve MTA - create a map, a gamemode, help document scripting functions, write example code, write tutorials or just play MTA and report the bugs you find.\n\nIf you have any questions or problems related to scripting, feel free to get in touch with us on Discord."
    },
    {
        "link": "https://commandlua.github.io/index2.html",
        "document": ""
    },
    {
        "link": "https://github.com/multitheftauto/mtasa-blue/issues/1591",
        "document": "As briefly discussed in #1459, we should implement a Lua API version which is set via .\n\nWe always want to ensure backwards-compatibility when making changes to code, however this may prevent us from:\n• Making \"beneficial\" changes (that would break backwards-compatibility)\n\nAn example of this is with CEGUI, where functionality in newer versions may differ from the version we're currently using. By default, we'll ensure everything looks/feels and functions the same as before, however this may prevent new features/changes in CEGUI being used (or at least implemented cleanly).\n\nThe server/resource should decide if they care about backwards-compatibility over improved functionality.\n\nAnother example may be when \"extended\" function alternatives have been suggested (#638) - instead of adding a separate function we'd simply allow them to set the API version specifically for this function, e.g:\n\nI haven't really thought about how exactly this will be implemented or configured via meta.xml, so input here would be great."
    },
    {
        "link": "https://lua.org/docs.html",
        "document": "The reference manuals for all versions of Lua are available online in English. Some are available in other languages and as a printed book.\n\nLua – an extensible extension language This paper was awarded the first prize (technological category) in the II Compaq Award for Research and Development in Computer Science in 1997. This award was a joint venture of Compaq Computer in Brazil, the Brazilian Ministry of Science and Technology, and the Brazilian Academy of Sciences."
    },
    {
        "link": "https://forum.multitheftauto.com/topic/64228-the-ultimate-lua-tutorial",
        "document": "This tutorial is no longer maintained and it's contents may be deprecated or no longer work. I created this tutorial in 2014, when I was very involved with MTA and the community around it. Due to the nature of life, I ended up leaving MTA to focus on more important things (work, family, life, etc).\n\nI believe this tutorial has helped a lot of people get into scripting for MTA over the years, and I'm happy I was able to do answer questions and help people get into coding!\n\nHello everyone, and thank you for viewing my introduction for Lua scripting. This tutorial will cover the basics of Lua, but nothing too advanced. This tutorial is highly detailed and should give you a pretty good understanding on how Lua works, even if you have never coded it before. Something to remember is that I do not teach or even talk about using object-oriented programming in this tutorial.\n\n- Create a resource and what is required for one - Complete\n\n- Exports & how to call one - Complete\n\nSo, now that you know what you're going to be learning about, let's get started!\n\nIn this section of the tutorial, I'll be teaching what a variable is and what it is used for. First of all, if you have any prior programming experience, you are likely to know what a variable is. Even if you are good at math, you should know what one is. A variable is like what you did in math class, solve for . Only in programming you don't solve for the variable, you set them and you can call them when the script needs to know something. So, A variable something that the user defined in the script. For example, if you set the variable equal to 255, then whenever you call the variable, it will replace it with 255 when the script is ran. Luckly for you, Lua doesn't make you define what type of variable it is (such as a boolean, string, array, etc..) Below I will list some examples of variables. Now, in the example above, whenever the variable , it will replace itself with . Variables can be re-written or in other words, you can change what they mean, shown in the code below. First the variable was defined as but after that, it was updated to . Not only can variables be re-defined, but they can also be duplicated and destroyed.. -- Set the variable var equal to \"Hello World\" (the value of my_var) Now that you have a basic understanding of variables (hopefully), we can move on to the difference between global and local variables. Local variables are variables that won't be defined in the whole script, or resource. They are variables that are defined in the function that is being used. If the variable isn't inside of a function, and is defined at the top of the script, then it will only be used for the file that it's in. Examples below. Here is an example of a variable just being defined in a function: -- You'll learn what this means later The variable \"hello\" will only be valid in the function \"Hello\". This means that if another function tries to call the variable \"hello\" it will return nil because it isn't defined. Here is an example of a variable that is globally defined in a function. Now the variable is defined for the entire script, but only after the function is called, because Lua works on a line-by-line basis, it doesn't all just load at once. Alrighty, now I think you pretty know what a variable is and how it works, but if you you still don't have a clear understanding please visit http://lua.gts-stolberg.de/en/Variablen.php\n\nWhat is a table? If you have programmed in another language and know what an array is, that's basically what a table is. If you don't know what it is, it is basically something you can define to hold a bunch of data in a single variable. So, to being, first I need to explain how to create a table. Tables are created the same way as a variable, only what you define is different, you will define: . For example: Right now the table is empty, so there is nothing in it to be used. There are a few methods to adding data to a table, and I'll be going over them. The first method is to just put the data in it when the table is created.. Such as this: You can define as much data as you want in a table, there isn't a limit. Not only strings have to be defined in a table, anything can be, even more tables can be defined in a table! Tables are a good way to define your stuff, because it keeps things really organized. This method for defining data isn't really a good way, unless your putting in something like coordinates. Most people will use the next method to define their data: This method is used to define an index for a table. The index doesn't have to be a number, but it can be anything that you want (except nil, of course) That is how a lot of scripters like to define their data, because most of the data that they are insert into the table they don't even really know the value of. This method can also be used inside of a table as shown below, they will both do the same exact thing: Now, the last method to insert data to a table is using the default lua function . This function has two arguments that you'll need to have, the table variable and what you want to insert. This method is used sometimes, but not as often as the other two ways. Now you have a basic knowledge of tables, so we can move on to section, functions!\n\nFunctions are the things that MTA creates for scripters to customize their servers and make theme unique. Almost anything that you are going to do in Lua is going to involve some sort of function, whether it is outputting text, formatting a string, or encrypting data, it is all going to use a function of some-sort. So, it's actually very, very basic to make a function in Lua. All you really have to do is write: and then be sure to end the function with at the end. So, let's go head and make your very first function in Lua. So now we have a function defined as , but it doesn't do anything Let's fix that now! Let's make it write \"Function funct loaded\" to the chatbox. To write to the chatbox, we'll be using the function that MTA provides called outputChatBox. The outputChatBox arguments (for server side) are: text -> The text that we want to output outputElement -> The element that we want to output r -> The amount of red you want on a scale of 0-255 g -> The amount of green you want on a scale of 0-255 b -> The amount of blue you want on a scale of 0-255 Now that we have our functions, we're ready to make our function actually do something! So, let's say that we want to send the message to all of the players in the server. If you want to send it to all of the players, you would just put another function called getRootElement() or you can use the MTA defined variable . returns the same thing as getRootElement(), so it doesn't matter what you put. Alright, so now we have created a basic function! But it won't output \\: This function is loaded into the server, but it is never being called, therefore it will never output, all you have to do is call the function, by putting somewhere below the function. The script is working! Now you have created your very very basic function. Let's get crazy! Let's add some function arguments.. We can add an argument to set custom text. So, to add arguments, you have to declare them when the function is created by doing: . That would define you 3 arguments. Think of the arguments as local variables defined inside your function, because that is basically all they are, and you can define them whenever you call the function, anyway, let's go head and add ourself some arguments! Now that we have our argumnet defined, let's set it when the function is called. This is done by doing: . Great! You're doing awesome so far on learning Lua! Now that we have the argument defined, lets go head and put it somewhere in the script. We can just replace our old message with the new argument, so you just have to replace the text with the argument (not in a string) Good job so far, you'll be a Lua master in no time at all! Now that we have our script working good, let's combine a variable and a string in the chatbox message. This is done by doing Now that you know what a function is and what arguments are, let's try adding some more arguments.. What should we do? Let's add some color codes shall we? All we basically are doing is re-creating the outputChatBox function. Feelin' like a scripter yet? Good! You're on the way to success.\n\nSo, now you're like a Lua professional! What is a loop? A loop is something to execute a piece of code amount of times. There are three types of loops that I'll be covering in this topic; table loops (pairs/ipairs), number loops (for i=x;10), and while loops. Let's just jump right into it! This type of loop is used to loop through everything inside of a table. It runs through all of the table index's and you can just do whatever you want with them. For the first example, I'll be getting all of the players in the server using getElementsByType(\"player\"). I'll get their names and output them to the chatbox, using the function that you should know by now, outputChatBox. \"The server says hello to \" In the example below, the script will get all of the players, put them into a table, and then put the table variable as . After all of the players are gotten and stored in the variable, it begins a for loop through the table. Index is the ID of the table that the loop is currently running, and player is what it returns in that index. is returning the players name, and then we output it. This type of loop is used, if the scripter knows exactly how much he wants the piece of code to run. It goes in the format and index is the variable that you're using for the number, 0 is the number that you want the table to begin at, and 100 is the number that you want the loop to go to. So, we're just going to make a loop for color codes, it will output the RGB color code, and make it the color that it is. This will be done be making a loop start at 0 and run to 255. Kinda colorful don'tcha think? As I'm sure you can see, loops are actually pretty basic to use, but they're EXTREMELY useful for coders. A while loops is a little bit different than the other two. A while loop runs while the argument that you put is true, or it reaches break. It is always important to make sure this loop ends, because if it doesn't your entire script will stop working and you'll get a stack overflow error message. We'll write the script that we just did, except this time in a while loop using a variable, and adding 1 to the variable each time. Something that is really useful when you're dealing with loops, is using or . When you use one of these methods, it will stop the loop immediately. For example, if you are running a while loop, and the statement is always going to be true, then you're going to need to use or . These are usually done using a basic statement. in the above script, it will always output chat if we didn't add a break. Once it outputs 200 times the will become true, and then it will stop the loop.\n\nAn if is just what you think it is. It is a thing to check if your arguments are valid. If they are valid, then the code will continue to run. If it isn't then it'll look for elseif, until it finds one that is true. If it can't find an elseif then it will simply run the else. If statements are really, really important when it comes to any type of programming. Whether it is Java, C++, or Lua, you need to know how to use an if statement, because there isn't much you can do without it. Let's get started with some basic if statements. -- Check to see if [i]player[/i] is equal to \"xXMADEXx\" \"This is your message!(:\" That code will work without a problem because the statement is returning true. Now, let's make it return false, and watch the results. -- Check to see if [i]player[/i] is equal to \"xXMADEXx\" \"This is your message!(:\" As you can see for that script, it will output to the console rather than outputting to the xXMADEXx player. Now, let's add another statement to check if the xXMADEXx player exists in the server. -- Check to see if [i]player[/i] is equal to \"xXMADEXx\" \"If Tutorial: The player variable is equal to \" \"This is your message!(:\" In that script, if is equal to xXMADEXx, then it would output to xXMADEXx, if he was in the server. If he wasn't then it out send a debug message saying that he wasn't in the server. As you can see, if statements are highly important, and really easy to do. Almost any script that you will make will have at least one if statement. Now, let's make: if -> elseif -> else. -- Check to see if [i]player[/i] is equal to \"xXMADEXx\" \"If Tutorial: xXMADEXx isn't present, but r was higher than 50.\" \"If Tutorial: The player variable is equal to \" \"This is your message!(:\" As you can see, if statements are really useful and easy to do. More info @ http://www.lua.org/pil/4.3.1.html\n\nGood, you've made it this far, you have what it takes to be a successful scripter, without a doubt! Now, I'm sure you want to learn how to add commands, because they're fast and easy to both create and execute. To add a command, you just stimply need to use the function addCommandHandler. Simple as that, just throw in your command name and the callback function! Here, let's get you started to just make a simple /kill command. Now, as you see in the code before, the player who executed the command is NOT as many new people to scripting MTA might think, don't be ashamed though, that's exactly what I thought when I first used the function. The player, the one who executed the command will be defined to the first argument of the callback function, so in my little command script, it just set the player to the variable (go figure lol). So, now let's build a bit of a more advanced command to do and where is, you can enter a number and it'll spawn a vehicle to you. Let's get started!! -- Now we know he has a vehicle ID (arg1) and it's an integer, now we need to check if it's between 400 and 611. -- Let's convert and round it, to prevent \"code-buggers\" As you can see in the code above, it's pretty straight forward. When you enter the command it'll run the function. will be set to the first argument that the player gives in the command. (This: ) will be set to the value that the user gives. First the function will check to see if the argument exists, and if it does, or the argument cannot be converted to a number then it will output a simple syntax error and stop the function with . If exists, and it can be converted to a number, then the code will take the value, convert it to a number, then round it to the lowest number if it's a decimal. After that, it checks if the number is a valid vehicle ID, and if it isn't then it just outputs a basic error saying it's invalid. If it is a valid number, it'll get the players position and rotation, then create a vehicle in the position and set the rotation Z axis to the players, then warp the player in and output a message.\n\nYou might be asking yourself, what is an export? Well, when you create a function, if it's global or a local function, MTA will make it only accessable by your resource. When you try to call the function in another resource, it'll say that it is undefined. An export gives you the ability to call a function that is contained in another resource. For example, in my resource TopBarChat (It's horrible English, I know) I made the function exported, so it can be used in any resource. Now, it's actually very easy to add an export, it's all about the meta. You just need an tag, with an attribute which is equal to the function that you want to export, and an optional attribute which tells whether it's a server or client function, server by default. There's some other attributes, however i'm not going to get into them because they're more for web-based applications. Let's say I have a resource named and it contains a function with the arguments:\n• - - A string of the message\n\n - - The player element to output to\n\n - - the R color from RGB\n\n - - the G color from RGB\n\n - - the B color from RGB So, in the resource, let's go head and create the server-side function. Now that the function is created, we need to create the meta. Now that we have our meta, we need to add the following line to export the function into other resources. Basically, the export line in the meta adds the function to a table called under the index of the resource name. Pretty basic right? Here is a basic diagram of the exports table: Say we have another resource, and we want to call the function that is exported in the resource. All you have to do is call the exports -> resource -> function_name. Here's what it would look like for the messages resource and the function message function: The main reason I never use method 3 is because it's easier to get confused, and it takes longer to type. I typically do method 1, but sometimes method 2.\n\nGood luck with your Lua scripting career, I hope that this tutorial has helped you!"
    },
    {
        "link": "https://wiki.multitheftauto.com/wiki/Scripting_Introduction",
        "document": "Resources are a key part of MTA. A resource is essentially a folder or zip file that contains a collection of files, plus a \"meta\" file that describes to the server how the resource should be loaded and what files it does contain. A resource can be seen as being partly equivalent to a program running in an operating system - it can be started and stopped, and multiple resources can run at once.\n\nEverything that has to do with scripting happens in resources, what a resource does defines if it is a gamemode, a map, or anything else. MTA comes with resources that you can optionally use in your gamemodes, such as map limits to keep playings within a playing area or death-pickups to create weapon pickups.\n\nWe will first learn how to make a basic script that lets the player walk around in the city, step by step.\n\nWhere are all the scripts?\n\nLet's take a look at the script's file structure. Go to your MTA Server folder, and follow the path below:\n\nYou will see a lot of .zip files, which are the packaged sample scripts shipped with MTA. Each file is a \"resource\", and they will all be unzipped and loaded by the server when it starts. To create your own resource, simply make a folder with your preferred name. We'll use \"myserver\" for this tutorial.\n\nNow you should be under this directory:\n\nIn order to let the server know what's in the resource, a meta.xml file must be created to list the resource's content. It must be located in the resource's root directory, which is the \"myserver\" folder in our case. So create a text file and name it \"meta.xml\", and open it with notepad.\n\nEnter the following codes in the meta.xml file:\n\nIn the <info /> tag, there's a \"type\" field which indicates that the resource is a gamemode instead of a regular include or a map, which will be explained later. A gamemode is what you need to make a stand-alone server.\n\nThe <script /> tag indicates the script files contained in the resource, which we will create next.\n\nNote that in the <script /> tag above, the .lua file is not under another directory. Therefore we'll create the file in the same folder as meta.xml. Now you can copy and paste the following code into script.lua:\n\nThe script will spawn you at the coordinate (x, y, z) specified above when you join the game. Note that the fadeCamera function must be used or the screen will be black. Also, in releases after DP2, you need to set the camera target (otherwise all the players will see is the blue sky).\n\nThe source variable indicates who triggered the event. Since a player has joined when the code is triggered, you use this variable to look which has joined. So it'll spawn that player instead of everyone or a random person.\n\nIf we have a closer look on addEventHandler, you can see 3 things: 'onPlayerJoin', which indicates when it's triggered. getRootElement(), which shows by what/who it can be triggered. (getRootElement() is everything/everyone) And joinHandler, which indicates the function that has to be triggered after the event is triggered. Other details will be explained later in another example, now let's just run the server and try it out!\n\nTo get the server started, simply run the executable under the server/ directory. A list of server stats will be shown first; note the port number, which you'll need when joining the game. Then the server loads all the resources under the mods/deathmatch/resources/ directory, and then \"ready to accept connections!\"\n\nBefore you connect to the server, you must run the gamemode. Type \"start myserver\" and press Enter. The server will start the gamemode you just created, and will also show any errors and warnings from this point on. Now you can start the MTA client, and \"Quick Connect\" using the IP address of your server and the port number you saw earlier. If all goes well, after a few seconds your character will be walking on the streets of Los Santos.\n\nNext, we'll add a command to your script that players can use to spawn a vehicle beside their position. You may skip it and check out more advanced scripting with the Map Manager, which continues this tutorial. Another branch from this tutorial is Introduction to Scripting GUI, you may follow it to see how the Graphical User Interface in MTA is drawn and scripted.\n\nLet's go back to the content of the script.lua file. As mentioned above, we want to provide a command to create a vehicle beside your current position in the game. Firstly we need to create a function we want to call and a command handler that creates the command the player will be able to enter in the console.\n\nNote: Function names are clickable in code examples on the wiki and linked to the functions' documentation.\n\nThe first argument of addCommandHandler is the name of the command the player will be able to enter, the second argument is the function this will call, in this case createVehicleForPlayer.\n\nIf you have already experienced in scripting, you will know that you call a function like this:\n\nIf we have a closer look on the lower example above, we can see argument1 is thePlayer and argument2 the commandName. thePlayer is simply the one who typed the command, so whatever you call it, the variable will contain the player who activated the command. commandName is simply the command they typed. So if they typed \"/greet\", this argument will contain \"greet\". Argument 3 is something extra the player typed, you'll learn it a little bit further in the tutorial. Never forget that the first 2 arguments are standard arguments, but you can name them to anything you want.\n\nWe called the addCommandHandler function this way already and since createVehicleForPlayer is a function too, it can be called that way as well. But we are using a command handler for that, which calls it in a similar manner, internally.\n\nFor example someone types \"createvehicle 468\" in-game in the console to spawn a Sanchez, the command handler calls the createVehicleForPlayer function, as if we would have this line of code in the script:\n\nAs we can see, it provides several parameters: the player who called the command, the command he entered, and whatever text he had after that, in this case, \"468\" as vehicle id for the Sanchez. The first two parameters are the same with all command handlers, which you can read on the addEventHandler page. For this fact, you always have to define at least those two parameters to use any after that (for example to process text that was entered after the command, like in our example the vehicle model id).\n\nNote: You have to add the command handler AFTER you defined the handler function, else it can't find it. The order of execution matters.\n\nIn order to fill the function we created, we need to think about what we have to do:\n• Get the players position, so we know where to spawn the vehicle (we want it to appear right beside the player)\n• Calculate the position we want to spawn the vehicle at (we don't want it to appear in the player)\n• Check if it has been spawned successfully, or output a message\n\nIn order to achieve our goals, we have to use several functions. To find the function we need to use, we should visit the Server Functions List. First, we need a function to get the player's position. Since players are Elements, we first jump to the Element functions where we find the getElementPosition function. By clicking on the function name in the list, you get to the function description. There we can see the syntax, what it returns, and usually an example. The syntax shows us what arguments we can or have to submit.\n\nFor getElementPosition, the syntax is:\n\nThe three float in front of the function name is the return type. In this case, it means the function returns three floating-point numbers. (x, y, and z) Within the parentheses, you can see what arguments you have to submit. In this case, only the element whose position you want to get, which is the player in our example.\n\nNext, we want to ensure that the vehicle won't spawn directly in the player, so we add a few units to the x variable, which will make it spawn east from the player.\n\nNow we need another function, one to spawn a vehicle. We once again search for it on the Server Functions List, this time - since we are talking about vehicles - in the Vehicle functions section, where we will choose createVehicle. In this function's syntax, we only have one return type (which is more common), a vehicle element that points to the vehicle we just created. Also, we see that some arguments are enclosed within [ ] which means that those are optional.\n\nWe already have all arguments we need for createVehicle in our function: The position we just calculated in the x,y,z variables and the model id that we provided through the command (\"createvehicle 468\") and can access in the function as vehicleModel variable.\n\nOf course, this code can be improved in many ways, but at least we want to add a check whether the vehicle was created successfully or not. As we can read on the createVehicle page under Returns, the function returns false when it was unable to create the vehicle. Thus, we check the value of the createVehicle variable.\n\nNow we have our complete script:\n\nAs you can see, we introduced another function with outputChatBox. By now, you should be able to explore the function's documentation page yourself. For more advanced scripting, please check out the Map Manager.\n\nWhat you need to know\n\nYou already read some things about resources, command handlers, and finding functions in the documentation in the first paragraph, but there is much more to learn. This section will give you a rather short overview over some of these things while linking to related pages if possible.\n\nYou may have already noticed these or similar terms (Server/Client) somewhere on this wiki, mostly in conjunction with functions. MTA not only supports scripts that run on the server and provide commands (like the one we wrote above) or other features but also scripts that run on the MTA client the players use to connect to the server. The reason for this is, that some features MTA provides have to be clientside (like a GUI - Graphical User Interface), others should be because they work better and still, others are better off to be serverside or just don't work clientside.\n\nMost scripts you will make (gamemodes, maps) will probably be serverside, like the one we wrote in the first section. If you run into something that can't be solved serverside, you will probably have to make it clientside. For a clientside script, for example, you would create an ordinary script file (for example called client.lua) and specify it in the meta.xml, like this:\n\nThe type attribute defaults to 'server', so you only need to specify it for client-side scripts. When you do this, the clientside script will be downloaded to the player's computer once he connects to the server. Read more about Client side scripts.\n\nThe previous section showed briefly how to add clientside scripts to the resource, but there is also much more possible. As mentioned at the very top of this page, resources can be pretty much everything. Their purpose is defined by what they do. Let's have some theoretical resources, by looking at the files it contains, the meta.xml and what they might do:\n• The commands.lua provides some admin commands, like banning a player, muting or something else that can be used to admin the server\n• The client.lua provides a GUI to be able to perform the mentioned actions easily\n\nThis example might be running all the time (maybe even auto-started when the server starts) as it's useful during the whole gaming experience and also won't interfere with the gameplay, unless an admin decides to take some action of course.\n• The counterstrike.lua contains similar to the following features:\n• Let players choose their team and spawn them\n• Provide them with weapons, targets, and instructions (maybe read from a Map, see below)\n• Define the game's rules, e.g. when does the round end, what happens when a player dies\n• .. and maybe some more\n• The buymenu.lua is a clientside script and creates a menu to buy weapons\n\nThis example can be called a gamemode, since it not only interferes with the gameplay but actually defines the rules of it. The type attribute indicates that this example works with the Map manager, yet another resource that was written by the QA Team to manage gamemodes and map loading. It is highly recommended that you base your gamemodes on the techniques it provides.\n\nThis also means that the gamemode probably won't run without a map. Gamemodes should always be as generic as possible. An example of a map is stated in the next example.\n• The airport.map in an XML file that provides information about the map to the gamemode, these may include:\n• Where the players should spawn, with what weapons, what teams there are\n• What the targets are\n• The airport.lua might contain map-specific features, that may include:\n• Opening some door/make something explode when something specific happens\n• Create or move some custom objects, or manipulate objects that are created through the .map file\n• .. anything else map-specific you can think of\n\nAs you can see, the type attribute changed to 'map', telling the Map manager that this resource is a map, while the gamemodes attribute tells it for which gamemodes this map is valid, in this case, the gamemode from the above example. What may come as a surprise is that there is also a script in the Map resource. Of course, this is not necessarily needed in a map but opens a wide range of possibilities for map makers to create their own world within the rules of the gamemode they create it for.\n\nThe airport.map file might look similiar to this:\n\nWhen a gamemode is started with a map, the map resources are automatically started by the map-manager and the information it contains can be read by the gamemode resource. When the map changes, the current map resource is stopped and the next map resource is started. For a more in-depth explanation and examples of how map resources are utilized in the main script, please visit the Writing Gamemodes page.\n\nEvents are the way MTA tells scripts about things that happen. For example, when a player dies, the onPlayerWasted event is triggered. In order to perform any actions when a player dies, you have to prepare yourself similar to adding a command handler, as shown in the first chapter.\n\nThis example will output a message with the name of the player who died:\n\nInstead of showing what arguments are needed, the documentation page for Events shows what parameters are passed to the handler function, similar to the way a command handler does, just that it is different from event to event. Another important point is the source variable, that exists in handler functions. It doesn't have to be added to the parameter list of the function, but it still exists. It has a different value from event to event, for player events (as in the example above) it is the player element. As another example, you can take a look at the basic spawning player script in the first section to get an idea of how source is used.\n\nWhere to go from here\n\nYou should now be familiar with the most basic aspects of MTA scripting and also a bit with the documentation. The Main Page provides you with links to more information, Tutorials, and References that allow a deeper look into the topics you desire to learn about."
    },
    {
        "link": "https://saessupport.wordpress.com/scriptingmapping/54-2",
        "document": "Welcome to my first of series tutorials of MTA Lua scripting. I will do my best to explain this in a more noob-friendly way than MTA Wiki does. I hope some of our community scripters will help me out a bit and suggest what to improve to make this easy to understand.\n\nSo let’s get started. I will be following some Wiki way of learning, so we are starting with “Locating your Resources folder”\n\nThis folder contains all the resources your server will run, including maps, scripts, gamemodes et cetera.\n\n Locating:\n\n1) Find your Multi Theft Auto directory (By default (for Windows users) it’s in Program Files, Disk C)\n\n 2) Open MTA Directory, then folder “server” > “mods” > “deatchmatch” > “resources”\n\n There we go, you’re now here: MTA San Andreas 1.3\\server\\mods\\deathmatch\\resources\n\nNow when you have located where your resources folder is, you may see bunch of .rar files and folders. These are all scripts and gamemodes provided by MTA and everyone should have them as they come by default with your MTA installation.\n\nThere are two things your resource HAS to contain:\n\n1) meta.xml – Meta is basicly telling the server what your resource contains and how should the files within be used, your resource cannot work without a working meta!!\n\n 2) file.lua – the .lua file is your script which should be defined in your meta.xml (detailed explanation further in tutorial)\n\nMeta.xml should look like this:\n\n<meta>\n\n <info author=”YourName” type=”script” name=”My First Resource” description=”This is my first resource” />\n\n <script src=”file.lua” type=”server” />\n\n </meta>\n\nauthor – self explanatory, the author of this resource, you may put your name here\n\n type – type of your resource, we will use “script”\n\n name – name your script\n\n description – optional, explain what your script does in couple of words\n\nand the most important part:\n\n <script src=”file.lua” type=”server” />\n\n src – the name must correspond to your script name, if it is named myscript.lua then we will rename it from file.lua to myscript.lua\n\n Why? Because meta needs correct info so it could load your script for server\n\n type – client or server – by default (if not defined) the type of script will be server\n\nI think that should be clear now.\n\nLET’S CREATE YOUR FIRST SCRIPT!\n\n Useful tools: Notepad++ (Highly recommended, highlights your functions and make scripting A LOT easier) or [WIP]Unofficial MTA Script Editor\n\nAll MTA functions are located here: The official MTA Wiki page\n\n Before we start. MTA uses two type of functions – clientside and serverside. Difference you mean? Clientside functions and Serversided CANNOT work in a same script. Clientsided files (scripts) are downloaded to your computer when joining a server while serversided files don’t. We will be making a serversided script therefore we are going to use server functions (Note: Many MTA functions can be used in clientside and serverside, but some are only working in serverside/clientside scripts!). If this part isn’t clear enough, post below.\n\nLet’s start this already, shall we.\n\nLet’s break this code into pieces and explain part by part.\n\n function outputName ()\n\n “function” indicates start of our code, let’s say it that way\n\n “outputName” – this is the name of our function, it can be anything you wish, but let’s keep the name of function related to our code\n\n “()” – brackets are used for some additional arguments which we will need for our code, in this case we leave those empty because we don’t need any other arguments in there\n\noutputChatBox is both, client and server side function, which means you can use it in both type of scripts. It’s name is self-explanatory, it outputs a string (text) in our chatbox. Every function has arguments, let’s see what this one has: outputChatBox (string=text, visibleTo=who will the message be visible to, R=red, G=green, B=blue, colorCodes=true or false, will the message support hex codes (optional))\n\n Notice that we are using another function which is called getPlayerName, that function gets some player’s name and whose name will it be is indicated in brackets which is “source” in this case (source is the player who joined the game)\n\nend – We always have to end our function somewhere, therefore we use end to mark the end of our function called outputName\n\naddEventHandler – this adds the event which triggers our function, in this case our event is “onPlayerJoin” <- once again, self-explanatory – when player joins our server, he will trigger our function called outputName and he will get a message like: Welcome to the server Mega9\n\n We also have client and server events (list can be found on our dear friend MTA Wiki. addEventHandler also has arguments, following: addEventHandler (eventName (“onPlayerJoin”), whoCanTriggerEvent (getRootElement() – everybody), function name (outputName))\n\nLet’s test your first script. Create a folder (or ZIP archive) in your resources directory, name it properly (without spaces), place your meta.xml and your script.lua inside it. Start your server and in console (black window) type: start resourcename\n\n Now join your server and see what happens."
    },
    {
        "link": "https://docsbot.ai/prompts/technical/lua-mta-security-tester",
        "document": ""
    },
    {
        "link": "https://github.com/multitheftauto/mtasa-blue",
        "document": "Multi Theft Auto (MTA) is a software project that adds network play functionality to Rockstar North's Grand Theft Auto game series, in which this functionality is not originally found. It is a unique modification that incorporates an extendable network play element into a proprietary commercial single-player PC game.\n\nNote If you're a fork developer, please read this note carefully. We have changed the default build type back to CUSTOM in . If you're developing without the anti-cheat in mind, say in the Debug configuration, this doesn't affect you at all. Now, if you plan to test your custom client with anti-cheat enabled, you should change your build type to . If you want to publish a release of your custom client, you must switch to a fork support hardened release of . Please read our Forks_Full_AC wiki page for more information.\n\nMulti Theft Auto is based on code injection and hooking techniques whereby the game is manipulated without altering any original files supplied with the game. The software functions as a game engine that installs itself as an extension of the original game, adding core functionality such as networking and GUI rendering while exposing the original game's engine functionality through a scripting language.\n\nOriginally founded back in early 2003 as an experimental piece of C/C++ software, Multi Theft Auto has since grown into an advanced multiplayer platform for gamers and third-party developers. Our software provides a minimal sandbox style gameplay that can be extended through the Lua scripting language in many ways, allowing servers to run custom created game modes with custom content for up to hundreds of online players.\n\nFormerly a closed-source project, we have migrated to open-source to encourage other developers to contribute as well as showing insight into our project's source code and design for educational reasons.\n\nMulti Theft Auto is built upon the \"Blue\" concept that implements a game engine framework. Since the class design of our game framework is based upon Grand Theft Auto's design, we are able to insert our code into the original game. The game is then heavily extended by providing new game functionality (including tweaks and crash fixes) as well as a completely new graphical interface, networking and scripting component.\n\nBy default, Multi Theft Auto provides the minimal sandbox style gameplay of Grand Theft Auto. The gameplay can be heavily extended through the use of the Lua scripting language that has been embedded in the client and server software. Both the server hosting the game, as well as the client playing the game are capable of running and synchronizing Lua scripts. These scripts are layered on top of Multi Theft Auto's game framework that consists of many classes and functions so that the game can be adjusted in virtually any possible way.\n\nAll gameplay content such as Lua scripts, images, sounds, custom models or textures is grouped into a \"resource\". This resource is nothing more than an archive (containing the content) and a metadata file describing the content and any extra information (such as dependencies on other resources).\n\nUsing a framework based on resources has a number of advantages. It allows content to be easily transferred to clients and servers. Another advantage is that we can provide a way to import and export scripting functionality in a resource. For example, different resources can import (often basic) functionality from one or more common resources. These will then be automatically downloaded and started. Another feature worth mentioning is that server administrators can control the access to specific resources by assigning a number of different user rights to them.\n\nOur project's code repository can be found on the multitheftauto/mtasa-blue Git repository at GitHub. We are always looking for new developers, so if you're interested, here are some useful links:\n\nVisit the wiki article \"Compiling MTASA\" for additional information and error troubleshooting.\n\nYou can build the MTA:SA server on GNU/Linux distributions only for x86, x86_64, armhf and arm64 CPU architectures. ARM architectures are currently in experimental phase, which means they're unstable, untested and may crash randomly. Beware that we only officially support building from x86_64 and that includes cross-compiling for x86, arm and arm64.\n\nPlease always read the Dockerfiles for up-to-date build dependencies. Note: ncftp is not required for building the MTA:SA server.\n\nNote: This script always deletes and directories and does a clean build.\n\nIf build architecture is not provided, then it's taken from the environment variable (defaults to: x64).\n\nIf build configuration is not provided, then it's taken from the environment variable (defaults to: release).\n\nIf you are trying to cross-compile to another architecture, then set , , , environment variables accordingly (see Dockerfile.arm64 for an example).\n\nIf you don't want to build the release configuration for the x86_64 architecture, you can instead pick another build configuration from: .\n\nIf you have problems resolving the required dependencies or want maximum compatibility, you can use our dockerized build environment that ships all needed dependencies. We also use this environment to build the official binaries.\n\nThese examples assume that your current directory is the mtasa-blue checkout directory. You should also know that is the code directory required by our Docker images inside the container. If the current directory is not a valid git repository, it instead create a (shallow) clone of the mtasa-blue repository. After compiling, you will find the resulting binaries in . To build the unoptimised debug build, add to the docker run arguments.\n\nUnless otherwise specified, all source code hosted on this repository is licensed under the GPLv3 license. See the LICENSE file for more details.\n\nGrand Theft Auto and all related trademarks are © Rockstar North 1997–2024."
    }
]