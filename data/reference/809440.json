[
    {
        "link": "https://docs.python.org/3/tutorial/inputoutput.html",
        "document": "There are several ways to present the output of a program; data can be printed in a human-readable form, or written to a file for future use. This chapter will discuss some of the possibilities.\n\nSo far we’ve encountered two ways of writing values: expression statements and the function. (A third way is using the method of file objects; the standard output file can be referenced as . See the Library Reference for more information on this.) Often you’ll want more control over the formatting of your output than simply printing space-separated values. There are several ways to format output.\n• None To use formatted string literals, begin a string with or before the opening quotation mark or triple quotation mark. Inside this string, you can write a Python expression between and characters that can refer to variables or literal values.\n• None The method of strings requires more manual effort. You’ll still use and to mark where a variable will be substituted and can provide detailed formatting directives, but you’ll also need to provide the information to be formatted. In the following code block there are two examples of how to format variables: Notice how the are padded with spaces and a negative sign only for negative numbers. The example also prints multiplied by 100, with 2 decimal places and followed by a percent sign (see Format Specification Mini-Language for details).\n• None Finally, you can do all the string handling yourself by using string slicing and concatenation operations to create any layout you can imagine. The string type has some methods that perform useful operations for padding strings to a given column width. When you don’t need fancy output but just want a quick display of some variables for debugging purposes, you can convert any value to a string with the or functions. The function is meant to return representations of values which are fairly human-readable, while is meant to generate representations which can be read by the interpreter (or will force a if there is no equivalent syntax). For objects which don’t have a particular representation for human consumption, will return the same value as . Many values, such as numbers or structures like lists and dictionaries, have the same representation using either function. Strings, in particular, have two distinct representations. The value of x is 32.5, and y is 40000... # The repr() of a string adds string quotes and backslashes: # The argument to repr() may be any Python object: The module contains a class that offers yet another way to substitute values into strings, using placeholders like and replacing them with values from a dictionary, but offers much less control of the formatting. Formatted string literals (also called f-strings for short) let you include the value of Python expressions inside a string by prefixing the string with or and writing expressions as . An optional format specifier can follow the expression. This allows greater control over how the value is formatted. The following example rounds pi to three places after the decimal: 'The value of pi is approximately The value of pi is approximately 3.142. Passing an integer after the will cause that field to be a minimum number of characters wide. This is useful for making columns line up. Other modifiers can be used to convert the value before it is formatted. applies , applies , and applies : 'My hovercraft is full of My hovercraft is full of eels. 'My hovercraft is full of My hovercraft is full of 'eels'. The specifier can be used to expand an expression to the text of the expression, an equal sign, then the representation of the evaluated expression: See self-documenting expressions for more information on the specifier. For a reference on these format specifications, see the reference guide for the Format Specification Mini-Language. Basic usage of the method looks like this: We are the knights who say \"Ni!\" The brackets and characters within them (called format fields) are replaced with the objects passed into the method. A number in the brackets can be used to refer to the position of the object passed into the method. If keyword arguments are used in the method, their values are referred to by using the name of the argument. Positional and keyword arguments can be arbitrarily combined: The story of Bill, Manfred, and Georg. If you have a really long format string that you don’t want to split up, it would be nice if you could reference the variables to be formatted by name instead of by position. This can be done by simply passing the dict and using square brackets to access the keys. This could also be done by passing the dictionary as keyword arguments with the notation. This is particularly useful in combination with the built-in function , which returns a dictionary containing all local variables: __name__: __main__; __doc__: None; __package__: None; __loader__: ... As an example, the following lines produce a tidily aligned set of columns giving integers and their squares and cubes: For a complete overview of string formatting with , see Format String Syntax. Here’s the same table of squares and cubes, formatted manually: # Note use of 'end' on previous line The method of string objects right-justifies a string in a field of a given width by padding it with spaces on the left. There are similar methods and . These methods do not write anything, they just return a new string. If the input string is too long, they don’t truncate it, but return it unchanged; this will mess up your column lay-out but that’s usually better than the alternative, which would be lying about a value. (If you really want truncation you can always add a slice operation, as in .) There is another method, , which pads a numeric string on the left with zeros. It understands about plus and minus signs: The % operator (modulo) can also be used for string formatting. Given (where format is a string), conversion specifications in format are replaced with zero or more elements of values. This operation is commonly known as string interpolation. For example: 'The value of pi is approximately The value of pi is approximately 3.142. More information can be found in the printf-style String Formatting section.\n\nreturns a file object, and is most commonly used with two positional arguments and one keyword argument: The first argument is a string containing the filename. The second argument is another string containing a few characters describing the way in which the file will be used. mode can be when the file will only be read, for only writing (an existing file with the same name will be erased), and opens the file for appending; any data written to the file is automatically added to the end. opens the file for both reading and writing. The mode argument is optional; will be assumed if it’s omitted. Normally, files are opened in text mode, that means, you read and write strings from and to the file, which are encoded in a specific encoding. If encoding is not specified, the default is platform dependent (see ). Because UTF-8 is the modern de-facto standard, is recommended unless you know that you need to use a different encoding. Appending a to the mode opens the file in binary mode. Binary mode data is read and written as objects. You can not specify encoding when opening file in binary mode. In text mode, the default when reading is to convert platform-specific line endings ( on Unix, on Windows) to just . When writing in text mode, the default is to convert occurrences of back to platform-specific line endings. This behind-the-scenes modification to file data is fine for text files, but will corrupt binary data like that in or files. Be very careful to use binary mode when reading and writing such files. It is good practice to use the keyword when dealing with file objects. The advantage is that the file is properly closed after its suite finishes, even if an exception is raised at some point. Using is also much shorter than writing equivalent - blocks: # We can check that the file has been automatically closed. If you’re not using the keyword, then you should call to close the file and immediately free up any system resources used by it. Calling without using the keyword or calling might result in the arguments of not being completely written to the disk, even if the program exits successfully. After a file object is closed, either by a statement or by calling , attempts to use the file object will automatically fail. The rest of the examples in this section will assume that a file object called has already been created. To read a file’s contents, call , which reads some quantity of data and returns it as a string (in text mode) or bytes object (in binary mode). size is an optional numeric argument. When size is omitted or negative, the entire contents of the file will be read and returned; it’s your problem if the file is twice as large as your machine’s memory. Otherwise, at most size characters (in text mode) or size bytes (in binary mode) are read and returned. If the end of the file has been reached, will return an empty string ( ). 'This is the entire file.\n\n' reads a single line from the file; a newline character ( ) is left at the end of the string, and is only omitted on the last line of the file if the file doesn’t end in a newline. This makes the return value unambiguous; if returns an empty string, the end of the file has been reached, while a blank line is represented by , a string containing only a single newline. 'This is the first line of the file.\n\n' 'Second line of the file\n\n' For reading lines from a file, you can loop over the file object. This is memory efficient, fast, and leads to simple code: This is the first line of the file. If you want to read all the lines of a file in a list you can also use or . writes the contents of string to the file, returning the number of characters written. Other types of objects need to be converted – either to a string (in text mode) or a bytes object (in binary mode) – before writing them: returns an integer giving the file object’s current position in the file represented as number of bytes from the beginning of the file when in binary mode and an opaque number when in text mode. To change the file object’s position, use . The position is computed from adding offset to a reference point; the reference point is selected by the whence argument. A whence value of 0 measures from the beginning of the file, 1 uses the current file position, and 2 uses the end of the file as the reference point. whence can be omitted and defaults to 0, using the beginning of the file as the reference point. # Go to the 6th byte in the file # Go to the 3rd byte before the end In text files (those opened without a in the mode string), only seeks relative to the beginning of the file are allowed (the exception being seeking to the very file end with ) and the only valid offset values are those returned from the , or zero. Any other offset value produces undefined behaviour. File objects have some additional methods, such as and which are less frequently used; consult the Library Reference for a complete guide to file objects. Strings can easily be written to and read from a file. Numbers take a bit more effort, since the method only returns strings, which will have to be passed to a function like , which takes a string like and returns its numeric value 123. When you want to save more complex data types like nested lists and dictionaries, parsing and serializing by hand becomes complicated. Rather than having users constantly writing and debugging code to save complicated data types to files, Python allows you to use the popular data interchange format called JSON (JavaScript Object Notation). The standard module called can take Python data hierarchies, and convert them to string representations; this process is called serializing. Reconstructing the data from the string representation is called deserializing. Between serializing and deserializing, the string representing the object may have been stored in a file or data, or sent over a network connection to some distant machine. The JSON format is commonly used by modern applications to allow for data exchange. Many programmers are already familiar with it, which makes it a good choice for interoperability. If you have an object , you can view its JSON string representation with a simple line of code: Another variant of the function, called , simply serializes the object to a text file. So if is a text file object opened for writing, we can do this: To decode the object again, if is a binary file or text file object which has been opened for reading: JSON files must be encoded in UTF-8. Use when opening JSON file as a text file for both of reading and writing. This simple serialization technique can handle lists and dictionaries, but serializing arbitrary class instances in JSON requires a bit of extra effort. The reference for the module contains an explanation of this. Contrary to JSON, pickle is a protocol which allows the serialization of arbitrarily complex Python objects. As such, it is specific to Python and cannot be used to communicate with applications written in other languages. It is also insecure by default: deserializing pickle data coming from an untrusted source can execute arbitrary code, if the data was crafted by a skilled attacker."
    },
    {
        "link": "https://geeksforgeeks.org/python-output-using-print-function",
        "document": "Python print() function prints the message to the screen or any other standard output device. In this article, we will cover about print() function in Python as well as it’s various operations.\n\nThough it is not necessary to pass arguments in print() function, it requires an empty parenthesis at the end that tells Python to execute the function rather than calling it by name. Now, let’s explore the optional arguments that can be used with the print() function.\n\nIn this example, we have 2 variables integer and string. We are printing all variables with print() function.\n\nYou can pass variables, strings, numbers, or other data types as one or more parameters when using the print() function. Then, these parameters are represented as strings by their respective str() functions. To create a single output string, the transformed strings are concatenated with spaces between them.\n\nIn this code, we are passing two parameters name and age to the print function.\n\nString literals in Python’s print statement are primarily used to format or design how a specific string appears when printed using the print() function.\n• : This string literal is used to add a new blank line while printing a statement.\n• “”: An empty quote (“”) is used to print an empty line.\n\nThis code uses \n\n to print the data to the new line.\n\nIn this example, we are concatenating strings inside print() function.\n\nThe end keyword is used to specify the content that is to be printed at the end of the execution of the print() function. By default, it is set to “\n\n”, which leads to the change of line after the execution of print() statement.\n\nThe print() function can accept any number of positional arguments. To separate these positional arguments, the keyword argument “sep” is used.\n\nThis code is showing that how can we use sep argument for multiple variables.\n\nNote: As sep, end, flush, and file are keyword arguments their position does not change the result of the code. \n\n\n\nThis code is writing the data in the print() function to the text file.\n\nHow to Format Output with\n\nHow to Print Without a Newline in Python?"
    },
    {
        "link": "https://stackoverflow.com/questions/34277363/how-to-print-your-functions-documentation-python",
        "document": "You can either use or print the . prints a more verbose description of an object while holds only the documentation string you have defined with triple quotes in the beginning of your function.\n\nFor example, using explicitly on the built-in function:\n\nAdditionally, since Python first compiles an object and during execution evaluates it you can call within the function with no problems:\n\nand remember, besides functions, modules and classes have a attribute holding their documentation.\n\ngives a bit more information, including the docstring."
    },
    {
        "link": "https://w3schools.com/python/ref_func_print.asp",
        "document": "The function prints the specified message to the screen, or other standard output device.\n\nThe message can be a string, or any other object, the object will be converted into a string before written to the screen.\n\nPrint more than one object: print(\"Hello\", \"how are you?\") Try it Yourself »"
    },
    {
        "link": "https://realpython.com/python-print",
        "document": "If you’re like most Python users, including me, then you probably started your Python journey by learning about . It helped you write your very own one-liner. You can use it to display formatted messages onto the screen and perhaps find some bugs. But if you think that’s all there is to know about Python’s function, then you’re missing out on a lot!\n\nKeep reading to take full advantage of this seemingly boring and unappreciated little function. This tutorial will get you up to speed with using Python effectively. However, prepare for a deep dive as you go through the sections. You may be surprised how much has to offer!\n\nBy the end of this tutorial, you’ll know how to:\n\nIf you’re a complete beginner, then you’ll benefit most from reading the first part of this tutorial, which illustrates the essentials of printing in Python. Otherwise, feel free to skip that part and jump around as you see fit.\n\nLet’s jump in by looking at a few real-life examples of printing in Python. By the end of this section, you’ll know every possible way of calling . Or, in programmer lingo, you’d say you’ll be familiar with the function signature. The simplest example of using Python requires just a few keystrokes: You don’t pass any arguments, but you still need to put empty parentheses at the end, which tell Python to actually execute the function rather than just refer to it by name. This will produce an invisible newline character, which in turn will cause a blank line to appear on your screen. You can call multiple times like this to add vertical space. It’s just as if you were hitting on your keyboard in a word processor. A newline character is a special control character used to indicate the end of a line (EOL). It usually doesn’t have a visible representation on the screen, but some text editors can display such non-printable characters with little graphics. The word “character” is somewhat of a misnomer in this case, because a newline is often more than one character long. For example, the Windows operating system, as well as the HTTP protocol, represent newlines with a pair of characters. Sometimes you need to take those differences into account to design truly portable programs. To find out what constitutes a newline in your operating system, use Python’s built-in module. This will immediately tell you that Windows and DOS represent the newline as a sequence of followed by : On Unix, Linux, and recent versions of macOS, it’s a single character: The classic Mac OS X, however, sticks to its own “think different” philosophy by choosing yet another representation: Notice how these characters appear in string literals. They use special syntax with a preceding backslash ( ) to denote the start of an escape character sequence. Such sequences allow for representing control characters, which would be otherwise invisible on screen. Most programming languages come with a predefined set of escape sequences for special characters such as these:\n• : newline, also known as line feed (LF) The last two are reminiscent of mechanical typewriters, which required two separate commands to insert a newline. The first command would move the carriage back to the beginning of the current line, while the second one would advance the roll to the next line. By comparing the corresponding ASCII character codes, you’ll see that putting a backslash in front of a character changes its meaning completely. However, not all characters allow for this–only the special ones. To compare ASCII character codes, you may want to use the built-in function: Keep in mind that, in order to form a correct escape sequence, there must be no space between the backslash character and a letter! As you just saw, calling without arguments results in a blank line, which is a line comprised solely of the newline character. Don’t confuse this with an empty line, which doesn’t contain any characters at all, not even the newline! You can use Python’s string literals to visualize these two: The first one is one character long, whereas the second one has no content. Note: To remove the newline character from a string in Python, use its method, like this: This strips any trailing whitespace from the right edge of the string of characters. In a more common scenario, you’d want to communicate some message to the end user. There are a few ways to achieve this. First, you may pass a string literal directly to : 'Please wait while the program is loading...' This will print the message verbatim onto the screen. String literals in Python can be enclosed either in single quotes ( ) or double quotes ( ). According to the official PEP 8 style guide, you should just pick one and keep using it consistently. There’s no difference, unless you need to nest one in another. For example, you can’t use double quotes for the literal and also include double quotes inside of it, because that’s ambiguous for the Python interpreter: What you want to do is enclose the text, which contains double quotes, within single quotes: The same trick would work the other way around: Alternatively, you could use escape character sequences mentioned earlier, to make Python treat those internal double quotes literally as part of the string literal: Escaping is fine and dandy, but it can sometimes get in the way. Specifically, when you need your string to contain relatively many backslash characters in literal form. One classic example is a file path on Windows: Notice how each backslash character needs to be escaped with yet another backslash. This is even more prominent with regular expressions, which quickly get convoluted due to the heavy use of special characters: Fortunately, you can turn off character escaping entirely with the help of raw-string literals. Simply prepend an or before the opening quote, and now you end up with this: That’s much better, isn’t it? There are a few more prefixes that give special meaning to string literals in Python, but you won’t get into them here. Lastly, you can define multi-line string literals by enclosing them between or , which are often used as docstrings. To prevent an initial newline, simply put the text right after the opening : You can also use a backslash to get rid of the newline: To remove indentation from a multi-line string, you might take advantage of the built-in module: This will take care of unindenting paragraphs for you. There are also a few other useful functions in for text alignment you’d find in a word processor. Secondly, you could extract that message into its own variable with a meaningful name to enhance readability and promote code reuse: 'Please wait while the program is loading...' Lastly, you could pass an expression, like string concatenation, to be evaluated before printing the result: Hello, jdoe! How are you? In fact, there are a dozen ways to format messages in Python. I highly encourage you to take a look at f-strings, introduced in Python 3.6, because they offer the most concise syntax of them all: Moreover, f-strings will prevent you from making a common mistake, which is forgetting to type cast concatenated operands. Python is a strongly typed language, which means it won’t allow you to do this: File , line , in : can only concatenate str (not \"int\") to str That’s wrong because adding numbers to strings doesn’t make sense. You need to explicitly convert the number to string first, in order to join them together: Unless you handle such errors yourself, the Python interpreter will let you know about a problem by showing a traceback. Note: is a global built-in function that converts an object into its string representation. You can call it directly on any object, for example, a number: Built-in data types have a predefined string representation out of the box, but later in this article, you’ll find out how to provide one for your custom classes. As with any function, it doesn’t matter whether you pass a literal, a variable, or an expression. Unlike many other functions, however, will accept anything regardless of its type. So far, you only looked at the string, but how about other data types? Let’s try literals of different built-in types and see what comes out: Watch out for the constant, though. Despite being used to indicate an absence of a value, it will show up as rather than an empty string: How does know how to work with all these different types? Well, the short answer is that it doesn’t. It implicitly calls behind the scenes to type cast any object into a string. Afterward, it treats strings in a uniform way. Later in this tutorial, you’ll learn how to use this mechanism for printing custom data types such as your classes. Okay, you’re now able to call with a single argument or without any arguments. You know how to print fixed or formatted messages onto the screen. The next subsection will expand on message formatting a little bit. To achieve the same result in the previous language generation, you’d normally want to drop the parentheses enclosing the text: That’s because wasn’t a function back then, as you’ll see in the next section. Note, however, that in some cases parentheses in Python are redundant. It wouldn’t harm to include them as they’d just get ignored. Does that mean you should be using the statement as if it were a function? Absolutely not! For example, parentheses enclosing a single expression or a literal are optional. Both instructions produce the same result in Python 2: Round brackets are actually part of the expression rather than the statement. If your expression happens to contain only one item, then it’s as if you didn’t include the brackets at all. On the other hand, putting parentheses around multiple items forms a tuple: This is a known source of confusion. In fact, you’d also get a tuple by appending a trailing comma to the only item surrounded by parentheses: The bottom line is that you shouldn’t call with brackets in Python 2. Although, to be completely accurate, you can work around this with the help of a import, which you’ll read more about in the relevant section. You saw called without any arguments to produce a blank line and then called with a single argument to display either a fixed or a formatted message. However, it turns out that this function can accept any number of positional arguments, including zero, one, or more arguments. That’s very handy in a common case of message formatting, where you’d want to join a few elements together. Arguments can be passed to a function in one of several ways. One way is by explicitly naming the arguments when you’re calling the function, like this: Since arguments can be uniquely identified by name, their order doesn’t matter. Swapping them out will still give the same result: Conversely, arguments passed without names are identified by their position. That’s why positional arguments need to follow strictly the order imposed by the function signature: allows an arbitrary number of positional arguments thanks to the parameter. Let’s have a look at this example: My name is jdoe and I am 42 concatenated all four arguments passed to it, and it inserted a single space between them so that you didn’t end up with a squashed message like . Notice that it also took care of proper type casting by implicitly calling on each argument before joining them together. If you recall from the previous subsection, a naïve concatenation may easily result in an error due to incompatible types: File , line , in : can only concatenate str (not \"int\") to str Apart from accepting a variable number of positional arguments, defines four named or keyword arguments, which are optional since they all have default values. You can view their brief documentation by calling from the interactive interpreter. Let’s focus on just for now. It stands for separator and is assigned a single space ( ) by default. It determines the value to join elements with. It has to be either a string or , but the latter has the same effect as the default space: If you wanted to suppress the separator completely, you’d have to pass an empty string ( ) instead: You may want to join its arguments as separate lines. In that case, simply pass the escaped newline character described earlier: A more useful example of the parameter would be printing something like file paths: Remember that the separator comes between the elements, not around them, so you need to account for that in one way or another: Specifically, you can insert a slash character ( ) into the first positional argument, or use an empty string as the first argument to enforce the leading slash. Note: Be careful about joining elements of a list or tuple. Doing it manually will result in a well-known if at least one of the elements isn’t a string: It’s safer to just unpack the sequence with the star operator ( ) and let handle type casting: Unpacking is effectively the same as calling with individual elements of the list. One more interesting example could be exporting data to a comma-separated values (CSV) format: This wouldn’t handle edge cases such as escaping commas correctly, but for simple use cases, it should do. The line above would show up in your terminal window. In order to save it to a file, you’d have to redirect the output. Later in this section, you’ll see how to use to write text to files straight from Python. Finally, the parameter isn’t constrained to a single character only. You can join elements with strings of any length: In the upcoming subsections, you’ll explore the remaining keyword arguments of the function. To print multiple elements in Python 2, you must drop the parentheses around them, just like before: My name is jdoe and I am 42 If you kept them, on the other hand, you’d be passing a single tuple element to the statement: Moreover, there’s no way of altering the default separator of joined elements in Python 2, so one workaround is to use string interpolation like so: My name is jdoe and I am 42 That was the default way of formatting strings until the method got backported from Python 3. Sometimes you don’t want to end your message with a trailing newline so that subsequent calls to will continue on the same line. Classic examples include updating the progress of a long-running operation or prompting the user for input. In the latter case, you want the user to type in the answer on the same line: Are you sure you want to do this? [y/n] y Many programming languages expose functions similar to through their standard libraries, but they let you decide whether to add a newline or not. For example, in Java and C#, you have two distinct functions, while other languages require you to explicitly append at the end of a string literal. Here are a few examples of syntax in such languages: In contrast, Python’s function always adds without asking, because that’s what you want in most cases. To disable it, you can take advantage of yet another keyword argument, , which dictates what to end the line with. In terms of semantics, the parameter is almost identical to the one that you saw earlier:\n• It must be a string or .\n• It can be arbitrarily long.\n• It has a default value of .\n• If equal to , it’ll have the same effect as the default value.\n• If equal to an empty string ( ), it’ll suppress the newline. Now you understand what’s happening under the hood when you’re calling without arguments. Since you don’t provide any positional arguments to the function, there’s nothing to be joined, and so the default separator isn’t used at all. However, the default value of still applies, and a blank line shows up. Note: You may be wondering why the parameter has a fixed default value rather than whatever makes sense on your operating system. Well, you don’t have to worry about newline representation across different operating systems when printing, because will handle the conversion automatically. Just remember to always use the escape sequence in string literals. This is currently the most portable way of printing a newline character in Python: If you were to try to forcefully print a Windows-specific newline character on a Linux machine, for example, you’d end up with broken output: On the flip side, when you open a file for reading with , you don’t need to care about newline representation either. The function will translate any system-specific newline it encounters into a universal . At the same time, you have control over how the newlines should be treated both on input and output if you really need that. To disable the newline, you must specify an empty string through the keyword argument: Even though these are two separate calls, which can execute a long time apart, you’ll eventually see only one line. First, it’ll look like this: However, after the second call to , the same line will appear on the screen as: As with , you can use to join individual pieces into a big blob of text with a custom separator. Instead of joining multiple arguments, however, it’ll append text from each function call to the same line: These three instructions will output a single line of text: The first sentence. The second sentence. The last sentence. You can mix the two keyword arguments: Not only do you get a single line of text, but all items are separated with a comma: There’s nothing to stop you from using the newline character with some extra padding around it: It would print out the following piece of text: As you can see, the keyword argument will accept arbitrary strings. Note: Looping over lines in a text file preserves their own newline characters, which combined with the function’s default behavior will result in a redundant newline character: There are two newlines after each line of text. You want to strip one of the them, as shown earlier in this article, before printing the line: Alternatively, you can keep the newline in the content but suppress the one appended by automatically. You’d use the keyword argument to do that: By ending a line with an empty string, you effectively disable one of the newlines. You’re getting more acquainted with printing in Python, but there’s still a lot of useful information ahead. In the upcoming subsection, you’ll learn how to intercept and redirect the function’s output. Preventing a line break in Python 2 requires that you append a trailing comma to the expression: However, that’s not ideal because it also adds an unwanted space, which would translate to instead of in Python 3. You can test this with the following code snippet: Notice there’s a space between the words and : BEFORE hello AFTER In order to get the expected result, you’d need to use one of the tricks explained later, which is either importing the function from or falling back to the module: This will print the correct output without extra space: While using the module gives you control over what gets printed to the standard output, the code becomes a little bit more cluttered. Believe it or not, doesn’t know how to turn messages into text on your screen, and frankly it doesn’t need to. That’s a job for lower-level layers of code, which understand bytes and know how to push them around. is an abstraction over these layers, providing a convenient interface that merely delegates the actual printing to a stream or file-like object. A stream can be any file on your disk, a network socket, or perhaps an in-memory buffer. In addition to this, there are three standard streams provided by the operating system: Standard output is what you see in the terminal when you run various command-line programs including your own Python scripts: cat hello.py print('This will appear on stdout') python hello.py This will appear on stdout Unless otherwise instructed, will default to writing to standard output. However, you can tell your operating system to temporarily swap out for a file stream, so that any output ends up in that file rather than the screen: python hello.py > file.txt cat file.txt This will appear on stdout The standard error is similar to in that it also shows up on the screen. Nonetheless, it’s a separate stream, whose purpose is to log error messages for diagnostics. By redirecting one or both of them, you can keep things clean. Note: To redirect , you need to know about file descriptors, also known as file handles. They’re arbitrary, albeit constant, numbers associated with standard streams. Below, you’ll find a summary of the file descriptors for a family of POSIX-compliant operating systems: Knowing those descriptors allows you to redirect one or more streams at a time: Redirect and to the same file Note that is the same as . Some programs use different coloring to distinguish between messages printed to and : While both and are write-only, is read-only. You can think of standard input as your keyboard, but just like with the other two, you can swap out for a file to read data from. In Python, you can access all standard streams through the built-in module: As you can see, these predefined values resemble file-like objects with and attributes as well as and methods among many others. By default, is bound to through its argument, but you can change that. Use that keyword argument to indicate a file that was open in write or append mode, so that messages go straight to it: This will make your code immune to stream redirection at the operating system level, which might or might not be desired. For more information on working with files in Python, you can check out Reading and Writing Files in Python (Guide). Note: Don’t try using for writing binary data as it’s only well suited for text. If you wanted to write raw bytes on the standard output, then this will fail too because is a character stream: File , line , in : write() argument must be str, not bytes You must dig deeper to get a handle of the underlying byte stream instead: This prints an uppercase letter and a newline character, which correspond to decimal values of 65 and 10 in ASCII. However, they’re encoded using hexadecimal notation in the bytes literal. Note that has no control over character encoding. It’s the stream’s responsibility to encode received Unicode strings into bytes correctly. In most cases, you won’t set the encoding yourself, because the default UTF-8 is what you want. If you really need to, perhaps for legacy systems, you can use the argument of : Instead of a real file existing somewhere in your file system, you can provide a fake one, which would reside in your computer’s memory. You’ll use this technique later for mocking in unit tests: If you got to this point, then you’re left with only one keyword argument in , which you’ll see in the next subsection. It’s probably the least used of them all. Nevertheless, there are times when it’s absolutely necessary. There’s a special syntax in Python 2 for replacing the default with a custom file in the statement: Because strings and bytes are represented with the same type in Python 2, the statement can handle binary data just fine: Although, there’s a problem with character encoding. The function in Python 2 lacks the parameter, which would often result in the dreadful : Notice how non-Latin characters must be escaped in both Unicode and string literals to avoid a syntax error. Take a look at this example: Alternatively, you could specify source code encoding according to PEP 263 at the top of the file, but that wasn’t the best practice due to portability issues: Your best bet is to encode the Unicode string just before printing it. You can do this manually: However, a more convenient option is to use the built-in module: It’ll take care of making appropriate conversions when you need to read or write files. In the previous subsection, you learned that delegates printing to a file-like object such as . Some streams, however, buffer certain I/O operations to enhance performance, which can get in the way. Let’s take a look at an example. Imagine you were writing a countdown timer, which should append the remaining time to the same line every second: Your first attempt may look something like this: As long as the variable is greater than zero, the code keeps appending text without a trailing newline and then goes to sleep for one second. Finally, when the countdown is finished, it prints and terminates the line. Unexpectedly, instead of counting down every second, the program idles wastefully for three seconds, and then suddenly prints the entire line at once: That’s because the operating system buffers subsequent writes to the standard output in this case. You need to know that there are three kinds of streams with respect to buffering: Unbuffered is self-explanatory, that is, no buffering is taking place, and all writes have immediate effect. A line-buffered stream waits before firing any I/O calls until a line break appears somewhere in the buffer, whereas a block-buffered one simply allows the buffer to fill up to a certain size regardless of its content. Standard output is both line-buffered and block-buffered, depending on which event comes first. Buffering helps to reduce the number of expensive I/O calls. Think about sending messages over a high-latency network, for example. When you connect to a remote server to execute commands over the SSH protocol, each of your keystrokes may actually produce an individual data packet, which is orders of magnitude bigger than its payload. What an overhead! It would make sense to wait until at least a few characters are typed and then send them together. That’s where buffering steps in. On the other hand, buffering can sometimes have undesired effects as you just saw with the countdown example. To fix it, you can simply tell to forcefully flush the stream without waiting for a newline character in the buffer using its flag: That’s all. Your countdown should work as expected now, but don’t take my word for it. Go ahead and test it to see the difference. Congratulations! At this point, you’ve seen examples of calling that cover all of its parameters. You know their purpose and when to use them. Understanding the signature is only the beginning, however. In the upcoming sections, you’ll see why. There isn’t an easy way to flush the stream in Python 2, because the statement doesn’t allow for it by itself. You need to get a handle of its lower-level layer, which is the standard output, and call it directly: Alternatively, you could disable buffering of the standard streams either by providing the flag to the Python interpreter or by setting up the environment variable: Note that was backported to Python 2 and made available through the module. Unfortunately, it doesn’t come with the parameter: Help on built-in function print in module __builtin__: What you’re seeing here is a docstring of the function. You can display docstrings of various objects in Python using the built-in function. Up until now, you only dealt with built-in data types such as strings and numbers, but you’ll often want to print your own abstract data types. Let’s have a look at different ways of defining them. For simple objects without any logic, whose purpose is to carry data, you’ll typically take advantage of , which is available in the standard library. Named tuples have a neat textual representation out of the box: That’s great as long as holding data is enough, but in order to add behaviors to the type, you’ll eventually need to define a class. Take a look at this example: If you now create an instance of the class and try to print it, you’ll get this bizarre output, which is quite different from the equivalent : It’s the default representation of objects, which comprises their address in memory, the corresponding class name and a module in which they were defined. You’ll fix that in a bit, but just for the record, as a quick workaround you could combine and a custom class through inheritance: Your class has just become a specialized kind of with two attributes, which you can customize. Note: In Python 3, the statement can be replaced with the ellipsis ( ) literal to indicate a placeholder: This prevents the interpreter from raising due to missing indented block of code. That’s better than a plain , because not only do you get printing right for free, but you can also add custom methods and properties to the class. However, it solves one problem while introducing another. Remember that tuples, including named tuples, are immutable in Python, so they can’t change their values once created. It’s true that designing immutable data types is desirable, but in many cases, you’ll want them to allow for change, so you’re back with regular classes again. Note: Following other languages and frameworks, Python 3.7 introduced data classes, which you can think of as mutable tuples. This way, you get the best of both worlds: The syntax for variable annotations, which is required to specify class fields with their corresponding types, was defined in Python 3.6. From earlier subsections, you already know that implicitly calls the built-in function to convert its positional arguments into strings. Indeed, calling manually against an instance of the regular class yields the same result as printing it: , in turn, looks for one of two magic methods within the class body, which you typically implement. If it doesn’t find one, then it falls back to the ugly default representation. Those magic methods are, in order of search: The first one is recommended to return a short, human-readable text, which includes information from the most relevant attributes. After all, you don’t want to expose sensitive data, such as user passwords, when printing objects. However, the other one should provide complete information about an object, to allow for restoring its state from a string. Ideally, it should return valid Python code, so that you can pass it directly to : Notice the use of another built-in function, , which always tries to call in an object, but falls back to the default representation if it doesn’t find that method. Note: Even though itself uses for type casting, some compound data types delegate that call to on their members. This happens to lists and tuples, for example. Consider this class with both magic methods, which return alternative string representations of the same object: If you print a single object of the class, then you won’t see the password, because will call , which eventually will invoke : However, if you put the same variable inside a list by wrapping it in square brackets, then the password will become clearly visible: That’s because sequences, such as lists and tuples, implement their method so that all of their elements are first converted with . Python gives you a lot of freedom when it comes to defining your own data types if none of the built-in ones meet your needs. Some of them, such as named tuples and data classes, offer string representations that look good without requiring any work on your part. Still, for the most flexibility, you’ll have to define a class and override its magic methods described above. The semantics of and didn’t change since Python 2, but you must remember that strings were nothing more than glorified byte arrays back then. To convert your objects into proper Unicode, which was a separate data type, you’d have to provide yet another magic method: . Here’s an example of the same class in Python 2: As you can see, this implementation delegates some work to avoid duplication by calling the built-in function on itself. Both and methods must return strings, so they encode Unicode characters into specific byte representations called character sets. UTF-8 is the most widespread and safest encoding, while is a special constant to express funky characters, such as , as escape sequences in plain ASCII, such as . The statement is looking for the magic method in the class, so the chosen charset must correspond to the one used by the terminal. For example, default encoding in DOS and Windows is CP 852 rather than UTF-8, so running this can result in a or even garbled output: However, if you ran the same code on a system with UTF-8 encoding, then you’d get the proper spelling of a popular Russian name: It’s recommended to convert strings to Unicode as early as possible, for example, when you’re reading data from a file, and use it consistently everywhere in your code. At the same time, you should encode Unicode back to the chosen character set right before presenting it to the user. It seems as if you have more control over string representation of objects in Python 2 because there’s no magic method in Python 3 anymore. You may be asking yourself if it’s possible to convert an object to its byte string representation rather than a Unicode string in Python 3. It’s possible, with a special method that does just that: Using the built-in function on an instance delegates the call to its method defined in the corresponding class.\n\nYou know how to use quite well at this point, but knowing what it is will allow you to use it even more effectively and consciously. After reading this section, you’ll understand how printing in Python has improved over the years. You’ve seen that is a function in Python 3. More specifically, it’s a built-in function, which means that you don’t need to import it from anywhere: It’s always available in the global namespace so that you can call it directly, but you can also access it through a module from the standard library: This way, you can avoid name collisions with custom functions. Let’s say you wanted to redefine so that it doesn’t append a trailing newline. At the same time, you wanted to rename the original function to something like : Now you have two separate printing functions just like in the Java programming language. You’ll define custom functions in the mocking section later as well. Also, note that you wouldn’t be able to overwrite in the first place if it wasn’t a function. On the other hand, isn’t a function in the mathematical sense, because it doesn’t return any meaningful value other than the implicit : Such functions are, in fact, procedures or subroutines that you call to achieve some kind of side-effect, which ultimately is a change of a global state. In the case of , that side-effect is showing a message on the standard output or writing to a file. Because is a function, it has a well-defined signature with known attributes. You can quickly find its documentation using the editor of your choice, without having to remember some weird syntax for performing a certain task. Besides, functions are easier to extend. Adding a new feature to a function is as easy as adding another keyword argument, whereas changing the language to support that new feature is much more cumbersome. Think of stream redirection or buffer flushing, for example. Another benefit of being a function is composability. Functions are so-called first-class objects or first-class citizens in Python, which is a fancy way of saying they’re values just like strings or numbers. This way, you can assign a function to a variable, pass it to another function, or even return one from another. isn’t different in this regard. For instance, you can take advantage of it for dependency injection: Here, the parameter lets you inject a callback function, which defaults to but can be any callable. In this example, printing is completely disabled by substituting with a dummy function that does nothing. Note: A dependency is any piece of code required by another bit of code. Dependency injection is a technique used in code design to make it more testable, reusable, and open for extension. You can achieve it by referring to dependencies indirectly through abstract interfaces and by providing them in a push rather than pull fashion. There’s a funny explanation of dependency injection circulating on the Internet: When you go and get things out of the refrigerator for yourself, you can cause problems. You might leave the door open, you might get something Mommy or Daddy doesn’t want you to have. You might even be looking for something we don’t even have or which has expired. What you should be doing is stating a need, “I need something to drink with lunch,” and then we will make sure you have something when you sit down to eat. Composition allows you to combine a few functions into a new one of the same kind. Let’s see this in action by specifying a custom function that prints to the standard error stream and prefixes all messages with a given log level: This custom function uses partial functions to achieve the desired effect. It’s an advanced concept borrowed from the functional programming paradigm, so you don’t need to go too deep into that topic for now. However, if you’re interested in this topic, I recommend taking a look at the module. Unlike statements, functions are values. That means you can mix them with expressions, in particular, lambda expressions. Instead of defining a full-blown function to replace with, you can make an anonymous lambda expression that calls it: However, because a lambda expression is defined in place, there’s no way of referring to it elsewhere in the code. Note: In Python, you can’t put statements, such as assignments, conditional statements, loops, and so on, in an anonymous lambda function. It has to be a single expression! Another kind of expression is a ternary conditional expression: Python has both conditional statements and conditional expressions. The latter is evaluated to a single value that can be assigned to a variable or passed to a function. In the example above, you’re interested in the side-effect rather than the value, which evaluates to , so you simply ignore it. As you can see, functions allow for an elegant and extensible solution, which is consistent with the rest of the language. In the next subsection, you’ll discover how not having as a function caused a lot of headaches. A statement is an instruction that may evoke a side-effect when executed but never evaluates to a value. In other words, you wouldn’t be able to print a statement or assign it to a variable like this: Here are a few more examples of statements in Python: Note: Python 3.8 brings a controversial walrus operator ( ), which is an assignment expression. With it, you can evaluate an expression and assign the result to a variable at the same time, even within another expression! Take a look at this example, which calls an expensive function once and then reuses the result for further computation: This is useful for simplifying the code without losing its efficiency. Typically, performant code tends to be more verbose: The controversy behind this new piece of syntax caused a lot of argument. An abundance of negative comments and heated debates eventually led Guido van Rossum to step down from the Benevolent Dictator For Life or BDFL position. Statements are usually comprised of reserved keywords such as , , or that have fixed meaning in the language. You can’t use them to name your variables or other symbols. That’s why redefining or mocking the statement isn’t possible in Python 2. You’re stuck with what you get. Furthermore, you can’t print from anonymous functions, because statements aren’t accepted in lambda expressions: The syntax of the statement is ambiguous. Sometimes you can add parentheses around the message, and they’re completely optional: At other times they change how the message is printed: String concatenation can raise a due to incompatible types, which you have to handle manually, for example: Compare this with similar code in Python 3, which leverages sequence unpacking: There aren’t any keyword arguments for common tasks such as flushing the buffer or stream redirection. You need to remember the quirky syntax instead. Even the built-in function isn’t that helpful with regards to the statement: Trailing newline removal doesn’t work quite right, because it adds an unwanted space. You can’t compose multiple statements together, and, on top of that, you have to be extra diligent about character encoding. The list of problems goes on and on. If you’re curious, you can jump back to the previous section and look for more detailed explanations of the syntax in Python 2. However, you can mitigate some of those problems with a much simpler approach. It turns out the function was backported to ease the migration to Python 3. You can import it from a special module, which exposes a selection of language features released in later Python versions. Note: You may import future functions as well as baked-in language constructs such as the statement. To find out exactly what features are available to you, inspect the module: You could also call , but that would show a lot of uninteresting internal details of the module. To enable the function in Python 2, you need to add this import statement at the beginning of your source code: From now on the statement is no longer available, but you have the function at your disposal. Note that it isn’t the same function like the one in Python 3, because it’s missing the keyword argument, but the rest of the arguments are the same. Other than that, it doesn’t spare you from managing character encodings properly. Here’s an example of calling the function in Python 2: You now have an idea of how printing in Python evolved and, most importantly, understand why these backward-incompatible changes were necessary. Knowing this will surely help you become a better Python programmer.\n\nIf you thought that printing was only about lighting pixels up on the screen, then technically you’d be right. However, there are ways to make it look cool. In this section, you’ll find out how to format complex data structures, add colors and other decorations, build interfaces, use animation, and even play sounds with text! Computer languages allow you to represent data as well as executable code in a structured way. Unlike Python, however, most languages give you a lot of freedom in using whitespace and formatting. This can be useful, for example in compression, but it sometimes leads to less readable code. Pretty-printing is about making a piece of data or code look more appealing to the human eye so that it can be understood more easily. This is done by indenting certain lines, inserting newlines, reordering elements, and so forth. Python comes with the module in its standard library, which will help you in pretty-printing large data structures that don’t fit on a single line. Because it prints in a more human-friendly way, many popular REPL tools, including JupyterLab and IPython, use it by default in place of the regular function. Note: To toggle pretty printing in IPython, issue the following command: Pretty printing has been turned OFF Pretty printing has been turned ON This is an example of Magic in IPython. There are a lot of built-in commands that start with a percent sign ( ), but you can find more on PyPI, or even create your own. If you don’t care about not having access to the original function, then you can replace it with in your code using import renaming: Personally, I like to have both functions at my fingertips, so I’d rather use something like as a short alias: At first glance, there’s hardly any difference between the two functions, and in some cases there’s virtually none: 'hello' # Did you spot the difference? That’s because calls instead of the usual for type casting, so that you may evaluate its output as Python code if you want to. The differences become apparent as you start feeding it more complex data structures: The function applies reasonable formatting to improve readability, but you can customize it even further with a couple of parameters. For example, you may limit a deeply nested hierarchy by showing an ellipsis below a given level: The ordinary also uses ellipses but for displaying recursive data structures, which form a cycle, to avoid stack overflow error: However, is more explicit about it by including the unique identity of a self-referencing object: The last element in the list is the same object as the entire list. Note: Recursive or very large data sets can be dealt with using the module as well: This module supports most of the built-in types and is used by the Python debugger. automatically sorts dictionary keys for you before printing, which allows for consistent comparison. When you’re comparing strings, you often don’t care about a particular order of serialized attributes. Anyways, it’s always best to compare actual dictionaries before serialization. Dictionaries often represent JSON data, which is widely used on the Internet. To correctly serialize a dictionary into a valid JSON-formatted string, you can take advantage of the module. It too has pretty-printing capabilities: Notice, however, that you need to handle printing yourself, because it’s not something you’d typically want to do. Similarly, the module has an additional function that returns a string, in case you had to do something other than printing it. Surprisingly, the signature of is nothing like the function’s one. You can’t even pass more than one positional argument, which shows how much it focuses on printing data structures. As personal computers got more sophisticated, they had better graphics and could display more colors. However, different vendors had their own idea about the API design for controlling it. That changed a few decades ago when people at the American National Standards Institute decided to unify it by defining ANSI escape codes. Most of today’s terminal emulators support this standard to some degree. Until recently, the Windows operating system was a notable exception. Therefore, if you want the best portability, use the library in Python. It translates ANSI codes to their appropriate counterparts in Windows while keeping them intact in other operating systems. To check if your terminal understands a subset of the ANSI escape sequences, for example, related to colors, you can try using the following command: My default terminal on Linux says it can display 256 distinct colors, while xterm gives me only 8. The command would return a negative number if colors were unsupported. ANSI escape sequences are like a markup language for the terminal. In HTML you work with tags, such as or , to change how elements look in the document. These tags are mixed with your content, but they’re not visible themselves. Similarly, escape codes won’t show up in the terminal as long as it recognizes them. Otherwise, they’ll appear in the literal form as if you were viewing the source of a website. As its name implies, a sequence must begin with the non-printable character, whose ASCII value is 27, sometimes denoted as in hexadecimal or in octal. You may use Python number literals to quickly verify it’s indeed the same number: Additionally, you can obtain it with the escape sequence in the shell: The most common ANSI escape sequences take the following form: one or more numbers separated with The numeric code can be one or more numbers separated with a semicolon, while the character code is just one letter. Their specific meaning is defined by the ANSI standard. For example, to reset all formatting, you would type one of the following commands, which use the code zero and the letter : At the other end of the spectrum, you have compound code values. To set foreground and background with RGB channels, given that your terminal supports 24-bit depth, you could provide multiple numbers: It’s not just text color that you can set with the ANSI escape codes. You can, for example, clear and scroll the terminal window, change its background, move the cursor around, make the text blink or decorate it with an underline. In Python, you’d probably write a helper function to allow for wrapping arbitrary codes into a sequence: This would make the word appear in red, bold, and underlined font: However, there are higher-level abstractions over ANSI escape codes, such as the mentioned library, as well as tools for building user interfaces in the console. While playing with ANSI escape codes is undeniably a ton of fun, in the real world you’d rather have more abstract building blocks to put together a user interface. There are a few libraries that provide such a high level of control over the terminal, but seems to be the most popular choice. Note: To use the library in Windows, you need to install a third-party package: That’s because isn’t available in the standard library of the Python distribution for Windows. Primarily, it allows you to think in terms of independent graphical widgets instead of a blob of text. Besides, you get a lot of freedom in expressing your inner artist, because it’s really like painting a blank canvas. The library hides the complexities of having to deal with different terminals. Other than that, it has great support for keyboard events, which might be useful for writing video games. First, you need to import the module. Since it modifies the state of a running terminal, it’s important to handle errors and gracefully restore the previous state. You can do this manually, but the library comes with a convenient wrapper for your main function: Note, the function must accept a reference to the screen object, also known as , that you’ll use later for additional setup. If you run this program now, you won’t see any effects, because it terminates immediately. However, you can add a small delay to have a sneak peek: This time the screen went completely blank for a second, but the cursor was still blinking. To hide it, just call one of the configuration functions defined in the module: Let’s define the snake as a list of points in screen coordinates: The head of the snake is always the first element in the list, whereas the tail is the last one. The initial shape of the snake is horizontal, starting from the top-left corner of the screen and facing to the right. While its y-coordinate stays at zero, its x-coordinate decreases from head to tail. To draw the snake, you’ll start with the head and then follow with the remaining segments. Each segment carries coordinates, so you can unpack them: Again, if you run this code now, it won’t display anything, because you must explicitly refresh the screen afterward: You want to move the snake in one of four directions, which can be defined as vectors. Eventually, the direction will change in response to an arrow keystroke, so you may hook it up to the library’s key codes: How does a snake move? It turns out that only its head really moves to a new location, while all other segments shift towards it. In each step, almost all segments remain the same, except for the head and the tail. Assuming the snake isn’t growing, you can remove the tail and insert a new head at the beginning of the list: To get the new coordinates of the head, you need to add the direction vector to it. However, adding tuples in Python results in a bigger tuple instead of the algebraic sum of the corresponding vector components. One way to fix this is by using the built-in , , and functions. The direction will change on a keystroke, so you need to call to obtain the pressed key code. However, if the pressed key doesn’t correspond to the arrow keys defined earlier as dictionary keys, the direction won’t change: By default, however, is a blocking call that would prevent the snake from moving unless there was a keystroke. Therefore, you need to make the call non-blocking by adding yet another configuration: You’re almost done, but there’s just one last thing left. If you now loop this code, the snake will appear to be growing instead of moving. That’s because you have to erase the screen explicitly before each iteration. Finally, this is all you need to play the snake game in Python: This is merely scratching the surface of the possibilities that the module opens up. You may use it for game development like this or more business-oriented applications. Living It Up With Cool Animations Not only can animations make the user interface more appealing to the eye, but they also improve the overall user experience. When you provide early feedback to the user, for example, they’ll know if your program’s still working or if it’s time to kill it. To animate text in the terminal, you have to be able to freely move the cursor around. You can do this with one of the tools mentioned previously, that is ANSI escape codes or the library. However, I’d like to show you an even simpler way. If the animation can be constrained to a single line of text, then you might be interested in two special escape character sequences: The first one moves the cursor to the beginning of the line, whereas the second one moves it only one character to the left. They both work in a non-destructive way without overwriting text that’s already been written. Let’s take a look at a few examples. You’ll often want to display some kind of a spinning wheel to indicate a work in progress without knowing exactly how much time’s left to finish: Many command line tools use this trick while downloading data over the network. You can make a really simple stop motion animation from a sequence of characters that will cycle in a round-robin fashion: The loop gets the next character to print, then moves the cursor to the beginning of the line, and overwrites whatever there was before without adding a newline. You don’t want extra space between positional arguments, so separator argument must be blank. Also, notice the use of Python’s raw strings due to backslash characters present in the literal. When you know the remaining time or task completion percentage, then you’re able to show an animated progress bar: First, you need to calculate how many hashtags to display and how many blank spaces to insert. Next, you erase the line and build the bar from scratch: As before, each request for update repaints the entire line. Note: There’s a feature-rich library, along with a few other similar tools, that can show progress in a much more comprehensive way. If you’re old enough to remember computers with a PC speaker, then you must also remember their distinctive beep sound, often used to indicate hardware problems. They could barely make any more noises than that, yet video games seemed so much better with it. Today you can still take advantage of this small loudspeaker, but chances are your laptop didn’t come with one. In such a case, you can enable terminal bell emulation in your shell, so that a system warning sound is played instead. Go ahead and type this command to see if your terminal can play a sound: This would normally print text, but the flag enables the interpretation of backslash escapes. As you can see, there’s a dedicated escape sequence , which stands for “alert”, that outputs a special bell character. Some terminals make a sound whenever they see it. Similarly, you can print this character in Python. Perhaps in a loop to form some kind of melody. While it’s only a single note, you can still vary the length of pauses between consecutive instances. That seems like a perfect toy for Morse code playback! The rules are the following:\n• Letters are encoded with a sequence of dot (·) and dash (–) symbols.\n• A dot is one unit of time.\n• A dash is three units of time.\n• Individual symbols in a letter are spaced one unit of time apart.\n• Symbols of two adjacent letters are spaced three units of time apart.\n• Symbols of two adjacent words are spaced seven units of time apart. According to those rules, you could be “printing” an SOS signal indefinitely in the following way: In Python, you can implement it in merely ten lines of code: Maybe you could even take it one step further and make a command line tool for translating text into Morse code? Either way, I hope you’re having fun with this!\n\nNowadays, it’s expected that you ship code that meets high quality standards. If you aspire to become a professional, you must learn how to test your code. Software testing is especially important in dynamically typed languages, such as Python, which don’t have a compiler to warn you about obvious mistakes. Defects can make their way to the production environment and remain dormant for a long time, until that one day when a branch of code finally gets executed. Sure, you have linters, type checkers, and other tools for static code analysis to assist you. But they won’t tell you whether your program does what it’s supposed to do on the business level. So, should you be testing ? No. After all, it’s a built-in function that must have already gone through a comprehensive suite of tests. What you want to test, though, is whether your code is calling at the right time with the expected parameters. That’s known as a behavior. You can test behaviors by mocking real objects or functions. In this case, you want to mock to record and verify its invocations. Note: You might have heard the terms: dummy, fake, stub, spy, or mock used interchangeably. Some people make a distinction between them, while others don’t. Martin Fowler explains their differences in a short glossary and collectively calls them test doubles. Mocking in Python can be done twofold. First, you can take the traditional path of statically-typed languages by employing dependency injection. This may sometimes require you to change the code under test, which isn’t always possible if the code is defined in an external library: This is the same example I used in an earlier section to talk about function composition. It basically allows for substituting with a custom function of the same interface. To check if it prints the right message, you have to intercept it by injecting a mocked function: Calling this mock makes it save the last message in an attribute, which you can inspect later, for example in an statement. In a slightly alternative solution, instead of replacing the entire function with a custom wrapper, you could redirect the standard output to an in-memory file-like stream of characters: This time the function explicitly calls , but it exposes its parameter to the outside world. However, a more Pythonic way of mocking objects takes advantage of the built-in module, which uses a technique called monkey patching. This derogatory name stems from it being a “dirty hack” that you can easily shoot yourself in the foot with. It’s less elegant than dependency injection but definitely quick and convenient. Note: The module got absorbed by the standard library in Python 3, but before that, it was a third-party package. You had to install it separately: Other than that, you referred to it as , whereas in Python 3 it’s part of the unit testing module, so you must import from . What monkey patching does is alter implementation dynamically at runtime. Such a change is visible globally, so it may have unwanted consequences. In practice, however, patching only affects the code for the duration of test execution. To mock in a test case, you’ll typically use the decorator and specify a target for patching by referring to it with a fully qualified name, that is including the module name: This will automatically create the mock for you and inject it to the test function. However, you need to declare that your test function accepts a mock now. The underlying mock object has lots of useful methods and attributes for verifying behavior. Did you notice anything peculiar about that code snippet? Despite injecting a mock to the function, you’re not calling it directly, although you could. That injected mock is only used to make assertions afterward and maybe to prepare the context before running the test. In real life, mocking helps to isolate the code under test by removing dependencies such as a database connection. You rarely call mocks in a test, because that doesn’t make much sense. Rather, it’s other pieces of code that call your mock indirectly without knowing it. The code under test is a function that prints a greeting. Even though it’s a fairly simple function, you can’t test it easily because it doesn’t return a value. It has a side-effect. To eliminate that side-effect, you need to mock the dependency out. Patching lets you avoid making changes to the original function, which can remain agnostic about . It thinks it’s calling , but in reality, it’s calling a mock you’re in total control of. There are many reasons for testing software. One of them is looking for bugs. When you write tests, you often want to get rid of the function, for example, by mocking it away. Paradoxically, however, that same function can help you find bugs during a related process of debugging you’ll read about in the next section. You can’t monkey patch the statement in Python 2, nor can you inject it as a dependency. However, you have a few other options:\n• Patch the standard output defined in the module. Let’s examine them one by one. Stream redirection is almost identical to the example you saw earlier: There are only two differences. First, the syntax for stream redirection uses chevron ( ) instead of the argument. The other difference is where is defined. You can import it from a similarly named module, or for a faster implementation. Patching the standard output from the module is exactly what it sounds like, but you need to be aware of a few gotchas: First of all, remember to install the module as it wasn’t available in the standard library in Python 2. Secondly, the statement calls the underlying method on the mocked object instead of calling the object itself. That’s why you’ll run assertions against . Finally, a single statement doesn’t always correspond to a single call to . In fact, you’ll see the newline character written separately. The last option you have is importing from and patching it: Again, it’s nearly identical to Python 3, but the function is defined in the module rather than .\n\nIn this section, you’ll take a look at the available tools for debugging in Python, starting from a humble function, through the module, to a fully fledged debugger. After reading it, you’ll be able to make an educated decision about which of them is the most suitable in a given situation. Note: Debugging is the process of looking for the root causes of bugs or defects in software after they’ve been discovered, as well as taking steps to fix them. The term bug has an amusing story about the origin of its name. Also known as print debugging or caveman debugging, it’s the most basic form of debugging. While a little bit old-fashioned, it’s still powerful and has its uses. The idea is to follow the path of program execution until it stops abruptly, or gives incorrect results, to identify the exact instruction with a problem. You do that by inserting print statements with words that stand out in carefully chosen places. Take a look at this example, which manifests a rounding error: As you can see, the function doesn’t return the expected value of , but now you know it’s because the sum is a little off. Tracing the state of variables at different steps of the algorithm can give you a hint where the issue is. In this case, the problem lies in how floating point numbers are represented in computer memory. Remember that numbers are stored in binary form. Decimal value of turns out to have an infinite binary representation, which gets rounded. For more information on rounding numbers in Python, you can check out How to Round Numbers in Python. This method is simple and intuitive and will work in pretty much every programming language out there. Not to mention, it’s a great exercise in the learning process. On the other hand, once you master more advanced techniques, it’s hard to go back, because they allow you to find bugs much quicker. Tracing is a laborious manual process, which can let even more errors slip through. The build and deploy cycle takes time. Afterward, you need to remember to meticulously remove all the calls you made without accidentally touching the genuine ones. Besides, it requires you to make changes in the code, which isn’t always possible. Maybe you’re debugging an application running in a remote web server or want to diagnose a problem in a post-mortem fashion. Sometimes you simply don’t have access to the standard output. Let’s pretend for a minute that you’re running an e-commerce website. One day, an angry customer makes a phone call complaining about a failed transaction and saying he lost his money. He claims to have tried purchasing a few items, but in the end, there was some cryptic error that prevented him from finishing that order. Yet, when he checked his bank account, the money was gone. You apologize sincerely and make a refund, but also don’t want this to happen again in the future. How do you debug that? If only you had some trace of what happened, ideally in the form of a chronological list of events with their context. Whenever you find yourself doing print debugging, consider turning it into permanent log messages. This may help in situations like this, when you need to analyze a problem after it happened, in an environment that you don’t have access to. There are sophisticated tools for log aggregation and searching, but at the most basic level, you can think of logs as text files. Each line conveys detailed information about an event in your system. Usually, it won’t contain personally identifying information, though, in some cases, it may be mandated by law. As you can see, it has a structured form. Apart from a descriptive message, there are a few customizable fields, which provide the context of an event. Here, you have the exact date and time, the log level, the logger name, and the thread name. Log levels allow you to filter messages quickly to reduce noise. If you’re looking for an error, you don’t want to see all the warnings or debug messages, for example. It’s trivial to disable or enable messages at certain log levels through the configuration, without even touching the code. With logging, you can keep your debug messages separate from the standard output. All the log messages go to the standard error stream by default, which can conveniently show up in different colors. However, you can redirect log messages to separate files, even for individual modules! Quite commonly, misconfigured logging can lead to running out of space on the server’s disk. To prevent that, you may set up log rotation, which will keep the log files for a specified duration, such as one week, or once they hit a certain size. Nevertheless, it’s always a good practice to archive older logs. Some regulations enforce that customer data be kept for as long as five years! Compared to other programming languages, logging in Python is simpler, because the module is bundled with the standard library. You just import and configure it in as little as two lines of code: You can call functions defined at the module level, which are hooked to the root logger, but more the common practice is to obtain a dedicated logger for each of your source files: The advantage of using custom loggers is more fine-grain control. They’re usually named after the module they were defined in through the variable. Note: There’s a somewhat related module in Python, which can also log messages to the standard error stream. However, it has a narrower spectrum of applications, mostly in library code, whereas client applications should use the module. That said, you can make them work together by calling . One last reason to switch from the function to logging is thread safety. In the upcoming section, you’ll see that the former doesn’t play well with multiple threads of execution. The truth is that neither tracing nor logging can be considered real debugging. To do actual debugging, you need a debugger tool, which allows you to do the following: A crude debugger that runs in the terminal, unsurprisingly named for “The Python Debugger,” is distributed as part of the standard library. This makes it always available, so it may be your only choice for performing remote debugging. Perhaps that’s a good reason to get familiar with it. However, it doesn’t come with a graphical interface, so using may be a bit tricky. If you can’t edit the code, you have to run it as a module and pass your script’s location: Otherwise, you can set up a breakpoint directly in the code, which will pause the execution of your script and drop you into the debugger. The old way of doing this required two steps: This shows up an interactive prompt, which might look intimidating at first. However, you can still type native Python at this point to examine or modify the state of local variables. Apart from that, there’s really only a handful of debugger-specific commands that you want to use for stepping through the code. Note: It’s customary to put the two instructions for spinning up a debugger on a single line. This requires the use of a semicolon, which is rarely found in Python programs: While certainly not Pythonic, it stands out as a reminder to remove it after you’re done with debugging. Since Python 3.7, you can also call the built-in function, which does the same thing, but in a more compact way and with some additional bells and whistles: You’re probably going to use a visual debugger integrated with a code editor for the most part. PyCharm has an excellent debugger, which boasts high performance, but you’ll find plenty of alternative IDEs with debuggers, both paid and free of charge. Debugging isn’t the proverbial silver bullet. Sometimes logging or tracing will be a better solution. For example, defects that are hard to reproduce, such as race conditions, often result from temporal coupling. When you stop at a breakpoint, that little pause in program execution may mask the problem. It’s kind of like the Heisenberg principle: you can’t measure and observe a bug at the same time. These methods aren’t mutually exclusive. They complement each other.\n\nI briefly touched upon the thread safety issue before, recommending over the function. If you’re still reading this, then you must be comfortable with the concept of threads. Thread safety means that a piece of code can be safely shared between multiple threads of execution. The simplest strategy for ensuring thread-safety is by sharing immutable objects only. If threads can’t modify an object’s state, then there’s no risk of breaking its consistency. Another method takes advantage of local memory, which makes each thread receive its own copy of the same object. That way, other threads can’t see the changes made to it in the current thread. But that doesn’t solve the problem, does it? You often want your threads to cooperate by being able to mutate a shared resource. The most common way of synchronizing concurrent access to such a resource is by locking it. This gives exclusive write access to one or sometimes a few threads at a time. However, locking is expensive and reduces concurrent throughput, so other means for controlling access have been invented, such as atomic variables or the compare-and-swap algorithm. Printing isn’t thread-safe in Python. The function holds a reference to the standard output, which is a shared global variable. In theory, because there’s no locking, a context switch could happen during a call to , intertwining bits of text from multiple calls. Note: A context switch means that one thread halts its execution, either voluntarily or not, so that another one can take over. This might happen at any moment, even in the middle of a function call. In practice, however, that doesn’t happen. No matter how hard you try, writing to the standard output seems to be atomic. The only problem that you may sometimes observe is with messed up line breaks: To simulate this, you can increase the likelihood of a context switch by making the underlying method go to sleep for a random amount of time. How? By mocking it, which you already know about from an earlier section: First, you need to store the original method in a variable, which you’ll delegate to later. Then you provide your fake implementation, which will take up to one second to execute. Each thread will make a few calls with its name and a letter: A, B, and C. If you read the mocking section before, then you may already have an idea of why printing misbehaves like that. Nonetheless, to make it crystal clear, you can capture values fed into your function. You’ll notice that you get a slightly different sequence each time: Even though itself is an atomic operation, a single call to the function can yield more than one write. For example, line breaks are written separately from the rest of the text, and context switching takes place between those writes. Note: The atomic nature of the standard output in Python is a byproduct of the Global Interpreter Lock, which applies locking around bytecode instructions. Be aware, however, that many interpreter flavors don’t have the GIL, where multi-threaded printing requires explicit locking. You can make the newline character become an integral part of the message by handling it manually: This will fix the output: [Thread-2 A] [Thread-1 A] [Thread-3 A] [Thread-1 B] [Thread-3 B] [Thread-2 B] [Thread-1 C] [Thread-2 C] [Thread-3 C] Notice, however, that the function still keeps making a separate call for the empty suffix, which translates to useless instruction: A truly thread-safe version of the function could look like this: You can put that function in a module and import it elsewhere: Now, despite making two writes per each request, only one thread is allowed to interact with the stream, while the rest must wait: I added comments to indicate how the lock is limiting access to the shared resource. Note: Even in single-threaded code, you might get caught up in a similar situation. Specifically, when you’re printing to the standard output and the standard error streams at the same time. Unless you redirect one or both of them to separate files, they’ll both share a single terminal window. Conversely, the module is thread-safe by design, which is reflected by its ability to display thread names in the formatted message: It’s another reason why you might not want to use the function all the time."
    },
    {
        "link": "https://jessica-miles.medium.com/writing-functions-in-python-a-beginners-guide-ed9182db959b",
        "document": "It’s worth briefly returning to the concept I mentioned above: you can ask your function to make decisions about certain things so you don’t have to do it manually. The normality test code segment is a very simple example of coding a decision that I would otherwise have to make manually: in addition to printing the result of the test, I’m also having the code determine if the p-value is significant at an alpha level of 0.05, and telling me the result of that decision. Although I could actually make this decision quite easily myself by looking at the value, much more complex logic could be written for more nuanced decisions.\n\nNow that I’ve got working code for each of the exploratory steps that I want to perform, I can combine them into a function.\n• Write the function definition using the format with empty parentheses (no parameters) to start with. Make sure to put a colon at the end.\n• Add an empty multiline string using a set of triple quotes ( ), as a placeholder for your docstring. We’ll come back to this later.\n• Add to the end of your function body as a placeholder for the eventual stopping point. The keyword is how we indicate the point at which the function will terminate and code execution will continue at the point where the function was originally called. Optionally, the function can pass a return variable or value back to the calling code, usually representing the fruits of its labor. We’re setting the output equal to for now, and you can come back and update it later.\n\nIt’s not mandatory for functions to explicitly return a value. In this example, we could easily just print all the visualizations and statistics so we can read through them, and may not be interested in having our function actually return anything else. If you don’t include a statement at all, will be implicit. I recommend including as a placeholder to remind you to think carefully whether there is something you might want to return. If not, you can just leave as-is or remove it with no change in functionality. Also, keep in mind that you can have multiple statements if your function returns different values, or terminates from different branches of the logic tree depending the circumstances.\n\n3. Copy your code into the function body\n• Starting now, and continuing as you modify the function, be sure to add descriptive comments so you can easily skim through and find which tasks each section of code performs. You’ll be glad you did when you return to a function you wrote weeks or months ago and need to remember how it works to make an update! Just put a at the beginning of each comment line.\n• Remember that in Python, groups of statements like loops and functions need to be indented, and the indentation in the statements you coded separately may need to be adjusted.\n\nIt’s generally recommended to use a consistent number of spaces (2 or 4 spaces are common) instead of tab characters to indent code blocks. Tab characters may be interpreted in different ways, and mixing them with spaces for indentation will cause issues with code execution. If you’re working in a Jupyter Notebook, you can use for indentation and by default it will automatically be converted to 4 spaces (you can also customize this setting). Jupyter Notebook will also maintain the appropriate level of indentation when you hit enter when writing within a block of code. This is great, since it keeps your code consistent and runnable outside Jupyter Notebooks, but still allows you to use shortcuts to save time. You can select multiple lines of code and and use to indent the whole group one level, or to de-indent the whole group by one level. The ability to use these shortcuts to indent or un-indent multiple lines of code at once is very useful when assembling code you wrote outside a function, and adding loops as your function becomes more complex.\n\nParameters are the values a function expects as inputs. They may represent variables to be updated or transformed, values to be used in calculations, or options indicating which tasks the function should or shouldn’t perform. Selecting which variables in the body of the function should be parameterized is key to having a flexible function that can be easily reused with varying inputs.\n\nWhen considering which variables should be parameterized in your first draft, ask yourself:\n• What will definitely change each time I run this? These should definitely become parameters.\n• Is there anything I’ve hard-coded in my first draft that I might want to adjust in the future? These could become parameters up front, or you could also just assign values to variables at the top of the function, so you can easily assign them from parameters later.\n\nIn our example, I’m using predictor and target columns stored in a Pandas dataframe, and if I want to use this function on a different dataframe then I’ll definitely want that to be passed in. I also want to be able to explore a custom subset of predictor columns that will change each time I run the function, so I’ll create a parameter for the list of predictor column names. And finally, although for this project my target will always be , I want to use the function for future projects where the target will be named something else, so I should have a parameter for that too.\n• Add each parameter to the function definition, inside the parentheses. The names will be used not only to refer to that variable in the body of the function, but also as the keyword argument names when the function is called.\n• Choose parameter names that aren’t too long, and will naturally bring to mind what they stand for. Shorter names will be easy to refer to throughout the function body and easier to refer to when calling the function.\n• Use the same rules for naming parameters as for naming functions (all lower-case, with underscores to separate words).\n• If there is a variable or value you’re using like a constant for now but think you might want to adjust later, add it as default parameter so you don’t have to specify it as an argument every time you call the function. To make a default parameter, assign a value to it in the function definition using the equals sign.\n\nAny parameter not assigned a value in the definition (non-default) will be considered required. In , and are both required because we haven’t assigned any values to them. If we tried to call this function with only one argument (such as ), we would get an error. If you assign default values to parameters, they will be optional to include as arguments when the function is called. Default parameters that are assigned values are usually placed at the end of the parameter list. If we had the function , would be optional when the function is called because it has been assigned the default value of . We would only need to provide an argument for so calling this like will work fine assuming we’re OK with having the default value of . However, we do still have the option to specify a value other than the default for if we want to, such as ( ). Using default parameters helps simplify calling a function, since fewer arguments need to be passed and someone calling the function doesn’t need to understand every single argument in order to get started. But for less common or more advanced functionality, the optional argument values still can be easily customized.\n• Remember to keep things simple to start with and add more complexity and flexibility as needed. Start with just parameterizing what is obvious and necessary and don’t “boil the ocean” trying to think of every option you might ever want to specify.\n\nOnce you’ve decided which variables should be parameterized and chosen names for them, go through the function body be sure to replace the hard-coded values or previous variable names with the new parameters.\n\n5. Code your return value (or not)\n\nIf your function was naturally designed to output a calculated value or object, just use this step to make sure you’re returning whatever that is at the end of the function. Replace the initial placeholder with your final variable or expression.\n\nIf you’re building a function to print graphs or a report like in our example, consider whether returning a dictionary or dataframe of some of the information might also be helpful. In our example, the primary goal is to print visualizations and descriptive statistics of different predictors, but we’re also performing a normality test and calculating the Pearson correlation coefficient. Right now, we’re printing that information along with the graphs, but if I had a large number of columns I might want to compile the results in one place so I could filter or sort it instead of reading back through a bunch of printed statements.\n\nFor this example, I decided to add a few lines of code to compile some of the statistics and test result in a list of lists, and then convert that list to a dataframe that will be returned.\n\nNow that we have the basics of our function coded, it’s time to test out the function and make sure it’s working as expected.\n\nIt’s easier to to troubleshoot problems if you have a shorter list of things you’ve changed since it last worked.\n• If you’re working in a Jupyter Notebook, make sure to execute the cell containing the function to load up its most recent version.\n• If your function returns a value, don’t forget to set a variable equal to the output of the function when you call it, so you can capture the output.\n\nSuccess! In addition to the graphs and printouts that I had coded earlier, now I also get a dataframe with a bunch of the statistics I calculated for each column, so I can easily review them without scrolling back through the graphs.\n\nA note about the different ways you can pass arguments when calling a function:\n\nWhen you pass arguments to a function, you can do so by keywords, or by position. Passing arguments using keywords means that you include the parameter name as well as the value or variable, using an equals sign to connect the argument value with the proper function parameter. Here’s an example of passing arguments by keywords: The benefit of using keywords include: - It’s easy to tell which value each argument is being passed to - The keyword arguments can be in any order, since the argument names are specified If you pass arguments positionally, you don’t include the names, but you must pass them in the order in which they occurred in the function definition. Without the keywords, the compiler relies on the order to match up the argument values with the function parameters. I generally recommend passing arguments using keywords because I think it makes code more readable and I like the flexibility of being able to pass them in any order (makes it easier to add another argument to the end of the list, if needed). But ultimately it’s up to you!\n\n7. Add a docstring (even just a basic one)\n\nA docstring is a block of text that you add as the very first thing after the function definition. Docstrings explains what the function does, what arguments it takes, and what it outputs, and can also include other helpful info such as code examples. They’re an easy way for the author of the function, who is the expert on what it does and how it works, to provide built-in instructions to anyone who might want to use it.\n\nIn a Jupyter Notebook, you can show the docstring for a built-in Python function by typing the name of the function, then the opening parentheses, then on your keyboard. This initially shows the beginning of the docstring, but you can click the button to show a deeper pop-up, or the button to open a separate container on the bottom of the notebook that is easier to scroll through.\n\nThe function signature (the names of the arguments and the order in which they occur) is automatically pulled up when you summon the docstring even if you haven’t added anything manually, but without any further explanation it would be difficult for anyone else to know what the function does. Even future-you who may want to use this function a few months from now will appreciate a reminder on what it does and what to pass as each argument!\n\nYou don’t have to write a novel, but I highly recommend creating a docstring in your first draft that includes at least these basics:\n• A brief summary of what the function does\n• A list of the parameters/arguments including name, data type(s) accepted, whether it’s optional or required, and brief description of what the value or object should represent\n• A description of what the function returns, if anything\n• If there is anything you specifically know your function does NOT support yet, include that information as well\n\nSee the PEP docstring conventions here for more best practices.\n\nAt this point we’ve made a basic function for exploring data by showing visualizations and statistics and running a normality test. I’ve tested it on a few of my predictor columns, and confirmed it works.\n\nI initially developed this example function using just two predictor columns, both of which were continuous numeric variables. The method proved useful, and I gained valuable insight into these types of variables by plotting a histogram, boxplot, and scatterplot against the target. But if I also have categorical variables or binary variables, I probably need to use other methods to understand the distribution of the values and how they relate to the target.\n\nBy keeping my first draft simple I was able to get a working and useful function up and running fairly quickly, but at the cost of having a fairly narrow scope that may not work on future data sets.\n\nIn real life, I went back and updated the initial function a whole bunch of times to incorporate support for different types of data I encountered, and make the output more flexible. Here’s a list of some of the things I eventually updated, so you can get a sense for just how much more I added after the first draft:\n• Added logic to evaluate what type of data was in each column (continuous or categorical) based partly on column type in the dataframe but also on the number of unique values\n• Depending on data type, generated different types of graphs and statistics ( instead of ) for what the function judged were categorical.\n• Added parameters for each type of chart to allow them to be turned off, which involved having to make the number of axes in the figure be calculated dynamically\n• Added dynamic sizing for the matplotlib figure to allow the barplot for categorical variables to show all values even if they had high cardinality\n\nIt did take some work, but I ended up with a robust function that can handle lots of different types of data, and that I can easily reuse in many data science projects to come!\n\nThe approach of starting simple and building iteratively means you don’t have to get overwhelmed trying to think of every exception or scenario in the beginning: start with the basics and let your own usage of the first draft guide what you add in the second draft and beyond."
    },
    {
        "link": "https://realpython.com/python-formatted-output",
        "document": "In modern Python, you have f-strings and the method to approach the tasks of interpolating and formatting strings. These tools help you embed variables and expressions directly into strings, control text alignment, and use custom format specifiers to modify how values appear. You can apply these techniques to create well-structured and readable Python code.\n\nBy the end of this tutorial, you’ll understand that:\n• String interpolation in Python involves embedding variables and expressions into strings.\n• You create an f-string in Python by prepending a string literal with an or and using curly braces to include variables or expressions.\n• You can use variables in Python’s method by placing them inside curly braces and passing them as arguments.\n• Format specifiers in Python control how values appear when formatted, using components like fill, align, sign, width, and type.\n• You align text in Python string formatting using the align component, which can justify text to the left, right, or center within a specified width.\n\nWhen working with strings in Python, you can leverage these formatting techniques to create dynamic and readable output. To get the most out of this tutorial, you should know the basics of Python programming and the string data type.\n\nPython has a string formatting tool called f-strings, which stands for formatted string literals. F-strings are string literals that you can create by prepending an or to the literal. They allow you to do string interpolation and formatting by inserting variables or expressions directly into the literal. Here you’ll take a look at how you can create an f-string by prepending the string literal with an or : Using either or has the same effect. However, it’s a more common practice to use a lowercase to create f-strings. Just like with regular string literals, you can use single, double, or triple quotes to define an f-string: Up to this point, your f-strings look pretty much the same as regular strings. However, if you create f-strings like those in the examples above, you’ll get complaints from your code linter if you have one. The remarkable feature of f-strings is that you can embed Python variables or expressions directly inside them. To insert the variable or expression, you must use a replacement field, which you create using a pair of curly braces. The variable that you insert in a replacement field is evaluated and converted to its string representation. The result is interpolated into the original string at the replacement field’s location: In this example, you’ve interpolated the variable into your string. Note that Python treats anything outside the curly braces as a regular string. Also, keep in mind that Python retrieves the value of when it runs the string literal, so if isn’t defined at that time, then you get a exception. Therefore, f-strings are appropriate for eager string interpolation. Note: You’ll typically find two different types of string interpolation:\n• Eager interpolation, where Python inserts the values into the string at execution time in the same place where you define the string.\n• Lazy interpolation, where Python delays the value insertion until the string is needed. In lazy interpolation, you typically create string templates at one point in your code and fill the template with values at another point. To do this type of interpolation, you can use the method, as you’ll see in a moment. Now that you’ve learned how to embed a variable into an f-string, you can look into embedding Python expressions into your f-string literals. You can embed almost any Python expression in an f-string, including arithmetic, Boolean, and conditional expressions. You can also include function calls, attribute access, common sequence operations like indexing and slicing, and more. Note: To learn more about using f-strings in Python, check out the Python’s F-String for String Interpolation and Formatting tutorial. Here’s an example that uses an arithmetic operation: The expressions that you embed in an f-string can be almost arbitrarily complex. The examples below show some of the possibilities. You can also do indexing and slicing on sequences and look up keys in dictionaries: \"First fruit in the list is ' \"First fruit in the list is 'apple'\" \"Last two fruits in the list are \"Last two fruits in the list are ['mango', 'grape']\" \"Dict value for key 'one' is \"Dict value for key 'one' is 1\" In this example, the first two embedded expressions run indexing and slicing operations in a list. The last expression runs a dictionary key lookup. Note: Before Python 3.12, f-strings had a few limitations that restricted the expressions that you could embed. These limitations were overcome with the arrival of Python 3.12. To explore the details, check out the Python 3.12 Preview: More Intuitive and Consistent F-Strings tutorial. To include curly braces in an f-string, you need to escape it by doubling it: In this example, the outer pair of curly braces tells Python to treat the inner braces as literal characters rather than part of the expression so they can appear in the resulting string.\n\nUsing the Method for String Interpolation In many ways, the Python string method is similar to the older string modulo operator, but goes well beyond it in terms of versatility. The general form of a call is shown below: You typically call the method on a string template, which is a string containing replacement fields. The and arguments allow you to specify the values to insert into the template. The resulting string is returned from the method. In the template string, replacement fields are enclosed in curly braces ( ). Anything outside of the curly braces is literal text that’s copied directly from the template to the output. To interpolate values into a string template using , you can use positional arguments in the method call. You can then use integer indices to determine which replacement field to insert each value into: In this example, is the string , which includes three replacement fields. The replacement fields , , and contain numbers that correspond to the zero-based positional arguments , , and . Each positional argument is inserted into the template according to its index. The following diagram shows the complete process: Using the String .format() Method With Positional Arguments and Indices The arguments to are inserted into the string template in the corresponding position. The first argument goes into the replacement field with index , the second argument goes into the replacement field with index , and so on. It’s important to note that the indices don’t have to follow a strict consecutive order or be unique in the template. This allows you to customize the position of each argument in the final string. When you specify a replacement field number that’s out of range, you’ll get an error. In the following example, the positional arguments are numbered , , and , but you specify in the template: : Replacement index 3 out of range for positional args tuple This call to raises an exception because index is out of range. You can also omit the indices in the replacement fields, in which case Python will assume a sequential order. This is referred to as automatic field numbering: In this example, you’ve removed the indices from your template. In this situation, Python inserts every argument into the replacement field following the same order you used in the call to . When you specify automatic field numbering, you must provide at least as many arguments as there are replacement fields. Here’s a toy example with four replacement fields and only three arguments: : Replacement index 3 out of range for positional args tuple In this example, you have four replacement fields in the template but only three arguments in the call to . So, you get an exception. Finally, it’s fine if the arguments outnumber the replacement fields. The excess arguments aren’t used: Here, Python ignores the argument and builds the final string using only and . Note that you can’t mix these two techniques: When you use Python to format strings with positional arguments, you must choose between either automatic or explicit replacement field numbering. You can also use keyword arguments instead of positional argument to produce the same result: In this case, the replacement fields are , , and . These fields specify keywords corresponding to the keyword arguments , , and . Each keyword value is inserted into the template in place of its corresponding replacement field by name. Keyword arguments are inserted into the template string in place of keyword replacement fields with the same name: In this example, the values of the keyword arguments , , and take the place of the replacement fields , , and , respectively. If you refer to a keyword argument that’s missing, then you’ll get an error: In this example, you specify the replacement field, but no corresponding keyword argument is named in the call to , so Python raises a exception. You can specify keyword arguments in any arbitrary order: In the first example, the replacement fields are in alphabetical order and the arguments aren’t. In the second example, it’s the other way around. You can specify positional and keyword arguments in one call. In this case, all of the positional arguments must appear before any of the keyword arguments: The requirement that all positional arguments appear before any keyword arguments doesn’t only apply to the method. This is generally true for any function or method call in Python. In all the examples so far, the values you passed to have been literal values, but you can specify variables as well: In this example, you pass the variables and as positional arguments and as a keyword argument.\n\nNow that you know the basics of how to interpolate values into your strings using f-strings or , you’re ready to learn about formatting. When you call Python’s method, the template string contains replacement fields. A replacement field consists of three components. Here’s the BNF notation for the replacement fields syntax: The three components are interpreted as shown in the table below: Specifies the source of the value to be formatted Indicates which standard Python function to use to perform the type conversion Specifies the format specifier to use when formatting the input value Each component is optional and may be omitted. The component can be a name or an index as you’ve already learned. F-strings also have replacement fields. Their syntax is similar: As shown here, f-strings have up to four components. The interpretation is mostly the same as with the method. However, in an f-string, the component can hold a variable or expression. The equal sign ( ) is optional and allows you to create self-documenting strings. Up to this point, you’ve coded examples that show how to use the component in f-strings and the component in . In the following sections, you’ll learn about the other two components, which work similarly in f-strings and . The component defines the function to use when converting the input value into a string. Python can do this conversion using built-in functions like the following: By default, both f-strings and the method use . However, in some situations, you may want to use . You can do this with the component of a replacement field. The possible values for are shown in the table below: To illustrate the difference between these two values, consider the following class: This class implements the special methods and , which internally support the built-in and functions. Now consider how this class works in the context of f-strings and the method: When you use the value for the component, you get the user-friendly string representation of the interpolated object. Similarly, when you use the value, you get the developer-friendly string representation. The component is the last portion of a replacement field. This component represents the guts of Python’s string formatting functionality. It contains information that exerts fine control over how to format the input values before inserting them into the template string. The BNF notation that describes the syntax of this component is shown below: The components of are listed in order in the following table: Specifies the character to use for padding values that don’t occupy the entire field width Specifies how to justify values that don’t occupy the entire field width Controls whether a leading sign is included for numeric values Selects an alternate output form for certain presentation types, such as integers Causes values to be padded on the left with zeros instead of ASCII space characters Specifies the minimum width of the output Specifies the number of digits after the decimal point for floating-point presentation types, and the maximum output width for string presentations types Specifies the presentation type, which is the type of conversion performed on the corresponding argument In the following section, you’ll learn how these components work in practice and how you can use them to format your strings either with f-string literals or with the method.\n\nIn practice, when you’re creating format specifiers to format the values that you interpolate into your strings, you can use different components according to your specific needs. In the following sections, you’ll learn about the format specifier components and how to use them. To kick things off, you’ll start with the component, which is the final portion of a . The component specifies the presentation type, which is the type of conversion that’s performed on the corresponding value to produce the output. The possible values for are described below: The first presentation type you have is , which designates binary integer conversion: In these examples, you use the conversion type to represent the decimal number as a binary number. The presentation type allows you to convert an input integer into its associated Unicode character: As shown above, you can convert a given integer value into its associated Unicode character with the presentation type. Note that you can use the built-in function to confirm the conversion. The conversion type chooses either floating-point or exponential output, depending on the magnitude of the exponent: The exact rules governing the choice might seem slightly complicated. Generally, you can trust that the choice will make sense. The conversion type is identical to except for when the output is exponential, in which case the will be displayed in uppercase: The result is the same as in the previous example, but this time with an uppercase . You’ll find a couple of other situations where you’ll see a difference between the and presentation types. For example, under some circumstances, a floating-point operation can result in a value that’s essentially infinite. The string representation of such a number in Python is . A floating-point operation may also produce a value that can’t be represented as a number. Python represents this value with the string , which stands for Not a Number. When you pass these values to an f-string or the method, the presentation type produces lowercase output, and produces uppercase output: You’ll see similar behavior with the and presentation types. For more information on floating-point representation, , and , check out the Wikipedia page on IEEE 754. To learn more about other representation types, take a look at the Converting Between Type Representations section of Python’s Format Mini-Language for Tidy Strings. The component specifies the minimum width of the output field: Note that this is a minimum field width. Suppose you specify a value that’s longer than the minimum: In this example, is effectively ignored and the final string displays the input value as is. The and components allow you to control how the formatted output is padded and positioned within the specified field width. These components only make a difference when the input value doesn’t occupy the entire field width, which can only happen if a minimum field width is specified. If isn’t specified, then and are effectively ignored. Here are the possible values for the subcomponent: Aligns the value to the left Aligns the value to the right A format specifier that uses the less than sign ( ) indicates that the output will be left-justified: Aligning the value to the left is the default behavior with strings like . A format specifier that uses the greater than sign ( ) indicates that the output will be right-justified: Aligning to the right is the default behavior for numeric values like . A format specifier that uses a caret ( ) indicates that the output will be centered in the output field: With the caret character, you can center the input value in the output field. Finally, you can specify a value for the component using the equal sign ( ) . This sign only has meaning for numeric values with signs included. When numeric output includes a sign, it’s normally placed directly to the left of the first digit in the number: In these examples, you’ve used the component, which you’ll learn about in detail in the next section. If you set to the equal sign ( ), then the sign appears at the left of the output field: As you can see, the sign now appears on the left and the padding is added in between the sign and the number. The component allows you to replace the extra space when the input value doesn’t completely fill the output width. It can be any character except for curly braces ( ). Some examples of using are shown below: Keep in mind that if you specify a value for , then you should also include a value for . You can control whether a sign appears in numeric output with the component of your format specifiers. In the following example, the plus sign ( ) indicates that the value should always display a leading sign: In these examples, you use the plus sign to always include a leading sign for both positive and negative values. If you use the minus sign ( ), then only negative numeric values will include a leading sign: The sign lets you display the sign when the input value is negative. If the input value is positive, then no sign is displayed. Finally, you can also use a space ( ) for the component. A space means that a sign is included for negative values and a space character for positive values. To make this behavior evident in the example below, you use an asterisk as the fill character: As you can see in these examples, positive values include a space rather than a plus sign. On the other hand, negative values include the actual minus sign. When you include a hash character ( ) in the component, Python will select an alternate output form for certain presentation types. For binary ( ), octal ( ), and hexadecimal ( ) presentation types, the hash character causes the inclusion of an explicit base indicator to the left of the value: The base indicators are , , and for binary, octal, and hexadecimal representations, respectively. For floating-point ( or ) and exponential ( or ) presentation types, the hash character forces the output to contain a decimal point, even if the input consists of a whole number: For any presentation type other than those covered above, the hash character ( ) has no effect. If the output is smaller than the indicated field width and you start the component with a zero ( ), then the input value will be padded on the left with zeros instead of space characters: You’ll typically use the component for numeric values, as shown above. However, it works for string values as well: If you specify both and , then overrides the component: The and components essentially control the same thing, so there isn’t any need to specify both at the same time. In practice, is superfluous and was probably included as a convenience for developers who are familiar with the string modulo operator’s similar conversion flag. The component allows you to include a grouping separator character in numeric outputs. For decimal and floating-point presentation types, may be either a comma ( ) or an underscore ( ). That character then separates each group of three digits in the output: In these examples, you’ve used a comma and an underscore as thousand separators for integer and floating-point values. Setting the component to an underscore ( ) may also be useful with the binary, octal, and hexadecimal presentation types. In those cases, each group of four digits is separated by an underscore character in the output: If you try to specify with any presentation type other than those listed above, then your code will raise an exception. The component specifies the number of digits after the decimal point for floating-point presentation types: In these examples, you use different precision values to display the output number. The is separated from the by a literal dot ( ). For string representation types, specifies the maximum width of the output: If the input value is longer than the specified value, then the output will be truncated."
    },
    {
        "link": "https://reddit.com/r/Python/comments/o9psjn/best_practice_for_function_placement_within_a_code",
        "document": "I am new to Python(<1 year) and want my code to be clean, clear and legible. I wasn't able to get a good answer to this question via stack overflow/google so I figured I would reach out to the reddit community. ..\n\nWhere do you place your functions? Do you place them at the start of your code? Do you leave it wherever you originally create it within the code? Do you want it to be just before it's first usage? Is there a consensus amongst the community or is it like the wild west?\n\nAny help or tips would be greatly appreciated, TIA!"
    },
    {
        "link": "https://docs.python.org/3/tutorial/inputoutput.html",
        "document": "There are several ways to present the output of a program; data can be printed in a human-readable form, or written to a file for future use. This chapter will discuss some of the possibilities.\n\nSo far we’ve encountered two ways of writing values: expression statements and the function. (A third way is using the method of file objects; the standard output file can be referenced as . See the Library Reference for more information on this.) Often you’ll want more control over the formatting of your output than simply printing space-separated values. There are several ways to format output.\n• None To use formatted string literals, begin a string with or before the opening quotation mark or triple quotation mark. Inside this string, you can write a Python expression between and characters that can refer to variables or literal values.\n• None The method of strings requires more manual effort. You’ll still use and to mark where a variable will be substituted and can provide detailed formatting directives, but you’ll also need to provide the information to be formatted. In the following code block there are two examples of how to format variables: Notice how the are padded with spaces and a negative sign only for negative numbers. The example also prints multiplied by 100, with 2 decimal places and followed by a percent sign (see Format Specification Mini-Language for details).\n• None Finally, you can do all the string handling yourself by using string slicing and concatenation operations to create any layout you can imagine. The string type has some methods that perform useful operations for padding strings to a given column width. When you don’t need fancy output but just want a quick display of some variables for debugging purposes, you can convert any value to a string with the or functions. The function is meant to return representations of values which are fairly human-readable, while is meant to generate representations which can be read by the interpreter (or will force a if there is no equivalent syntax). For objects which don’t have a particular representation for human consumption, will return the same value as . Many values, such as numbers or structures like lists and dictionaries, have the same representation using either function. Strings, in particular, have two distinct representations. The value of x is 32.5, and y is 40000... # The repr() of a string adds string quotes and backslashes: # The argument to repr() may be any Python object: The module contains a class that offers yet another way to substitute values into strings, using placeholders like and replacing them with values from a dictionary, but offers much less control of the formatting. Formatted string literals (also called f-strings for short) let you include the value of Python expressions inside a string by prefixing the string with or and writing expressions as . An optional format specifier can follow the expression. This allows greater control over how the value is formatted. The following example rounds pi to three places after the decimal: 'The value of pi is approximately The value of pi is approximately 3.142. Passing an integer after the will cause that field to be a minimum number of characters wide. This is useful for making columns line up. Other modifiers can be used to convert the value before it is formatted. applies , applies , and applies : 'My hovercraft is full of My hovercraft is full of eels. 'My hovercraft is full of My hovercraft is full of 'eels'. The specifier can be used to expand an expression to the text of the expression, an equal sign, then the representation of the evaluated expression: See self-documenting expressions for more information on the specifier. For a reference on these format specifications, see the reference guide for the Format Specification Mini-Language. Basic usage of the method looks like this: We are the knights who say \"Ni!\" The brackets and characters within them (called format fields) are replaced with the objects passed into the method. A number in the brackets can be used to refer to the position of the object passed into the method. If keyword arguments are used in the method, their values are referred to by using the name of the argument. Positional and keyword arguments can be arbitrarily combined: The story of Bill, Manfred, and Georg. If you have a really long format string that you don’t want to split up, it would be nice if you could reference the variables to be formatted by name instead of by position. This can be done by simply passing the dict and using square brackets to access the keys. This could also be done by passing the dictionary as keyword arguments with the notation. This is particularly useful in combination with the built-in function , which returns a dictionary containing all local variables: __name__: __main__; __doc__: None; __package__: None; __loader__: ... As an example, the following lines produce a tidily aligned set of columns giving integers and their squares and cubes: For a complete overview of string formatting with , see Format String Syntax. Here’s the same table of squares and cubes, formatted manually: # Note use of 'end' on previous line The method of string objects right-justifies a string in a field of a given width by padding it with spaces on the left. There are similar methods and . These methods do not write anything, they just return a new string. If the input string is too long, they don’t truncate it, but return it unchanged; this will mess up your column lay-out but that’s usually better than the alternative, which would be lying about a value. (If you really want truncation you can always add a slice operation, as in .) There is another method, , which pads a numeric string on the left with zeros. It understands about plus and minus signs: The % operator (modulo) can also be used for string formatting. Given (where format is a string), conversion specifications in format are replaced with zero or more elements of values. This operation is commonly known as string interpolation. For example: 'The value of pi is approximately The value of pi is approximately 3.142. More information can be found in the printf-style String Formatting section.\n\nreturns a file object, and is most commonly used with two positional arguments and one keyword argument: The first argument is a string containing the filename. The second argument is another string containing a few characters describing the way in which the file will be used. mode can be when the file will only be read, for only writing (an existing file with the same name will be erased), and opens the file for appending; any data written to the file is automatically added to the end. opens the file for both reading and writing. The mode argument is optional; will be assumed if it’s omitted. Normally, files are opened in text mode, that means, you read and write strings from and to the file, which are encoded in a specific encoding. If encoding is not specified, the default is platform dependent (see ). Because UTF-8 is the modern de-facto standard, is recommended unless you know that you need to use a different encoding. Appending a to the mode opens the file in binary mode. Binary mode data is read and written as objects. You can not specify encoding when opening file in binary mode. In text mode, the default when reading is to convert platform-specific line endings ( on Unix, on Windows) to just . When writing in text mode, the default is to convert occurrences of back to platform-specific line endings. This behind-the-scenes modification to file data is fine for text files, but will corrupt binary data like that in or files. Be very careful to use binary mode when reading and writing such files. It is good practice to use the keyword when dealing with file objects. The advantage is that the file is properly closed after its suite finishes, even if an exception is raised at some point. Using is also much shorter than writing equivalent - blocks: # We can check that the file has been automatically closed. If you’re not using the keyword, then you should call to close the file and immediately free up any system resources used by it. Calling without using the keyword or calling might result in the arguments of not being completely written to the disk, even if the program exits successfully. After a file object is closed, either by a statement or by calling , attempts to use the file object will automatically fail. The rest of the examples in this section will assume that a file object called has already been created. To read a file’s contents, call , which reads some quantity of data and returns it as a string (in text mode) or bytes object (in binary mode). size is an optional numeric argument. When size is omitted or negative, the entire contents of the file will be read and returned; it’s your problem if the file is twice as large as your machine’s memory. Otherwise, at most size characters (in text mode) or size bytes (in binary mode) are read and returned. If the end of the file has been reached, will return an empty string ( ). 'This is the entire file.\n\n' reads a single line from the file; a newline character ( ) is left at the end of the string, and is only omitted on the last line of the file if the file doesn’t end in a newline. This makes the return value unambiguous; if returns an empty string, the end of the file has been reached, while a blank line is represented by , a string containing only a single newline. 'This is the first line of the file.\n\n' 'Second line of the file\n\n' For reading lines from a file, you can loop over the file object. This is memory efficient, fast, and leads to simple code: This is the first line of the file. If you want to read all the lines of a file in a list you can also use or . writes the contents of string to the file, returning the number of characters written. Other types of objects need to be converted – either to a string (in text mode) or a bytes object (in binary mode) – before writing them: returns an integer giving the file object’s current position in the file represented as number of bytes from the beginning of the file when in binary mode and an opaque number when in text mode. To change the file object’s position, use . The position is computed from adding offset to a reference point; the reference point is selected by the whence argument. A whence value of 0 measures from the beginning of the file, 1 uses the current file position, and 2 uses the end of the file as the reference point. whence can be omitted and defaults to 0, using the beginning of the file as the reference point. # Go to the 6th byte in the file # Go to the 3rd byte before the end In text files (those opened without a in the mode string), only seeks relative to the beginning of the file are allowed (the exception being seeking to the very file end with ) and the only valid offset values are those returned from the , or zero. Any other offset value produces undefined behaviour. File objects have some additional methods, such as and which are less frequently used; consult the Library Reference for a complete guide to file objects. Strings can easily be written to and read from a file. Numbers take a bit more effort, since the method only returns strings, which will have to be passed to a function like , which takes a string like and returns its numeric value 123. When you want to save more complex data types like nested lists and dictionaries, parsing and serializing by hand becomes complicated. Rather than having users constantly writing and debugging code to save complicated data types to files, Python allows you to use the popular data interchange format called JSON (JavaScript Object Notation). The standard module called can take Python data hierarchies, and convert them to string representations; this process is called serializing. Reconstructing the data from the string representation is called deserializing. Between serializing and deserializing, the string representing the object may have been stored in a file or data, or sent over a network connection to some distant machine. The JSON format is commonly used by modern applications to allow for data exchange. Many programmers are already familiar with it, which makes it a good choice for interoperability. If you have an object , you can view its JSON string representation with a simple line of code: Another variant of the function, called , simply serializes the object to a text file. So if is a text file object opened for writing, we can do this: To decode the object again, if is a binary file or text file object which has been opened for reading: JSON files must be encoded in UTF-8. Use when opening JSON file as a text file for both of reading and writing. This simple serialization technique can handle lists and dictionaries, but serializing arbitrary class instances in JSON requires a bit of extra effort. The reference for the module contains an explanation of this. Contrary to JSON, pickle is a protocol which allows the serialization of arbitrarily complex Python objects. As such, it is specific to Python and cannot be used to communicate with applications written in other languages. It is also insecure by default: deserializing pickle data coming from an untrusted source can execute arbitrary code, if the data was crafted by a skilled attacker."
    },
    {
        "link": "https://stackoverflow.com/questions/55664633/best-practice-for-defining-method-type-in-python",
        "document": "In python the method parameter types need not be specified. Python dynamically interprets them.\n\nBut in some code snippets I see the type being defined.\n\n1) Why is this done 2) for other data structures i need to define only the data structure and not type of the parameters it is accepting\n\nWhy is the purpose of such a design.\n\nand why i am not allowed to define the type of the list"
    }
]