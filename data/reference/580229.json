[
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/api/system.diagnostics.process?view=net-9.0",
        "document": "The following example uses an instance of the Process class to start a process.\n\nThe following example uses the Process class itself and a static Start method to start a process.\n\nThe following F# example defines a function that starts a process, captures all output and error information, and records the number of milliseconds that the process has run. The function has three parameters: the name of application to launch, the arguments to supply to the application, and the starting directory.\n\nThe code for the function was written by ImaginaryDevelopment and is available under the Microsoft Public License.\n\nA Process component provides access to a process that is running on a computer. A process, in the simplest terms, is a running app. A thread is the basic unit to which the operating system allocates processor time. A thread can execute any part of the code of the process, including parts currently being executed by another thread.\n\nThe Process component is a useful tool for starting, stopping, controlling, and monitoring apps. You can use the Process component, to obtain a list of the processes that are running, or you can start a new process. A Process component is used to access system processes. After a Process component has been initialized, it can be used to obtain information about the running process. Such information includes the set of threads, the loaded modules (.dll and .exe files), and performance information such as the amount of memory the process is using.\n\nThis type implements the IDisposable interface. When you have finished using the type, you should dispose of it either directly or indirectly. To dispose of the type directly, call its Dispose method in a / block. To dispose of it indirectly, use a language construct such as (in C#) or (in Visual Basic). For more information, see the \"Using an Object that Implements IDisposable\" section in the IDisposable interface documentation.\n\nThe process component obtains information about a group of properties all at once. After the Process component has obtained information about one member of any group, it will cache the values for the other properties in that group and not obtain new information about the other members of the group until you call the Refresh method. Therefore, a property value is not guaranteed to be any newer than the last call to the Refresh method. The group breakdowns are operating-system dependent.\n\nIf you have a path variable declared in your system using quotes, you must fully qualify that path when starting any process found in that location. Otherwise, the system will not find the path. For example, if is not in your path, and you add it using quotation marks: , you must fully qualify any process in when starting it.\n\nA system process is uniquely identified on the system by its process identifier. Like many Windows resources, a process is also identified by its handle, which might not be unique on the computer. A handle is the generic term for an identifier of a resource. The operating system persists the process handle, which is accessed through the Handle property of the Process component, even when the process has exited. Thus, you can get the process's administrative information, such as the ExitCode (usually either zero for success or a nonzero error code) and the ExitTime. Handles are an extremely valuable resource, so leaking handles is more virulent than leaking memory.\n\nIn .NET Framework, the Process class by default uses Console encodings, which are typically code page encodings, for the input, output, and error streams. For example code, on systems whose culture is English (United States), code page 437 is the default encoding for the Console class. However, .NET Core may make only a limited subset of these encodings available. If this is the case, it uses Encoding.UTF8 as the default encoding.\n\nIf a Process object depends on specific code page encodings, you can still make them available by doing the following before you call any Process methods:\n• None Retrieve the EncodingProvider object from the CodePagesEncodingProvider.Instance property.\n• None Pass the EncodingProvider object to the Encoding.RegisterProvider method to make the additional encodings supported by the encoding provider available.\n\nThe Process class will then automatically use the default system encoding rather than UTF8, provided that you have registered the encoding provider before calling any Process methods."
    },
    {
        "link": "https://stackoverflow.com/questions/1551809/why-is-the-process-class-in-the-diagnostics-namespace",
        "document": "Well, according to the documentation, \"The System.Diagnostics namespace provides classes that allow you to interact with system processes, event logs, and performance counters.\" So I guess by definition it fits. :-)\n\nBut yes, it does seem a bit like an overloading of terms by putting it next to things a bit more obviously diagnostics-related (tracing, performance counters).\n\nStill, I would say that the Process class is as much about monitoring running processes as it is about starting new ones. Monitoring is generally accepted as a diagnostic activity. Furthermore, it might be less intuitive to most programmers if the framework had split up functionality pertaining to the same item in separate namespaces. So I can see the logic of including it here."
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/api/system.diagnostics?view=net-9.0",
        "document": "Represents an operation with context to be used for logging. Allows listening to the start and stop activity events and gives the opportunity to decide creating an activity for sampling scenarios. Provides APIs to create and start Activity objects and to register ActivityListener objects to listen to the Activity events. ActivityTagsCollection is a collection class used to store tracing tags. This collection will be used with classes like ActivityEvent and ActivityLink. This collection behaves as follows:\n• The collection items will be ordered according to how they are added.\n• Don't allow duplication of items with the same key.\n• When using the indexer to store an item in the collection:\n• If the item has a key that previously existed in the collection and the value is , the collection item matching the key will be removed from the collection.\n• If the item has a key that previously existed in the collection and the value is not , the new item value will replace the old value stored in the collection.\n• Otherwise, the item will be added to the collection.\n• Add method will add a new item to the collection if an item doesn't already exist with the same key. Otherwise, it will throw an exception. Provides a simple on/off switch that controls debugging and tracing output. Indicates to compilers that a method call or attribute should be ignored unless a specified conditional compilation symbol is defined. Directs tracing or debugging output to either the standard output or the standard error stream. Correlates traces that are part of a logical transaction. Defines the counter type, name, and Help string for a custom counter. Provides a set of utility functions for interpreting performance counter data. Provides data for the OutputDataReceived and ErrorDataReceived events. Provides a set of methods and properties that help debug your code. Modifies code generation for runtime just-in-time (JIT) debugging. This class cannot be inherited. Enables communication with a debugger. This class cannot be inherited. Determines if and how a member is displayed in the debugger variable windows. This class cannot be inherited. If a .NET Debugger is attached that supports the BreakForUserUnhandledException(Exception) API, the debugger won't break on user-unhandled exceptions when the exception is caught by a method with this attribute, unless BreakForUserUnhandledException(Exception) is called. Determines how a class or field is displayed in the debugger variable windows. Specifies the DebuggerHiddenAttribute. This class cannot be inherited. Identifies a type or member that is not part of the user code for an application. Indicates the code following the attribute is to be executed in run, not step, mode. Instructs the debugger to step through the code instead of stepping into the code. This class cannot be inherited. Specifies that the type has a visualizer. This class cannot be inherited. Provides the default output methods and behavior for tracing. Directs tracing or debugging output to a text writer, such as a stream writer, or to a stream, such as a file stream. Provides an implementation of the abstract DiagnosticSource class that represents a named place to which a source sends its information (events). Represents diagnostic information about a method. Information provided by this class is similar to information provided by MethodBase but it's meant for logging and tracing purposes. An abstract class that allows code to be instrumented for production-time logging of rich data payloads for consumption within the process that was instrumented. An implementation of DistributedContextPropagator determines if and how distributed context information is encoded and decoded as it traverses the network. The encoding can be transported over any network protocol that supports string key-value pairs. For example, when using HTTP, each key-value pair is an HTTP header. DistributedContextPropagator injects values into and extracts values from carriers as string key-value pairs. Provides data for the EntryWritten event. Encapsulates a single record in the event log. This class cannot be inherited. Defines size and enumerators for a collection of EventLogEntry instances. Allows you to install and configure an event log that your application reads from or writes to when running. Defines the smallest unit of a code access security permission that is set for an EventLog. Provides a simple listener that directs tracing or debugging output to an EventLog. Directs tracing or debugging output of end-to-end events to an XML-encoded, schema-compliant log file. Represents the configuration settings used to create an event log source on the local computer or a remote computer. Indicates whether a listener should trace based on the event type. Provides version information for a physical file on disk. Provides data for the Switch.Initializing event. Provides data for the TraceSource.Initializing event. Specifies an installer for the PerformanceCounter component. Prepares performance data for the performance.dll the system loads when working with performance counters. Allows control of code access permissions for PerformanceCounter. Defines the smallest unit of a code access security permission that is set for a PerformanceCounter. Provides debug tracing support that is specifically targeted for Windows Presentation Foundation (WPF) applications. Provides access to local and remote processes and enables you to start and stop local system processes. Represents a .dll or .exe file that is loaded into a particular process. Specifies a set of values that are used when you start a process. Indicates whether a listener should trace a message based on the source of a trace. Provides a multilevel switch to control tracing and debug output without recompiling your code. Provides information about a StackFrame, which represents a function call on the call stack for the current thread. Provides extension methods for the StackFrame class, which represents a function call on the call stack for the current thread. Represents a stack trace, which is an ordered collection of one or more stack frames. Types and Methods attributed with StackTraceHidden will be omitted from the stack trace text shown in StackTrace.ToString() and Exception.StackTrace Provides a set of methods and properties that you can use to accurately measure elapsed time. Provides an abstract base class to create new debugging and tracing switches. Identifies a switch used in an assembly, class, or member. Directs tracing or debugging output to a TextWriter or to a Stream, such as FileStream. Provides a set of methods and properties that help you trace the execution of your code. This class cannot be inherited. Provides trace event data specific to a thread and a process. Provides the base class for trace filter implementations. Provides the base class for the listeners who monitor trace and debug output. Provides a set of methods and properties that enable applications to trace the execution of code and associate trace messages with their source. Provides a multilevel switch to control tracing and debug output without recompiling your code. Provides unescaped XML data for the logging of user-provided trace data. The exception that is thrown when the program executes an instruction that was thought to be unreachable. Directs tracing or debugging output as XML-encoded data to a TextWriter or to a Stream, such as a FileStream.\n\nEnumerates the data stored on an Activity object. Provides data for the CurrentChanged event. A representation that conforms to the W3C TraceContext specification. It contains two identifiers: a TraceId and a SpanId, along with a set of common TraceFlags and system-specific TraceState values. Encapsulates all the information that is sent to the activity listener, to make decisions about the creation of the activity instance, as well as its state. The possible generic type parameters are ActivityContext or String. Represents an event containing a name and a timestamp, as well as an optional list of tags. Activities may be linked to zero or more activity context instances that are causally related. Activity links can point to activity contexts inside a single trace or across different traces. Activity links can be used to represent batched operations where an activity was initiated by multiple initiating activities, each representing a single incoming item being processed in the batch. Enumerates the elements of an . Represents a TraceId whose format is based on a W3C standard. Defines a structure that holds the raw data for a performance counter. Provides an interpolated string handler for Assert(Boolean) that only performs formatting if the assert fails. Provides an interpolated string handler for WriteIf(Boolean, String) and WriteLineIf(Boolean, Object) that only performs formatting if the condition applies. Represents a list of tags that can be accessed by index. Provides methods to search, sort, and manipulate lists.\n\nSpecifies the format of the Id property. Describes the relationship between the activity, its parents and its children in a trace. Enumeration values used by ActivityListener to indicate the amount of data to collect for the related Activity. Requesting more data causes a greater performance overhead. Define the status code of the Activity which indicate the status of the instrumented operation. Specifies flags defined by the W3C standard that are associated with an activity. Specifies the debugging mode for the just-in-time (JIT) compiler. Provides display instructions for the debugger. Specifies the event type of an event log entry. Specifies how to handle entries in an event log that has reached its maximum file size. Indicates whether the performance counter category can have multiple instances. Describes the level of detail to trace about a particular object. Indicates the priority that the system associates with a process. This value, together with the priority value of each thread of the process, determines each thread's base priority level. Specified how a new window should appear when the system starts a process. Specifies the levels of trace messages filtered by the source switch and event type filter. Specifies the current execution state of the thread. Identifies the type of event that has caused the trace. Specifies what messages to output for the Debug, Trace and TraceSwitch classes. Specifies the file structure that will be used for the EventSchemaTraceListener log. Specifies trace data options to be written to the trace output.\n\nRepresents the method that will handle the OutputDataReceived event or ErrorDataReceived event of a Process. Represents the callback method that's used in the extract methods of propagators. The callback is invoked to look up the value of a named field. Represents the callback method that's used in propagators' inject methods. This callback is invoked to set the value of a named field. Propagators may invoke it multiple times in order to set multiple fields. Represents the method that will handle the EntryWritten event of an EventLog. A delegate that defines the signature of the ActivityListener callbacks used in the sampling process.\n• None The EventLog component provides functionality to write to event logs, read event log entries, and create and delete event logs and event sources on the network. The EntryWrittenEventHandler provides a way to interact with event logs asynchronously. Supporting classes provide access to more detailed control, including: permission restrictions, the ability to specify event log types (which controls the type of default data that is written with an event log entry), and iterate through collections of event log entries. For more information about these tasks, see the EventLogPermission, EventLogEntryType, and EventLogEntryCollection classes.\n• None The Process class provides functionality to monitor system processes across the network, and to start and stop local system processes. In addition to retrieving lists of running processes (by specifying either the computer, the process name, or the process id) or viewing information about the process that currently has access to the processor, you can get detailed knowledge of process threads and modules both through the Process class itself, and by interacting with the ProcessThread and ProcessModule classes. The ProcessStartInfo class enables you to specify a variety of elements with which to start a new process, such as input, output, and error streams, working directories, and command line verbs and arguments. These give you fine control over the behavior of your processes. Other related classes let you specify window styles, process and thread priorities, and interact with collections of threads and modules.\n• None The PerformanceCounter class enables you to monitor system performance, while the PerformanceCounterCategory class provides a way to create new custom counters and categories. You can write to local custom counters and read from both local and remote counters (system as well as custom). You can sample counters using the PerformanceCounter class, and calculate results from successive performance counter samples using the CounterSample class. The CounterCreationData class enables you to create multiple counters in a category and specify their types. Other classes associated with the performance counter component provide access to collections of counters, counter permission, and counter types.\n\nThe System.Diagnostics namespace also provides classes that allow you to debug your application and to trace the execution of your code. For more information, see the Trace and Debug classes."
    },
    {
        "link": "https://medium.com/@jepozdemir/how-to-launch-and-control-processes-in-c-net-applications-4ae6565410d6",
        "document": "How to Launch and Control Processes in C#.NET Applications\n\nHave you ever wanted your .NET application to open another program, run a command-line tool, or interact with other processes? The class makes this possible. It’s a powerful feature in .NET that lets you launch, monitor, and manage processes programmatically.\n\nIn this guide, we’ll cover the essentials of using straightforward examples.\n\nThe class is part of the System.Diagnostics namespace in .NET.\n\nIt allows you to:\n\nYou can launch an external application or command using the method. Here’s how to open Notepad:\n\nThis will open Notepad on your machine. Some processes require arguments. For example, opening a specific file with Notepad:\n\nIf you need more control (e.g., hiding the window or redirecting input/output), use the class.\n\nLet’s dive into the advanced options that class provides.\n\nWhile you can start a process with the method alone, gives you more control. is another class in the namespace. It provides a way to configure various settings for a process before starting it. Think of it as a blueprint for launching a program.\n\nIt’s especially useful when:\n• Specify the program or file to execute.\n• Control how the new process behaves (e.g., visibility, window style).\n\nThink of it as a detailed instruction manual for launching a process.\n\nHere are some commonly used properties of :\n• FileName: Specifies the application or file to execute.\n• Arguments: Specifies the command-line arguments to pass to the program.\n• UseShellExecute: Indicates whether to use the operating system shell to start the process.\n• CreateNoWindow: Specifies whether to create a new window for the process.\n• RedirectStandardInput: Allows you to redirect the process’s input stream.\n• RedirectStandardOutput: Allows you to redirect the process’s output stream.\n• RedirectStandardError: Allows you to redirect the process’s error stream.\n• WorkingDirectory: Specifies the working directory for the process.\n\nHow to Use -ProcessStartInfo-\n\nHere’s how you can use step by step:\n\nCreate an instance of and set its properties as follows:\n\nThen, you are able to use the class to start the process.\n\nIn this example:\n• We create a object and set the property to .\n• Then, we create a object and link it to the .\n• Finally, we call to launch the process.\n\nSuppose we want to open a specific text file in Notepad. \n\nHere, the property is set to “example.txt”. This tells to open the file .\n\nYou can manage how much CPU time a process gets by setting its priority using the property after starting the process.\n\nSome tasks don’t need a visible window. For example, running a background script:\n\nNote that in this example, ensures no command window pops up. is required for hiding the window and enabling advanced options like redirection.\n\nYou can subscribe to the event to run code when a process ends. This is useful for scenarios where you want to perform cleanup or logging.\n\nSometimes, a process requires specific environmental variables to run correctly. You can set these directly using the property.\n\nYou can use the property to add or modify environment variables for the process. This is handy when working with tools that rely on specific configurations.\n\nSometimes, you may need to send data to a process after it has started. This is possible by redirecting the standard input.\n\nYou can also redirect the standard output of a process for logging or analysis. \n\nAssume that you want to run a command-line process (cmd.exe), capture its output (what it writes to the console), and then display that output in our application.\n\nIf you want to capture errors generated by the process, you can redirect the standard error.\n\nWant to see which processes are running on your system? You can use the method to inspect running processes. \n\nFor example, listing all currently running processes:\n\nThis lists all active processes with their names and IDs.\n\nIf you need to terminate a specific process, you can use the method.\n\nFor example, to stop an unwanted Notepad instance:\n\nThis code finds all instances of Notepad and terminates them.\n\nSample codes used here are available in the following GitHub repository:\n\nis a powerful class in the .NET Framework for starting and configuring processes. Whether you need to open a file, run a command-line utility, or interact with another program, gives you the flexibility to get the job done.\n\nStart experimenting with in your projects, and you’ll see how it can simplify tasks that involve external processes!"
    },
    {
        "link": "https://blog.devgenius.io/mastering-process-management-in-net-the-ultimate-guide-to-system-diagnostics-process-a527819c9cff",
        "document": "Managing processes is a critical aspect of developing robust and efficient .NET applications. The System.Diagnostics.Process class provides a powerful and flexible way to interact with processes, allowing you to start, monitor, and control them. In this ultimate guide, we’ll cover everything you need to know to become proficient in using the Process class.\n\nUnderstanding the Process class and its properties\n\nThe Process class, found in the System.Diagnostics namespace, enables you to interact with system processes. It provides properties to access process information (e.g., process ID, start time), methods to start and stop processes, and events to monitor process behavior.\n\nTo work with the Process class, you need to create a new instance:"
    },
    {
        "link": "https://stackoverflow.com/questions/53581295/how-to-distinguish-system-diagnostic-process-exit-events-based-on-the-reason-for",
        "document": "Within my application the user can select different files and executables via a . From the path of the chosen file a is created and added to a .\n\nThe plan is that the user can select different files and programs and add them to a list within the application. The software should then open - and later close - the chosen files as soon as a certain event is fired (in this case a gesture by the user captured with the camera).\n\nThe holds several properties for different options, but the ones important for my question are set in the constructor as follows:\n\nWhat I want to do with each is, that in case a certain event in the application is triggered I want to start the associated process. Furthermore, I want to track, how many instances of the same processes have been started and also be able to close them via another event. To achieve this, I listen to the event and handle my list of instances accordingly. Before I get to the actual issue, here are the methods I use (all within my class):\n\nstopping the last instance in the list:\n\nmethod, which listens to the event of the process being closed (externally):\n\nUpdating the number of current instances to the GUI:\n\nAs you can see in the method, I check if the extension is from an executable or an software associated file ( is a string holding @\".exe\"). Everthing is working as intented, however if for example the user puts two different files, the second process is immediately terminated, because my pdf-viewer has already been started by associated to the first file.\n\nFor this case I need to handle things differently. As far as I can see, I have to ways of doing it:\n• Forcing each newly started process into it's own Window: I don't really consider this a good idea additionally to not really knowing how to achieve that with all different software types.\n• Informing the user what is happening and why there are 0 instances in the respective item, when clearly the file is opened. I prefer this one and my approach would be to get information from the argument of the method.\n\nSo my question: how can I distinguish if the process exit happened because of the described case?\n\nEDIT: My current approach would be to track the process IDs, however I'm wondering if there is a better solution, maybe already implemented to the Process-Class\n\nEDIT2: For better understanding, the complete project can be found here."
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/api/system.diagnostics.process.exited?view=net-9.0",
        "document": "Some information relates to prerelease product that may be substantially modified before it’s released. Microsoft makes no warranties, express or implied, with respect to the information provided here.\n\nThe following code example creates a process that prints a file. It raises the Exited event when the process exits because the EnableRaisingEvents property was set when the process was created. The Exited event handler displays process information.\n\nThe Exited event indicates that the associated process exited. This occurrence means either that the process terminated (aborted) or successfully closed. This event can occur only if the value of the EnableRaisingEvents property is .\n\nThere are two ways of being notified when the associated process exits: synchronously and asynchronously. Synchronous notification means calling the WaitForExit method to block the current thread until the process exits. Asynchronous notification uses the Exited event, which allows the calling thread to continue execution in the meantime. In the latter case, EnableRaisingEvents must be set to for the calling application to receive the Exited event.\n\nWhen the operating system shuts down a process, it notifies all other processes that have registered handlers for the Exited event. At this time, the handle of the process that just exited can be used to access some properties such as ExitTime and HasExited that the operating system maintains until it releases that handle completely.\n\nFor more information about the use of the Exited event in Windows Forms applications, see the SynchronizingObject property."
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/standard/events",
        "document": "Events in .NET are based on the delegate model. The delegate model follows the observer design pattern, which enables a subscriber to register with and receive notifications from a provider. An event sender pushes a notification when an event occurs. An event receiver defines the response. This article describes the major components of the delegate model, how to consume events in applications, and how to implement events in your code.\n\nAn event is a message sent by an object to signal the occurrence of an action. The action might be user interaction, such as a button press, or it might result from other program logic, such as a property value change. The object that raises the event is called the event sender. The event sender doesn't know the object or method that receives (handles) the events it raises. The event is typically a member of the event sender. For example, the Click event is a member of the Button class, and the PropertyChanged event is a member of the class that implements the INotifyPropertyChanged interface.\n\nTo define an event, you use the C# event or the Visual Basic Event keyword in the signature of your event class, and specify the type of delegate for the event. Delegates are described in the next section.\n\nTypically, to raise an event, you add a method that is marked as and (in C#) or and (in Visual Basic). The naming convention for the method is , such as . The method should take one parameter that specifies an event data object, which is an object of type EventArgs or a derived type. You provide this method to enable derived classes to override the logic for raising the event. A derived class should always call the method of the base class to ensure registered delegates receive the event.\n\nThe following example shows how to declare an event named . The event is associated with the EventHandler delegate and raised in a method named :\n\nA delegate is a type that holds a reference to a method. A delegate is declared with a signature that shows the return type and parameters for the methods it references. It can hold references only to methods that match its signature. A delegate is equivalent to a type-safe function pointer or a callback. A delegate declaration is sufficient to define a delegate class.\n\nDelegates have many uses in .NET. In the context of events, a delegate is an intermediary (or pointer-like mechanism) between the event source and the code that handles the event. You associate a delegate with an event by including the delegate type in the event declaration, as shown in the example in the previous section. For more information about delegates, see the Delegate class.\n\n.NET provides the EventHandler and EventHandler<TEventArgs> delegates to support most event scenarios. Use the EventHandler delegate for all events that don't include event data. Use the EventHandler<TEventArgs> delegate for events that include data about the event. These delegates have no return type value and take two parameters (an object for the source of the event and an object for event data).\n\nDelegates are multicast class objects, which means they can hold references to more than one event-handling method. For more information, see the Delegate reference page. Delegates provide flexibility and fine-grained control in event handling. A delegate acts as an event dispatcher for the class that raises the event by maintaining a list of registered event handlers for the event.\n\nUse the EventHandler and EventHandler<TEventArgs> delegate types to define the needed delegate. You mark a delegate with the type in [C#]](../../csharp/language-reference/builtin-types/reference-types.md#the-delegate-type) or the type in Visual Basic in the declaration. The following example shows how to declare a delegate named :\n\nData associated with an event can be provided through an event data class. .NET provides many event data classes that you can use in your applications. For example, the SerialDataReceivedEventArgs class is the event data class for the SerialPort.DataReceived event. .NET follows a naming pattern where all event data classes end with the suffix. You determine which event data class is associated with an event by looking at the delegate for the event. For example, the SerialDataReceivedEventHandler delegate includes the SerialDataReceivedEventArgs class as a parameter.\n\nThe EventArgs class is typically the base type for event data classes. You also use this class if an event doesn't have any data associated with it. When you create an event that notifies subscribers that something happened without any additional data, include the EventArgs class as the second parameter in the delegate. You can pass the EventArgs.Empty value when no data is provided. The EventHandler delegate includes the EventArgs class as a parameter.\n\nYou can create a class that derives from the EventArgs class to provide any members needed to pass data related to the event. Typically, you should use the same naming pattern as .NET and end your event data class name with the suffix.\n\nThe following example shows an event data class named that contains properties that are specific to the event being raised:\n\nTo respond to an event, you define an event handler method in the event receiver. This method must match the signature of the delegate for the event you're handling. In the event handler, you perform the actions that are required when the event is raised, such as collecting user input after the user presses a button. To receive notifications when the event occurs, your event handler method must subscribe to the event.\n\nThe following example shows an event handler method named that matches the signature for the EventHandler delegate. The method subscribes to the event:\n\n.NET allows subscribers to register for event notifications either statically or dynamically. Static event handlers are in effect for the entire life of the class whose events they handle. Dynamic event handlers are explicitly activated and deactivated during program execution, usually in response to some conditional program logic. You can use dynamic handlers when event notifications are needed only under certain conditions, or when run-time conditions determine the specific handler to call. The example in the previous section shows how to dynamically add an event handler. For more information, see Events (in Visual Basic) and Events (in C#).\n\nIf your class raises multiple events, the compiler generates one field per event delegate instance. If the number of events is large, the storage cost of one field per delegate might not be acceptable. For these scenarios, .NET provides event properties that you can use with another data structure of your choice to store event delegates.\n\nEvent properties consist of event declarations accompanied by event accessors. Event accessors are methods that you define to add or remove event delegate instances from the storage data structure.\n\nThe trade-off is between memory and speed. If your class defines many events that are infrequently raised, you should implement event properties. For more information, see Handle multiple events by using event properties.\n\nThe following resources describe other tasks and concepts related to working with events:\n• Raise and consume events: Find examples for raising and consuming events.\n• Handle multiple events with event properties: Discover how to use event properties to handle multiple events.\n• Explore the observer design pattern: Review a design pattern that enables a subscriber to register with and receive notifications from a provider.\n\nSpecification reference documentation is available for the APIs that support event handling:"
    },
    {
        "link": "https://stackoverflow.com/questions/24940142/how-to-exit-exe-process-on-c",
        "document": "How to exit process on this scenario on Application Exit or on Exit Button.\n\nHow to exit process on this scenario on Application Exit."
    },
    {
        "link": "https://codeblog.jonskeet.uk/2015/01/30/clean-event-handlers-invocation-with-c-6",
        "document": "Invoking event handlers in C# has always been a bit of a pain, because an event with no subscribers is usually represented as a null reference. This leads to code like this:\n\nIt’s important to use the local variable, as if instead you access the field twice, it’s possible that the last subscriber will unsubscribe between the check and the invocation:\n\nNow this can be simplified slightly using an extension method:\n\nThen in each event, you can write a single line:\n\nHowever, this means having a different extension method for each delegate type. It’s not too bad if you’re using but it’s still not ideal.\n\nC# 6 to the rescue!\n\nThe null-conditional operator ( ) in C# 6 isn’t just for properties. It can also be used for method calls. The compiler does the right thing (evaluating the expression only once) so you can do without the extension method entirely:\n\nHooray! This will never throw a , and doesn’t need any extra utility classes.\n\nAdmittedly it might be nicer if you could write but that would no longer be a operator, so would complicate the language quite a bit, I suspect. The extra slight cruft of really doesn’t bother me much.\n\nWhat is this thing you call thread-safe?\n\nThe code we’ve got so far is “thread-safe” in that it doesn’t matter what other threads do – you won’t get a from the above code. However, if other threads are subscribing to the event or unsubscribing from it, you might not see the most recent changes for the normal reasons of memory models being complicated.\n\nAs of C# 4, field-like events are implemented using , so we can just use a corresponding call to make sure we get the most recent value. There’s nothing new about being able to do that, admittedly, but it does mean we can just write:\n\nwith no other code, to invoke the absolute latest set of event subscribers, without failing if a is thrown. Thanks to David Fowler for reminding me about this aspect.\n\nAdmittedly the call is ugly. In .NET 4.5 and up, there’s which may do the tricky, but it’s not entirely clear to me (based on the documentation) whether it actually does the right thing. (The summary suggests it’s about preventing the movement of later reads/writes earlier than the given volatile read; we want to prevent earlier writes from being moved later.)\n\n… but that makes me nervous in terms of whether I’ve missed something. Expert readers may well be able to advise me on why this is sufficiently foolish that it’s not in the BCL.\n\nOne alternative approach I’ve used in the past is to create a dummy event handler, usually using the one feature that anonymous methods have over lambda expressions – the ability to indicate that you don’t care about the parameters by not even specifying a parameter list:\n\nThis has all the same memory barrier issues as before, but it does mean you don’t have to worry about the nullity aspect. It looks a little odd and presumably there’s a tiny performance penalty, but it’s a good alternative option to be aware of.\n\nYup, C# 6 rocks again. Really looking forward to the final release."
    }
]