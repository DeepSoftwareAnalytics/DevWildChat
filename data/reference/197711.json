[
    {
        "link": "https://shorewall.org/configuration_file_basics.htm",
        "document": "You may use the file to set shell variables that you can then use in the other configuration files. It is suggested that variable names begin with an upper case letter to distinguish them from variables used internally within the Shorewall programs The following variable names must be avoided. Those in bold font must be avoided in all Shorewall versions; those in regular font must be avoided in versions prior to 4.4.8. Any name beginning with SHOREWALL_ or SW_ /etc/shorewall/params NET_IF=eth0 NET_OPTIONS=routefilter,routefilter /etc/shorewall/interfaces record: net $NET_IF $NET_OPTIONS The result will be the same as if the record had been written net eth0 routefilter,routefilter Variables may be used anywhere in the other configuration files. If you use \"$FW\" on the right side of assignments in the file, you must also set the FW variable in that file. Because the file is simply sourced into the shell, you can place arbitrary shell code in the file and it will be executed each time that the file is read. Any code included should follow these guidelines:\n• None The code should not have side effects, especially on other shorewall configuration files.\n• None The code should be safe to execute multiple times without producing different results.\n• None Should not depend on where the code is called from.\n• None Should not assume anything about the state of Shorewall.\n• None The names of any functions or variables declared should begin with an upper case letter.\n• None The file is processed by the compiler at compile-time and by the compiled script at run-time. If you have set EXPORTPARAMS=No in , then the file is only processed by the compiler; it is not run by the compiled script. Beginning with Shorewall 4.4.17, the values of the variables set at compile time are available at run time with EXPORTPRARMS=No.\n• None If you are using Shorewall Lite and if the script needs to set shell variables based on the configuration of the firewall system, you can use this trick: The shorewall-lite call command allows you to call interactively any Shorewall function that you can call in an extension script. Within your configuration files, only the $VAR and ${VAR} forms of variable expansion are supported. You may not use the more exotic forms supported by the shell (${VAR:=val}, ${VAR:-val}, ...) Beginning with Shorewall 4.4.27, you may also use options in shorewall.conf (5) (e.g., $BLACKLIST_LOGLEVEL). When an option is set to 'No' in shorewall.conf, the corresponding shell variable will be empty. Options that were not set in shorewall.conf will expand to their default value. Beginning with Shorewall 4.5.2, configuration files can access variables defined in the shorewallrc file. Beginning with Shorewall 4.5.11, variables can be altered by compiler directives. The can be specified either with or without a leading '$' to allow using both Perl and Shell variable representation. The ${...} form (e.g. ${foo}) is not allowed. The Shorewall compiler performs variable expansion within the expression. So variables are expanded even when they appear in single quotes. If a variable within the expression can contain a non-numeric value, it is a good idea to enclose it in quotes. Otherwise, the Shorewall compiler has to guess whether to enclose the variable's value in quotes or not. Removes the named from the compiler's variable table. Action variables are read-only and cannot be ?SET (although you can change their values using embedded Perl). Beginning with Shorewall 4.5.13, Shorewall Variables may be set. When setting a Shorewall Variable, the must include the leading '@' and the @{...} form is not allowed.\n\nPrior to Shorewall 5.0.14, if you use address variables that refer to an optional interface, the enable command will not change/insert the rules that use the variable. Therefore, to be completely safe, if you use such address variables then you must follow a successful enable command with a reload command. Beginning with Shorewall 5.0.14, if a Shorewall-defined address variable's value has changed since the Netfilter ruleset was instantiated, then a successful enable command will automatically reload the ruleset. Given that shell variables are expanded at compile time, there is no way to cause such variables to be expanded at run time. Prior to Shorewall 4.4.17, this made it difficult (to impossible) to include dynamic IP addresses in a Shorewall-lite configuration. Version 4.4.17 implemented Run-time address variables. In configuration files, these variables are expressed as an apersand ('&') followed by the logical name of an interface defined in shorewall-interfaces (5). Wildcard interfaces (those ending in '+') are not supported and will cause a compilation error. ð0 would represent the primary IP address of eth0. Beginning with Shorewall 4.5.11, you can define your own address variables by using this syntax: where is a valid shell variable name. The generated script will verify that the contains a valid host or network address, either from the environment or from it being assigned in your init extension script, and will raise an error if it does not. In the error case, the state of the firewall will remain unchanged. A second form is also available beginning with Shorewall 4.5.11 Unlike with the first form, this form does not require the variable to be set. If the variable is empty, the generated script will supply the all-zeros address (0.0.0.0 in IPv4 and :: in IPv6). In most cases, the compiler simply omits rules containing matches on the all-zeros address. For a particular address variable, all references must use the same prefix character ('&' or '%'). Otherwise, the following error message is raised: Run-time address variables may be used in the SOURCE and DEST column of the following configuration files: They may also appear in the ORIGDEST column of: They may also be used as the parameter to SNAT() in shorewall-snat(5). For optional interfaces, if the interface is not usable at the time that the firewall starts, one of two approaches are taken, depending on the context:\n• None the all-zero address will be used (0.0.0.0 in IPv4 and :: in IPv6), resulting in no packets matching the rule (or all packets if used with exclusion).\n• None the entire rule is omitted from the ruleset. Beginning with Shorewall 4.5.1, Run-time Gateway Variables in the form of a percent sign ('%') followed by a logical interface name are also supported. These are expanded at run-time to the gateway through the named interface. For optional interfaces, if the interface is not usable at the time that the firewall starts, the nil address will be used (0.0.0.0 in IPv4 and :: in IPv6), resulting in no packets matching the rule. Run-time gateway variables may be used in the SOURCE and DEST columns of the following configuration files:\n• None shorewall-nat(5) (As a qualifier to the INTERFACE). %eth0 would represent the IP address of the gateway out of eth0. If there is no gateway out of the named interface, rules containing the intefaces's run-time gateway variable are omitted.\n\nShorewall Variables were introduced in Shorewall 4.5.11. To insure uniqueness, these variables start with the character @; the name of the variable must be enclosed in {...} when the following character is alphanumeric or is an underscore (\"_\"). With the exception of @0 (or it's alias @chain), Shorewall variables may only be used within an action body. Prior to Shorewall 4.5.13, Shorewall variables are read-only. Beginning with Shorewall 4.5.13, their values may be altered using the ?SET directive. Expands to the name of the current chain. Unlike $0, @0 has all non-alphanumeric characters except underscore removed. Also unlike $0, @0 may be used in SWITCH columns in configuration files. These are synonyms for the Action parameter variables $1, $2, etc. Expands to the log level specified when the action was invoked. Expands to the log tag specified when the action was invoked. Expands to the name of the action being compiled. Added in Shorewall 4.5.13. When a non-inlined action is entered, this variable is set to the empty value. When an inline action is entered, the variable's value is unchanged. Added in Shorewall 4.5.13. Within an action, expands to the name of the chain that invoked the action. Beginning with Shorewall 4.5.13, the values of @chain and @disposition are used to generated the --log-prefix in logging rules. When either is empty, the historical value is used to generate the --log-prefix. Within an action body, if a parameter is omitted in a DEFAULTS statement, then the value of the corresponding action and Shorewall variables is '-', while if the parameter is specified as '-' in the parameter list, the value of the action/Shorewall variable is '', if it is expanded before the DEFAULTS statement. Additionally, when an expression is evaluated, the value 0 evaluates as false, so '?IF @n' and '?IF $n' fail if the nth parameter is passed with value zero. To make testing of the presense of parameters more efficient and uniform, an new function has been added in Shorewall 5.0.7 for use in ?IF and ?ELSEIF: where <variable> is an action or Shorewall variable. 'passed(@n)' and 'passed($n)' evaluate to true if the nth parameter is not empty and its contents are other than '-'. If '!' is present, the result is inverted. In this simple form, the expression is evaluated by the compiler without having to invoke the (expensive) Perl exec() function. The 'passed' function may also be used in more complex expressions, but exec() will be invoked to evaluate those expressions.\n\nBeginning with Shorewall 4.5.2, lines in configuration files may be conditionally included or omitted based on the setting of Shell variables. ?IF <lines to be included if $variable is non-empty and non-zero> ?ELSE <lines to be omitted if $variable is non-empty and non-zero> ?ENDIF The compiler predefines two special s that may only be used in ?IF lines: True if this is an IPv4 compilation True if this is an IPv6 compilation. Unless is one of these pre-defined ones, it is searched for in the following places in the order listed.\n• None options set in the file when Shorewall Core was installed. Beginning with Shorewall 4.5.11, the compiler's environmental variables are searched last rather than first. If the is still not found:\n• None if it begins with '__', then those leading characters are stripped off.\n• None the variable is then searched for in the defined capabilities. The current set of capabilities may be obtained by the command shorewall show capabilities (the capability names are in parentheses). If it is not found in any of those places, the is assumed to have a value of 0 (false) in Shorewall versions prior to 4.5.11. In 4.5.11 and later, it is assumed to have the value '' (an empty string, which also evaluates to false). The setting in may be overridden at runtime, provided the setting in is done like this: Either of those will set variable to 0 if it is not set to a non-empty value in the environment. The setting can be overridden at runtime: =1 shorewall restart -c # use -c to force recompilation if AUTOMAKE=Yes in /etc/shorewall/shorewall.conf The ?ELSE may be omitted if there are no lines to be omitted. The test may also be inverted using '!': ?IF ! <lines to be omitted if $variable is non-empty and non-zero> ?ELSE <lines to be included if $variable is non-empty and non-zero> ?ENDIF Conditional entries may be nested but the number of ?IFs must match the number of ?ENDs in any give file. INCLUDE directives are ignored in omitted lines. ?IF <lines to be included if $variable1 is non-empty and non-zero> ?IF $variable2 <lines to be included if $variable1 and $variable2 are non-empty and non-zero> ?ELSE <lines to be omitted if $variable1 is non-empty and non-zero and if $variable2 is empty or zero> ?ENDIF <lines to be included if $variable1 is non-empty and non-zero> ?ELSE <lines to be omitted if $variable is non-empty and non-zero> ?ENDIF Beginning with Shorewall 4.5.6, rather than a simple variable in ?IF directives, Perl-compatible expressions are allowed (after the Shorewall compiler expands all variables, the resulting expression is then evaluated by Perl). Variables in the expressions are as described above. ?IF <lines to be included if expression-1 evaluates to true (non-empty and non-zero) ?ELSIF <lines to be included if expression-1 evaluates to false (zero or empty) and expression-2 evaluates to true ?ELSIF <lines to be included if expression-1 and expression-2 both evalute to false and expression-3 evalutes to true ?ELSE <lines to be included if all three expressions evaluate to false. ?ENDIF Beginning in Shorewall 5.0.7, an error can be raised using the ?ERROR directive: Variables in the message are evaluated and the result appears in a standard Shorewall ERROR: message. Example from the 5.0.7 action.GlusterFS: ?if @1 !~ /^\\d+/ || ! @1 || @1 > 1024 ?error Invalid value for Bricks (@1) ?elsif @2 !~ /^[01]$/ ?error Invalid value for IB (@2) ?endif The above code insures that the first action paramater is a non-zero number <= 1024 and that the second parameter is either 0 or 1. If 2000 is passed for the first parameter, the following error message is generated: ERROR: Invalid value for Bricks (2000) /usr/share/shorewall/action.GlusterFS (line 15) from /etc/shorewall/rules (line 45) In Shorewall 5.0.8, ?WARNING and ?INFO directives were added. ?WARNING message produces a standard Shorewall WARNING: message, while ?INFO produces a similar message which is prefaced by INFO: rather than WARNING:. Both write the message to STDERR. The message is also written to the STARTUP_LOG, if any, provided that the command is start, try, restart, reload, refresh, or one of the safe-* commands. See the VERBOSE_MESSAGES option in shorewall.conf(5) for additional information. In Shorewall 5.1.4, the behavior of ?ERROR, ?WARNING and ?INFO was changed when they appear in an action file. Rather than reporting the action filename and line number, the generated message reports where the action was invoked. For example, the GlusterFS message above was changed to: ERROR: Invalid value (2000) for the GlusterFS Bricks argument /etc/shorewall/rules (line 45)\n\nI personally recommend strongly against using DNS names in Shorewall configuration files. If you use DNS names and you are called out of bed at 2:00AM because Shorewall won't start as a result of DNS problems then don't say that you were not forewarned. Host addresses in Shorewall configuration files may be specified as either IP addresses or DNS Names. DNS names in iptables rules aren't nearly as useful as they first appear. When a DNS name appears in a rule, the iptables utility resolves the name to one or more IP addresses and inserts those addresses into the rule. So changes in the DNS->IP address relationship that occur after the firewall has started have absolutely no effect on the firewall's rule set. For some sites, using DNS names is very risky. Here's an example: teastep@ursa:~$ dig pop.gmail.com ; <<>> DiG 9.4.2-P1 <<>> pop.gmail.com ;; global options: printcmd ;; Got answer: ;; ->>HEADER<<- opcode: QUERY, status: NOERROR, id: 1774 ;; flags: qr rd ra; QUERY: 1, ANSWER: 3, AUTHORITY: 7, ADDITIONAL: 0 ;; QUESTION SECTION: ;pop.gmail.com. IN A ;; ANSWER SECTION: pop.gmail.com. IN CNAME gmail-pop.l.google.com. gmail-pop.l.google.com. IN A 209.85.201.109 gmail-pop.l.google.com. IN A 209.85.201.111 Note that the TTL is 300 -- 300 seconds is only 5 minutes. So five minutes later, the answer may change! So this rule may work for five minutes then suddently stop working: There are two options in shorewall[6].conf(5) that affect the use of DNS names in Shorewall[6] config files:\n• None DEFER_DNS_RESOLUTION - When set to No, DNS names are resolved at compile time; when set to Yes, DNS Names are resolved at runtime.\n• None AUTOMAKE - When set to Yes, start, restart and reload only result in compilation if one of the files on the CONFIG_PATH has changed since the the last compilation. So by setting AUTOMAKE=Yes, and DEFER_DNS_RESOLUTION=No, compilation will only take place at boot time if a change had been make to the config but no restart or reload had taken place. This is clearly spelled out in the shorewall.conf manpage. So with these settings, so long as a 'reload' or 'restart' takes place after the Shorewall configuration is changes, there should be no DNS-related problems at boot time. When DEFER_DNS_RESOLUTION=No and AUTOMAKE=Yes and a DNS change makes it necessary to recompile an existing firewall script, the option must be used with the reload or restart command to force recompilation. If your firewall rules include DNS names then, even if DEFER_DNS_RESOLUTION=No and AUTOMAKE=Yes:\n• None If your is wrong then your firewall may not start.\n• None If your is wrong then your firewall may not start.\n• None If your Name Server(s) is(are) down then your firewall may not start.\n• None If your startup scripts try to start your firewall before starting your DNS server then your firewall may not start.\n• None Factors totally outside your control (your ISP's router is down for example), can prevent your firewall from starting.\n• None You must bring up your network interfaces prior to starting your firewall, or the firewall may not start. Each DNS name must be fully qualified and include a minimum of two periods (although one may be trailing). This restriction is imposed by Shorewall to insure backward compatibility with existing configuration files. \n\n \n\n DNS names may not be used as:\n• None In the ADDRESS column of an entry in /etc/shorewall/masq. These restrictions are imposed by Netfilter and not by Shorewall."
    },
    {
        "link": "https://shorewall.org/manpages/shorewall-nat.html",
        "document": "External IP Address - this should NOT be the primary IP address of the interface named in the next column and must not be a DNS Name. If you put ?COMMENT in this column, the rest of the line will be attached as a comment to the Netfilter rule(s) generated by the following entries in the file. The comment will appear delimited by \"/* ... */\" in the output of \"shorewall show nat\" To stop the comment from being attached to further rules, simply include ?COMMENT on a line by itself.\n\nInterfaces that have the EXTERNAL address. If ADD_IP_ALIASES=Yes in shorewall.conf(5), Shorewall will automatically add the EXTERNAL address to this interface. Also if ADD_IP_ALIASES=Yes, you may follow the interface name with \":\" and a digit to indicate that you want Shorewall to add the alias with this name (e.g., \"eth0:0\"). That allows you to see the alias with ifconfig. That is the only thing that this name is good for -- you cannot use it anywhere else in your Shorewall configuration. Each interface must match an entry in shorewall-interfaces(5). Shorewall allows loose matches to wildcard entries in shorewall-interfaces(5). For example, in this file will match a shorewall-interfaces(5) entry that defines . If you want to override ADD_IP_ALIASES=Yes for a particular entry, follow the interface name with \":\" and no digit (e.g., \"eth0:\").\n\nIf Yes or yes, NAT will be effective from all hosts. If No or no (or left empty) then NAT will be effective only through the interface named in the INTERFACE column. This column was formerly labelled ALL INTERFACES."
    },
    {
        "link": "https://shorewall.org/manpages/shorewall.conf.html",
        "document": ""
    },
    {
        "link": "https://shorewall.org/NAT.htm",
        "document": "If all you want to do is forward ports to servers behind your firewall, you do NOT want to use one-to-one NAT. Port forwarding can be accomplished with simple entries in the rules file. One-to-one NAT is a way to make systems behind a firewall and configured with private IP addresses (those reserved for private use in RFC 1918) appear to have public IP addresses. Before you try to use this technique, I strongly recommend that you read the Shorewall Setup Guide. One-to-one NAT can be used to make the systems with the 10.1.1.* addresses appear to be on the upper (130.252.100.*) subnet. If we assume that the interface to the upper subnet is eth0, then the following file would make the lower left-hand system appear to have IP address 130.252.100.18 and the right-hand one to have IP address 130.252.100.19. It should be stressed that these entries in the file do not automatically enable traffic between the external network and the internal host(s) — such traffic is still subject to your policies and rules. #EXTERNAL INTERFACE INTERNAL ALLINTS LOCAL 130.252.100.18 eth0 10.1.1.2 no no 130.252.100.19 eth0 10.1.1.3 no no Be sure that the internal system(s) (10.1.1.2 and 10.1.1.3 in the above example) is (are) not included in any specification in ( ) or . The “ALL INTERFACES” column is used to specify whether access to the external IP from all firewall interfaces should undergo NAT (Yes or yes) or if only access from the interface in the INTERFACE column should undergo NAT. If you leave this column empty, “No” is assumed . Specifying “Yes” in this column will not by itself allow systems on the lower LAN to access each other using their public IP addresses. For example, the lower left-hand system (10.1.1.2) cannot connect to 130.252.100.19 and expect to be connected to the lower right-hand system. See FAQ 2a. Shorewall will automatically add the external address to the specified interface unless you specify ADD_IP_ALIASES=“no” (or “No”) in ; If you do not set ADD_IP_ALIASES or if you set it to “Yes” or “yes” then you must NOT configure your own alias(es). The contents of the “LOCAL” column determine whether packets originating on the firewall itself and destined for the EXTERNAL address are redirected to the internal ADDRESS. If this column contains “yes” or “Yes” (and the ALL INTERFACES COLUMN also contains “Yes” or “yes”) then such packets are redirected; otherwise, such packets are not redirected. This feature requires that you enabled CONFIG_IP_NF_NAT_LOCAL in your kernel. Entries in only arrange for address translation; they do not allow traffic to pass through the firewall in violation of your policies. In the above example, suppose that you wish to run a web server on 10.1.1.2 (a.k.a. 130.252.100.18). You would need the following entry in :\n\nA word of warning is in order here. ISPs typically configure their routers with a long ARP cache timeout. If you move a system from parallel to your firewall to behind your firewall with one-to-one NAT, it will probably be HOURS before that system can communicate with the Internet. If you sniff traffic on the firewall's external interface, you can see incoming traffic for the internal system(s) but the traffic is never sent out the internal interface. You can determine if your ISP's gateway ARP cache is stale using ping and tcpdump. Suppose that we suspect that the gateway router has a stale ARP cache entry for 130.252.100.19. On the firewall, run tcpdump as follows: Now from 10.1.1.3, ping the ISP's gateway (which we will assume is 130.252.100.254): We can now observe the tcpdump output: Notice that the source MAC address in the echo request is different from the destination MAC address in the echo reply!! In this case 0:4:e2:20:20:33 was the MAC of the firewall's eth0 NIC while 0:c0:a8:50:b2:57 was the MAC address of the system on the lower right. In other words, the gateway's ARP cache still associates 130.252.100.19 with the NIC in that system rather than with the firewall's eth0. If you have this problem, there are a couple of things that you can try:\n• None A reading of TCP/IP Illustrated, Vol 1 by Stevens reveals that a “gratuitous” ARP packet should cause the ISP's router to refresh their ARP cache (section 4.7). A gratuitous ARP is simply a host requesting the MAC address for its own IP; in addition to ensuring that the IP address isn't a duplicate... if the host sending the gratuitous ARP has just changed its hardware address..., this packet causes any other host...that has an entry in its cache for the old hardware address to update its ARP cache entry accordingly. Which is, of course, exactly what you want to do when you switch a host from being exposed to the Internet to behind Shorewall using one-to-one NAT (or Proxy ARP for that matter). Happily enough, recent versions of Redhat's iputils package include “arping”, whose “-U” flag does just that: Stevens goes on to mention that not all systems respond correctly to gratuitous ARPs, but googling for “arping -U” seems to support the idea that it works most of the time. To use arping with one-to-one NAT in the above example, you would have to: shorewall clear ip addr add 130.252.100.18 dev eth0 # You need to add the addresses only if Shorewall clear ip addr add 130.252.100.19 dev eth0 # deletes them arping -U -c 10 -I eth0 130.252.100.18 arping -U -c 10 -I eth0 130.252.100.19 ip addr del 130.252.100.18 dev eth0 # You need to delete the addresses only if you added ip addr del 130.252.100.19 dev eth0 # them above shorewall start\n• None You can call your ISP and ask them to purge the stale ARP cache entry but many either can't or won't purge individual entries. There are two distinct versions of arping available:\n• None arping as part of the iputils package by Alexey Kuznetsov (Debian package iputils-arping). You want the second one by Alexey Kuznetsov."
    },
    {
        "link": "https://shorewall.org/Documentation_Index.html",
        "document": "Permission is granted to copy, distribute and/or modify this document under the terms of the GNU Free Documentation License, Version 1.2 or any later version published by the Free Software Foundation; with no Invariant Sections, with no Front-Cover, and with no Back-Cover Texts. A copy of the license is included in the section entitled “GNU Free Documentation License”."
    },
    {
        "link": "https://shorewall.org/4.6/manpages/shorewall-masq.html",
        "document": ""
    },
    {
        "link": "https://shorewall.org/4.2/manpages/shorewall-masq.html",
        "document": ""
    },
    {
        "link": "https://manpages.ubuntu.com/manpages/bionic/man5/shorewall-masq.5.html",
        "document": ""
    },
    {
        "link": "https://shorewall.org/configuration_file_basics.htm",
        "document": "You may use the file to set shell variables that you can then use in the other configuration files. It is suggested that variable names begin with an upper case letter to distinguish them from variables used internally within the Shorewall programs The following variable names must be avoided. Those in bold font must be avoided in all Shorewall versions; those in regular font must be avoided in versions prior to 4.4.8. Any name beginning with SHOREWALL_ or SW_ /etc/shorewall/params NET_IF=eth0 NET_OPTIONS=routefilter,routefilter /etc/shorewall/interfaces record: net $NET_IF $NET_OPTIONS The result will be the same as if the record had been written net eth0 routefilter,routefilter Variables may be used anywhere in the other configuration files. If you use \"$FW\" on the right side of assignments in the file, you must also set the FW variable in that file. Because the file is simply sourced into the shell, you can place arbitrary shell code in the file and it will be executed each time that the file is read. Any code included should follow these guidelines:\n• None The code should not have side effects, especially on other shorewall configuration files.\n• None The code should be safe to execute multiple times without producing different results.\n• None Should not depend on where the code is called from.\n• None Should not assume anything about the state of Shorewall.\n• None The names of any functions or variables declared should begin with an upper case letter.\n• None The file is processed by the compiler at compile-time and by the compiled script at run-time. If you have set EXPORTPARAMS=No in , then the file is only processed by the compiler; it is not run by the compiled script. Beginning with Shorewall 4.4.17, the values of the variables set at compile time are available at run time with EXPORTPRARMS=No.\n• None If you are using Shorewall Lite and if the script needs to set shell variables based on the configuration of the firewall system, you can use this trick: The shorewall-lite call command allows you to call interactively any Shorewall function that you can call in an extension script. Within your configuration files, only the $VAR and ${VAR} forms of variable expansion are supported. You may not use the more exotic forms supported by the shell (${VAR:=val}, ${VAR:-val}, ...) Beginning with Shorewall 4.4.27, you may also use options in shorewall.conf (5) (e.g., $BLACKLIST_LOGLEVEL). When an option is set to 'No' in shorewall.conf, the corresponding shell variable will be empty. Options that were not set in shorewall.conf will expand to their default value. Beginning with Shorewall 4.5.2, configuration files can access variables defined in the shorewallrc file. Beginning with Shorewall 4.5.11, variables can be altered by compiler directives. The can be specified either with or without a leading '$' to allow using both Perl and Shell variable representation. The ${...} form (e.g. ${foo}) is not allowed. The Shorewall compiler performs variable expansion within the expression. So variables are expanded even when they appear in single quotes. If a variable within the expression can contain a non-numeric value, it is a good idea to enclose it in quotes. Otherwise, the Shorewall compiler has to guess whether to enclose the variable's value in quotes or not. Removes the named from the compiler's variable table. Action variables are read-only and cannot be ?SET (although you can change their values using embedded Perl). Beginning with Shorewall 4.5.13, Shorewall Variables may be set. When setting a Shorewall Variable, the must include the leading '@' and the @{...} form is not allowed.\n\nPrior to Shorewall 5.0.14, if you use address variables that refer to an optional interface, the enable command will not change/insert the rules that use the variable. Therefore, to be completely safe, if you use such address variables then you must follow a successful enable command with a reload command. Beginning with Shorewall 5.0.14, if a Shorewall-defined address variable's value has changed since the Netfilter ruleset was instantiated, then a successful enable command will automatically reload the ruleset. Given that shell variables are expanded at compile time, there is no way to cause such variables to be expanded at run time. Prior to Shorewall 4.4.17, this made it difficult (to impossible) to include dynamic IP addresses in a Shorewall-lite configuration. Version 4.4.17 implemented Run-time address variables. In configuration files, these variables are expressed as an apersand ('&') followed by the logical name of an interface defined in shorewall-interfaces (5). Wildcard interfaces (those ending in '+') are not supported and will cause a compilation error. ð0 would represent the primary IP address of eth0. Beginning with Shorewall 4.5.11, you can define your own address variables by using this syntax: where is a valid shell variable name. The generated script will verify that the contains a valid host or network address, either from the environment or from it being assigned in your init extension script, and will raise an error if it does not. In the error case, the state of the firewall will remain unchanged. A second form is also available beginning with Shorewall 4.5.11 Unlike with the first form, this form does not require the variable to be set. If the variable is empty, the generated script will supply the all-zeros address (0.0.0.0 in IPv4 and :: in IPv6). In most cases, the compiler simply omits rules containing matches on the all-zeros address. For a particular address variable, all references must use the same prefix character ('&' or '%'). Otherwise, the following error message is raised: Run-time address variables may be used in the SOURCE and DEST column of the following configuration files: They may also appear in the ORIGDEST column of: They may also be used as the parameter to SNAT() in shorewall-snat(5). For optional interfaces, if the interface is not usable at the time that the firewall starts, one of two approaches are taken, depending on the context:\n• None the all-zero address will be used (0.0.0.0 in IPv4 and :: in IPv6), resulting in no packets matching the rule (or all packets if used with exclusion).\n• None the entire rule is omitted from the ruleset. Beginning with Shorewall 4.5.1, Run-time Gateway Variables in the form of a percent sign ('%') followed by a logical interface name are also supported. These are expanded at run-time to the gateway through the named interface. For optional interfaces, if the interface is not usable at the time that the firewall starts, the nil address will be used (0.0.0.0 in IPv4 and :: in IPv6), resulting in no packets matching the rule. Run-time gateway variables may be used in the SOURCE and DEST columns of the following configuration files:\n• None shorewall-nat(5) (As a qualifier to the INTERFACE). %eth0 would represent the IP address of the gateway out of eth0. If there is no gateway out of the named interface, rules containing the intefaces's run-time gateway variable are omitted.\n\nShorewall Variables were introduced in Shorewall 4.5.11. To insure uniqueness, these variables start with the character @; the name of the variable must be enclosed in {...} when the following character is alphanumeric or is an underscore (\"_\"). With the exception of @0 (or it's alias @chain), Shorewall variables may only be used within an action body. Prior to Shorewall 4.5.13, Shorewall variables are read-only. Beginning with Shorewall 4.5.13, their values may be altered using the ?SET directive. Expands to the name of the current chain. Unlike $0, @0 has all non-alphanumeric characters except underscore removed. Also unlike $0, @0 may be used in SWITCH columns in configuration files. These are synonyms for the Action parameter variables $1, $2, etc. Expands to the log level specified when the action was invoked. Expands to the log tag specified when the action was invoked. Expands to the name of the action being compiled. Added in Shorewall 4.5.13. When a non-inlined action is entered, this variable is set to the empty value. When an inline action is entered, the variable's value is unchanged. Added in Shorewall 4.5.13. Within an action, expands to the name of the chain that invoked the action. Beginning with Shorewall 4.5.13, the values of @chain and @disposition are used to generated the --log-prefix in logging rules. When either is empty, the historical value is used to generate the --log-prefix. Within an action body, if a parameter is omitted in a DEFAULTS statement, then the value of the corresponding action and Shorewall variables is '-', while if the parameter is specified as '-' in the parameter list, the value of the action/Shorewall variable is '', if it is expanded before the DEFAULTS statement. Additionally, when an expression is evaluated, the value 0 evaluates as false, so '?IF @n' and '?IF $n' fail if the nth parameter is passed with value zero. To make testing of the presense of parameters more efficient and uniform, an new function has been added in Shorewall 5.0.7 for use in ?IF and ?ELSEIF: where <variable> is an action or Shorewall variable. 'passed(@n)' and 'passed($n)' evaluate to true if the nth parameter is not empty and its contents are other than '-'. If '!' is present, the result is inverted. In this simple form, the expression is evaluated by the compiler without having to invoke the (expensive) Perl exec() function. The 'passed' function may also be used in more complex expressions, but exec() will be invoked to evaluate those expressions.\n\nBeginning with Shorewall 4.5.2, lines in configuration files may be conditionally included or omitted based on the setting of Shell variables. ?IF <lines to be included if $variable is non-empty and non-zero> ?ELSE <lines to be omitted if $variable is non-empty and non-zero> ?ENDIF The compiler predefines two special s that may only be used in ?IF lines: True if this is an IPv4 compilation True if this is an IPv6 compilation. Unless is one of these pre-defined ones, it is searched for in the following places in the order listed.\n• None options set in the file when Shorewall Core was installed. Beginning with Shorewall 4.5.11, the compiler's environmental variables are searched last rather than first. If the is still not found:\n• None if it begins with '__', then those leading characters are stripped off.\n• None the variable is then searched for in the defined capabilities. The current set of capabilities may be obtained by the command shorewall show capabilities (the capability names are in parentheses). If it is not found in any of those places, the is assumed to have a value of 0 (false) in Shorewall versions prior to 4.5.11. In 4.5.11 and later, it is assumed to have the value '' (an empty string, which also evaluates to false). The setting in may be overridden at runtime, provided the setting in is done like this: Either of those will set variable to 0 if it is not set to a non-empty value in the environment. The setting can be overridden at runtime: =1 shorewall restart -c # use -c to force recompilation if AUTOMAKE=Yes in /etc/shorewall/shorewall.conf The ?ELSE may be omitted if there are no lines to be omitted. The test may also be inverted using '!': ?IF ! <lines to be omitted if $variable is non-empty and non-zero> ?ELSE <lines to be included if $variable is non-empty and non-zero> ?ENDIF Conditional entries may be nested but the number of ?IFs must match the number of ?ENDs in any give file. INCLUDE directives are ignored in omitted lines. ?IF <lines to be included if $variable1 is non-empty and non-zero> ?IF $variable2 <lines to be included if $variable1 and $variable2 are non-empty and non-zero> ?ELSE <lines to be omitted if $variable1 is non-empty and non-zero and if $variable2 is empty or zero> ?ENDIF <lines to be included if $variable1 is non-empty and non-zero> ?ELSE <lines to be omitted if $variable is non-empty and non-zero> ?ENDIF Beginning with Shorewall 4.5.6, rather than a simple variable in ?IF directives, Perl-compatible expressions are allowed (after the Shorewall compiler expands all variables, the resulting expression is then evaluated by Perl). Variables in the expressions are as described above. ?IF <lines to be included if expression-1 evaluates to true (non-empty and non-zero) ?ELSIF <lines to be included if expression-1 evaluates to false (zero or empty) and expression-2 evaluates to true ?ELSIF <lines to be included if expression-1 and expression-2 both evalute to false and expression-3 evalutes to true ?ELSE <lines to be included if all three expressions evaluate to false. ?ENDIF Beginning in Shorewall 5.0.7, an error can be raised using the ?ERROR directive: Variables in the message are evaluated and the result appears in a standard Shorewall ERROR: message. Example from the 5.0.7 action.GlusterFS: ?if @1 !~ /^\\d+/ || ! @1 || @1 > 1024 ?error Invalid value for Bricks (@1) ?elsif @2 !~ /^[01]$/ ?error Invalid value for IB (@2) ?endif The above code insures that the first action paramater is a non-zero number <= 1024 and that the second parameter is either 0 or 1. If 2000 is passed for the first parameter, the following error message is generated: ERROR: Invalid value for Bricks (2000) /usr/share/shorewall/action.GlusterFS (line 15) from /etc/shorewall/rules (line 45) In Shorewall 5.0.8, ?WARNING and ?INFO directives were added. ?WARNING message produces a standard Shorewall WARNING: message, while ?INFO produces a similar message which is prefaced by INFO: rather than WARNING:. Both write the message to STDERR. The message is also written to the STARTUP_LOG, if any, provided that the command is start, try, restart, reload, refresh, or one of the safe-* commands. See the VERBOSE_MESSAGES option in shorewall.conf(5) for additional information. In Shorewall 5.1.4, the behavior of ?ERROR, ?WARNING and ?INFO was changed when they appear in an action file. Rather than reporting the action filename and line number, the generated message reports where the action was invoked. For example, the GlusterFS message above was changed to: ERROR: Invalid value (2000) for the GlusterFS Bricks argument /etc/shorewall/rules (line 45)\n\nI personally recommend strongly against using DNS names in Shorewall configuration files. If you use DNS names and you are called out of bed at 2:00AM because Shorewall won't start as a result of DNS problems then don't say that you were not forewarned. Host addresses in Shorewall configuration files may be specified as either IP addresses or DNS Names. DNS names in iptables rules aren't nearly as useful as they first appear. When a DNS name appears in a rule, the iptables utility resolves the name to one or more IP addresses and inserts those addresses into the rule. So changes in the DNS->IP address relationship that occur after the firewall has started have absolutely no effect on the firewall's rule set. For some sites, using DNS names is very risky. Here's an example: teastep@ursa:~$ dig pop.gmail.com ; <<>> DiG 9.4.2-P1 <<>> pop.gmail.com ;; global options: printcmd ;; Got answer: ;; ->>HEADER<<- opcode: QUERY, status: NOERROR, id: 1774 ;; flags: qr rd ra; QUERY: 1, ANSWER: 3, AUTHORITY: 7, ADDITIONAL: 0 ;; QUESTION SECTION: ;pop.gmail.com. IN A ;; ANSWER SECTION: pop.gmail.com. IN CNAME gmail-pop.l.google.com. gmail-pop.l.google.com. IN A 209.85.201.109 gmail-pop.l.google.com. IN A 209.85.201.111 Note that the TTL is 300 -- 300 seconds is only 5 minutes. So five minutes later, the answer may change! So this rule may work for five minutes then suddently stop working: There are two options in shorewall[6].conf(5) that affect the use of DNS names in Shorewall[6] config files:\n• None DEFER_DNS_RESOLUTION - When set to No, DNS names are resolved at compile time; when set to Yes, DNS Names are resolved at runtime.\n• None AUTOMAKE - When set to Yes, start, restart and reload only result in compilation if one of the files on the CONFIG_PATH has changed since the the last compilation. So by setting AUTOMAKE=Yes, and DEFER_DNS_RESOLUTION=No, compilation will only take place at boot time if a change had been make to the config but no restart or reload had taken place. This is clearly spelled out in the shorewall.conf manpage. So with these settings, so long as a 'reload' or 'restart' takes place after the Shorewall configuration is changes, there should be no DNS-related problems at boot time. When DEFER_DNS_RESOLUTION=No and AUTOMAKE=Yes and a DNS change makes it necessary to recompile an existing firewall script, the option must be used with the reload or restart command to force recompilation. If your firewall rules include DNS names then, even if DEFER_DNS_RESOLUTION=No and AUTOMAKE=Yes:\n• None If your is wrong then your firewall may not start.\n• None If your is wrong then your firewall may not start.\n• None If your Name Server(s) is(are) down then your firewall may not start.\n• None If your startup scripts try to start your firewall before starting your DNS server then your firewall may not start.\n• None Factors totally outside your control (your ISP's router is down for example), can prevent your firewall from starting.\n• None You must bring up your network interfaces prior to starting your firewall, or the firewall may not start. Each DNS name must be fully qualified and include a minimum of two periods (although one may be trailing). This restriction is imposed by Shorewall to insure backward compatibility with existing configuration files. \n\n \n\n DNS names may not be used as:\n• None In the ADDRESS column of an entry in /etc/shorewall/masq. These restrictions are imposed by Netfilter and not by Shorewall."
    },
    {
        "link": "https://shorewall.org/manpages6/shorewall6-masq.html",
        "document": ""
    }
]