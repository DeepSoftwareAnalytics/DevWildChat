[
    {
        "link": "https://stackoverflow.com/questions/56427357/java-bfs-what-should-i-change-if-i-wanted-to-move-diagonally",
        "document": "I'm looking at this code and I don't really know how I can implement diagonal moves. I've tried changing the possible movements, but I don't know how should I do that. The expected result is that the code looks for the shortest path moving diagonally when possible to reduce the total cost. Sorry for the length of the code and thank you."
    },
    {
        "link": "https://stackoverflow.com/questions/37784324/shortest-path-in-a-grid",
        "document": "1.Enqueue the source vertex and mark it visited.\n\n2.While the Q is not empty repeat 3 and 4.\n\n3. Perform deque and the for the dequed vertex x, do\n\n4. For all adjacent vertices of x, that are not visited and mark them visited and enqueue them to the Q.\n\nSo thats the basic algorithm, if we go step by step its very easy to apply these steps to grid,the only thing that we should be careful is for a cell in a grid there are 8 neighbours possible, and we must check the boundary conditions before traversing the neighbours, to avoid array index out of bounds.\n\nSay we are at position and we want to reach . We follow the similar 4 steps but with some modification as follows:\n\n1.Make a Q of 2-d points,(You can do that easily in languages like Java, by making a class of 2-d points and then Q of objects of that class)\n\n2.Make a 2-d array of size of grid of type boolean, initialized to false.\n\n3.Make a 2-d array of size of grid of type integer, that will be used for the distance.\n\nLet size of grid be\n\nNow the pseudocode is as follows:"
    },
    {
        "link": "https://geeksforgeeks.org/shortest-path-in-grid-with-obstacles",
        "document": "Given a grid of n rows and m columns. Currently, you are at point (0, 0) and must reach point (n-1, m-1). If any cell contains 0, it is a free cell, if it contains 1, there is an obstacle and you can’t pass through the cell, and if it contains 2, that means it is free and if you step into this cell, you can pass through any adjacent cell of it that contains obstacles. In one step you can go one unit in any four directions (Inside the grid), the task is to find the minimum number of steps to reach the destination if it is impossible return -1.\n\nFollow the steps to solve the problem:\n• None First, check whether the starting point (0, 0) (n-1, m-1) is blocked (value 1). If either of them is blocked, it means that not able to reach the destination.\n• None , to represent the four possible directions (up, right, down, and left).\n• None to perform BFS traversal on the grid.\n• None to keep track of the minimum number of steps required to reach. initialize all values to -1 to indicate that they are not yet visited.\n• None During BFS traversal, process each cell in the queue one by one. For each cell, explore its four neighboring cells using\n• None If the neighboring cell is within the grid bounds, and it is either a free cell (value 0) or a special cell (value 2), proceed to process it.\n• None If the neighboring cell is a special cell (value 2), update the grid to mark the adjacent blocked cells as free (value 0). This allows us to bypass obstacles by stepping into the special cell.\n• None Then continue the BFS traversal from the neighboring cell and keep updating the minimum steps needed to reach each cell in the\n• None Finally, look at the value in the “dis” vector for the bottom-right cell (n-1, m-1). This is the shortest way to find it. If it is still -1, it means there is no way at all.\n\nBelow is the implementation for the above approach:"
    },
    {
        "link": "https://algo.monster/liteproblems/1091",
        "document": "The problem presents us with an binary matrix , where the objective is to find the shortest path from the top-left corner to the bottom-right corner . The path is considered clear if it consists only of 's and all adjacent cells in the path (including diagonally adjacent cells) are connected, meaning every step in the path can move horizontally, vertically, or diagonally to the next cell as long as it remains within the bounds of the grid and is a . The length of the path is defined by the number of cells that the path visits. If no such path exists, the function should return . Here's the algorithm analysis for LeetCode 1091. Shortest Path in Binary Matrix using the algorithm flowchart. Please follow the step-by-step decision path for understanding the choice of algorithm: Let's begin with the algorithm flowchart which can be found here.\n• Yes: The binary matrix can be seen as a graph where each cell is a node connected to its adjacent cells (including diagonals if they are not blocked).\n• No: The binary matrix representation includes multiple possible paths from the start to the end, and it can have cycles formed by multiple access paths to various cells. Is the problem related to directed acyclic graphs (DAGs)?\n• No: The problem does not specifically pertain to directed acyclic graphs, as connections between nodes (cells) are not directional dependent only progressing from one specific point to another. Is the problem related to shortest paths?\n• Yes: The objective is to find the shortest path from the top-left corner to the bottom-right corner, if it exists.\n• No: Each step from one cell to a neighboring cell that’s not blocked represents an equal cost or distance, conventionally treated as unweighted where each move has a weight of 1. Conclusion: The flowchart suggests using BFS for this unweighted shortest path problem in a grid. Breadth-First Search (BFS) is ideal for unweighted shortest path issues as it explores all possibilities level by level, ensuring that once it reaches the target, the path used is the shortest possible in terms of the number of edges traversed. To solve this problem, we can employ a Breadth-First Search (BFS) approach. BFS is ideal for finding the shortest path in an unweighted grid because it explores all neighboring cells at the current depth level before moving on to cells at the next level of depth. Here’s how we get there:\n• Starting Point: First, we check if the starting cell is a (which would block the path). If it is, we immediately return since we cannot start the path. If it's a , we can proceed by marking it as visited ( in this implementation) to prevent backtracking and initialize our queue with this position.\n• The Queue: We use a queue to manage the cells to visit next. It initially contains just the starting cell.\n• Visiting Cells: In each step of the BFS, we pop a cell from the queue, process it, and add all its unvisited -neighbors to the queue.\n• Movement: We move to adjacent cells in all 8 possible directions. Since the problem specifies 8-directional connectivity, we have to check all cells around the current cell (horizontally, vertically, and diagonally).\n• Goal Check: Each time we pop a cell from the queue, we check if it's the bottom-right cell . If so, we have reached the destination, and we can return the current path length.\n• Incrementing Path Length: Every time we've checked all neighbors for the current level (cells with the same path length), we increment the path length before moving on to the next level.\n• Base Case for No Path: If we exhaust the queue without reaching the destination, we return , indicating there is no possible path. The BFS guarantees that the first time we reach the bottom-right cell, that path is the shortest because we have explored in a way that checks all possible paths of incrementally longer lengths. The grid modification ( ) acts as a visited marker to avoid revisiting cells and potentially creating loops.\n\nThe solution approach employs Breadth-First Search (BFS) to systematically search for the shortest path from the start to the end of the binary matrix. The BFS algorithm is ideal for such a problem since it exhaustively explores all neighbors of a given cell before moving further away, thereby ensuring the shortest path is found if it exists. Given below is a step-by-step walkthrough of the algorithm:\n• Validate Start: Before starting the search, we check if the starting cell (top-left corner) is . If it's (blocking the path), we return .\n• Initial Setup: We initialise our queue, , with a tuple representing the starting cell coordinates and set the value of the starting cell to to mark it as visited. The variable is initialized to , indicating the current path length we're at (starting with the first cell).\n• Queue Processing: We create a loop that runs as long as the queue is not empty. This queue will store the cells to explore at each level of depth.\n• Current Level Exploration: Inside the loop, we have an inner loop . This ensures that we only process cells that are at the current level of depth, thus maintaining the BFS property.\n• Neighbor Exploration: We pop the front cell from the queue and check all possible 8 directions around this cell. For each of those directions, we check whether the cell is within the grid bounds and whether it is unvisited ( ). If these conditions are met, we mark the cell as visited ( ) to prevent revisiting it and add its coordinates to the queue for further exploration.\n• Goal Condition: If we encounter the bottom-right cell during exploration, we immediately return the current path length ( ), as this is the shortest path due to the BFS.\n• Incrementing Path Length: Once we have explored all neighbors of the current depth level, we increment by 1 to account for the next level that we'll start exploring in the next iteration of the outer loop.\n• Returning -1: If the loop terminates without finding the bottom-right cell, we return , signifying it doesn't have an accessible path. The choice of a queue in BFS is a fundamental part of the algorithm. It ensures that nodes are explored in the order of their proximity to the start node (level by level, not depth by depth like DFS), which is why the path length is incremented once per level, not per node. By modifying the grid in-place, we can keep track of visited nodes without the need for an additional visited matrix, which also helps in reducing space complexity. Overall, the algorithm has a time complexity of if all cells are visited in the worst case and a space complexity of as well, taken up by the queue in the worst case where all cells are added to it.\n\nLet's take a small binary matrix as an example to illustrate the solution approach: We want to find the shortest path from the top-left corner to the bottom-right corner using the BFS approach. Here's a step-by-step walkthrough of what the algorithm would do:\n• Validate Start: We check if the starting cell is . Since it is, we can proceed.\n• Initial Setup: We initialize our queue with , the starting cell coordinates and the initial path length. The cell is marked as visited by setting it to .\n• Queue Processing: We begin the loop since our queue is not empty.\n• Current Level Exploration: Our initially contains one element, so we will explore this level with just one loop iteration.\n• Neighbor Exploration: We pop from the queue. We explore all possible neighbors:\n• The right cell is within bounds and is . We mark it visited, and add it to the queue.\n• The bottom cell is within bounds and is . We mark it visited, and add it to the queue.\n• The diagonal cell is within bounds but is , so we don't add it to the queue. Our queue now looks like this (with corresponding path lengths): .\n• Incrementing Path Length: At this point we complete the first level, so if we didn't find the end cell, we would proceed to the next level and increment . Since we found multiple neighbors, would be .\n• Processing Next Level: We continue with our BFS loop for the next level.\n• We first process . Its right neighbor is outside the grid, bottom neighbor is blocked, and the diagonal bottom-right neighbor is in bounds and . We add to the queue and mark it as visited.\n• Next, we process . Its neighbors to the right and bottom are blocked, but the diagonal is in bounds and . We mark it and add it to the queue. Our queue and corresponding path lengths now look like this: .\n• Reaching Goal: Continuing the loop, we then process ; its diagonal neighbor is the end cell , and since it is , it means we have reached our destination. We return the current path length , which is now . Since we've reached the goal on this level, we don't need to process any further levels. The shortest path length from the top-left corner to the bottom-right corner is . If at any point we had exhausted the queue without reaching the bottom-right corner, we would return . In this example, that is not the case, as we have successfully found a path.\n\n# Check if the starting cell is blocked # Initialize the size of the grid # Set starting point as visited by marking it with a 1 (path length from the origin) # Process nodes until the queue is empty # Loop through all nodes at the current level of breadth # Boundary check and cell is not blocked # Mark cell as visited and add its coordinates to the queue queue.append((x, y)) # Increment path length at the conclusion of the level # If we exit the loop without returning, no path has been found // Method to find the shortest path in a binary matrix from top-left to bottom-right // If the starting cell is blocked, return -1 } // Get the size of the grid // Mark the starting cell as visited by setting it to 1 // Initialize a queue to hold the cells to be visited // Variable to keep track of the number of steps taken // Poll the current cell from the queue // If we have reached the bottom-right corner, return the number of steps } // Explore all 8 directions from the current cell // Check for valid cell coordinates and if the cell is not blocked // Add the cell to the queue to explore its neighbors later } } } } } // If the goal was not reached, return -1 } } // If the starting cell is blocked, there is no path. } // Mark the starting cell as visited by setting it to 1 // Define a queue to store the cells to visit // Start with the top-left corner of the grid // Loop until there are no more cells to visit // Remove the current cell from the queue // If the current cell is the bottom-right corner, the path is found } // Iterate through all the neighbors of the current cell // Check if the neighbor is within the grid and is not blocked // Add the neighbor to the queue } } } } } // If there is no path, return -1 } }; // Early exit if the starting cell (0, 0) is blocked. } // Queue for the BFS, starting with position (0, 0). // BFS loop. 'steps' counts the number of steps taken. // 'nextQueue' will store the positions to visit in the next loop iteration. // Process each cell in the current queue. // Check if the bottom-right corner is reached. } // Explore all 8 directions around the current cell. // Check if the new position is valid and not blocked. // Mark the cell as visited by setting it to 1. // Add the position to the 'nextQueue'. nextQueue.push([x, y]); } } } } // Update the queue for the next iteration of BFS. queue = nextQueue; } // If the bottom-right corner was never reached, return -1. }\n\nDiscover Your Strengths and Weaknesses: Take Our 2-Minute Quiz to Tailor Your Study Plan:\n\nWant a Structured Path to Master System Design Too? Don’t Miss This!"
    },
    {
        "link": "https://geeksforgeeks.org/shortest-distance-two-cells-matrix-grid",
        "document": "Given a matrix of N*M order. Find the shortest distance from a source cell to a destination cell, traversing through limited cells only. Also you can move only up, down, left and right. If found output the distance else -1. \n\ns represents ‘source’ \n\nd represents ‘destination’ \n\n* represents cell you can travel \n\n0 represents cell you can not travel \n\nThis problem is meant for single source and destination.\n\nExamples: \n\n\n\nThe idea is to BFS (breadth first search) on matrix cells. Note that we can always use BFS to find shortest path if graph is unweighted.\n• Store each cell as a node with their row, column values and distance from source cell.\n• Make a visited array with all having “false” values except ‘0’cells which are assigned “true” values as they can not be traversed.\n• Keep updating distance from source value in each move.\n• Return distance when destination is met, else return -1 (no path exists in between source and destination)."
    },
    {
        "link": "https://stackoverflow.com/questions/8922060/how-to-trace-the-path-in-a-breadth-first-search",
        "document": "I liked qiao's first answer very much! The only thing missing here is to mark the vertexes as visited.\n\n\n\n Why we need to do it?\n\n Lets imagine that there is another node number 13 connected from node 11. Now our goal is to find node 13.\n\n After a little bit of a run the queue will look like this:\n\n\n\nNote that there are TWO paths with node number 10 at the end.\n\n Which means that the paths from node number 10 will be checked twice. In this case it doesn't look so bad because node number 10 doesn't have any children.. But it could be really bad (even here we will check that node twice for no reason..)\n\n Node number 13 isn't in those paths so the program won't return before reaching to the second path with node number 10 at the end..And we will recheck it..\n\n\n\n\n\nAll we are missing is a set to mark the visited nodes and not to check them again..\n\n This is qiao's code after the modification:\n\n\n\nThe output of the program will be:"
    },
    {
        "link": "https://geeksforgeeks.org/breadth-first-search-or-bfs-for-a-graph",
        "document": "Breadth First Search or BFS for a Graph\n\nGiven a undirected graph represented by an adjacency list , where each represents the list of vertices connected to vertex . Perform a Breadth First Traversal (BFS) starting from vertex , visiting vertices from left to right according to the adjacency list, and return a list containing the BFS traversal of the graph.\n\nInput: adj = [[2,3,1], [0], [0,4], [0], [2]]\n\n Output: [0, 2, 3, 1, 4]\n\nExplanation: Starting from 0, the BFS traversal will follow these steps: \n\nVisit 0 → Output: 0 \n\nVisit 2 (first neighbor of 0) → Output: 0, 2 \n\nVisit 3 (next neighbor of 0) → Output: 0, 2, 3 \n\nVisit 1 (next neighbor of 0) → Output: 0, 2, 3, \n\nVisit 4 (neighbor of 2) → Final Output: 0, 2, 3, 1, 4 Input: adj = [[1, 2], [0, 2], [0, 1, 3, 4], [2], [2]]\n\n Output: [0, 1, 2, 3, 4]\n\nExplanation: Starting from 0, the BFS traversal proceeds as follows: \n\nVisit 0 → Output: 0 \n\nVisit 1 (the first neighbor of 0) → Output: 0, 1 \n\nVisit 2 (the next neighbor of 0) → Output: 0, 1, 2 \n\nVisit 3 (the first neighbor of 2 that hasn’t been visited yet) → Output: 0, 1, 2, 3 \n\nVisit 4 (the next neighbor of 2) → Final Output: 0, 1, 2, 3, 4 Input: adj = [[1], [0, 2, 3], [1], [1, 4], [3]]\n\nOutput: [0, 1, 2, 3, 4]\n\nExplanation: Starting the BFS from vertex 0:\n\nVisit vertex 0 → Output: [0]\n\nVisit vertex 1 (first neighbor of 0) → Output: [0, 1]\n\nVisit vertex 2 (first unvisited neighbor of 1) → Output: [0, 1, 2]\n\nVisit vertex 3 (next neighbor of 1) → Output: [0, 1, 2, 3]\n\nVisit vertex 4 (neighbor of 3) → Final Output: [0, 1, 2, 3, 4]\n\nWhat is Breadth First Search?\n\nFollow the below given approach:\n• Initialization: Enqueue the given source vertex into a queue and mark it as visited.\n• Exploration: While the queue is not empty:\n• None Dequeue a node from the queue and visit it (e.g., print its value).\n• None For each unvisited neighbor of the dequeued node:\n• None Enqueue the neighbor into the queue.\n• Termination: Repeat step 2 until the queue is empty.\n\nThis algorithm ensures that all nodes in the graph are visited in a breadth-first manner, starting from the starting node.\n\n// create an array to store the traversal // Initially mark all the vertices as not visited // Mark source node as visited and enqueue it // Dequeue a vertex from queue and store it // Get all adjacent vertices of the dequeued // vertex curr If an adjacent has not been // visited, mark it visited and enqueue it // Function to find BFS of Graph from given source s // create an array to store the traversal // Initially mark all the vertices as not visited // Mark source node as visited and enqueue it // Dequeue a vertex from queue and store it // Get all adjacent vertices of the dequeued // vertex curr If an adjacent has not been // visited, mark it visited and enqueue it # Function to find BFS of Graph from given source s # create an array to store the traversal # Initially mark all the vertices as not visited # Mark source node as visited and enqueue it # Dequeue a vertex from queue and store it # Get all adjacent vertices of the dequeued # vertex curr If an adjacent has not been # visited, mark it visited and enqueue it // Function to find BFS of Graph from given source s // create an array to store the traversal // Initially mark all the vertices as not visited // Mark source node as visited and enqueue it // Dequeue a vertex from queue and store it // Get all adjacent vertices of the dequeued // vertex curr If an adjacent has not been // visited, mark it visited and enqueue it // Function to find BFS of Graph from given source s // create an array to store the traversal // Initially mark all the vertices as not visited // Mark source node as visited and enqueue it // Dequeue a vertex from queue and store it // Get all adjacent vertices of the dequeued // vertex curr If an adjacent has not been // visited, mark it visited and enqueue it\n\nThe above implementation takes a source as an input and prints only those vertices that are reachable from the source and would not print all vertices in case of disconnected graph. Let us see the algorithm that prints all vertices without any source and the graph maybe disconnected. The algorithm is simple, instead of calling BFS for a single vertex, we call the above implemented BFS for all not yet visited vertices one by one.\n\n// Mark source node as visited and enqueue it // Get all adjacent vertices of the dequeued // vertex curr If an adjacent has not been // visited, mark it visited and enqueue it // Perform BFS for the entire graph which maybe // create an array to store the traversal // Initially mark all the vertices as not visited // Mark source node as visited and enqueue it // Get all adjacent vertices of the dequeued // vertex curr If an adjacent has not been // visited, mark it visited and enqueue it // Perform BFS for the entire graph which maybe // create an array to store the traversal // Initially mark all the vertices as not visited # Mark source node as visited and enqueue it # Get all adjacent vertices of the dequeued # vertex curr If an adjacent has not been # visited, mark it visited and enqueue it # Perform BFS for the entire graph which maybe # create an array to store the traversal # Initially mark all the vertices as not visited // Mark source node as visited and enqueue it // Get all adjacent vertices of the dequeued // vertex curr If an adjacent has not been // visited, mark it visited and enqueue it // Perform BFS for the entire graph which maybe // create an array to store the traversal // Initially mark all the vertices as not visited // Mark source node as visited and enqueue it // Get all adjacent vertices of the dequeued // vertex curr If an adjacent has not been // visited, mark it visited and enqueue it // Perform BFS for the entire graph which maybe // create an array to store the traversal // Initially mark all the vertices as not visited\n\nTime Complexity: O(V + E), BFS explores all the vertices and edges in the graph. In the worst case, it visits every vertex and edge once. Therefore, the time complexity of BFS is O(V + E), where V and E are the number of vertices and edges in the given graph. Auxiliary Space: O(V), BFS uses a queue to keep track of the vertices that need to be visited. In the worst case, the queue can contain all the vertices in the graph. Therefore, the space complexity of BFS is O(V).\n\nBFS has various applications in graph theory and computer science, including:\n• Shortest Path Finding: BFS can be used to find the shortest path between two nodes in an unweighted graph. By keeping track of the parent of each node during the traversal, the shortest path can be reconstructed.\n• Cycle Detection: BFS can be used to detect cycles in a graph. If a node is visited twice during the traversal, it indicates the presence of a cycle.\n• Connected Components: BFS can be used to identify connected components in a graph. Each connected component is a set of nodes that can be reached from each other.\n• Topological Sorting: BFS can be used to perform topological sorting on a directed acyclic graph (DAG). Topological sorting arranges the nodes in a linear order such that for any edge (u, v), u appears before v in the order.\n• Level Order Traversal of Binary Trees: BFS can be used to perform a level order traversal of a binary tree. This traversal visits all nodes at the same level before moving to the next level.\n• Network Routing: BFS can be used to find the shortest path between two nodes in a network, making it useful for routing data packets in network protocols.\n• None Find the level of a given node in an Undirected Graph\n• None Minimize maximum adjacent difference in a path from top-left to bottom-right\n• None Minimum jump to the same value or adjacent to reach the end of an Array\n• None Maximum coin in minimum time by skipping K obstacles along the path in Matrix\n• None Check if all nodes of the Undirected Graph can be visited from the given Node\n• None Minimum time to visit all nodes of a given Graph at least once\n• None Minimize moves to the next greater element to reach the end of the Array\n• None Minimum time required to infect all the nodes of the Binary tree\n• None Check if destination of given Matrix is reachable with required values of cells\n\nFAQs on Breadth First Search (BFS) for a Graph\n\nQuestion 1: What is BFS and how does it work?\n\nQuestion 2: What are the applications of BFS?\n\nQuestion 3: What is the time complexity of BFS?\n\nQuestion 4: What is the space complexity of BFS?\n\nQuestion 5: What are the advantages of using BFS?\n• None Time and Space Complexity of Breadth First Search (BFS)"
    },
    {
        "link": "https://geeksforgeeks.org/print-paths-given-source-destination-using-bfs",
        "document": "Print all paths from a given source to a destination using BFS\n\nGiven a directed graph, a source vertex ‘src’ and a destination vertex ‘dst’, print all paths from given ‘src’ to ‘dst’. Please note that in the cases, we have cycles in the graph, we need not to consider paths have cycles as in case of cycles, there can by infinitely many by doing multiple iterations of a cycle. For simplicity, you may assume that there are no cycles in the input graph.\n\nConsider the following directed graph. Let the src be 2 and dst be 3. There are 3 different paths from 2 to 3.\n\nWe have already discussed Print all paths from a given source to a destination using DFS.\n\ncreate a queue which will store path(s) of type vector \n\n initialise the queue with first path starting from src \n\n\n\n Now run a loop till queue is not empty \n\n get the frontmost path from queue \n\n check if the lastnode of this path is destination \n\n if true then print the path \n\n run a loop for all the vertices connected to the \n\n \n\n if the vertex is not visited in current path \n\n a) create a new path from earlier path and \n\n\n\n b) insert this new path to queue\n\n// C++ program to print all paths of source to // vertex is already present in path // if last vertex is the desired destination // traverse to all the nodes connected to // current vertex and push new path to queue // Java program to print all paths of source to // vertex is already present in path // If last vertex is the desired destination // Traverse to all the nodes connected to // current vertex and push new path to queue // This code is contributed by rajatsri94 # Python3 program to print all paths of # source to destination in given graph # vertex is already present in path # If last vertex is the desired destination # Traverse to all the nodes connected to # current vertex and push new path to queue # This code is contributed by sanjeev2552 // C# program to print all paths of source to // vertex is already present in path // If last vertex is the desired destination // Traverse to all the nodes connected to // current vertex and push new path to queue // This code is contributed by shikhasingrajput // JavaScript code to print all paths of // source to destination in given graph // vertex is already present in path // If last vertex is the desired destination // Traverse to all the nodes connected to // current vertex and push new path to queue\n\nTime Complexity: O(VV), the time complexity is exponential. From each vertex there are v vertices that can be visited from current vertex.\n\nAuxiliary space: O(VV), as there can be VV paths possible in the worst case."
    },
    {
        "link": "https://stackoverflow.com/questions/58690928/i-think-my-bfs-adds-all-valid-coordinates-to-list-not-just-shortest-path",
        "document": "So I'm working on a BFS algorithm to find the shortest path in a 2d binary maze and print the path in the form of coordinates. The code is running, but there must be some mistakes somewhere.\n\nBasically the maze coordinates have either true or false values (where walls are false). The coordinates in the maze are given in the form of a custom class called .\n\nMy goal is to find the path, add the points in a list (in form of Pos) and return the array list\n\nHere's what I got so far:\n\nThe code is run in another class that reads the maze from an file and then runs my algorithm on said maze. If an is returned it will print each element. If not it just prints \"Not solvable\". Lets say I have the file test.in and run :\n\nI want the output to be:\n\nBut this is what I'm getting:\n\nBy looking at the output, it seems like the algorithm finds the shortest path, but prints each coordinate twice. Additionally, x and y values flip and the start coordinate is printed 3 times. Any help with troubleshooting this is greatly appreciated."
    },
    {
        "link": "https://gamedev.stackexchange.com/questions/197165/java-simple-2d-grid-pathfinding",
        "document": "Stack Exchange network consists of 183 Q&A communities including Stack Overflow, the largest, most trusted online community for developers to learn, share their knowledge, and build their careers."
    },
    {
        "link": "https://docs.oracle.com/javase/8/docs/api/java/util/ArrayDeque.html",
        "document": "Retrieves, but does not remove, the head of the queue represented by this deque, or returns if this deque is empty.\n\nRetrieves, but does not remove, the first element of this deque, or returns if this deque is empty.\n\nRetrieves, but does not remove, the last element of this deque, or returns if this deque is empty.\n\nRetrieves and removes the head of the queue represented by this deque (in other words, the first element of this deque), or returns if this deque is empty.\n\nRemoves the first occurrence of the specified element in this deque (when traversing the deque from head to tail).\n\nRemoves the last occurrence of the specified element in this deque (when traversing the deque from head to tail).\n\nReturns an array containing all of the elements in this deque in proper sequence (from first to last element).\n\nReturns an array containing all of the elements in this deque in proper sequence (from first to last element); the runtime type of the returned array is that of the specified array."
    },
    {
        "link": "https://geeksforgeeks.org/arraydeque-in-java",
        "document": "In Java, the ArrayDeque is a resizable array implementation of the Deque interface, which stands for double-ended queue. It allows elements to be added or removed from both ends efficiently. It can be used as a stack (LIFO) or a queue (FIFO).\n• None It generally provides faster operations than LinkedList because it does not have the overhead of node management.\n• None Operations like addFirst(), addLast(), removeFirst(), removeLast() are all done in constant time O(1).\n• None The ArrayDeque class implements these two interfaces\n\nExample: This example demonstrates how to use an ArrayDeque to add elements to both ends of the deque and then remove them from both ends using addFirst(), addLast(), removeFirst(), and removeLast() methods.\n\nThe below image demonstrates the inheritance hierarchy of ArrayDeque, how it implements the Deque interface, which extends the Queue , and how both are part of the Collection interface.\n\nIn Java, the declaration of ArrayDeque can be done as:\n\nNote: Here, “Type” is the type of the element the deque will hold (e.g. Integer, String).\n\nExample 1: This example demonstrates how to create an empty ArrayDeque, add elements to it, and print the deque’s contents.\n\nExample 2: This example demonstrates how to initialize an ArrayDeque with elements from a collection and print its contents.\n\nExample 3: This example demonstrates how to create an ArrayDeque with a specified initial capacity (10) and add elements to it.\n\n1. Adding Element: We can use methods like add(), addFirst(), addLast(), offer(), offerFirst(), offerLast() to insert element to the ArrayDeque.\n\nExample: This example demonstrates how to use various methods add(), addFirst(), addLast(), offer(), offerFirst(), offerLast() to insert elements in the Deque.\n\n2. Accessing Elements: We can use methods like getFirst(), getLast(), peek(), peekFirst(), peekLast() to access elements of the ArrayDeque.\n\nExample: This example demonstrates how to access the elements of the ArrayDeque using getFirst() and getLast() method.\n\n3. Removing Elements: We can use various methods like remove(), removeFirst(), removeLast(), poll(), pollFirst(), pollLast(), pop() to remove elements from the ArrayDeque.\n\nExample: This example demonstrates removing elements from the ArrayDeque using pop(), poll() and pollFirst() method.\n\n4.Iterating Elements: We can use various methods like remove(), iterator(), descendingIterator() to iterate over the elements of ArrayDeque.\n\nExample: This example demonstrates iterating through a Deque in both forward and reverse order using the Iterator and descendingIterator() method.\n• None The ArrayDeque class provides constant-time performance for inserting and removing elements from both ends of the queue, making it a good choice for scenarios where you need to perform many add and remove operations.\n• None The ArrayDeque class uses a resizable array to store its elements, which means that it can grow and shrink dynamically to accommodate the number of elements in the queue.\n• None The ArrayDeque class is a lightweight data structure that does not require additional overhead, such as linked list nodes, making it a good choice for scenarios where memory is limited.\n• None The ArrayDeque class is not thread-safe, but you can use the Collections.synchronizedDeque method to create a thread-safe version of the ArrayDeque class.\n• None By default, the ArrayDeque class is not synchronized, which means that multiple threads can access it simultaneously, leading to potential data corruption.\n• None Although the ArrayDeque class uses a resizable array to store its elements, it still has a limited capacity, which means that you may need to create a new ArrayDeque when the old one reaches its maximum size."
    },
    {
        "link": "https://baeldung.com/java-array-deque",
        "document": "In this tutorial, we’ll show how to use Java’s ArrayDeque class – which is an implementation of the Deque interface.\n\nAn ArrayDeque (also known as an “Array Double Ended Queue”, pronounced as “ArrayDeck”) is a special kind of a growable array that allows us to add or remove an element from both sides.\n\nAn ArrayDeque implementation can be used as a Stack (Last-In-First-Out) or a Queue(First-In-First-Out).\n\nFor each operation, we basically have two options.\n\nThe first group consists of methods that throw an exception if the operation fails. The other group returns a status or a value:\n\nLet’s look at a few simple examples of how we can make use of the ArrayDeque.\n\nWe’ll start with an example of how we can treat the class as a Stack – and push an element:\n\nLet’s also see how we can pop an element from the ArrayDeque – when used as a Stack:\n\nThe pop method throws NoSuchElementException when a stack is empty.\n\nLet’s now start with a simple example showing how we can offer an element in an ArrayDeque – when used as a simple Queue:\n\nAnd let’s see how we can poll an element from an ArrayDeque, also when used as a Queue:\n\nThe poll method returns a null value if a queue is empty.\n\nUnder the hood, the ArrayDeque is backed by an array that doubles its size when it gets filled.\n\nInitially, the array is initialized with a size of 16. It’s implemented as a double-ended queue where it maintains two pointers, namely a head and a tail.\n\nLet’s see this logic in action – at a high level.\n\nThe following diagram shows how ArrayDeque handles stack.push(“first”); stack.push(“second”); and then stack.pop():\n\nAs we can see, when ArrayDeque works as a stack, adding an element using the push() method inserts the element at the top of the stack and makes head point to it.\n\nIf we pop an element, it sets the element at the current head position as null so the element could be garbage collected and then moves back the head pointer by one.\n\nWhen we add an element using the offer() method, it moves the tail pointer by one.\n\nWhen the user polls an element, it sets the element at the head position to null so the element can be garbage collected and then moves the head pointer.\n\nFinally, a few more notes worth understanding and remembering about this particular implementation:\n• It is a faster queue than LinkedList due to the better locality of reference\n• An Iterator returned by an ArrayDeque is fail-fast\n• ArrayDeque automatically doubles the size of an array when the head and tail pointer meets each other while adding an element\n\nIn this short article, we illustrated the usage of methods in ArrayDeque."
    },
    {
        "link": "https://nikhilmopidevi.github.io/2017/07/06/Queue-using-ArrayDeque-class-in-Java",
        "document": "Queue is a linear data structure which orders elements in a First-In-First-Out (FIFO) manner, where the first element inserted is the first one to be removed.\n\nIn this post, we’ll see how to implement a queue using ArrayDeque — a resizable array implementation of the Deque interface. Java provides the ArrayDeque class as part of the Java Collections Framework. For an overview of the Java Collections Framework, check out my post Overview of the Java Collections Framework.\n\nSome important methods provided by the ArrayDeque class for implementing a queue are:\n\nArray deques have no capacity restrictions, which means they grow as necessary to support usage.\n\nArrayDeque class prohibits elements. Even if it had allowed, it is not recommended to insert nulls because is used as a special return value by various methods to indicate that the deque is empty.\n\nAccording to Java Docs, ArrayDeque class is likely to be faster than Stack when used as a stack, and faster than LinkedList when used as a queue.\n\nThe following example demonstrates how to implement a queue using the ArrayDeque class.\n\n//Pushes some integers into the queue \"Current element at the top of the queue: \" //Removes one integer from the queue\n\nLet us look at the methods available to us.\n\nThis method inserts an element at the end of the deque.\n\nIt retrieves, but does not remove, the head of the queue represented by this deque. It returns if the deque is empty.\n\nIt retrieves and removes the head of the queue represented by this deque. If the deque is empty, it returns .\n\nThis method returns true if the deque contains no elements, or false otherwise.\n\nThe offer(E element) method is exactly similar to the add(E element) method. element() and remove() methods also function similar to the methods peek() and poll() respectively but don’t return if the queue is empty.\n\nNow since you know how to implement a queue using the ArrayDeque class, check out how to create a Queue using LinkedList."
    },
    {
        "link": "https://docs.oracle.com/javase/tutorial/collections/implementations/deque.html",
        "document": "The Java Tutorials have been written for JDK 8. Examples and practices described in this page don't take advantage of improvements introduced in later releases and might use technology no longer available. See Dev.java for updated tutorials taking advantage of the latest releases. See Java Language Changes for a summary of updated language features in Java SE 9 and subsequent releases. See JDK Release Notes for information about new features, enhancements, and removed or deprecated options for all JDK releases.\n\nThe interface, pronounced as \"deck\", represents a double-ended queue. The interface can be implemented as various types of . The interface implementations are grouped into general-purpose and concurrent implementations.\n\nThe general-purpose implementations include and classes. The interface supports insertion, removal and retrieval of elements at both ends. The class is the resizeable array implementation of the interface, whereas the class is the list implementation.\n\nThe basic insertion, removal and retrieval operations in the interface , , , , and . The method adds an element at the head whereas adds an element at the tail of the instance.\n\nThe implementation is more flexible than the implementation. implements all optional list operations. elements are allowed in the implementation but not in the implementation.\n\nIn terms of efficiency, is more efficient than the for add and remove operation at both ends. The best operation in a implementation is removing the current element during the iteration. implementations are not ideal structures to iterate.\n\nThe implementation consumes more memory than the implementation. For the instance traversal use any of the following:\n\nThe is fast and can be used for all kinds of lists.\n\nThe can be used for the forward traversal on all kinds of lists for all kinds of data.\n\nThe class is used in this tutorial to implement the interface. The complete code of the example used in this tutorial is available in . Both the and classes do not support concurrent access by multiple threads.\n\nThe class is the concurrent implementation of the interface. If the deque is empty then methods such as and wait until the element becomes available, and then retrieves and removes the same element."
    }
]