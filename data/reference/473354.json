[
    {
        "link": "https://developer.android.com/reference/android/location/LocationManager",
        "document": "This class provides access to the system location services. These services allow applications to obtain periodic updates of the device's geographical location, or to be notified when the device enters the proximity of a given geographical location.\n\nUnless otherwise noted, all Location API methods require the or permissions. If your application only has the coarse permission then providers will still return location results, but the exact location will be obfuscated to a coarse level of accuracy. \n\n Requires the feature which can be detected using .\n\nRegister for location updates from the specified provider, using a , and a callback on the specified . Only one request can be registered for each unique listener/provider pair, so any subsequent requests with the same provider and listener will overwrite all associated arguments. The same listener may be used across multiple providers with different requests for each provider. It may take some time to receive the first location update depending on the conditions the device finds itself in. In order to take advantage of cached locations, application may consider using or instead. See documentation for an explanation of various request parameters and how they can affect the received locations. If your application wants to passively observe location updates from all providers, then use the . This provider does not turn on or modify active location providers, so you do not need to be as careful about minimum time and minimum distance parameters. However, if your application performs heavy work on a location update (such as network activity) then you should set an explicit fastest interval on your location request in case another application enables a location provider with extremely fast updates. In case the provider you have selected is disabled, location updates will cease, and a provider availability update will be sent. As soon as the provider is enabled again, another provider availability update will be sent and location updates will resume. Locations returned from are with respect to the primary GNSS antenna position within the device. may be used to determine the GNSS antenna position with respect to the Android Coordinate System, and convert between them if necessary. This is generally only necessary for high accuracy applications. When location callbacks are invoked, the system will hold a wakelock on your application's behalf for some period of time, but not indefinitely. If your application requires a long running wakelock within the location callback, you should acquire it yourself. Spamming location requests is a drain on system resources, and the system has preventative measures in place to ensure that this behavior will never result in more locations than could be achieved with a single location request with an equivalent interval that is left in place the whole time. As part of this amelioration, applications that target Android S and above may receive cached or historical locations through their listener. These locations will never be older than the interval of the location request. To unregister for location updates, use . \n\n Requires or : a provider listed by This value cannot be . : the location request containing location parameters This value cannot be . : the executor handling listener callbacks This value cannot be . Callback and listener events are dispatched through this , providing an easy way to control which thread is used. To dispatch events through the main thread of your application, you can use . Otherwise, provide an that dispatches to an appropriate thread. : the listener to receive location updates This value cannot be . if provider is null or doesn't exist if no suitable permission is present"
    },
    {
        "link": "https://developer.android.com/develop/sensors-and-location/location/request-updates",
        "document": "Appropriate use of location information can be beneficial to users of your app. For example, if your app helps the user find their way while walking or driving, or if your app tracks the location of assets, it needs to get the location of the device at regular intervals. As well as the geographical location (latitude and longitude), you may want to give the user further information such as the bearing (horizontal direction of travel), altitude, or velocity of the device. This information, and more, is available in the object that your app can retrieve from the fused location provider. In response, the API updates your app periodically with the best available location, based on the currently-available location providers such as WiFi and GPS (Global Positioning System). The accuracy of the location is determined by the providers, the location permissions you've requested, and the options you set in the location request.\n\nThis lesson shows you how to request regular updates about a device's location using the method in the fused location provider.\n\nGet the last known location\n\nThe last known location of the device provides a handy base from which to start, ensuring that the app has a known location before starting the periodic location updates. The lesson on Getting the Last Known Location shows you how to get the last known location by calling . The snippets in the following sections assume that your app has already retrieved the last known location and stored it as a object in the global variable .\n\nBefore requesting location updates, your app must connect to location services and make a location request. The lesson on Changing Location Settings shows you how to do this. Once a location request is in place you can start the regular updates by calling .\n\nDepending on the form of the request, the fused location provider either invokes the callback method and passes it a list of objects, or issues a that contains the location in its extended data. The accuracy and frequency of the updates are affected by the location permissions you've requested and the options you set in the location request object.\n\nThis lesson shows you how to get the update using the callback approach. Call , passing it your instance of the object, and a . Define a method as shown in the following code sample:\n\nNotice that the above code snippet refers to a boolean flag, , used to track whether the user has turned location updates on or off. If users have turned location updates off, you can inform them of your app's location requirement. For more about retaining the value of the boolean flag across instances of the activity, see Save the State of the Activity.\n\nThe fused location provider invokes the callback method. The incoming argument contains a list object containing the location's latitude and longitude. The following snippet shows how to implement the interface and define the method, then get the timestamp of the location update and display the latitude, longitude and timestamp on your app's user interface:\n\nConsider whether you want to stop the location updates when the activity is no longer in focus, such as when the user switches to another app or to a different activity in the same app. This can be handy to reduce power consumption, provided the app doesn't need to collect information even when it's running in the background. This section shows how you can stop the updates in the activity's method.\n\nTo stop location updates, call , passing it a , as shown in the following code sample:\n\nUse a boolean, , to track whether location updates are currently turned on. In the activity's method, check whether location updates are currently active, and activate them if not:\n\nSave the state of the activity\n\nA change to the device's configuration, such as a change in screen orientation or language, can cause the current activity to be destroyed. Your app must therefore store any information it needs to recreate the activity. One way to do this is via an instance state stored in a object.\n\nThe following code sample shows how to use the activity's callback to save the instance state:\n\nDefine an method to restore the saved values from the previous instance of the activity, if they're available. Call the method from the activity's method, as shown in the following code sample:\n\nFor more about saving instance state, see the Android Activity class reference.\n\nNote: For a more persistent storage, you can store the user's preferences in your app's . Set the shared preference in your activity's method, and retrieve the preference in . For more information about saving preferences, read Saving Key-Value Sets.\n\nTo learn more, take advantage of the following resources:"
    },
    {
        "link": "https://developer.android.com/develop/sensors-and-location/location/permissions",
        "document": "Stay organized with collections Save and categorize content based on your preferences.\n\nTo protect user privacy, apps that use location services must request location permissions.\n\nMultiple permissions are related to location. Which permissions you request, and how you request them, depend on the location requirements for your app's use case.\n\nThis page describes the different types of location requirements and explains how to request location permissions in each case.\n\nTo request location permissions, follow the best practices for all runtime permissions.\n\nEach permission has a combination of the following characteristics:\n\nIf your app contains a feature that shares or receives location information only once, or for a defined amount of time, then that feature requires foreground location access. Some examples include the following:\n• Within a navigation app, a feature allows users to get turn-by-turn directions.\n• Within a messaging app, a feature allows users to share their current location with another user.\n\nThe system considers your app to be using foreground location if a feature of your app accesses the device's current location in one of the following situations:\n• An activity that belongs to your app is visible.\n• None Your app is running a foreground service. When a foreground service is running, the system raises user awareness by showing a persistent notification. Your app retains access when it's placed in the background, such as when the user presses the Home button on their device or turns their device's display off. Additionally, you should declare a foreground service type of , as shown in the following code snippet. On Android 10 (API level 29) and higher, you must declare this foreground service type. <!-- Recommended for Android 9 (API level 28) and lower. --> <!-- Required for Android 10 (API level 29) and higher. --> <service android:name=\"MyNavigationService\" android:foregroundServiceType=\"location\" ... > <!-- Any inner elements would go here. --> </service>\n\nYou declare a need for foreground location when your app requests either the permission or the permission, as shown in the following snippet:\n\nAn app requires background location access if a feature within the app constantly shares location with other users or uses the Geofencing API. Several examples include the following:\n• Within a family location sharing app, a feature allows users to continuously share location with family members.\n• Within an IoT app, a feature allows users to configure their home devices such that they turn off when the user leaves their home and turn back on when the user returns home.\n\nThe system considers your app to be using background location if it accesses the device's current location in any situation other than the ones described in the foreground location section. The background location precision is the same as the foreground location precision, which depends on the location permissions that your app declares.\n\nOn Android 10 (API level 29) and higher, you must declare the permission in your app's manifest in order to request background location access at runtime. On earlier versions of Android, when your app receives foreground location access, it automatically receives background location access as well.\n\nAndroid supports the following levels of location accuracy:\n\nIf the user grants the approximate location permission, your app only has access to approximate location, regardless of which location permissions your app declares.\n\nYour app should still work when the user grants only approximate location access. If a feature in your app absolutely requires access to precise location using the permission, you can ask the user to allow your app to access precise location.\n\nOn Android 10 (API level 29) and higher, when a feature in your app accesses device location in the background for the first time after the user grants background location access, the system schedules a notification to send to the user. This notification reminds the user that they've allowed your app to access device location all the time. An example notification appears in figure 8.\n\nCheck for location requirements in your app's SDK dependencies\n\nCheck whether your app uses any SDKs that depend on location permissions, especially the permission. Read the Getting to know the behaviors of your SDK dependencies blog post on Medium for more.\n\nFor more information about location permissions in Android, view the following materials:\n• How to find possible background location usage\n• Sample app to demonstrate the use of location permissions."
    },
    {
        "link": "https://stuff.mit.edu/afs/sipb/project/android/docs/training/basics/location/locationmanager.html",
        "document": "Before your application can begin receiving location updates, it needs to perform some simple steps to set up access. In this lesson, you'll learn what these steps entail.\n\nThe first step of setting up location update access is to declare proper permissions in the manifest. If permissions are missing, the application will get a at runtime.\n\nDepending on the methods used, either or permission is needed. For example, you need to declare the permission if your application uses a network-based location provider only. The more accurate GPS requires the permission. Note that declaring the permission implies already.\n\nAlso, if a network-based location provider is used in the application, you'll need to declare the internet permission as well.\n\nis the main class through which your application can access location services on Android. Similar to other system services, a reference can be obtained from calling the method. If your application intends to receive location updates in the foreground (within an ), you should usually perform this step in the method.\n\nWhile not required, most modern Android-powered devices can receive location updates through multiple underlying technologies, which are abstracted to an application as objects. Location providers may have different performance characteristics in terms of time-to-fix, accuracy, monetary cost, power consumption, and so on. Generally, a location provider with a greater accuracy, like the GPS, requires a longer fix time than a less accurate one, such as a network-based location provider.\n\nDepending on your application's use case, you have to choose a specific location provider, or multiple providers, based on similar tradeoffs. For example, a points of interest check-in application would require higher location accuracy than say, a retail store locator where a city level location fix would suffice. The snippet below asks for a provider backed by the GPS.\n\nAlternatively, you can provide some input criteria such as accuracy, power requirement, monetary cost, and so on, and let Android decide a closest match location provider. The snippet below asks for a location provider with fine accuracy and no monetary cost. Note that the criteria may not resolve to any providers, in which case a null will be returned. Your application should be prepared to gracefully handle the situation.\n\nSome location providers such as the GPS can be disabled in Settings. It is good practice to check whether the desired location provider is currently enabled by calling the method. If the location provider is disabled, you can offer the user an opportunity to enable it in Settings by firing an with the action."
    },
    {
        "link": "https://digitalocean.com/community/tutorials/android-location-api-tracking-gps",
        "document": "Android Location API can be used to track your mobile current location and show in the app. In this tutorial, we’ll develop an application that fetches the user’s current location programmatically.\n\nThere are two ways to get a users location in our application:\n• : This is a part of the Android API.\n• : This is present in the Google Play Services API. (We’ll look into this in the next tutorial)\n\nAndroid Location Services is available since Android API 1. Google officially recommends using Google Play Location Service APIs. Android Location Services API is still used to develop location-based apps for devices that don’t support Google Play Services.\n\nThe LocationListener interface, which is part of the Android Locations API is used for receiving notifications from the LocationManager when the location has changed. The LocationManager class provides access to the systems location services. The LocationListener class needs to implement the following methods.\n• onLocationChanged(Location location) : Called when the location has changed.\n• onProviderDisabled(String provider) : Called when the provider is disabled by the user.\n• onProviderEnabled(String provider) : Called when the provider is enabled by the user.\n• onStatusChanged(String provider, int status, Bundle extras) : Called when the provider status changes.\n\nThe has two means of acquiring location data:\n• LocationManager.GPS_PROVIDER: Determines location using satellites. Depending on the conditions, this provider may take a while to return a location fix\n• LocationManager.NETWORK_PROVIDER: Determines location based on the availability of nearby cell towers and WiFi access points. This is faster than GPS_PROVIDER\n\nIn this tutorial, we’ll create a Service that implements the LocationListener class to receive periodic location updates via GPS Providers or Network Providers.\n\nThe project consists of a class which displays a Get Location and a Service class.\n\nThe activity_main.xml layout is defined below.\n\nThe MainActivity.java class is defined below.\n\nIn the above code, we’re implementing runtime permissions that are used in Android 6.0+ devices. We’ve added the ACCESS_FINE_LOCATION and ACCESS_COARSE_LOCATION permissions in the AndroidManifest.xml file. Clicking the button invokes the LocationTrack.java service class. If the location returned is NULL in the case of GPS Provider, we call the method from the LocationTrack.java class that we’ll be seeing shortly. When the activity is destroyed method is called to turn off the location updates. The class is defined below.\n\nFew inferences drawn from the above code are:\n• In the above code is called upon the locationManager object and is used to check whether GPS/Network Provider is enabled or not.\n• If the Providers aren’t enabled we’re calling the method that shows a prompt to enable GPS.\n• method of the LocationManager class is used to register the current activity to be notified periodically by the named provider.\n• is invoked periodically based upon the minTime and minDistance, whichever comes first.\n• Location class hosts the latitude and longitude. To get the current location the following code snippet is used. On the above Location object, getters are called to store the double values of latitude and longitude. These double values are then disabled as a Toast message on the screen.\n• To stop location updates removeUpdates method is called on the LocationManager instance.\n\nThe output of the above application in action on an emulator is: Our emulators can’t fetch locations, hence it’s returning 0.0 for lat/lng. You can connect your smartphone and run the application in debug mode to check your current location. To emulate GPS Locations in an emulator we can pass fixed Latitude and Longitude values from Android Studio. Besides the emulator window, you can see a list of options. The one at the bottom (which has three dots) is our Extended Controls options. Open that and send a dummy location. Your application should look like this: This brings an end to this tutorial. We’ll be implementing Location API using Google Play Services in a later tutorial. You can download the Android GPSLocationTracking Project from the link below."
    },
    {
        "link": "https://stackoverflow.com/questions/29313687/trying-to-use-spring-boot-rest-to-read-json-string-from-post",
        "document": "Am using the latest version of Spring Boot to read in a sample JSON via Restful Web Service...\n\nWhen I invoke it using the following command:\n\nThe only thing I am trying to do is pass in some valid JSON (as a string via curl) and to see if the String payload enters the process method as {\"name\":\"value\"}\n\nWhat am I possibly doing wrong?\n\nThank you for taking the time to read this..."
    },
    {
        "link": "https://spring.io/guides/tutorials/rest",
        "document": ""
    },
    {
        "link": "https://baeldung.com/spring-boot-json",
        "document": "In this tutorial, we’ll demonstrate how to build a REST service to consume and produce JSON content with Spring Boot.\n\nWe’ll also take a look at how we can easily employ RESTful HTTP semantics.\n\nFor simplicity, we won’t include a persistence layer, but Spring Data also makes this easy to add.\n\nWriting a JSON REST service in Spring Boot is simple, as that’s its default opinion when Jackson is on the classpath:\n\nBy annotating our StudentController with @RestController, we’ve told Spring Boot to write the return type of the read method to the response body. Since we also have a @RequestMapping at the class level, it would be the same for any more public methods that we add.\n\nThough simple, this approach lacks HTTP semantics. For example, what would happen if we didn’t find the requested student? Instead of returning a 200 or 500 status code, we might want to return a 404.\n\nLet’s look at how to gain more control over the HTTP response itself and add some typical RESTful behaviors to our controller.\n\nWhen we need to control aspects of the response other than the body, like the status code, we can instead return a ResponseEntity:\n\nHere, we’re doing much more than just returning the created Student in the response. We’re also responding with a semantically clear HTTP status and, if creation succeeds, a URI to the new resource.\n\nAs previously mentioned, if we want to read a single Student, it’s more semantically clear to return a 404 if we can’t find the student:\n\nHere, we can clearly see the difference from our initial read() implementation.\n\nThis way, the Student object will be properly mapped to the response body and returned with a proper status at the same time.\n\nUpdating is very similar to creation, except it’s mapped to PUT instead of POST, and the URI contains an id of the resource we’re updating:\n\nThe delete operation is mapped to the DELETE method. The URI also contains the id of the resource:\n\nWe didn’t implement specific error handling because the delete() method actually fails by throwing an Exception.\n\nIn this article, we learned how to consume and produce JSON content in a typical CRUD REST service developed with Spring Boot. Additionally, we demonstrated how to implement proper response status control and error handling.\n\nTo keep things simple, we didn’t go into persistence this time, but Spring Data REST provides a quick and efficient way to build a RESTful data service."
    },
    {
        "link": "https://medium.com/@namanoli/understanding-produce-and-consume-in-spring-boot-628f597681fe",
        "document": "Spring Boot is a powerful framework that simplifies the development of Java applications. One of its essential features is the ability to produce and consume data using various formats such as JSON, XML, or even custom formats. In this blog post, we will dive deep into the concepts of producing and consuming data in Spring Boot applications.\n\nProducing data in Spring Boot refers to the process of generating and sending data from your application to the outside world, typically in response to incoming requests. Spring Boot provides several ways to achieve this, and one of the most common approaches is by using the annotation.\n\nTo produce data, start by creating a REST controller. Annotate your class with to indicate that it will handle HTTP requests and return data to clients.\n\nNext, define endpoints by creating methods in your controller and annotating them with , specifying the HTTP method and URL path. These methods will return data to clients.\n\nIn the example above, the method returns a string, which Spring Boot automatically converts to JSON and sends as a response to the client.\n\nSpring Boot is flexible when it comes to data formats. You can control the format of the data you produce by using annotations like to specify the return type and to set the desired content type.\n\nIn this example, we are explicitly specifying that the endpoint produces JSON data.\n\nConsuming data in Spring Boot involves receiving and processing data sent by clients in their requests. Like producing data, Spring Boot offers various ways to handle incoming data. Let’s explore a common method using the annotation.\n\nTo consume JSON data sent by clients, annotate a method parameter with . Spring Boot will automatically deserialize the incoming JSON into a Java object.\n\nIn this example, the method expects a instance in the request body and processes it.\n\nSpring Boot can handle various data formats. You can specify the content type you expect to consume using the attribute.\n\nIn this case, the endpoint expects XML data in the request body.\n\nIn Spring Boot, producing and consuming data is a fundamental aspect of building web applications. By following the principles outlined in this blog post, you can create robust RESTful APIs that communicate seamlessly with clients, whether they are sending or receiving data in JSON, XML, or other formats. Understanding how to produce and consume data effectively is key to building modern and efficient Spring Boot applications."
    },
    {
        "link": "https://howtodoinjava.com/spring-mvc/controller-getmapping-postmapping",
        "document": "Learn to create Spring WebMVC REST controllers with annotation and map HTTP requests with annotations like , and in a Spring or Spring Boot application.\n\nBefore Spring 4.3, Spring had only annotation for mapping all the incoming HTTP request URLs to the corresponding controller methods.\n\nSpring 4.3 introduced 5 new and more specific annotations for each HTTP request type.\n\nFor example, the following code demonstrates the usage of @GetMapping and @PostMapping.\n\nTo make it easy to relate the changes, in the given below code, annotation has been used to map the same HTTP requests. Notice that we have specified the HTTP request type (GET, POST) as the annotation attribute .\n• The @GetMapping annotation is a composed version of annotation that acts as a shortcut for .\n• The annotated methods handle the HTTP requests matched with the given URI expression.\n\nLet us understand how to write controller methods mapped with @GetMapping annotations. In the following example, we are mapping two GET requests:\n• HTTP GET /users – returns all the users in the system.\n• HTTP GET /users/{id} – returns a user by specified id.\n• The is a specialized version of annotation that acts as a shortcut for .\n• The annotated methods handle the HTTP requests matched with the given URI expression.\n• As a best practice, always specify the media types (XML, JSON etc.) using the ‘consumes’ and ‘produces’ attributes.\n\nLet us understand how to write controller methods mapped with @PostMapping annotations. In the following example, we are mapping a POST request:\n• HTTP POST /users – creates a new user in the system.\n\nAll request mapping annotations support the following attributes, but they should be used when appropriate for the request type:\n• path or value: specifies the mapping URI. A handler method that is not mapped to any path explicitly is effectively mapped to an empty path.\n• consumes: consists of one or more media types, one of which must match the request header.\n• produces: consists of one or more media types one of which must be chosen via content negotiation against the “acceptable” media types, generally extracted from the header but may be derived from query parameters.\n• headers: specifies the headers of the mapped request, narrowing the primary mapping, with a request only mapped if each such header is found to have the given value.\n• name: Assign a name to the mapping.\n• params: specifies the parameters of the mapped request, narrowing the primary mapping, with a request only mapped if each such parameter is found to have the given value.\n\nThe mapping annotations such as @RequestMapping, @GetMapping and @PostMapping, inherit the annotation attribute values from the @RequestMapping annotation applied at the @RestController class.\n\nIn HomeController, the @RequestMapping annotation at the top specifies the attribute to MediaType.APPLICATION_JSON_VALUE , so all the handler methods in this class, by default, will return the JSON response.\n\nNote that the method-level mapping annotation may override the attribute values by providing its own values. In the following example, the /members API overrides the attribute so it will return the XML response to the clients.\n\nAs noted above @PostMapping annotation is one specialized version of @RequestMapping annotation that handles only the HTTP POST requests.\n\nLet’s see the difference between @PostMapping and @RequestMapping annotations with a very simple example. Both versions in the given example will work exactly the same. They just have a slightly different syntax.\n\nIn other words, @PostMapping acts as a shortcut for @RequestMapping(method = RequestMethod.POST). We can see the source code of the annotation which internally uses the annotation.\n\nSpring MVC has made writing request handlers / REST controller classes and methods very easy. Just add a few annotations like @GetMapping and @PostMapping and put the class where component scanning can find them and configure them in the web application context.\n\nIt is also very easy to create attributes at the class level so that all handler methods inherit them by default and can override them when needed.\n\nSame way, you can use other request mapping annotations e.g. , and ."
    }
]