[
    {
        "link": "https://github.com/fatedier/frp",
        "document": "frp is an open source project with its ongoing development made possible entirely by the support of our awesome sponsors. If you'd like to join them, please consider sponsoring frp's development.\n\nfrp is a fast reverse proxy that allows you to expose a local server located behind a NAT or firewall to the Internet. It currently supports TCP and UDP, as well as HTTP and HTTPS protocols, enabling requests to be forwarded to internal services via domain name.\n• Example Usage\n• Access your computer in a LAN network via SSH\n• Features\n• Only allowing certain ports on the server\n\nfrp is currently under development. You can try the latest release version in the branch, or use the branch to access the version currently in development.\n\nWe are currently working on version 2 and attempting to perform some code refactoring and improvements. However, please note that it will not be compatible with version 1.\n\nWe will transition from version 0 to version 1 at the appropriate time and will only accept bug fixes and improvements, rather than big feature requests.\n\nThe complexity and difficulty of the v2 version are much higher than anticipated. I can only work on its development during fragmented time periods, and the constant interruptions disrupt productivity significantly. Given this situation, we will continue to optimize and iterate on the current version until we have more free time to proceed with the major version overhaul.\n\nThe concept behind v2 is based on my years of experience and reflection in the cloud-native domain, particularly in K8s and ServiceMesh. Its core is a modernized four-layer and seven-layer proxy, similar to envoy. This proxy itself is highly scalable, not only capable of implementing the functionality of intranet penetration but also applicable to various other domains. Building upon this highly scalable core, we aim to implement all the capabilities of frp v1 while also addressing the functionalities that were previously unachievable or difficult to implement in an elegant manner. Furthermore, we will maintain efficient development and iteration capabilities.\n\nIn addition, I envision frp itself becoming a highly extensible system and platform, similar to how we can provide a range of extension capabilities based on K8s. In K8s, we can customize development according to enterprise needs, utilizing features such as CRD, controller mode, webhook, CSI, and CNI. In frp v1, we introduced the concept of server plugins, which implemented some basic extensibility. However, it relies on a simple HTTP protocol and requires users to start independent processes and manage them on their own. This approach is far from flexible and convenient, and real-world demands vary greatly. It is unrealistic to expect a non-profit open-source project maintained by a few individuals to meet everyone's needs.\n\nFinally, we acknowledge that the current design of modules such as configuration management, permission verification, certificate management, and API management is not modern enough. While we may carry out some optimizations in the v1 version, ensuring compatibility remains a challenging issue that requires a considerable amount of effort to address.\n\nWe sincerely appreciate your support for frp.\n\nTo begin, download the latest program for your operating system and architecture from the Release page.\n\nNext, place the binary and server configuration file on Server A, which has a public IP address.\n\nFinally, place the binary and client configuration file on Server B, which is located on a LAN that cannot be directly accessed from the public internet.\n\nSome antiviruses improperly mark frpc as malware and delete it. This is due to frp being a networking tool capable of creating reverse proxies. Antiviruses sometimes flag reverse proxies due to their ability to bypass firewall port restrictions. If you are using antivirus, then you may need to whitelist/exclude frpc in your antivirus settings to avoid accidental quarantine/deletion. See issue 3637 for more details.\n• Modify on server A by setting the for frp clients to connect to:\n• Modify on server B and set the field to the public IP address of your frps server:\n\nNote that the (listened on the client) and (exposed on the server) are used for traffic going in and out of the frp system, while the is used for communication between frps and frpc.\n• To access server B from another machine through server A via SSH (assuming the username is ), use the following command:\n\nThis example implements multiple SSH services exposed through the same port using a proxy of type tcpmux. Similarly, as long as the client supports the HTTP Connect proxy connection method, port reuse can be achieved in this way.\n• Deploy frps on a machine with a public IP and modify the frps.toml file. Here is a simplified configuration:\n• Deploy frpc on the internal machine A with the following configuration:\n• Deploy another frpc on the internal machine B with the following configuration:\n• To access internal machine A using SSH ProxyCommand, assuming the username is \"test\":\n• To access internal machine B, the only difference is the domain name, assuming the username is \"test\":\n\nSometimes we need to expose a local web service behind a NAT network to others for testing purposes with our own domain name.\n\nUnfortunately, we cannot resolve a domain name to a local IP. However, we can use frp to expose an HTTP(S) service.\n• Modify and set the HTTP port for vhost to 8080:\n\nIf you want to configure an https proxy, you need to set up the .\n• Modify and set to the IP address of the remote frps server. Specify the of your web service:\n• Map the A record of to either the public IP of the remote frps server or a CNAME record pointing to your original domain.\n• Modify and set to the IP address of the remote frps server. Forward DNS query requests to the Google Public DNS server :\n• Start with the following configuration:\n• Test the configuration by getting the docker version using :\n\nExpose a simple HTTP file server to access files stored in the LAN from the public Internet.\n\nConfigure as described above, then:\n• Start with the following configuration:\n• Visit from your browser and specify correct username and password to view files in on the machine.\n\nYou may substitute for the plugin, and point the to a HTTPS endpoint.\n• Start with the following configuration:\n\nTo mitigate risks associated with exposing certain services directly to the public network, STCP (Secret TCP) mode requires a preshared key to be used for access to the service from other clients.\n\nConfigure same as above.\n• Start on machine B with the following config. This example is for exposing the SSH service (port 22), and note the field for the preshared key, and that the field is removed here:\n• Start another (typically on another machine C) with the following config to access the SSH service with a security key ( field):\n• On machine C, connect to SSH on machine B, using this command:\n\nxtcp is designed to transmit large amounts of data directly between clients. A frps server is still needed, as P2P here only refers to the actual data transmission.\n\nNote that it may not work with all types of NAT devices. You might want to fallback to stcp if xtcp doesn't work.\n• Start on machine B, and expose the SSH port. Note that the field is removed:\n• Start another (typically on another machine C) with the configuration to connect to SSH using P2P mode:\n• On machine C, connect to SSH on machine B, using this command:\n\nSince v0.52.0, we support TOML, YAML, and JSON for configuration. Please note that INI is deprecated and will be removed in future releases. New features will only be available in TOML, YAML, or JSON. Users wanting these new features should switch their configuration format accordingly.\n\nRead the full example configuration files to find out even more features not described here.\n\nExamples use TOML format, but you can still use YAML or JSON.\n\nThese configuration files is for reference only. Please do not use this configuration directly to run the program as it may have various issues.\n\nEnvironment variables can be referenced in the configuration file, using Go's standard format:\n\nWith the config above, variables can be passed into program like this:\n\nwill render configuration file template using OS environment variables. Remember to prefix your reference with .\n\nYou can split multiple proxy configs into different files and include them in the main file.\n\nConfigure a port for dashboard to enable this feature:\n\nThen visit to see the dashboard, with username and password both being .\n\nAdditionally, you can use HTTPS port by using your domains wildcard or normal SSL certificate:\n\nThen visit to see the dashboard in secure HTTPS connection, with username and password both being .\n\nThe Client Admin UI helps you check and manage frpc's configuration.\n\nConfigure an address for admin UI to enable this feature:\n\nThen visit to see admin UI, with username and password both being .\n\nWhen web server is enabled, frps will save monitor data in cache for 7 days. It will be cleared after process restart.\n\nEnable dashboard first, then configure in .\n\nThere are 2 authentication methods to authenticate frpc with frps.\n\nYou can decide which one to use by configuring in and , the default one is token.\n\nConfiguring will use the configured authentication method to add and validate authentication on every heartbeat between frpc and frps.\n\nConfiguring will do the same for every new work connection between frpc and frps.\n\nWhen specifying in and - token based authentication will be used.\n\nMake sure to specify the same in and for frpc to pass frps validation\n\nWhen specifying in and - OIDC based authentication will be used.\n\nOIDC stands for OpenID Connect, and the flow used is called Client Credentials Grant.\n\nTo use this authentication type - configure and as follows:\n\nThe features are off by default. You can turn on encryption and/or compression:\n\nSince v0.50.0, the default value of and has been changed to true, and tls is enabled by default.\n\nFor port multiplexing, frp sends a first byte to dial a TLS connection. This only takes effect when you set to false.\n\nTo enforce to only accept TLS connections - configure in . This is optional.\n\nYou will need a root CA cert and at least one SSL/TLS certificate. It can be self-signed or regular (such as Let's Encrypt or another SSL/TLS certificate provider).\n\nIf you using via IP address and not hostname, make sure to set the appropriate IP address in the Subject Alternative Name (SAN) area when generating SSL/TLS Certificates.\n\nGiven an example:\n• Prepare openssl config file. It exists at in Linux System and in MacOS, and you can copy it to current path, like . If not, you can build it by yourself, like:\n\nThe fields are required for enabling HTTP API:\n\nThen run command and wait for about 10 seconds to let create or update or remove proxies.\n\nNote that global client parameters won't be modified except 'start'.\n\nYou can run command before reloading to check if there are config errors.\n\nUse to get status of all proxies. The fields are required for enabling HTTP API.\n\nin is used to avoid abuse of ports:\n\nand in frps can use same port with . frps will detect the connection's protocol and handle it correspondingly.\n\nWhat you need to pay attention to is that if you want to configure and to the same port, you need to first set to false.\n\nWe would like to try to allow multiple proxies bind a same remote port with different protocols in the future.\n\nSet in each proxy's configure to enable this feature. Supported units are and .\n\nSet to or to limit bandwidth on the client or server side. Default is .\n\nfrp supports tcp stream multiplexing since v0.10.0 like HTTP2 Multiplexing, in which case all logic connections to the same frpc are multiplexed into the same TCP connection.\n\nYou can disable this feature by modify and :\n\nKCP is a fast and reliable protocol that can achieve the transmission effect of a reduction of the average latency by 30% to 40% and reduction of the maximum delay by a factor of three, at the cost of 10% to 20% more bandwidth wasted than TCP.\n\nKCP mode uses UDP as the underlying transport. Using KCP in frp:\n\nThe number can be the same number as , since field specifies a TCP port.\n• Configure to use KCP to connect to frps:\n\nQUIC is a new multiplexed transport built on top of UDP.\n\nThe number can be the same number as , since field specifies a TCP port.\n• Configure to use QUIC to connect to frps:\n\nBy default, frps creates a new frpc connection to the backend service upon a user request. With connection pooling, frps keeps a certain number of pre-established connections, reducing the time needed to establish a connection.\n\nThis feature is suitable for a large number of short connections.\n• Configure the limit of pool count each proxy can use in :\n• Enable and specify the number of connection pool:\n\nThis feature is only available for types , , now.\n\nis used for authentication.\n\nConnections to port 80 will be dispatched to proxies in the same group randomly.\n\nFor type , in the same group should be the same.\n\nFor type , , , should be the same.\n\nHealth check feature can help you achieve high availability with load balancing.\n\nWith health check type tcp, the service port will be pinged (TCPing):\n\nWith health check type http, an HTTP request will be sent to the service and an HTTP 2xx OK response is expected:\n\nBy default frp does not modify the tunneled HTTP requests at all as it's a byte-for-byte copy.\n\nHowever, speaking of web servers and HTTP requests, your web server might rely on the HTTP header to determine the website to be accessed. frp can rewrite the header when forwarding the HTTP requests, with the field:\n\nThe HTTP request will have the header rewritten to when it reaches the actual web server, although the request from the browser probably has .\n\nSimilar to , You can override other HTTP request and response headers with proxy type .\n\nIn this example, it will set header in the HTTP request and in the HTTP response.\n\nThis feature is for proxies or proxies with the and plugins enabled.\n\nYou can get user's real IP from HTTP request headers .\n\nfrp supports Proxy Protocol to send user's real IP to local services. It support all types except UDP.\n\nHere is an example for https service:\n\nYou can enable Proxy Protocol support in nginx to expose user's real IP in HTTP header , and then read header in your web service for the real IP.\n\nAnyone who can guess your tunnel URL can access your local web server unless you protect it with a password.\n\nThis enforces HTTP Basic Auth on all requests with the username and password specified in frpc's configure file.\n\nIt can only be enabled when proxy type is http.\n\nVisit in the browser and now you are prompted to enter the username and password.\n\nIt is convenient to use configure for http and https types when many people share one frps server.\n\nResolve to the frps server's IP. This is usually called a Wildcard DNS record.\n\nNow you can visit your web service on .\n\nNote that if is not empty, should not be the subdomain of .\n\nfrp supports forwarding HTTP requests to different backend web services by url routing.\n\nspecifies the prefix of URL used for routing. frps first searches for the most specific prefix location given by literal strings regardless of the listed order.\n\nHTTP requests with URL prefix or will be forwarded to web02 and other requests to web01.\n\nfrp supports receiving TCP sockets directed to different proxies on a single port on frps, similar to and .\n\nThe only supported TCP port multiplexing method available at the moment is - HTTP CONNECT tunnel.\n\nWhen setting to anything other than 0 in frps, frps will listen on this port for HTTP CONNECT requests.\n\nThe host of the HTTP CONNECT request will be used to match the proxy in frps. Proxy hosts can be configured in frpc by configuring and / or under proxies, when .\n\nIn the above configuration - frps can be contacted on port 1337 with a HTTP CONNECT header such as:\n\nand the connection will be routed to .\n\nfrpc can connect to frps through proxy if you set OS environment variable , or if is set in frpc.toml file.\n\nIt only works when protocol is tcp.\n\nWe can use the range syntax of Go template combined with the built-in function to achieve port range mapping.\n\nThe following example, when run, will create 8 proxies named , each mapping the remote port to the local port.\n\nfrpc only forwards requests to local TCP or UDP ports by default.\n\nPlugins are used for providing rich features. There are built-in plugins such as , , , , , , and you can see example usage.\n\nand are configuration parameters used in plugin.\n\nfrp supports listening to an SSH port on the frps side and achieves TCP protocol proxying through the SSH -R protocol, without relying on frpc.\n\nWhen running , a private key file named will be automatically created in the current working directory. This generated private key file will be used by the SSH server in frps.\n\nsets up a proxy on frps that forwards the local 8080 service to the port 9090.\n\nThis is equivalent to:\n\nPlease refer to this document for more information.\n• gofrp/plugin - A repository for frp plugins that contains a variety of plugins implemented based on the frp extension mechanism, meeting the customization needs of different scenarios.\n• gofrp/tiny-frpc - A lightweight version of the frp client (around 3.5MB at minimum) implemented using the ssh protocol, supporting some of the most commonly used features, suitable for devices with limited resources.\n\nInterested in getting involved? We would like to help you!\n• Take a look at our issues list and consider sending a Pull Request to dev branch.\n• If you want to add a new feature, please create an issue first to describe the new feature, as well as the implementation approach. Once a proposal is accepted, create an implementation of the new features and submit it as a pull request.\n• Sorry for my poor English. Improvements for this document are welcome, even some typo fixes.\n• If you have great ideas, send an email to fatedier@gmail.com.\n\nNote: We prefer you to give your advise in issues, so others with a same question can search it quickly and we don't need to answer them repeatedly.\n\nIf frp helps you a lot, you can support us by:\n\nYou can have your company's logo placed on README file of this project.\n\nDonate money by PayPal to my account fatedier@gmail.com."
    },
    {
        "link": "https://github.com/fatedier/frp/issues/2286",
        "document": "[REQUIRED] hat version of frp are you using\n\n[REQUIRED] What operating system and processor architecture are you using\n\n OS: Ubuntu\n\n CPU architecture: x86\n\n[REQUIRED] description of errors\n\n When trying to forward a service from a local PC using HTTPS with an SSL certificate the service is not accessible. When I visit the domain that I specified I just get a 502 Nginx error code. If I try to access it directly over the IP-Address using IP_ADDRESS:vhost_https_port I get the following error messages:\n• Setup FRP using the above configs\n• Use Nginx as a reverse proxy from the domain to the\n• Trying to access the service that FRP should forward\n• Nginx-Proxy Docker container is used as a reverse proxy from the domain to the defined in the FRP config.\n• I also looked at How to implement HTTPS SSL connection for multiple frp wildcard subdomains with wildcard SSL certificates? , but it did not help fix my problem.\n\nCan you guess what caused this issue\n• I included all information required in the sections above\n• I made sure there are no duplicates of this report (Use Search)"
    },
    {
        "link": "https://ruianding.com/blog/frp-part-1-introduction-and-server-side-setup",
        "document": "In this two-part series, we’ll explore how to use FRP (Fast Reverse Proxy) to securely and efficiently expose local services behind a NAT or firewall to the public internet. In this first part, we’ll focus on what FRP is and how to set up the FRP server (frps) on a machine with a public IP. In Part 2, we’ll cover the client side configuration and how to connect your local services to the server for external access.\n\nFRP is an open-source, high-performance reverse proxy solution. It’s frequently used to publish “internal resources” or local services to the internet, bypassing NAT or firewall restrictions. Essentially, if you have a web application, API, or any TCP/UDP service running in a private network, FRP can tunnel that service through a server in the public cloud, enabling external access without complex network changes.\n• Simple Deployment: You install frps on a public server and frpc on your local machine.\n• Cross-Platform: Runs on Linux, Windows, macOS, ARM, and more.\n• FRP Server (frps): Deployed on a publicly reachable host (has a public IP, or at least a forwarded port). It waits for inbound connections from both the external internet and the FRP clients.\n• FRP Client (frpc): Runs on your internal or local machine. It “dials out” to the FRP server, maintaining a secure tunnel. External requests to the server get forwarded back to the local service through this tunnel.\n\nThis architecture lets you easily expose local resources without requiring direct inbound connections to your internal network.\n\nYou’ll need a public-facing machine—this could be a VPS or cloud server (AWS, DigitalOcean, Azure, etc.) with a public IP address. We’ll refer to this machine as your FRP server.\n\nHead over to the official FRP Releases page and choose the frp_{version}_linux_amd64.tar.gz file (assuming you’re on a 64-bit Linux host). Replace the version accordingly, for example:\n\nExtract the tarball and rename the folder for convenience:\n\nInside, you should see , , example config files, and other documentation.\n\nAlthough FRP historically supported INI, it’s now recommended to use TOML, JSON, or YAML.\n\nBelow is an example TOML config named :\n• is the port on which frps listens for connections from FRP clients.\n• , , and enable a web UI to monitor FRP activity at .\n• is a secret key to authenticate incoming connections from frpc. You must use the same token on the client side.\n\nRun frps directly to ensure it starts without errors:\n\nIf successful, you’ll see logs such as:\n\nTo ensure frps automatically restarts on reboot, we’ll use systemd.\n\nPaste in the following\n\nIf it shows , frps is now running in the background.\n\nIf you’re using a cloud provider, ensure TCP:7000 and TCP:7500 (for the dashboard) are allowed in your security group. Also, if you’re running a local firewall (e.g., , ), open those ports as well:\n\nWith configured, you can visit:\n• Password: \n\n(or whatever you set in ). You’ll see details like connected clients, proxies, and traffic stats.\n\nOne common question is whether FRP’s speed depends on the server’s bandwidth. In short, yes. When you use FRP to expose a local service:\n• Traffic flows from your local machine to the FRP server, and then\n• From the FRP server to the end user (or in reverse).\n\nBecause all data is relayed through the FRP server, the throughput is directly influenced by the server’s network capacity (and of course, your local network as well). If your server is on a slow connection or limited bandwidth, the maximum throughput will be restricted even if you have fast internet at home. Similarly, if your local upload bandwidth is small, that also becomes a bottleneck.\n• Server Bandwidth: A low or congested network on your VPS/cloud server will limit overall speeds.\n• Server Performance: CPU/memory constraints can become a bottleneck under heavy loads.\n• Local Network: If your home or office upload bandwidth is small, your traffic can’t exceed that limit.\n• Routing & Latency: Geographical distance and ISP routing can affect transfer speeds and latency.\n\nIn other words, the slowest or most congested link between your local machine and the FRP server (and onward to the requesting client) will dictate the maximum speed.\n\nYou’ve successfully installed the FRP server (frps) on your public host. In Part 2, we’ll set up the FRP client (frpc) on your local machine. By using the same and specifying the / you just configured, you’ll be able to tunnel your private services through the FRP server and make them accessible from the internet."
    },
    {
        "link": "https://xtom.com/blog/frp-rathole-ngrok-comparison-best-reverse-tunneling-solution",
        "document": "When it comes to reverse tunneling, you'll continuously be recommended 3 main options: FRP (Fast Reverse Proxy), Rathole, and ngrok.\n\nAnd to be honest, it can be kind of difficult figuring out which one is the right reverse tunneling solution for you. They're all slightly different, tailored to different use cases.\n\nThat said, in this article, we'll be comparing all of these options in depth, and our goal is to make that decision much easier for you.\n\nWhat are FRP, Rathole, and ngrok?\n\nFRP is an open-source, reverse proxy tool that enables secure communication between internal services and external clients.\n\nIt supports various protocols, including HTTP, HTTPS, TCP, and UDP, allowing users to expose local servers to the internet, perform internal network penetration testing, enable remote desktop access, and more.\n\nRathole is an open-source reverse proxy solution written in Rust, known for its high performance and low resource consumption.\n\nRathole is designed to handle NAT traversal efficiently, achieving higher throughput and stability compared to similar tools.\n\nIt supports TCP and UDP protocols and features mandatory service tokens for security, optional Noise Protocol encryption, and TLS support. Rathole can dynamically add or remove services by hot-reloading the configuration file.\n\nngrok is a widely-used tunneling service that provides a secure way to expose local servers to the internet.\n\nIt offers both free and paid plans, with additional features like custom domains, authentication, and detailed usage analytics.\n\nngrok is popular among developers for testing webhooks, demonstrating prototypes, and conducting secure local development.\n\nWho are they for?\n\nFRP is best suited for developers who need a flexible and configurable tunneling solution, network administrators performing internal network penetration tests, and IT professionals requiring remote access to internal services.\n\nRathole is ideal for developers working with low-end devices or embedded systems, hobbyists and makers needing a lightweight reverse proxy, and system administrators looking for a straightforward and resource-efficient tunneling tool.\n\nngrok is perfect for developers needing a quick and easy way to expose local servers for testing and development, startups and small businesses looking for a professional-grade tunneling service with additional features, and educators and trainers demonstrating web applications in real-time.\n\nFRP offers high performance with a focus on speed and security, making it suitable for high-traffic applications.\n\nIt's well-suited for scenarios where flexibility and configurability are crucial. FRP can handle multiple protocols, providing a versatile solution for diverse needs. However, it requires careful configuration to optimize performance, especially in complex environments.\n\nRathole is optimized for low resource usage and high performance, achieving higher throughput than FRP and maintaining stability with a large volume of connections.\n\nIts lightweight nature makes it particularly suitable for low-end devices and embedded systems. Rathole’s efficient use of memory and processing power ensures that it performs well even under significant load, making it ideal for high-performance applications with limited resources.\n\nngrok provides balanced performance with a focus on ease of use and additional features for professional users.\n\nWhile it may not achieve the same raw performance metrics as Rathole, ngrok excels in delivering a user-friendly experience with robust functionality. Its global network infrastructure ensures reliable performance and low latency for users worldwide. The inclusion of features like load balancing, observability, and zero-trust security enhances its suitability for production environments and professional use cases.\n\nFRP requires some configuration and is best suited for users familiar with networking concepts.\n\nIts flexibility comes with a steeper learning curve, but it offers extensive customization options for those who need it. FRP is ideal for developers and IT professionals who need a highly configurable solution and are comfortable with more complex setups.\n\nRathole is simple to set up and use, ideal for users needing a quick and efficient solution.\n\nIts minimal configuration requirements and straightforward design make it accessible even for those with limited technical expertise. Rathole's hot-reloading feature allows dynamic updates to the configuration without downtime, enhancing its usability for ongoing maintenance and adjustments.\n\nngrok is extremely user-friendly with minimal setup, perfect for quick deployments and testing.\n\nIts intuitive interface and pre-configured options reduce the time and effort required to get started. ngrok's comprehensive documentation and active community support further enhance its usability. It is well-suited for developers, startups, and educators who need a reliable and easy-to-use solution for exposing local services to the internet.\n\nFRP has a straightforward installation process that involves downloading the binary for your platform and configuring the and files.\n\nWhile the setup is simple, configuring it to meet specific needs may require a good understanding of network configurations and reverse proxy setups. FRP’s detailed documentation aids in this process, making it accessible for users who are willing to invest time in learning its configuration options.\n\nRathole is also easy to install, with binaries available for multiple platforms. In fact, its configuration is simpler than FRP’s.\n\nngrok, though, is still the easiest out of any of these reverse tunnels to get set up.\n\nUsers simply download and run the binary, and they can immediately start creating tunnels with a single command. This makes ngrok particularly attractive for quick demos, testing, and development purposes.\n\nFRP has a strong community of users and contributors, with active development and frequent updates.\n\nIts open-source nature means users can contribute to the project, suggest features, and get help from other community members. The project’s GitHub repository is a hub for finding resources, reporting issues, and collaborating on improvements.\n\nThe simplicity and performance benefits of Rathole attract users who contribute to its development and provide support through forums and GitHub. While it may not have as large a community as FRP or ngrok, its user base is dedicated and actively involved in improving the tool.\n\nIts widespread use among developers means that help and resources are readily available through forums, community sites, and comprehensive official documentation. The company behind ngrok also provides professional support for its paid plans, ensuring that users can get assistance with any issues they encounter.\n\nFRP is designed to handle a wide range of use cases, from small personal projects to large-scale deployments. Its ability to support multiple protocols and extensive configuration options makes it highly scalable. Users can deploy FRP on various server setups and scale their applications as needed, making it suitable for growing businesses and expanding projects.\n\nRathole offers excellent scalability, particularly for high-performance applications on resource-constrained devices. Its efficient resource usage allows it to handle a large number of connections without significant performance degradation.\n\nngrok provides scalability through its global network infrastructure, which is designed to handle high volumes of traffic and large-scale deployments. It works quite well, and they even offer things like load balancing.\n\nFRP emphasizes security with features such as token authentication, TLS support, and IP whitelist/blacklist configurations. These security measures help protect exposed services and ensure that only authorized users can access them. FRP’s flexibility allows users to implement additional security layers based on their specific requirements.\n\nRathole provides many security features, including mandatory service tokens, optional Noise Protocol encryption, and beyond.\n\nngrok offers comprehensive security features, including automatic TLS certificates, OAuth, SAML, OIDC authentication, and webhook signature verification. Its zero-trust model ensures that all connections are authenticated and encrypted, providing a high level of security for exposed services. Enterprise features like SSO, RBAC, and audit trails further enhance ngrok’s security capabilities, making it a trusted solution for sensitive applications.\n\nFRP is completely free and open-source, making it an attractive option for budget-conscious users.\n\nRathole is also free and open-source, providing a high-performance tunneling solution without any associated costs.\n\nngrok offers a freemium model, with a free plan that includes basic features and paid plans that unlock advanced functionalities. The free plan is suitable for small projects and testing, while the paid plans provide enhanced features such as custom domains, API access, and professional support. This tiered pricing model allows users to start with the free version and upgrade as their needs grow.\n\nUltimately, the tunneling solution that's right for you just depends on your needs and use case. It's up to you to make that decision.\n\nHopefully, though, this article helped clear things up for you and made that decision easier. And hey... if not, why not just try all 3 and see what works best for you?\n\nBy the way, if you're looking for premium digital infrastructure, anywhere from production to hobbyist, xTom would love to be your next host. We offer things like colocation, dedicated servers, and transit through our xTom brand.\n\nFor scalable and self-service NVMe VPS hosting, which are great for things like reverse tunnels and development environments (but also reliable enough for production environments), you can check out our VPS line right here."
    },
    {
        "link": "https://reddit.com/r/selfhosted/comments/19bbloa/expose_a_service_behind_a_restrictive_firewall",
        "document": "I searched a lot about how to expose a service behind a CG-NAT firewall to the public internet. I tried many solutions and most didn’t work well.\n• Cloudflare tunnels terminate the TLS on the Cloudflare servers.\n• Ngrok probably works, but is closed source and proprietary.\n• Tailscale funnels are not meant for long term connections.\n• Reverse proxies on the VPS (together with the local server connecting to the VPS by VPN) usually terminate the TLS on the VPS, and the ones that don’t are complicated to set up SSL pass through.\n• SSH reverse tunnels forward only http traffic not https, so rather useless.\n\nI found this tool, which is apparently is well known (70k stars on GitHub), yet unknown (I posted a few questions on this topic and nobody pointed out this tool). It’s got two static GO binaries and two very short config files, and will apparently proxy anything:\n\nIt was very easy and fast. I’m sharing it for home labbers!\n\nYou can probably even VPN from the public directly to your firewall behind a CG-NAT, end to end encrypted!"
    },
    {
        "link": "https://github.com/fatedier/frp",
        "document": "frp is an open source project with its ongoing development made possible entirely by the support of our awesome sponsors. If you'd like to join them, please consider sponsoring frp's development.\n\nfrp is a fast reverse proxy that allows you to expose a local server located behind a NAT or firewall to the Internet. It currently supports TCP and UDP, as well as HTTP and HTTPS protocols, enabling requests to be forwarded to internal services via domain name.\n• Example Usage\n• Access your computer in a LAN network via SSH\n• Features\n• Only allowing certain ports on the server\n\nfrp is currently under development. You can try the latest release version in the branch, or use the branch to access the version currently in development.\n\nWe are currently working on version 2 and attempting to perform some code refactoring and improvements. However, please note that it will not be compatible with version 1.\n\nWe will transition from version 0 to version 1 at the appropriate time and will only accept bug fixes and improvements, rather than big feature requests.\n\nThe complexity and difficulty of the v2 version are much higher than anticipated. I can only work on its development during fragmented time periods, and the constant interruptions disrupt productivity significantly. Given this situation, we will continue to optimize and iterate on the current version until we have more free time to proceed with the major version overhaul.\n\nThe concept behind v2 is based on my years of experience and reflection in the cloud-native domain, particularly in K8s and ServiceMesh. Its core is a modernized four-layer and seven-layer proxy, similar to envoy. This proxy itself is highly scalable, not only capable of implementing the functionality of intranet penetration but also applicable to various other domains. Building upon this highly scalable core, we aim to implement all the capabilities of frp v1 while also addressing the functionalities that were previously unachievable or difficult to implement in an elegant manner. Furthermore, we will maintain efficient development and iteration capabilities.\n\nIn addition, I envision frp itself becoming a highly extensible system and platform, similar to how we can provide a range of extension capabilities based on K8s. In K8s, we can customize development according to enterprise needs, utilizing features such as CRD, controller mode, webhook, CSI, and CNI. In frp v1, we introduced the concept of server plugins, which implemented some basic extensibility. However, it relies on a simple HTTP protocol and requires users to start independent processes and manage them on their own. This approach is far from flexible and convenient, and real-world demands vary greatly. It is unrealistic to expect a non-profit open-source project maintained by a few individuals to meet everyone's needs.\n\nFinally, we acknowledge that the current design of modules such as configuration management, permission verification, certificate management, and API management is not modern enough. While we may carry out some optimizations in the v1 version, ensuring compatibility remains a challenging issue that requires a considerable amount of effort to address.\n\nWe sincerely appreciate your support for frp.\n\nTo begin, download the latest program for your operating system and architecture from the Release page.\n\nNext, place the binary and server configuration file on Server A, which has a public IP address.\n\nFinally, place the binary and client configuration file on Server B, which is located on a LAN that cannot be directly accessed from the public internet.\n\nSome antiviruses improperly mark frpc as malware and delete it. This is due to frp being a networking tool capable of creating reverse proxies. Antiviruses sometimes flag reverse proxies due to their ability to bypass firewall port restrictions. If you are using antivirus, then you may need to whitelist/exclude frpc in your antivirus settings to avoid accidental quarantine/deletion. See issue 3637 for more details.\n• Modify on server A by setting the for frp clients to connect to:\n• Modify on server B and set the field to the public IP address of your frps server:\n\nNote that the (listened on the client) and (exposed on the server) are used for traffic going in and out of the frp system, while the is used for communication between frps and frpc.\n• To access server B from another machine through server A via SSH (assuming the username is ), use the following command:\n\nThis example implements multiple SSH services exposed through the same port using a proxy of type tcpmux. Similarly, as long as the client supports the HTTP Connect proxy connection method, port reuse can be achieved in this way.\n• Deploy frps on a machine with a public IP and modify the frps.toml file. Here is a simplified configuration:\n• Deploy frpc on the internal machine A with the following configuration:\n• Deploy another frpc on the internal machine B with the following configuration:\n• To access internal machine A using SSH ProxyCommand, assuming the username is \"test\":\n• To access internal machine B, the only difference is the domain name, assuming the username is \"test\":\n\nSometimes we need to expose a local web service behind a NAT network to others for testing purposes with our own domain name.\n\nUnfortunately, we cannot resolve a domain name to a local IP. However, we can use frp to expose an HTTP(S) service.\n• Modify and set the HTTP port for vhost to 8080:\n\nIf you want to configure an https proxy, you need to set up the .\n• Modify and set to the IP address of the remote frps server. Specify the of your web service:\n• Map the A record of to either the public IP of the remote frps server or a CNAME record pointing to your original domain.\n• Modify and set to the IP address of the remote frps server. Forward DNS query requests to the Google Public DNS server :\n• Start with the following configuration:\n• Test the configuration by getting the docker version using :\n\nExpose a simple HTTP file server to access files stored in the LAN from the public Internet.\n\nConfigure as described above, then:\n• Start with the following configuration:\n• Visit from your browser and specify correct username and password to view files in on the machine.\n\nYou may substitute for the plugin, and point the to a HTTPS endpoint.\n• Start with the following configuration:\n\nTo mitigate risks associated with exposing certain services directly to the public network, STCP (Secret TCP) mode requires a preshared key to be used for access to the service from other clients.\n\nConfigure same as above.\n• Start on machine B with the following config. This example is for exposing the SSH service (port 22), and note the field for the preshared key, and that the field is removed here:\n• Start another (typically on another machine C) with the following config to access the SSH service with a security key ( field):\n• On machine C, connect to SSH on machine B, using this command:\n\nxtcp is designed to transmit large amounts of data directly between clients. A frps server is still needed, as P2P here only refers to the actual data transmission.\n\nNote that it may not work with all types of NAT devices. You might want to fallback to stcp if xtcp doesn't work.\n• Start on machine B, and expose the SSH port. Note that the field is removed:\n• Start another (typically on another machine C) with the configuration to connect to SSH using P2P mode:\n• On machine C, connect to SSH on machine B, using this command:\n\nSince v0.52.0, we support TOML, YAML, and JSON for configuration. Please note that INI is deprecated and will be removed in future releases. New features will only be available in TOML, YAML, or JSON. Users wanting these new features should switch their configuration format accordingly.\n\nRead the full example configuration files to find out even more features not described here.\n\nExamples use TOML format, but you can still use YAML or JSON.\n\nThese configuration files is for reference only. Please do not use this configuration directly to run the program as it may have various issues.\n\nEnvironment variables can be referenced in the configuration file, using Go's standard format:\n\nWith the config above, variables can be passed into program like this:\n\nwill render configuration file template using OS environment variables. Remember to prefix your reference with .\n\nYou can split multiple proxy configs into different files and include them in the main file.\n\nConfigure a port for dashboard to enable this feature:\n\nThen visit to see the dashboard, with username and password both being .\n\nAdditionally, you can use HTTPS port by using your domains wildcard or normal SSL certificate:\n\nThen visit to see the dashboard in secure HTTPS connection, with username and password both being .\n\nThe Client Admin UI helps you check and manage frpc's configuration.\n\nConfigure an address for admin UI to enable this feature:\n\nThen visit to see admin UI, with username and password both being .\n\nWhen web server is enabled, frps will save monitor data in cache for 7 days. It will be cleared after process restart.\n\nEnable dashboard first, then configure in .\n\nThere are 2 authentication methods to authenticate frpc with frps.\n\nYou can decide which one to use by configuring in and , the default one is token.\n\nConfiguring will use the configured authentication method to add and validate authentication on every heartbeat between frpc and frps.\n\nConfiguring will do the same for every new work connection between frpc and frps.\n\nWhen specifying in and - token based authentication will be used.\n\nMake sure to specify the same in and for frpc to pass frps validation\n\nWhen specifying in and - OIDC based authentication will be used.\n\nOIDC stands for OpenID Connect, and the flow used is called Client Credentials Grant.\n\nTo use this authentication type - configure and as follows:\n\nThe features are off by default. You can turn on encryption and/or compression:\n\nSince v0.50.0, the default value of and has been changed to true, and tls is enabled by default.\n\nFor port multiplexing, frp sends a first byte to dial a TLS connection. This only takes effect when you set to false.\n\nTo enforce to only accept TLS connections - configure in . This is optional.\n\nYou will need a root CA cert and at least one SSL/TLS certificate. It can be self-signed or regular (such as Let's Encrypt or another SSL/TLS certificate provider).\n\nIf you using via IP address and not hostname, make sure to set the appropriate IP address in the Subject Alternative Name (SAN) area when generating SSL/TLS Certificates.\n\nGiven an example:\n• Prepare openssl config file. It exists at in Linux System and in MacOS, and you can copy it to current path, like . If not, you can build it by yourself, like:\n\nThe fields are required for enabling HTTP API:\n\nThen run command and wait for about 10 seconds to let create or update or remove proxies.\n\nNote that global client parameters won't be modified except 'start'.\n\nYou can run command before reloading to check if there are config errors.\n\nUse to get status of all proxies. The fields are required for enabling HTTP API.\n\nin is used to avoid abuse of ports:\n\nand in frps can use same port with . frps will detect the connection's protocol and handle it correspondingly.\n\nWhat you need to pay attention to is that if you want to configure and to the same port, you need to first set to false.\n\nWe would like to try to allow multiple proxies bind a same remote port with different protocols in the future.\n\nSet in each proxy's configure to enable this feature. Supported units are and .\n\nSet to or to limit bandwidth on the client or server side. Default is .\n\nfrp supports tcp stream multiplexing since v0.10.0 like HTTP2 Multiplexing, in which case all logic connections to the same frpc are multiplexed into the same TCP connection.\n\nYou can disable this feature by modify and :\n\nKCP is a fast and reliable protocol that can achieve the transmission effect of a reduction of the average latency by 30% to 40% and reduction of the maximum delay by a factor of three, at the cost of 10% to 20% more bandwidth wasted than TCP.\n\nKCP mode uses UDP as the underlying transport. Using KCP in frp:\n\nThe number can be the same number as , since field specifies a TCP port.\n• Configure to use KCP to connect to frps:\n\nQUIC is a new multiplexed transport built on top of UDP.\n\nThe number can be the same number as , since field specifies a TCP port.\n• Configure to use QUIC to connect to frps:\n\nBy default, frps creates a new frpc connection to the backend service upon a user request. With connection pooling, frps keeps a certain number of pre-established connections, reducing the time needed to establish a connection.\n\nThis feature is suitable for a large number of short connections.\n• Configure the limit of pool count each proxy can use in :\n• Enable and specify the number of connection pool:\n\nThis feature is only available for types , , now.\n\nis used for authentication.\n\nConnections to port 80 will be dispatched to proxies in the same group randomly.\n\nFor type , in the same group should be the same.\n\nFor type , , , should be the same.\n\nHealth check feature can help you achieve high availability with load balancing.\n\nWith health check type tcp, the service port will be pinged (TCPing):\n\nWith health check type http, an HTTP request will be sent to the service and an HTTP 2xx OK response is expected:\n\nBy default frp does not modify the tunneled HTTP requests at all as it's a byte-for-byte copy.\n\nHowever, speaking of web servers and HTTP requests, your web server might rely on the HTTP header to determine the website to be accessed. frp can rewrite the header when forwarding the HTTP requests, with the field:\n\nThe HTTP request will have the header rewritten to when it reaches the actual web server, although the request from the browser probably has .\n\nSimilar to , You can override other HTTP request and response headers with proxy type .\n\nIn this example, it will set header in the HTTP request and in the HTTP response.\n\nThis feature is for proxies or proxies with the and plugins enabled.\n\nYou can get user's real IP from HTTP request headers .\n\nfrp supports Proxy Protocol to send user's real IP to local services. It support all types except UDP.\n\nHere is an example for https service:\n\nYou can enable Proxy Protocol support in nginx to expose user's real IP in HTTP header , and then read header in your web service for the real IP.\n\nAnyone who can guess your tunnel URL can access your local web server unless you protect it with a password.\n\nThis enforces HTTP Basic Auth on all requests with the username and password specified in frpc's configure file.\n\nIt can only be enabled when proxy type is http.\n\nVisit in the browser and now you are prompted to enter the username and password.\n\nIt is convenient to use configure for http and https types when many people share one frps server.\n\nResolve to the frps server's IP. This is usually called a Wildcard DNS record.\n\nNow you can visit your web service on .\n\nNote that if is not empty, should not be the subdomain of .\n\nfrp supports forwarding HTTP requests to different backend web services by url routing.\n\nspecifies the prefix of URL used for routing. frps first searches for the most specific prefix location given by literal strings regardless of the listed order.\n\nHTTP requests with URL prefix or will be forwarded to web02 and other requests to web01.\n\nfrp supports receiving TCP sockets directed to different proxies on a single port on frps, similar to and .\n\nThe only supported TCP port multiplexing method available at the moment is - HTTP CONNECT tunnel.\n\nWhen setting to anything other than 0 in frps, frps will listen on this port for HTTP CONNECT requests.\n\nThe host of the HTTP CONNECT request will be used to match the proxy in frps. Proxy hosts can be configured in frpc by configuring and / or under proxies, when .\n\nIn the above configuration - frps can be contacted on port 1337 with a HTTP CONNECT header such as:\n\nand the connection will be routed to .\n\nfrpc can connect to frps through proxy if you set OS environment variable , or if is set in frpc.toml file.\n\nIt only works when protocol is tcp.\n\nWe can use the range syntax of Go template combined with the built-in function to achieve port range mapping.\n\nThe following example, when run, will create 8 proxies named , each mapping the remote port to the local port.\n\nfrpc only forwards requests to local TCP or UDP ports by default.\n\nPlugins are used for providing rich features. There are built-in plugins such as , , , , , , and you can see example usage.\n\nand are configuration parameters used in plugin.\n\nfrp supports listening to an SSH port on the frps side and achieves TCP protocol proxying through the SSH -R protocol, without relying on frpc.\n\nWhen running , a private key file named will be automatically created in the current working directory. This generated private key file will be used by the SSH server in frps.\n\nsets up a proxy on frps that forwards the local 8080 service to the port 9090.\n\nThis is equivalent to:\n\nPlease refer to this document for more information.\n• gofrp/plugin - A repository for frp plugins that contains a variety of plugins implemented based on the frp extension mechanism, meeting the customization needs of different scenarios.\n• gofrp/tiny-frpc - A lightweight version of the frp client (around 3.5MB at minimum) implemented using the ssh protocol, supporting some of the most commonly used features, suitable for devices with limited resources.\n\nInterested in getting involved? We would like to help you!\n• Take a look at our issues list and consider sending a Pull Request to dev branch.\n• If you want to add a new feature, please create an issue first to describe the new feature, as well as the implementation approach. Once a proposal is accepted, create an implementation of the new features and submit it as a pull request.\n• Sorry for my poor English. Improvements for this document are welcome, even some typo fixes.\n• If you have great ideas, send an email to fatedier@gmail.com.\n\nNote: We prefer you to give your advise in issues, so others with a same question can search it quickly and we don't need to answer them repeatedly.\n\nIf frp helps you a lot, you can support us by:\n\nYou can have your company's logo placed on README file of this project.\n\nDonate money by PayPal to my account fatedier@gmail.com."
    },
    {
        "link": "https://github.com/fatedier/frp/blob/dev/conf/frps_full_example.toml",
        "document": "This configuration file is for reference only. Please do not use this configuration directly to run the program as it may have various issues.\n\nIf you want to enable this feature, the bindPort parameter is required, while others are optional."
    },
    {
        "link": "https://support.servbay.com/advanced-settings/how-to-use-frp",
        "document": "FRP is a high-performance reverse proxy tool that achieves internal network penetration through a client-server architecture. This guide will assist ServBay users in configuring the frpc client to set up a secure tunnel, enabling public access to local services.\n\nFRP establishes an encrypted communication tunnel between the server (frps) and the client (frpc), mapping internal network services to a public server. This solution supports various protocols, including TCP/UDP/HTTP/HTTPS, making it suitable for remote debugging and API testing in a ServBay development environment.\n\nFollow the steps below to deploy the frpc client:\n• Access the GitHub Release page to download the appropriate version.\n• Extract and deploy it to your system PATH (example for macOS ARM architecture):\n\nCreate the configuration file with the following basic structure:\n\nMapping the local ServBay HTTPS service to the public network:\n\nIn this example:\n• The domain configured for local ServBay is\n• The domain providing public services is (the domain must resolve to the frp server)\n• Access the mapped domain in your browser:\n\nThe FRP solution provides ServBay users with the following core values:\n\nIt is recommended to enable TLS encrypted communication in production environments and enforce encrypted transmission with the configuration ."
    },
    {
        "link": "https://gofrp.org/en",
        "document": "We do a Issue and Pull Request contributions workflow on GitHub. New users are always welcome!"
    },
    {
        "link": "https://ruianding.com/blog/frp-part-2-client-side-setup-windows",
        "document": "In Part 1 of this series, we explained what FRP is and how to set up the FRP server (frps) on a public-facing machine. Now it’s time to configure the FRP client (frpc) on a Windows computer so you can tunnel local services through the FRP server and make them accessible from the internet.\n• You have Windows on your local machine (e.g., Windows 10 or 11).\n• You have a local service you want to expose—for example, a web app running on port 8080.\n• The server’s firewall or security group allows inbound connections on the FRP server’s listening port (e.g., 7000).\n• Visit the FRP Releases page\n\nGo to the official FRP GitHub Releases.\n• Choose the Windows build\n\nFor most modern Windows systems, select something like (or the latest version).\n• Extract the ZIP\n\nUnzip the file into a convenient folder, e.g.: Inside this directory, you should see:\n• Example config files like , , etc.\n\nAs I metioned in previous post, while INI format is still supported (with a deprecation warning), it’s recommended to use TOML, JSON, or YAML. Here’s a TOML example named .\n\nOpen Notepad (or your favorite editor) and create :\n• server_addr: IP or domain of the server where frps is running (e.g., or ).\n• server_port: Match the from your (often 7000).\n• token: Must match the token set in the server config.\n\nBelow , you can define one or more “proxies” to tunnel specific services. Let’s look at two approaches:\n\nIf you have a domain ( ) pointing to your FRP server:\n• type = “http”: Tunneling over HTTP (or HTTPS if you configure TLS on the server side).\n• local_ip and local_port: The service on your Windows machine (e.g., a web server on port ).\n• custom_domains: FRP will direct traffic for (A record points to your server IP) to this local service.\n\nIf you do not have a domain or you just want to map a port:\n• remote_port: The port on the FRP server that will map to your local .\n\nWhen someone visits , FRP will forward the connection to on your Windows machine.\n\nIf you wish to access your Windows machine’s Remote Desktop (RDP) service through FRP, you can set up a TCP proxy that maps the local RDP port (default 3389) to a remote port on your FRP server. For example:\n• remote_port (6000): An arbitrary free port on the FRP server. You can choose a different port if needed.\n\nOnce configured, connecting to the FRP server at YOUR_SERVER_IP:6000 will forward you to your Windows machine’s RDP session.\n\nNote: Ensure that your Windows machine’s RDP is enabled and that the Windows Firewall permits inbound RDP connections. Make sure that your FRP server remote_port is enabled as well.\n\nOpen Command Prompt or PowerShell, navigate to , and run:\n\nIf everything is correct, you’ll see logs like:\n\nThis indicates that frpc successfully connected to the server and is now forwarding traffic.\n\nIf you enabled a dashboard on the server (e.g., port 7500 in your ), open:\n\nLog in with the username/password you configured ( by default). You should see the my_http or my_tcp proxy listed under “Proxies.”\n• If you used HTTP + domain: Visit (assuming your DNS points to the server IP).\n• If you used TCP + remote_port: Go to (or for raw TCP).\n• Confirm you can reach your local service (e.g., a web page, API, or database port).\n\nIf everything is set up correctly, your Windows machine’s service is now publicly accessible through the FRP server.\n• Token Mismatch\n• If your server uses a , ensure the same token is set in . Otherwise, you’ll see a “bad authentication” error.\n• Local Port Unavailable\n• Ensure the service is actually running on the port you specified ( in these examples). If your app is on a different port, adjust accordingly.\n• Firewall or NAT on the Client Side\n• Typically Windows outbound traffic is allowed, but double-check that your service and outbound port aren’t blocked.\n• Missing or Incorrect DNS\n• If you’re using a custom domain, be sure the domain’s A record points to the FRP server’s IP.\n• Server-Side Firewall\n• If the server’s firewall or security group isn’t open on the FRP port, you won’t be able to connect from Windows.\n\nRemember that traffic flows through your FRP server. The overall speed is influenced by:\n• Geographical distance & routing (especially if the server is far away)\n\nIn other words, whichever segment is the bottleneck (local network or server bandwidth) will set the effective limit.\n\nIf you want to auto-start when you log in or reboot your Windows PC, you have a few options:\n• Scheduled Task\n• Use Windows Task Scheduler to run at login or system startup.\n• Startup Folder\n• Place a shortcut to in the Windows “Startup” folder.\n• Run as a Service (3rd-Party Tools)\n• Tools like NSSM (Non-Sucking Service Manager) can help you run as a Windows service.\n\nPart 1 covered the server side: installing on a public IP host, configuring ports, setting up security groups, and launching via systemd.\n\nThis Part 2 introduced the Windows client: installing , creating a TOML config, and mapping local ports or domains to the server.\n\nWith both sides configured, your internal Windows services are now accessible online via FRP—without needing to expose your local network directly. Enjoy your newly tunneled setup!"
    }
]