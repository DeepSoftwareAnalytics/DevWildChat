[
    {
        "link": "https://mygreatlearning.com/blog/file-handling-in-cpp",
        "document": "What is File Handling in C++?\n\nFile handling in C++ is a mechanism to store the output of a program in a file and help perform various operations on it. Files help store these data permanently on a storage device.\n\nThe term “Data” is commonly referred to as known facts or information. In the present era, data plays a vital role. It helps to describe, diagnose, predict or prescribe. But to achieve all this, we need to store it somewhere. You all would argue that there are so many text editors like ‘Notepad’ and ‘MS Office’, which help us store data in the form of text. You are right! But here we are discussing at a level of programming. In contrast, text editors like ‘Notepad’ and ‘MS Office’ are pre-built and cannot be accessed at the programming level to store data. File Handling is a hot topic when it comes to storing such programming data.\n\nAlmost every programming language has a ‘File Handling’ method to deal with the storage of data. In this article, we will learn about file handling in C++. But, before that, if you are a newbie at C++, you could check out this free course on C++ to learn the basics. \n\nNow, This topic of file handling is further divided into sub-topics:\n\nBefore diving into each sub-topics, let us first learn about the header file we will be using to gain access to the file handling method. In C++, fstream library is used to handle files, and it is dealt with the help of three classes known as ofstream, ifstream and fstream.\n\nThis class helps create and write the data to the file obtained from the program’s output. It is also known as the input stream.\n\nWe use this class to read data from files and also known as the input stream.\n\nThis class is the combination of both ofstream and ifstream. It provides the capability of creating, writing and reading a file.\n\nTo access the following classes, you must include the fstream as a header file like how we declare iostream in the header.\n\nAfter including the header file, there comes a question saying do we need to create the file within the program or else do we need to use an existing file. But this isn’t that difficult to answer because, in C++, we get four different methods to handle files. Let’s discuss them one by one.\n\nC++ provides us with four different operations for file handling. They are:\n• open() – This is used to create a file.\n• read() – This is used to read the data from the file.\n• write() – This is used to write new data to file.\n• close() – This is used to close the file.\n\nWe will look into each of these and try to understand them better.\n\nTo read or enter data to a file, we need to open it first. This can be performed with the help of ‘ifstream’ for reading and ‘fstream’ or ‘ofstream’ for writing or appending to the file. All these three objects have open() function pre-built in them.\n\nFileName – It denotes the name of file which has to be opened.\n\nMode – There different mode to open a file and it explained in this article.\n\nIn C++, we can use two modes simultaneously with the help of | (OR) operator.\n• Here we have an iostream library, which is responsible for input/output stream.\n• We also have a fstream library, which is responsible for handling files.\n• Creating an object of the fstream class and named it as ‘FileName’.\n• On the above-created object, we have to apply the open() function to create a new file, and the mode is set to ‘out’ which will allow us to write into the file.\n• We use the ‘if’ statement to check for the file creation.\n• Prints the message to console if the file doesn’t exist.\n• Prints the message to console if the file exists/created.\n• We use the close() function on the object to close the file.\n\nTill now, we learned how to create the file using C++. Now, we will learn how to write data to file which we created before. We will use fstream or ofstream object to write data into the file and to do so; we will use stream insertion operator (<<) along with the text enclosed within the double-quotes.\n\nWith the help of open() function, we will create a new file named ‘FileName’ and then we will set the mode to ‘ios::out’ as we have to write the data to file.\n• Here we have an iostream library, which is responsible for input/output stream.\n• We also have a fstream library, which is responsible for handling files.\n• Creating an object of the fstream class and named it as ‘FileName’.\n• On the above-created object, we have to apply the open() function to create a new file, and the mode is set to ‘out’ which will allow us to write into the file.\n• We use the ‘if’ statement to check for the file creation.\n• Prints the message to console if the file doesn’t exist.\n• Prints the message to console if the file exists/created.\n• Writing the data to the created file.\n• We use the close() function on the object to close the file.\n\nFile created and data got written to file\n\nReading from file in C++\n\nGetting the data from the file is an essential thing to perform because without getting the data, we cannot perform any task. But don’t worry, C++ provides that option too. We can perform the reading of data from a file with the CIN to get data from the user, but then we use CIN to take inputs from the user’s standard console. Here we will use fstream or ifstream.\n\nHello World, Thank You for Visiting Great Learning.\n• Here we have an iostream library, which is responsible for input/output stream.\n• We also have a fstream library which is responsible for handling files.\n• Creating an object of the fstream class and named it ‘FileName’.\n• On the above-created object, we have to apply the open() function to create a new file, and the mode is set to ‘in’ which will allow us to read from the file.\n• We use the ‘if’ statement to check for the file creation.\n• Prints the message to console if the file doesn’t exist.\n• Iterating of the file with the help of while loop.\n• Getting the file data to the variable x.\n• Here we are using if condition with eof() which stands for the end of the file to tell the compiler to read till the file’s end.\n• We use the ‘break’ statement to stop the reading from file when it reaches the end.\n• The print statement to print the content that is available in the variable x.\n• We use the close() function on the object to close the file\n\nHello World, Thank You for Visiting Great Learning.\n\nWe can also use inFile to read from the file. Here, takes in the file stream, which is your file data, and uses a space delimiter (breaks it up by whitespace) and then puts the contents in the variable S.\n\nIf we had a file that had the data:\n\nand we used inFile >> S here, i.e.:\n\nWe will get the output:\n\nThe words will continue to return ‘true’ until there are no more items separated by whitespace.\n\nClosing a file is a good practice, and it is must to close the file. Whenever the C++ program comes to an end, it clears the allocated memory, and it closes the file. We can perform the task with the help of close() function.\n• Here we have an iostream library, which is responsible for input/output stream.\n• We also have a fstream library, which is responsible for handling files.\n• Creating an object of the fstream class and named it as ‘FileName’.\n• On the above-created object, we will apply the open() function to create a new file, and the mode is set to ‘out’ which allows us to write into the file.\n• We use the ‘if’ statement to check for the file creation.\n• Prints the message to console if the file doesn’t exist.\n• Prints the message to console if the file opened or not.\n• We use the close() function on the object to close the file.\n\nWe can reposition the file-position pointer in istream and ostream using its special member functions. These member functions are ‘seekg’ and ‘seekp’. ‘seekg’ or ‘seek get’ is used for istream and ‘seekp’ or ‘seek put’ is used for ostream.\n\nBoth these member functions take long integer as arguments. A second argument is used to specify the direction of seek. The seek directions can be ios::beg( for positioning in the beginning of a stream), ios::cur( for positioning relative to a current position of a stream) and ios::end( to position relative to the end of a stream).\n\nThis brings us to the end of the blog on the concept of File Handling in C++. We hope that you found this comprehensive and helpful and were able to gain the required knowledge. If you’re interested in expanding your skills beyond C++, you can explore a variety of free courses with certificates to broaden your knowledge and earn certifications.\n\nAlso, if you are preparing for Interviews, check out these Interview Questions for C++ to ace it like a pro."
    },
    {
        "link": "https://stackoverflow.com/questions/2575116/fopen-fopen-s-and-writing-to-files",
        "document": "is a variant of which contains parameter validation and hands back an error code instead of a pointer in case something goes wrong during the open process. It's more secure than the base variant because it accounts for more edge conditions. The compiler is warning you to use it because represents a potential exploitation vector in your application.\n\nYou can specify digits of precision to the family of functions by using the specifier , where x is the digits of precision you want in the output. A varies in precision from platform to platform, but you can generally bet on it being at least 16 digits of decimal precision.\n\nEdit: While I'm not entirely on board with the others who are suggesting that is a complete waste of time, it does represent a pretty low chance of exploitation and it isn't widely supported. Some of the other functions warned about under C4996 are much more serious vulnerabilities, however, and using is the equivalent of turning off the alarm for both \"you left your bedroom door unlocked\" and \"you left a nuclear bomb in the kitchen\".\n\nAs long as you aren't restricted to using \"pure C\" for your project (e.g. for a school assignment or an embedded microcontroller), you would do well to exploit the fact that almost all modern C compilers are also C++ compilers and use the C++ variants of all of these I/O functions in order to get both improved security and compatibility at the same time."
    },
    {
        "link": "https://stackoverflow.com/questions/25903590/c-vs-c-file-handling",
        "document": "An interesting critical comparison can be found here.\n\nNot exactly polite, but makes to think...\n\nThe C++ FQA (that is a critical response to the C++ FAQ) is often considered by the C++ community a \"stupid joke issued by a silly guy the even don't understand what C++ is or wants to be\"(cit. from the FQA itself).\n\nThese kind of argumentation are often used to flame (or escape from) religion battles between C++ believers, Others languages believers or language atheists each in his own humble opinion convinced to be in something superior to the other.\n\nI'm not interested in such battles, I just like to stimulate critical reasoning about the pros and cons argumentation. The C++ FQA -in this sens- has the advantage to place both the FQA and the FAQ one over the other, allowing an immediate comparison. And that the only reason why I referenced it.\n\nFollowing TonyD comments, below (tanks for them, I makes me clear my intention need a clarification...), it must be noted that the OP is not just discussing the and (I just talk about them in my comments just for brevity) but the entire function-set that makes up the I/O model of C and C++.\n\nWith this idea in mind, think also to other \"imperative\" languages (Java, Python, D ...) and you'll see they are all more conformant to the C model than C++. Sometimes making it even type safe (what the C model is not, and that's its major drawback).\n\nWhat my point is all about\n\nAt the time C++ came along as mainstream (1996 or so) the library (note the \".h\": pre-ISO) was in a language where templates where not yet fully available, and, essentially, no type-safe support for varadic functions (we have to wait until C++11 to get them), but with type-safe overloaded functions.\n\nThe idea of oveloading retuning it's first parameter over and over is -in fact- a way to chain a variable set of arguments using only a binary function, that can be overload in a type-safe manner. That idea extends to whatever \"state management function\" (like or ) through manipulators (like ) appear as a natural consequence. This points -despite of what you may thing to the FQA author- are real facts. And is also a matter of fact that FQA is the only site I found that talks about it.\n\nThat said, years later, when the D language was designed starting offering varadic templates, the function was added in the D standard library providing a -like syntax, but also being perfectly type-safe. (see here)\n\nNowadays C++11 also have varadic templates ... so the same approach can be putted in place just in the same way.\n\nBoth C++ and C io models appear \"outdated\" respect to a modern programming style. C retain speed, C++ type safety and a \"more flexible abstraction for localization\" (but I wonder how many C++ programmers are in the world that are aware of locales and facets...) at a runtime-cost (jut track with a debugger the << of a number, going through stream, buffer locale and facet ... and all the related virtual functions!).\n\nThe C model, is also easily extensible to parametric messages (the one the order of the parameters depends on the localization of the text they are in) with format strings like\n\nThe C++ model has no concept of \"format string\": the parameter order is fixed and itermixed with the text.\n\nBut C++11 varadic templates can be used to provide a support that:\n• can offer both compile-time and run-time locale selection\n• can offer both compile-time and run-time parametric order\n\nIs it time to standardize a new C++ i/o model ?"
    },
    {
        "link": "https://reddit.com/r/cpp/comments/x0o8cs/file_handling_in_c",
        "document": "In C++ we have multiple ways to work with files:\n• The C API (fopen, fclose, etc). It is not terrible, but it is not RAII friendly and therefore harder to make exception-safe.\n• IOStreams. Terribly designed, not exception friendly. The exception API it does have is very error-prone. Just all-around a terrible experience.\n• Whatever the OS provides. Typically a C API with all the downsides of (1), in addition to not being portable.\n\nAll of that sucks. But having said that, I don't see a de-facto standard library to deal with files in a cross-platform manner for C++. Nothing universally accepted.\n\nWhat is everyone using for dealing with files in C++? Am I missing something?\n\nI am tempted to make one myself, but such an obvious thing surely can't go unnoticed for 40 years, right?"
    },
    {
        "link": "https://reddit.com/r/cpp/comments/1g1qsqu/c_file_reading_guidance_on_the_options",
        "document": "I've been exploring file IO a bit more, particularly reading files into an application, and as with many things in C++ I'm finding that there are many ways to do the same thing. With this post I am not asking \"what is the best way to load a file in C++\". I'm willing to bet the answer to this question is \"it depends\" (although if I'm wrong I'd love to know). Instead I'm hoping to get some clarity on different methods and options so that I can make a well-informed decision on the best way to handling reading a file for a given circumstance. Specifically, I am interested in both what the recommendations are, and (if different) what the actual common way of doing things are, and why they might be different.\n\nMy first area of questions concerns the three common methods I see in examples for how to read a file. In this example I am simply trying to read the contents of a file into a string. I am making the assumption that the entire file can reasonably fit in a single buffer. I have broadly seen three ideas thrown around, which I will show in examples below. For the sake of readability, assume the following snippet proceeds each of the example snippets (I have omitted error checks for brevity).\n\nThis idea of fetching each line and appending it to some buffer is the most common one I see, but I'm not entirely sure why. I would have thought that I would be more efficient to load the entire file (or chunk of a file) in a single call (as in option 2). I can see this option being useful if you need to process each line before appending it to the string, but beyond that I don't see why this is so common. Also I'm not sure why but I almost never see anyone 'reserve' the memory before filling it with this method. I could be wrong but my understanding is that without reserving you would get multiple memory reallocations as the underlying array is resized to fit the new data. Is this correct?\n\nThis is what I thought would be the most recommended way of doing things, but I haven't seen it as much. If I understand things correctly I this should just copy the entire file contents into the string in one go, which I would imagine would be more efficient than multiple calls.\n\nEven simpler than the previous two, I see this one a bit more, i'm guessing because of the simplicity of it. Would this be as performant as the other two options though? I haven't really wrapped my head around how works under the hood, so I'm not sure what the efficiency of this would look like.\n\nOf these three methods, where would be the best scenarios to use each? Is there any meaningful performance difference between each? Are there philosophical reasons why an option would be preferred or avoided?\n\nThrough my readings I have seen conflicting claims about C++ IO-streams vs C File IO functions. The most common one is performance. One side claims that streams are significantly slower, and the other says that streams are just as fast if not faster than C File IO. (I have some a little evidence that supports the first position but not enough to be confident).\n\nMy questions about Streams vs C-Style File IO are:\n• Are C++ streams actually that much slower than C File IO?\n• If they are, are the features they have like RAII and exception support worth the speed decrease?\n• What is more common to see in real codebases?\n\nFor the first question, if anyone can provide benchmarks that would be amazing. I've found some but not many so it be great to see some more testing results.\n\nShould we be disabling sync_with_stdio?\n\nThis final question is pretty self explanatory. The reason I ask is because I've seen claims that setting sync_with_stdio significantly improves the performance, but I haven't found much evidence that proves this either way. I also don't see the suggestion very often so I'm wondering if there is a reason for that. Is disabling sync_with_stdio something that is generally recommended in practice? If not, why?"
    },
    {
        "link": "https://learn.microsoft.com/en-us/cpp/c-runtime-library/filename-search-functions?view=msvc-170",
        "document": "These functions search for and close searches for specified file names:\n\nThe function provides information about the first instance of a file name that matches the file specified in the argument. You can use in any combination of wildcard characters that is supported by the host operating system.\n\nThe functions return file information in a structure, which is defined in . Various functions in the family use many variations on the structure. The basic structure includes the following elements:\n\n\n\n Time of file creation ( for FAT file systems). This time is stored in UTC format. To convert to the local time, use .\n\n\n\n Time of the last file access ( for FAT file systems). This time is stored in UTC format. To convert to the local time, use .\n\n\n\n Time of the last write to file. This time is stored in UTC format. To convert to the local time, use .\n\n\n\n Length of the file in bytes.\n\n[ ] -terminated name of matched file or directory, without the path.\n\nIn file systems that don't support the creation and last access times of a file, such as the FAT system, the and fields are always .\n\nis defined in as 260 bytes.\n\nYou can't specify target attributes (such as ) to limit the find operation. These attributes are returned in the field of the structure and can have the following values (defined in ). Users shouldn't rely on these attributes being the only values possible for the field.\n\n\n\n Archive. Set whenever the file is changed and cleared by the command. Value: .\n\n\n\n Hidden file. Not often seen with the command, unless you use the option. Returns information about normal files and files that have this attribute. Value: .\n\n\n\n Normal. File has no other attributes set and can be read or written to without restriction. Value: .\n\n\n\n Read-only. File can't be opened for writing and a file that has the same name can't be created. Value: .\n\n\n\n System file. Not ordinarily seen with the command, unless the or option is used. Value: .\n\nfinds the next name, if any, that matches the argument specified in an earlier call to . The argument should point to a structure initialized by the previous call to . If a match is found, the structure contents are changed as described earlier. Otherwise, it's left unchanged. closes the specified search handle and releases all associated resources for both and . The handle returned by either or must first be passed to , before modification operations, such as deleting, can be performed on the directories that form the paths passed to them.\n\nYou can nest the functions. For example, if a call to or finds the file that is a subdirectory, a new search can be initiated with another call to or .\n\nand are wide-character versions of and . The structure argument of the wide-character versions has the data type, which is defined in and in . The fields of this data type are the same as the fields of the data type, except that in the field is of type instead of type . Otherwise, and behave identically to and .\n\nand use the 64-bit time type. If you must use the old 32-bit time type, you can define . The versions of these functions that have the suffix in their names use the 32-bit time type, and the ones with the suffix use the 64-bit time type.\n\nFunctions , , , and also behave identically to the 32-bit time type versions of these functions except they use and return 64-bit file lengths. Functions , , , and use the 64-bit time type but use 32-bit file lengths. These functions use appropriate variations of the type in which the fields have different types for the time and the file size.\n\nis actually a macro that evaluates to (or if is defined). The following table summarizes the variations on :"
    },
    {
        "link": "https://stackoverflow.com/questions/36419923/understanding-findfirst-and-findnext",
        "document": "Need to understand how _findfirst and _findnext works with pattern inputs.\n\nI used to following code to analyze their functionality but the results confuse me.\n\nThe results : I have four files in the folder.\n\nOk. There are no files with ext tx\n\nOk. There are no files with ext txt_ also\n\n??? I asked only for ext txt. Why is txt_bck displayed?\n\nNow what is the diff between this and prev?\n\nExpected \"?\" wildcard would match exactly one character but it matched 0 also."
    },
    {
        "link": "https://learn.microsoft.com/en-us/windows/win32/fileio/listing-the-files-in-a-directory",
        "document": "The following example calls FindFirstFile, FindNextFile, and FindClose to list files in a specified directory."
    },
    {
        "link": "https://stackoverflow.com/questions/6567697/replacement-for-findfirst-and-findnext",
        "document": "Is there any replacement for and . I am using and it doesn't support these functions neither the header file ?\n\nI was looking to count the number of files in the directory using these functions but i am having a problem without these functions.\n\nIf there is no replacement of the mentioned functions is there any other way out. ? Some other functions ?"
    },
    {
        "link": "https://forums.codeguru.com/showthread.php?94259-How-to-get-file-in-the-directories",
        "document": "\n• None How to get file in the directories? Thread: How to get file in the directories?\n• How to get file in the directories? hi,\n\n I want to search the directory tree to get some named file, the function is like the performance of Windows' Find but without opening the dialog , how to do it?\n\n \n\n Thanks.\n• Re: How to get file in the directories? Try _findfirst and _findnext from <io.h>\n\n \n\n Here some info and a sammple code. Maybe it's not the right sample but right now I don't have time to write a sample code (and test it (- . So, if this it's useful for u plese let me know. If don't let me know and I will try to send you a sample code in next days.\n\n \n\n Regards,\n\n Oliviu Burlacu\n\n \n\n These functions search for and close searches for specified filenames. \n\n \n\n _findclose\n\n \n\n \n\n _findnext, _findnexti64, _wfindnext, _wfindnexti64\n\n \n\n \n\n _findfirst, _findfirsti64, _wfindfirst, _wfindfirsti64 \n\n Remarks\n\n \n\n The _findfirst function provides information about the first instance of a filename that matches the file specified in the filespec argument. Any wildcard combination supported by the host operating system can be used in filespec. File information is returned in a _finddata_t structure, defined in IO.H. The _finddata_t structure includes the following elements:\n\n \n\n unsigned attrib\n\n \n\n File attribute\n\n \n\n time_t time_create\n\n \n\n Time of file creation ( Ã¢â¬â1L for FAT file systems)\n\n \n\n time_t time_access\n\n \n\n Time of last file access (Ã¢â¬â1L for FAT file systems)\n\n \n\n time_t time_write\n\n \n\n Time of last write to file\n\n \n\n _fsize_t size\n\n \n\n Length of file in bytes\n\n \n\n char name[_MAX_FNAME]\n\n \n\n Null-terminated name of matched file/directory, without the path\n\n \n\n In file systems that do not support the creation and last access times of a file, such as the FAT system, the time_create and time_access fields are always Ã¢â¬â1L.\n\n \n\n _MAX_FNAME is defined in STDLIB.H as 256 bytes.\n\n \n\n You cannot specify target attributes (such as _A_RDONLY) by which to limit the find operation. This attribute is returned in the attrib field of the _finddata_t structure and can have the following values (defined in IO.H).\n\n \n\n _A_ARCH\n\n \n\n Archive. Set whenever the file is changed, and cleared by the BACKUP command. Value: 0x20\n\n \n\n _A_HIDDEN\n\n \n\n Hidden file. Not normally seen with the DIR command, unless the /AH option is used. Returns information about normal files as well as files with this attribute. Value: 0x02\n\n \n\n _A_NORMAL\n\n \n\n Normal. File can be read or written to without restriction. Value: 0x00\n\n \n\n _A_RDONLY\n\n \n\n Read-only. File cannot be opened for writing, and a file with the same name cannot be created. Value: 0x01\n\n \n\n _A_SUBDIR\n\n \n\n Subdirectory. Value: 0x10\n\n \n\n _A_SYSTEM\n\n \n\n System file. Not normally seen with the DIR command, unless the /A or /A:S option is used. Value: 0x04\n\n \n\n _findnext finds the next name, if any, that matches the filespec argument specified in a prior call to _findfirst. The fileinfo argument should point to a structure initialized by a previous call to _findfirst. If a match is found, the fileinfo structure contents are altered as described above. _findclose closes the specified search handle and releases all associated resources for both _findfirst and _findnext. The handle returned by either _findfirst or _findnext must first be passed to _findclose, before modification operations, such as deleting, can be performed on the directories that form the paths passed to them.\n\n \n\n The _find functions allow nested calls. For example, if the file found by a call to _findfirst or _findnext is a subdirectory, a new search can be initiated with another call to _findfirst or _findnext.\n\n \n\n _wfindfirst and _wfindnext are wide-character versions of _findfirst and _findnext. The structure argument of the wide-character versions has the _wfinddata_t data type, which is defined in IO.H and in WCHAR.H. The fields of this data type are the same as those of the _finddata_t data type, except that in _wfinddata_t the name field is of type wchar_t rather than type char. Otherwise _wfindfirst and _wfindnext behave identically to _findfirst and _findnext. Functions _findfirsti64, _findnexti64, _wfindfirsti64, and _wfindnexti64 also behave identically except they use and return 64-bit file lengths.\n\n \n\n Example\n\n \n\n /* FFIND.C: This program uses the 32-bit _find functions to print\n\n * a list of all files (and their attributes) with a .C extension\n\n * in the current directory.\n\n */\n\n \n\n #include <stdio.h>\n\n #include <io.h>\n\n #include <time.h>\n\n \n\n void main( void )\n\n {\n\n struct _finddata_t c_file;\n\n long hFile;\n\n \n\n /* Find first .c file in current directory */\n\n if( (hFile = _findfirst( \"*.c\", &c_file )) == -1L )\n\n printf( \"No *.c files in current directory!\n\n\" );\n\n else\n\n {\n\n printf( \"Listing of .c files\n\n\n\n\" );\n\n printf( \"\n\nRDO HID SYS ARC FILE DATE %25c SIZE\n\n\", ' ' );\n\n printf( \"--- --- --- --- ---- ---- %25c ----\n\n\", ' ' );\n\n printf( ( c_file.attrib & _A_RDONLY ) ? \" Y \" : \" N \" );\n\n printf( ( c_file.attrib & _A_SYSTEM ) ? \" Y \" : \" N \" );\n\n printf( ( c_file.attrib & _A_HIDDEN ) ? \" Y \" : \" N \" );\n\n printf( ( c_file.attrib & _A_ARCH ) ? \" Y \" : \" N \" );\n\n printf( \" %-12s %.24s %9ld\n\n\",\n\n c_file.name, ctime( &( c_file.time_write ) ), c_file.size );\n\n \n\n /* Find the rest of the .c files */\n\n while( _findnext( hFile, &c_file ) == 0 )\n\n {\n\n printf( ( c_file.attrib & _A_RDONLY ) ? \" Y \" : \" N \" );\n\n printf( ( c_file.attrib & _A_SYSTEM ) ? \" Y \" : \" N \" );\n\n printf( ( c_file.attrib & _A_HIDDEN ) ? \" Y \" : \" N \" );\n\n printf( ( c_file.attrib & _A_ARCH ) ? \" Y \" : \" N \" );\n\n printf( \" %-12s %.24s %9ld\n\n\",\n\n c_file.name, ctime( &( c_file.time_write ) ), c_file.size );\n\n }\n\n \n\n _findclose( hFile );\n\n }\n\n }\n• Re: How to get file in the directories? hi, Oliviu\n\n \n\n Thank you, I appriciate your help and I will study the code you sent me, also, I have found a CFileFind Class in the MFC and taming it now.\n\n \n\n Regards,\n\n Buzz Fox Zhubo\n• You may not post new threads\n• You may not post replies\n• You may not post attachments\n• You may not edit your posts\n\n\n\n\n\n\n\n \n\n \n\n Click Here to Expand Forum to Full Width \n\n \n\n * The Best Reasons to Target Windows 8\n\n Learn some of the best reasons why you should seriously consider bringing your Android mobile development expertise to bear on the Windows 8 platform.\n• * Porting from Android to Windows 8: The Real Story\n\n Do you have an Android application? How hard would it really be to port to Windows 8?\n• * Guide to Porting Android Applications to Windows 8\n\n If you've already built for Android, learn what do you really need to know to port your application to Windows Phone 8.\n• * HTML5 Development Center\n\n Our portal for articles, videos, and news on HTML5, CSS3, and JavaScript\n• * Windows App Gallery\n\n See the Windows 8.x apps we've spotlighted or submit your own app to the gallery!"
    }
]