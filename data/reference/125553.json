[
    {
        "link": "https://stackoverflow.com/questions/34495614/python-bit-trick-to-find-number-of-bits-required-to-represent-a-number",
        "document": "In python I want to calculate the number of bits required to represent an unsigned number. For eg:\n\nI am simply calculating it as follows\n\nIs there any other better way to calculate this ? purely using bit manipulation so that I can use it on other languages as well ?"
    },
    {
        "link": "https://realpython.com/python-bitwise-operators",
        "document": "Computers store all kinds of information as a stream of binary digits called bits. Whether you’re working with text, images, or videos, they all boil down to ones and zeros. Python’s bitwise operators let you manipulate those individual bits of data at the most granular level.\n\nYou can use bitwise operators to implement algorithms such as compression, encryption, and error detection as well as to control physical devices in your Raspberry Pi project or elsewhere. Often, Python isolates you from the underlying bits with high-level abstractions. You’re more likely to find the overloaded flavors of bitwise operators in practice. But when you work with them in their original form, you’ll be surprised by their quirks!\n\nIn this tutorial, you’ll learn how to:\n• Read and write binary data in a platform-agnostic way\n• Use bitmasks to pack information on a single byte\n\nTo get the complete source code of the digital watermarking example, and to extract a secret treat hidden in an image, click the link below:\n\nBefore moving on, take a moment to brush up your knowledge of the binary system, which is essential to understanding bitwise operators. If you’re already comfortable with it, then go ahead and jump to the Bitwise Logical Operators section below. There are an infinite number of ways to represent numbers. Since ancient times, people have developed different notations, such as Roman numerals and Egyptian hieroglyphs. Most modern civilizations use positional notation, which is efficient, flexible, and well suited for doing arithmetic. A notable feature of any positional system is its base, which represents the number of digits available. People naturally favor the base-ten numeral system, also known as the decimal system, because it plays nicely with counting on fingers. Computers, on the other hand, treat data as a bunch of numbers expressed in the base-two numeral system, more commonly known as the binary system. Such numbers are composed of only two digits, zero and one. Note: In math books, the base of a numeric literal is commonly denoted with a subscript that appears slightly below the baseline, such as 42 . For example, the binary number 10011100 is equivalent to 156 in the base-ten system. Because there are ten numerals in the decimal system—zero through nine—it usually takes fewer digits to write the same number in base ten than in base two. Note: You can’t tell a numeral system just by looking at a given number’s digits. For example, the decimal number 101 happens to use only binary digits. But it represents a completely different value than its binary counterpart, 101 , which is equivalent to 5 . The binary system requires more storage space than the decimal system but is much less complicated to implement in hardware. While you need more building blocks, they’re easier to make, and there are fewer types of them. That’s like breaking down your code into more modular and reusable pieces. More importantly, however, the binary system is perfect for electronic devices, which translate digits into different voltage levels. Because voltage likes to drift up and down due to various kinds of noise, you want to keep sufficient distance between consecutive voltages. Otherwise, the signal might end up distorted. By employing only two states, you make the system more reliable and resistant to noise. Alternatively, you could jack up the voltage, but that would also increase the power consumption, which you definitely want to avoid. Imagine for a moment that you had only two fingers to count on. You could count a zero, a one, and a two. But when you ran out of fingers, you’d need to note how many times you had already counted to two and then start over until you reached two again: Every time you wrote down another pair of fingers, you’d also need to group them by powers of two, which is the base of the system. For example, to count up to thirteen, you would have to use both of your fingers six times and then use one more finger. Your fingers could be arranged as one eight, one four, and one one. These powers of two correspond to digit positions in a binary number and tell you exactly which bits to switch on. They grow right to left, starting at the least-significant bit, which determines if the number is even or odd. Positional notation is like the odometer in your car: Once a digit in a particular position reaches its maximum value, which is one in the binary system, it rolls over to zero and the one carries over to the left. This can have a cascading effect if there are already some ones to the left of the digit. Now that you know the basic principles of the binary system and why computers use it, you’re ready to learn how they represent data with it. Before any piece of information can be reproduced in digital form, you have to break it down into numbers and then convert them to the binary system. For example, plain text can be thought of as a string of characters. You could assign an arbitrary number to each character or pick an existing character encoding such as ASCII, ISO-8859-1, or UTF-8. In Python, strings are represented as arrays of Unicode code points. To reveal their ordinal values, call on each of the characters: The resulting numbers uniquely identify the text characters within the Unicode space, but they’re shown in decimal form. You want to rewrite them using binary digits: Notice that bit-length, which is the number of binary digits, varies greatly across the characters. The euro sign ( ) requires fourteen bits, while the rest of the characters can comfortably fit on seven bits. Note: Here’s how you can check the bit-length of any integer number in Python: Without a pair of parentheses around the number, it would be treated as a floating-point literal with a decimal point. Variable bit-lengths are problematic. If you were to put those binary numbers next to one another on an optical disc, for example, then you’d end up with a long stream of bits without clear boundaries between the characters: One way of knowing how to interpret this information is to designate fixed-length bit patterns for all characters. In modern computing, the smallest unit of information, called an octet or a byte, comprises eight bits that can store 256 distinct values. You can pad your binary code points with leading zeros to express them in terms of bytes: Now each character takes two bytes, or 16 bits. In total, your original text almost doubled in size, but at least it’s encoded reliably. You can use Huffman coding to find unambiguous bit patterns for every character in a particular text or use a more suitable character encoding. For example, to save space, UTF-8 intentionally favors Latin letters over symbols that you’re less likely to find in an English text: Encoded according to the UTF-8 standard, the entire text takes six bytes. Since UTF-8 is a superset of ASCII, the letters , , and occupy one byte each, whereas the euro symbol takes three bytes in this encoding: Other types of information can be digitized similarly to text. Raster images are made of pixels, with every pixel having channels that represent color intensities as numbers. Sound waveforms contain numbers corresponding to air pressure at a given sampling interval. Three-dimensional models are built from geometric shapes defined by their vertices, and so forth. At the end of the day, everything is a number.\n\nYou can use bitwise operators to perform Boolean logic on individual bits. That’s analogous to using logical operators such as , , and , but on a bit level. The similarities between bitwise and logical operators go beyond that. It’s possible to evaluate Boolean expressions with bitwise operators instead of logical operators, but such overuse is generally discouraged. If you’re interested in the details, then you can expand the box below to find out more. The ordinary way of specifying compound Boolean expressions in Python is to use the logical operators that connect adjacent predicates, like this: Here, you check if the user is at least eighteen years old and if they haven’t opted out of gambling. You can rewrite that condition using bitwise operators: Although this expression is syntactically correct, there are a few problems with it. First, it’s arguably less readable. Second, it doesn’t work as expected for all groups of data. You can demonstrate that by choosing specific operand values: The expression made of the bitwise operators evaluates to , while the same expression built from the logical operators evaluates to . That’s because bitwise operators take precedence over the comparison operators, changing how the whole expression is interpreted: It’s as if someone put implicit parentheses around the wrong operands. To fix this, you can put explicit parentheses, which will enforce the correct order of evaluation: However, you no longer get a Boolean result. Python bitwise operators were designed primarily to work with integers, so their operands automatically get casted if needed. This may not always be possible, though. While you can use truthy and falsy integers in a Boolean context, it’s a known antipattern that can cost you long hours of unnecessary debugging. You’re better off following the Zen of Python to save yourself the trouble. Last but not least, you may deliberately want to use bitwise operators to disable the short-circuit evaluation of Boolean expressions. Expressions using logical operators are evaluated lazily from left to right. In other words, the evaluation stops as soon as the result of the entire expression is known: In the second example, the right operand isn’t called at all because the value of the entire expression has already been determined by the value of the left operand. No matter what the right operand is, it won’t affect the result, so there’s no point in calling it unless you rely on side effects. There are idioms, such as falling back to a default value, that take advantage of this peculiarity: A Boolean expression takes the value of the last evaluated operand. The operand becomes truthy or falsy inside the expression but retains its original type and value afterward. In particular, a positive integer on the left gets propagated, while a zero gets discarded. Even though knowing the left operand is sufficient to determine the value of the entire expression, all operands are always evaluated unconditionally. Unless you have a strong reason and know what you’re doing, you should use bitwise operators only for controlling bits. It’s too easy to get it wrong otherwise. In most cases, you’ll want to pass integers as arguments to the bitwise operators. The bitwise AND operator ( ) performs logical conjunction on the corresponding bits of its operands. For each pair of bits occupying the same position in the two numbers, it returns a one only when both bits are switched on: The resulting bit pattern is an intersection of the operator’s arguments. It has two bits turned on in the positions where both operands are ones. In all other places, at least one of the inputs has a zero bit. Arithmetically, this is equivalent to a product of two bit values. You can calculate the bitwise AND of numbers a and b by multiplying their bits at every index i: A one multiplied by one gives one, but anything multiplied by zero will always result in zero. Alternatively, you can take the minimum of the two bits in each pair. Notice that when operands have unequal bit-lengths, the shorter one is automatically padded with zeros to the left. The bitwise OR operator ( ) performs logical disjunction. For each corresponding pair of bits, it returns a one if at least one of them is switched on: The resulting bit pattern is a union of the operator’s arguments. It has five bits turned on where either of the operands has a one. Only a combination of two zeros gives a zero in the final output. The arithmetic behind it is a combination of a sum and a product of the bit values. To calculate the bitwise OR of numbers a and b, you need to apply the following formula to their bits at every index i: It’s almost like a sum of two bits but clamped at the higher end so that it never exceeds the value of one. You could also take the maximum of the two bits in each pair to get the same result. Unlike bitwise AND, OR, and NOT, the bitwise XOR operator ( ) doesn’t have a logical counterpart in Python. However, you can simulate it by building on top of the existing operators: It evaluates two mutually exclusive conditions and tells you whether exactly one of them is met. For example, a person can be either a minor or an adult, but not both at the same time. Conversely, it’s not possible for a person to be neither a minor nor an adult. The choice is mandatory. The name XOR stands for “exclusive or” since it performs exclusive disjunction on the bit pairs. In other words, every bit pair must contain opposing bit values to produce a one: Visually, it’s a symmetric difference of the operator’s arguments. There are three bits switched on in the result where both numbers have different bit values. Bits in the remaining positions cancel out because they’re the same. Similarly to the bitwise OR operator, the arithmetic of XOR involves a sum. However, while the bitwise OR clamps values at one, the XOR operator wraps them around with a sum modulo two: Modulo is a function of two numbers—the dividend and the divisor—that performs a division and returns its remainder. In Python, there’s a built-in modulo operator denoted with the percent sign ( ). Once again, you can confirm the formula by looking at an example: The sum of two zeros or two ones yields a whole number when divided by two, so the result has a remainder of zero. However, when you divide the sum of two different bit values by two, you get a fraction with a remainder of one. A more straightforward formula for the XOR operator is the difference between the maximum and the minimum of both bits in each pair. The last of the bitwise logical operators is the bitwise NOT operator ( ), which expects just one argument, making it the only unary bitwise operator. It performs logical negation on a given number by flipping all of its bits: The inverted bits are a complement to one, which turns zeros into ones and ones into zeros. It can be expressed arithmetically as the subtraction of individual bit values from one: Here’s an example showing one of the numbers used before: While the bitwise NOT operator seems to be the most straightforward of them all, you need to exercise extreme caution when using it in Python. Everything you’ve read so far is based on the assumption that numbers are represented with unsigned integers. Note: Unsigned data types don’t let you store negative numbers such as -273 because there’s no space for a sign in a regular bit pattern. Trying to do so would result in a compilation error, a runtime exception, or an integer overflow depending on the language used. Although there are ways to simulate unsigned integers, Python doesn’t support them natively. That means all numbers have an implicit sign attached to them whether you specify one or not. This shows when you do a bitwise NOT of any number: Instead of the expected 99 , you get a negative value! The reason for this will become clear once you learn about the various binary number representations. For now, the quick-fix solution is to take advantage of the bitwise AND operator: That’s a perfect example of a bitmask, which you’ll explore in one of the upcoming sections.\n\nBitwise shift operators are another kind of tool for bit manipulation. They let you move the bits around, which will be handy for creating bitmasks later on. In the past, they were often used to improve the speed of certain mathematical operations. The bitwise left shift operator ( ) moves the bits of its first operand to the left by the number of places specified in its second operand. It also takes care of inserting enough zero bits to fill the gap that arises on the right edge of the new bit pattern: Shifting a single bit to the left by one place doubles its value. For example, instead of a two, the bit will indicate a four after the shift. Moving it two places to the left will quadruple the resulting value. When you add up all the bits in a given number, you’ll notice that it also gets doubled with every place shifted: In general, shifting bits to the left corresponds to multiplying the number by a power of two, with an exponent equal to the number of places shifted: The left shift used to be a popular optimization technique because bit shifting is a single instruction and is cheaper to calculate than exponent or product. Today, however, compilers and interpreters, including Python’s, are quite capable of optimizing your code behind the scenes. Note: Don’t use the bit shift operators as a means of premature optimization in Python. You won’t see a difference in execution speed, but you’ll most definitely make your code less readable. On paper, the bit pattern resulting from a left shift becomes longer by as many places as you shift it. That’s also true for Python in general because of how it handles integers. However, in most practical cases, you’ll want to constrain the length of a bit pattern to be a multiple of eight, which is the standard byte length. For example, if you’re working with a single byte, then shifting it to the left should discard all the bits that go beyond its left boundary: It’s sort of like looking at an unbounded stream of bits through a fixed-length window. There are a few tricks that let you do this in Python. For example, you can apply a bitmask with the bitwise AND operator: Shifting 39 by three places to the left returns a number higher than the maximum value that you can store on a single byte. It takes nine bits, whereas a byte has only eight. To chop off that one extra bit on the left, you can apply a bitmask with the appropriate value. If you’d like to keep more or fewer bits, then you’ll need to modify the mask value accordingly. The bitwise right shift operator ( ) is analogous to the left one, but instead of moving bits to the left, it pushes them to the right by the specified number of places. The rightmost bits always get dropped: Every time you shift a bit to the right by one position, you halve its underlying value. Moving the same bit by two places to the right produces a quarter of the original value, and so on. When you add up all the individual bits, you’ll see that the same rule applies to the number they represent: Halving an odd number such as 157 would produce a fraction. To get rid of it, the right shift operator automatically floors the result. It’s virtually the same as a floor division by a power of two: Again, the exponent corresponds to the number of places shifted to the right. In Python, you can leverage a dedicated operator to perform a floor division: The bitwise right shift operator and the floor division operator both work the same way, even for negative numbers. However, the floor division lets you choose any divisor and not just a power of two. Using the bitwise right shift was a common way of improving the performance of some arithmetic divisions. Note: You might be wondering what happens when you run out of bits to shift. For example, when you try pushing by more places than there are bits in a number: Once there are no more bits switched on, you’re stuck with a value of zero. Zero divided by anything will always return zero. However, things get trickier when you right shift a negative number because the implicit sign bit gets in the way: The rule of thumb is that, regardless of the sign, the result will be the same as a floor division by some power of two. The floor of a small negative fraction is always minus one, and that’s what you’ll get. Read on for a more detailed explanation. Just like with the left shift operator, the bit pattern changes its size after a right shift. While moving bits to the right makes the binary sequence shorter, it usually won’t matter because you can put as many zeros in front of a bit sequence as you like without changing the value. For example, 101 is the same as 0101 , and so is 00000101 , provided that you’re dealing with nonnegative numbers. Sometimes you’ll want to keep a given bit-length after doing a right shift to align it against another value or to fit in somewhere. You can do that by applying a bitmask: It carves out only those bits you’re interested in and fills the bit pattern with leading zeros if necessary. The handling of negative numbers in Python is slightly different from the traditional approach to bitwise shifting. In the next section, you’ll examine this in more detail. You can further categorize the bitwise shift operators as arithmetic and logical shift operators. While Python only lets you do the arithmetic shift, it’s worthwhile to know how other programming languages implement the bitwise shift operators to avoid confusion and surprises. This distinction comes from the way they handle the sign bit, which ordinarily lies at the far left edge of a signed binary sequence. In practice, it’s relevant only to the right shift operator, which can cause a number to flip its sign, leading to integer overflow. Note: Java and JavaScript, for example, distinguish the logical right shift operator with an additional greater-than sign ( ). Since the left shift operator behaves consistently across both kinds of shifts, these languages don’t define a logical left shift counterpart. Conventionally, a turned-on sign bit indicates negative numbers, which helps keep the arithmetic properties of a binary sequence: Looking from the left at these two binary sequences, you can see that their first bit carries the sign information, while the remaining part consists of the magnitude bits, which are the same for both numbers. Note: The specific decimal values will depend on how you decide to express signed numbers in binary. It varies between languages and gets even more complicated in Python, so you can ignore it for the moment. You’ll have a better picture once you get to the binary number representations section below. A logical right shift, also known as an unsigned right shift or a zero-fill right shift, moves the entire binary sequence, including the sign bit, and fills the resulting gap on the left with zeros: Notice how the information about the sign of the number is lost. Regardless of the original sign, it’ll always produce a nonnegative integer because the sign bit gets replaced by zero. As long as you aren’t interested in the numeric values, a logical right shift can be useful in processing low-level binary data. However, because signed binary numbers are typically stored on a fixed-length bit sequence in most languages, it can make the result wrap around the extreme values. You can see this in an interactive Java Shell tool: The resulting number changes its sign from negative to positive, but it also overflows, ending up very close to Java’s maximum integer: This number may seem arbitrary at first glance, but it’s directly related to the number of bits that Java allocates for the data type: It uses 32 bits to store signed integers in two’s complement representation. When you take the sign bit out, you’re left with 31 bits, whose maximum decimal value is equal to 231 - 1, or 2147483647 . Python, on the other hand, stores integers as if there were an infinite number of bits at your disposal. Consequently, a logical right shift operator wouldn’t be well defined in pure Python, so it’s missing from the language. You can still simulate it, though. One way of doing so is to take advantage of the unsigned data types available in C that are exposed through the built-in module: They let you pass in a negative number but don’t attach any special meaning to the sign bit. It’s treated like the rest of the magnitude bits. While there are only a few predefined unsigned integer types in C, which differ in bit-length, you can create a custom function in Python to handle arbitrary bit-lengths: This converts a signed bit sequence to an unsigned one and then performs the regular arithmetic right shift. However, since bit sequences in Python aren’t fixed in length, they don’t really have a sign bit. Moreover, they don’t use the traditional two’s complement representation like in C or Java. To mitigate that, you can take advantage of the modulo operation, which will keep the original bit patterns for positive integers while appropriately wrapping around the negative ones. An arithmetic right shift ( ), sometimes called the signed right shift operator, maintains the sign of a number by replicating its sign bit before moving bits to the right: In other words, it fills the gap on the left with whatever the sign bit was. Combined with the two’s complement representation of signed binary, this results in an arithmetically correct value. Regardless of whether the number is positive or negative, an arithmetic right shift is equivalent to floor division. As you’re about to find out, Python doesn’t always store integers in plain two’s complement binary. Instead, it follows a custom adaptive strategy that works like sign-magnitude with an unlimited number of bits. It converts numbers back and forth between their internal representation and two’s complement to mimic the standard behavior of the arithmetic shift.\n\nYou’ve experienced firsthand the lack of unsigned data types in Python when using the bitwise negation ( ) and the right shift operator ( ). You’ve seen hints about the unusual approach to storing integers in Python, which makes handling negative numbers tricky. To use bitwise operators effectively, you need to know about the various representations of numbers in binary. In programming languages like C, you choose whether to use the signed or unsigned flavor of a given numeric type. Unsigned data types are more suitable when you know for sure that you’ll never need to deal with negative numbers. By allocating that one extra bit, which would otherwise serve as a sign bit, you practically double the range of available values. It also makes things a little safer by increasing the maximum limit before an overflow happens. However, overflows happen only with fixed bit-lengths, so they’re irrelevant to Python, which doesn’t have such constraints. The quickest way to get a taste of the unsigned numeric types in Python is to use the previously mentioned module: Since there’s no sign bit in such integers, all their bits represent the magnitude of a number. Passing a negative number forces Python to reinterpret the bit pattern as if it had only the magnitude bits. The sign of a number has only two states. If you ignore zero for a moment, then it can be either positive or negative, which translates nicely to the binary system. Yet there are a few alternative ways to represent signed integers in binary, each with its own pros and cons. Probably the most straightforward one is the sign-magnitude, which builds naturally on top of unsigned integers. When a binary sequence is interpreted as sign-magnitude, the most significant bit plays the role of a sign bit, while the rest of the bits work the same as usual: A zero on the leftmost bit indicates a positive ( ) number, and a one indicates a negative ( ) number. Notice that a sign bit doesn’t contribute to the number’s absolute value in sign-magnitude representation. It’s there only to let you flip the sign of the remaining bits. It keeps bit indexing intact, which, in turn, helps maintain backward compatibility of the bit weights used to calculate the decimal value of a binary sequence. However, not everything about sign-magnitude is so great. Note: Binary representations of signed integers only make sense on fixed-length bit sequences. Otherwise, you couldn’t tell where the sign bit was. In Python, however, you can represent integers with as many bits as you like: Whether it’s four bits or eight, the sign bit will always be found in the leftmost position. The range of values that you can store in a sign-magnitude bit pattern is symmetrical. But it also means that you end up with two ways to convey zero: Zero doesn’t technically have a sign, but there’s no way not to include one in sign-magnitude. While having an ambiguous zero isn’t ideal in most cases, it’s not the worst part of the story. The biggest downside of this method is cumbersome binary arithmetic. When you apply standard binary arithmetic to numbers stored in sign-magnitude, it may not give you the expected results. For example, adding two numbers with the same magnitude but opposite signs won’t make them cancel out: The sum of 42 and -42 doesn’t produce zero. Also, the carryover bit can sometimes propagate from magnitude to the sign bit, inverting the sign and yielding an unexpected result. To address these problems, some of the early computers employed one’s complement representation. The idea was to change how decimal numbers are mapped to particular binary sequences so that they can be added up correctly. For a deeper dive into one’s complement, you can expand the section below. In one’s complement, positive numbers are the same as in sign-magnitude, but negative numbers are obtained by flipping the positive number’s bits using a bitwise NOT: This preserves the original meaning of the sign bit, so positive numbers still begin with a binary zero, while negative ones start with a binary one. Likewise, the range of values remains symmetrical and continues to have two ways to represent zero. However, the binary sequences of negative numbers in one’s complement are arranged in reverse order as compared to sign-magnitude: Thanks to that, you can now add two numbers more reliably because the sign bit doesn’t need special treatment. If a carryover originates from the sign bit, it’s fed back at the right edge of the binary sequence instead of just being dropped. This ensures the correct result. Nevertheless, modern computers don’t use one’s complement to represent integers because there’s an even better way called two’s complement. By applying a small modification, you can eliminate double zero and simplify the binary arithmetic in one go. To explore two’s complement in more detail, you can expand the section below. When finding bit sequences of negative values in two’s complement, the trick is to add one to the result after negating the bits: This pushes the bit sequences of negative numbers down by one place, eliminating the notorious minus zero. A more useful minus one will take over its bit pattern instead. As a side effect, the range of available values in two’s complement becomes asymmetrical, with a lower bound that’s a power of two and an odd upper bound. For example, an 8-bit signed integer will let you store numbers from -128 to 127 in two’s complement: Another way to put it is that the most significant bit carries both the sign and part of the number magnitude: Notice the minus sign next to the leftmost bit weight. Deriving a decimal value from a binary sequence like that is only a matter of adding appropriate columns. For example, the value of 11010110 in 8-bit two’s complement representation is the same as the sum: -128 + 64 + 16 + 4 + 2 = -42 . With the two’s complement representation, you no longer need to worry about the carryover bit unless you want to use it as an overflow detection mechanism, which is kind of neat. There are a few other variants of signed number representations, but they’re not as popular. The IEEE 754 standard defines a binary representation for real numbers consisting of the sign, exponent, and mantissa bits. Without getting into too many technical details, you can think of it as the scientific notation for binary numbers. The decimal point “floats” around to accommodate a varying number of significant figures, except it’s a binary point. Two data types conforming to that standard are widely supported: Python’s data type is equivalent to the double-precision type. Note that some applications require more or fewer bits. For example, the OpenEXR image format takes advantage of half precision to represent pixels with a high dynamic range of colors at a reasonable file size. The number Pi (π) has the following binary representation in single precision when rounded to five decimal places: The sign bit works just like with integers, so zero denotes a positive number. For the exponent and mantissa, however, different rules can apply depending on a few edge cases. First, you need to convert them from binary to the decimal form: The exponent is stored as an unsigned integer, but to account for negative values, it usually has a bias equal to 127 in single precision. You need to subtract it to recover the actual exponent. Mantissa bits represent a fraction, so they correspond to negative powers of two. Additionally, you need to add one to the mantissa because it assumes an implicit leading bit before the radix point in this particular case. Putting it all together, you arrive at the following formula to convert a floating-point binary number into a decimal one: When you substitute the variables for the actual values in the example above, you’ll be able to decipher the bit pattern of a floating-point number stored in single precision: There it is, granted that Pi has been rounded to five decimal places. You’ll learn how to display such numbers in binary later on. While floating-point numbers are a good fit for engineering purposes, they fail in monetary calculations due to their limited precision. For example, some numbers with a finite representation in decimal notation have only an infinite representation in binary. That often results in a rounding error, which can accumulate over time: In such cases, you’re better off using Python’s module, which implements fixed-point arithmetic and lets you specify where to put the decimal point on a given bit-length. For example, you can tell it how many digits you want to preserve: However, it includes all digits, not just the fractional ones. Note: If you’re working with rational numbers, then you might be interested in checking out the module, which is part of Python’s standard library. If you can’t or don’t want to use a fixed-point data type, a straightforward way to reliably store currency values is to scale the amounts to the smallest unit, such as cents, and represent them with integers.\n\nIn the old days of programming, computer memory was at a premium. Therefore, languages would give you pretty granular control over how many bytes to allocate for your data. Let’s take a quick peek at a few integer types from C as an example: These values might vary from platform to platform. However, such an abundance of numeric types allows you to arrange data in memory compactly. Remember that these don’t even include unsigned types! On the other end of the spectrum are languages such as JavaScript, which have just one numeric type to rule them all. While this is less confusing for beginning programmers, it comes at the price of increased memory consumption, reduced processing efficiency, and decreased precision. When talking about bitwise operators, it’s essential to understand how Python handles integer numbers. After all, you’ll use these operators mainly to work with integers. There are a couple of wildly different representations of integers in Python that depend on their values. In CPython, very small integers between -5 and 256 are interned in a global cache to gain some performance because numbers in that range are commonly used. In practice, whenever you refer to one of those values, which are singletons created at the interpreter startup, Python will always provide the same instance: Both variables have the same identity because they refer to the exact same object in memory. That’s typical of reference types but not immutable values such as integers. However, when you go beyond that range of cached values, Python will start creating distinct copies during variable assignment: Despite having equal values, these variables point to separate objects now. But don’t let that fool you. Python will occasionally jump in and optimize your code behind the scenes. For example, it’ll cache a number that occurs on the same line multiple times regardless of its value: Variables and are independent objects because they reside at different memory locations, while the numbers used literally in are, in fact, the same object. Note: Interning is an implementation detail of the CPython interpreter, which might change in future versions, so don’t rely on it in your programs. Interestingly, there’s a similar string interning mechanism in Python, which kicks in for short texts comprised of ASCII letters only. It helps speed up dictionary lookups by allowing their keys to be compared by memory addresses, or C pointers, instead of by the individual string characters. Integers that you’re most likely to find in Python will leverage the C data type. They use the classic two’s complement binary representation on a fixed number of bits. The exact bit-length will depend on your hardware platform, operating system, and Python interpreter version. Modern computers typically use 64-bit architecture, so this would translate to decimal numbers between -263 and 263 - 1. You can check the maximum value of a fixed-precision integer in Python in the following way: It’s huge! Roughly 9 million times the number of stars in our galaxy, so it should suffice for everyday use. While the maximum value that you could squeeze out of the type in C is even bigger, on the order of 1019, integers in Python have no theoretical limit. To allow this, numbers that don’t fit on a fixed-length bit sequence are stored differently in memory. Do you remember that popular K-pop song “Gangnam Style” that became a worldwide hit in 2012? The YouTube video was the first to break a billion views. Soon after that, so many people had watched the video that it made the view counter overflow. YouTube had no choice but to upgrade their counter from 32-bit signed integers to 64-bit ones. That might give plenty of headroom for a view counter, but there are even bigger numbers that aren’t uncommon in real life, notably in the scientific world. Nonetheless, Python can deal with them effortlessly: This number has fifty-two decimal digits. It would take at least 170 bits to represent it in binary with the traditional approach: Since they’re well over the limits that any of the C types have to offer, such astronomical numbers are converted into a sign-magnitude positional system, whose base is 230. Yes, you read that correctly. Whereas you have ten fingers, Python has over a billion! Again, this may vary depending on the platform you’re currently using. When in doubt, you can double-check: This will tell you how many bits are used per digit and what the size in bytes is of the underlying C structure. To get the same namedtuple in Python 2, you’d refer to the attribute instead. While this conversion between fixed- and arbitrary-precision integers is done seamlessly under the hood in Python 3, there was a time when things were more explicit. For more information, you can expand the box below. In the past, Python explicitly defined two distinct integer types: The first one was modeled after the C type, which typically occupied 32 or 64 bits and offered a limited range of values: For bigger numbers, you were supposed to use the second type that didn’t come with a limit. Python would automatically promote plain integers to long ones if needed: This feature prevented the integer overflow error. Notice the letter at the end of a literal, which could be used to enforce the given type by hand: Eventually, both types were unified so that you wouldn’t have to think about it anymore. Such a representation eliminates integer overflow errors and gives the illusion of infinite bit-length, but it requires significantly more memory. Additionally, performing bignum arithmetic is slower than with fixed precision because it can’t run directly in hardware without an intermediate layer of emulation. Another challenge is keeping a consistent behavior of the bitwise operators across alternative integer types, which is crucial in handling the sign bit. Recall that fixed-precision integers in Python use the standard two’s complement representation from C, while large integers use sign-magnitude. To mitigate that difference, Python will do the necessary binary conversion for you. It might change how a number is represented before and after applying a bitwise operator. Here’s a relevant comment from the CPython source code, which explains this in more detail: Bitwise operations for negative numbers operate as though on a two’s complement representation. So convert arguments from sign-magnitude to two’s complement, and convert the result back to sign-magnitude at the end. (Source) In other words, negative numbers are treated as two’s complement bit sequences when you apply the bitwise operators on them, even though the result will be presented to you in sign-magnitude form. There are ways to emulate the sign bit and some of the unsigned types in Python, though.\n\nYou’re welcome to use pen and paper throughout the rest of this article. It may even serve as a great exercise! However, at some point, you’ll want to verify whether your binary sequences or bit strings correspond to the expected numbers in Python. Here’s how. To reveal the bits making up an integer number in Python, you can print a formatted string literal, which optionally lets you specify the number of leading zeros to display: Alternatively, you can call with the number as an argument: This global built-in function returns a string consisting of a binary literal, which starts with the prefix and is followed by ones and zeros. It always shows the minimum number of digits without the leading zeros. You can use such literals verbatim in your code, too: Other integer literals available in Python are the hexadecimal and octal ones, which you can obtain with the and functions, respectively: Notice how the hexadecimal system, which is base sixteen, takes advantage of letters through to augment the set of available digits. The octal literals in other programming languages are usually prefixed with plain zero, which might be confusing. Python explicitly forbids such literals to avoid making a mistake: File , line : leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers You can express the same value in different ways using any of the mentioned integer literals: Choose the one that makes the most sense in context. For example, it’s customary to express bitmasks with hexadecimal notation. On the other hand, the octal literal is rarely seen these days. All numeric literals in Python are case insensitive, so you can prefix them with either lowercase or uppercase letters: This also applies to floating-point number literals that use scientific notation as well as complex number literals. Once you have your bit string ready, you can get its decimal representation by taking advantage of a binary literal: This is a quick way to do the conversion while working inside the interactive Python interpreter. Unfortunately, it won’t let you convert bit sequences synthesized at runtime because all literals need to be hard-coded in the source code. Note: You might be tempted to evaluate Python code with , but that’s an easy way to compromise the security of your program, so don’t do it! Calling with two arguments will work better in the case of dynamically generated bit strings: The first argument is a string of digits, while the second one determines the base of the numeral system. Unlike a binary literal, a string can come from anywhere, even a user typing on the keyboard. For a deeper look at , you can expand the box below. Other Uses of Show/Hide There are other ways to call . For example, it returns zero when called without arguments: This feature makes it a common pattern in the collection, which needs a default value provider. Take this as an example: Here, helps to count words in a sentence. It’s called automatically whenever needs to initialize the value of a missing key in the dictionary. Another popular use of is typecasting. For example, when you pass a floating-point value, it truncates the value by removing the fractional component: When you give it a string, it tries to parse out a number from it: In general, will accept an object of any type as long as it defines a special method that can handle the conversion. So far, so good. But what about negative numbers? When you call on a negative integer, it merely prepends the minus sign to the bit string obtained from the corresponding positive value: Changing the sign of a number doesn’t affect the underlying bit string in Python. Conversely, you’re allowed to prefix a bit string with the minus sign when transforming it to decimal form: That makes sense in Python because, internally, it doesn’t use the sign bit. You can think of the sign of an integer number in Python as a piece of information stored separately from the modulus. However, there are a few workarounds that let you emulate fixed-length bit sequences containing the sign bit: You know from earlier sections that to ensure a certain bit-length of a number, you can use a nifty bitmask. For example, to keep one byte, you can use a mask composed of exactly eight turned-on bits: Masking forces Python to temporarily change the number’s representation from sign-magnitude to two’s complement and then back again. If you forget about the decimal value of the resulting binary literal, which is equal to 214 , then it’ll represent -42 in two’s complement. The leftmost bit will be the sign bit. Alternatively, you can take advantage of the modulo operation that you used previously to simulate the logical right shift in Python: If that looks too convoluted for your taste, then you can use one of the modules from the standard library that express the same intent more clearly. For example, using will have an identical effect: You’ve seen it before, but just as a reminder, it’ll piggyback off the unsigned integer types from C. Another standard module that you can use for this kind of conversion in Python is the module. It defines a data structure that’s similar to a but is only allowed to hold elements of the same numeric type. When declaring an array, you need to indicate its type up front with a corresponding letter: For example, stands for an 8-bit signed byte, while stands for its unsigned equivalent. There are a few other predefined types, such as a signed 16-bit integer or a 32-bit floating-point number. Copying raw bytes between these two arrays changes how bits are interpreted. However, it takes twice the amount of memory, which is quite wasteful. To perform such a bit rewriting in place, you can rely on the module, which uses a similar set of format characters for type declarations: Packing lets you lay objects in memory according to the given C data type specifiers. It returns a read-only object, which contains raw bytes of the resulting block of memory. Later, you can read back those bytes using a different set of type codes to change how they’re translated into Python objects. Up to this point, you’ve used different techniques to obtain fixed-length bit strings of integers expressed in two’s complement representation. If you want to convert these types of bit sequences back to Python integers instead, then you can try this function: The function accepts a string composed of binary digits. First, it converts the digits to a plain unsigned integer, disregarding the sign bit. Next, it uses two bitmasks to extract the sign and magnitude bits, whose locations depend on the specified bit-length. Finally, it combines them using regular arithmetic, knowing that the value associated with the sign bit is negative. You can try it out against the trusty old bit string from earlier examples: Python’s treats all the bits as the magnitude, so there are no surprises there. However, this new function assumes a 32-bit long string by default, which means the sign bit is implicitly equal to zero for shorter strings. When you request a bit-length that matches your bit string, then you’ll get the expected result. While integer is the most appropriate data type for working with bitwise operators in most cases, you’ll sometimes need to extract and manipulate fragments of structured binary data, such as image pixels. The and modules briefly touch upon this topic, so you’ll explore it in more detail next. You know how to read and interpret individual bytes. However, real-world data often consists of more than one byte to convey information. Take the data type as an example. A single floating-point number in Python occupies as many as eight bytes in memory. How do you see those bytes? You can’t simply use bitwise operators because they don’t work with floating-point numbers: You have to forget about the particular data type you’re dealing with and think of it in terms of a generic stream of bytes. That way, it won’t matter what the bytes represent outside the context of them being processed by the bitwise operators. To get the of a floating-point number in Python, you can pack it using the familiar module: Ignore the format characters passed through the first argument. They won’t make sense until you get to the byte order section below. Behind this rather obscure textual representation hides a list of eight integers: Their values correspond to the subsequent bytes used to represent a floating-point number in binary. You can combine them to produce a very long bit string: These 64 bits are the sign, exponent, and mantissa in double precision that you read about earlier. To synthesize a from a similar bit string, you can reverse the process: returns a tuple because it allows you to read more than one value at a time. For example, you could read the same bit string as four 16-bit signed integers: As you can see, the way a bit string should be interpreted must be known up front to avoid ending up with garbled data. One important question you need to ask yourself is which end of the byte stream you should start reading from—left or right. Read on to find out.\n\nThere’s no dispute about the order of bits in a single byte. You’ll always find the least-significant bit at index zero and the most-significant bit at index seven, regardless of how they’re physically laid out in memory. The bitwise shift operators rely on this consistency. However, there’s no consensus for the byte order in multibyte chunks of data. A piece of information comprising more than one byte can be read from left to right like an English text or from right to left like an Arabic one, for example. Computers see bytes in a binary stream like humans see words in a sentence. It doesn’t matter which direction computers choose to read the bytes from as long as they apply the same rules everywhere. Unfortunately, different computer architectures use different approaches, which makes transferring data between them challenging. Let’s take a 32-bit unsigned integer corresponding to the number 1969 , which was the year when Monty Python first appeared on TV. With all the leading zeros, it has the following binary representation 00000000000000000000011110110001 . How would you store such a value in computer memory? If you imagine memory as a one-dimensional tape consisting of bytes, then you’d need to break that data down into individual bytes and arrange them in a contiguous block. Some find it natural to start from the left end because that’s how they read, while others prefer starting at the right end: When bytes are placed from left to right, the most-significant byte is assigned to the lowest memory address. This is known as the big-endian order. Conversely, when bytes are stored from right to left, the least-significant byte comes first. That’s called little-endian order. Note: These humorous names draw inspiration from the eighteenth-century novel Gulliver’s Travels by Jonathan Swift. The author describes a conflict between the Little-Endians and the Big-Endians over the correct way to break the shell of a boiled egg. While Little-Endians prefer to start with the little pointy end, Big-Endians like the big end more. From a practical standpoint, there’s no real advantage of using one over the other. There might be some marginal gains in performance at the hardware level, but you won’t notice them. Major network protocols use the big-endian order, which allows them to filter data packets more quickly given the hierarchical design of IP addressing. Other than that, some people may find it more convenient to work with a particular byte order when debugging. Either way, if you don’t get it right and mix up the two standards, then bad things start to happen: When you serialize some value to a stream of bytes using one convention and try reading it back with another, you’ll get a completely useless result. This scenario is most likely when data is sent over a network, but you can also experience it when reading a local file in a specific format. For example, the header of a Windows bitmap always uses little-endian, while JPEG can use both byte orders. To find out your platform’s endianness, you can use the module: You can’t change endianness, though, because it’s an intrinsic feature of your CPU architecture. It’s impossible to mock it for testing purposes without hardware virtualization such as QEMU, so even the popular VirtualBox won’t help. Notably, the x86 family of processors from Intel and AMD, which power most modern laptops and desktops, are little-endian. Mobile devices are based on low-energy ARM architecture, which is bi-endian, while some older architectures such as the ancient Motorola 68000 were big-endian only. For information on determining endianness in C, expand the box below. Historically, the way to get your machine’s endianness in C was to declare a small integer and then read its first byte with a pointer: If the value comes out higher than zero, then the byte stored at the lowest memory address must be the least-significant one. Once you know the native endianness of your machine, you’ll want to convert between different byte orders when manipulating binary data. A universal way to do so, regardless of the data type at hand, is to reverse a generic object or a sequence of integers representing those bytes: However, it’s often more convenient to use the module, which lets you define standard C data types. In addition to this, it allows you to request a given byte order with an optional modifier: The greater-than sign ( ) indicates that bytes are laid out in the big-endian order, while the less-than symbol ( ) corresponds to little-endian. If you don’t specify one, then native endianness is assumed. There are a few more modifiers, like the exclamation mark ( ), which signifies the network byte order. Computer networks are made of heterogeneous devices such as laptops, desktops, tablets, smartphones, and even light bulbs equipped with a Wi-Fi adapter. They all need agreed-upon protocols and standards, including the byte order for binary transmission, to communicate effectively. At the dawn of the Internet, it was decided that the byte order for those network protocols would be big-endian. Programs that want to communicate over a network can grab the classic C API, which abstracts away the nitty-gritty details with a socket layer. Python wraps that API through the built-in module. However, unless you’re writing a custom binary protocol, you’ll probably want to take advantage of an even higher-level abstraction, such as the HTTP protocol, which is text-based. Where the module can be useful is in the byte order conversion. It exposes a few functions from the C API, with their distinctive, tongue-twisting names: If your host already uses the big-endian byte order, then there’s nothing to be done. The values will remain the same.\n\nThe primary domain of bitwise operators is integer numbers. That’s where they make the most sense. However, you’ve also seen them used in a Boolean context, in which they replaced the logical operators. Python provides alternative implementations for some of its operators and lets you overload them for new data types. Although the proposal to overload the logical operators in Python was rejected, you can give new meaning to any of the bitwise operators. Many popular libraries, and even the standard library, take advantage of it. Python bitwise operators are defined for the following built-in data types: It’s not a widely known fact, but bitwise operators can perform operations from set algebra, such as union, intersection, and symmetric difference, as well as merge and update dictionaries. Note: At the time of writing, Python 3.9 hadn’t been released, but you could take a sneak peek at the upcoming language features using Docker or pyenv. When and are Python sets, then bitwise operators correspond to the following methods: They do virtually the same thing, so it’s up to you which syntax to use. Apart from that, there’s also an overloaded minus operator ( ), which implements a difference of two sets. To see them in action, assume you have the following two sets of fruits and vegetables: They share one common member, which is hard to classify, but the rest of their elements are disjoint. One thing to watch out for is the immutable , which is missing the methods for in-place updates. However, when you use their bitwise operator counterparts, the meaning is slightly different: It looks like isn’t so immutable after all when you use the bitwise operators, but the devil is in the details. Here’s what actually happens: The reason it works the second time is that you don’t change the original immutable object. Instead, you create a new one and assign it to the same variable again. Python supports only bitwise OR, which works like a union operator. You can use it to update a dictionary in place or merge two dictionaries into a new one: The augmented version of the bitwise operator is equivalent to . Many popular libraries, including NumPy, pandas, and SQLAlchemy, overload the bitwise operators for their specific data types. This is the most likely place you’ll find bitwise operators in Python because they aren’t used very often in their original meaning anymore. For example, NumPy applies them to vectorized data in a pointwise fashion: This way, you don’t need to manually apply the same bitwise operator to each element of the array. But you can’t do the same thing with ordinary lists in Python. pandas uses NumPy behind the scenes, and it also provides overloaded versions of the bitwise operators for its and objects. However, they behave as you’d expect. The only difference is that they do their usual job on vectors and matrices of numbers instead of on individual scalars. Things get more interesting with libraries that give the bitwise operators entirely new meanings. For example, SQLAlchemy provides a compact syntax for querying the database: The bitwise AND operator ( ) will eventually translate to a piece of SQL query. However, that’s not very obvious, at least not to my IDE, which complains about the unpythonic use of bitwise operators when it sees them in this type of expression. It immediately suggests replacing every occurrence of with a logical , not knowing that doing so would make the code stop working! This type of operator overloading is a controversial practice that relies on implicit magic you have to know up front. Some programming languages like Java prevent such abuse by disallowing operator overloading altogether. Python is more liberal in that regard and trusts that you know what you’re doing. To customize the behavior of Python’s bitwise operators, you have to define a class and then implement the corresponding magic methods in it. At the same time, you can’t redefine the behavior of the bitwise operators for the existing types. Operator overloading is possible only on new data types. Here’s a quick rundown of special methods that let you overload the bitwise operators: You don’t need to define all of them. For example, to have a slightly more convenient syntax for appending and prepending elements to a deque, it’s sufficient to implement only and : This user-defined class wraps a deque to reuse its implementation and augment it with two additional methods that allow for adding items to the left or right end of the collection.\n\nWhew, that was a lot to process! If you’re still scratching your head, wondering why you’d want to use bitwise operators, then don’t worry. It’s time to showcase what you can do with them in a fun way. To follow along with the examples in this section, you can download the source code by clicking the link below: Get the Source Code: Click here to get the source code you’ll use to learn about Python’s bitwise operators in this tutorial. You’re going to learn about steganography and apply this concept to secretly embed arbitrary files in bitmap images. Cryptography is about changing a message into one that is readable only to those with the right key. Everyone else can still see the encrypted message, but it won’t make any sense to them. One of the first forms of cryptography was the substitution cipher, such as the Caesar cipher named after Julius Caesar. Steganography is similar to cryptography because it also allows you to share secret messages with your desired audience. However, instead of using encryption, it cleverly hides information in a medium that doesn’t attract attention. Examples include using invisible ink or writing an acrostic in which the first letter of every word or line forms a secret message. Unless you knew that a secret message was concealed and the method to recover it, you’d probably ignore the carrier. You can combine both techniques to be even safer, hiding an encrypted message rather than the original one. There are plenty of ways to smuggle secret data in the digital world. In particular, file formats carrying lots of data, such as audio files, videos, or images, are a great fit because they give you a lot of room to work with. Companies that release copyrighted material might use steganography to watermark individual copies and trace the source of a leak, for example. Below, you’ll inject secret data into a plain bitmap, which is straightforward to read and write in Python without the need for external dependencies. The word bitmap usually refers to the Windows bitmap ( ) file format, which supports a few alternative ways of representing pixels. To make life easier, you’re going to assume that pixels are stored in 24-bit uncompressed RGB (red, green, and blue) format. A pixel will have three color channels that can each hold values from 0 to 255 . Every bitmap begins with a file header, which contains metadata such as the image width and height. Here are a few interesting fields and their positions relative to the start of the header: You can infer from this header that the corresponding bitmap is 1,954 pixels wide and 1,301 pixels high. It doesn’t use compression, nor does it have a color palette. Every pixel occupies 24 bits, or 3 bytes, and the raw pixel data starts at offset 122 . You can open the bitmap in binary mode, seek the desired offset, read the given number of bytes, and deserialize them using like before: Note that all integer fields in bitmaps are stored in the little-endian byte order. You might have noticed a small discrepancy between the number of pixel bytes declared in the header and the one that would result from the image size. When you multiply 1,954 pixels × 1,301 pixels × 3 bytes, you get a value that is 2,602 bytes less than 7,629,064. This is because pixel bytes are padded with zeros so that every row is a multiple of four bytes. If the width of the image times three bytes happens to be a multiple of four, then there’s no need for padding. Otherwise, empty bytes are added at the end of every row. Note: To avoid raising suspicion, you’ll need to take that padding into account by skipping the empty bytes. Otherwise, it would be a clear giveaway to someone who knows what to look for. Bitmaps store pixel rows upside down, starting from the bottom rather than the top. Also, every pixel is serialized to a vector of color channels in a somewhat odd BGR order rather than RGB. However, this is irrelevant to the task of hiding secret data. You can use the bitwise operators to spread custom data over consecutive pixel bytes. The idea is to overwrite the least-significant bit in each of them with bits coming from the next secret byte. This will introduce the least amount of noise, but you can experiment with adding more bits to strike a balance between the size of injected data and pixel distortion. Note: Using the least-significant bit steganography doesn’t affect the file size of the resulting bitmap. It’ll remain the same as the original file. In some cases, the corresponding bits will be the same, resulting in no change in pixel value whatsoever. However, even in the worst-case scenario, a pixel color will differ only by a fraction of a percent. Such a tiny anomaly will remain invisible to the human eye but can be detected with steganalysis, which uses statistics. Take a look at these cropped images: The one on the left comes from the original bitmap, while the image on the right depicts a processed bitmap with an embedded video stored on the least-significant bits. Can you spot the difference? The following piece of code encodes the secret data onto the bitmap: For every byte of secret data and the corresponding eight bytes of pixel data, excluding the pad bytes, it prepares a list of bits to be spread over. Next, it overwrites the least-significant bit in each of the eight bytes using a relevant bitmask. The result is converted to a object and assigned back to the part of the bitmap that it originally came from. To decode a file from the same bitmap, you need to know how many secret bytes were written to it. You could allocate a few bytes at the beginning of the data stream to store this number, or you could use the reserved fields from the bitmap header: This jumps to the right offset in the file, serializes the Python to raw bytes, and writes them down. You might also want to store the name of your secret file. Since it can have an arbitrary length, it makes sense to serialize it using a null-terminated string, which would precede the file contents. To create such a string, you need to encode a Python object to bytes and manually append the null byte at the end: Also, it doesn’t hurt to drop the redundant parent directory from the path using . The sample code supplementing this article will let you encode, decode, and erase a secret file from the given bitmap with the following commands: python -m stegano example.bmp -d python -m stegano example.bmp -x python -m stegano example.bmp -e pdcast.mp4 Secret file was embedded in the bitmap This is a runnable module that can be executed by calling its encompassing directory. You could also make a portable ZIP-format archive out of its contents to take advantage of the Python ZIP application support. This program relies on modules from the standard library mentioned in the article and a few others that you might not have heard about before. A critical module is , which exposes a Python interface to memory-mapped files. They let you manipulate huge files using both the standard file API and the sequence API. It’s as if the file were one big mutable list that you could slice. Go ahead and play around with the bitmap attached to the supporting materials. It contains a little surprise for you!"
    },
    {
        "link": "https://stackoverflow.com/questions/44910883/optimization-how-to-store-bits-in-memory",
        "document": "I'm a newbie in Python and I have a problem with storing information. I've got a task from my 'mentor' and I don't know how to do that. I have array with numbers 0 and 1, e.g.\n\nI know that's integers, but he told I should keep it as bits. I was trying to convert my variable to number e.g:\n\nBut when I'm using ab is bigger than a. I was trying to use but I don't understand it, too. I was thinking that I know how a computer works, but that makes me confused.\n\nHow should I keep bits? What should I use? What should I read to understand it? and how to measure how big is my variable ( is okay for that? Or should I write it to a binary file?). We doing it to optimize memory."
    },
    {
        "link": "https://labex.io/tutorials/python-how-to-get-number-bit-length-437836",
        "document": "In computer science, bit length refers to the number of bits required to represent a specific integer value. It is a fundamental concept in digital representation and plays a crucial role in various programming scenarios.\n\nBit length represents the minimum number of binary digits (bits) needed to express a non-negative integer. For example:\n• The number 5 (binary: 101) has a bit length of 3\n• The number 8 (binary: 1000) has a bit length of 4\n\nPython provides a built-in method to easily calculate the bit length of an integer. This method returns the number of bits required to represent the number.\n\nAt LabEx, we understand the importance of understanding fundamental programming concepts like bit length, which are critical for advanced software development and system-level programming."
    },
    {
        "link": "https://cs.stackexchange.com/questions/5032/calculate-storage-requirements-for-a-data-set",
        "document": "Stack Exchange network consists of 183 Q&A communities including Stack Overflow, the largest, most trusted online community for developers to learn, share their knowledge, and build their careers."
    },
    {
        "link": "https://reddit.com/r/Database/comments/oaffk2/best_practices_for_storing_passwords_in_database",
        "document": "I am volunteering on a project to overhaul a very poorly-designed database. There were many problems but one of the more alarming is that currently administrator passwords are being stored in decryptable hashes. If breached, it would be trivial to crack these. We are using MariaDB currently.\n\nThis got me wondering what the current best method is. In this use case, we have an e-mail account associated with each student that is their official e-mail. We considered a system that would generate a one-time code to set up their profile but this isn't very reusable.\n\nIf we need to store passwords in the database, what is the best way to achieve this safely? I have read a bit about the \"salt\" approach and this particular article seems promising: https://www.mssqltips.com/sqlservertip/4037/storing-passwords-in-a-secure-way-in-a-sql-server-database/\n\nThe goal is to have persistent profiles for students to edit as well as persistent profiles for organizations that they could edit. I know there is some salt implementation built into MariaDB but for the most part it appears to be only for accessing the the DB as an admin itself.\n\nThis is one of those subjects that comes up often but I've seen a lot of conflicting opinions on it. I am curious what people think is the best solution to keep passwords protected without completely destroying performance (I know some suggest bcrypt).\n\nAs always, I appreciate the opinions, insights, and expertise of this community and thank everyone who reads this."
    },
    {
        "link": "https://snyk.io/articles/password-storage-best-practices",
        "document": "Secure password storage is a challenge for every organization — whether a small startup or a major corporation.\n\nFor newly founded startups, a lack of resources may mean initially hiring novice developers who lack the deep expertise in proper password storage. Because authentication is added on rather early in the development process, this can lead to poor password storage practices.\n\nThis leads to sub-par implementations that form the base of the application. And of course, the more central a module is for an application, the less inclined the developer will be to change it later on in the project’s lifetime for fear of breaking it.\n\nSo the bad authentication implementation is passed along until things finally go south and someone manages to steal your users’ passwords.\n\nApplication security best practices are critical in the development stage for preventing system breaches in the first place. But nothing is 100% secure, so you must take measures to protect your users’ passwords.\n\nIn this article, we’ll cover the most important password storage best practices.\n\nDatabase security isn’t strictly a password best practice. Rather, it applies to all the data being stored in your database, and as such, it shouldn’t be overlooked.\n\nIf an attacker is unable to access your data in the first place, they won’t have the chance to decrypt it either. So be sure to check out your database vendor’s security best practices too.\n\nOf course, this applies to all your systems, not just your databases. If you’re using a popular container engine like Docker, you’re vulnerable to all the issues Dockers brings with it. So don’t neglect container security, and make sure your systems are being monitored as needed.\n\nNever store passwords in plain text. Always create a hash from them and store the hash instead. In password storage, hashing is superior to encryption since a hash can’t be reversed.\n\nIf a user attempts to log in, you can recreate the hash from the password they entered and check if the new hash matches the one you saved at sign up. Nobody with access to the database will be able to read or guess the original password from that hash, not even you or your co-workers. Using a hash also means there is no encryption key that could be stolen.\n\nNot all hash functions are created equal. Some aren’t cryptographically safe, and some are made to be computed quickly — which you want to avoid when hashing a password.\n\nHash functions that can be computed quickly allow attackers to brute-force many random strings until they find the passwords hidden in the hashes. You have to make them work hard. And while you will have to use those slow functions yourself when hashing the password upon signup or login, you won’t have to use it with millions of random strings.\n\nOWASP recommends using Argon2 to hash passwords. If that’s not available, use bcrypt; and if bcrypt is not available, use scrypt.\n\nSalting a password refers to adding a random string to it before hashing it. This ensures the output hashes of well-known passwords don’t look the same. An attacker might have a table with these passwords and the corresponding hashes, and could simply go through it, checking which have been used by your users. This table might have the hash for the password in it, but not the one for\n\nUsers also tend to reuse the same password for multiple applications. So if an attacker accessed leaked passwords from multiple popular applications, salting them before hashing will prevent them from being able to compare them.\n\nThe salt string will be stored alongside the password string in your database. Modern hashing libraries like Argon2 or bcrypt automatically salt passwords before hashing them.\n\nPeppering your passwords works the same as salting: You add a random string to it before hashing.\n\nThe difference between the two is that with peppering, the string is the same for all passwords, but the pepper string isn’t stored alongside the passwords in the database. Instead, you have to store it in the filesystem or in object storage. Anywhere is okay, as long as it’s not stored in the same place as your password database.\n\nShould a hacker manage to access your database, they would still be missing a piece of data, and it would be much more difficult to match your password hashes with the correct passwords.\n\nThough hash functions take some time to do their work, as computer processing speed accelerates, the process is also getting faster. A hash creation that may have taken you a few seconds back when the code was written might take an attacker with a better computer just milliseconds.\n\nTo get around this problem, hash functions come with a parameter called “work factor.” By the work factor, the function will do more iterations on your hash, and thus, take longer.\n\nThere are two considerations with work factors. On the one hand, you don’t want to make hashing too easy for an attacker, but on the other hand, you don’t want to make it too hard to log in. In general, you should therefore avoid choosing extremely high work factors.\n\nIf you upgrade your infrastructure and your servers become more performant, you should also upgrade your work factors so your security benefits from that performance gain too.\n\nIt was once considered best practice to force users to change their passwords every few weeks. The idea was to give stolen passwords an expiration date. In practice, however, this only frustrated users and led them to choose simpler, more insecure passwords.\n\nIf you’re bound by this outdated practice due to compliance regulations, you won’t be able to get around it. But if there are no external factors requiring you to follow such guidelines, don’t make your users change their passwords. This will ensure better password quality in the long run.\n\nOverall, password length is more important than how complex it is. The longer the password, the more processing time it takes to hack programmatically (years, in some cases). This can be considered a good thing because a user can remember much better than .\n\nThat’s why you shouldn’t require users to use numbers or special characters. Simply let them write down what they want and make sure it’s longer than five characters.\n\nWhile you shouldn’t require users to use arbitrary complex passwords, checking new passwords against well-known ones in public dictionaries and deny lists is recommended. If a new password matches the content of these sources, inform the user and ensure they don’t use it.\n\nHackers also rely on such sources for passwords in order to check against the hashes they steal. Checking them against these lists will therefore make it even harder for hackers to figure out your plaintext passwords.\n\nPassword storage best practices are a critical part of the SDLC\n\nPasswords are a vital part of your application. Proper password storage matters in the long run. Depending on how critical the user data is, storing a breached password can bring your entire company down.\n\nPoor password practices can lead to many security problems: They can enable both external and internal attackers while also making you vulnerable to reused passwords from other applications. If user compliance goes down, this can also lead to frustration among users and reduce compliance, thus increasing security risks. Worse, it may also discourage people from using your service.\n\nWhen building critical software, security best practices must be applied at every layer of the development process. Password security is just a small part of the secure SDLC. Prevent attackers from getting to your passwords in the first place. The Snyk Code static application security scanner checks your code for well-known vulnerabilities and tells you how to fix them."
    },
    {
        "link": "https://stackoverflow.com/questions/1054022/best-way-to-store-password-in-database",
        "document": "Background You never ... really ... need to know the user's password. You just want to verify an incoming user knows the password for an account.\n\nHash It: Store user passwords hashed (one-way encryption) via a strong hash function. A search for \"c# encrypt passwords\" gives a load of examples.\n\nSee the online SHA1 hash creator for an idea of what a hash function produces (But don't use SHA1 as a hash function, use something stronger such as SHA256).\n\nNow, a hashed passwords means that you (and database thieves) shouldn't be able to reverse that hash back into the original password.\n\nHow to use it: But, you say, how do I use this mashed up password stored in the database?\n\nWhen the user logs in, they'll hand you the username and the password (in its original text) You just use the same hash code to hash that typed-in password to get the stored version.\n\nSo, compare the two hashed passwords (database hash for username and the typed-in & hashed password). You can tell if \"what they typed in\" matched \"what the original user entered for their password\" by comparing their hashes.\n\nQuestion: If I had your database, then couldn't I just take a cracker like John the Ripper and start making hashes until I find matches to your stored, hashed passwords? (since users pick short, dictionary words anyway ... it should be easy)\n\nAnswer: Yes ... yes they can.\n\nSo, you should 'salt' your passwords. See the Wikipedia article on salt\n\nSee \"How to hash data with salt\" C# example (archived)"
    },
    {
        "link": "https://markilott.medium.com/password-storage-basics-2aa9e1586f98",
        "document": "And why you should never re-use passwords\n\nI’ve found myself explaining the technicalities of password management in back-end systems a few times recently — both to technical teams unfamiliar with the issues, and to friends and family curious about how passwords get stolen and why password re-use is such a bad idea.\n\nWhile the topic can be quite complex, especially the theory behind the various hashing algorithms, at a basic level the key concepts are not difficult to understand — and I think it would be helpful if more people had some basic knowledge. I’ll provide links to more in-depth information as we go, but for the most part this explanation will cover key-concepts rather than detail.\n\nLet’s have a look at a typical interaction with a web-based application we use to do something useful, like share pictures of our favourite widgets. Let’s call it Widgetology.\n\nIn the beginning there is plaintext, the technical term for your unencrypted password (as opposed to plain text, which is the stuff you’re reading right here). We come up with a super secret password no one would ever guess — say like “MyP@ssword1” — and we enter it into the Widgetology web site as we set up our account.\n\nNext time we want to access our account we type in our username and password, there’s some magic in the background as our password is verified, and all going well we have access to the Widgetology app and our personal data.\n\nSomehow the Widgetology app knows our account password and can compare it to the password we enter and confirm we are who we say we are.\n\nFortunately it’s not because Widgetology has simply stored our plaintext password in a database, for that would be extraordinarily insecure. If the Widgetology system is compromised and the database stolen the attacker would now have full access to all accounts immediately. It would also mean that Widgetology admin staff would have access to our passwords, and while I’m sure they are a trustworthy bunch, you just never can know for sure.\n\nInstead, we use a process called hashing to obscure the plaintext password in storage, in a way that ensures we can still verify your password when you log in using plaintext.\n\nHashing is a one-way encryption of the password — with one-way simply meaning that once encrypted the data cannot be decrypted. When you create an account or modify your password, this encrypted password — called a hash — is stored in the Widgetology user database with your account for future logins.\n\nIf the stored password cannot be decrypted, then how can we compare it to the password you enter?\n\nThe hashing process will always produce the same result given the same plaintext input. So we take the password you enter, apply the hashing process, and compare the result to the hash we have stored in the database. If they match, Widgetology knows you have entered the correct password.\n\nIf a hacker or rogue admin manages to steal the Widgetology user database, all they have is the hash which cannot be used to log in, and cannot be decrypted to reveal your plaintext password.\n\nFor a long time this was how passwords were stored, and they still are in many systems including Windows itself. Unfortunately there’s a few flaws in the plan.\n\nHashing algorithms have evolved and improved over the years, with older versions not considered as secure as they once were. It’s beyond the scope here but typically the issue is limitations in the algorithm (or computing capability when it was invented) allow for too many collisions — where different plaintext can produce the same hash.\n\nTechnology isn’t really the problem here though.\n\nLet’s look at the SHA-2 algorithm as an example (the SHA256 version specifically). SHA256 is a very popular hashing algorithm and was and is extremely common in password management. The algorithm itself is considered secure — it is impossible to reverse the encryption, so that’s not the issue. People are the issue.\n\nLet’s take our secure password above as an example:\n\nWell it turns out quite a few other Widgetology users had the same idea, and every one of these “MyP@ssword1” passwords generates the same hash. So inside the user database there will be a number of hashes that look just like mine. What’s worse is, across a million other applications and a billion users, turns out that all over the planet there are user databases full of the exact same hash.\n\nA SHA256 hash cannot be reversed or “cracked”, but in many cases it just doesn’t need to be. An attacker will simply use a list (called a rainbow table) of hashes to compare to the stolen data. The rainbow table includes a massive list of common words, phrases, and all the usual symbol and number substitutions we all think help keep us secure — and their corresponding hashes. The attacker will simply look up my hash in the rainbow table, and they will have my password in seconds. My Widgetology account has been “hacked”.\n\nIf I’ve been a little bit more obscure with my password choice and it doesn’t appear in a rainbow table I will definitely be a little safer. But there’s still an issue.\n\nThe attacker has the hash list on their own PC, and can decipher the more complex passwords at their leisure. This is done using automated brute-force attacks. A program will create hashes using words, phrases, symbols and numbers and compare them to the stolen hash list. Brute-forcing can take a lot of time, especially if your password is long and not just full of common words. It is helped along by two factors however — first, SHA256 is a very fast algorithm, so a lot of hashes can be generated without a lot of computing power, and second — the attacker has the hash list for every user from the database and can compare each guess with the full list in milliseconds.\n\nAs computing power improved and rainbow tables of known password hashes got larger and larger, this brute force problem became a major issue. Storing passwords as simple hashes is now considered insecure, although unfortunately it is still very common.\n\nThe solution is to make password hashes unique, even if the passwords are not. Pass the salt…\n\nLike sprinkling salt on your dinner, adding a salt to a password hash adds some randomness and makes each password hash unique.\n\nYou enter your plaintext password as usual in the account creation process, and the Widgetology back end takes over to create your account. This time, instead of just hashing your password, the system creates a random string of characters — a salt — and adds it to your input. Your password becomes the password + salt.\n\nThe salted password is then hashed and stored in the user database. Using Bcrypt, a common password salting application, it would look like this:\n• $2y is the hash algorithm (Blowfish in this case)\n• $10 is the cost (or complexity/time)\n• XElWz9WPwSLK3y0jUP6KhO is the salt (always 22 characters)\n• Hepv.KF4zj6z4J3XXyYRye.VXnPsMA2 is the hash of the password+salt (always 31 characters)\n\nIn addition to the salt, modern password hashing algorithms have been deliberately slowed down. It may take a second or two longer to create a password hash using modern salting techniques, but we don’t do it often and it is barely noticeable to us. To an attacker trying to create millions of hash guesses however that extra time is considerable. This extra complexity and time is configurable, so applications can make it even harder if required (at the cost of more computing power), and we can all make it harder over time as computing power increases.\n\nYou may have have noticed we are storing the salt with the hash. This means an attacker who has stolen the database knows the random salt string we added to each password to generate the hash. Turns out this isn’t very helpful for our attacker.\n\nIn theory the attacker could add the salt to a common password, generate the hash, then compare it to our stored hash to see if it matches.\n\nIt will work, but they have to do that for every password in their big list of common passwords with my salt until they find a match. With the slow Bcrypt algorithm on our side, this could take a very very long time.\n\nWhat’s worse for the hacker is that every salt is unique, which means that every user who has come up with the same password as me has a different hash. The attacker has to go through this common password + salt = hash process individually for each user in the database. What can be done in seconds with a SHA256 database may take thousands of years with a Bcrypt hash list.\n\nAdding salt to a hash increases the difficulty of rainbow lookups and brute-forcing significantly, and is now the minimum standard for password storage.\n\nStealing a user database isn’t the only way an attacker can hack your account, and it’s not the most common.\n\nThe admins at Widgetology limit the number of times you can enter an incorrect password before your account will be blocked. This prevents attackers from simply trying passwords continually until they guess the right one.\n\nHowever what is more difficult to defend against is an attacker using a single password against multiple accounts — a technique called password spraying. If they know or can guess usernames, they can over time simply try passwords against large numbers of accounts without being blocked.\n\nA variation is to try your username/password combination across multiple sites. Your email address is likely to be your username across many of the applications you use — so it’s only your password protecting you against this technique.\n\nWhich leads us to the primary point of this article…\n\nWhen we put all this together hopefully it’s become apparent that using the same password, and especially the same username/password across multiple sites is a bad idea!\n\nMany sites still use simple hashing for password storage and their databases are vulnerable to brute-force attacks if stolen. Even salted passwords can be cracked, it’s just a matter of time (with password complexity playing a big part).\n\nAs soon as a password database is leaked attackers all over the internet start brute-forcing the passwords, and from there start using the username/password combinations to try logging in to other sites.\n\nWant to know if your own super-secret passwords are already out there? Have I been Pwned will tell you. If you’ve been using your email address for more than a few years you will almost certainly be on the list.\n\nOther mistakes, mis-configurations and malicious insiders can cause plaintext passwords to leak. Admins are human too.\n\nIn addition to avoiding re-use, use complex passwords that are machine generated whenever possible. Use a password manager like 1Password, Bitwarden or LastPass to manage your passwords for you and help make them complex and unique. (Note that LastPass has had some bad publicity lately when users password databases were stolen. It’s still far more secure than managing your own passwords — assuming you don’t use a simple to guess password on your LastPass account. 1Password uses a less convenient method of securing your password database that is immune to that type of breach — your password database cannot be decrypted without a key that is only stored locally with you).\n\nIf you are creating your own passwords and need to remember them, use phrases rather than words to make them longer, and use uncommon words or nonsense sentences. Length is the most effective way to increase complexity.\n\nAnd always turn on two-factor authentication when it is available — preferably using an authenticator app rather than SMS."
    },
    {
        "link": "https://vaadata.com/blog/how-to-securely-store-passwords-in-database",
        "document": "Storing passwords securely is a recurring concern.\n\nBut what are the main methods, how do they work, and what are they worth against current password cracking techniques?\n\nIn this article we explain the main principles of secure storage (hash, salt, pepper, iteration) and highlight their importance for resisting password recovery methods. Finally, we will talk about a reliable hash function for secure storage.\n\nLet’s say an attacker manages to retrieve a database from a Web application and extracts from it the couple <Login, Password>.\n\nIn this case, the attacker directly owns the passwords of all users in plain text. Even Billy who has a strong password is not protected.\n\nStoring passwords in plain text is NOT a secure solution. No one, including website / database administrators, should have access to the plain text password of the user.\n\nIn some cases, passwords are stored in a database after being encrypted by a reversible algorithm (rot13, mask encryption…). As the algorithm is reversible, it does not comply with the rules of the CNIL (French National Commission on Informatics and Liberty).\n\nIndeed, it recommends that any password be transformed by a non-reversible cryptographic function. (source in French)\n\nSince the attacker knows his password in plain text/encrypted form, he can guess the logic of the encryption and try to reverse it. If he succeeds, all passwords will be retrieved as quickly as they were in plain text, regardless of the algorithm’s complexity.\n\nIn many cases, passwords are stored with outdated irreversible cryptographic functions (md5, sha1…). For example, the LinkedIn site used to store part of its passwords with sha1, and after the hash leaks in 2012, it took only three days to recover 90% of the passwords. (source in French)\n\nLet’s take the following database (the passwords are the same as earlier)\n• In our case, all passwords (except Billy’s) are very frequently used passwords and are among the most used passwords (for example in the 10-million-password-list-top-1000.txt)\n• It is also interesting to note that since hashs do not have a notion of randomness, toto and tata share the same hash, as they have the same password.\n\nA simple search of the admin’s hash on the internet allows to directly retrieve their passwords.\n\nExcept for the user Billy who has a complex password, it is possible to retrieve all hashes directly by queries in a search engine.\n\nIf the hashes are not found directly in a search engine, the attacker has other methods:\n\nBrute force is the action of trying out all the possibilities iteratively following a generation rule. It’s like when we try to open a padlock by listing all the possibilities from 0000 to 9999 until the lock opens.\n\nA dictionary attack is an attack where you try all the terms in a word list. Several types of dictionaries can be imagined:\n• A ranking of the most used passwords\n\nIf we take the image of the padlock, we can imagine a contextualised list like this:\n\nWe know that the padlock belongs to “Tutu”, that he loves the number 42, and that he was born on November 26, 2001. So we can assume that the padlock can possibly contain the number 42, 26, 11 and 01 and thus generate a list according to these criteria.\n\nNote: By abuse of language, it is common to call a dictionary attack a brute force attack.\n\nRainbow tables are a subject that deserves an article on its own. Quickly, it’s a data structure that allows retrieving passwords with a good storage/time compromise. This structure has a list of pre-calculated hashes and makes it possible to retrieve a hash in an acceptable time. \n\nMany rainbow tables are available online.\n\nA benchmark was performed on the database with the rockyou list which contains 14,341,564 unique passwords. The benchmark was performed on a virtual machine, which is not optimal for breaking passwords.\n\nLooking at the results, we see that except for Billy’s password, which isn’t in the rockyou list, all three passwords have been found and only 11 seconds were necessary for the software to calculate all hashes present in rockyou.\n\nAfter seeing the previous bad examples, it is tempting to use secure irreversible functions like sha256, sha512, or sha3. However, the purpose of these functions is to be used to compute a cryptographic summary to check the integrity of a file, to make an electronic signature, or to optimise search and indexing. They are not suitable for storing passwords, because they are fast to calculate, as the following benchmark proves:\n\nHere again, except for the user Billy, all passwords have been retrieved and only 16 seconds was necessary for hashcat to finish its operations.\n\nEven if it has been said earlier that the SHA512 function was not optimised for password storage, it may be interesting to show how to optimise it to understand the interest of appropriate hash functions for passwords.\n\nThe salt is a pollutant to the raw data (here the password) allowing producing two different hashes from the same data. The salt is unique for each user and is composed of a random sequence. It increases the chance that a password is unique and therefore the chance that a hash has never been used. \n\nFor example, with salt, toto and tata will not have the same hash in the database.\n\nThe advantages of salt are multiple:\n• It is almost impossible to find hash directly on the internet if it is salted. However, the salt must be long enough and random.\n• Rainbow tables do not work with salted hash.\n• As said before, two users with the same password will not have the same hash if salt is used. Password cracking software (hashcat, Johntheripper…), after breaking a hash, look to see if it is not present for another user. Therefore, without salt, after discovering the password of toto, the password of tata is directly discovered. However, with a salt, the software must start again from scratch for each user.\n\nWith this configuration, it took 33 seconds for the hashcat software to recover the passwords. None of the hashes in the database are indexed by a search engine.\n\nPepper is also a pollutant, but common to all users. It is not stored in a database, but in the sources of an application, in a configuration file or in an environment variable. An attacker having “just” understood a database must guess the pepper or retrieve it in another way to be able to effectively break hashes.\n\nAnother way to increase security is to repeat the number of iterations of hash. Increasing the number of iterations means that we’re going to hash the password several times. For example, with sha512 we have the following loop:\n\nAs long as iteration is greater than 0\n\n hash = sha512(hash)\n\n Decrement iteration\n\nFor a user who logs in, the calculation of the hash will be longer (it still takes a millisecond). But where a user loses a few milliseconds to log in, an attacker will lose much more time, because the attacker will lose several milliseconds per attempt, and since the attacker makes millions of attempts, this will result in additional hours/days to retrieve passwords.\n\nWe can merge the three methods (salt, pepper and number of iterations) to have one method to store passwords more securely than a simple hash.\n\nFunction calculation_hash(password,salt,pepper,iteration)\n\n Inputs\n\n password is the user's password in plain text\n\nsalt is the unique salt per user and is randomly generated\n\n pepper is the common pepper for all users and is randomly generated.\n\niteration is the number of iterations\n\n \n\nOutput:\n\n The password hash\n\n Hash = sha512(salt+password+pepper)\n\n As long as iteration is greater than 0\n\n hash = sha512(hash)\n\n Decrement iteration\n\n \n\n return hash\n\nThen, to check the passwords when logging in, just call the same function with the password entered by the user and compare it with the hash in the database. If both are identical, then the login is successful.\n\nPreviously, we managed to create an algorithm generating hashes that are more resistant to password cracking software. However, functions already exist and have proven their effectiveness over time. It is therefore useless to reinvent the wheel and risk causing errors. Among these different functions, we can find: Argon2, scrypt, PBKDF2, bcrypt…\n\nThese functions have many strengths:\n• More RAM-intensive (which is the weak point of GPUs)\n• Defining the number of iterations of the cryptographic function used. As seen previously, the more iterations, the more expensive the calculation will be.\n\nbcrypt is a hash function created by Niels Provos and David Mazières. It is based on the Blowfish encryption algorithm and was presented at USENIX in 1999.\n\nAmong these positive points in addition to those mentioned above we find implementations in many languages. Moreover, since this algorithm dates back to 1999, it has shown its robustness over time, where some algorithms like Argon2(i) only exist since 2015.\n\nThe hash computed by bcrypt has a predefined form:\n• Algorithm: This one can take several versions depending on the version of bcrypt ($2$, $2a$, $2x$, $2y$ and $2b$)\n• The cost: The number of iterations in power of 2. For example here, the iteration is 11, the algorithm will do 211 iterations (2048 iterations).\n• Salt: Instead of storing the salt in a dedicated column, it is directly stored in the final hash.\n\nSince bcrypt stores the number of iterations, this makes it an adaptive function, because the number of iterations can be increased and therefore it is longer and longer. This allows it, despite its age and the evolution of computing power, to be still robust against brute force attacks. The following benchmark shows that it takes 23 days for hashcat to compute the totality of rockyou hashes.\n\nIt is interesting to note that the passwords azerty and matrix, being very weak passwords and present at the top of the list, were found during the short time (2 hours) that the software worked in the example.\n\nWe have seen in this article the usefulness of a robust hash function and the advantage of using an already existing function. Moreover, the problem of password storage has legal issues in addition to security issues.\n\nFinally, it is interesting to note that in all cases the passwords azerty and matrix were found quickly, while the password yep59f$4txwrr was never found. Indeed, as this one is not present on any list, the only way to find it is to perform an exhaustive brute force on 13 characters, which is a very time-consuming operation (due to the large number of password possibilities). This also shows how important it is for a web application to force a strong password policy."
    }
]