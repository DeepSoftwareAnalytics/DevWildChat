[
    {
        "link": "https://docs.oracle.com/javase/tutorial/uiswing/index.html",
        "document": "The Java Tutorials have been written for JDK 8. Examples and practices described in this page don't take advantage of improvements introduced in later releases and might use technology no longer available. See Dev.java for updated tutorials taking advantage of the latest releases. See Java Language Changes for a summary of updated language features in Java SE 9 and subsequent releases. See JDK Release Notes for information about new features, enhancements, and removed or deprecated options for all JDK releases.\n\nAlso known as The Swing Tutorial\n\nThis trail tells you how to create graphical user interfaces (GUIs) for applications and applets, using the Swing components. If you would like to incorporate JavaFX into your Swing application, please see Integrating JavaFX into Swing Applications.\n\nGetting Started with Swing is a quick start lesson. First it gives you a bit of background about Swing. Then it tells you how to compile and run programs that use Swing components.\n\nLearning Swing with the NetBeans IDE is the fastest and easiest way to begin working with Swing. This lesson explores the NetBeans IDE's GUI builder, a powerful feature that lets you visually construct your Graphical User Interfaces.\n\nUsing Swing Components tells you how to use each of the Swing components  buttons, tables, text components, and all the rest. It also tells you how to use borders and icons.\n\nConcurrency in Swing discusses concurrency as it applies to Swing programming. Information on the event dispatch thread and the SwingWorker class are included.\n\nUsing Other Swing Features tells you how to use actions, timers, and the system tray; how to integrate with the desktop class, how to support assistive technologies, how to print tables and text, how to create a splash screen, and how to use modality in dialogs.\n\nLaying Out Components Within a Container tells you how to choose a layout manager, how to use each of the layout manager classes the Java platform provides, how to use absolute positioning instead of a layout manager, and how to create your own layout manager.\n\nModifying the Look and Feel tells you how to specify the look and feel of Swing components.\n\nDrag and Drop and Data Transfer tells you what you need to know to implement data transfer in your application.\n\nWriting Event Listeners tells you how to handle events in your programs.\n\nPerforming Custom Painting gives you information on painting your own Swing components. It discusses painting issues specific to Swing components, provides an overview of painting concepts, and has examples of custom components that paint themselves.\n\nAlthough this is the main trail for learning about GUIs, it isn't the only trail with UI-related information.\n• 2D Graphics, which describes the 2D graphics features available in the JDK.\n• Sound, which discusses the sound capabilities available in the JDK.\n• Java Applets, which describes API available only to applets.\n• Essential Java Classes, which covers many topics, including properties and the standard I/O streams.\n• The JavaFX Documentation, which describes how to build UIs with JavaFX.\n• The Bonus trail contains Full-Screen Exclusive Mode API, a lesson that describes how to use API introduced in v1.4 to render graphics directly to the screen."
    },
    {
        "link": "https://docs.oracle.com/javase/tutorial/uiswing/events/actionlistener.html",
        "document": "The Java Tutorials have been written for JDK 8. Examples and practices described in this page don't take advantage of improvements introduced in later releases and might use technology no longer available. See Dev.java for updated tutorials taking advantage of the latest releases. See Java Language Changes for a summary of updated language features in Java SE 9 and subsequent releases. See JDK Release Notes for information about new features, enhancements, and removed or deprecated options for all JDK releases.\n\nHow to Write an Action Listener\n\nAction listeners are probably the easiest — and most common — event handlers to implement. You implement an action listener to define what should be done when an user performs certain operation.\n\nAn action event occurs, whenever an action is performed by the user. Examples: When the user clicks a button, chooses a menu item, presses Enter in a text field. The result is that an message is sent to all action listeners that are registered on the relevant component.\n\nTo write an Action Listener, follow the steps given below:\n• Declare an event handler class and specify that the class either implements an ActionListener interface or extends a class that implements an ActionListener interface. For example:\n• Register an instance of the event handler class as a listener on one or more components. For example:\n• Include code that implements the methods in listener interface. For example: public void actionPerformed(ActionEvent e) { ...//code that reacts to the action... }\n\nIn general, to detect when the user clicks an onscreen button (or does the keyboard equivalent), a program must have an object that implements the ActionListener interface. The program must register this object as an action listener on the button (the event source), using the addActionListener method. When the user clicks the onscreen button, the button fires an action event. This results in the invocation of the action listener's actionPerformed method (the only method in the ActionListener interface). The single argument to the method is an ActionEvent object that gives information about the event and its source.\n\nLet us write a simple program which displays how many number of times a button is clicked by the user. First, here is the code that sets up the TextField , button and numClicks variable:\n\nIn the above example, the event handler class is AL which implements ActionListener.\n\nWe would like to handle the button-click event, so we add an action listener to the button b as below:\n\nIn the above code, Button b is a component upon which an instance of event handler class AL is registered.\n\nNow, we want to display the text as to how many number of times a user clicked button. We can do this by writing the code as below:\n\nNow, when the user clicks the Button b, the button fires an action event which invokes the action listener's actionPerformed method. Each time the user presses the button, numClicks variable is appended and the message is displayed in the text field.\n\nHere is the complete program(AL.java):\n\nMore Examples: program example is available in this trail's introduction to events, Introduction to Event Listeners. You can find the entire program in . The other example described in that section, , has two action sources and two action listeners, with one listener listening to both sources and the other listening to just one.\n\nBecause has only one method, it has no corresponding adapter class.\n\nThe following table lists some of the many examples that use action listeners."
    },
    {
        "link": "https://medium.com/@rolandmack63/introduction-to-java-gui-programming-with-swing-c9bedda86ee8",
        "document": "Java Swing is a powerful toolkit for creating graphical user interfaces (GUIs) in Java. It provides a wide range of components, such as buttons, text fields, and menus, that can be used to create attractive and functional GUIs. Swing is platform-independent, which means that your GUIs will look the same on any platform, including Windows, Mac OS X, and Linux.\n\nIn this blog post, we will give you a brief introduction to Java Swing. We will cover the following topics:\n\nJava Swing is a set of graphical user interface (GUI) components that are part of the Java platform. Swing components are built on top of the Abstract Window Toolkit (AWT), but they provide a number of advantages over AWT components. For example, Swing components are more lightweight and efficient, and they are platform-independent.\n\nJava Swing is included in the Java Development Kit (JDK). If you already have the JDK installed, you can skip this section.\n\nTo install the JDK, go to the Oracle website and download the latest version of the JDK for your operating system. Once the JDK is installed, you can start creating Swing GUIs.\n\nTo create a simple Swing GUI, you will need to create a new Java project and add a Swing library to the project. Once you have added the Swing library, you can start creating Swing components.\n\nThe following code shows how to create a simple Swing GUI with a button and a text field:\n\nThis code will create a simple GUI with a button and a text field. When the user clicks the button, the program will print “Hello, “ + textField.getText() + “!” to the console.\n\nSwing provides a wide range of components that can be used to create GUIs. Some of the most commonly used components include:\n\nLayout managers are used to control the layout of components in a GUI. Swing provides a number of different layout managers, including:\n\nSwing components can respond to events, such as mouse clicks and key presses. To handle events, you need to add event listeners to the components. Event listeners are objects that implement the ActionListener, KeyListener, or other event listener interfaces. Check here for Java Course in Gurgaon"
    },
    {
        "link": "https://geeksforgeeks.org/java-actionlistener-in-awt",
        "document": "The Java Abstract Window Toolkit (AWT) is a GUI framework that provides a set of classes and methods for creating and managing user interfaces in Java applications. One of the most important components in AWT is the ActionListener interface. It is a key element for adding interactivity in Java applications by handling user actions. In this article, let us understand about the ActionListener interface in detail.\n\nIn Java AWT, the ActionListener interface is a part of the 'java.awt.event' package. When you click on a button, menu item, or a check box, the Java ActionListener is called. It is notified in reference to an ActionEvent. It only has one method, actionPerformed(). The principle of an ActionListener is to record and respond to user interactions with GUI components.\n\n1. At first, implement the ActionListener interface in the class.\n\n2. Configure the component with the Listener.\n\n3. Override the actionPerformed method as a response to the method call.\n\nGiven below are some examples that will help you to understand the workings of the ActionListener interface easily.\n\nIn this example, a simple ActionListener is implemented on a Button component. The text on the label is updated with the name entered in the TextField when the Button is clicked.\n\nRun the code using the following commands:\n\nFinal Screen Output of the Example:\n\nIn this example, when the \"Order\" button is clicked, the ActionListener calculates the total cost of selected food items and displays it in a message dialog.\n\nRun the code using the following commands:\n\nFinal Screen Output of the Example:"
    },
    {
        "link": "https://doc.castsoftware.com/export/FBP/SWING+and+AWT+-+Best+Practice",
        "document": "Created by , last modified on Aug 17, 2018\n\nSummary: This document provides a guide based on CAST’s field experience on how to configure Swing and AWT based applications using CAST AIP. These configurations are used all versions of CAST AIP 8.2.x and above for Swing and AWT offering (see Reference Materials below for links) to overcome limitations such as missing links. The applicability of this guide should have assessed for newer versions of CAST AIP and Extension.\n\nThis section gives a brief overview of the framework.\n\nAbstract Window Toolkit (AWT) is Java's original platform-dependent windowing, graphics, and user-interface widget toolkit. From first release of Sun Microsystems Java in 1995, AWT.\n• None\n• Java 1.0 & Java 1.1 - These features are provided by the Abstract Windowing Toolkit (AWT). Java 2D\n• Java 2.0 - Swing is a core part for this release.\n\nAWT existed before JFC. AWT was heavily criticized for being little more than a wrapper around the native graphical capabilities of the host platform.\n\nAn alternative graphics library called the Internet Foundation Classes was developed in more platform-independent code by Netscape.\n\nSame time, another graphics library, called Application Foundation Classes (AFC), was developed independently by Microsoft. It was made to be easier to extend the graphic components, but was primarily aimed for use with the Microsoft Java Virtual Machine.\n\nOn April 2, 1997, Sun Microsystems and Netscape announced their intention to combine IFC with other technologies to form the \"Java Foundation Classes\".[1] It is later renamed to \"Swing\", adding the capability for a pluggable look and feel of the widgets.\n\nVersions of Swing and AWT supported by CAST\n\nThis section highlights the Swing and AWT versions supported by CAST AIP 8.2.x.\n\nThis section highlights all the file types that can be expected to be delivered if the application has implemented this framework.\n\nHow to identify the implementation of Swing and AWT\n\nThis section details the approach for identifying the presence of Swing and AWT in the code delivered.\n\nThis section gives a brief overview of Swing and AWT.\n\nThe Java Foundation Classes (JFC) are a comprehensive set of GUI components and services which dramatically simplify the development and deployment of commercial-quality desktop and Internet/Intranet applications.\n• Swing is the project code name for the lightweight GUI components in JFC.\n• Accessibility API enables Java applications to work with alternate input and output devices such as Screen Readers, Screen Magnifiers, Braille terminals, and others.\n• Java 2D, developers can render, manipulate, and transform complex 2D images and text. Java 2D enables the creation of richer-looking components and applications.\n\nDrag & Drop - Supports dragging and dropping of objects between java program or non-java programs.\n\nHow to configure Swing and AWT in CAST AIP\n\nThis section describes all the CAST configuration steps to be followed in order to configure Swing and AWT based application.\n\nThis section gives an overview of the Enlighten diagram."
    },
    {
        "link": "https://geeksforgeeks.org/event-handling-in-java",
        "document": "An event is a change in the state of an object triggered by some action such as Clicking a button, Moving the cursor, Pressing a key on the keyboard, Scrolling a page, etc. In Java, the java.awt.event package provides various event classes to handle these actions.\n\nEvents in Java can be broadly classified into two categories based on how they are generated:\n• Foreground Events: Foreground events are the events that require user interaction to generate. Examples of these events include Button clicks, Scrolling the scrollbar, Moving the cursor, etc.\n• Background Events: Events that don’t require interactions of users to generate are known as background events. Examples of these events are operating system failures/interrupts, operation completion, etc.\n\nEvent handling is a mechanism that allows programs to control events and define what should happen when an event occurs. Java uses the Delegation Event Model to handle events. This model consists of two main components:\n• Source: Events are generated from the source. There are various sources like buttons, checkboxes, list, menu-item, choice, scrollbar, text components, windows, etc., to generate events.\n• Listeners: Listeners are used for handling the events generated from the source. Each of these listeners represents interfaces that are responsible for handling events.\n\nTo handle events, the source must be registered with a listener. Java provides specific methods for registering listeners based on the type of event.\n\nJava provides a variety of event classes and corresponding listener interfaces. Below table demonstrates the most commonly used event classes and their associated listener interfaces:\n\nAn event that indicates that a component-defined action occurred like a button click or selecting an item from the menu-item list. The adjustment event is emitted by an Adjustable object like Scrollbar. An event that indicates that a component moved, the size changed or changed its visibility. When a component is added to a container (or) removed from it, then this event is generated by a container object. These are focus-related events, which include focus, focusin, focusout, and blur. An event that indicates whether an item was selected or not. An event that occurs due to a sequence of keypresses on the keyboard. The events that occur due to the user interaction with the mouse (Pointing Device). An event that specifies that the mouse wheel was rotated in a component. An event that occurs when an object’s text changes. An event which indicates whether a window has changed its status or not.\n\nNote: As Interfaces contains abstract methods which need to implemented by the registered class to handle events.\n\nEach listener interface contains specific methods that must be implemented to handle events. Below table demonstrates the key methods for each interface:\n\nThe event handling process in Java follows these steps:\n• None User Interaction with a component is required to generate an event.\n• None The object of the respective event class is created automatically after event generation, and it holds all information of the event source.\n• None The newly created object is passed to the methods of the registered listener.\n• None The method executes and returns the result.\n\nJava provides three main approaches to implement event handling\n• None Firstly extend the class with the applet and implement the respective listener.\n• None Registered the button component with respective event. i.e. ActionEvent by addActionListener().\n• None In the end, implement the abstract method.\n\nNote: To run event handling code, use an IDE or install the JDK. Online compilers may throw errors due to the unavailability of certain packages."
    },
    {
        "link": "https://docs.oracle.com/javase/tutorial/uiswing/index.html",
        "document": "The Java Tutorials have been written for JDK 8. Examples and practices described in this page don't take advantage of improvements introduced in later releases and might use technology no longer available. See Dev.java for updated tutorials taking advantage of the latest releases. See Java Language Changes for a summary of updated language features in Java SE 9 and subsequent releases. See JDK Release Notes for information about new features, enhancements, and removed or deprecated options for all JDK releases.\n\nAlso known as The Swing Tutorial\n\nThis trail tells you how to create graphical user interfaces (GUIs) for applications and applets, using the Swing components. If you would like to incorporate JavaFX into your Swing application, please see Integrating JavaFX into Swing Applications.\n\nGetting Started with Swing is a quick start lesson. First it gives you a bit of background about Swing. Then it tells you how to compile and run programs that use Swing components.\n\nLearning Swing with the NetBeans IDE is the fastest and easiest way to begin working with Swing. This lesson explores the NetBeans IDE's GUI builder, a powerful feature that lets you visually construct your Graphical User Interfaces.\n\nUsing Swing Components tells you how to use each of the Swing components  buttons, tables, text components, and all the rest. It also tells you how to use borders and icons.\n\nConcurrency in Swing discusses concurrency as it applies to Swing programming. Information on the event dispatch thread and the SwingWorker class are included.\n\nUsing Other Swing Features tells you how to use actions, timers, and the system tray; how to integrate with the desktop class, how to support assistive technologies, how to print tables and text, how to create a splash screen, and how to use modality in dialogs.\n\nLaying Out Components Within a Container tells you how to choose a layout manager, how to use each of the layout manager classes the Java platform provides, how to use absolute positioning instead of a layout manager, and how to create your own layout manager.\n\nModifying the Look and Feel tells you how to specify the look and feel of Swing components.\n\nDrag and Drop and Data Transfer tells you what you need to know to implement data transfer in your application.\n\nWriting Event Listeners tells you how to handle events in your programs.\n\nPerforming Custom Painting gives you information on painting your own Swing components. It discusses painting issues specific to Swing components, provides an overview of painting concepts, and has examples of custom components that paint themselves.\n\nAlthough this is the main trail for learning about GUIs, it isn't the only trail with UI-related information.\n• 2D Graphics, which describes the 2D graphics features available in the JDK.\n• Sound, which discusses the sound capabilities available in the JDK.\n• Java Applets, which describes API available only to applets.\n• Essential Java Classes, which covers many topics, including properties and the standard I/O streams.\n• The JavaFX Documentation, which describes how to build UIs with JavaFX.\n• The Bonus trail contains Full-Screen Exclusive Mode API, a lesson that describes how to use API introduced in v1.4 to render graphics directly to the screen."
    },
    {
        "link": "https://geeksforgeeks.org/introduction-to-java-swing",
        "document": "Swing is a Java Foundation Classes [JFC] library and an extension of the Abstract Window Toolkit [AWT]. Java Swing offers much-improved functionality over AWT, new components, expanded components features, and excellent event handling with drag-and-drop support.\n\nSwing has about four times the number of User Interface [UI] components as AWT and is part of the standard Java distribution. By today’s application GUI requirements, AWT is a limited implementation, not quite capable of providing the components required for developing complex GUIs required in modern commercial applications. The AWT component set has quite a few bugs and does take up a lot of system resources when compared to equivalent Swing resources. Netscape introduced its Internet Foundation Classes [IFC] library for use with Java. Its Classes became very popular with programmers creating GUI’s for commercial applications.\n• None Swing is a Set of API (API- Set of Classes and Interfaces)\n• None Swing is an Extension library to the AWT (Abstract Window Toolkit)\n• None Includes New and improved Components that have been enhancing the looks and Functionality of GUIs’\n• None Swing can be used to build (Develop) The Standalone swing GUI Apps as Servlets and Applets\n• None Swing is more portable and more flexible than AWT, the Swing is built on top of the AWT.\n• None Swing is Entirely written in Java.\n• None Java Swing Components are Platform-independent, and The Swing Components are lightweight.\n• None Swing Supports a Pluggable look and feel and Swing provides more powerful components.\n• None such as tables, lists, Scrollpanes, Colourchooser, tabbed pane, etc.\n\nThere are certain points from which Java Swing is different than Java AWT as mentioned below:\n\nTo know more about the topic, refer to Java Swing vs Java AWT.\n\nJFC stands for Java Foundation Classes. JFC is the set of GUI components that simplify desktop Applications. Many programmers think that JFC and Swing are one and the same thing, but that is not so. JFC contains Swing [A UI component package] and quite a number of other items:\n• None Accessibility features: Aimed at developing GUIs for users with disabilities.\n• None The Desktop Colors Features were first introduced in Java 1.1\n• None Java 2D: it has Improved colors, images, and text support.\n• None Advanced features such as JTable, JTabbedPane, JScollPane, etc.\n• None Java is a platform-independent language and runs on any client machine, the GUI look and feel, owned and delivered by a platform-specific O/S, simply does not affect an application’s GUI constructed using Swing components.\n• Lightweight Components: Starting with the JDK 1.1, its AWT-supported lightweight component development. For a component to qualify as lightweight, it must not depend on any non-Java [O/s based) system classes. Swing components have their own view supported by Java’s look and feel classes.\n• Pluggable Look and Feel: This feature enable the user to switch the look and feel of Swing components without restarting an application. The Swing library supports components’ look and feels that remain the same across all platforms wherever the program runs. The Swing library provides an API that gives real flexibility in determining the look and feel of the GUI of an application\n• Highly customizable – Swing controls can be customized in a very easy way as visual appearance is independent of internal representation.\n• Rich controls – Swing provides a rich set of advanced controls like Tree TabbedPane, slider, colorpicker, and table controls.\n• None In general, a visual component is a composite of three distinct aspects:\n• None The way that the component looks when rendered on the screen.\n• None The way such that the component reacts to the user.\n• None The state information associated with the component.\n• None Over the years, one component architecture has proven itself to be exceptionally effective: – Model-View-Controller MVC\n• model corresponds to the state information associated with the Component.\n• view determines how the component is displayed on the screen, including any aspects of the view that are affected by the current state of the model.\n• controller determines how the component reacts to the user.\n\nThe simplest Swing components have capabilities far beyond AWT components as follows:\n• None Swing buttons and labels can be displaying images instead of or in addition to text.\n• None The borders around most Swing components can be changed easily. For example, it is easy to put a 1-pixel border around the outside of a Swing label.\n• None Swing components do not have to be rectangular. Buttons, for example, can be round.\n• None Now The Latest Assertive technologies such as screen readers can easily get information from Swing components. Example: A screen reader tool can easily capture the text that is displayed on a Swing button or label.\n\nExample 1: Develop a program using label (swing) to display the message “GFG WEB Site Click”:\n\nExample 2: Write a program to create three buttons with caption OK, SUBMIT, CANCEL.\n\nExample 3: Program to Add Checkbox in the Frame\n\nA Component is the Abstract base class for about the non-menu user-interface controls of Java SWING. Components are representing an object with a graphical representation. A Container is a component that can container Java SWING Components A JComponent is a base class for all swing UI Components In order to use a swing component that inherits from JComponent, the component must be in a containment hierarchy whose root is a top-level Java Swing container. A JLabel is an object component for placing text in a container. A JColorChooser provides a pane of controls designed to allow the user to manipulate and select a color. A JCheckBox is a graphical (GUI) component that can be in either an on-(true) or off-(false) state. The JRadioButton class is a graphical (GUI) component that can be in either an on-(true) or off-(false) state. in the group A JList component represents the user with the scrolling list of text items. A JComboBox component is Presents the User with a show up Menu of choices. A JTextField object is a text component that will allow for the editing of a single line of text. A JPasswordField object it is a text component specialized for password entry. A JTextArea object is a text component that allows for the editing of multiple lines of text. A ImageIcon control is an implementation of the Icon interface that paints Icons from Images A JScrollbar control represents a scroll bar component in order to enable users to Select from range values. JOptionPane provides set of standard dialog boxes that prompt users for a value or Something. A JFileChooser it Controls represents a dialog window from which the user can select a file. As the task progresses towards completion, the progress bar displays the tasks percentage on its completion. A JSlider this class is letting the user graphically (GUI) select by using a value by sliding a knob within a bounded interval. A JSpinner this class is a single line input where the field that lets the user select by using a number or an object value from an ordered sequence."
    },
    {
        "link": "https://docs.oracle.com/javase/tutorial/uiswing/events/generalrules.html",
        "document": "The Java Tutorials have been written for JDK 8. Examples and practices described in this page don't take advantage of improvements introduced in later releases and might use technology no longer available. See Dev.java for updated tutorials taking advantage of the latest releases. See Java Language Changes for a summary of updated language features in Java SE 9 and subsequent releases. See JDK Release Notes for information about new features, enhancements, and removed or deprecated options for all JDK releases.\n\nThis section discusses several design considerations to keep in mind when implementing event handlers in your application. We then introduce you to event objects small objects that describe each event. In particular, we talk about , the superclass for all AWT and Swing events. Next, we introduce the concepts of low-level events and semantic events, recommending that you prefer semantic events when possible. The remainder of this section discusses implementation techniques you might use in some event listeners or see in event listeners created by other people or by GUI builders.\n• Inner Classes and Anonymous Inner Classes\n\nThe most important rule to keep in mind about event listeners is that they should execute very quickly. Because all drawing and event-listening methods are executed in the same thread, a slow event-listener method can make the program seem unresponsive and slow to repaint itself. If you need to perform some lengthy operation as the result of an event, do it by starting up another thread (or somehow sending a request to another thread) to perform the operation. For help on using threads, see Concurrency in Swing.\n\nYou have many choices on how to implement an event listener. We can not recommend a specific approach because one solution would not suit all situations. However, we can give you some hints and show you some techniques that you might see, even if you do not use the same solution in your program.\n\nFor example, you might choose to implement separate classes for different kinds of event listeners. This can be an easy architecture to maintain, but many classes can also mean reduced performance.\n\nWhen designing your program, you might want to implement your event listeners in a class that is not public, but somewhere more hidden. A private implementation is a more secure implementation.\n\nIf you have a very specific kind of simple event listener, you might be able to avoid creating a class at all by using the class.\n\nEvery event-listener method has a single argument an object that inherits from the class. Although the argument always descends from , its type is generally specified more precisely. For example, the argument for methods that handle mouse events is an instance of , where is an indirect subclass of .\n\nThe class defines one very useful method:\n\nNote that the method returns an . Event classes sometimes define methods similar to , but that have more restricted return types. For example, the class defines a method that just like returns the object that fired the event. The difference is that always returns a . Each how-to page for event listeners mentions whether you should use or another method to get the event source.\n\nOften, an event class defines methods that return information about the event. For example, you can query a object for information about where the event occurred, how many clicks the user made, which modifier keys were pressed, and so on.\n\nEvents can be divided into two groups: low-level events and semantic events. Low-level events represent window-system occurrences or low-level input. Everything else is a semantic event.\n\nExamples of low-level events include mouse and key events both of which result directly from user input. Examples of semantic events include action and item events. A semantic event might be triggered by user input; for example, a button customarily fires an action event when the user clicks it, and a text field fires an action event when the user presses Enter. However, some semantic events are not triggered by low-level events, at all. For example, a table-model event might be fired when a table model receives new data from a database.\n\nWhenever possible, you should listen for semantic events rather than low-level events. That way, you can make your code as robust and portable as possible. For example, listening for action events on buttons, rather than mouse events, means that the button will react appropriately when the user tries to activate the button using a keyboard alternative or a look-and-feel-specific gesture. When dealing with a compound component such as a combo box, it is imperative that you stick to semantic events, since you have no reliable way of registering listeners on all the look-and-feel-specific components that might be used to form the compound component.\n\nSome listener interfaces contain more than one method. For example, the interface contains five methods: , , , , and . Even if you care only about mouse clicks, if your class directly implements , then you must implement all five methods. Methods for those events you do not care about can have empty bodies. Here is an example:\n\nThe resulting collection of empty method bodies can make code harder to read and maintain. To help you avoid implementing empty method bodies, the API generally includes an adapter class for each listener interface with more than one method. (The Listener API Table lists all the listeners and their adapters.) For example, the class implements the interface. An adapter class implements empty versions of all its interface's methods.\n\nTo use an adapter, you create a subclass of it and override only the methods of interest, rather than directly implementing all methods of the listener interface. Here is an example of modifying the preceding code to extend . By extending , it inherits empty definitions of all five of the methods that contains.\n\nInner Classes and Anonymous Inner Classes\n\nWhat if you want to use an adapter class, but do not want your public class to inherit from an adapter class? For example, suppose you write an applet, and you want your subclass to contain some code to handle mouse events. Since the Java language does not permit multiple inheritance, your class cannot extend both the and classes. A solution is to define an inner class a class inside of your subclass that extends the class.\n\nInner classes can also be useful for event listeners that implement one or more interfaces directly.\n\nYou can create an inner class without specifying a name this is known as an anonymous inner class. While it might look strange at first glance, anonymous inner classes can make your code easier to read because the class is defined where it is referenced. However, you need to weigh the convenience against possible performance implications of increasing the number of classes.\n\nHere is an example of using an anonymous inner class:\n\nInner classes work even if your event listener needs access to private instance variables from the enclosing class. As long as you do not declare an inner class to be , an inner class can refer to instance variables and methods just as if its code is in the containing class. To make a local variable available to an inner class, just save a copy of the variable as a local variable.\n\nTo refer to the enclosing instance, you can use . For more information about inner classes, see Nested Classes.\n\nAn class supports dynamic generation of simple, one-statement event listeners. Although is only useful for a certain type of extremely simple event listeners, it is worth mentioning for two reasons. It is useful for:\n• Making an event listener that persistence can see and yet does not clog up your own classes with event listener interfaces and methods.\n• Not adding to the number of classes defined in an application this can help performance.\n\nCreating an by hand is difficult. An must be carefully constructed. If you make a mistake, you would not be notified at compile time it will throw an obscure exception at runtime. For this reason, s are best created by a GUI builder. s should be carefully documented. Otherwise you run the risk of producing hard-to-read code.\n\nThe class is intended to be used by interactive tools, such as application builders, that allow developers to make connections between beans. Typically connections are made from a user interface bean (the event source) to an application logic bean (the target). The most effective connections of this kind isolate the application logic from the user interface. For example, the for a connection from a JCheckBox to a method that accepts a boolean value can deal with extracting the state of the check box and passing it directly to the method so that the method is isolated from the user interface layer.\n\nInner classes are another, more general way to handle events from user interfaces. The class handles only a subset of what is possible using inner classes. However, works better with the long-term persistence scheme than inner classes. Also, using in large applications in which the same interface is implemented many times can reduce the disk and memory footprint of the application.\n\nExamples of Using The simplest use of is to install a listener that calls a method on the target object with no arguments. In the following example we create an ActionListener that invokes the toFront method on an instance of .\n\nWhen myButton is pressed, the statement frame.toFront() will be executed. One could get the same effect, with some additional compile-time type safety, by defining a new implementation of the ActionListener interface and adding an instance of it to the button:\n\nThe next simplest use of is to extract a property value from the first argument of the method in the listener interface (typically an event object) and use it to set the value of a property in the target object. In the following example we create an ActionListener that sets the nextFocusableComponent property of the target (myButton) object to the value of the \"source\" property of the event.\n\nThis would correspond to the following inner class implementation:\n\nIt is also possible to create an that just passes the incoming event object to the target's action. If the fourth argument is an empty string, then the event is just passed along:\n\nThis would correspond to the following inner class implementation:\n\nProbably the most common use of is to extract a property value from the source of the event object and set this value as the value of a property of the target object. In the following example we create an ActionListener that sets the \"label\" property of the target object to the value of the \"text\" property of the source (the value of the \"source\" property) of the event.\n\nThis would correspond to the following inner class implementation:"
    }
]