[
    {
        "link": "https://postgresql.org/docs/current/sql-createtable.html",
        "document": "The optional clause specifies a list of tables from which the new table automatically inherits all columns. Parent tables can be plain tables or foreign tables. Use of creates a persistent relationship between the new child table and its parent table(s). Schema modifications to the parent(s) normally propagate to children as well, and by default the data of the child table is included in scans of the parent(s). If the same column name exists in more than one parent table, an error is reported unless the data types of the columns match in each of the parent tables. If there is no conflict, then the duplicate columns are merged to form a single column in the new table. If the column name list of the new table contains a column name that is also inherited, the data type must likewise match the inherited column(s), and the column definitions are merged into one. If the new table explicitly specifies a default value for the column, this default overrides any defaults from inherited declarations of the column. Otherwise, any parents that specify default values for the column must all specify the same default, or an error will be reported. constraints are merged in essentially the same way as columns: if multiple parent tables and/or the new table definition contain identically-named constraints, these constraints must all have the same check expression, or an error will be reported. Constraints having the same name and expression will be merged into one copy. A constraint marked in a parent will not be considered. Notice that an unnamed constraint in the new table will never be merged, since a unique name will always be chosen for it. Column settings are also copied from parent tables. If a column in the parent table is an identity column, that property is not inherited. A column in the child table can be declared identity column if desired.\n\nCreates the table as a partition of the specified parent table. The table can be created either as a partition for specific values using or as a default partition using . Any indexes, constraints and user-defined row-level triggers that exist in the parent table are cloned on the new partition. The must correspond to the partitioning method and partition key of the parent table, and must not overlap with any existing partition of that parent. The form with is used for list partitioning, the form with and is used for range partitioning, and the form with is used for hash partitioning. is any variable-free expression (subqueries, window functions, aggregate functions, and set-returning functions are not allowed). Its data type must match the data type of the corresponding partition key column. The expression is evaluated once at table creation time, so it can even contain volatile expressions such as . When creating a list partition, can be specified to signify that the partition allows the partition key column to be null. However, there cannot be more than one such list partition for a given parent table. cannot be specified for range partitions. When creating a range partition, the lower bound specified with is an inclusive bound, whereas the upper bound specified with is an exclusive bound. That is, the values specified in the list are valid values of the corresponding partition key columns for this partition, whereas those in the list are not. Note that this statement must be understood according to the rules of row-wise comparison (Section 9.25.5). For example, given , a partition bound allows with any , with any non-null , and with any . The special values and may be used when creating a range partition to indicate that there is no lower or upper bound on the column's value. For example, a partition defined using allows any values less than 10, and a partition defined using allows any values greater than or equal to 10. When creating a range partition involving more than one column, it can also make sense to use as part of the lower bound, and as part of the upper bound. For example, a partition defined using allows any rows where the first partition key column is greater than 0 and less than or equal to 10. Similarly, a partition defined using allows any rows where the first partition key column starts with \"a\". Note that if or is used for one column of a partitioning bound, the same value must be used for all subsequent columns. For example, is not a valid bound; you should write . Also note that some element types, such as , have a notion of \"infinity\", which is just another value that can be stored. This is different from and , which are not real values that can be stored, but rather they are ways of saying that the value is unbounded. can be thought of as being greater than any other value, including \"infinity\" and as being less than any other value, including \"minus infinity\". Thus the range is not an empty range; it allows precisely one value to be stored — \"infinity\". If is specified, the table will be created as the default partition of the parent table. This option is not available for hash-partitioned tables. A partition key value not fitting into any other partition of the given parent will be routed to the default partition. When a table has an existing partition and a new partition is added to it, the default partition must be scanned to verify that it does not contain any rows which properly belong in the new partition. If the default partition contains a large number of rows, this may be slow. The scan will be skipped if the default partition is a foreign table or if it has a constraint which proves that it cannot contain rows which should be placed in the new partition. When creating a hash partition, a modulus and remainder must be specified. The modulus must be a positive integer, and the remainder must be a non-negative integer less than the modulus. Typically, when initially setting up a hash-partitioned table, you should choose a modulus equal to the number of partitions and assign every table the same modulus and a different remainder (see examples, below). However, it is not required that every partition have the same modulus, only that every modulus which occurs among the partitions of a hash-partitioned table is a factor of the next larger modulus. This allows the number of partitions to be increased incrementally without needing to move all the data at once. For example, suppose you have a hash-partitioned table with 8 partitions, each of which has modulus 8, but find it necessary to increase the number of partitions to 16. You can detach one of the modulus-8 partitions, create two new modulus-16 partitions covering the same portion of the key space (one with a remainder equal to the remainder of the detached partition, and the other with a remainder equal to that value plus 8), and repopulate them with data. You can then repeat this -- perhaps at a later time -- for each modulus-8 partition until none remain. While this may still involve a large amount of data movement at each step, it is still better than having to create a whole new table and move all the data at once. A partition must have the same column names and types as the partitioned table to which it belongs. Modifications to the column names or types of a partitioned table will automatically propagate to all partitions. constraints will be inherited automatically by every partition, but an individual partition may specify additional constraints; additional constraints with the same name and condition as in the parent will be merged with the parent constraint. Defaults may be specified separately for each partition. But note that a partition's default value is not applied when inserting a tuple through a partitioned table. Rows inserted into a partitioned table will be automatically routed to the correct partition. If no suitable partition exists, an error will occur. Operations such as which normally affect a table and all of its inheritance children will cascade to all partitions, but may also be performed on an individual partition. Note that creating a partition using requires taking an lock on the parent partitioned table. Likewise, dropping a partition with requires taking an lock on the parent table. It is possible to use to perform these operations with a weaker lock, thus reducing interference with concurrent operations on the partitioned table.\n\nThe clause specifies a table from which the new table automatically copies all column names, their data types, and their not-null constraints. Unlike , the new table and original table are completely decoupled after creation is complete. Changes to the original table will not be applied to the new table, and it is not possible to include data of the new table in scans of the original table. Also unlike , columns and constraints copied by are not merged with similarly named columns and constraints. If the same name is specified explicitly or in another clause, an error is signaled. The optional clauses specify which additional properties of the original table to copy. Specifying copies the property, specifying omits the property. is the default. If multiple specifications are made for the same kind of object, the last one is used. The available options are: Comments for the copied columns, constraints, and indexes will be copied. The default behavior is to exclude comments, resulting in the copied columns and constraints in the new table having no comments. Compression method of the columns will be copied. The default behavior is to exclude compression methods, resulting in columns having the default compression method. constraints will be copied. No distinction is made between column constraints and table constraints. Not-null constraints are always copied to the new table. Default expressions for the copied column definitions will be copied. Otherwise, default expressions are not copied, resulting in the copied columns in the new table having null defaults. Note that copying defaults that call database-modification functions, such as , may create a functional linkage between the original and new tables. Any generation expressions of copied column definitions will be copied. By default, new columns will be regular base columns. Any identity specifications of copied column definitions will be copied. A new sequence is created for each identity column of the new table, separate from the sequences associated with the old table. Indexes, , , and constraints on the original table will be created on the new table. Names for the new indexes and constraints are chosen according to the default rules, regardless of how the originals were named. (This behavior avoids possible duplicate-name failures for the new indexes.) Extended statistics are copied to the new table. settings for the copied column definitions will be copied. The default behavior is to exclude settings, resulting in the copied columns in the new table having type-specific default settings. For more on settings, see Section 65.2. is an abbreviated form selecting all the available individual options. (It could be useful to write individual clauses after to select all but some specific options.) The clause can also be used to copy column definitions from views, foreign tables, or composite types. Inapplicable options (e.g., from a view) are ignored.\n\nThe constraint specifies that a group of one or more columns of a table can contain only unique values. The behavior of a unique table constraint is the same as that of a unique column constraint, with the additional capability to span multiple columns. The constraint therefore enforces that any two rows must differ in at least one of these columns. For the purpose of a unique constraint, null values are not considered equal, unless is specified. Each unique constraint should name a set of columns that is different from the set of columns named by any other unique or primary key constraint defined for the table. (Otherwise, redundant unique constraints will be discarded.) When establishing a unique constraint for a multi-level partition hierarchy, all the columns in the partition key of the target partitioned table, as well as those of all its descendant partitioned tables, must be included in the constraint definition. Adding a unique constraint will automatically create a unique btree index on the column or group of columns used in the constraint. The created index has the same name as the unique constraint. The optional clause adds to that index one or more columns that are simply “payload”: uniqueness is not enforced on them, and the index cannot be searched on the basis of those columns. However they can be retrieved by an index-only scan. Note that although the constraint is not enforced on included columns, it still depends on them. Consequently, some operations on such columns (e.g., ) can cause cascaded constraint and index deletion.\n\nThe clause defines an exclusion constraint, which guarantees that if any two rows are compared on the specified column(s) or expression(s) using the specified operator(s), not all of these comparisons will return . If all of the specified operators test for equality, this is equivalent to a constraint, although an ordinary unique constraint will be faster. However, exclusion constraints can specify constraints that are more general than simple equality. For example, you can specify a constraint that no two rows in the table contain overlapping circles (see Section 8.8) by using the operator. The operator(s) are required to be commutative. Exclusion constraints are implemented using an index that has the same name as the constraint, so each specified operator must be associated with an appropriate operator class (see Section 11.10) for the index access method . Each defines a column of the index, so it can optionally specify a collation, an operator class, operator class parameters, and/or ordering options; these are described fully under CREATE INDEX. The access method must support (see Chapter 62); at present this means cannot be used. Although it's allowed, there is little point in using B-tree or hash indexes with an exclusion constraint, because this does nothing that an ordinary unique constraint doesn't do better. So in practice the access method will always be or . The allows you to specify an exclusion constraint on a subset of the table; internally this creates a partial index. Note that parentheses are required around the predicate.\n\nThese clauses specify a foreign key constraint, which requires that a group of one or more columns of the new table must only contain values that match values in the referenced column(s) of some row of the referenced table. If the list is omitted, the primary key of the is used. Otherwise, the list must refer to the columns of a non-deferrable unique or primary key constraint or be the columns of a non-partial unique index. The user must have permission on the referenced table (either the whole table, or the specific referenced columns). The addition of a foreign key constraint requires a lock on the referenced table. Note that foreign key constraints cannot be defined between temporary tables and permanent tables. A value inserted into the referencing column(s) is matched against the values of the referenced table and referenced columns using the given match type. There are three match types: , , and (which is the default). will not allow one column of a multicolumn foreign key to be null unless all foreign key columns are null; if they are all null, the row is not required to have a match in the referenced table. allows any of the foreign key columns to be null; if any of them are null, the row is not required to have a match in the referenced table. is not yet implemented. (Of course, constraints can be applied to the referencing column(s) to prevent these cases from arising.) In addition, when the data in the referenced columns is changed, certain actions are performed on the data in this table's columns. The clause specifies the action to perform when a referenced row in the referenced table is being deleted. Likewise, the clause specifies the action to perform when a referenced column in the referenced table is being updated to a new value. If the row is updated, but the referenced column is not actually changed, no action is done. Referential actions other than the check cannot be deferred, even if the constraint is declared deferrable. There are the following possible actions for each clause: Produce an error indicating that the deletion or update would create a foreign key constraint violation. If the constraint is deferred, this error will be produced at constraint check time if there still exist any referencing rows. This is the default action. Produce an error indicating that the deletion or update would create a foreign key constraint violation. This is the same as except that the check is not deferrable. Delete any rows referencing the deleted row, or update the values of the referencing column(s) to the new values of the referenced columns, respectively. Set all of the referencing columns, or a specified subset of the referencing columns, to null. A subset of columns can only be specified for actions. Set all of the referencing columns, or a specified subset of the referencing columns, to their default values. A subset of columns can only be specified for actions. (There must be a row in the referenced table matching the default values, if they are not null, or the operation will fail.) If the referenced column(s) are changed frequently, it might be wise to add an index to the referencing column(s) so that referential actions associated with the foreign key constraint can be performed more efficiently."
    },
    {
        "link": "https://postgresql.org/docs/8.1/sql-createtable.html",
        "document": "This documentation is for an unsupported version of PostgreSQL.You may want to view the same page for the current version, or one of the other supported versions listed above instead.\n\nwill create a new, initially empty table in the current database. The table will be owned by the user issuing the command. If a schema name is given (for example, ) then the table is created in the specified schema. Otherwise it is created in the current schema. Temporary tables exist in a special schema, so a schema name may not be given when creating a temporary table. The name of the table must be distinct from the name of any other table, sequence, index, or view in the same schema. also automatically creates a data type that represents the composite type corresponding to one row of the table. Therefore, tables cannot have the same name as any existing data type in the same schema. The optional constraint clauses specify constraints (tests) that new or updated rows must satisfy for an insert or update operation to succeed. A constraint is an SQL object that helps define the set of valid values in the table in various ways. There are two ways to define constraints: table constraints and column constraints. A column constraint is defined as part of a column definition. A table constraint definition is not tied to a particular column, and it can encompass more than one column. Every column constraint can also be written as a table constraint; a column constraint is only a notational convenience for use when the constraint only affects one column.\n\nIf specified, the table is created as a temporary table. Temporary tables are automatically dropped at the end of a session, or optionally at the end of the current transaction (see below). Existing permanent tables with the same name are not visible to the current session while the temporary table exists, unless they are referenced with schema-qualified names. Any indexes created on a temporary table are automatically temporary as well. Optionally, or can be written before or . This makes no difference in PostgreSQL, but see Compatibility. The name (optionally schema-qualified) of the table to be created. The name of a column to be created in the new table. The data type of the column. This may include array specifiers. For more information on the data types supported by PostgreSQL, refer to Chapter 8. The clause assigns a default data value for the column whose column definition it appears within. The value is any variable-free expression (subqueries and cross-references to other columns in the current table are not allowed). The data type of the default expression must match the data type of the column. The default expression will be used in any insert operation that does not specify a value for the column. If there is no default for a column, then the default is null. The optional clause specifies a list of tables from which the new table automatically inherits all columns. Use of creates a persistent relationship between the new child table and its parent table(s). Schema modifications to the parent(s) normally propagate to children as well, and by default the data of the child table is included in scans of the parent(s). If the same column name exists in more than one parent table, an error is reported unless the data types of the columns match in each of the parent tables. If there is no conflict, then the duplicate columns are merged to form a single column in the new table. If the column name list of the new table contains a column name that is also inherited, the data type must likewise match the inherited column(s), and the column definitions are merged into one. However, inherited and new column declarations of the same name need not specify identical constraints: all constraints provided from any declaration are merged together and all are applied to the new table. If the new table explicitly specifies a default value for the column, this default overrides any defaults from inherited declarations of the column. Otherwise, any parents that specify default values for the column must all specify the same default, or an error will be reported. The clause specifies a table from which the new table automatically copies all column names, their data types, and their not-null constraints. Unlike , the new table and original table are completely decoupled after creation is complete. Changes to the original table will not be applied to the new table, and it is not possible to include data of the new table in scans of the original table. Default expressions for the copied column definitions will only be copied if is specified. The default behavior is to exclude default expressions, resulting in all columns of the new table having null defaults. This optional clause specifies whether rows of the new table should have OIDs (object identifiers) assigned to them. If neither nor is specified, the default value depends upon the default_with_oids configuration parameter. (If the new table inherits from any tables that have OIDs, then is forced even if the command says .) If is specified or implied, the new table does not store OIDs and no OID will be assigned for a row inserted into it. This is generally considered worthwhile, since it will reduce OID consumption and thereby postpone the wraparound of the 32-bit OID counter. Once the counter wraps around, OIDs can no longer be assumed to be unique, which makes them considerably less useful. In addition, excluding OIDs from a table reduces the space required to store the table on disk by 4 bytes per row (on most machines), slightly improving performance. To remove OIDs from a table after it has been created, use ALTER TABLE. An optional name for a column or table constraint. If not specified, the system generates a name. The column is not allowed to contain null values. The column is allowed to contain null values. This is the default. This clause is only provided for compatibility with non-standard SQL databases. Its use is discouraged in new applications. The constraint specifies that a group of one or more columns of a table may contain only unique values. The behavior of the unique table constraint is the same as that for column constraints, with the additional capability to span multiple columns. For the purpose of a unique constraint, null values are not considered equal. Each unique table constraint must name a set of columns that is different from the set of columns named by any other unique or primary key constraint defined for the table. (Otherwise it would just be the same constraint listed twice.) The primary key constraint specifies that a column or columns of a table may contain only unique (non-duplicate), nonnull values. Technically, is merely a combination of and , but identifying a set of columns as primary key also provides metadata about the design of the schema, as a primary key implies that other tables may rely on this set of columns as a unique identifier for rows. Only one primary key can be specified for a table, whether as a column constraint or a table constraint. The primary key constraint should name a set of columns that is different from other sets of columns named by any unique constraint defined for the same table. The clause specifies an expression producing a Boolean result which new or updated rows must satisfy for an insert or update operation to succeed. Expressions evaluating to TRUE or UNKNOWN succeed. Should any row of an insert or update operation produce a FALSE result an error exception is raised and the insert or update does not alter the database. A check constraint specified as a column constraint should reference that column's value only, while an expression appearing in a table constraint may reference multiple columns. Currently, expressions cannot contain subqueries nor refer to variables other than columns of the current row. These clauses specify a foreign key constraint, which requires that a group of one or more columns of the new table must only contain values that match values in the referenced column(s) of some row of the referenced table. If is omitted, the primary key of the is used. The referenced columns must be the columns of a unique or primary key constraint in the referenced table. Note that foreign key constraints may not be defined between temporary tables and permanent tables. A value inserted into the referencing column(s) is matched against the values of the referenced table and referenced columns using the given match type. There are three match types: , , and , which is also the default. will not allow one column of a multicolumn foreign key to be null unless all foreign key columns are null. allows some foreign key columns to be null while other parts of the foreign key are not null. is not yet implemented. In addition, when the data in the referenced columns is changed, certain actions are performed on the data in this table's columns. The clause specifies the action to perform when a referenced row in the referenced table is being deleted. Likewise, the clause specifies the action to perform when a referenced column in the referenced table is being updated to a new value. If the row is updated, but the referenced column is not actually changed, no action is done. Referential actions other than the check cannot be deferred, even if the constraint is declared deferrable. There are the following possible actions for each clause: Produce an error indicating that the deletion or update would create a foreign key constraint violation. If the constraint is deferred, this error will be produced at constraint check time if there still exist any referencing rows. This is the default action. Produce an error indicating that the deletion or update would create a foreign key constraint violation. This is the same as except that the check is not deferrable. Delete any rows referencing the deleted row, or update the value of the referencing column to the new value of the referenced column, respectively. Set the referencing column(s) to their default values. If the referenced column(s) are changed frequently, it may be wise to add an index to the foreign key column so that referential actions associated with the foreign key column can be performed more efficiently. This controls whether the constraint can be deferred. A constraint that is not deferrable will be checked immediately after every command. Checking of constraints that are deferrable may be postponed until the end of the transaction (using the SET CONSTRAINTS command). is the default. Only foreign key constraints currently accept this clause. All other constraint types are not deferrable. If a constraint is deferrable, this clause specifies the default time to check the constraint. If the constraint is , it is checked after each statement. This is the default. If the constraint is , it is checked only at the end of the transaction. The constraint check time can be altered with the SET CONSTRAINTS command. The behavior of temporary tables at the end of a transaction block can be controlled using . The three options are: No special action is taken at the ends of transactions. This is the default behavior. All rows in the temporary table will be deleted at the end of each transaction block. Essentially, an automatic TRUNCATE is done at each commit. The temporary table will be dropped at the end of the current transaction block. The is the name of the tablespace in which the new table is to be created. If not specified, default_tablespace is used, or the database's default tablespace if is an empty string. This clause allows selection of the tablespace in which the index associated with a or constraint will be created. If not specified, default_tablespace is used, or the database's default tablespace if is an empty string.\n\nUsing OIDs in new applications is not recommended: where possible, using a or other sequence generator as the table's primary key is preferred. However, if your application does make use of OIDs to identify specific rows of a table, it is recommended to create a unique constraint on the column of that table, to ensure that OIDs in the table will indeed uniquely identify rows even after counter wraparound. Avoid assuming that OIDs are unique across tables; if you need a database-wide unique identifier, use the combination of and row OID for the purpose. Tip: The use of is not recommended for tables with no primary key, since without either an OID or a unique data key, it is difficult to identify specific rows. PostgreSQL automatically creates an index for each unique constraint and primary key constraint to enforce uniqueness. Thus, it is not necessary to create an index explicitly for primary key columns. (See CREATE INDEX for more information.) Unique constraints and primary keys are not inherited in the current implementation. This makes the combination of inheritance and unique constraints rather dysfunctional. A table cannot have more than 1600 columns. (In practice, the effective limit is lower because of tuple-length constraints.)\n\nCREATE TABLE films ( code char(5) CONSTRAINT firstkey PRIMARY KEY, title varchar(40) NOT NULL, did integer NOT NULL, date_prod date, kind varchar(10), len interval hour to minute ); CREATE TABLE distributors ( did integer PRIMARY KEY DEFAULT nextval('serial'), name varchar(40) NOT NULL CHECK (name <> '') ); Define a unique table constraint for the table . Unique table constraints can be defined on one or more columns of the table. CREATE TABLE distributors ( did integer CHECK (did > 100), name varchar(40) ); CREATE TABLE distributors ( did integer, name varchar(40) CONSTRAINT con1 CHECK (did > 100 AND name <> '') ); Define a primary key table constraint for the table . Primary key table constraints can be defined on one or more columns of the table. Define a primary key constraint for table . The following two examples are equivalent, the first using the table constraint syntax, the second the column constraint syntax. This assigns a literal constant default value for the column , arranges for the default value of column to be generated by selecting the next value of a sequence object, and makes the default value of be the time at which the row is inserted. Define two column constraints on the table , one of which is explicitly given a name: CREATE TABLE distributors ( did integer CONSTRAINT no_null NOT NULL, name varchar(40) NOT NULL ); The above is equivalent to the following specified as a table constraint:\n\nThe command conforms to the standard, with exceptions listed below. Although the syntax of resembles that of the SQL standard, the effect is not the same. In the standard, temporary tables are defined just once and automatically exist (starting with empty contents) in every session that needs them. PostgreSQL instead requires each session to issue its own command for each temporary table to be used. This allows different sessions to use the same temporary table name for different purposes, whereas the standard's approach constrains all instances of a given temporary table name to have the same table structure. The standard's definition of the behavior of temporary tables is widely ignored. PostgreSQL's behavior on this point is similar to that of several other SQL databases. The standard's distinction between global and local temporary tables is not in PostgreSQL, since that distinction depends on the concept of modules, which PostgreSQL does not have. For compatibility's sake, PostgreSQL will accept the and keywords in a temporary table declaration, but they have no effect. The clause for temporary tables also resembles the SQL standard, but has some differences. If the clause is omitted, SQL specifies that the default behavior is . However, the default behavior in PostgreSQL is . The option does not exist in SQL. The SQL standard says that column constraints may only refer to the column they apply to; only table constraints may refer to multiple columns. PostgreSQL does not enforce this restriction; it treats column and table check constraints alike. The \"constraint\" (actually a non-constraint) is a PostgreSQL extension to the SQL standard that is included for compatibility with some other database systems (and for symmetry with the constraint). Since it is the default for any column, its presence is simply noise. Multiple inheritance via the clause is a PostgreSQL language extension. SQL:1999 and later define single inheritance using a different syntax and different semantics. SQL:1999-style inheritance is not yet supported by PostgreSQL. The PostgreSQL concept of OIDs is not standard. PostgreSQL allows a table of no columns to be created (for example, ). This is an extension from the SQL standard, which does not allow zero-column tables. Zero-column tables are not in themselves very useful, but disallowing them creates odd special cases for , so it seems cleaner to ignore this spec restriction. The PostgreSQL concept of tablespaces is not part of the standard. Hence, the clauses and are extensions."
    },
    {
        "link": "https://postgresql.org/docs/current/ddl-constraints.html",
        "document": "Data types are a way to limit the kind of data that can be stored in a table. For many applications, however, the constraint they provide is too coarse. For example, a column containing a product price should probably only accept positive values. But there is no standard data type that accepts only positive numbers. Another issue is that you might want to constrain column data with respect to other columns or rows. For example, in a table containing product information, there should be only one row for each product number.\n\nTo that end, SQL allows you to define constraints on columns and tables. Constraints give you as much control over the data in your tables as you wish. If a user attempts to store data in a column that would violate a constraint, an error is raised. This applies even if the value came from the default value definition.\n\nA check constraint is the most generic constraint type. It allows you to specify that the value in a certain column must satisfy a Boolean (truth-value) expression. For instance, to require positive product prices, you could use: As you see, the constraint definition comes after the data type, just like default value definitions. Default values and constraints can be listed in any order. A check constraint consists of the key word followed by an expression in parentheses. The check constraint expression should involve the column thus constrained, otherwise the constraint would not make too much sense. You can also give the constraint a separate name. This clarifies error messages and allows you to refer to the constraint when you need to change it. The syntax is: So, to specify a named constraint, use the key word followed by an identifier followed by the constraint definition. (If you don't specify a constraint name in this way, the system chooses a name for you.) A check constraint can also refer to several columns. Say you store a regular price and a discounted price, and you want to ensure that the discounted price is lower than the regular price: The first two constraints should look familiar. The third one uses a new syntax. It is not attached to a particular column, instead it appears as a separate item in the comma-separated column list. Column definitions and these constraint definitions can be listed in mixed order. We say that the first two constraints are column constraints, whereas the third one is a table constraint because it is written separately from any one column definition. Column constraints can also be written as table constraints, while the reverse is not necessarily possible, since a column constraint is supposed to refer to only the column it is attached to. (PostgreSQL doesn't enforce that rule, but you should follow it if you want your table definitions to work with other database systems.) The above example could also be written as: Names can be assigned to table constraints in the same way as column constraints: It should be noted that a check constraint is satisfied if the check expression evaluates to true or the null value. Since most expressions will evaluate to the null value if any operand is null, they will not prevent null values in the constrained columns. To ensure that a column does not contain null values, the not-null constraint described in the next section can be used. PostgreSQL does not support constraints that reference table data other than the new or updated row being checked. While a constraint that violates this rule may appear to work in simple tests, it cannot guarantee that the database will not reach a state in which the constraint condition is false (due to subsequent changes of the other row(s) involved). This would cause a database dump and restore to fail. The restore could fail even when the complete database state is consistent with the constraint, due to rows not being loaded in an order that will satisfy the constraint. If possible, use , , or constraints to express cross-row and cross-table restrictions. If what you desire is a one-time check against other rows at row insertion, rather than a continuously-maintained consistency guarantee, a custom trigger can be used to implement that. (This approach avoids the dump/restore problem because pg_dump does not reinstall triggers until after restoring data, so that the check will not be enforced during a dump/restore.) PostgreSQL assumes that constraints' conditions are immutable, that is, they will always give the same result for the same input row. This assumption is what justifies examining constraints only when rows are inserted or updated, and not at other times. (The warning above about not referencing other table data is really a special case of this restriction.) An example of a common way to break this assumption is to reference a user-defined function in a expression, and then change the behavior of that function. PostgreSQL does not disallow that, but it will not notice if there are rows in the table that now violate the constraint. That would cause a subsequent database dump and restore to fail. The recommended way to handle such a change is to drop the constraint (using ), adjust the function definition, and re-add the constraint, thereby rechecking it against all table rows.\n\nA not-null constraint simply specifies that a column must not assume the null value. A syntax example: A not-null constraint is always written as a column constraint. A not-null constraint is functionally equivalent to creating a check constraint , but in PostgreSQL creating an explicit not-null constraint is more efficient. The drawback is that you cannot give explicit names to not-null constraints created this way. Of course, a column can have more than one constraint. Just write the constraints one after another: CREATE TABLE products ( product_no integer NOT NULL, name text NOT NULL, price numeric NOT NULL CHECK (price > 0) ); The order doesn't matter. It does not necessarily determine in which order the constraints are checked. The constraint has an inverse: the constraint. This does not mean that the column must be null, which would surely be useless. Instead, this simply selects the default behavior that the column might be null. The constraint is not present in the SQL standard and should not be used in portable applications. (It was only added to PostgreSQL to be compatible with some other database systems.) Some users, however, like it because it makes it easy to toggle the constraint in a script file. For example, you could start with: and then insert the key word where desired. In most database designs the majority of columns should be marked not null.\n\nUnique constraints ensure that the data contained in a column, or a group of columns, is unique among all the rows in the table. The syntax is: when written as a column constraint, and: To define a unique constraint for a group of columns, write it as a table constraint with the column names separated by commas: This specifies that the combination of values in the indicated columns is unique across the whole table, though any one of the columns need not be (and ordinarily isn't) unique. You can assign your own name for a unique constraint, in the usual way: Adding a unique constraint will automatically create a unique B-tree index on the column or group of columns listed in the constraint. A uniqueness restriction covering only some rows cannot be written as a unique constraint, but it is possible to enforce such a restriction by creating a unique partial index. In general, a unique constraint is violated if there is more than one row in the table where the values of all of the columns included in the constraint are equal. By default, two null values are not considered equal in this comparison. That means even in the presence of a unique constraint it is possible to store duplicate rows that contain a null value in at least one of the constrained columns. This behavior can be changed by adding the clause , like The default behavior can be specified explicitly using . The default null treatment in unique constraints is implementation-defined according to the SQL standard, and other implementations have a different behavior. So be careful when developing applications that are intended to be portable.\n\nA primary key constraint indicates that a column, or group of columns, can be used as a unique identifier for rows in the table. This requires that the values be both unique and not null. So, the following two table definitions accept the same data: Primary keys can span more than one column; the syntax is similar to unique constraints: Adding a primary key will automatically create a unique B-tree index on the column or group of columns listed in the primary key, and will force the column(s) to be marked . A table can have at most one primary key. (There can be any number of unique and not-null constraints, which are functionally almost the same thing, but only one can be identified as the primary key.) Relational database theory dictates that every table must have a primary key. This rule is not enforced by PostgreSQL, but it is usually best to follow it. Primary keys are useful both for documentation purposes and for client applications. For example, a GUI application that allows modifying row values probably needs to know the primary key of a table to be able to identify rows uniquely. There are also various ways in which the database system makes use of a primary key if one has been declared; for example, the primary key defines the default target column(s) for foreign keys referencing its table.\n\nA foreign key constraint specifies that the values in a column (or a group of columns) must match the values appearing in some row of another table. We say this maintains the referential integrity between two related tables. Say you have the product table that we have used several times already: Let's also assume you have a table storing orders of those products. We want to ensure that the orders table only contains orders of products that actually exist. So we define a foreign key constraint in the orders table that references the products table: Now it is impossible to create orders with non-NULL entries that do not appear in the products table. We say that in this situation the orders table is the referencing table and the products table is the referenced table. Similarly, there are referencing and referenced columns. You can also shorten the above command to: because in absence of a column list the primary key of the referenced table is used as the referenced column(s). You can assign your own name for a foreign key constraint, in the usual way. A foreign key can also constrain and reference a group of columns. As usual, it then needs to be written in table constraint form. Here is a contrived syntax example: Of course, the number and type of the constrained columns need to match the number and type of the referenced columns. Sometimes it is useful for the “other table” of a foreign key constraint to be the same table; this is called a self-referential foreign key. For example, if you want rows of a table to represent nodes of a tree structure, you could write A top-level node would have NULL , while non-NULL entries would be constrained to reference valid rows of the table. A table can have more than one foreign key constraint. This is used to implement many-to-many relationships between tables. Say you have tables about products and orders, but now you want to allow one order to contain possibly many products (which the structure above did not allow). You could use this table structure: Notice that the primary key overlaps with the foreign keys in the last table. We know that the foreign keys disallow creation of orders that do not relate to any products. But what if a product is removed after an order is created that references it? SQL allows you to handle that as well. Intuitively, we have a few options:\n• Delete the orders as well To illustrate this, let's implement the following policy on the many-to-many relationship example above: when someone wants to remove a product that is still referenced by an order (via ), we disallow it. If someone removes an order, the order items are removed as well: Restricting and cascading deletes are the two most common options. prevents deletion of a referenced row. means that if any referencing rows still exist when the constraint is checked, an error is raised; this is the default behavior if you do not specify anything. (The essential difference between these two choices is that allows the check to be deferred until later in the transaction, whereas does not.) specifies that when a referenced row is deleted, row(s) referencing it should be automatically deleted as well. There are two other options: and . These cause the referencing column(s) in the referencing row(s) to be set to nulls or their default values, respectively, when the referenced row is deleted. Note that these do not excuse you from observing any constraints. For example, if an action specifies but the default value would not satisfy the foreign key constraint, the operation will fail. The appropriate choice of action depends on what kinds of objects the related tables represent. When the referencing table represents something that is a component of what is represented by the referenced table and cannot exist independently, then could be appropriate. If the two tables represent independent objects, then or is more appropriate; an application that actually wants to delete both objects would then have to be explicit about this and run two delete commands. In the above example, order items are part of an order, and it is convenient if they are deleted automatically if an order is deleted. But products and orders are different things, and so making a deletion of a product automatically cause the deletion of some order items could be considered problematic. The actions or can be appropriate if a foreign-key relationship represents optional information. For example, if the products table contained a reference to a product manager, and the product manager entry gets deleted, then setting the product's product manager to null or a default might be useful. The actions and can take a column list to specify which columns to set. Normally, all columns of the foreign-key constraint are set; setting only a subset is useful in some special cases. Consider the following example: CREATE TABLE tenants ( tenant_id integer PRIMARY KEY ); CREATE TABLE users ( tenant_id integer REFERENCES tenants ON DELETE CASCADE, user_id integer NOT NULL, PRIMARY KEY (tenant_id, user_id) ); CREATE TABLE posts ( tenant_id integer REFERENCES tenants ON DELETE CASCADE, post_id integer NOT NULL, author_id integer, PRIMARY KEY (tenant_id, post_id), FOREIGN KEY (tenant_id, author_id) REFERENCES users ON DELETE SET NULL ); Without the specification of the column, the foreign key would also set the column to null, but that column is still required as part of the primary key. Analogous to there is also which is invoked when a referenced column is changed (updated). The possible actions are the same, except that column lists cannot be specified for and . In this case, means that the updated values of the referenced column(s) should be copied into the referencing row(s). Normally, a referencing row need not satisfy the foreign key constraint if any of its referencing columns are null. If is added to the foreign key declaration, a referencing row escapes satisfying the constraint only if all its referencing columns are null (so a mix of null and non-null values is guaranteed to fail a constraint). If you don't want referencing rows to be able to avoid satisfying the foreign key constraint, declare the referencing column(s) as . A foreign key must reference columns that either are a primary key or form a unique constraint, or are columns from a non-partial unique index. This means that the referenced columns always have an index to allow efficient lookups on whether a referencing row has a match. Since a of a row from the referenced table or an of a referenced column will require a scan of the referencing table for rows matching the old value, it is often a good idea to index the referencing columns too. Because this is not always needed, and there are many choices available on how to index, the declaration of a foreign key constraint does not automatically create an index on the referencing columns. More information about updating and deleting data is in Chapter 6. Also see the description of foreign key constraint syntax in the reference documentation for CREATE TABLE."
    },
    {
        "link": "https://postgresql.org/docs/8.0/sql-createtable.html",
        "document": "This documentation is for an unsupported version of PostgreSQL.You may want to view the same page for the current version, or one of the other supported versions listed above instead.\n\nwill create a new, initially empty table in the current database. The table will be owned by the user issuing the command. If a schema name is given (for example, ) then the table is created in the specified schema. Otherwise it is created in the current schema. Temporary tables exist in a special schema, so a schema name may not be given when creating a temporary table. The table name must be distinct from the name of any other table, sequence, index, or view in the same schema. also automatically creates a data type that represents the composite type corresponding to one row of the table. Therefore, tables cannot have the same name as any existing data type in the same schema. The optional constraint clauses specify constraints (tests) that new or updated rows must satisfy for an insert or update operation to succeed. A constraint is an SQL object that helps define the set of valid values in the table in various ways. There are two ways to define constraints: table constraints and column constraints. A column constraint is defined as part of a column definition. A table constraint definition is not tied to a particular column, and it can encompass more than one column. Every column constraint can also be written as a table constraint; a column constraint is only a notational convenience for use when the constraint only affects one column.\n\nIf specified, the table is created as a temporary table. Temporary tables are automatically dropped at the end of a session, or optionally at the end of the current transaction (see below). Existing permanent tables with the same name are not visible to the current session while the temporary table exists, unless they are referenced with schema-qualified names. Any indexes created on a temporary table are automatically temporary as well. Optionally, or can be written before or . This makes no difference in PostgreSQL, but see Compatibility. The name (optionally schema-qualified) of the table to be created. The name of a column to be created in the new table. The data type of the column. This may include array specifiers. For more information on the data types supported by PostgreSQL, refer to Chapter 8. The clause assigns a default data value for the column whose column definition it appears within. The value is any variable-free expression (subqueries and cross-references to other columns in the current table are not allowed). The data type of the default expression must match the data type of the column. The default expression will be used in any insert operation that does not specify a value for the column. If there is no default for a column, then the default is null. The optional clause specifies a list of tables from which the new table automatically inherits all columns. Use of creates a persistent relationship between the new child table and its parent table(s). Schema modifications to the parent(s) normally propagate to children as well, and by default the data of the child table is included in scans of the parent(s). If the same column name exists in more than one parent table, an error is reported unless the data types of the columns match in each of the parent tables. If there is no conflict, then the duplicate columns are merged to form a single column in the new table. If the column name list of the new table contains a column name that is also inherited, the data type must likewise match the inherited column(s), and the column definitions are merged into one. However, inherited and new column declarations of the same name need not specify identical constraints: all constraints provided from any declaration are merged together and all are applied to the new table. If the new table explicitly specifies a default value for the column, this default overrides any defaults from inherited declarations of the column. Otherwise, any parents that specify default values for the column must all specify the same default, or an error will be reported. The clause specifies a table from which the new table automatically copies all column names, their data types, and their not-null constraints. Unlike , the new table and original table are completely decoupled after creation is complete. Changes to the original table will not be applied to the new table, and it is not possible to include data of the new table in scans of the original table. Default expressions for the copied column definitions will only be copied if is specified. The default behavior is to exclude default expressions, resulting in all columns of the new table having null defaults. This optional clause specifies whether rows of the new table should have OIDs (object identifiers) assigned to them. If neither nor is specified, the default value depends upon the default_with_oids configuration parameter. (If the new table inherits from any tables that have OIDs, then is forced even if the command says .) If is specified or implied, the new table does not store OIDs and no OID will be assigned for a row inserted into it. This is generally considered worthwhile, since it will reduce OID consumption and thereby postpone the wraparound of the 32-bit OID counter. Once the counter wraps around, OIDs can no longer be assumed to be unique, which makes them considerably less useful. In addition, excluding OIDs from a table reduces the space required to store the table on disk by 4 bytes per row (on most machines), slightly improving performance. To remove OIDs from a table after it has been created, use ALTER TABLE. An optional name for a column or table constraint. If not specified, the system generates a name. The column is not allowed to contain null values. The column is allowed to contain null values. This is the default. This clause is only provided for compatibility with non-standard SQL databases. Its use is discouraged in new applications. The constraint specifies that a group of one or more columns of a table may contain only unique values. The behavior of the unique table constraint is the same as that for column constraints, with the additional capability to span multiple columns. For the purpose of a unique constraint, null values are not considered equal. Each unique table constraint must name a set of columns that is different from the set of columns named by any other unique or primary key constraint defined for the table. (Otherwise it would just be the same constraint listed twice.) The primary key constraint specifies that a column or columns of a table may contain only unique (non-duplicate), nonnull values. Technically, is merely a combination of and , but identifying a set of columns as primary key also provides metadata about the design of the schema, as a primary key implies that other tables may rely on this set of columns as a unique identifier for rows. Only one primary key can be specified for a table, whether as a column constraint or a table constraint. The primary key constraint should name a set of columns that is different from other sets of columns named by any unique constraint defined for the same table. The clause specifies an expression producing a Boolean result which new or updated rows must satisfy for an insert or update operation to succeed. Expressions evaluating to TRUE or UNKNOWN succeed. Should any row of an insert or update operation produce a FALSE result an error exception is raised and the insert or update does not alter the database. A check constraint specified as a column constraint should reference that column's value only, while an expression appearing in a table constraint may reference multiple columns. Currently, expressions cannot contain subqueries nor refer to variables other than columns of the current row. These clauses specify a foreign key constraint, which requires that a group of one or more columns of the new table must only contain values that match values in the referenced column(s) of some row of the referenced table. If is omitted, the primary key of the is used. The referenced columns must be the columns of a unique or primary key constraint in the referenced table. A value inserted into the referencing column(s) is matched against the values of the referenced table and referenced columns using the given match type. There are three match types: , , and , which is also the default. will not allow one column of a multicolumn foreign key to be null unless all foreign key columns are null. allows some foreign key columns to be null while other parts of the foreign key are not null. is not yet implemented. In addition, when the data in the referenced columns is changed, certain actions are performed on the data in this table's columns. The clause specifies the action to perform when a referenced row in the referenced table is being deleted. Likewise, the clause specifies the action to perform when a referenced column in the referenced table is being updated to a new value. If the row is updated, but the referenced column is not actually changed, no action is done. Referential actions other than the check cannot be deferred, even if the constraint is declared deferrable. There are the following possible actions for each clause: Produce an error indicating that the deletion or update would create a foreign key constraint violation. If the constraint is deferred, this error will be produced at constraint check time if there still exist any referencing rows. This is the default action. Produce an error indicating that the deletion or update would create a foreign key constraint violation. This is the same as except that the check is not deferrable. Delete any rows referencing the deleted row, or update the value of the referencing column to the new value of the referenced column, respectively. Set the referencing column(s) to their default values. If the referenced column(s) are changed frequently, it may be wise to add an index to the foreign key column so that referential actions associated with the foreign key column can be performed more efficiently. This controls whether the constraint can be deferred. A constraint that is not deferrable will be checked immediately after every command. Checking of constraints that are deferrable may be postponed until the end of the transaction (using the SET CONSTRAINTS command). is the default. Only foreign key constraints currently accept this clause. All other constraint types are not deferrable. If a constraint is deferrable, this clause specifies the default time to check the constraint. If the constraint is , it is checked after each statement. This is the default. If the constraint is , it is checked only at the end of the transaction. The constraint check time can be altered with the SET CONSTRAINTS command. The behavior of temporary tables at the end of a transaction block can be controlled using . The three options are: No special action is taken at the ends of transactions. This is the default behavior. All rows in the temporary table will be deleted at the end of each transaction block. Essentially, an automatic TRUNCATE is done at each commit. The temporary table will be dropped at the end of the current transaction block. The is the name of the tablespace in which the new table is to be created. If not specified, default_tablespace is used, or the database's default tablespace if is an empty string. This clause allows selection of the tablespace in which the index associated with a or constraint will be created. If not specified, default_tablespace is used, or the database's default tablespace if is an empty string.\n\nUsing OIDs in new applications is not recommended: where possible, using a or other sequence generator as the table's primary key is preferred. However, if your application does make use of OIDs to identify specific rows of a table, it is recommended to create a unique constraint on the column of that table, to ensure that OIDs in the table will indeed uniquely identify rows even after counter wraparound. Avoid assuming that OIDs are unique across tables; if you need a database-wide unique identifier, use the combination of and row OID for the purpose. Tip: The use of is not recommended for tables with no primary key, since without either an OID or a unique data key, it is difficult to identify specific rows. PostgreSQL automatically creates an index for each unique constraint and primary key constraint to enforce uniqueness. Thus, it is not necessary to create an index explicitly for primary key columns. (See CREATE INDEX for more information.) Unique constraints and primary keys are not inherited in the current implementation. This makes the combination of inheritance and unique constraints rather dysfunctional. A table cannot have more than 1600 columns. (In practice, the effective limit is lower because of tuple-length constraints.)\n\nCREATE TABLE films ( code char(5) CONSTRAINT firstkey PRIMARY KEY, title varchar(40) NOT NULL, did integer NOT NULL, date_prod date, kind varchar(10), len interval hour to minute ); CREATE TABLE distributors ( did integer PRIMARY KEY DEFAULT nextval('serial'), name varchar(40) NOT NULL CHECK (name <> '') ); Define a unique table constraint for the table . Unique table constraints can be defined on one or more columns of the table. CREATE TABLE distributors ( did integer CHECK (did > 100), name varchar(40) ); CREATE TABLE distributors ( did integer, name varchar(40) CONSTRAINT con1 CHECK (did > 100 AND name <> '') ); Define a primary key table constraint for the table . Primary key table constraints can be defined on one or more columns of the table. Define a primary key constraint for table . The following two examples are equivalent, the first using the table constraint syntax, the second the column constraint syntax. This assigns a literal constant default value for the column , arranges for the default value of column to be generated by selecting the next value of a sequence object, and makes the default value of be the time at which the row is inserted. Define two column constraints on the table , one of which is explicitly given a name: CREATE TABLE distributors ( did integer CONSTRAINT no_null NOT NULL, name varchar(40) NOT NULL ); The above is equivalent to the following specified as a table constraint:\n\nThe command conforms to SQL-92 and to a subset of SQL:1999, with exceptions listed below. Although the syntax of resembles that of the SQL standard, the effect is not the same. In the standard, temporary tables are defined just once and automatically exist (starting with empty contents) in every session that needs them. PostgreSQL instead requires each session to issue its own command for each temporary table to be used. This allows different sessions to use the same temporary table name for different purposes, whereas the standard's approach constrains all instances of a given temporary table name to have the same table structure. The standard's definition of the behavior of temporary tables is widely ignored. PostgreSQL's behavior on this point is similar to that of several other SQL databases. The standard's distinction between global and local temporary tables is not in PostgreSQL, since that distinction depends on the concept of modules, which PostgreSQL does not have. For compatibility's sake, PostgreSQL will accept the and keywords in a temporary table declaration, but they have no effect. The clause for temporary tables also resembles the SQL standard, but has some differences. If the clause is omitted, SQL specifies that the default behavior is . However, the default behavior in PostgreSQL is . The option does not exist in SQL. The SQL standard says that column constraints may only refer to the column they apply to; only table constraints may refer to multiple columns. PostgreSQL does not enforce this restriction; it treats column and table check constraints alike. The \"constraint\" (actually a non-constraint) is a PostgreSQL extension to the SQL standard that is included for compatibility with some other database systems (and for symmetry with the constraint). Since it is the default for any column, its presence is simply noise. Multiple inheritance via the clause is a PostgreSQL language extension. SQL:1999 (but not SQL-92) defines single inheritance using a different syntax and different semantics. SQL:1999-style inheritance is not yet supported by PostgreSQL. The PostgreSQL concept of OIDs is not standard. PostgreSQL allows a table of no columns to be created (for example, ). This is an extension from the SQL standard, which does not allow zero-column tables. Zero-column tables are not in themselves very useful, but disallowing them creates odd special cases for , so it seems cleaner to ignore this spec restriction. The PostgreSQL concept of tablespaces is not part of the standard. Hence, the clauses and are extensions."
    },
    {
        "link": "https://beekeeperstudio.io/blog/postgres-create-tables",
        "document": "In order to organize data in Postgres, you must first know how to create tables to store your data. This article covers ten different scenarios of creating tables. This includes but certainly is not limited to creating tables with primary keys, constraints, and indexes.\n\nLet’s create a simple table to store data about students in a university. You will create a table with the query followed by the table name and the list of columns.\n\nThe statement lets you create a table in the database. Our table name is students. The students table has five columns to store the students’ ID, name, GPA, enrollment date, and status of completion of the degree. A column must be declared with its data type, and each columns should be separated by a comma.\n\nA data type tells the database what sort of data you are allowed to enter for a particular column. For example, allows only whole number values. allows adding string values with varying character lengths. As you can see, we have given a maximum length of 100 characters to student_name. Furthermore, allows you to add decimal values. The total number of digits and digits after the decimal point is given in brackets. allows adding date values without the time. allows adding true (yes) or false (no) values. Although there are many other data types in Postgres, these are some of the most commonly used types.\n\nIf you use Beekeeper Studio, you can easily create a table in two clicks.\n\nA primary key is a column that uniquely identifies each row using a unique value. In our example, each student has a distinctive student ID value that cannot be repeated. The other columns we do not restrict, and may have repeated values.\n\nTo declare the student_id column as the primary key, simply use the keywords PRIMARY KEY after its data type.\n\nIf you want the primary key column values to increment automatically, the easiest method is to use the datatype. This creates a series of integer values automatically for the student id column when you add new records.\n\nLet’s put everything together. This is how the code looks now.\n\nLet’s create another table to store data about student user accounts. Suppose that, when a student account is created we need to store the date and exact time of creation. Also, whenever a student logs in the date and time have to be updated. To store these types of values we use the data type. See the example below to understand it better.\n\nNow let’s create a sub-table from our students table to show the students who have a GPA higher than 3.7. This can be done by using the CREATE TABLE AS statement and fetching data using a SELECT query. You may select the columns you need from the students table by checking if the GPA is greater than or equal to 3.7.\n\nHere is what the output table looks like. This is a new permanent table named first_class_students and you can insert or modify data later too. Note that will not update when the original students table updates, it is a snapshot in time from when we ran this query.\n\nThe statement doesn’t work for tables in PostgreSQL, unlike other database systems. can be used with a , but otherwise we are forced to use the statement to modify tables.\n\nViews are virtual tables that do not contain any data, but are simply a ‘view’ to other tables in your database. Let’s create a view to find the students who have enrolled after the deadline. This can be done by checking whether they enrolled on or after 2022-03-01.\n\nUsing the ALTER TABLE statement you may add or modify column names, data types, or constraints in an existing table.\n\nYou may even rename your table.\n\nAfter creating a table you can import data from a CSV (Comma Separated Values) file using its absolute path.\n\nThe table should be created prior to importing data, otherwise, it causes an error. I have used the new table name in this example since we altered it in the previous example. Delimiter specifies the character used to separate columns in the CSV file. CSV HEADER statement lets the database know that the file contains header values.\n\nIndexes allow queries against specific columns execute faster. Think of indexes like the index of a book – they allow you to find the page you need quickly. This is similar for databases, they let you find the record you need quickly.\n\nAn index created on the primary key column will be automatically created when we define the primary key. That means in our students table an index is created on the student_id column.\n\nYou can of course create indexes on other columns. Use the statement with the table name and the relevant column name to do this. I have used student_name_index as the index name here.\n\nThis index allows us to quickly find a student by name.\n\nConstraints are specific limitations. You already are familiar with the statement. It is a type of constraint. , , and are some other examples of constraints. A constraint can be either declared as a column constraint or a table constraint.\n\nColumn constraints are written after the data type. You may even have multiple constraints. There is no specific order in writing them. Let’s rewrite a few column declarations from the students table using column constraints.\n\nTable constraints must be written after the column names list. The NOT NULL constraint can not be directly used as a table constraint, unlike the other constraint types. So, you may use IS NOT NULL with each column inside a CHECK constraint. Let’s rewrite a few column declarations from the student_accounts table using table constraints.\n\nIf you want a table for temporary use, you can create a temporary table using the (or ) keyword. This table will be automatically dropped when your session ends.\n\nLet’s create a temp table to fetch students who have graduated.\n\nSo far we created tables directly on the database. However, there is another layer between databases and tables. These are called schemas. All the tables, views, functions, sequences we create in PostgreSQL should belongs to a schema.\n\nPostgreSQL comes with a default schema called public. So all the tables we created so far belong to the public schema. So let’s take our first example which was creating a simple student table.\n\nSo you can access the above table with the following query.\n\nHowever, it’s not necessary to mention the schema as it’s the default schema.\n\nIt’s a good practice to break your database into several schemas without putting all the tables, views, and functions into one database. There are four main benefits to schemas.\n• You can apply bulk actions easily - For example, it’s easier to backup and restore data when they are in separate schemas.\n• Users can be restricted to work in certain schemas. - Imagine a school database containing various tables such as teachers, students, non-academic staff, finance, etc. So you can put tables related to student details into one schema and tables related to finance into another schema. Then you restrict access of users based on the schema. This is easier than giving access table by table.\n• Schema works similarly to namespaces - You can have tables with the same name in different schemas. For example, when you create a database for a university, you can have separate schemas for the undergraduate section and postgraduate section. Both schemas can have separate student tables.\n• Easier to update to new versions. - Suppose you are releasing a new version of your application and you have to change the structure of the database. It’s overall easier to cut some schema and add new schemas than dealing with the full database.\n\nNow let’s see how to create a new schema.\n\nHowever, if there is already a table with that schema name, the database will send an error. So it’s better to write the query like this\n\nNow let’s create a table in that schema. We will create a student table again in the school schema.\n\nSo as you can see, all you had to do was to include the schema name before the table name.\n\nSuppose that you want to shift a table you created in a public schema to a newly created schema. So how do you do it? The following code will help\n\nYou have to use the following query to access the data in the students table in the school schema.\n\nOne of the main reasons behind creating schemas is to restrict the access of users. So let’s see how to do that. Suppose there is a user called finance_manager. Let’s give him access to the finance schema.\n\nWhen we create a new database in PostgreSQL, any role is allowed to create tables in the public schema. To prevent that from happening, you have to first remove that privilege from all users except the superuser. You can do it with the following code\n\nThen you can give privileges to create a table to a specific user. (let’s call him designer).\n\nHere is a command in PostgreSQL to provide privileges to users. is a type of which includes the permission. A person who has permission can create tables, views, functions, and any type of object in that schema.\n\nHowever, when it comes to temporary tables, every user can create them.\n\nTo summarize, data types and constraints are used to specify rules to table columns. You can create sub-tables, views, or temporary tables from existing tables. Tables can be modified by using the ALTER statement. Indexes are used for efficient data retrieval."
    },
    {
        "link": "https://crunchydata.com/blog/enums-vs-check-constraints-in-postgres",
        "document": "A question recently came up in the internal Crunchy Data slack channel: Does anyone actually use enums out in the wild?\n\nIf you're unfamiliar with enums, they’re enumerated types, a static set of values in a database like days of the week or a shipping status. Enums are a powerful feature of Postgres that allows you to define a set of predefined values that can be assigned to a column. However, enums can have some limitations and drawbacks that make them less than ideal for certain scenarios.\n\nLet's look at a practical example for enums. Here we create a table with as , , or .\n\nAs we can see here, using enums allows us to have very specific values stored and other features and functions securly built off of those static values. Enums let you have the exact value you want without having to join to a smaller lookup table. And you haven't allowed freeform text in this field that can be prone to typos or errors.\n\nSo if enums are handy, then why in our internal chat was there little to no examples of them being actually used out in the wild. Because this handy little feature check constraints allows you the same functionality in Postgres with even more flexibility.\n\nConstraints allow developers to specify rules and restrictions for the values that can be inserted into a column, and can be easily modified or removed without having to change the underlying data structure. Using constraints instead of enums, we can simply define a constraint that specifies the allowed values for the status column. This allows us to easily add or remove values as needed, without having to modify the data structure or update existing data. We can also define complex rules and restrictions, such as allowing multiple statuses for a single order, or requiring that certain statuses be set in combination with others.\n\nCheck constraints can do even more, for instance we can ensure that is always greater than or equal to . We can ensure that when status is that we have a that is .\n\nSo while they're incredibly useful as another approach to enums, they're broadly an amazing tool for ensuring data quality. By leveraging the power of constraints, you can easily enforce data integrity and ensure that the database is able to adapt to changing requirements and scenarios.\n\nMy vote, if you’re thinking about enums, do a test drive of the constraint."
    },
    {
        "link": "https://stackoverflow.com/questions/10923213/postgres-enum-data-type-or-check-constraint",
        "document": "Based on the comments and answers here, and some rudimentary research, I have the following summary to offer for comments from the Postgres-erati. Will really appreciate your input.\n\nThere are three ways to restrict entries in a Postgres database table column. Consider a table to store \"colors\" where you want only 'red', 'green', or 'blue' to be valid entries.\n• Advantages are that the type can be defined once and then reused in as many tables as needed. A standard query can list all the values for an ENUM type, and can be used to make application form widgets. SELECT n.nspname AS enum_schema, t.typname AS enum_name, e.enumlabel AS enum_value FROM pg_type t JOIN pg_enum e ON t.oid = e.enumtypid JOIN pg_catalog.pg_namespace n ON n.oid = t.typnamespace WHERE t.typname = 'valid_colors' enum_schema | enum_name | enum_value -------------+---------------+------------ public | valid_colors | red public | valid_colors | green public | valid_colors | blue Disadvantages are, the ENUM type is stored in system catalogs, so a query as above is required to view its definition. These values are not apparent when viewing the table definition. And, since an ENUM type is actually a data type separate from the built in NUMERIC and TEXT data types, the regular numeric and string operators and functions don't work on it. So, one can't do a query like SELECT FROM t WHERE color LIKE 'bl%';\n• Two advantage are that, one, \"what you see is what you get,\" that is, the valid values for the column are recorded right in the table definition, and two, all native string or numeric operators work.\n• Essentially the same as creating an ENUM type, except, the native numeric or string operators work, and one doesn't have to query system catalogs to discover the valid values. A join is required to link the to the desired text value."
    },
    {
        "link": "https://making.close.com/posts/native-enums-or-check-constraints-in-postgresql",
        "document": "Recently, we had a discussion about whether we should use native enums in PostgreSQL, or rely on regular string columns with constraints. In the end, we decided that we wanted to go with the latter.\n\nTag along if you want to learn why.\n\nNative enums in PostgreSQL are full-blown types. You declare a column as an enum the same way you would declare a column of any built-in type:\n\nThey come with ordering (from the order in which the values were declared), type safety (you cannot compare two values coming from different enums, even if their string or numerical representations are the same), and space efficiency (they are stored in the tuples as references to the actual enum values that exist in the catalogue tables). Although enums are intended for static sets of values, you can add values to the type and rename existing values. But enums also come with some limitations: for example, you cannot remove an existing value from an enum. To do that, you need to create a new enum in the form you want it to have, and then change all columns to use that new type (well, technically there are alternatives, see below).\n\nCreating a new enum and swapping existing columns to use the new type can be tricky. For the most straightforward cases, you will need something like this:\n\nHowever, depending on the size of the table, the command can have serious performance implications, because it acquires an lock. This lock is the most restrictive of all locks in PostgreSQL: your transaction is the only transaction that can access that table while it exists. Once it has that lock, it will perform a full table scan to migrate the data and ensure it conforms to the new type. This could make this alternative unfeasible to your application.\n\nString columns with constraints keep the most important property we want with enums: we can enforce data correctness in the database. It also comes with more flexibility: updating a constraint in the most complex cases is more manageable. And because you use the same method in all cases of updating the constraint, you don't have to remember multiple options. But it does come with one big downside: it is less space efficient. Because the actual values are stored in the tuples themselves, and not just a reference to the values, it can potentially take a lot of disk space.\n\nTo update a constraint, we do something like this:\n\nLet's go through each of these commands in more detail:\n• Drop the previous constraint. This is a operation. Nice and quick!\n• Migrate the data, to make it conform to the new constraint you are going to create. (If you are just dropping a value from the set of possible values, this can also be done before dropping the original constraint.)\n• Create the constraint in the new form you need, but with . This is also an operation: the constraint will not be enforced for existing rows, but it will be enforced for rows being created or updated.\n• Run to make sure all rows are good. The validation command acquires a more permissive lock, the lock, which allows concurrent updates to the table: basically, only schema changes and vacuum operations are blocked while validating a constraint.\n\nAs I mentioned above, there are alternatives to sidestep the locking of the database when you want to update an enum:\n• You can alter the catalogue tables directly. However, by doing that, you will have to make sure data is consistent yourself instead of relying on the database for that, and there's always a chance of corrupting the database.\n• Removing a value from an enum requires more care:\n• Add a constraint (with ) requiring that the value that you want to drop from the enum is not used.\n• Run for all indexes that use the enum.\n• This is required because the enum value you are dropping may still be used internally in the index as a decision node to help the database know where to go when looking for a value. The internal functions that compare enums wouldn't know what to do when they find the dropped value.\n• Remove the value from the catalogue tables directly.\n\nHowever, these methods are too involved for most use cases, and they do carry some risk of corrupting the database, since you are directly modifying tables that are supposed to be internal.\n\nBecause of not having to fully lock down the database for the migration of the constraint, and the relatively small disadvantages of the update procedure being a little more elaborate even in the simpler cases, and the usage of space being less efficient, we've decided to go with constraints instead of native enums in PostgreSQL."
    },
    {
        "link": "https://stackoverflow.com/questions/51299202/how-to-use-check-constraint-in-postgresql-for-string",
        "document": "i am new to postgres\n\nhow to create table with check constraint for column name say polluted which only have to accept 'yes' or 'no' values on insert.\n\nfor other values it should promote error message\n\nMy table name is vehicles"
    },
    {
        "link": "https://neon.tech/postgresql/postgresql-tutorial/postgresql-check-constraint",
        "document": "Summary: in this tutorial, you will learn about the PostgreSQL constraints and how to use them to constrain values in columns of a table based on a boolean expression.\n\nIn PostgreSQL, a constraint ensures that values in a column or a group of columns meet a specific condition.\n\nA check constraint allows you to enforce data integrity rules at the database level. A check constraint uses a boolean expression to evaluate the values, ensuring that only valid data is inserted or updated in a table.\n\nTypically, you create a check constraint when creating a table using the statement:\n• First, specify the constraint name after the keyword. This is optional. If you omit it, PostgreSQL will automatically generate a name for the constraint.\n• Second, define a condition that must be satisfied for the constraint to be valid.\n\nIf the constraint involves only one column, you can define it as a column constraint like this:\n\nBy default, PostgreSQL assigns a name to a constraint using the following format:\n\nTo add a constraint to an existing table, you use the statement:\n\nTo drop a constraint, you use the statement:\n\nLet’s explore some examples of using the constraints.\n\nFirst, create a new table called with some constraints:\n\nIn this statement, the table has one constraint that enforces the values in the salary column greater than zero.\n\nSecond, attempt to insert a new row with a negative salary into the table:\n\nThe insert fails because the constraint on the column accepts only positive values.\n\nFirst, use the statement to add a constraint to the table:\n\nThe constraint ensures that the joined date is later than the birthdate.\n\nSecond, attempt to insert a new row into the table with the joined date is earlier than the birth date:\n\nThe output indicates that the data violates the check constraint “joined_date_check”.\n\nThe following example adds a constraint to ensure that the first name has at least 3 characters:\n\nIn this example, we define a condition using the and functions:\n• First, the function removes leading and trailing whitespaces from the first_name.\n• Second, the function returns the character length of the result of the function.\n\nThe whole expression ensures the first name contains three or more characters.\n\nThe following statement will fail because it attempts to insert a row into the table with the first name that has 2 characters:\n\nThe following statement removes the constraint from the table:\n• Use PostgreSQL constraint to check the values of columns based on a boolean expression."
    }
]