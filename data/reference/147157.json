[
    {
        "link": "https://pygame.org/docs/tut/tom_games2.html",
        "document": ""
    },
    {
        "link": "https://stackoverflow.com/questions/20842801/how-to-display-text-in-pygame",
        "document": "I can't figure out to display text in pygame.\n\n I know I can't use print like in regular Python IDLE but I don't know how.\n\nThis is only the beginning part of the whole program.\n\n If there is a format that will allow me to show the text I type in the pygame window that'd be great. So instead of using print I would use something else. But I don't know what that something else is. When I run my program in pygame it doesn't show anything.\n\n I want the program to run in the pygame window instead of it just running in idle."
    },
    {
        "link": "https://medium.com/@maxknivets/pygame-tutorial-1-displaying-rendered-text-in-a-window-d0894d838ab3",
        "document": "Recently I had an idea to create a story-based game using python and pygame library. So I decided it’d be worth giving it a shot.\n\nFirst things first, let’s import the stuff that we need for now.\n\nNow, let’s configure all the necessary stuff.\n\nThe function changes the window’s name. You could name the window anything you want.\n\nFirstly, we need to create a font renderer that renders text with specific font and size. But creating a rendered font requires 2 things: the font that we need, and the size of the text.\n\nThe problem with passing the first thing to the font renderer is that you need to pass the string of the entire path to the font. It is time-consuming to manually search for the fonts you need, so Pygame offers a simple function: , which returns the path to the font, given the font’s name.\n\nPygame also offers a function that returns a list of available fonts: . Try running this in your shell to see all available fonts:\n\nUsually when running this function, it randomly shuffles the list, so I strongly discourage getting fonts from this list via index. \n\nNow that we settled the question, let’s create the font renderer.\n\nNow let’s try to render the message with our rendered font, and color (with a XY position of 5, 500)\n\nThis is how it should look like:\n\nThis is not a really convenient way to render messages, but at least it renders it now! Let’s simplify this even more:\n\nWe can simplify it even more!\n\nLet’s remove the font renderer function and write the message display as a one big function.\n\nAt this point the function looks much simpler and requires only one line to be called. It’ll come in handy when writing story-based games.\n\nIt is also annoying to write long function calls with the same parameters all the time. So let’s write a list with desired parameters to run the message display function with two arguments instead of five.\n\nNow, let’s use the variable.\n\nWe managed to simplify this task to calling the function with ease and 1 short line of code!\n\nLet’s not forget to make a while-loop so our window won’t close as soon as we launch the game.\n\nHere’s the result of our hard work:\n\nThe progress might look insignificant, but later on we will use this function to write dialogue between characters, and much more!\n\nThis is it for this tutorial. Thank you for reading!"
    },
    {
        "link": "https://pygame.org/docs/ref/font.html",
        "document": "The font module allows for rendering TrueType fonts into Surface objects. This module is built on top of the SDL_ttf library, which comes with all normal pygame installations.\n\nMost of the work done with fonts are done by using the actual Font objects. The module by itself only has routines to support the creation of Font objects with create a new Font object from a file.\n\nYou can load fonts from the system by using the create a Font object from the system fonts function. There are a few other functions to help look up the system fonts.\n\nPygame comes with a builtin default font, freesansbold. This can always be accessed by passing as the font name.\n\nBefore pygame 2.0.3, pygame.font accepts any UCS-2 / UTF-16 character ('\\u0001' to '\\uFFFF'). After 2.0.3, pygame.font built with SDL_ttf 2.0.15 accepts any valid UCS-4 / UTF-32 character (like emojis, if the font has them) ('\\U00000001' to '\\U0010FFFF')). More about this in .\n\nBefore pygame 2.0.3, this character space restriction can be avoided by using the Enhanced pygame module for loading and rendering computer fonts based to emulate the Font module. This can be used by defining the environment variable PYGAME_FREETYPE before the first import of the top level pygame package. Since the problem solves no longer exists, it will likely be removed in the future.\n\nGets or sets whether the font should be rendered in (faked) bold. Gets or sets whether the font should be rendered in (faked) italics. Gets or sets whether the font should be rendered with an underline. Gets or sets whether the font should be rendered with a strikethrough. determine the amount of space needed to render text control if text is rendered with an underline check if text will be rendered with an underline control if text is rendered with a strikethrough check if text will be rendered with a strikethrough check if text will be rendered bold gets the metrics for each character in the passed string check if the text will be rendered italic get the line space of the font text get the height of the font get the ascent of the font get the descent of the font Load a new font from a given filename or a python file object. The size is the height of the font in pixels. If the filename is the pygame default font will be loaded. If a font cannot be loaded from the arguments given an exception will be raised. Once the font is created the size cannot be changed. If no arguments are given then the default font will be used and a font size of 12 is used. Font objects are mainly used to render text into new Surface objects. The render can emulate bold or italic features, but it is better to load from a font with actual italic or bold glyphs. Gets or sets whether the font should be rendered in (faked) bold. Whether the font should be rendered in bold. When set to True, this enables the bold rendering of text. This is a fake stretching of the font that doesn't look good on many font types. If possible load the font from a real bold font file. While bold, the font will have a different width than when normal. This can be mixed with the italic, underline and strikethrough modes. Gets or sets whether the font should be rendered in (faked) italics. Whether the font should be rendered in italic. When set to True, this enables fake rendering of italic text. This is a fake skewing of the font that doesn't look good on many font types. If possible load the font from a real italic font file. While italic the font will have a different width than when normal. This can be mixed with the bold, underline and strikethrough modes. Gets or sets whether the font should be rendered with an underline. Whether the font should be rendered in underline. When set to True, all rendered fonts will include an underline. The underline is always one pixel thick, regardless of font size. This can be mixed with the bold, italic and strikethrough modes. Gets or sets whether the font should be rendered with a strikethrough. Whether the font should be rendered with a strikethrough. When set to True, all rendered fonts will include an strikethrough. The strikethrough is always one pixel thick, regardless of font size. This can be mixed with the bold, italic and underline modes. This creates a new Surface with the specified text rendered on it. pygame module for loading and rendering fonts provides no way to directly draw text on an existing Surface: instead you must use to create an image (Surface) of the text, then blit this image onto another Surface. The text can only be a single line: newline characters are not rendered. Null characters ('x00') raise a TypeError. Both Unicode and char (byte) strings are accepted. For Unicode strings only UCS-2 characters ('\\u0001' to '\\uFFFF') were previously supported and any greater unicode codepoint would raise a UnicodeError. Now, characters in the UCS-4 range are supported. For char strings a encoding is assumed. The antialias argument is a boolean: if True the characters will have smooth edges. The color argument is the color of the text [e.g.: (0,0,255) for blue]. The optional background argument is a color to use for the text background. If no background is passed the area outside the text will be transparent. The Surface returned will be of the dimensions required to hold the text. (the same as those returned by ). If an empty string is passed for the text, a blank surface will be returned that is zero pixel wide and the height of the font. Depending on the type of background and antialiasing used, this returns different types of Surfaces. For performance reasons, it is good to know what type of image will be used. If antialiasing is not used, the return image will always be an 8-bit image with a two-color palette. If the background is transparent a colorkey will be set. Antialiased images are rendered to 24-bit images. If the background is transparent a pixel alpha will be included. Optimization: if you know that the final destination for the text (on the screen) will always have a solid background, and the text is antialiased, you can improve performance by specifying the background color. This will cause the resulting image to maintain transparency information by colorkey rather than (much less efficient) alpha values. If you render '\n\n' an unknown char will be rendered. Usually a rectangle. Instead you need to handle newlines yourself. Font rendering is not thread safe: only a single thread can render text at any time. Changed in pygame 2.0.3: Rendering UCS4 unicode works and does not raise an exception. Use to see if pygame supports rendering UCS4 unicode including more languages and emoji. determine the amount of space needed to render text Returns the dimensions needed to render the text. This can be used to help determine the positioning needed for text before it is rendered. It can also be used for word wrapping and other layout effects. Be aware that most fonts use kerning which adjusts the widths for specific letter pairs. For example, the width for \"ae\" will not always match the width for \"a\" + \"e\". control if text is rendered with an underline When enabled, all rendered fonts will include an underline. The underline is always one pixel thick, regardless of font size. This can be mixed with the bold, italic and strikethrough modes. This is the same as the attribute. check if text will be rendered with an underline This is the same as the attribute. control if text is rendered with a strikethrough When enabled, all rendered fonts will include a strikethrough. The strikethrough is always one pixel thick, regardless of font size. This can be mixed with the bold, italic and underline modes. This is the same as the attribute. check if text will be rendered with a strikethrough This is the same as the attribute. Enables the bold rendering of text. This is a fake stretching of the font that doesn't look good on many font types. If possible load the font from a real bold font file. While bold, the font will have a different width than when normal. This can be mixed with the italic, underline and strikethrough modes. This is the same as the attribute. check if text will be rendered bold This is the same as the attribute. Enables fake rendering of italic text. This is a fake skewing of the font that doesn't look good on many font types. If possible load the font from a real italic font file. While italic the font will have a different width than when normal. This can be mixed with the bold, underline and strikethrough modes. This is the same as the attribute. gets the metrics for each character in the passed string The list contains tuples for each character, which contain the minimum offset, the maximum offset, the minimum offset, the maximum offset and the advance offset (bearing plus width) of the character. [(minx, maxx, miny, maxy, advance), (minx, maxx, miny, maxy, advance), ...]. None is entered in the list for each unrecognized character. check if the text will be rendered italic This is the same as the attribute. get the line space of the font text Return the height in pixels for a line of text with the font. When rendering multiple lines of text this is the recommended amount of space between lines. get the height of the font Return the height in pixels of the actual rendered text. This is the average size for each glyph in the font. get the ascent of the font Return the height in pixels for the font ascent. The ascent is the number of pixels from the font baseline to the top of the font. get the descent of the font Return the height in pixels for the font descent. The descent is the number of pixels from the font baseline to the bottom of the font. Experimental: feature still in development available for testing and feedback. It may change. Please leave feedback with authors Sets the script used by harfbuzz text shaping, taking a 4 character script code as input. For example, Hindi is written in the Devanagari script, for which the script code is . See the full list of script codes in ISO 15924. This method requires pygame built with SDL_ttf 2.20.0 or above. Otherwise the method will raise a pygame.error."
    },
    {
        "link": "https://pygame.org/docs/ref/display.html",
        "document": "This module offers control over the pygame display. Pygame has a single display Surface that is either contained in a window or runs full screen. Once you create the display you treat it as a regular Surface. Changes are not immediately visible onscreen; you must choose one of the two flipping functions to update the actual display.\n\nThe origin of the display, where x = 0 and y = 0, is the top left of the screen. Both axes increase positively towards the bottom right of the screen.\n\nThe pygame display can actually be initialized in one of several modes. By default, the display is a basic software driven framebuffer. You can request special modules like automatic scaling or OpenGL support. These are controlled by flags passed to .\n\nPygame can only have a single display active at any time. Creating a new one with will close the previous display. To detect the number and size of attached screens, you can use and then select appropriate window size and display index to pass to .\n\nFor backward compatibility allows precise control over the pixel format or display resolutions. This used to be necessary with old graphics cards and CRT screens, but is usually not needed any more. Use the functions , , and to query detailed information about the display.\n\nOnce the display Surface is created, the functions from this module affect the single existing display. The Surface becomes invalid if the module is uninitialized. If a new display mode is set, the existing Surface will automatically switch to operate on the new display.\n\nWhen the display mode is set, several events are placed on the pygame event queue. is sent when the user has requested the program to shut down. The window will receive events as the display gains and loses input focus. If the display is set with the flag, events will be sent when the user adjusts the window dimensions. Hardware displays that draw direct to the screen will get events when portions of the window must be redrawn.\n\nA new windowevent API was introduced in pygame 2.0.1. Check event module docs for more information on that\n\nSome display environments have an option for automatically stretching all windows. When this option is enabled, this automatic stretching distorts the appearance of the pygame window. In the pygame examples directory, there is example code (prevent_display_stretching.py) which shows how to disable this automatic stretching of the pygame display on Microsoft Windows (Vista or newer required).\n\nThis function will create a display Surface. The arguments passed in are requests for a display type. The actual created display will be the best possible match supported by the system. Note that calling this function implicitly initializes , if it was not initialized before. The size argument is a pair of numbers representing the width and height. The flags argument is a collection of additional options. The depth argument represents the number of bits to use for color. The Surface that gets returned can be drawn to like a regular Surface but changes will eventually be seen on the monitor. If no size is passed or is set to and pygame uses version 1.2.10 or above, the created Surface will have the same size as the current screen resolution. If only the width or height are set to , the Surface will have the same width or height as the screen resolution. Using a version prior to 1.2.10 will raise an exception. It is usually best to not pass the depth argument. It will default to the best and fastest color depth for the system. If your game requires a specific color format you can control the depth with this argument. Pygame will emulate an unavailable color depth which can be slow. When requesting fullscreen display modes, sometimes an exact match for the requested size cannot be made. In these situations pygame will select the closest compatible match. The returned surface will still always match the requested size. On high resolution displays(4k, 1080p) and tiny graphics games (640x480) show up very small so that they are unplayable. SCALED scales up the window for you. The game thinks it's a 640x480 window, but really it can be bigger. Mouse events are scaled for you, so your game doesn't need to do it. Note that SCALED is considered an experimental API and may change in future releases. The flags argument controls which type of display you want. There are several to choose from, and you can even combine multiple types using the bitwise or operator, (the pipe \"|\" character). Here are the display flags you will want to choose from: New in pygame 2.0.0: , and By setting the parameter to , it is possible to get a display with vertical sync, but you are not guaranteed to get one. The request only works at all for calls to with the or flags set, and is still not guaranteed even with one of those set. What you get depends on the hardware and driver configuration of the system pygame is running on. Here is an example usage of a call to that may give you a display with vsync: Vsync behaviour is considered experimental, and may change in future releases. The display index means the default display is used. If no display index argument is provided, the default display can be overridden with an environment variable. Changed in pygame 2.1.3: pygame now ensures that subsequent calls to this function clears the window to black. On older versions, this was an implementation detail on the major platforms this function was tested with."
    },
    {
        "link": "https://stackoverflow.com/questions/43441996/how-to-display-game-over-screen-and-you-win-screen-in-pygame",
        "document": "If the player or the enemy have less than zero health, set which stops the game's while loop. Then the method of the game instance is called in the outermost while loop.\n\nIn the method, blit the background image and the text (I created the BACKGROUND_IMG and the FONT object globally), flip the display and start another while loop with an event loop in which you check if the user wants to quit or continue. If the user quits, you set to so that the outer while loop will stop as well, because its condition is . If space is pressed, you can just return from this method and the outer while loop calls what resets the game.\n\nIf you want to make more complex scenes/states, I recommend to use a finite state machine like this. It's actually just a scene manager class which allows you to switch between the different scenes/states of the game."
    },
    {
        "link": "https://quirkycort.github.io/tutorials/20-Pygame-Zero-Basics/20-Gem/80-gameover.html",
        "document": "This course teaches game development using Pygame Zero. It will take the student through the creation of a few sample games.\n\nIt's not much fun to play a game that you cannot lose. So let's add in a game over condition. If the gem touches the bottom of the screen, we'll end the game.\n\nFirst, add in a new variable called and set it to .\n\nInside the function, look for these lines...\n\n...and change them to these...\n\nThis will set the variable to if the gem touches the bottom of the screen.\n\nYou will also need to add to the top of the function. Do you remember why? If you can't, refer back to the keeping score page.\n\n...into these (watch out for the indents)...\n\nThis will make it draw the game over text when the variable is , otherwise it will draw the gem and the ship as before.\n\nYour final program should look like this..."
    },
    {
        "link": "https://stackoverflow.com/questions/20431501/pygame-game-over-screen",
        "document": "Hello I am making a game in and I am wondering how and what the best way is to add a game over screen. Here is the code up to where the players health is smaller or equal to 0:\n\nI am not exactly sure how to do it, because I tried to use another py call game over but the time of which the player died was then reset to 0 and went back up, so is it possible for anything to happen where the player dies?"
    },
    {
        "link": "https://instructables.com/Dodging-Fire-Pygame-Zero-Beginner-Tutorial",
        "document": "About: Hello, my name is Michael. I am an electrical and computer engineer turned educator. I have a lot of experience in embedded software and hardware design. I am taking my technical experiences and leveraging the… Follow along with this Pygame Zero tutorial to implement the game: \"Dodging Fire\". In this game, fireballs spawn from the sides with random trajectories. Dodge them all or you will lose! Your score increases the longer you survive. I use this tutorial in my high school Game Design course at NCSSM. After learning the basics of Pygame Zero, we begin our unit on 2D games. This tutorial is the second in a series they complete as they are learning the fundamentals of developing 2D games. At the end of the unit, they create a 2D game of their own. Below are links to all the tutorials: Note: This tutorial gives an exhaustive overview of how to implement this game, with complete explanations for each step. Feel free to skip over certain parts you feel more comfortable with. I wrote a thorough explanation of each concept, so that when you encountered something you weren't as familiar with, you could read in more detail.\n\nAll you need is a Windows/Mac/Linux machine with Python installed. If you are on a Chromebook or can't install Python on your machine, you can use the Pygame template on replit for free. To set up your local environment, follow the steps below. Go to the page listed above. Download the latest version available for your operating system. Run the installer and follow the instructions. Make sure you install pip and add the Python executable to the path (should be check boxes for each). There are many, many different options for a text editor for developing code. Far be it from me to mandate a specific code editor only for you to blame me later on when you find an editor more suitable for your purposes. Each editor has its pros and cons; it is really based on personal preference and how you will use it. Feel free to search around and find one that works for you. I recommend using VScode. VScode - https://code.visualstudio.com/ - A powerful code editor that is quickly becoming the standard for many forms of software development. Includes a lot of features and has many useful packages/extensions that can be installed. Below is a list of helpful extensions. Open the extensions tab, search for the extension, and install it. Once you have Python installed, we will need to install Pygame Zero. To do this, you will need to \"Command Prompt\" on Windows or \"Terminal\" on Mac. Once you have done this, enter the following command: If pip is not installed, try running the following command: You may experience some weirdness on Macs. Try running the following commands. Create a folder where you want to save your project. Make sure it is an easily accessible location on your computer. In VScode, click the \"File\" menu and select \"Open Folder\". Select the folder containing the examples and assets. Inside VScode, open one of the examples or create a new file and copy your code from repl.it. Once the file is open, click the \"play\" button in the top right-hand corner to run the code. On the left side of VScode is the file navigation pane. You can create a new file by clicking on the icon. All files should end with .py, indicating that they are a Python source file.\n\nIn this game, there are three key Actors: the background scene, the robot player, and the fireball. An Actor is just a representation of some visual object within our game. It can be a player, enemy, background, obstacle, etc. It is a way of showing and controlling an image. Start by making the background scene Actor and setting it to the \"water\" image. We need to set the initial position of the background. We will set it to the center. We can combine this with the step above or individually set the pos. pos represents the position of center of the Actor. To get the exact center of the screen, divide the WIDTH and HEIGHT by two. Positions are provided and set as tuples. Tuples are a list-like data type that stores a collection of values; however, it cannot be changed. Tuples are written with parentheses as opposed to square brackets. However, we can retrieve their values in the same way using indexing with square brackets. See the example below. new_pos = (300, 400)\n\nnew_pos[0] # gives us the x coordinate\n\nnew_pos[1] # gives us the y coordinate\n\nnew_pos[0] = 100 # cannot be done! Can only assign new tuple\n\nnew_pos = (100, 400) # correctly makes new assignment\n\n Next, create the robot Actor and set it to the \"robot_idle\" image. In a future step, we will get it to show the left and right versions of the image. Set the actor's position to be centered, but standing at the very bottom of the screen. The graphic below shows all the ways we can get or set the position of an Actor using tuples. We can also get or set the Actor's position by just changing a single x or y coordinate. We can do this using the anchors shown below. y, top, and bottom would give the y-coordinate of that location of the actor. x, right, left would give the x-coordinate of that location of the actor. Finally, create a fireball Actor and set it to the \"fireball\" image. There will be many instances of this fireball, but for now we will start with one. We want the fireball to appear at a random position. To do this, we will need to import the randint() function by adding from random import randint to the top of our program. Then we can use randint(a, b) by supplying two values identifying the start and end of the range of values from which we want to choose a number randomly. See the example below that choose a random x-coordinate between 0 and WIDTH and a y-coordinate between 0 and HEIGHT. Remember, pos and x and y represent the center of the actor. With the above code, we could randomly generate the coordinate (0, 0), which would center the fireball at this location placing it half off the screen. We can adjust for this by adding a buffer of 20 pixels like shown below. Now it is time to draw these Actors into the scene/game. We will do this using the variable representing each Actor with the .draw() method. This code will go inside the draw() function because it is displaying the new frame. Remember to always start your draw() functions with screen.clear() or it will display artifacts from the previous time something was drawn to the screen. Another thing to keep in mind is that the order in which you draw things matters. If you draw the background after the robot and the fireball, the background will be placed over top of the other Actors, hiding them from view.\n\nWe want to be able to move our robot character with the keyboard. There are many different ways to go about it based on the behavior you want. For this game, we want the player to move while the button is pressed. To make this happen, we will add code to our update() function since it is called consistently. The on_key_down() and on_key_up() event listeners are only triggered once when a button is pressed and released. By adding a conditional statement to update() to check if the button is pressed, it will have the effect of continually moving while the button is pressed. Even though we don't have a loop in our program, update() behaves somewhat like a loop because it is called endlessly. To check if a key on the keyboard is pressed in update(), we use the keyboard.KEY_NAME syntax, which is a boolean expression that tells us whether a button is pressed. The various keyboard KEY_NAME constants are described here. def update():\n\n if keyboard.LEFT:\n\n # do something\n\n elif keyboard.RIGHT:\n\n # do something\n\n if keyboard.UP:\n\n # do something\n\n elif keyboard.DOWN\n\n # do something\n\n To move the robot, we need to modify its position. The best way to do that is to add or remove by the same consistent value. We will store this value in a global variable called velocity. By storing the value in a global variable, we only need to change the value in the variable to increase the robot's velocity, as opposed to multiple places in the code. It also allows us to modify velocity from anywhere in the code if we want the player to speed up due to a power-up or some other effect. Below show's an example of how to define and use the variable velocity. # define global variables towards the top of your program\n\nvelocity = 5\n\n\n\n...\n\n\n\n# modify the player's position within update()\n\n# add code below to corresponding keyboard conditionals\n\nrobot.x -= velocity # moves Actor left\n\nrobot.y += velocity # moves Actor down\n\n We want our actor to move up, down, left, and right when the arrow keys are pressed by the value set in velocity.\n\nAt this point, your player robot should be moving up, down, left, and right while the arrow key buttons are pressed. But you've probably noticed that the robot can move beyond the extents of the screen and never stops. That is because the actor's x and y coordinates are unaware of the screen size! We will have to implement this logic ourselves. To do this, we will only allow the robot to move in update() if the key is pressed AND it is not at the edge of the screen. We will need to modify our movement conditionals within update(). We can do this by checking if the Actor's position is beyond the extents of the screen. We want to make sure that when moving horizontally, it does not go beyond the left edge of our screen (x must be greater than 0) or the right edge of our screen (x must be less than WIDTH). When moving vertically, the Actor cannot go beyond the top edge of the screen (y must be greater than 0) or the bottom edge of our screen (y must be less than HEIGHT). We can modify our conditional statements to look like this. def update():\n\n if keyboard.LEFT and robot.x > 0:\n\n robot.x -= velocity\n\n elif keyboard.RIGHT and robot.x < WIDTH:\n\n robot.x += velocity\n\n elif keyboard.UP and robot.y > 0:\n\n robot.y -= velocity\n\n elif keyboard.DOWN and robot.y < HEIGHT:\n\n robot.y += velocity\n\n However, pos doesn't tell us if the edge of the actor is beyond the extents of the screen. It only tells us if the center is off the screen. To check the edges, we need to use one of the other anchor points for an Actor listed below. There are a few ways to go about this, but the following way makes the most sense to me. robot.left # gets Actor's leftmost x position\n\nrobot.right # gets Actor's rightmost x position\n\nrobot.top # gets Actor's topmost y position\n\nrobot.bottom # gets Actor's bottommost y position\n\n Substitute these values into the conditional statements shown above to prevent the robot from moving off the screen. No part of the image should move beyond the extent of the screen.\n\nNow, we want to investigate how to modify which image is being shown for a specific Actor. We will animate the player or create a sprite as it is known in video game design. To change the image we can use the following code, where image is the parameter we want to change and the value is a String value representing the file name of the image from the images directory that we want to change it to: To check which image is currently being shown, we can retrieve the value using robot.image and compare its value within the condition of an if statement. See the example below In this case, we have three robot images: robot_idle, robot_left, robot_right. We want to modify which way the robot is facing based on which direction the robot is moving. If it is moving left, show the left facing image. If it is moving right, show the right facing image. If it is moving up or down or standing still, show the front facing image. There are a number of ways to do this. We have our on_key_down() and on_key_up() event listeners, which are triggered when a keyboard button is pressed and released, respectively. The way I would approach this is to add the following code to the corresponding conditional statements in update() to update the image based on which keyboard key is pressed. By adding that code to your update(), it should show the image moving left and right when you press the corresponding button. However, the Actor would never return to the front facing image. To handle this case, I would use the on_key_up() event listener to return the Actor to its front facing image when the left or right buttons are released. # called when a keyboard button is released\n\ndef on_key_up(key):\n\n # change to forward facing image when left/right keys released\n\n if key == keys.LEFT or key == keys.RIGHT:\n\n robot.image = \"robot_idle\"\n\n\n\nIn this game, we will want to spawn many fireballs. To be able to use the same section of code repeatedly, it is best to place this code inside a function, so we can call it repeatedly. Move your code that creates a fireball actor inside a function called spawn_fireball(). Notice the last line in the function. It appends the new fireball Actor to a list of Actors called fireballs. Remember, a list is a collection of items that we want to group together, so we don't have to keep track of individual variables for every item. It will be helpful to keep a list of all the fireball Actors, so we can draw each of them on the screen and detect if the player has collected any of them. To do this, we will need to define a global list variable called fireballs. This will need to go towards the top of your program along with the definition of velocity. Now that we have created a function to create a new fireball Actor and add it to the list fireballs, we can schedule that function to be called at a regular interval using Clock. The following line of code shows how to schedule a callback to spawn_fireball to occur every 0.5 seconds. Place this line of code just before pgzrun.go() outside all functions. That ensures that Pygame will schedule the callback to occur just before repeatedly calling update() and draw(). If you run the program at this point, you still won't see any fireballs on the screen. That's because we haven't drawn them yet in the draw() function. There are a few more steps involved here since we are drawing an entire list of Actors and not just a single actor. You will need to create a for loop to get each individual Actor, then you can draw them one at a time. It should look something like this. Now, you should have fireballs showing up at random locations on the screen every half a second!\n\nLike the last game, we want our objects to move. We will need to adjust the fireball position within update() to move them about the screen each frame. First, let's start by making them spawn just to the left of the screen To do this, we will need to adjust the x-position we set for each new fireball. Instead of making it random, let's start at a fixed x-coordinate of 0. We still want the y-coordinate to be random so that it adjusts where they fall from. Now, let's make the fireballs move. We are going to make new Actor-specific variables. They are similar to global variables in that they can be used anywhere, but they allow each Actor to have its specific values for the variables. To create Actor-specific variables, you use the variable representing the actor and declare the new variable like so: actor.new_variable = 12. We will create velocity_x and velocity_y variables for each fireball. This ensure each fireball will have its own unique speed and direction. velocity_x represents the change in the x-coordinate of the fireball each frame. velocity_y represents the change in the y-coordinate of the fireball each frame. def spawn_fireball():\n\n fireball = Actor(\"fireball\")\n\n # set initial position\n\n fireball.x = 0\n\n fireball.y = randint(100, HEIGHT - 100)\n\n # creates new actor variables for velocity\n\n fireball.velocity_x = randint(1, 3)\n\n fireball.velocity_y = randint(-3, 3)\n\n # append to list of fireballs\n\n fireballs.append(fireball)\n\n We randomly generate the x and y components of the velocity to change how they move. Since the starting x-coordinate is 0, we make the velocity a positive value so it moves onto the screen. To update the fireball's position, we need to increment both the x and y positions by velocity_x and velocity_y inside update(). We will need to use our for loop again to visit each fireball in the list of fireballs. # for each fireball\n\nfor fireball in fireballs:\n\n # advance fireballs to new position\n\n fireball.x += fireball.velocity_x\n\n fireball.y += fireball.velocity_y\n\n However, we will also want the fireballs to sometimes start on the right side of the screen. That would mean that the x-coordinate should start at WIDTH and velocity should be negative. See the modification to the code below to make the fireballs move right to left and left to right. def spawn_fireball():\n\n fireball = Actor(\"fireball\")\n\n # set initial position\n\n fireball.x = randint(0, 1) * WIDTH\n\n fireball.y = randint(100, HEIGHT - 100)\n\n # creates new actor variables for velocity\n\n if fireball.x == 0:\n\n fireball.velocity_x = randint(1, 3)\n\n else:\n\n fireball.velocity_x = randint(-3, -1)\n\n fireball.velocity_y = randint(-3, 3)\n\n # append to list of fireballs\n\n fireballs.append(fireball)\n\n Run the game and you should start to see fireballs moving across the screen. But what happens when the fireballs move off the screen? Based on our current code, we are still advancing its position and drawing it. Our program is still keeping track of every fireball, despite the fact that it is not visible on the screen. This is taking up a lot of computer's memory and could eventually crash the program, so we should help it out! We want to add code to remove each fireball once it has gone below the screen. To do this, we can add some additional logic to our for loop above to remove the fireball. We will add a conditional statement to check the extremes of the fireballs to see if they've gone beyond the extents of the screen. # for each fireball\n\nfor fireball in fireballs:\n\n # advance to new position\n\n fireball.x += fireball.velocity_x\n\n fireball.y += fireball.velocity_y\n\n # if top of fireball is off the screen\n\n if fireball.top > HEIGHT or fireball.bottom < 0 or fireball.left > WIDTH or fireball.right < 0:\n\n fireballs.remove(fireball)\n\n When you run your program again, you shouldn't see a difference, although your computer will thank you! At a certain point, it would have crashed your program by generating too many fireballs. To rotate an actor, we can add to a parameter called angle. This represents the angle of rotation in degrees between 0 and 360. Inside update(), we can continually add 10 degrees to the angle to make it look like the fireball is spinning. # for each fireball\n\nfor fireball in fireballs:\n\n # advance fireballs to new position\n\n fireball.x += fireball.velocity_x\n\n fireball.y += fireball.velocity_y\n\n # rotate the image by 10 degrees each time\n\n fireball.angle += 10\n\n\n\nTo handle the lose scenario, we are going to add a game_over() function. This is not a function that is built into Pygame, but rather, a function we will call once we've determined that the player has lost. We can use it to halt the timer, stop creating new objects, display a message, etc. Before we define the function, we will need to add another global variable called over. This will be a boolean variable that will be True when the game is over and False when the game is running. Define it at the top with the other global variables and set its initial value to False. In this game, our game_over() function should stop the interval timers for spawn_fireball and increment_timer and set over to True. Note: over should be declared as global since it is a boolean variable that we are modifying. # called during lose condition to trigger game_over\n\ndef game_over():\n\n global over\n\n # set over to True\n\n over = True\n\n # stop interval timers\n\n clock.unschedule(increment_timer)\n\n clock.unschedule(spawn_fireball)\n\n Defining a function does nothing until we call it! We want to call our game_over() function when the robot has collided with a fireball. We should do this inside update() after the collision detection. if not over: # if over == False\n\n game_over()\n\n Why did we write if not over? if not over means that game_over will only be called when the over variable is set to False. It prevents us from calling game_over() over and over and over again once the player has lost. We only want to call game_over() once. We can check if we've called it before, because we only change over to False within game_over(). We also want to display a \"Game Over!\" message once the player has lost. Since we are updating the screen, we will add this code to draw(). We can check the value of the over variable in a condition. If it is True, we can write a message on the center of the screen. if over: # same as \"if over == True\"\n\n screen.draw.text(\"Game Over!\", center=(WIDTH // 2, HEIGHT // 2))"
    },
    {
        "link": "https://quirkycort.github.io/tutorials/20-Pygame-Zero-Basics/30-Ninja/70-gameover.html",
        "document": "This course teaches game development using Pygame Zero. It will take the student through the creation of a few sample games.\n\nRight now, the game does nothing even if our ninja crashes into the cactus. Let's add in a game over condition. If the ninja touches any of the obstacles, we'll end the game.\n\nFirst, we'll add in a variable called and set it to at the start.\n\nInside the function, we'll detect if our runner collided with any of the obstacles. If she did, we'll set to .\n\nImportant: Remember to declare as a global in the function.\n\nThe checks if the runner collided with any of the actors in the list. If she didn't, the function will give us the value .\n\nNext, we'll need to draw the game over text inside by changing this...\n\nYour final game should look like this..."
    },
    {
        "link": "https://reddit.com/r/pygame/comments/18q5dns/how_should_game_states_be_handled",
        "document": "I’ve had this question for a while and I have always just decided to do what felt easiest in the moment but I’m really starting to wonder what the best way to do it is. In a game you always have your game loop that runs every frame. But let’s say you have a game over screen. Should that be a separate loop that begins running when the game_over variable becomes true or should it be within your main loop handled by if statements? I feel like having multiple game loops is messy and not very DRY usually but I also feel like it’s hard to manage and messy putting it in the main loop. So what is the best solution here? Thank you for all answers!"
    },
    {
        "link": "https://reddit.com/r/learnpython/comments/ed1x3r/best_way_to_manage_game_state_in_pygame_for_a",
        "document": "This is more of a teaching python question (is there a sub for that)?. I'm writing curriculum for a beginner middle school coding club and am having an internal debate, and could use some feedback from an education perspective.\n\nIf you've used pygame before, you know that a major conceptual hurdle for beginners is variable scope. Once you learn to organize your code into functions, you'll find things don't work quite as you expected. Sure, you can access variables that are declared outside in your function, but now you can't change them. However, you can change variables that are in another namespace (such as object properties).\n\nLet's take an example student, Sophie, who has just learned the following python concepts:\n\nAt this point, she's ready to make her first pygame. She learns the following pygame concepts:\n• The game loop (we'll use the analogy of a flip-book animation): *# process events *# update stuff *# render stuff\n\nSophie is now learning to organize her code into functions. But fairly soon, she runs into the problem of how to handle game state (though she won't yet know this problem has a name).\n\nThere are many options to handle this, and I'm struggling with how it should be taught. Each option has its pros and cons, as each one requires additional concepts that must be learned.\n\nCan't change a variable? Just slap a in there somewhere. Of course, this is enough to make any Python dev cringe. On the other hand, declaring something as global is a quick and easy (albeit dirty) solution. But should should we be encouraging bad habits this early?\n\nThis might be seen as the most \"pythonic\" way to manage state. In fact, it's what functions are designed for. You pass relevant information in, you get something else out. In practice, however, this quickly gets messy and difficult to manage. The more game state variables Sophie needs to keep track of, the more parameters she needs to add to her function. A seasoned developer would be able to refactor things so that everything works beautifully, but this would prove difficult for beginners.\n\nAs a seasoned dev, this was my first instinct. Define one dictionary at the top called and store your variables in that. You can then change the values anywhere as you please. The only downside to this is that you have to introduce new students to dictionary syntax pretty early, and it may seem odd when most of the stuff you've been doing in pygame until now uses dot notation. Which would look more familiar to Suzie at this point?\n\nIf we like dot notation, we could define a class with the variables we want and set at the top. Then, like the dictionary, we could reference and change those variables anywhere in our script. Something like this:\n\nThis has the downside of needing to learn some new concepts:\n\nAt this phase, I feel it's a bit too early to teach object-oriented programming concepts (I know you're using OO when using dot-notation, but you don't need to fully understand OO concepts in order to use it).\n\nIn option 4, there's really no practical reason to instantiate the class as we need it only once, so in essence it's a singleton pattern. If that's the case, we could simplify things a bit by using a static class as a namespace with mutable variables:\n\nOption 5 seems like the cleanest and easiest to learn. While it seems unconventional, it doesn't seem a major abuse of classes, as classes are essentially a dict under the hood. However, we might introduce object-oriented programming later on when our games become more complex, and I'd hate for this to make that more confusing.\n\nWhat do you think?\n\nWhether you're an educator or a beginner, I'd love to hear your thoughts and opinions on this!"
    },
    {
        "link": "https://amudacodes.hashnode.dev/mastering-game-flow-pygames-secret-sauce-for-seamless-state-transitions",
        "document": ""
    },
    {
        "link": "https://gamedev.stackexchange.com/questions/117193/managing-game-states-states-flow-controlling-the-state-machine",
        "document": "Stack Exchange network consists of 183 Q&A communities including Stack Overflow, the largest, most trusted online community for developers to learn, share their knowledge, and build their careers."
    },
    {
        "link": "https://codewithc.com/managing-game-states-in-pygame-menus-gameplay-and-beyond?amp=1",
        "document": "Mastering Game States in Pygame: From Menus to Gameplay and Beyond Have you ever found yourself completely engrossed in a video game, losing track of time and reality? The seamless transition between different game screens and states plays a crucial role in creating an immersive and interactive gaming experience. In this blog post, we will explore the fascinating world of managing game states in Pygame, a popular game development library for Python. From designing captivating menus to navigating through various in-game states, we will uncover the secrets to making your games truly engaging and dynamic. So, grab your virtual joysticks and let’s level up our game development skills together!\n\nBefore we dive into creating menus and gameplay states, let’s start by understanding what game states are and why they are essential for crafting rich gaming experiences.\n\nWhat are game states and why are they important?\n\nIn any video game, a game state refers to a particular phase or screen that the player interacts with. It could be as simple as a main menu, a pause menu, or as complex as in-game levels, cutscenes, and game-over screens. Each state has its own unique set of rules, visuals, and user interactions. By managing these game states effectively, we can control the flow of gameplay and provide players with a seamless and immersive experience.\n\nThe role of game states in creating interactive and dynamic gameplay\n\nGame states are the building blocks of a game’s structure. They allow us to create dynamic and interactive gameplay by modifying the rules and visuals based on the current state. Think of it as switching between different dimensions, where each dimension represents a specific state of the game. By seamlessly transitioning between these dimensions, we can create a nonlinear and engaging gaming experience.\n\nHow Pygame utilizes game states for smooth transitions and immersive experiences\n\nPygame, an open-source game development library for Python, provides a powerful set of tools and functionalities to manage game states effectively. With Pygame, we can create a hierarchy of screens or states and handle their respective events, visuals, and logic. This allows us to switch between menu screens, gameplay screens, cutscenes, and more with ease.\n\nNow that we have a grasp on the importance of game states, let’s explore how to create compelling menus using Pygame.\n\nMenus serve as the gateway to your game, setting the tone and providing essential options and information to the player. Let’s delve into the art of creating eye-catching menus using Pygame’s surface and sprite modules.\n\nThe main menu is the first impression your game makes on players, so it should be visually appealing and inviting. Here are some tips to make your main menu stand out:\n• Use vibrant colors, attractive fonts, and visually pleasing graphics to create an enticing aesthetic.\n• Incorporate interactive buttons that respond to hovering and clicking events, making the menu feel dynamic.\n• Implement smooth and animated transitions between menu screens to captivate the player’s attention.\n• Add background music or sound effects to enhance the overall experience and create an immersive atmosphere.\n\nGiving players the ability to customize game options heightens engagement and personalization. Here’s how you can implement game settings within your menu:\n• Create a settings menu screen with toggle switches or sliders for adjusting options like sound volume, graphics quality, and control schemes.\n• Utilize Pygame’s event handling system to capture user input and update the game settings accordingly.\n• Design a clear “back” button that allows players to return to the main menu without losing their progress.\n\nIf your game offers different levels or stages, a level selection menu is essential. Follow these steps to create a smooth level selection experience:\n• Design an appealing level selection screen that showcases the different levels, complete with enticing visuals and descriptions.\n• Implement a system to save and load player progress, enabling players to continue where they left off.\n• Offer various difficulty levels to cater to players with different skill levels, providing a range of challenges and ensuring an enjoyable experience for everyone.\n\nHooray! We’ve mastered the art of creating dynamic menus. Now, let’s shift our focus to navigating through various in-game states in Pygame.\n\nIn-game states determine how players interact with the game world, from starting a new game to handling pauses and game over scenarios. Let’s explore how to handle these states gracefully using Pygame.\n\nStarting a new game is a significant part of the player’s journey. To ensure a seamless start, follow these steps:\n• Initialize a new game state when transitioning from the main menu to the gameplay screen.\n• Set up a timer and score tracker if your game is time-based or point-based.\n• Implement player lives and game-over conditions to add challenges and create a sense of achievement.\n\nSometimes players need to take a break or adjust game settings without quitting the game entirely. Here’s how to design a pause and resume system:\n• Create a pause menu with options to resume gameplay, access settings, or quit the game.\n• Temporarily halt game logic while displaying the pause menu, ensuring smooth transitions from gameplay to pause and back.\n• Use visual cues like dimming the screen or displaying a “paused” message to indicate the game is temporarily on hold.\n\nGame-over scenarios are inevitable in most games, but they also provide opportunities for players to reflect and strive for improvement. Here’s how to handle the game-over state effectively:\n• Design a visually appealing game-over screen that displays the player’s statistics and offers options to retry or return to the main menu.\n• Incorporate leaderboards or high scores to add a competitive element and motivate players to beat their own records.\n• Allow players to save their progress or share their achievements on social media to boost engagement and foster a sense of accomplishment.\n\nWow! We’ve made it through the in-game state maze! But wait, there’s more! Let’s take a glimpse into the realm of advanced game states in Pygame.\n\nAre you ready to level up your game development skills and take your game states to the next level? Get your coding gloves on as we explore advanced game states in Pygame!\n\nCutscenes and intros do wonders in setting the stage and immersing players in your game’s storyline. Here’s how to implement captivating cutscenes and intros:\n• Provide an option for players to skip cutscenes or replay them if they desire.\n\nLooking to add an extra layer of excitement and replay value to your game? Bonus levels and unlockables are the way to go! Here’s what you can do:\n• Integrate bonus levels or secret content that players can discover by meeting specific in-game conditions.\n• Include unlockable characters, features, or levels as rewards for players’ progress, giving them a sense of accomplishment.\n• Strike a balance between difficulty and accessibility to ensure every player enjoys the additional content.\n\nIf you’re feeling adventurous and want to venture into the world of multiplayer gaming, Pygame has got your back! Follow these steps to implement multiplayer and online modes:\n• Expand game states to accommodate multiplayer interactions, such as allowing players to join or host game sessions.\n• Implement online connectivity using Pygame’s networking capabilities to enable multiplayer gameplay and leaderboards.\n• Ensure smooth synchronization between players by handling real-time updates and mitigating network latency.\n\nPhew! We’ve covered a lot of ground here, my fellow game developers! But before we wrap up, let’s reflect on the importance of managing game states and what we’ve learned throughout this exciting journey.\n\nProgram Output:\n\n The program will display different screens based on the current game state.\n\n Initially, the program will start with the MENU state and render the menu screen.\n\n Pressing the ‘1’ key will transition to the GAMEPLAY state, rendering the gameplay screen.\n\n Pressing the ‘p’ key during the gameplay will transition to the PAUSE state, rendering the pause screen.\n\n Pressing the ‘p’ key again will resume the gameplay.\n\n Pressing the ‘q’ key during the pause will quit the game.\n\n Pressing the ‘r’ key during the GAME_OVER state will transition back to the MENU state, rendering the menu screen.\n\n Pressing the ‘2’ key during the MENU state will quit the game.\n• The program starts by initializing the Pygame library and creating a window with a resolution of 800×600 pixels.\n• A GameStateManager object is created, which manages the game states and controls their transitions.\n• The start() method is called, which runs an infinite loop for the game.\n• Inside the loop, the handle_events() method is called to handle any input events such as key presses or window close.\n• Based on the current game state, the appropriate handle_*_input() method is called to handle the input.\n• In the update() method, the game logic and update functions are called based on the current game state.\n• In the render() method, the screen is cleared, and the appropriate render_*() method is called to render the current screen.\n• The quit_game() method is called to safely quit the game by closing the Pygame window and exiting the program.\n• The program also defines different render_*() methods for each game state to handle rendering of specific screens.\n\nThis program follows the State design pattern, where each game state is represented by a different object and is responsible for handling its own events, updating the game world, and rendering the screen. The GameStateManager acts as a controller, managing the current state and transitioning between states based on input events. This architecture allows for flexible and scalable game development, as adding new game states and behavior is straightforward.\n\nBy using an enumeration (GameState) to represent the different states, we ensure type safety and easy comparison when handling input events. The program utilizes object-oriented principles to organize and encapsulate the different functionalities of the game states, promoting separation of concerns and code modularity.\n\nOverall, this program provides a solid foundation for managing game states in Pygame, allowing for the creation of complex games with menus, gameplay, and additional states like pause and game over.\n\nManaging game states is an art that enables us to create captivating and immersive gaming experiences. By understanding the significance of game states, we can create seamless transitions between menus, gameplay, cutscenes, and more. Pygame provides us with a powerful arsenal of tools and capabilities to tackle game states with ease.\n\nIn this blog post, we explored the fundamentals of game states in Pygame, from designing dynamic menus to navigating through in-game states. We also delved into advanced game states like cutscenes, bonus levels, and multiplayer modes. Armed with this knowledge, you can now embark on your own game development journey and create unforgettable gaming experiences!\n\nKeep in mind that managing game states requires experimentation, creativity, and attention to detail. So start coding, embrace the challenges, and never stop refining your skills. Remember, great games are built on great game states!\n\n?️?? Thank you for joining me on this epic adventure into the realm of game states in Pygame! I hope you found this blog post insightful and inspiring. If you have any questions or would like to share your own experiences with game state management, feel free to drop a comment below. Until next time, keep coding, keep playing, and keep unlocking new levels of game development awesomeness! Happy gaming! ??\n\nRandom Fact: Did you know that Pygame originated from the PySDL project and was later renamed to Pygame to emphasize its focus on game development? This library has been powering countless games and nurturing the dreams of aspiring game developers for many years! How cool is that? ??"
    }
]