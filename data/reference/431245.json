[
    {
        "link": "https://man7.org/linux/man-pages/man2/semop.2.html",
        "document": "Pages that refer to this page: ipcs(1), lsipc(1), pcp-ipcs(1), clone(2), fork(2), ipc(2), semctl(2), semget(2), syscalls(2), unshare(2), proc_sys_kernel(5), pthreads(7), sem_overview(7), signal(7), sysvipc(7)"
    },
    {
        "link": "https://ibm.com/docs/en/zos/2.4.0?topic=functions-semop-semaphore-operations",
        "document": "The semop() function performs semaphore operations atomically on a set of semaphores associated with argument semid. The argument sops is a pointer to an array of data structures. The argument nsops is the number of structures in the array.\n\nThe structure is defined as follows:\n\nshort Semaphore number in the range 0 to (nsems - 1)\n\n short Semaphore operation\n\n short Operation flags\n\n, is represented by the following anonymous data structure. This data structure for all semaphores is updated atomically when semop() returns successfully: Number of processes waiting for to become greater than current value Number of processes waiting for to become zero Each semaphore in the semaphore set, identified by, is represented by the following anonymous data structure. This data structure for all semaphores is updated atomically when semop() returns successfully:\n\nEach semaphore operation specified by is performed on the corresponding semaphore specified by semid and .\n\nA semaphore set created with the __IPC_BINSEM flag must behave in the following manner: number of semaphore operations must be 1 and the semop must be +1 with a semval of 0 or the semop must be -1 with a semval of 0 or 1. SEM_UNDO is not allowed on a semop() with this option. The use of this flag will cause improved performance if the PLO instruction is available on the hardware."
    },
    {
        "link": "https://pubs.opengroup.org/onlinepubs/009695299/functions/semop.html",
        "document": "The semop() function operates on XSI semaphores (see the Base Definitions volume of IEEE Std 1003.1-2001, Section 4.15, Semaphore). It is unspecified whether this function interoperates with the realtime interprocess communication facilities defined in Realtime.\n\nThe semop() function shall perform atomically a user-defined array of semaphore operations on the set of semaphores associated with the semaphore identifier specified by the argument semid.\n\nThe argument sops is a pointer to a user-defined array of semaphore operation structures. The implementation shall not modify elements of this array unless the application uses implementation-defined extensions.\n\nThe argument nsops is the number of such structures in the array.\n\nEach structure, sembuf, includes the following members:\n\nEach semaphore operation specified by sem_op is performed on the corresponding semaphore specified by semid and sem_num.\n\nThe variable sem_op specifies one of three semaphore operations:\n• If sem_op is a negative integer and the calling process has alter permission, one of the following shall occur:\n• If semval(see <sys/sem.h>) is greater than or equal to the absolute value of sem_op, the absolute value of sem_op is subtracted from semval. Also, if (sem_flg &SEM_UNDO) is non-zero, the absolute value of sem_op shall be added to the calling process' semadj value for the specified semaphore.\n• If semval is less than the absolute value of sem_op and (sem_flg &IPC_NOWAIT) is non-zero, semop() shall return immediately.\n• If semval is less than the absolute value of sem_op and (sem_flg &IPC_NOWAIT) is 0, semop() shall increment the semncnt associated with the specified semaphore and suspend execution of the calling thread until one of the following conditions occurs:\n• The value of semval becomes greater than or equal to the absolute value of sem_op. When this occurs, the value of semncnt associated with the specified semaphore shall be decremented, the absolute value of sem_op shall be subtracted from semval and, if (sem_flg &SEM_UNDO) is non-zero, the absolute value of sem_op shall be added to the calling process' semadj value for the specified semaphore.\n• The semid for which the calling thread is awaiting action is removed from the system. When this occurs, errno shall be set equal to [EIDRM] and -1 shall be returned.\n• The calling thread receives a signal that is to be caught. When this occurs, the value of semncnt associated with the specified semaphore shall be decremented, and the calling thread shall resume execution in the manner prescribed in sigaction().\n• If sem_op is a positive integer and the calling process has alter permission, the value of sem_op shall be added to semval and, if (sem_flg &SEM_UNDO) is non-zero, the value of sem_op shall be subtracted from the calling process' semadj value for the specified semaphore.\n• If sem_op is 0 and the calling process has read permission, one of the following shall occur:\n• If semval is 0, semop() shall return immediately.\n• If semval is non-zero and (sem_flg &IPC_NOWAIT) is non-zero, semop() shall return immediately.\n• If semval is non-zero and (sem_flg &IPC_NOWAIT) is 0, semop() shall increment the semzcnt associated with the specified semaphore and suspend execution of the calling thread until one of the following occurs:\n• The value of semval becomes 0, at which time the value of semzcnt associated with the specified semaphore shall be decremented.\n• The semid for which the calling thread is awaiting action is removed from the system. When this occurs, errno shall be set equal to [EIDRM] and -1 shall be returned.\n• The calling thread receives a signal that is to be caught. When this occurs, the value of semzcnt associated with the specified semaphore shall be decremented, and the calling thread shall resume execution in the manner prescribed in sigaction().\n\nUpon successful completion, the value of sempid for each semaphore specified in the array pointed to by sops shall be set equal to the process ID of the calling process."
    },
    {
        "link": "https://linuxcampus.net/documentation/man-html/htmlman2/semop.2.html",
        "document": ""
    },
    {
        "link": "https://aquasecurity.github.io/tracee/v0.13/docs/events/builtin/syscalls/semop",
        "document": "Semop is a Linux system call used to perform operations on a set of semaphores. It ensures that all operations specified in the argument will either be completed or none of them will be performed at all. This call can be used for synchronization between threads or processes. The only drawback is that if the maximum number of semaphores allowed is reached, the call will fail.\n• : - ID of the set of semaphores.\n• : - pointer to an array of semaphore operations.\n• : - number of semaphores in the array.\n• OPT - Optional argument - might not always be available (passed with null value)\n\nTo gain insight to the arguments passed to semop, as well as to log any broken semaphore constraints.\n\nIf you need to synchronize between threads or processes, semop can be used to guarantee that a set of operations on a set of semaphores will either all succeed or none of them will.\n\nIf the maximum number of semaphores allowed is reached, the call will fail.\n• semget - Gets an existing semaphore set or allocate a new one.\n• semtimedop - Like , but with an additional timeout parameter.\n\nThis document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better."
    },
    {
        "link": "https://ibm.com/docs/en/zos/2.4.0?topic=functions-semget-get-set-semaphores",
        "document": "C or C++\n\nThe semget() function returns the semaphore identifier associated with key.\n\ndata structure, see <sys/sem.h>, associated with semaphores when any of the following is true:\n• Argument has a value of IPC_PRIVATE\n• Argument is not associated with a semaphore ID and ( & IPC_CREAT) is non zero. A semaphore identifier is created with adata structure, see , associated withsemaphores when any of the following is true:\n\ninclude any combination of the following defined in <sys/ipc.h> and <sys/modes.h>: Creates a semaphore if the specified does not already have an associated ID. IPC_CREATE is ignored when IPC_PRIVATE is specified. Causes the semget() function to fail if the specified has an associated ID. IPC_EXCL is ignored when IPC_CREAT is not specified or IPC_PRIVATE is specified. Binary semaphore - semaphore must behave in a binary manner: number of semaphore operations must be 1 and the semop must be 1 with a semval of 0 or the semop must be -1 with a semval of 0 or 1. SEM_UNDO is now allowed on a semop() with this option. The use of this flag will cause improved performance if the PLO instruction is available on the hardware. See z/OS XL C/C++ Programming Guide for further information on semaphore performance. This flag states that it is known that the application will only hold the resource being serialized for extremely short time intervals. When this flag is combined with the __IPC_BINSEM flag, the default first-in-first-out (FIFO) ordering of semaphore obtain requesters will be bypassed, to allow short duration requesters to successfully obtain the semaphore (and hopefully release it) within the interval it normally takes to dispatch the next pending waiter for that semaphore. Permits read access when the effective user ID of the caller matches either or . Permits write access when the effective user ID of the caller matches either or . Permits read access when the effective group ID of the caller matches either or . Permits write access when the effective group ID of the caller matches either or . Valid values for the fieldinclude any combination of the following defined in\n\nWhen a semaphore set associated with argument key already exists, setting IPC_EXCL and IPC_CREAT in argument semflg will force semget() to fail.\n\ndata structure is created the following anonymous data structure is created for each semaphore in the set: Number of processes waiting for to become greater than current value Number of processes waiting for to become zero When adata structure is created the following anonymous data structure is created for each semaphore in the set:\n\ndata structure is created:\n• The fields and are set equal to the effective user ID of the calling process.\n• The fields and are set equal to effective group ID of the calling process.\n• The low-order 9 bits of are set to the value in the low-order 9 bits of .\n• The field is set to the value of .\n• The field is set to 0.\n• The field is set to the current time.\n• The anonymous data structure containing for each semaphore is not initialized. semctl() commands SETVAL and SETALL should be used to initialize each semaphore's value. The following fields are initialized when adata structure is created:"
    },
    {
        "link": "https://ibm.com/docs/en/zos/2.4.0?topic=functions-semctl-semctl64-semaphore-control-operations",
        "document": "Compile requirement: Use of the semctl64() function requires the long long data type. For more information on how to make the long long data type available, see z/OS XL C/C++ Language Reference .\n\nThe or function performs control operations in semaphore set semid as specified by the argument cmd.\n\nDepending on the value of argument cmd, argument semnum may be ignored or identify one specific semaphore number.\n\nEach semaphore in the semaphore set is represented by the following anonymous data structure:\n\nWhen or is used to identify one specific semaphore number for commands GETVAL, SETVAL, GETPID, GETNCNT, and GETZCNT, then references are made to this anonymous data structure for the semaphore semnum.\n\nmay be specified. The level of permission required for each operation is shown with each command. These symbolic constants are defined by the < > header: Returns the value of , if the current process has read permission. Sets the value of to , where is the value of the fourth argument to or . When this command is successfully executed, the value corresponding to the specified semaphore in all processes is cleared. This command requires alter permission. For an __IPC_BINSEM semaphore set the only values that may be set are zero and one. Returns the most recent process to update the semaphore ( ), if the current process has read permission. Returns the number of threads waiting on the semaphore to become greater than the current value, if the current process has read permission. Returns the number of threads waiting on the semaphore to become zero, if the current process has read permission. For an __IPC_BINSEM semaphore set this operation will always return a zero; threads are not allowed to wait for the semaphore to become zero in this type of semaphore set. Stores for each semaphore in the semaphore set and place into the array pointed to by , where is the fourth argument to or . GETALL requires read permission. It is the caller's responsibility to ensure that the storage allocated is large enough to hold the number of semaphore elements. The number of semaphore values stored is , which may be obtained using the IPC_STAT command. Sets values for each semaphore in the semaphore set according to the array pointed to by arg.array, where is the fourth argument to or . SETALL requires alter permission. Each value must be zero or positive. When this command is successfully executed, the values corresponding to each specified semaphore in all processes are cleared. It is the caller's responsibility to ensure that the storage allocated is large enough to hold the number of semaphore elements. The number of semaphore values set is , which may be obtained using the IPC_STAT command. If __IPC_BINSEM was specified on the , this option should not be used while there is the possibility of other threads performing semaphore operations on this semaphore, as there may be no serialization while updating the semaphore values; therefore a SETALL will not be allowed after a has been done to the __IPC_BINSEM semaphore set. Also, for the __IPC_BINSEM semaphore set, the only values that may be set are zero and one. This command obtains status information for the semaphore identifier specified by . This requires read permission. This information is stored in the address specified by the fourth argument defined by data structure or . Set the value of the , , and in or data structure for the semaphore identifier specified by . These values are set to the values found in or structure pointed to by the fourth argument. Any value for and may be set. Only mode bits defined under function argument semflg may be set in . This command can only be executed by a process that has an effective user ID equal to either that of a process with appropriate privileges or to the value of or in the or structure associated with semid. Remove the semaphore identifier specified by argument from the system and free the storage for the set of semaphores in the or structure. This command can only be executed by a process that has an effective user ID equal to either that of a process with appropriate privileges or to the value of or in the or structure associated with semid. For an __IPC_BINSEM semaphore set, it is recommended that all use of should be completed before removing the semaphore ID. The following semaphore control operations as specified by argumentmay be specified. The level of permission required for each operation is shown with each command. These symbolic constants are defined by the <> header:\n\nUnion uses struct pointer as its second member instead of struct pointer."
    },
    {
        "link": "https://stackoverflow.com/questions/24421718/semaphores-in-c-linux-programming",
        "document": "I'm taking over some C code running in Linux (Centos) with extensive use of semaphores. The way the code is written :\n\nThis program launches a bunch of processes which makes use of mutexes and semaphores.\n\nThis program also launches a bunch of processes which makes use of mutexes and semaphores.\n\nI've realised that Program1 and Program2, they make use of semaphores with the same names. In Linux C programming, can different programs use the same semaphores? My guess is no, but the same naming is confusing the hell out of me. They are using the same source code to launch and handle the semaphores.\n\nThe semaphores are invoked using the following commands:\n\nsemget semctl semop I've read that these are called processes semaphores.. if Program1 creates SEMAPHORE1, can Program2 access SEMAPHORE1?\n\nAppreciate any help here, thanks!"
    },
    {
        "link": "https://docs.oracle.com/cd/E19683-01/816-5042/auto32/index.html",
        "document": "Semaphores enable processes to query or alter status information. They are often used to monitor and control the availability of system resources such as shared memory segments. Semaphores can be operated on as individual units or as elements in a set.\n\nBecause System V IPC semaphores can be in a large array, they are extremely heavy weight. Much lighter-weight semaphores are available in the threads library (see the semaphore(3THR) man page). Also, POSIX semaphores are the most current implementation of System V semaphores (see POSIX Semaphores). Threads library semaphores must be used with mapped memory (see Memory Management Interfaces).\n\nA semaphore set consists of a control structure and an array of individual semaphores. A set of semaphores can contain up to 25 elements. The semaphore set must be initialized using semget(2). The semaphore creator can change its ownership or permissions using semctl(2). Any process with permission can use semctl(2) to do control operations.\n\nSemaphore operations are performed by semop(2). This interface takes a pointer to an array of semaphore operation structures. Each structure in the array contains data about an operation to perform on a semaphore. Any process with read permission can test whether a semaphore has a zero value. Operations to increment or decrement a semaphore require write permission.\n\nWhen an operation fails, none of the semaphores are altered. The process blocks unless the flag is set, and remains blocked until:\n• The semaphore operations can all finish, so the call succeeds.\n\nOnly one process at a time can update a semaphore. Simultaneous requests by different processes are performed in an arbitrary order. When an array of operations is given by a semop(2) call, no updates are done until all operations on the array can finish successfully.\n\nIf a process with exclusive use of a semaphore terminates abnormally and fails to undo the operation or free the semaphore, the semaphore stays locked in memory in the state the process left it. To prevent this occurrence, the control flag makes semop(2) allocate an undo structure for each semaphore operation, which contains the operation that returns the semaphore to its previous state. If the process dies, the system applies the operations in the undo structures. This prevents an aborted process from leaving a semaphore set in an inconsistent state.\n\nIf processes share access to a resource controlled by a semaphore, operations on the semaphore should not be made with in effect. If the process that currently has control of the resource terminates abnormally, the resource is presumed to be inconsistent. Another process must be able to recognize this to restore the resource to a consistent state.\n\nWhen performing a semaphore operation with in effect, you must also have in effect for the call that performs the reversing operation. When the process runs normally, the reversing operation updates the undo structure with a complementary value. This ensures that, unless the process is aborted, the values applied to the undo structure are canceled to zero. When the undo structure reaches zero, it is removed.\n\nUsing inconsistently can lead to memory leaks because allocated undo structures might not be freed until the system is rebooted.\n\nsemget(2) initializes or gains access to a semaphore. When the call succeeds, it returns the semaphore ID ( ). The key argument is a value associated with the semaphore ID. The argument specifies the number of elements in a semaphore array. The call fails when is greater than the number of elements in an existing array. When the correct count is not known, supplying 0 for this argument ensures that it will succeed. The argument specifies the initial access permissions and creation control flags.\n\nThe system configuration option determines the maximum number of semaphore arrays allowed. The option determines the maximum possible number of individual semaphores across all semaphore sets. Because of fragmentation between semaphore sets, allocating all available semaphores might not be possible.\n\nsemctl(2) changes permissions and other characteristics of a semaphore set. It must be called with a valid semaphore ID. The value selects a semaphore within an array by its index. The argument is one of the following control flags.\n\nA process must have an effective user identification of owner, creator, or superuser to perform an or command. Read and write permission is required, as for the other control commands.\n\nsemop(2) performs operations on a semaphore set. The argument is the semaphore ID returned by a previous semget(2) call. The argument is a pointer to an array of structures, each containing the following information about a semaphore operation:\n• The operation to be performed\n\nThe structure specifies a semaphore operation, as defined in . The argument specifies the length of the array, the maximum size of which is determined by the configuration option. This option determines the maximum number of operations allowed by a single semop(2) call, and is set to 10 by default.\n\nThe operation to be performed is determined as follows:\n• Positive integer increments the semaphore value by that amount.\n• Negative integer decrements the semaphore value by that amount. An attempt to set a semaphore to a value less than zero fails or blocks, depending on whether is in effect.\n• Value of zero means to wait for the semaphore value to reach zero.\n\nThe two control flags that can be used with semop(2) are and ."
    },
    {
        "link": "https://stackoverflow.com/questions/72163316/system-v-semaphores-semop-in-different-function",
        "document": "I created and initialized System V semaphores with and in the main function, but the function is called in a different function. I simply passed the ids of the semaphores as parameters to that function. It looks something like this:\n\nDoes this work or should be called in the same function as and ?"
    }
]