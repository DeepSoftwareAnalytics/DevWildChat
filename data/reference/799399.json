[
    {
        "link": "https://doc.qt.io/qtforpython-5/PySide2/QtWidgets/QProgressBar.html",
        "document": "The QProgressBar widget provides a horizontal or vertical progress bar. More …\n\nA progress bar is used to give the user an indication of the progress of an operation and to reassure them that the application is still running. The progress bar uses the concept of steps . You set it up by specifying the minimum and maximum possible step values, and it will display the percentage of steps that have been completed when you later give it the current step value. The percentage is calculated by dividing the progress ( - ) divided by - . You can specify the minimum and maximum number of steps with and . The current number of steps is set with . The progress bar can be rewound to the beginning with . If minimum and maximum both are set to 0, the bar shows a busy indicator instead of a percentage of steps. This is useful, for example, when using to download items when they are unable to determine the size of the item being downloaded.\n\nSets the progress bar’s minimum and maximum values to and respectively. If is smaller than , becomes the only legal value. If the current value falls outside the new range, the progress bar is reset with . The can be set to undetermined state by using (0, 0).\n\nThis property holds the descriptive text shown with the progress bar. The text returned is the same as the text displayed in the center (or in some styles, to the left) of the progress bar. The progress shown in the text may be smaller than the minimum value, indicating that the progress bar is in the “reset” state before any progress is set. In the default implementation, the text either contains a percentage value that indicates the progress so far, or it is blank because the progress bar is in the reset state."
    },
    {
        "link": "https://doc.qt.io/qt-6/qprogressbar.html",
        "document": "The QProgressBar widget provides a horizontal or vertical progress bar. More...\n\nA progress bar is used to give the user an indication of the progress of an operation and to reassure them that the application is still running. The progress bar uses the concept of steps. You set it up by specifying the minimum and maximum possible step values, and it will display the percentage of steps that have been completed when you later give it the current step value. The percentage is calculated by dividing the progress (value() - minimum()) divided by maximum() - minimum(). You can specify the minimum and maximum number of steps with setMinimum() and setMaximum. The current number of steps is set with setValue(). The progress bar can be rewound to the beginning with reset(). If minimum and maximum both are set to 0, the bar shows a busy indicator instead of a percentage of steps. This is useful, for example, when using QNetworkAccessManager to download items when they are unable to determine the size of the item being downloaded.\n\nThis property holds the alignment of the progress bar This property holds the string used to generate the current text %p - is replaced by the percentage completed. %v - is replaced by the current value. %m - is replaced by the total number of steps. The default value is \"%p%\". This property holds whether or not a progress bar shows its progress inverted If this property is , the progress bar grows in the other direction (e.g. from right to left). By default, the progress bar is not inverted. See also orientation and layoutDirection. This property holds the progress bar's maximum value When setting this property, the minimum is adjusted if necessary to ensure that the range remains valid. If the current value falls outside the new range, the progress bar is reset with reset(). This property holds the progress bar's minimum value When setting this property, the maximum is adjusted if necessary to ensure that the range remains valid. If the current value falls outside the new range, the progress bar is reset with reset(). This property holds the orientation of the progress bar The orientation must be Qt::Horizontal (the default) or Qt::Vertical. See also invertedAppearance and textDirection. This property holds the descriptive text shown with the progress bar The text returned is the same as the text displayed in the center (or in some styles, to the left) of the progress bar. The progress shown in the text may be smaller than the minimum value, indicating that the progress bar is in the \"reset\" state before any progress is set. In the default implementation, the text either contains a percentage value that indicates the progress so far, or it is blank because the progress bar is in the reset state. This property holds the reading direction of the text for vertical progress bars This property has no impact on horizontal progress bars. By default, the reading direction is QProgressBar::TopToBottom. See also orientation and textVisible. This property holds whether the current completed percentage should be displayed This property may be ignored by the style (e.g., QMacStyle never draws the text). This property holds the progress bar's current value Attempting to change the current value to one outside the minimum-maximum range has no effect on the current value."
    },
    {
        "link": "https://build-system.fman.io/pyqt5-tutorial",
        "document": "This PyQt5 tutorial shows how to use Python 3 and Qt to create a GUI on Windows, Mac or Linux. It even covers creating an installer for your app.\n\nPyQt is a library that lets you use the Qt GUI framework from Python. Qt itself is written in C++. By using it from Python, you can build applications much more quickly while not sacrificing much of the speed of C++.\n\nPyQt5 refers to the most recent version 5 of Qt. You may still find the occasional mention of (Py)Qt4 on the web, but it is old and no longer supported.\n\nAn interesting new competitor to PyQt is Qt for Python. Its API is virtually identical. Unlike PyQt, it is licensed under the LGPL and can thus be used for free in commercial projects. It's backed by the Qt company, and thus likely the future. We use PyQt here because it is more mature. Since the APIs are so similar, you can easily switch your apps to Qt for Python later.\n\nThe best way to manage dependencies in Python is via a virtual environment. A virtual environment is simply a local directory that contains the libraries for a specific project. This is unlike a system-wide installation of those libraries, which would affect all of your other projects as well.\n\nTo create a virtual environment in the current directory, execute the following command:\n\nThis creates the folder. To activate the virtual environment on Windows, run:\n\nOn Mac and Linux, use:\n\nYou can see that the virtual environment is active by the prefix in your shell:\n\nTo now install PyQt, issue the following command:\n\nTime to write our very first GUI app! With the virtual environment still active, start Python. We will execute the following commands:\n\nFirst, we tell Python to load PyQt via the import statement:\n\nNext, we create a with the command:\n\nThis is a requirement of Qt: Every GUI app must have exactly one instance of . Many parts of Qt don't work until you have executed the above line. You will therefore need it in virtually every (Py)Qt app you write.\n\nThe brackets in the above line represent the command line arguments passed to the application. Because our app doesn't use any parameters, we leave the brackets empty.\n\nNow, to actually see something, we create a simple label:\n\nThen, we tell Qt to show the label on the screen:\n\nDepending on your operating system, this already opens a tiny little window:\n\nThe last step is to hand control over to Qt and ask it to \"run the application until the user closes it\". This is done via the command:\n\nIf all this worked as expected then well done! You've just built your first GUI app with Python and Qt.\n\nEverything you see in a (Py)Qt app is a widget: Buttons, labels, windows, dialogs, progress bars etc. Like HTML elements, widgets are often nested. For example, a window can contain a button, which in turn contains a label.\n\nThe following screenshot shows the most common Qt widgets:\n\nYou can download the code for the app shown in the screenshot here, if you are interested.\n\nLike the example above, your GUI will most likely consist of multiple widgets. In this case, you need to tell Qt how to position them. For instance, you can use QVBoxLayout to stack widgets vertically:\n\nThe code for this screenshot is:\n\nAs before, we instantiate a . Then, we create a . We use the most basic type for it because it merely acts as a container and we don't want it to have any special behavior. Next, we create the and add two s to it. Finally, we tell the window to use this layout (and thus its contents). As in our first application, we end with calls to and .\n\nThere are of course many other kinds of layouts (eg. QHBoxLayout to lay out items in a row). See Qt's documentation for an overview.\n\nOne of Qt's strengths is its support for custom styles. There are many mechanisms that let you customize the look and feel of your application. This section outlines a few.\n\nThe coarsest way to change the appearance of your application is to set the global Style. Recall the widgets screenshot above:\n\nThis uses a style called . If you use the style instead, then it looks as follows:\n\nThe available styles depend on your platform but are usually , , (Windows only) and (Mac only).\n\nIf you like a style, but want to change its colors (eg. to a dark theme), then you can use QPalette and . For example:\n\nThis changes the text color in buttons to red:\n\nFor a dark theme of the Fusion style, see here.\n\nIn addition to the above, you can change the appearance of your application via style sheets. This is Qt's analogue of CSS. We can use this for example to add some spacing:\n\nFor more information about style sheets, please see Qt's documentation.\n\nQt uses a mechanism called signals to let you react to events such as the user clicking a button. The following example illustrates this. It contains a button that, when clicked, shows a message box:\n\nThe interesting line is highlighted above: is a signal, lets us install a so-called slot on it. This is simply a function that gets called when the signal occurs. In the above example, our slot shows a message box.\n\nThe term slot is important when using Qt from C++, because slots must be declared in a special way in C++. In Python however, any function can be a slot – we saw this above. For this reason, the distinction between slots and \"normal\" functions has little relevance for us.\n\nSignals are ubiquitous in Qt. And of course, you can also define your own. This however is beyond the scope of this tutorial.\n\nYou now have the basic knowledge for creating a GUI that responds to user input. Say you've written an app. It runs on your computer. How do you give it to other people, so they can run it as well?\n\nYou could ask the users of your app to install Python and PyQt like we did above, then give them your source code. But that is very tedious (and usually impractical). What we want instead is a standalone version of your app. That is, a binary executable that other people can run on their systems without having to install anything.\n\nIn the Python world, the process of turning source code into a self-contained executable is called freezing. Although there are many libraries that address this issue – such as PyInstaller, py2exe, cx_Freeze, bbfreze, py2app, ... – freezing PyQt apps has traditionally been a surprisingly hard problem.\n\nWe will use a new library called fbs that lets you create standalone executables for PyQt apps. To install it, enter the command:\n\nThen, execute the following:\n\nThis prompts you for a few values:\n\nWhen you type in the suggested command, an empty window should open:\n\nThis is a PyQt5 app just like the ones we have seen before. Its source code is in in your current directory. But here's the cool part: We can use fbs to turn it into a standalone executable!\n\nThis places a self-contained binary in the folder of your current directory. You can send it to your friends (with the same OS as yours) and they will be able to run your app!\n\n(Please note that the free version of fbs only supports Python 3.5 or 3.6. If you have a different version, please install one of these supported Python versions or buy fbs Pro).\n\nfbs also lets you create an installer for your app via the command :\n\nFor more information on how you can use fbs for your existing application, please see this article. Or fbs's tutorial.\n\nIf you have made it this far, then big congratulations. Hopefully, you now have a good idea of how PyQt (and its various parts) can be used to write a desktop application with Python. We also saw how fbs lets you create standalone executables and installers.\n\nDue to the popularity of this article, I wrote a PyQt6 book.\n\nThe book explains in more detail how you can create your own apps. Even Phil Thompson, the creator of PyQt, read the book and said it's \"very good\". So check it out!"
    },
    {
        "link": "https://geeksforgeeks.org/pyqt5-qprogressbar-how-to-create-progress-bar",
        "document": "In this article we will see how we can create the progress bar in PyQt5. In order to create progress bar object we will use .\n\nA progress bar is a graphical control element used to visualize the progression of an extended computer operation, such as a download, file transfer, or installation. Sometimes, the graphic is accompanied by a textual representation of the progress in a percent format."
    },
    {
        "link": "https://realpython.com/python-menus-toolbars",
        "document": "When it comes to developing graphical user interface (GUI) applications with Python and PyQt, some of the most useful and versatile graphical elements that you’ll ever use are menus, toolbars, and status bars.\n\nMenus and toolbars can make your applications look polished and professional, presenting users with an accessible set of options, while status bars allow you to display relevant information about the application’s status.\n• What menus, toolbars, and status bars are\n• How to create menus, toolbars, and status bars programmatically\n• How to populate Python menu and toolbar using PyQt actions\n• How to use status bars to display status information\n\nIn addition, you’ll learn some programming best practices that you can apply when creating menus, toolbars, and status bars with Python and PyQt. If you’re new to GUI programming with PyQt, then you can check out Python and PyQt: Building a GUI Desktop Calculator.\n\nYou can download the code and resources for the sample application that you’ll build in this tutorial by clicking on the box below:\n\nA menu bar is a region of a GUI application’s main window that holds menus. Menus are pull-down lists of options that provide convenient access to your application’s options. For example, if you were creating a text editor, then you might have some of the following menus in your menu bar:\n• A File menu that provides some of the following menu options:\n• New for creating a new document\n• An Edit menu that provides some of the following menu options:\n• A Help menu that provides some of the following menu options:\n• Help Content for launching to user’s manual and help content\n• About for launching an About dialog You can also add some of these options to a toolbar. A toolbar is a panel of buttons with meaningful icons that provide fast access to the most commonly used options in an application. In your text editor example, you could add options like New, Open, Save, Copy, and Paste to a toolbar. Note: In this tutorial, you’ll develop a sample application that implements all the above menus and options. You can use this sample application as a starting point to create a text editor project. In this section, you’ll learn the basics of how to add menu bars, menus, and toolbars to your GUI applications with Python and PyQt. Before going any further, you’ll create a sample PyQt application that you’ll use throughout this tutorial. In each section, you’ll add new features and functionalities to this sample application. The application will be a main window–style application. This means that it’ll have a menu bar, a toolbar, a status bar, and a central widget. Open your favorite code editor or IDE and create a Python file called . Then add the following code to it: Now contains all the code that you need for creating your sample PyQt application. In this case, inherits from . So, you’re building a main window–style application. Note: Unfortunately, PyQt5’s official documentation has some incomplete sections. To work around this, you can check out either the PyQt4 documentation or the original Qt documentation. In the class initializer , you first call the parent class’s initializer using . Then you set the title of the window using and resize the window using . Note: If you aren’t familiar with PyQt applications and how to create them, then you can check out Python and PyQt: Building a GUI Desktop Calculator. The window’s central widget is a object that you’ll use to show messages in response to certain user actions. These messages will display at the center of the window. To do this, you call on the object with a couple of alignment flags. If you run the application from your command line, then you’ll see the following window on your screen: That’s it! You’ve created a main window–style application with Python and PyQt. You’ll use this sample application for all the upcoming examples in this tutorial. In a PyQt main window–style application, provides an empty object by default. To get access to this menu bar, you need to call on your object. This method will return an empty menu bar. The parent for this menu bar will be your main window object. Now go back to your sample application and add the following method in the definition of : This is the preferred way of creating a menu bar in PyQt. Here, the variable will hold an empty menu bar, which will be your main window’s menu bar. Note: A common practice in PyQt programming is to use local variables for objects that you won’t use or need from outside their definition method. Python garbage-collects all objects that get out of scope, so you might think that in the above example will disappear once returns. The truth is that PyQt keeps a reference to local objects such as using their ownership, or parent-child relationship. In other words, since is owned by your main window object, Python won’t be able to garbage-collect it. Another way of adding a menu bar to your PyQt applications is to create a object and then set it as the main window’s menu bar using . With this in mind, you can also write in the following way: In the above example, holds a object with the parent set to , which is the application’s main window. Once you have the menu bar object, you can use to add it to your main window. Finally, note that for this example to work, you first need to import from . In a GUI application, the menu bar will be displayed in different positions depending on the underlying operating system:\n• Windows: At the top of the application’s main window, under the title bar\n• macOS: At the top of the screen\n• Linux: Either at the top of the main window or at the top of the screen, depending on your desktop environment The final step to create a menu bar for your application is to call from the main window’s initializer : If you run your sample application with these new changes, then you won’t see the menu bar shown on the application’s main window. That’s because your menu bar is still empty. To see the menu bar on your application’s main window, you need to create some menus. That’s what you’ll learn next. Menus are pull-down lists of menu options that you can trigger by clicking them or by hitting a keyboard shortcut. There are at least three ways for adding menus to a menu bar object in PyQt:\n• appends a object ( ) to a menu bar object. It returns the action associated with this menu.\n• creates and appends a new object with the string ( ) as its title to a menu bar. The menu bar takes the ownership of the menu and the method returns the new object.\n• creates and appends a new object with an and a to a menu bar object. The menu bar takes the ownership of the menu and the method returns the new object. If you use the first option, then you need to create your custom objects first. To do that, you can use one of the following constructors: In both cases, is the that will hold the ownership of the object. You’ll typically set to the window in which you’ll use the menu. In the second constructor, will hold a string with a text that describes the menu option. Here’s how you can add File, Edit, and Help menus to the menu bar of your sample application: First, you import from . Then in , you add three menus to your menu bar using the first two variations of . The third variation requires an icon object, but you haven’t learned how to create and use icons yet. You’ll learn about how to use icons in the section Using Icons and Resources in PyQt. If you run the sample application, then you’ll see that you now have a menu bar like this: The application’s menu bar has the menus File, Edit, and Help. When you click these menus, they don’t show a pull-down list of menu options. That’s because you haven’t added menu options yet. You’ll learn how to add menu options to a menu in the section Populating Menus With Actions. Finally, note that the ampersand character ( ) that you include in the title of each menu creates underlined letters in the menu bar display. This is discussed in more detail in the section Defining Keyboard Shortcuts for Menu and Toolbar Options. A toolbar is a movable panel that holds buttons and other widgets to provide fast access to the most common options of a GUI application. Toolbar buttons can display icons, text, or both to represent the task that they perform. The base class for toolbars in PyQt is . This class will allow you to create custom toolbars for your GUI applications. When you add a toolbar to a main window–style application, the default position is at the top of the window. However, you can place a toolbar in any one of the following four toolbar areas: Toolbar areas are defined as constants in PyQt. If you need to use them, then you have to import from and then use fully qualified names just like in . There are three ways to add toolbars to your main window application in PyQt:\n• creates a new and empty object and sets its window title to . This method inserts the toolbar into the top toolbar area and returns the newly created toolbar.\n• inserts a object ( ) into the specified toolbar area ( ). If the main window already has toolbars, then is placed after the last existing toolbar. If already exists in the main window, then it will only be moved to . If you use one of the last two options, then you need to create the toolbar by yourself. To do this, you can use one of the following constructors: In both cases, represents the object that will hold the ownership of the toolbar. You’ll commonly set the toolbar ownership to the window in which you’re going to use the toolbar. In the second constructor, will be a string with the toolbar’s window title. PyQt uses this window title to build a default context menu that allows you to hide and show your toolbars. Now you can go back to your sample application and add the following method to : First, you import from . Then, in , you first create the File toolbar using with a title. Next, you create a object with the title and add it to the toolbar using without passing a toolbar area. In this case, the Edit toolbar is placed at the top toolbar area. Finally, you create the Help toolbar and place it in the left toolbar area using . The final step to make this work is to call from the initializer of : The call to inside the initializer of will create three toolbars and add them to your main window. Here’s how your application looks now: Now you have two toolbars right below the menu bar and one toolbar along the left side of the window. Each toolbar has a double dotted line. When you move the mouse over the dotted lines, the pointer changes to a hand. If you click and hold on the dotted line, then you can move the toolbar to any other position or toolbar area on the window. If you right-click a toolbar, then PyQt will show a context menu that will allow you to hide and show existing toolbars according to your needs. So far, you have three toolbars on your application’s window. These toolbars are still empty—you’ll need to add some toolbar buttons to make them functional. To do that, you can use PyQt actions, which are instances of . You’ll learn how to create actions in PyQt in a later section. For now, you’ll learn how to use icons and other resources in your PyQt applications.\n\nUsing Icons and Resources in PyQt The Qt library includes the Qt resource system, which is a convenient way of adding binary files such as icons, images, translation files, and other resources to your applications. To use the resource system, you need to list your resources in a resource collection file, or a file. A file is an file that contains the location, or path, of each resource in your file system. Suppose that your sample application has a directory containing the icons that you want to use in the application’s GUI. You have icons for options like New, Open, and so on. You can create a file containing the path to each icon: Each entry must contain the path to a resource in your file system. The specified paths are relative to the directory containing the file. In the above example, the directory needs to be in the same directory as the file. is an optional attribute that defines a short alternative name that you can use in your code to get access to each resource. Once you have the resources for your application, you can run the command-line tool targeting your file. is shipped with PyQt and must be fully functional on your Python environment once you have PyQt installed. reads a file and produces a Python module that contains the binary code for all your resources: This command will read and generate containing the binary code for each resource. You’ll be able to use those resources in your Python code by importing . Note: If something goes wrong when running , then make sure that you’re using the right Python environment. If you install PyQt in a Python virtual environment, then you won’t be able to use from outside that environment. Here’s a fragment of the code in that corresponds to your : # Created by: The Resource Compiler for PyQt5 (Qt v5.9.5) # WARNING! All changes made in this file will be lost! With in place, you can import it into your application and refer to each resource by typing a colon (:) and then either its or its path. For example, to access with its alias, you would use the access string . If you didn’t have an , you would access it by its path with the access string . If you have aliases, but for some reason you want to access a given resource by its path instead, then you might have to remove the colon from the access string in order to make this work properly. To use the icons in your actions, you first need to import your resources module: Once you’ve imported the module that contains your resources, you can use the resources in your application’s GUI. Note: Linters, editors, and IDEs may flag the above import statement as unused because your code won’t include any explicit use of it. Some IDEs may go even further and remove that line automatically. In these situations, you must override the suggestions of your linter, editor, or IDE and keep that import in your code. Otherwise, your application won’t be able to display your resources. To create an icon using the resources system, you need to instantiate , passing the alias or the path to the class constructor: In this example, you create a object with the file , which is in your resources module. This provides a convenient way of using icons and resources throughout your GUI application. Now go back to your sample application and update the last line of : # Using an icon and a title For this code to work, you first need to import from . You also need to import . In the last highlighted line, you add an icon to using from your resources module. If you run your sample application with this update, then you’ll get the following output: The application’s main window now shows an icon on its Help menu. When you click the icon, the menu shows the text . Using icons in a menu bar isn’t a common practice, but PyQt allows you to do it anyway.\n\nCreating Actions for Python Menus and Toolbars in PyQt PyQt actions are objects that represent a given command, operation, or action in an application. They’re useful when you need to provide the same functionality for different GUI components such as menu options, toolbar buttons, and keyboard shortcuts. You can create actions by instantiating . Once you’ve created an action, you need to add it to a widget to be able to use it in practice. You also need to connect your actions to some functionality. In other words, you need to connect them to the function or method that you want to run when the action is triggered. This will allow your application to perform operations in response to user actions in the GUI. Actions are quite versatile. They allow you to reuse and keep in sync the same functionality across menu options, toolbar buttons, and keyboard shortcuts. This provides a consistent behavior throughout the application. For example, users might expect the application to perform the same action when they click the Open… menu option, click the Open toolbar button, or press + on their keyboard. provides an abstraction that allows you to track the following elements:\n• The help tip on a toolbar option (tooltip)\n• The What’s This help tip\n• The help tip on a status bar (status tip)\n• The keyboard shortcut associated with options\n• The icon associated with menu and toolbar options To create actions, you need to instantiate . There are at least three general ways to do that: In all three cases, represents the object that holds the ownership of the action. This argument can be any . A best practice is to create actions as children of the window in which you’re going to use them. In the second and third constructors, holds the text that the action will display on a menu option or a toolbar button. The text of an action displays differently on menu options and toolbar buttons. For example, the text displays as Open… in a menu option and as Open in a toolbar button. In the third constructor, is a object that holds the action’s icon. This icon will be displayed on the left side of the text in a menu option. The position of the icon in a toolbar button depends on the toolbar’s property, which can take one of the following values: Follows the general style of the underlying platform You can also set the action’s text and icon using their respective setter methods, and . Note: For a complete list of properties, you can check out the documentation. Here’s how you can create some actions for your sample application using the different constructors of : # Creating action using the first constructor # Creating actions using the second constructor In , you create a few actions for your sample application. These actions will allow you to add options to the application’s menus and toolbars. Note that you’re creating actions as instance attributes, so you can access them from outside using . This way, you’ll be able to use these actions on both your menus and your toolbars. Note: In , you don’t use the third constructor of because it doesn’t make sense to use icons if you can’t see the actions yet. You’ll learn how to add icons to actions in the section Populating Toolbars With Actions. The next step is to call form the initializer of : If you run the application now, then you won’t see any change on the GUI. That’s because actions don’t get displayed until they’re added to a menu or toolbar. Note that you call before you call and because you’ll be using these actions on your menus and toolbars. If you add an action to a menu, then the action becomes a menu option. If you add an action to a toolbar, then the action becomes a toolbar button. That’s the topic for the next few sections.\n\nToolbars are a quite useful component when it comes to building GUI applications with Python and PyQt. You can use a toolbar to present your users with a quick way to get access to the most commonly used options in your application. You can also add widgets like spin boxes and combo boxes to a toolbar for allowing the user to directly modify some properties and variables from the application’s GUI. In the following few sections, you’ll learn how to add options or buttons to your toolbars using actions and also how to add widgets to a toolbar with . To add options or buttons to a toolbar, you need to call . In this section, you’ll rely on the variation of that inherits from . So, you’ll call with an action as an argument. This will allow you to share your actions between menus and toolbars. When you’re creating toolbars, you’ll commonly face the problem of deciding what options to add to them. Typically, you’ll want to add only the most frequently used actions to your toolbars. If you return to your sample application, then you’ll remember that you added three toolbars: In the File toolbar, you can add options like the following: In the Edit toolbar, you can add the following options: Normally, when you want to add buttons to a toolbar, you first select the icons that you want to use on each button. This isn’t mandatory, but it’s a best practice. Once you’ve selected the icons, you need to add them to their corresponding actions. Here’s how you can add icons to the actions of your sample application: To add icons to your actions, you update the highlighted lines. In the case of , you use . In the rest of the actions, you use the constructor with an , a , and a object as arguments. Once your selected actions have icons, you can add these actions to their corresponding toolbar by calling on the toolbar object: With this update to , you add buttons for the New, Open, and Save options to the File toolbar. You also add buttons for the Copy, Paste, and Cut options to the Edit toolbar. Note: The order in which buttons are displayed on a toolbar from left to right corresponds to the order in which you add the buttons in your code. If you run your sample application now, then you’ll get the following window on your screen: The sample application now shows two toolbars with a few buttons each. Your users can click these buttons to get quick access to the application’s most commonly used options. Note: When you first wrote back in the section Creating Toolbars, you created a Help toolbar. This toolbar was intended to show how to add a toolbar using a different variation of . In the above update of , you get rid of the Help toolbar just to keep the example short and clear. Note that, since you share the same actions between your menus and toolbars, the menu options will also display the icons on their left side, which is a big win in terms of productivity and resource use. This is one of the advantages of using PyQt actions to create menus and toolbars with Python. In some situations, you’ll find it useful to add specific widgets like spin boxes, combo boxes, or others to a toolbar. A common example of this is the combo boxes that most word processors use to allow the user to change the font of a document or the size of a selected text. To add widgets to a toolbar, you first need to create the widget, setup its properties and then call on the toolbar object passing the widget as an argument. Suppose you want to add a object to the Edit toolbar of your sample application to allow the user to change the size of something, which could be the font size. You need to update : Here, you first import the spin box class. Then you create a object, set its to , and finally add it to your Edit toolbar. Note: In the above code, you set the property of the spin box to because if this widget gets the focus, then the application’s keyboard shortcuts won’t work properly. Now, if you run the application, then you’ll get the following output: Here, the Edit toolbar shows a object that your users can use to set the size of the font or any other numeric property on your application. PyQt toolbars are quite flexible and customizable. You can set a bunch of properties on a toolbar object. Some of the most useful properties are shown in the following table: The toolbar areas in which you can place a given toolbar Whether you can drag and drop the toolbar as an independent window Whether the toolbar is an independent window The size of the icons displayed on the toolbar buttons Whether you can move the toolbar within the toolbar area or between toolbar areas The orientation of the toolbar All these properties have an associated setter method. For example, you can use to set , to set , and so on. Now, suppose you don’t want your users to move the File toolbar around the window. In this case, you can set to using : The highlighted line makes the magic here. Now your users can’t move the toolbar around the application’s window: The File toolbar doesn’t show the double dotted line anymore, so your users won’t be able to move it. Note that the Edit toolbar is still movable. You can change other properties on your toolbars using this same approach and customize them according to your needs.\n\nContext menus, also known as pop-up menus, are a special type of menu that appears in response to certain user actions, like a right-click on a given widget or window. These menus offer a small list of options that are available in a given context of the operating system or application that you’re using. For example, if you right-click the desktop of a Windows machine, then you’ll get a menu with options that corresponds to that specific context or space of the operating system. If you right-click the workspace of a text editor, then you’ll get a totally different context menu that will depend on the editor you’re using. In PyQt, you have several options for creating context menus. In this tutorial, you’ll learn about two of those options:\n• Setting the property on specific widgets to\n• Handling the context menu event on the application’s window through The first option is the most common and user-friendly of the two, so you’ll learn about it first. The second option is a little bit more complex and relies on handling user events. In GUI programming, an event is any user action on the application, like clicking a button or a menu, selecting an item from a combo box, entering or updating the text in a text field, pressing a key on the keyboard, and so on. All PyQt graphical components or widgets that derive from inherit a property called . This property controls how the widget displays a context menu. One of the most commonly used values for this property is . This makes the widget display its internal list of actions as a context menu. To make a widget display a context menu based on its internal actions, you need to run two steps:\n• Add some actions to the widget using .\n• Set to on the widget using . Setting to causes widgets that have actions to show them in a context menu. This is a really quick way to create a context menu with Python and PyQt. With this technique, you can add a context menu to the central widget of your sample application and provide your users with a way to quickly access to some of the application’s options. To do that, you can add the following method to : In , you first set to using the setter method . Then you add actions to the widget using as usual. The final step is to call from the initializer of : If you run your sample application after these additions, then you’ll see that the application’s central widget shows a context menu when you right-click on it: Now your sample application has a context menu that pops up whenever you right-click the application’s central widget. The central widget stretches to occupy all the available space in the window, so you’re not limited to right-clicking on the label text to see the context menu. Finally, since you use the same actions throughout this application, the options on the context menu show the same set of icons. An alternative way of creating context menus in PyQt is to handle the context menu event of the application’s main window. To do this, you need to run the following steps:\n• Override the event handler method, , on the object.\n• Launch the menu object using with the event’s as an argument. This way of managing context menus is a bit more complex. However, it gives you fine control over what happens when the context menu is invoked. For example, you can enable or disable menus options according to the application’s state and so on. Note: Before you go any further in this section, you need to disable the code you wrote in the previous section. To do that, just go to the initializer of and comment out the line that calls . Here’s how you can reimplement the context menu of your sample application, overriding the event handler method on the main window object: # Creating a menu object with the central widget as parent In , you first create a object ( ) with as its parent widget. Next you populate the menu with actions using . Finally, you call on the object to show it on the screen. The second argument of represents the event that the method catches. In this case, will be a right-click on the application’s central widget. In the call to , you use as an argument. This method returns the global position of the mouse pointer when the user clicks a PyQt window or a widget. The mouse position will tell where on the window to show the context menu. If you run your sample application with these new changes, then you’ll get the same result that you got in the previous section. Unlike in menus and toolbars, in context menus, you can’t use to add a separator and visually separate your menu options according to the relationship between them. When it comes to organizing context menus, you need to create a separator action: The call to on an action object will turn that action into a separator. Once you have the separator action, you need to insert it in the right place in the context menu using . If you look back to your sample application, then you might want to visually separate the options that come from the File menu from the options that come from the Edit menu. To do that, you can update : # Adding the separator to the menu In the first two highlighted lines, you create the separator action. In the third highlighted line, you add the separator action to the menu using . This will add a horizontal line between the File options and the Edit options. Here’s how your context menu looks with this addition: Now your context menu includes a horizontal line that visually separates the options that come from File from the options that come from Edit. With this, you’ve improved the visual quality of the menu and provided a better user experience.\n\nConnecting Signals and Slots in Menus and Toolbars In PyQt, you use signals and slots to provide functionality to your GUI applications. PyQt widgets emit signals every time an event such as a mouse click, a keypress, or a window resizing, occurs on them. A slot is a Python callable that you can connect to a widget’s signal to perform some actions in response to user events. If a signal and a slot are connected, then the slot will be called automatically every time the signal is emitted. If a given signal isn’t connected to a slot, then nothing will happen when the signal is emitted. To make your menu options and toolbar buttons launch some operations when the user clicks on them, you need to connect the signals of the underlying actions with some custom or built-in slots. objects can emit a variety of signals. However, the most commonly used signal in menus and toolbars is . This signal is emitted every time the user clicks a menu option or a toolbar button. To connect with a slot, you can use the following syntax: In this example, is a Python callable. In other words, can be a function, a method, a class, or an instance of a class that implements . You already have a set of actions in your sample application. Now you need to code the slots that you’ll call every time the user clicks a menu option or a toolbar button. Go to the definition of and add the following methods: # Logic for creating a new file goes here... # Logic for opening an existing file goes here... # Logic for saving a file goes here... # Logic for copying content goes here... # Logic for pasting content goes here... # Logic for cutting content goes here... # Logic for launching help goes here... # Logic for showing an about dialog content goes here... These methods will play the role of the slots of your sample application. They’ll be called every time the user clicks the corresponding menu option or toolbar button. Once you have the slots that provide the functionality, you need to connect them with the action’s signal. This way, the application will perform actions in response to the user events. To make these connections, go to the sample application and add the following method to : This method will connect all your actions’ signals with their respective slots or callbacks. With this update, your sample application will display a message on the object that you set as a central widget telling you what menu option or toolbar button was clicked. In the case of , you connect its signal with the built-in slot . This way, if you select File → Exit, then your application will close. Finally, go to the initializer of and add a call to : With this final update, you can run the application again. Here’s how all these changes work: If you click a menu option, a toolbar button, or a context menu option, then the label at the center of the application’s window shows a message indicating the action that was executed. This functionality isn’t very useful outside of a learning context, but it gives you an idea of how to make your applications perform real-world actions when the user interacts with the GUI. Finally, when you select File → Exit, the application closes because the signal of is connected to the built-in slot . As an exercise, you can try to create custom slots for the Find… and Replace… options in the Find and Replace submenu and then connect their signals to those slots to make them live. You can also experiment with the slots that you coded in this section and try to do new things with them.\n\nWhen creating menus for an application, you’ll sometimes need to populate those menus with options that are unknown at the time you create the application’s GUI. For example, the Open Recent menu in a text editor shows a list of recently opened documents. You can’t populate this menu at the time of creating the application’s GUI because every user will open different documents and there’s no way to know this information in advance. In this case, you need to populate the menus dynamically in response to user actions or the application’s state. has a signal called that you can connect to a custom slot to dynamically populate the menu object before it’s shown on the screen. To continue developing your sample application, suppose you need to create an Open Recent submenu under File and dynamically populate it with recently opened files or documents. To do this, you need to run the following steps:\n• Code a custom slot that dynamically generates the actions to populate the menu.\n• Connect the signal of the menu with the custom slot. Here’s the code for creating the submenu: In the highlighted line, you add a submenu under the File menu with the title . This submenu doesn’t have menu options yet. You need to create the actions dynamically to populate it. You can do this by coding a method to create the actions dynamically and add them to the submenu. Here’s an example that shows the general logic that you can use: # Step 1. Remove the old options from the menu # Step 3. Add the actions to the menu In , you first remove the old options, if any, from the menu using . Then you add the logic for dynamically creating and connecting the actions. Finally, you add the actions to the menu using . In the loop, you use to connect the signal with because you want to pass as an argument to . This is a quite useful technique when it comes to connecting a signal with a slot that takes extra arguments. For it to work, you need to import from . Note: The logic in the second step of this example doesn’t really load a list of recently opened files. It just creates a of five hypothetical files with the only purpose of showing a way to implement this technique. The next step is to connect the signal of to . To do that, add the following line at the end of : In the highlighted line, you connect the signal with . This ensures that your menu gets populated right before it’s shown. Now you need to code . This is the method that your application will call when your users click any of the dynamically created actions: # Logic for opening a recent file goes here... This method will update the text of the object that you use as the central widget of your sample application. Here’s how your dynamically created submenu works in practice: When your mouse pointer hovers over the Open Recent menu, the menu emits the signal. This results in a call to , which creates and connects the actions. If you click a file name, then you’ll see that the central label changes accordingly to show a message.\n\nA status bar is a horizontal panel that is usually placed at the bottom of the main window in a GUI application. Its primary purpose is to display information about the current status of the application. The status bar can also be divided into sections to show different information on each section. According to the Qt documentation, there are three types of status indicators:\n• Temporary indicators take up almost the entire status bar for a short time to display tooltip texts, menu entries, and other time-sensitive information.\n• Normal indicators take up a part of the status bar and display information that users may want to reference periodically, such as word counts in a word processor. These may be briefly hidden by temporary indicators.\n• Permanent indicators are always displayed in the status bar, even when a temporary indicator is activated. They’re used to show important information about the current mode of the application, such as when the Caps Lock key has been pressed. You can add a status bar to your main window–style application using one of the following options:\n• Call on your object. creates and returns an empty status bar for the main window.\n• Create a object, then call on your main window with the status bar object as an argument. That way, will set your status bar object as the main window’s status bar. Here you have two alternative implementations for adding a status bar to your sample application: Both implementations produce the same result. However, most of the time you’ll use the first implementation for creating your status bars. Note that for the second implementation to work, you need to import from . Add one of the above implementations to your application’s and then call in the class initializer. With these additions, when you run your application again, you’ll see a window like this: Your application now has a status bar at the bottom of its main window. The status bar is almost invisible, but if you look closely, then you’ll notice a small dotted triangle on the bottom-right corner of the window. The main purpose of a status bar is to present status information to the users of your application. To show temporary status messages in a status bar, you need to use . This method takes the following two arguments:\n• holds the number of milliseconds that the message will be shown on the status bar. If is , which is its default value, then the message remains on the status bar until you call or on the status bar. If there’s an active message on your status bar and you call with a new message, then the new message will obscure or replace the old one. Go to your sample application and add the following line to : The final line in will make your application show a message on the application’s status bar for milliseconds: When you run the application, the status bar shows the message . After milliseconds, the message disappears and the status bar gets cleared and ready to show a new status message. You can also show permanent messages on your application’s status bar. A permanent message keeps the user informed about some general state of the application. For example, in a text editor, you might want to show a permanent message with information about the text encoding of the currently opened file. To add permanent messages to your status bars, you use a object to hold the message. Then you add the label to the status bar by calling . This method permanently adds the given widget to the current status bar. The widget’s parent is set to the status bar. takes the following two arguments:\n• holds the widget object that you want to add to the status bar. Some commonly used widgets on this role are , , and .\n• is used to compute a suitable size for the widget as the status bar grows and shrinks. It defaults to , which means that the widget is going to take the minimum amount of space. Keep in mind that a permanent widget won’t be obscured or replaced by temporary messages. locates widgets at the right side of the status bar. Note: You can use not only to show permanent messages on your status bars but also to present the user with a progress bar to monitor the duration of a given operation. You can also provide buttons on the status bar to allow the user to change properties like the file encoding on a text editor. When you use these kinds of widgets on a status bar, try to stick to the most commonly used widget for the type of application that you’re developing. This way, your users will feel right at home. Say you want to turn your sample application into a text editor, and you want to add a message to the status bar that shows information about the word count of the current file. To do that, you can create a method called and then add a permanent message using and a object: # Logic for computing the word count goes here... This method adds the logic for computing the word count in the currently opened document. Now, you can show this information as a permanent message: In the last two lines, you first create a object ( ) to hold the message about the word count. To create the message, you use an f-string, in which you insert a call to to get the word count information. Then you add the label to the status bar using . In this case, you create the object as an instance attribute because the word count needs to be updated according to the changes that the user makes to the current file. If you run the application with this update, then you’ll see the word count message on the right side of the status bar: The status bar shows a message that informs the user about the word count in a hypothetical current file. The ability to present the user with permanent information or other options in the status bar is quite useful and can help you to greatly improve the user experience for your applications."
    },
    {
        "link": "https://stackoverflow.com/questions/2150966/should-i-use-qcoreapplicationprocessevents-or-qapplicationprocessevents",
        "document": "I have a method which is called from both and the main thread. this method can sometimes take a long time to do its computations in a loop so I put and this prevents the GUI from freezing. At some point I had changed for but that caused the GUI to freeze (im pretty sure thats what was fereezing it because since I put back it hasnt frozen again) Am I right to think that calling from both the main thread and QThreads can freeze the GUI?"
    },
    {
        "link": "https://stackoverflow.com/questions/34419926/how-to-make-qtgui-window-process-events-whenever-it-is-brought-forward-on-the-sc",
        "document": "I'm using for Python, and am building a gui. I had a problem a few weeks ago where I had a function outside of the gui module modifying widgets within the gui (advanced progress bar, updating strings, etc.), and those modifications were not reflected in the gui until the function that had made the changes finished running.\n\nThe solution to this was to simply call after doing whatever modifications I wanted, which would immediately update the graphics of the window.\n\nBut now I am wondering, is there a way to do this everytime the window is brought forward?\n\nLet's say I have called a function that will be modifying the progress bar, but this function takes quite a while to run. Inbetween calling the function, and the progress bar modification, the processes no events. So, it during this time, I pull up a Chrome window (or anything else), and then close it, my gui window is blank, just gray, until is called again.\n\nIs ther functionality in that allows me to detect whenever the window is brought to the front of all current windows?"
    },
    {
        "link": "https://doc.qt.io/qtforpython-5/PySide2/QtCore/QCoreApplication.html",
        "document": ""
    },
    {
        "link": "https://pythonguis.com/tutorials/multithreading-pyqt6-applications-qthreadpool",
        "document": "A common problem when building Python GUI applications is the interface \"locking up\" when attempting to perform long-running background tasks. In this tutorial, we'll cover quick ways to achieve concurrent execution in PyQt6.\n\nIf you'd like to run external programs (such as command-line utilities) from your applications, check out the Using to run external programs tutorial.\n\nApplications based on Qt (like most GUI applications) are based on events. This means that execution is driven in response to user interaction, signals, and timers. In an event-driven application, clicking a button creates an event that your application subsequently handles to produce some expected output. Events are pushed onto and taken off an event queue and processed sequentially.\n\nIn PyQt, we create an app with the following code:\n\nThe event loop starts when you call on the object and runs within the same thread as your Python code. The thread that runs this event loop — commonly referred to as the GUI thread — also handles all window communication with the host operating system.\n\nBy default, any execution triggered by the event loop will also run synchronously within this thread. In practice, this means that the time your PyQt application spends doing something, the communication with the window and the interaction with the GUI are frozen.\n\nIf what you're doing is simple, and it returns control to the GUI loop quickly, the GUI freeze will be imperceptible to the user. However, if you need to perform longer-running tasks, for example, opening and writing a large file, downloading some data, or rendering a high-resolution image, there are going to be problems.\n\nTo your user, the application will appear to be unresponsive (because it is). Because your app is no longer communicating with the OS, on macOS, if you click on your app, you will see the spinning wheel of death. And, nobody wants that.\n\nThe solution is to move your long-running tasks out of the GUI thread into another thread. PyQt provides a straightforward interface for this.\n\nTo demonstrate multi-threaded execution, we need an application to work with. Below is a minimal stub application for PyQt that will allow us to demonstrate multithreading and see the outcome in action. Simply copy and paste this into a new file and save it with an appropriate filename, like . The remainder of the code will be added to this file (there is also a complete working example at the bottom if you're impatient:\n\nRun the app as for any other Python application:\n\nYou will see a demonstration window with a number counting upwards. This count is generated by a simple recurring timer, firing once per second. Think of this as our event loop indicator (or GUI thread indicator), a simple way to let us know that our application is ticking over normally. There is also a button with the word \"DANGER!. Push it.\n\nYou'll notice that each time you push the button, the counter stops ticking, and your application freezes entirely. On Windows, you may see the window turn pale, indicating it is not responding, while on macOS, you'll get the spinning wheel of death.\n\nAvoid doing this in your code.\n\nWhat appears as a frozen interface is the main Qt event loop being blocked from processing (and responding to) window events. Your clicks on the window are still registered by the host OS and sent to your application, but because it's sat in your big ol' lump of code (calling ), it can't accept or react to them. They have to wait until your code passes control back to Qt.\n\nThe quickest and perhaps most logical way to get around this issue is to accept events from within your code. This allows Qt to continue to respond to the host OS and your application will stay responsive. You can do this easily by using the static method on the class.\n\nFor example, our long-running code could be broken down into five 1-second sleeps and insert the in between. The code for this would be:\n\nNow, when you push the DANGER! button, your app runs as before. However, now intermittently passes control back to Qt, and allows it to respond to events as normal. Qt will then accept events and handle them before returning to run the remainder of your code.\n\nThis approach works, but it's horrible for a few reasons, including the following:\n• When you pass control back to Qt, your code is no longer running. This means that whatever long-running task you're trying to do will take longer. That is definitely not what you want.\n• When you have multiple long-running tasks within your application, with each calling to keep things ticking, your application's behavior can be unpredictable.\n• Processing events outside the main event loop ( ) causes your application to branch off into handling code (e.g. for triggered slots or events) while within your loop. If your code depends on or responds to an external state, then this can cause undefined behavior.\n\nThe code below demonstrates the last point in action:\n\nIf you run this code you'll see the counter as before. Pressing DANGER! will change the displayed text to , as defined at the entry point to the method. However, if you press the \"?\" button while is still running, you'll see that the message changes. The state is being changed from outside your event loop.\n\nIf you take a step back and think about what you want to happen in your application, then you can probably sum it up with \"stuff to happen at the same time as other stuff happens\".\n\nThere are two main approaches to running independent tasks within a PyQt application:\n\nThreads share the same memory space, so they are quick to start up and consume minimal resources. The shared memory makes it trivial to pass data between threads. However, reading or writing memory from different threads can lead to race conditions or segfaults.\n\nIn a Python, there is the added issue that multiple threads are bound by the Global Interpreter Lock (GIL) — meaning non-GIL-releasing Python code can only execute in one thread at a time. However, this is not a major issue with PyQt, where most of the time is spent outside of Python.\n\nProcesses use separate memory space and an entirely separate Python interpreter. They sidestep any potential problems with Python's GIL but at the cost of slower start-up times, larger memory overhead, and complexity in sending and receiving data.\n\nProcesses in Qt are well suited to running and communicating with external programs. However, for simplicity's sake, threads are usually the best choice unless you have a good reason to use processes (see caveats later).\n\nThere is nothing stopping you from using pure Python threading or process-based approaches within your PyQt application. In the following sections, though, you'll rely on Qt's threading classes.\n\nFavor this approach in your code.\n\nQt provides a straightforward interface for running jobs or tasks in other threads, which is nicely supported in PyQt. This interface is built around two classes:\n• : The container for the work you want to perform.\n• : The method by which you pass that work to alternate threads.\n\nThe neat thing about using is that it handles queuing and executing workers for you. Other than queuing up jobs and retrieving the results, there is not much to do.\n\nTo define a custom , you can subclass the base class. Then, place the code you wish you execute within the method. The following is an implementation of our long-running job as a .\n\nGo ahead and add the following code to , above the class definition, and don't forget to import and from :\n\nExecuting our long-running job in another thread is simply a matter of creating an instance of the and passing it to our instance. It will be executed automatically.\n\nNext, import from and add the following code to the method to set up our thread pool:\n\nFinally, update the method as follows:\n\nNow, clicking the DANGER! button will create a worker to handle the (long-running) job and spin that off into another thread via thread pool. If there are not enough threads available to process incoming workers, they'll be queued and executed in order at a later time.\n\nTry it out, and you'll see that your application now handles you bashing the button with no problems.\n\nCheck what happens if you hit the button multiple times. You should see your threads executed immediately up to the number reported by . If you press the button again after there are already this number of active workers, then the subsequent workers will be queued until a thread becomes available.\n\nIf you want to pass custom data into the runner function, you can do so via , and then have access to the data via from within the slot:\n\nWe can take advantage of the fact that Python functions are objects and pass in the function to execute rather than subclassing for each runner function. In the following construction we only require a single class to handle all of our jobs:\n\nYou can now pass in any Python function and have it executed in a separate thread. Go ahead and update with the following code:\n\nNow, when you click DANGER!, the app will print to your terminal without affecting the counter.\n\nSometimes, it's helpful to be able to pass back state and data from running workers. This could include the outcome of calculations, raised exceptions, or ongoing progress (maybe for progress bars). Qt provides the signals and slots framework to allow you to do just that. Qt's signals and slots are thread-safe, allowing safe communication directly from running threads to your GUI thread.\n\nSignals allow you to emit values, which are then picked up elsewhere in your code by slot functions that have been linked with the method.\n\nBelow is a custom class defined to contain a number of example signals. Note that custom signals can only be defined on objects derived from . Since is not derived from we can't define the signals there directly. A custom to hold the signals is a quick solution:\n\nIn this code, we've defined three custom signals:\n• , which receives no data and is aimed to indicate when the task is complete.\n• , which receives a of type, value, and formatted traceback.\n• , which receives any type from the executed function.\n\nYou may not find a need for all of these signals, but they are included to give an indication of what is possible. In the following code, we're going to implement a long-running task that makes use of these signals to provide useful information to the user:\n\nYou can connect your own handler functions to the signals to receive notification of completion (or the result) of threads:\n\nYou also often want to receive status information from long-running threads. This can be done by passing in callbacks to which your running code can send the information. You have two options here:\n• Define new signals, allowing the handling to be performed using the event loop\n\nIn both cases, you'll need to pass these callbacks into your target function to be able to use them. The signal-based approach is used in the completed code below, where we pass a back as an indicator of the thread's % progress.\n\nA complete working example is given below, showcasing the custom worker together with the worker & progress signals. You should be able to easily adapt this code to any multithreaded application you develop.\n\nYou may have spotted a slight flaw in this master plan—we are still using the event loop (and the GUI thread) to process our workers' output.\n\nThis isn't a problem when we're simply tracking progress, completion, or returning metadata. However, if you have workers that return large amounts of data — e.g. loading large files, performing complex analysis and needing (large) results, or querying databases — passing this data back through the GUI thread may cause performance problems and is best avoided.\n\nSimilarly, if your application uses a large number of threads and Python result handlers, you may come up against the limitations of the GIL. As mentioned previously, when using threads execution of Python code is limited to a single thread at a time. The Python code that handles signals from your threads can be blocked by your workers and the other way around. Since blocking your slot functions blocks the event loop, this can directly impact GUI responsiveness.\n\nIn these cases, it is often better to investigate using a pure Python thread pool (e.g. concurrent futures) to keep your processing and thread-event handling further isolated from your GUI. However, note that any Python GUI code can block other Python code unless it's in a separate process."
    },
    {
        "link": "https://xingyulei.com/post/qt-threading/index.html",
        "document": "It is inevitable that some of our tasks in the program will take long time to run, leaving the user staring at a frozen screen, whether it is reading/writing a large file, searching database or syncing assets. In a production environment, these seconds can really add up for the entire team; can you imagine how many working hours are wasted when every user need to wait for, let’s say, a library tool to query the entire asset database and finally displaying them every single time.\n\nWe can surely improve the query, but that’s usually not where the bottleneck is. The speed of querying is usually sufficient for human brain to process. What we want is not to be slow down by un-interactive GUI. So, why not have assets to fill little by little in a continuous stream, or just query their name first, and use a separate thread to load in rest of the information like date created, author and thumbnail.\n\nNow, let’s get straight to the point. I’m going to show three basic examples of different methods to deal with frozen GUI, each has its own use cases.\n\nHere I created a simple example to show how a long-running task can block controls in our Qt Gui.\n\nThe is simply a that will halt for 2 seconds util returning control back to the main event loop.\n\nAfter evoking the method, we can no longer interact with the line edit from our UI, until the task has finished.\n\nUsing can achieve a semi-interactive GUI during a long-running task. Here’s to show what I meant.\n\nAnd now, by evoking the static method during the long-running task, we enforce Qt to handle normal events like updating GUI, and respond to our user input, before handing the control back to the task.\n\nNow, as we can see, our main GUI can update the progress bar and messages, and even allow us to sort of interact with the line edit, but the interaction is by no means smooth.\n\nBefore we create a real multi-threading solution, first, let’s establish a signal slot workflow that Qt provides: instead of updating the progress bar and status bar by calling its method directly, we emit a signal to handle that.\n\nInstead of directly subclassing , it is recommended by many to create a and attach it to a . The we created, known as the worker, will be running our long-running task, and emits the update signals.\n\nIt is important to keep a note that, the that houses our worker needs to live in the main event loop (i.e. kept in the main application as ). If not, it will be collected by gc and the thread will exit pre-maturely.\n\nis also essential if the worker doesn’t live in the main event loop (i.e. ).\n\nNow as we can see, we can freely interact with the line edit while the long-running task is handled in the background.\n\nA natural progression would be handling multiple long-running tasks, luckily, we have for that.\n\nIn the following example, we have three long-running task in the background, while we still have free control of the main GUI.\n• manages , which doesn’t have built-in signals, thus we need to attach signals externally by creating a to store them.\n• also deletes the instances automatically when it finishes by default.\n• if max thread is exceeded, the process is queued until a thread is available.\n\nMaya’s Programming & Electronics Blog - How To Really, Truly Use QThreads; The Full Explanation"
    }
]