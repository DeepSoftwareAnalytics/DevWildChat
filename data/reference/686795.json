[
    {
        "link": "https://cplusplus.com/doc/tutorial/files",
        "document": "std; main () { ofstream myfile ( ); (myfile.is_open()) { myfile << ; myfile << \"This is another line.\n\n\" ; myfile.close(); } cout << ; 0; }\n\n[file example.txt] This is a line. This is another line."
    },
    {
        "link": "https://geeksforgeeks.org/file-handling-c-classes",
        "document": "File handling is used to store data permanently in a computer. Using file handling we can store our data in secondary memory (Hard disk).\n\nHow to achieve the File Handling\n\nFor achieving file handling we need to follow the following steps:-\n\n STEP 1-Naming a file\n\n STEP 2-Opening a file\n\n STEP 3-Writing data into the file\n\n STEP 4-Reading data from the file\n\n STEP 5-Closing a file.\n\nWe give input to the executing program and the execution program gives back the output. The sequence of bytes given as input to the executing program and the sequence of bytes that comes as output from the executing program are called stream. In other words, streams are nothing but the flow of data in a sequence.\n\nThe input and output operation between the executing program and the devices like keyboard and monitor are known as “console I/O operation”. The input and output operation between the executing program and files are known as “disk I/O operation”.\n\nThe I/O system of C++ contains a set of classes which define the file handling methods. These include ifstream, ofstream and fstream classes. These classes are derived from fstream and from the corresponding iostream class. These classes, designed to manage the disk files, are declared in fstream and therefore we must include this file in any program that uses files. File handling is essential for data storage and retrieval in applications.\n• None This class is the base class for other classes in this class hierarchy.\n• None This class contains the necessary facilities that are used by all the other derived classes for input and output operations.\n• None This class is derived from the class ‘ios’.\n• None The extraction operator(>>) is overloaded in this class to handle input streams from files to the program execution.\n• None This class declares input functions such as get(), getline() and read().\n• None This class is derived from the class ‘ios’.\n• None The insertion operator(<<) is overloaded in this class to handle output streams to files from the program execution.\n• None This class declares output functions such as put() and write().\n• None This class contains a pointer which points to the buffer which is used to manage the input and output streams.\n• None This class provides operations common to the file streams. Serves as a base for fstream, ifstream and ofstream class.\n• None This class contains open() and close() function.\n• None It contains open() function with default input mode.\n• None Inherits the functions get(), getline(), read(), seekg() and tellg() functions from the istream.\n• None It contains open() function with default output mode.\n• None Inherits the functions put(), write(), seekp() and tellp() functions from the ostream.\n• None This class provides support for simultaneous input and output operations.\n• None Inherits all the functions from istream and ostream classes through iostream.\n• None Its purpose is to set the file buffers to read and write.\n• None We can also use file buffer member function to determine the length of the file. \n\n\n\nIn C++, files are mainly dealt by using three classes fstream, ifstream, ofstream available in fstream headerfile. \n\nofstream: Stream class to write on files \n\nifstream: Stream class to read from files \n\nfstream: Stream class to both read and write from/to files.\n\nNow the first step to open the particular file for read or write operation. We can open file by \n\n1. passing file name in constructor at the time of object creation \n\n2. using the open method\n\nBoth ios::app and ios::ate take us to the end of the file when it is opened. The difference between the two modes is that ios :: app allow us to add data to the end of the file only, while ios :: ate mode permits us add data or to modify the existing data anywhere in the file.\n\nProblem Statement : To read and write a File in C++. \n\nExamples:\n\nBelow is the implementation by using ifstream & ofstream classes.\n\nBelow is the implementation by using fstream class."
    },
    {
        "link": "https://tutorialspoint.com/cplusplus/cpp_files_streams.htm",
        "document": "So far, we have been using the iostream standard library, which provides cin and cout methods for reading from standard input and writing to standard output respectively.\n\nThis tutorial will teach you how to read and write from a file. This requires another standard C++ library called fstream, which defines three new data types −\n\nTo perform file processing in C++, header files <iostream> and <fstream> must be included in your C++ source file.\n\nA file must be opened before you can read from it or write to it. Either ofstream or fstream object may be used to open a file for writing. And ifstream object is used to open a file for reading purpose only.\n\nFollowing is the standard syntax for open() function, which is a member of fstream, ifstream, and ofstream objects.\n\nHere, the first argument specifies the name and location of the file to be opened and the second argument of the open() member function defines the mode in which the file should be opened.\n\nYou can combine two or more of these values by ORing them together. For example if you want to open a file in write mode and want to truncate it in case that already exists, following will be the syntax −\n\nSimilar way, you can open a file for reading and writing purpose as follows −\n\nWhen a C++ program terminates it automatically flushes all the streams, release all the allocated memory and close all the opened files. But it is always a good practice that a programmer should close all the opened files before program termination.\n\nFollowing is the standard syntax for close() function, which is a member of fstream, ifstream, and ofstream objects.\n\nWhile doing C++ programming, you write information to a file from your program using the stream insertion operator (<<) just as you use that operator to output information to the screen. The only difference is that you use an ofstream or fstream object instead of the cout object.\n\nYou read information from a file into your program using the stream extraction operator (>>) just as you use that operator to input information from the keyboard. The only difference is that you use an ifstream or fstream object instead of the cin object.\n\nFollowing is the C++ program which opens a file in reading and writing mode. After writing information entered by the user to a file named afile.dat, the program reads information from the file and outputs it onto the screen −\n\nWhen the above code is compiled and executed, it produces the following sample input and output −\n\nAbove examples make use of additional functions from cin object, like getline() function to read the line from outside and ignore() function to ignore the extra characters left by previous read statement.\n\nBoth istream and ostream provide member functions for repositioning the file-position pointer. These member functions are seekg (\"seek get\") for istream and seekp (\"seek put\") for ostream.\n\nThe argument to seekg and seekp normally is a long integer. A second argument can be specified to indicate the seek direction. The seek direction can be ios::beg (the default) for positioning relative to the beginning of a stream, ios::cur for positioning relative to the current position in a stream or ios::end for positioning relative to the end of a stream.\n\nThe file-position pointer is an integer value that specifies the location in the file as a number of bytes from the file's starting location. Some examples of positioning the \"get\" file-position pointer are −"
    },
    {
        "link": "https://stackoverflow.com/questions/67631098/what-is-the-difference-between-ifstream-ofstream-and-fstream",
        "document": "This is how the class hierarchy looks like:\n\nThe three classes that deal with file handling are:\n\n, and are \" \" template specializations which means they are nothing but , and i.e. they deal with reading and writing s from a file.\n• is input file stream which allows you to read the contents of a file.\n• is output file stream which allows you to write contents to a file.\n• allows both reading from and writing to files by default. However, you can have an behave like an or by passing in the flag.\n\nThese flags are additive which means you can combine multiple flags using the bitwise OR operator. If I want to open the file in binary mode and append, I can combine the flags as follows:\n• always has the flag set and it cannot be removed. Similary, always has the flag set and it cannot be removed. Any other flags added will be combined with for and for\n• On the other hand, if you do not pass any flags to , the default is , so you can read from as well as write to the file. But if you specify a flag explicitly for like , it will be opened only for reading, like an .\n\nYou can do so in the constructor or when calling :\n\nIt is basically possible to never use and and always use with the required flags. But it is prone to accidental errors while setting the flags. Hence, using you can be sure that writes will never occur and with only writes will take place.\n\nC++ 23 adds the flag which opens a file exclusively for writing. This flag already existed in some implementations but is now standardized in C++ 23. If the file already exists, it fails to open."
    },
    {
        "link": "https://simplilearn.com/tutorials/cpp-tutorial/ifstream-in-cpp",
        "document": ""
    },
    {
        "link": "https://stackoverflow.com/questions/41005659/dynamic-and-static-array",
        "document": "I am studying C++ reading Stroustrup's book that in my opinion is not very clear in this topic (arrays). From what I have understood C++ has (like Delphi) two kind of arrays:\n\nStatic arrays that are declared like\n\nI have already seen answers about this (and there were tons of lines and concepts inside) but they didn't clarify me the concept.\n\nFrom what I have understood s consume more memory but they can change their size (dynamically, in fact). Arrays instead have a fixed size that is given at compile time.\n\nIn the chapter Stroustrup said that vectors are safe while arrays aren't, whithout explaining the reason. I trust him indeed, but why? Is the reason safety related to the location of the memory? (heap/stack)\n\nI would like to know why I am using vectors if they are safe."
    },
    {
        "link": "https://algocademy.com/link?problem=static-arrays&lang=cpp&solution=1",
        "document": "Size Of Islands in C++\n\nSize Of Islands in C++\n\nNumber Of Islands in C++\n\nNumber Of Islands in C++\n\nBest Time To Buy Stock in C++\n\nBest Time To Buy Stock in C++\n\nNon Overlapping Intervals in C++\n\nNon Overlapping Intervals in C++\n\nBest Time To Buy Stock in C++\n\nBest Time To Buy Stock in C++\n\nBest Time To Buy Stock in C++\n\nBest Time To Buy Stock in C++\n\nPermutations With K Inversions in C++\n\nPermutations With K Inversions in C++\n\nBinary Strings With At Most K Consecutive Ones in C++\n\nBinary Strings With At Most K Consecutive Ones in C++\n\nBinary Strings With K Ones On Even Positions in C++\n\nBinary Strings With K Ones On Even Positions in C++\n\nBinary Strings With K Ones in C++\n\nBinary Strings With K Ones in C++\n\nBinary Strings Without Consecutive Ones in C++\n\nBinary Strings Without Consecutive Ones in C++\n\nPermutations Of Given Length in C++\n\nPermutations Of Given Length in C++\n\nBinary Strings Of Given Length in C++\n\nBinary Strings Of Given Length in C++\n\nRecover Tree From Preorder in C++\n\nRecover Tree From Preorder in C++\n\nKth Smallest Element In Bst in C++\n\nKth Smallest Element In Bst in C++\n\nConvert Sorted Array To Bst in C++\n\nConvert Sorted Array To Bst in C++\n\nLca In Bst in C++\n\nLca In Bst in C++\n\nLargest Rectangle In Histogram in C++\n\nLargest Rectangle In Histogram in C++\n\nNext Greater Element in C++\n\nNext Greater Element in C++\n\nMinimum Number Of Boats in C++\n\nMinimum Number Of Boats in C++\n\nLast Stone Weight in C++\n\nLast Stone Weight in C++\n\nSubarray Of Given Sum Ii in C++\n\nSubarray Of Given Sum Ii in C++\n\nLongest Subarray Without Reapeating in C++\n\nLongest Subarray Without Reapeating in C++\n\nLongest Subarray With At Most K Distinct Integers in C++\n\nLongest Subarray With At Most K Distinct Integers in C++\n\nLongest Subarray With Sum At Most S in C++\n\nLongest Subarray With Sum At Most S in C++\n\nTwo Pointers Technique in C++\n\nTwo Pointers Technique in C++\n\nAdd Two Numbers in C++\n\nAdd Two Numbers in C++\n\nIntersection Of Two Linked Lists in C++\n\nIntersection Of Two Linked Lists in C++\n\nRemove Duplicates From Sorted Linked List in C++\n\nRemove Duplicates From Sorted Linked List in C++\n\nRemove Nth Node From End Of List in C++\n\nRemove Nth Node From End Of List in C++\n\nGenerate Binary Strings With K Ones in C++\n\nGenerate Binary Strings With K Ones in C++\n\nThe Factory in C++\n\nThe Factory in C++\n\nThe Factory in C++\n\nThe Factory in C++\n\nTwo Sum in C++\n\nTwo Sum in C++\n\nNumber Of Occurrences in C++\n\nNumber Of Occurrences in C++\n\nLongest Subarray With At Most K Distinct Integers in C++\n\nLongest Subarray With At Most K Distinct Integers in C++\n\nLongest Subarray Without Reapeating in C++\n\nLongest Subarray Without Reapeating in C++\n\nRemove Duplicates From Array in C++\n\nRemove Duplicates From Array in C++\n\nTwo Sum in C++\n\nTwo Sum in C++\n\nCollection Of Numbers in C++\n\nCollection Of Numbers in C++\n\nContainer With Most Water in C++\n\nContainer With Most Water in C++\n\nTwo Sum in C++\n\nTwo Sum in C++\n\nMax Sum Of Three Subarrays in C++\n\nMax Sum Of Three Subarrays in C++\n\nMax Sum Of Three Subarrays in C++\n\nMax Sum Of Three Subarrays in C++\n\nMax Sum Of Three Subarrays in C++\n\nMax Sum Of Three Subarrays in C++\n\nSubarray Of Given Sum in C++\n\nSubarray Of Given Sum in C++\n\nLongest Subarray With Sum At Most S in C++\n\nLongest Subarray With Sum At Most S in C++\n\nMaximum Sum Subarray Of Length K in C++\n\nMaximum Sum Subarray Of Length K in C++\n\nMaximum Sum Subarray Of Length K in C++\n\nMaximum Sum Subarray Of Length K in C++\n\nMax Sum Of Three Subarrays in C++\n\nMax Sum Of Three Subarrays in C++\n\nRemove Duplicates From Array in C++\n\nRemove Duplicates From Array in C++\n\nLongest Subarray Without Reapeating in C++\n\nLongest Subarray Without Reapeating in C++\n\nRemove Duplicates From Array in C++\n\nRemove Duplicates From Array in C++\n\nTwo Sum in C++\n\nTwo Sum in C++\n\nPrint Triangle Of Stars in C++\n\nPrint Triangle Of Stars in C++\n\nIntro To Strings in C++\n\nIntro To Strings in C++\n\nMax Val And Number Of Occurrences in C++\n\nMax Val And Number Of Occurrences in C++\n\nGet Full Names 2 in C++\n\nGet Full Names 2 in C++\n\nLongest Common Prefix Of Two Strings in C++\n\nLongest Common Prefix Of Two Strings in C++\n\nIntroduction To Logarithm in C++\n\nIntroduction To Logarithm in C++\n\nContinue In For Loops in C++\n\nContinue In For Loops in C++\n\nBreak In For Loops in C++\n\nBreak In For Loops in C++\n\nGet Full Names in C++\n\nGet Full Names in C++\n\nLooping Through Arrays With Indices in C++\n\nLooping Through Arrays With Indices in C++\n\nOdd Even in C++\n\nOdd Even in C++\n\nMax In Array in C++\n\nMax In Array in C++\n\nSum Of Squares in C++\n\nSum Of Squares in C++\n\nSum Of Numbers in C++\n\nSum Of Numbers in C++\n\nBuggy Code Check For Positive Numbers in C++\n\nBuggy Code Check For Positive Numbers in C++\n\nArray Contains in C++\n\nArray Contains in C++\n\nPrint Even Odd in C++\n\nPrint Even Odd in C++\n\nBuggy Code Print Even Numbers in C++\n\nBuggy Code Print Even Numbers in C++\n\nPrint Positive Numbers From Array in C++\n\nPrint Positive Numbers From Array in C++\n\nInfinite For Loops in C++\n\nInfinite For Loops in C++\n\nLooping In Reverse in C++\n\nLooping In Reverse in C++\n\nThe For Loop in C++\n\nThe For Loop in C++\n\nInfinite While Loops in C++\n\nInfinite While Loops in C++\n\nThe While Loop in C++\n\nThe While Loop in C++\n\nWhy Loops in C++\n\nWhy Loops in C++\n\nInfinite For Loops 2 in C++\n\nInfinite For Loops 2 in C++\n\nBuggy Code For Loops Execution Flow 3 in C++\n\nBuggy Code For Loops Execution Flow 3 in C++\n\nBuggy Code For Loops Execution Flow 2 in C++\n\nBuggy Code For Loops Execution Flow 2 in C++\n\nBuggy Code For Loops Execution Flow 1 in C++\n\nBuggy Code For Loops Execution Flow 1 in C++\n\nExercise Create A For Loop in C++\n\nExercise Create A For Loop in C++\n\nBuggy Code For Loops 2 in C++\n\nBuggy Code For Loops 2 in C++\n\nBuggy Code For Loops 1 in C++\n\nBuggy Code For Loops 1 in C++\n\nLooping Through Arrays in C++\n\nLooping Through Arrays in C++\n\nWhy For Loops in C++\n\nWhy For Loops in C++\n\nSecond Largest Value in C++\n\nSecond Largest Value in C++\n\nMinimum Value Of Three in C++\n\nMinimum Value Of Three in C++\n\nNested Vs Chained Conditionals in C++\n\nNested Vs Chained Conditionals in C++\n\nNot Operator in C++\n\nNot Operator in C++\n\nOr Operator in C++\n\nOr Operator in C++\n\nAllow To Contest in C++\n\nAllow To Contest in C++\n\nReducing If Else To Boolean Expression in C++\n\nReducing If Else To Boolean Expression in C++\n\nAnd Operator in C++\n\nAnd Operator in C++\n\nParity Of Number in C++\n\nParity Of Number in C++\n\nRedundant Else Statement in C++\n\nRedundant Else Statement in C++\n\nIs Number Negative in C++\n\nIs Number Negative in C++\n\nIf Else in C++\n\nIf Else in C++\n\nIf Statements in C++\n\nIf Statements in C++\n\nLast Two Digit Sum in C++\n\nLast Two Digit Sum in C++\n\nYour First Challenge in C++\n\nYour First Challenge in C++\n\nBuggy Code Return Instead Of Print in C++\n\nBuggy Code Return Instead Of Print in C++\n\nQuiz Return Instead Of Print in C++\n\nQuiz Return Instead Of Print in C++\n\nBuggy Code Print Instead Of Return in C++\n\nBuggy Code Print Instead Of Return in C++\n\nQuiz Print Instead Of Return in C++\n\nQuiz Print Instead Of Return in C++\n\nReturning From A Function in C++\n\nReturning From A Function in C++\n\nExercise Create Function With Parameters in C++\n\nExercise Create Function With Parameters in C++\n\nWhy Parameters And Arguments in C++\n\nWhy Parameters And Arguments in C++\n\nBuggy Code Non Existing Variable in C++\n\nBuggy Code Non Existing Variable in C++\n\nFunction Parameters And Arguments in C++\n\nFunction Parameters And Arguments in C++\n\nWhy Functions in C++\n\nWhy Functions in C++\n\nBuggy Code Call Before Definition in C++\n\nBuggy Code Call Before Definition in C++\n\nQuiz Defining Without Calling in C++\n\nQuiz Defining Without Calling in C++\n\nIncrement And Decrement Operators in C++\n\nIncrement And Decrement Operators in C++\n\nConvert Hours And Mins Into Seconds in C++\n\nConvert Hours And Mins Into Seconds in C++\n\nPrice After Discount in C++\n\nPrice After Discount in C++\n\nArea Of Rectangle in C++\n\nArea Of Rectangle in C++\n\nThe Power Of Variables in C++\n\nThe Power Of Variables in C++\n\nStrings Vs Numbers in C++\n\nStrings Vs Numbers in C++\n\nName Errors in C++\n\nName Errors in C++\n\nIntroduction To Strings in C++\n\nIntroduction To Strings in C++\n\nWelcome To C++\n\nWhen we're dealing with large amounts of data, we want to make sure we can organize and manage it properly. In C++, we use arrays to store several pieces of data in one place. The items in an array must be of the same data type. A static array or fixed array is an array for which the size / length is determined when the array is created and/or allocated. We create a static array by writing the data type of its elements, followed by the array's name and the array's length inside : \n\n In this program we created an array named that consists of 5 items. These 5 items are (no value given yet) initially. There is a way to initialize an array at creation by using the operator with an opening bracket, end it with a closing bracket, and put a comma between each entry, like this: \n\n We created an array named which consits of 3 string items: , and . Assignment\n\nFollow the Coding Tutorial and let's play with some arrays. Hint\n\n Look at the examples above if you get stuck.\n\nIn this lesson, we will explore the concept of static arrays in C++. Static arrays are a fundamental data structure that allows us to store multiple items of the same data type in a single, contiguous block of memory. Understanding static arrays is crucial for efficient data management and manipulation in programming.\n\nStatic arrays are particularly useful in scenarios where the size of the data set is known beforehand and does not change during the execution of the program. They are commonly used in applications such as data processing, game development, and system programming.\n\nBefore diving into the details of static arrays, let's understand some fundamental concepts:\n• Array: An array is a collection of elements, all of the same data type, stored in contiguous memory locations.\n• Static Array: A static array is an array with a fixed size, determined at the time of its creation. The size cannot be changed during the program's execution.\n\nHere is a simple example to illustrate these concepts:\n\nIn this example, we declared a static array named that can hold 5 integer values. Initially, the elements of the array are uninitialized.\n\nLet's delve deeper into the key concepts and techniques involved in working with static arrays:\n• Declaration: To declare a static array, specify the data type, array name, and size in square brackets.\n• Initialization: You can initialize an array at the time of declaration using curly braces and comma-separated values.\n• Accessing Elements: Access elements of the array using the index, starting from 0.\n\nHere is an example demonstrating these concepts:\n\nIn this example, we declared and initialized a static array named with 5 integer values. We then accessed and printed the first and second elements of the array.\n\nLet's explore some examples and use cases where static arrays are beneficial:\n\nIn the first example, we used a static array to store student grades. In the second example, we stored names in a static array. These examples demonstrate how static arrays can be used to manage and access data efficiently.\n\nWhen working with static arrays, it's important to be aware of common pitfalls and follow best practices:\n• Out-of-Bounds Access: Accessing elements outside the array's bounds can lead to undefined behavior. Always ensure the index is within the valid range.\n• Initialization: Initialize arrays to avoid using uninitialized values, which can cause unexpected results.\n• Size Management: Be mindful of the array size and avoid hardcoding values. Use constants or variables to define array sizes.\n• Multidimensional Arrays: Static arrays can have multiple dimensions, allowing you to create matrices or tables.\n• Pointer Arithmetic: You can use pointers to navigate and manipulate array elements efficiently.\n\nHere is an example of a multidimensional array:\n\nIn this example, we created a 2x3 matrix using a multidimensional array and accessed specific elements.\n\nLet's implement a complete program that demonstrates the use of static arrays:\n\nIn this program, we declared and initialized a static array named with 5 integer values. We then used a loop to access and print each element of the array.\n\nWhen working with static arrays, debugging and testing are essential to ensure correctness:\n• Debugging: Use debugging tools to step through the code and inspect array values. Check for out-of-bounds access and uninitialized values.\n• Testing: Write test cases to verify the behavior of functions that use static arrays. Test edge cases and boundary conditions.\n\nHere is an example of a simple test case:\n\nIn this example, we wrote a test case to verify the values of a static array. The statements ensure that the array elements have the expected values.\n\nHere are some strategies for approaching problems related to static arrays:\n• Break Down Problems: Divide complex problems into smaller, manageable parts. Focus on solving each part individually.\n• Practice: Solve coding exercises and projects that involve static arrays. Practice helps reinforce your understanding and improves problem-solving skills.\n\nIn this lesson, we covered the key concepts and techniques related to static arrays in C++. We explored their creation, initialization, and usage, along with examples and best practices. Understanding static arrays is essential for efficient data management and manipulation in programming.\n\nWe encourage you to practice and explore further applications of static arrays to strengthen your understanding and skills.\n\nFor further reading and practice problems related to static arrays, check out the following resources:"
    },
    {
        "link": "https://labex.io/tutorials/c-how-to-manage-static-array-boundaries-431175",
        "document": "Introduction to Static Arrays in C\n\nIn C programming, static arrays are fundamental data structures that provide a way to store multiple elements of the same type in contiguous memory locations. Understanding their basic characteristics is crucial for efficient memory management and data manipulation.\n• Allocated in the stack or data segment\n• Size must be known at compile-time\n• Always initialize arrays before use\n\nWhen practicing array manipulation, LabEx provides interactive coding environments that help you understand these concepts through hands-on experience."
    },
    {
        "link": "https://modernescpp.com/index.php/c-core-guidelines-bounds-safety",
        "document": "Today’s post concerns the second C++ Core Guidelines: Bounds Safety profile. The goal of the profile bounds safety is that you operate inside the bounds of allocated memory.\n\nThe profile names the two enemies for bounds safety: pointer arithmetic and array indexing. Additionally, when you use a pointer, it should only address a single object but not an array. To complete the profile bounds safety, you should combine it with the rules to type safety and lifetime safety. Type safety was the topic of my two previous posts: C++ Core Guidelines: Type Safety and C++ Core Guidelines: Type Safety by Design. Lifetime safety will be the topic of my next post.\n• Bounds.2: The only index into arrays using constant expressions\n• Bounds.4: Don’t use standard-library functions and types that are not bounds-checked\n\nThe four rules to bounds safety mention three rules of the C++ core guidelines. As in the last posts to the profiles, I will make my additions if necessary.\n\nBounds.1: Don’t use pointer arithmetic, Bounds.2: Only index into arrays using constant expressions and Bounds.3: No array-to-pointer decay\n\nThe reason for the three rules boils down to the three do’s: pass pointers to single objects (only), keep pointer arithmetic simple, and use std::span. The first do can also be formulated negatively: don’t pass pointers to arrays. I assume you don’t know std::span. std::span<T> represents a non-owning range of contiguous memory. This range can be an array, a pointer with a size, or a std::vector.\n\nLet me cite the words of the guidelines: “Complicated pointer manipulation is a major source of errors.”. Why should we care? Of course, our legacy code is full of functionality, such as this example:\n\nThe main issue with this code is that the caller must provide the correct length of the C-array. If not, we get undefined behavior.\n\nThink about the last lines (1) and (2) for a few seconds. We start with an array and remove its type information by passing it to the function f. This process is called an array to pointer decay and is the reason for many errors. Maybe we had a bad day, and we counted the number of elements wrong, or the size of the C-array changed. Anyway, the result is the same: undefined behavior. The same argumentation will also hold for a C-string.\n\nWhat should we do? We should use a suitable data type. C++20 supports std::span. Have a look here:\n\nBut I hear your complaints: We don’t have C++20. No problem. It’s pretty easy to rewrite the functions f using the container std::array and the method std::array::at. Here we are:\n\nThe std::array::at operator will check at runtime its bounds. If pos >= size(), you will get an std::out_of_range exception. Looking carefully at the spanVersusArray.cpp program, you will notice two issues. First, the expression (1) is more verbose than the std::span version, and second, the size of the std::array is part of the signature of the function f. This isn’t good. I can only use f with the type std::array<int, 100>. In this case, the checks of the array size inside the function are superfluous.\n\nTo your rescue, C++ has templates; therefore, overcoming the type restrictions is easy but staying type-safe.\n\nNow, the function f works for std::array‘s of different sizes and types (lines (1) and (2)) but also for a std::vector (3) or a std::string (4). These containers have in common that their data is stored in a contiguous memory block. This will no hold std::deque; therefore, the call a.data() in expression (6) fails. A std::deque is a kind of doubly-linked list of small memory blocks.\n\nThe expression T::value_type (5) helps me get each container’s underlying value type. T is a so-called dependent type because T is a type parameter of the function template f. This is the reason I have to give the compiler a hint that T::value_type is a type: typename T::value_type.\n\nBounds.4: Don’t use standard-library functions and types that are not bounds-checked\n\nI have already written a post C++ Core Guidelines: Avoid Bounds Errors. This post gives background information to this rule and provides do’s.\n\nThe name of the third profile is Lifetime Safety Profile. This profile which is the topic of my next post, boils down to one rule: Don’t dereference a possibly invalid pointer."
    },
    {
        "link": "https://stackoverflow.com/questions/189892/best-practices-for-handling-variable-size-arrays-in-c-c",
        "document": "For C++, using std::vector\n\nThere's no real point in using a C-array. The std::vector has (almost) the same performance as a C array, and it will:\n• verify you are really accessing the right memory (i.e. it could throw an exception if you go beyond its bounds)\n\nAnd this is not even considering the generic algorithm associated with the std::vector.\n\nNow, using C\n\nYou can write it somewhat better at least in two ways. First, replacing a define with a true constant variable:\n\nUsing a true variable will offer your somewhat more type safety, and won't pollute the global scope. To minimize dependancies, you can even declare the variables in the header, and define them in a source:\n\nThis way, you'll be able to change the size of the array in one source, without needing recompilation of all the sources using it. The downside is that MAXPLAYERS is not anymore known at compile time (but, is this really a downside?)\n\nNote that your second type of array cannot grow dynamically. The sizeof is (at least in C++) evaluated at compile time. For growing arrays, malloc/realloc/free is the way to go in C, and std::vector (or any other generic STL container) is the way to go in C++."
    }
]