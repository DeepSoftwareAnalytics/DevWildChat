[
    {
        "link": "https://stackoverflow.com/questions/3978492/fastest-way-to-duplicate-an-array-in-javascript-slice-vs-for-loop",
        "document": "I'm asking only about speed.\n\nI know both ways do only a shallow copy : if original_array contains references to objects, objects won't be cloned, but only the references will be copied, and therefore both arrays will have references to the same objects. But this is not the point of this question.\n\nIn order to duplicate an array in JavaScript: Which of the following is faster to use?\n\nThere are at least 6 (!) ways to clone an array: There has been a huuuge BENCHMARKS thread, providing following information:\n• None for blink browsers is the fastest method, is a bit slower, and is 2.4x slower.\n• None for other browsers is the fastest method, since those browsers don't have internal optimizations for and . Below are simple scripts that you can copy-paste into your browser's console and run several times to see the picture. They output milliseconds, lower is better. Please note that these methods will clone the Array object itself, array contents however are copied by reference and are not deep cloned.\n\nis another alternative for this job. As of today is very fast (almost as fast as ) in Firefox, but not in Chrome. On the other hand, if an array is multi-dimensional, since arrays are objects and objects are reference types, none of the slice or concat methods will be a cure... So one proper way of cloning an array is an invention of as follows.\n\nFastest way to clone an Array of Objects will be using spread operator var clonedArray=[...originalArray] or var clonedArray = originalArray.slice(0); //with 0 index it's little bit faster than normal slice() but the objects inside that cloned array will still pointing at the old memory location. hence change to clonedArray objects will also change the orignalArray. So this will not only create new array but also the objects will be cloned to. disclaimer if you are working with nested object in that case spread operator will work as SHALLOW CLONE. At that point better to use\n\nTake a look at: link. It's not about speed, but comfort. Besides as you can see you can only use slice(0) on primitive types. To make an independent copy of an array rather than a copy of the refence to it, you can use the array slice method. To make an independent copy of an array rather than a copy of the refence to it, you can use the array slice method. To copy or clone an object : function cloneObject(source) { for (i in source) { if (typeof source[i] == 'source') { this[i] = new cloneObject(source[i]); } else{ this[i] = source[i]; } } } var obj1= {bla:'blabla',foo:'foofoo',etc:'etc'}; var obj2= new cloneObject(obj1);\n\nIt depends on the length of the array. If the array length is <= 1,000,000, the and methods are taking approximately the same time. But when you give a wider range, the method wins. For example, try this code: var original_array = []; for(var i = 0; i < 10000000; i ++) { original_array.push( Math.floor(Math.random() * 1000000 + 1)); } function a1() { var dup = []; var start = Date.now(); dup = original_array.slice(); var end = Date.now(); console.log('slice method takes ' + (end - start) + ' ms'); } function a2() { var dup = []; var start = Date.now(); dup = original_array.concat([]); var end = Date.now(); console.log('concat method takes ' + (end - start) + ' ms'); } function a3() { var dup = []; var start = Date.now(); for(var i = 0; i < original_array.length; i ++) { dup.push(original_array[i]); } var end = Date.now(); console.log('for loop with push method takes ' + (end - start) + ' ms'); } function a4() { var dup = []; var start = Date.now(); for(var i = 0; i < original_array.length; i ++) { dup[i] = original_array[i]; } var end = Date.now(); console.log('for loop with = method takes ' + (end - start) + ' ms'); } function a5() { var dup = new Array(original_array.length) var start = Date.now(); for(var i = 0; i < original_array.length; i ++) { dup.push(original_array[i]); } var end = Date.now(); console.log('for loop with = method and array constructor takes ' + (end - start) + ' ms'); } a1(); a2(); a3(); a4(); a5(); If you set the length of original_array to 1,000,000, the method and method are taking approximately the same time (3-4 ms, depending on the random numbers). If you set the length of original_array to 10,000,000, then the method takes over 60 ms and the method takes over 20 ms.\n\nI was redirected here from another question about shallow cloning Arrays, and after finding out that most of the links are either dead, outdated, or broken, figured I'd post a solution that you can just run in your own environment. The following code should semi-accurately measure how much time it takes to clone an array using specific ways. You can run it in your Browser directly using the Developer console or Node.JS. The latest version of it can always be found here. function benchTime(cycles, timeLimit, fnSetup, ...fnProcess) { function measureCycle(timeLimit, fn, args) { let tmp = null; let end, start = performance.now(); let iterations = 0; // Run until we exceed the time limit for one cycle. do { tmp = fn.apply(null, args); end = performance.now(); ++iterations; } while ((end - start) <= timeLimit); tmp = undefined; // Build a result object and return it. return { \"iterations\": iterations, \"start\": start, \"end\": end, \"duration\": end - start, \"opsPerSec\": (iterations / (end - start)) * 1000.0, }; } console.log(`Measuring ${fnProcess.length} functions...`); let params = fnSetup(); //console.log(\"Setup function returned:\", params); // Perform this for every function passed. for (let fn of fnProcess) { let results = []; console.groupCollapsed(`${fn.name}: Running for ${cycles} cycles...`); // Perform this N times. for (let cycle = 0; cycle < cycles; cycle++) { let result = { \"iterations\": Number.NaN, \"start\": Number.NaN, \"end\": Number.NaN, \"duration\": Number.NaN, \"opsPerSec\": Number.NaN, }; try { result = measureCycle(timeLimit, fn, params); results.push(result); } catch (ex) { console.error(`${fn.name}:`, ex); break; } console.log(`Cycle ${cycle}/${cycles}: ${result.iterations}, ${result.end - result.start}, ${result.opsPerSec} ops/s`); } // If we have more than 3 repeats, drop slowest and fastest as outliers. if (results.length > 3) { console.log(\"Dropping slowest and fastest result.\"); results = results.sort((a, b) => { return (a.end - a.start) > (b.end - b.start); }).slice(1); results = results.sort((a, b) => { return (a.end - a.start) < (b.end - b.start); }).slice(1); } console.groupEnd(); // Merge all results for the final average. let iterations = 0; let totalTime = 0; let opsPerSecMin = +Infinity; let opsPerSecMax = -Infinity; let opsPerSec = 0; for (let result of results) { iterations += result.iterations; totalTime += result.duration; opsPerSec += result.opsPerSec; if (opsPerSecMin > result.opsPerSec) { opsPerSecMin = result.opsPerSec; } if (opsPerSecMax < result.opsPerSec) { opsPerSecMax = result.opsPerSec; } } let operations = opsPerSec / results.length; //iterations / totalTime; let operationVariance = opsPerSecMax - opsPerSecMin; console.log(`${fn.name}: ${(operations).toFixed(2)}±${(operationVariance).toFixed(2)} ops/s, ${iterations} iterations over ${totalTime} ms.`); } console.log(\"Done.\"); } function spread(arr) { return [...arr]; } function spreadNew(arr) { return new Array(...arr); } function arraySlice(arr) { return arr.slice(); } function arraySlice0(arr) { return arr.slice(0); } function arrayConcat(arr) { return [].concat(arr); } function arrayMap(arr) { return arr.map(i => i); } function objectValues(arr) { return Object.values(arr); } function objectAssign(arr) { return Object.assign([], arr); } function json(arr) { return JSON.parse(JSON.stringify(arr)); } function loop(arr) { const a = []; for (let val of arr) { a.push(val); } return a; } benchTime( 10, 1000, () => { let arr = new Array(16384); for (let a = 0; a < arr.length; a++) { arr[a] = Math.random(); }; return [arr]; }, spread, spreadNew, arraySlice, arraySlice0, arrayConcat, arrayMap, objectValues, objectAssign, json, loop ); I've run this for a few sizes, but here's a copy of the 16384 element data: Overall, it appears as if the following is true:\n• (arraySlice) , (arraySlice0) and (arrayConcat) are equivalently fast. arraySlice appears to be minimally faster.\n• In Chromium-based Browsers only, (objectAssign) is faster with massive arrays, but brings the downside of eliminating any entries that are .\n• The worst ways overall to shallow-clone arrays are (spreadNew) , (arrayMap) , (objectValues) , (objectAssign) , (json) , (loop) let arr = new Array(); for (let e of array) { arr.push(e); }; return arr; } .\n• Firefox appears to be optimizing in a way that outright looks like cheating. I've failed to identify a way to make Firefox look normal. Disclaimer: These results are from my personal system, and I reserve the right to have made an error in my code.\n\nIf you want a REAL cloned object/array in JS with cloned references of all attributes and sub-objects: ALL other operations do not create clones, because they just change the base address of the root element, not of the included objects. Except you traverse recursive through the object-tree. For a simple copy, these are OK. For storage address relevant operations I suggest (and in most all other cases, because this is fast!) to type convert into string and back in a complete new object."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax",
        "document": "The spread ( ) syntax allows an iterable, such as an array or string, to be expanded in places where zero or more arguments (for function calls) or elements (for array literals) are expected. In an object literal, the spread syntax enumerates the properties of an object and adds the key-value pairs to the object being created. Spread syntax looks exactly like rest syntax. In a way, spread syntax is the opposite of rest syntax. Spread syntax \"expands\" an array into its elements, while rest syntax collects multiple elements and \"condenses\" them into a single element. See rest parameters and rest property.\n\nSpread syntax can be used when all elements from an object or array need to be included in a new array or object, or should be applied one-by-one in a function call's arguments list. There are three distinct places that accept the spread syntax: Although the syntax looks the same, they come with slightly different semantics. Only iterable values, like and , can be spread in array literals and argument lists. Many objects are not iterable, including all plain objects that lack a method: On the other hand, spreading in object literals enumerates the own properties of the value. For typical arrays, all indices are enumerable own properties, so arrays can be spread into objects. All primitives can be spread in objects. Only strings have enumerable own properties, and spreading anything else doesn't create properties on the new object. When using spread syntax for function calls, be aware of the possibility of exceeding the JavaScript engine's argument length limit. See for more details.\n\nIt is common to use in cases where you want to use the elements of an array as arguments to a function. With spread syntax the above can be written as: Any argument in the argument list can use spread syntax, and the spread syntax can be used multiple times. When calling a constructor with , it's not possible to directly use an array and , because calls the target function instead of constructing it, which means, among other things, that will be . However, an array can be easily used with thanks to spread syntax:\n\nWithout spread syntax, the array literal syntax is no longer sufficient to create a new array using an existing array as one part of it. Instead, imperative code must be used using a combination of methods, including , , , etc. With spread syntax, this becomes much more succinct: Just like spread for argument lists, can be used anywhere in the array literal, and may be used more than once. You can use spread syntax to make a shallow copy of an array. Each array element retains its identity without getting copied. Spread syntax effectively goes one level deep while copying an array. Therefore, it may be unsuitable for copying multidimensional arrays. The same is true with — no native operation in JavaScript does a deep clone. The web API method allows deep copying values of certain supported types. See shallow copy for more details. const a = [[1], [2], [3]]; const b = [...a]; b.shift().shift(); // 1 // Oh no! Now array 'a' is affected as well: console.log(a); // [[], [2], [3]] A better way to concatenate arrays is often used to concatenate an array to the end of an existing array. Without spread syntax, this is done as: let arr1 = [0, 1, 2]; const arr2 = [3, 4, 5]; // Append all items from arr2 onto arr1 arr1 = arr1.concat(arr2); With spread syntax this becomes: let arr1 = [0, 1, 2]; const arr2 = [3, 4, 5]; arr1 = [...arr1, ...arr2]; // arr1 is now [0, 1, 2, 3, 4, 5] is often used to insert an array of values at the start of an existing array. Without spread syntax, this is done as: const arr1 = [0, 1, 2]; const arr2 = [3, 4, 5]; // Prepend all items from arr2 onto arr1 Array.prototype.unshift.apply(arr1, arr2); console.log(arr1); // [3, 4, 5, 0, 1, 2] With spread syntax, this becomes: Note: Unlike , this creates a new , instead of modifying the original array in-place. You can make an element present or absent in an array literal, depending on a condition, using a conditional operator. When the condition is , we spread an empty array, so that nothing gets added to the final array. Note that this is different from the following: In this case, an extra element is added when is , and this element will be visited by methods such as .\n\nYou can use spread syntax to merge multiple objects into one new object. A single spread creates a shallow copy of the original object (but without non-enumerable properties and without copying the prototype), similar to copying an array. When one object is spread into another object, or when multiple objects are spread into one object, and properties with identical names are encountered, the property takes the last value assigned while remaining in the position it was originally set. You can make an element present or absent in an object literal, depending on a condition, using a conditional operator. The case where the condition is is an empty object, so that nothing gets spread into the final object. Note that this is different from the following: In this case, the property is always present and will be visited by methods such as . Because primitives can be spread into objects as well, and from the observation that all falsy values do not have enumerable properties, you can simply use a logical AND operator: In this case, if is any falsy value, no property will be created on the object. Note that can be used to mutate an object, whereas spread syntax can't. In addition, triggers setters on the target object, whereas spread syntax does not. const objectAssign = Object.assign( { set foo(val) { console.log(val); }, }, { foo: 1 }, ); // Logs \"1\"; objectAssign.foo is still the original setter const spread = { set foo(val) { console.log(val); }, ...{ foo: 1 }, }; // Nothing is logged; spread.foo is 1 You cannot naively re-implement the function through a single spreading: In the above example, the spread syntax does not work as one might expect: it spreads an array of arguments into the object literal, due to the rest parameter. Here is an implementation of using the spread syntax, whose behavior is similar to , except that it doesn't trigger setters, nor mutates any object:"
    },
    {
        "link": "https://geeksforgeeks.org/how-to-splice-an-array-without-mutating-the-original-array",
        "document": "How to Splice an Array Without Mutating the Original Array?\n\nTo splice or remove elements without changing the original array, you can use various techniques to create a copy first. Here are the most effective ways to do this\n\n1. Using slice() and concat() Methods – Most Used\n\nThe combination of slice() and concat() methods allows you to remove elements from an array without mutating the original by creating a new array.\n\nThe filter() method can be used to create a new array which only includes elements that meet a certain condition.\n\n3. Using the Spread Operator and slice() Method\n\nThe spread operator (…) with slice() is a simple way to remove elements without modifying the original array.\n\nFor more complex tasks, you can use map() to go through each item in an array and make changes. You can also set conditions to skip over items that meet certain criteria, so only the ones you want are included."
    },
    {
        "link": "https://freecodecamp.org/news/how-to-clone-an-array-in-javascript-1d3183468f6a",
        "document": "JavaScript has many ways to do anything. I’ve written on 10 Ways to Write pipe/compose in JavaScript, and now we’re doing arrays.\n\nHere's an interactive scrim that shows various ways to clone arrays in JavaScript:\n\nEver since ES6 dropped, this has been the most popular method. It’s a brief syntax and you’ll find it incredibly useful when using libraries like React and Redux.\n\nNote: This doesn’t safely copy multi-dimensional arrays. Array/object values are copied by reference instead of by value.\n\nThis is not fine\n\nI imagine this approach is the least popular, given how trendy functional programming’s become in our circles.\n\nPure or impure, declarative or imperative, it gets the job done!\n\nNote: This doesn’t safely copy multi-dimensional arrays. Since you’re using the operator, it’ll assign objects/arrays by reference instead of by value.\n\nThis is not fine\n\nNote: This also assigns objects/arrays by reference instead of by value.\n\nThis is not fine\n\nBack in modern territory, we’ll find the function. Rooted in mathematics, is the concept of transforming a set into another type of set, while preserving structure.\n\nIn English, that means returns an array of the same length every single time.\n\nTo double a list of numbers, use with a function.\n\nTrue, this article’s about cloning arrays. To duplicate an array, just return the element in your call.\n\nIf you’d like to be a bit more mathematical, is called identity. It returns whatever parameter it’s been given.\n\nNote: This also assigns objects/arrays by reference instead of by value.\n\nThis function returns an array, just like , but it’s not guaranteed to be the same length.\n\nWhat if you’re filtering for even numbers?\n\nThe input array length was 3, but the resulting length is 1.\n\nIf your 's predicate always returns , however, you get a duplicate!\n\nEvery element passes the test, so it gets returned.\n\nNote: This also assigns objects/arrays by reference instead of by value.\n\nI almost feel bad using to clone an array, because it’s so much more powerful than that. But here we go…\n\ntransforms an initial value as it loops through a list.\n\nHere the initial value is an empty array, and we’re filling it with each element as we go. That array must be returned from the function to be used in the next iteration.\n\nNote: This also assigns objects/arrays by reference instead of by value.\n\nreturns a shallow copy of an array based on the provided start/end index you provide.\n\nIf we want the first 3 elements:\n\nIf we want all the elements, don’t give any parameters\n\nNote: This is a shallow copy, so it also assigns objects/arrays by reference instead of by value.\n\nCombining them can turn an object into a string, and then reverse the process to create a brand new data structure.\n\ncombines arrays with values or other arrays.\n\nIf you give nothing or an empty array, a shallow copy’s returned.\n\nNote: This also assigns objects/arrays by reference instead of by value.\n\nThis can turn any iterable object into an array. Giving an array returns a shallow copy.\n\nNote: This also assigns objects/arrays by reference instead of by value.\n\nWell, this was fun ?\n\nI tried to clone using just 1 step. You’ll find many more ways if you employ multiple methods and techniques."
    },
    {
        "link": "https://geeksforgeeks.org/how-to-clone-an-array-in-javascript",
        "document": "How to clone an array in JavaScript ?\n\nIn JavaScript, cloning an array means creating a new array with the same elements as the original array without modifying the original array.\n\nHere are some common use cases for cloning an array:\n\nWe use the slice method to create a shallow copy of an array. This method creates a new array with a subset of the elements from the original array.\n\nExample: This example shows the implementation of the above-explained approach.\n\nUsing the spread operator … is a concise and easy way to clone an array in JavaScript. The spread operator allows you to expand an array into individual elements, which can then be used to create a new array.\n\nExample: This example shows the implementation of the above-explained approach.\n\nUsing the Array.from() method is another way to clone an array in JavaScript. This method creates a new array from an existing array, using an optional mapping function to transform the values in the new array.\n\nExample: This example shows the implementation of the above-explained approach.\n\nUsing the Array.concat() method is another way to clone an array in JavaScript. This method creates a new array by concatenating two or more arrays together.\n\nExample: This example shows the implementation of the above-explained approach.\n\nThis method involves iterating through each element in the original array and copying each element into a new array.\n\nExample: This example shows the implementation of the above-explained approach.\n\nUsing the Array.map() method is another way to clone an array in JavaScript. This method creates a new array by mapping each element from the original array to a new value.\n\nExample: This example shows the implementation of the above-explained approach.\n\nUsing the Array.from() method with a map function\n\nUsing the Array.from() method with a map function is another way to clone an array in JavaScript. This method creates a new array by mapping each element from the original array to a new value using a provided function.\n\nExample: This example shows the implementation of the above-explained approach.\n\nThis method creates a new array with the same elements as the original array.\n\nExample: This example shows the implementation of the above-explained approach.\n\nUsing the JSON.parse() and JSON.stringify() Methods\n\nUsing the JSON.parse() and JSON.stringify() methods is another way to clone an array in JavaScript. This method involves converting the original array to a JSON string and then parsing the JSON string to create a new array.\n\nExample: This example shows the implementation of the above-explained approach.\n\nUsing the Object.assign() method is another way to clone an array in JavaScript. This method creates a new array by copying the properties of the original array to a new object.\n\nExample: This example shows the implementation of the above-explained approach.\n\nThe Array.reduce() method executes a reducer function on each element of the array, resulting in a single output value. We can use it to construct a new array with the same elements as the original array.\n\nExample: In this example, we’ll use the Array.reduce() method to create a clone of an array.\n\nNote: Thus, When cloning an array, it is important to consider the complexity of the data and the performance requirements of the application.\n\nAnother approach to clone an array in JavaScript is by using the flatMap() method. The flatMap() method first maps each element using a mapping function, then flattens the result into a new array. While its primary use case is for flattening arrays, it can also be utilized to clone an array by simply mapping each element to itself.\n\nExample: In this example, we will use the flatMap() method to clone an array by mapping each element to itself.\n\nIf you want to perform some operations on an array, such as sorting, filtering, or mapping, but you don’t want to modify the original array, you can create a clone of the original array and perform the operations on the clone instead.\n• None When passing an array to a function as an argument, you may want to ensure that the function does not modify the original array. In this case, you can pass a clone of the array instead.\n• None If you want to preserve the original array for future reference, you can create a clone of the original array and use the clone for further processing or manipulation.\n• None If you have an array that contains objects or arrays as elements, and you want to avoid modifying the original objects or arrays, you can create a clone of the array to work with, so that changes to the objects or arrays in the clone do not affect the original objects or arrays.\n\nThus, cloning an array in JavaScript is a useful technique for working with arrays in a way that preserves the integrity of the original array and its elements."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map",
        "document": "The method is an iterative method. It calls a provided function once for each element in an array and constructs a new array from the results. Read the iterative methods section for more information about how these methods work in general. is invoked only for array indexes which have assigned values. It is not invoked for empty slots in sparse arrays. The method is generic. It only expects the value to have a property and integer-keyed properties. Since builds a new array, calling it without using the returned array is an anti-pattern; use or instead.\n\nIt is common to use the callback with one argument (the element being traversed). Certain functions are also commonly used with one argument, even though they take additional optional arguments. These habits may lead to confusing behaviors. Consider: While one might expect , the actual result is . is often used with one argument, but takes two. The first is an expression and the second is the radix to the callback function, passes 3 arguments: the element, the index, and the array. The third argument is ignored by — but not the second one! This is the source of possible confusion. Here is a concise example of the iteration steps: /* first iteration (index is 0): */ parseInt(\"1\", 0); // 1 /* second iteration (index is 1): */ parseInt(\"2\", 1); // NaN /* third iteration (index is 2): */ parseInt(\"3\", 2); // NaN To solve this, define another function that only takes one argument: You can also use the function, which only takes one argument: [\"1\", \"2\", \"3\"].map(Number); // [1, 2, 3] // But unlike parseInt(), Number() will also return a float or (resolved) exponential notation: [\"1.1\", \"2.2e2\", \"3e300\"].map(Number); // [1.1, 220, 3e+300] // For comparison, if we use parseInt() on the array above: [\"1.1\", \"2.2e2\", \"3e300\"].map((str) => parseInt(str, 10)); // [1, 2, 3] See A JavaScript optional argument hazard by Allen Wirfs-Brock for more discussions.\n\nThe callback can have side effects. This is not recommended, because copying methods are best used with pure functions. In this case, we can choose to iterate the array twice. Sometimes this pattern goes to its extreme and the only useful thing that does is causing side effects. const products = [ { name: \"sports car\" }, { name: \"laptop\" }, { name: \"phone\" }, ]; products.map((product) => { product.price = 100; }); As mentioned previously, this is an anti-pattern. If you don't use the return value of , use or a loop instead. Or, if you want to create a new array instead:\n\nUsing the third argument of callbackFn The argument is useful if you want to access another element in the array, especially when you don't have an existing variable that refers to the array. The following example first uses to extract the positive values and then uses to create a new array where each element is the average of its neighbors and itself. const numbers = [3, -1, 1, 4, 1, 5, 9, 2, 6]; const averaged = numbers .filter((num) => num > 0) .map((num, idx, arr) => { // Without the arr argument, there's no way to easily access the // intermediate array without saving it to a variable. const prev = arr[idx - 1]; const next = arr[idx + 1]; let count = 1; let total = num; if (prev !== undefined) { count++; total += prev; } if (next !== undefined) { count++; total += next; } const average = total / count; // Keep two decimal places return Math.round(average * 100) / 100; }); console.log(averaged); // [2, 2.67, 2, 3.33, 5, 5.33, 5.67, 4] The argument is not the array that is being built — there is no way to access the array being built from the callback function.\n\nThe method reads the property of and then accesses each property whose key is a nonnegative integer less than . const arrayLike = { length: 3, 0: 2, 1: 3, 2: 4, 3: 5, // ignored by map() since length is 3 }; console.log(Array.prototype.map.call(arrayLike, (x) => x ** 2)); // [ 4, 9, 16 ] This example shows how to iterate through a collection of objects collected by . This is because returns a (which is a collection of objects). In this case, we return all the selected s' values on the screen: You can also use to transform to an array, and then access the method."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array",
        "document": "objects cannot use arbitrary strings as element indexes (as in an associative array) but must use nonnegative integers (or their respective string form). Setting or accessing via non-integers will not set or retrieve an element from the array list itself, but will set or access a variable associated with that array's object property collection. The array's object properties and list of array elements are separate, and the array's traversal and mutation operations cannot be applied to these named properties. Array elements are object properties in the same way that is a property (to be specific, however, is a method). Nevertheless, trying to access an element of an array as follows throws a syntax error because the property name is not valid: JavaScript syntax requires properties beginning with a digit to be accessed using bracket notation instead of dot notation. It's also possible to quote the array indices (e.g., instead of ), although usually not necessary. The in is coerced into a string by the JavaScript engine through an implicit conversion. As a result, and would refer to two different slots on the object, and the following example could be : Only is an actual array index. is an arbitrary string property that will not be visited in array iteration.\n\nMany array methods take a callback function as an argument. The callback function is called sequentially and at most once for each element in the array, and the return value of the callback function is used to determine the return value of the method. They all share the same signature: The current element being processed in the array. The index of the current element being processed in the array. The array that the method was called upon. What is expected to return depends on the array method that was called. The argument (defaults to ) will be used as the value when calling . The value ultimately observable by is determined according to the usual rules: if is non-strict, primitive values are wrapped into objects, and / is substituted with . The argument is irrelevant for any defined with an arrow function, as arrow functions don't have their own binding. The argument passed to is most useful if you want to read another index during iteration, because you may not always have an existing variable that refers to the current array. You should generally not mutate the array during iteration (see mutating initial array in iterative methods), but you can also use this argument to do so. The argument is not the array that is being built, in the case of methods like , , and — there is no way to access the array being built from the callback function. All iterative methods are copying and generic, although they behave differently with empty slots. The following methods are iterative: , , , , , , , , , and . In particular, , , , , , and do not always invoke on every element — they stop iteration as soon as the return value is determined. The and methods also take a callback function and run it at most once for each element in the array, but they have slightly different signatures from typical iterative methods (for example, they don't accept ). The method also takes a callback function, but it is not an iterative method. It mutates the array in-place, doesn't accept , and may invoke the callback multiple times on an index. Iterative methods iterate the array like the following (with a lot of technical details omitted): function method(callbackFn, thisArg) { const length = this.length; for (let i = 0; i < length; i++) { if (i in this) { const result = callbackFn.call(thisArg, this[i], i, this); // Do something with result; maybe return early } } }\n• Not all methods do the test. The , , , and methods do not, but other methods do.\n• The is memorized before the loop starts. This affects how insertions and deletions during iteration are handled (see mutating initial array in iterative methods).\n• The method doesn't memorize the array contents, so if any index is modified during iteration, the new value might be observed.\n• The code above iterates the array in ascending order of index. Some methods iterate in descending order of index ( ): , , and .\n• and have slightly different signatures and do not always start at the first/last element.\n\nArray methods are always generic — they don't access any internal data of the array object. They only access the array elements through the property and the indexed elements. This means that they can be called on array-like objects as well. The property is converted to an integer and then clamped to the range between 0 and 253 - 1. becomes , so even when is not present or is , it behaves as if it has value . The language avoids setting to an unsafe integer. All built-in methods will throw a if will be set to a number greater than 253 - 1. However, because the property of arrays throws an error if it's set to greater than 232 - 1, the safe integer threshold is usually not reached unless the method is called on a non-array object. Some array methods set the property of the array object. They always set the value after normalization, so always ends as an integer. The term array-like object refers to any object that doesn't throw during the conversion process described above. In practice, such object is expected to actually have a property and to have indexed elements in the range to . (If it doesn't have all indices, it will be functionally equivalent to a sparse array.) Any integer index less than zero or greater than is ignored when an array method operates on an array-like object. Many DOM objects are array-like — for example, and . The object is also array-like. You can call array methods on them even if they don't have these methods themselves.\n\nReturns the array item at the given index. Accepts negative integers, which count back from the last item. Returns a new array that is the calling array joined with other array(s) and/or value(s). Copies a sequence of array elements within an array. Returns a new array iterator object that contains the key/value pairs for each index in an array. Returns if every element in the calling array satisfies the testing function. Fills all the elements of an array from a start index to an end index with a static value. Returns a new array containing all elements of the calling array for which the provided filtering function returns . Returns the value of the first element in the array that satisfies the provided testing function, or if no appropriate element is found. Returns the index of the first element in the array that satisfies the provided testing function, or if no appropriate element was found. Returns the value of the last element in the array that satisfies the provided testing function, or if no appropriate element is found. Returns the index of the last element in the array that satisfies the provided testing function, or if no appropriate element was found. Returns a new array with all sub-array elements concatenated into it recursively up to the specified depth. Returns a new array formed by applying a given callback function to each element of the calling array, and then flattening the result by one level. Calls a function for each element in the calling array. Determines whether the calling array contains a value, returning or as appropriate. Returns the first (least) index at which a given element can be found in the calling array. Joins all elements of an array into a string. Returns a new array iterator that contains the keys for each index in the calling array. Returns the last (greatest) index at which a given element can be found in the calling array, or if none is found. Returns a new array containing the results of invoking a function on every element in the calling array. Removes the last element from an array and returns that element. Adds one or more elements to the end of an array, and returns the new of the array. Executes a user-supplied \"reducer\" callback function on each element of the array (from left to right), to reduce it to a single value. Executes a user-supplied \"reducer\" callback function on each element of the array (from right to left), to reduce it to a single value. Reverses the order of the elements of an array in place. (First becomes the last, last becomes first.) Removes the first element from an array and returns that element. Extracts a section of the calling array and returns a new array. Returns if at least one element in the calling array satisfies the provided testing function. Sorts the elements of an array in place and returns the array. Returns a localized string representing the calling array and its elements. Overrides the method. Returns a new array with the elements in reversed order, without modifying the original array. Returns a new array with the elements sorted in ascending order, without modifying the original array. Returns a new array with some elements removed and/or replaced at a given index, without modifying the original array. Returns a string representing the calling array and its elements. Overrides the method. Adds one or more elements to the front of an array, and returns the new of the array. Returns a new array iterator object that contains the values for each index in the array. Returns a new array with the element at the given index replaced with the given value, without modifying the original array. An alias for the method by default.\n\nIterative methods do not mutate the array on which it is called, but the function provided as can. The key principle to remember is that only indexes between 0 and are visited, where is the length of the array at the time the array method was first called, but the element passed to the callback is the value at the time the index is visited. Therefore:\n• will not visit any elements added beyond the array's initial length when the call to the iterative method began.\n• Changes to already-visited indexes do not cause to be invoked on them again.\n• If an existing, yet-unvisited element of the array is changed by , its value passed to the will be the value at the time that element gets visited. Removed elements are not visited. Warning: Concurrent modifications of the kind described above frequently lead to hard-to-understand code and are generally to be avoided (except in special cases). The following examples use the method as an example, but other methods that visit indexes in ascending order work in the same way. We will first define a helper function: Modification to indexes not visited yet will be visible once the index is reached: Modification to already visited indexes does not change iteration behavior, although the array will be different afterwards: Inserting n elements at unvisited indexes that are less than the initial array length will make them be visited. The last n elements in the original array that now have index greater than the initial array length will not be visited: testSideEffect((arr, index) => { if (index === 1) arr.splice(2, 0, \"new\"); }); // array: [e1, e2, e3, e4], index: 0, elem: e1 // array: [e1, e2, e3, e4], index: 1, elem: e2 // array: [e1, e2, new, e3, e4], index: 2, elem: new // array: [e1, e2, new, e3, e4], index: 3, elem: e3 // Final array: [e1, e2, new, e3, e4] // e4 is not visited because it now has index 4 Inserting n elements with index greater than the initial array length will not make them be visited: testSideEffect((arr) => arr.push(\"new\")); // array: [e1, e2, e3, e4], index: 0, elem: e1 // array: [e1, e2, e3, e4, new], index: 1, elem: e2 // array: [e1, e2, e3, e4, new, new], index: 2, elem: e3 // array: [e1, e2, e3, e4, new, new, new], index: 3, elem: e4 // Final array: [e1, e2, e3, e4, new, new, new, new] Inserting n elements at already visited indexes will not make them be visited, but it shifts remaining elements back by n, so the current index and the n - 1 elements before it are visited again: testSideEffect((arr, index) => arr.splice(index, 0, \"new\")); // array: [e1, e2, e3, e4], index: 0, elem: e1 // array: [new, e1, e2, e3, e4], index: 1, elem: e1 // array: [new, new, e1, e2, e3, e4], index: 2, elem: e1 // array: [new, new, new, e1, e2, e3, e4], index: 3, elem: e1 // Final array: [new, new, new, new, e1, e2, e3, e4] // e1 keeps getting visited because it keeps getting shifted back Deleting n elements at unvisited indexes will make them not be visited anymore. Because the array has shrunk, the last n iterations will visit out-of-bounds indexes. If the method ignores non-existent indexes (see array methods and empty slots), the last n iterations will be skipped; otherwise, they will receive : testSideEffect((arr, index) => { if (index === 1) arr.splice(2, 1); }); // array: [e1, e2, e3, e4], index: 0, elem: e1 // array: [e1, e2, e3, e4], index: 1, elem: e2 // array: [e1, e2, e4], index: 2, elem: e4 // Final array: [e1, e2, e4] // Does not visit index 3 because it's out-of-bounds // Compare this with find(), which treats nonexistent indexes as undefined: const arr2 = [\"e1\", \"e2\", \"e3\", \"e4\"]; arr2.find((elem, index, arr) => { console.log(`array: [${arr.join(\", \")}], index: ${index}, elem: ${elem}`); if (index === 1) arr.splice(2, 1); return false; }); // array: [e1, e2, e3, e4], index: 0, elem: e1 // array: [e1, e2, e3, e4], index: 1, elem: e2 // array: [e1, e2, e4], index: 2, elem: e4 // array: [e1, e2, e4], index: 3, elem: undefined Deleting n elements at already visited indexes does not change the fact that they were visited before they get deleted. Because the array has shrunk, the next n elements after the current index are skipped. If the method ignores non-existent indexes, the last n iterations will be skipped; otherwise, they will receive : testSideEffect((arr, index) => arr.splice(index, 1)); // array: [e1, e2, e3, e4], index: 0, elem: e1 // Does not visit e2 because e2 now has index 0, which has already been visited // array: [e2, e3, e4], index: 1, elem: e3 // Does not visit e4 because e4 now has index 1, which has already been visited // Final array: [e2, e4] // Index 2 is out-of-bounds, so it's not visited // Compare this with find(), which treats nonexistent indexes as undefined: const arr2 = [\"e1\", \"e2\", \"e3\", \"e4\"]; arr2.find((elem, index, arr) => { console.log(`array: [${arr.join(\", \")}], index: ${index}, elem: ${elem}`); arr.splice(index, 1); return false; }); // array: [e1, e2, e3, e4], index: 0, elem: e1 // array: [e2, e3, e4], index: 1, elem: e3 // array: [e2, e4], index: 2, elem: undefined // array: [e2, e4], index: 3, elem: undefined For methods that iterate in descending order of index, insertion causes elements to be skipped, and deletion causes elements to be visited multiple times. Adjust the code above yourself to see the effects."
    },
    {
        "link": "https://w3schools.com/jsref/jsref_map.asp",
        "document": "W3Schools offers a wide range of services and products for beginners and professionals, helping millions of people everyday to learn and master new skills."
    },
    {
        "link": "https://hostman.com/tutorials/how-to-use-javascript-array-map",
        "document": "Database Connection in Python, Go, and JavaScript\n\nDatabases are an essential part of almost any project today. Database interactions are especially familiar to system and database administrators, DevOps/SRE professionals, and software developers. While administrators typically deploy one or multiple database instances and configure the necessary connection parameters for applications, developers need to connect directly to the database within their code. This article explores how to connect to databases using different programming languages. Prerequisites We will provide examples for connecting to MySQL, PostgreSQL, Redis, MongoDB, and ClickHouse databases using Python, Go, and JavaScript. To follow this guide, you will need: A database deployed on a server or in the cloud. Installed environments for Python, Go, and JavaScript, depending on your application programming language. Additionally for Python: pip installed. Additionally for JavaScript: Node.js and npm installed. Database Connection in Python MySQL and Python For connecting to MySQL databases, we can use a Python driver called MySQL Connector. Install the driver using pip: pip install mysql-connector-python Initialize a new connection: Import the mysql.connector library and the Error class to handle specific connection errors. Create a function named create_connection, passing the database address (host), user name (user), and user password (password). To establish the connection, define a class called create_connection that receives the variable names containing the database connection details. import mysql.connector from mysql.connector import Error def create_connection(host_name, user_name, user_password): connection = None try: connection = mysql.connector.connect( host=\"91.206.179.29\", user=\"gen_user\", password=\"m-EE6Wm}z@wCKe\" ) print(\"Successfully connected to MySQL Server!\") except Error as e: print(f\"The error '{e}' occurred\") return connection def execute_query(connection, query): cursor = connection.cursor() try: cursor.execute(query) connection.commit() print(\"Query executed successfully\") except Error as e: print(f\"The error '{e}' occurred\") connection = create_connection(\"91.206.179.29\", \"gen_user\", \"m-EE6Wm}z@wCKe\") Run the script. If everything works correctly, you will see the \"Successfully connected to MySQL Server!\" message. If any errors occur, the console will display error code and description. Create a new table: Connect to the database using the connection.database class, specifying the name of the database. Note that the database should already exist. To create a table, initialize a variable create_table_query containing the SQL CREATE TABLE query. For data insertion, initialize another variable insert_data_query with the SQL INSERT INTO query. To execute each query, use the execute_query class, which takes the database connection string and the variable containing the SQL query. connection.database = 'test_db' create_table_query = \"\"\" CREATE TABLE IF NOT EXISTS users ( id INT AUTO_INCREMENT PRIMARY KEY, name VARCHAR(100) NOT NULL, age INT NOT NULL ) \"\"\" execute_query(connection, create_table_query) insert_data_query = \"\"\" INSERT INTO users (name, age) VALUES ('Alice', 30), ('Bob', 25) \"\"\" execute_query(connection, insert_data_query) if connection.is_connected(): connection.close() print(\"Connection closed\") Run the script. PostgreSQL and Python Python offers several plugins for connecting to PostgreSQL, but the most popular one is psycopg2, which we will use here. Psycopg2 is one of the most frequently used Python plugins for PostgreSQL connections. One of its key advantages is its support for multithreading which allows you to maintain the database connection across multiple threads. Install psycopg2 using pip (if not already installed): pip install psycopg2-binary Connect to PostgreSQL. Import the Python psycopg2 package and create a function create_new_conn, using the try block. Establish the connection with the psycopg2.connect function, which requires the database name, user name, password, and database address as input. To initialize the connection, use the create_new_conn() function. Here’s the full code example for connecting to a database: import psycopg2 from psycopg2 import OperationalError def create_new_conn(): conn_to_postgres = None while not conn_to_postgres: try: conn_to_postgres = psycopg2.connect( default_db=\"default_db\", default_user=\"gen_user\", password_for_default_user=\"PasswordForDefautUser9893#\", db_address=\"91.206.179.128\" ) print(\"The connection to PostgreSQL has been successfully established!\") except OperationalError as e: print(e) return conn_to_postgres conn_to_postgres = create_new_conn() Run the script: python3 connect_to_postgres.py If successful, you will see the \"The connection to PostgreSQL has been successfully established!\" message. . Next, create a table named books, which will have three columns. Use the cursor class for SQL expressions, such as creating database objects. If the query involves adding or modifying data, you must call the conn_to_postgres.commit() function afterward to apply the changes. import psycopg2 from psycopg2 import OperationalError def create_new_conn(): conn_to_postgres = None while not conn_to_postgres: try: conn_to_postgres = psycopg2.connect( default_db=\"default_db\", default_user=\"gen_user\", password_for_default_user=\"PasswordForDefautUser9893#\", db_address=\"91.206.179.128\" ) except OperationalError as e: print(e) return conn_to_postgres conn_to_postgres = create_new_conn() cursor = conn_to_postgres.cursor() cursor.execute(\"\"\" CREATE TABLE books ( book_id INT PRIMARY KEY NOT NULL, book_name VARCHAR(255) NOT NULL, book_author VARCHAR(255) NOT NULL ) \"\"\") conn_to_postgres.commit() print(\"Table Created successfully\") Run the script: python3 create_table.py Now, let’s run INSERT INTO to add a new line: cursor.execute(\"\"\" INSERT INTO books (book_id,book_name,book_author) VALUES (1, 'Long Walk to Freedom', 'Nelson_Mandela') \"\"\") The full code is below: import psycopg2 from psycopg2 import OperationalError def create_new_conn(): conn_to_postgres = None while not conn_to_postgres: try: conn_to_postgres = psycopg2.connect( default_db=\"default_db\", default_user=\"gen_user\", password_for_default_user=\"PasswordForDefautUser9893#\", db_address=\"91.206.179.128\" ) except OperationalError as e: print(e) return conn_to_postgres conn_to_postgres = create_new_conn() cursor = conn_to_postgres.cursor() cursor.execute(\"\"\" INSERT INTO books (book_id,book_name,book_author) VALUES (1, 'Long Walk to Freedom', 'Nelson_Mandela') \"\"\") conn_to_postgres.commit() conn_to_postgres.close() print(\"Data inserted successfully\") Run the script: python3 insert-data.py Redis and Python Redis belongs to the class of NoSQL databases, where data is stored in memory rather than on hard drives. It uses a key-value format for data storage. Redis has a wide range of applications, from data storage and caching to serving as a message broker. We will use the redis-py (or simply redis) library for connecting to Redis. Install the Redis library using pip: pip install redis Connecting to a Redis instance: Use a try block structure for connection, specifying the function redis.StrictRedis where you provide the Redis address, port, and user password. import redis try: connect_to_redis_server = redis.StrictRedis( redis_db_host=91.206.179.128, redis_db_port=6379, redis_user_password='PasswordForRedis6379') print connect_to_redis_server connect_to_redis_server.ping() print 'Successfully connected to Redis Server!' except Exception as ex: print 'Error:', ex exit('Failed to connect to Redis server.') Run the script: python3 connect_to_redis.py If successful, you will see a message like \"Successfully connected to Redis Server!\". Unlike relational databases, Redis stores data in a key-value format. The key uniquely identifies the corresponding value. Use the set method to create a new record. The example below creates a record with the key City and the value Berlin: print('Create new record:', connect_to_redis_server.set(\"City\", \"Berlin\")) Use the get method to retrieve the value associated with a key: print('Print record using record key:', connect_to_redis_server.get(\"City\")) Use the delete method to remove a record by its key: print('Delete record with key:', connect_to_redis_server.delete(\"City\")) The complete code fragment is below. import redis try: connect_to_redis_server = redis.StrictRedis( redis_db_host=91.206.179.128, redis_db_port=6379, redis_user_password='PasswordForRedis6379') print ('New record created:', connect_to_redis_server.set(\"City\", \"Berlin\")) print ('Print created record using record key', connect_to_redis_server.get(\"City\")) print ('Delete created record with key :', connect_to_redis_server.delete(\"City\")) except Exception as ex: print ('Error:', ex) MongoDB and Python MongoDB is another widely used NoSQL database that belongs to the document-oriented category. Data is organized as JSON-like documents. To connect to a MongoDB database with Python, the recommended library is PyMongo, which provides a synchronous API. Install the PyMongo plugin: pip3 install pymongo Connect to MongoDB server using the following Python code. Import the pymongo module and use the MongoClient class to specify the database server address. To establish a connection to the MongoDB server, use a try block for error handling: import pymongo connect_to_mongo = pymongo.MongoClient(\"mongodb://91.206.179.29:27017/\") first_db = connect_to_mongo[\"mongo-db1\"] try: first_db.command(\"serverStatus\") except Exception as e: print(e) else: print(\"Successfully connected to MongoDB Server!\") connect_to_mongo.close() Run: python3 connect_mongodb.py If the connection is successfully established, the script will return the message: \"Successfully connected to MongoDB Server!\" Add data to MongoDB. To add data, you need to create a dictionary. Let's create a dictionary named record1, containing three keys: record1 = { \"name\": \"Alex\", \"age\": 25, \"location\": \"London\" } To insert the dictionary data, use the insert_one method in MongoDB. insertrecord = collection1.insert_one(record1) import pymongo connect_to_mongo = pymongo.MongoClient(\"mongodb://91.206.179.29:27017/\") db1 = connect_to_mongo[\"newdb\"] collection1 = db1[\"userdata\"] record1 = { \"name\": \"Alex\", \"age\": 25, \"location\": \"London\" } insertrecord = collection1.insert_one(record1) print(insertrecord) Run the script: python3 connect_mongodb.py ClickHouse and Python ClickHouse is a columnar NoSQL database where data is stored in columns rather than rows. It is widely used for handling analytical queries. Install the ClickHouse driver for Python. There is a dedicated plugin for ClickHouse called clickhouse-driver. Install the driver using the pip package manager: pip install clickhouse-driver Connect to ClickHouse. To initialize a connection with ClickHouse, you need to import the Client class from the clickhouse_driver library. To execute SQL queries, use the client.execute function. You also need to specify the engine. For more details on supported engines in ClickHouse, you can refer to the official documentation. We'll use the default engine, MergeTree. Next, create a new table called users and insert two columns with data. To list the data to be added to the table, use the tuple data type. After executing the necessary queries, make sure to close the connection to the database using the client.disconnect() method. The final code will look like this: from clickhouse_driver import Client client = Client(host=91.206.179.128', user='root', password='P@$$w0rd123', port=9000) client.execute(''' CREATE TABLE IF NOT EXISTS Users ( id UInt32, name String, ) ENGINE = MergeTree() ORDER BY id ''') data = [ (1, 'Alice'), (2, 'Mary') ] client.execute('INSERT INTO Users (id, name) VALUES', data) result = client.execute('SELECT * FROM Users') for row in result: print(row) client.disconnect() Database Connection in Go Go is one of the youngest programming languages, developed in 2009 by Google. It is widely used in developing microservice architectures and network utilities. For example, services like Docker and Kubernetes are written in Go. Go supports integrating all popular databases, including PostgreSQL, Redis, MongoDB, MySQL, ClickHouse, etc. MySQL and Go For working with the MySQL databases in Go, use the go-sql-driver/mysql driver. Create a new directory for storing project files and navigate into it: mkdir mysql-connect && cd mysql-connect Create a go.mod file to store the dependencies: go mod init golang-connect-mysql Download the MySQL driver using the go get command: go get -u github.com/go-sql-driver/mysql Create a new file named main.go. Specify the database connection details in the dsn variable: package main import ( \"database/sql\" \"fmt\" \"log\" _ \"github.com/go-sql-driver/mysql\" ) func main() { dsn := \"root:password@tcp(localhost:3306)/testdb\" db, err := sql.Open(\"mysql\", dsn) if err != nil { log.Fatal(err) } defer db.Close() if err := db.Ping(); err != nil { log.Fatal(err) } fmt.Println(\"Successfully connected to the database!\") query := \"INSERT INTO users (name, age) VALUES (?, ?)\" result, err := db.Exec(query, \"Alex\", 25) if err != nil { log.Fatal(err) } lastInsertID, err := result.LastInsertId() if err != nil { log.Fatal(err) } fmt.Printf(\"Inserted data with ID: %d\n\n\", lastInsertID) } PostgreSQL and Go To connect to PostgreSQL, use the pq driver. Before installing the driver, let's prepare our environment. Create a new directory for storing the project files and navigate into it: mkdir postgres-connect && cd postgres-connect Since we will be working with dependencies, we need to create a go.mod file to store them: go mod init golang-connect-postgres Download the pq driver using the go get command: go get github.com/lib/pq Create a new file named main.go. In addition to importing the pq library, it is necessary to add the database/sql library as Go does not come with official database drivers by default. The database/sql library consists of general, independent interfaces for working with databases. It is also important to note the underscore (empty identifier) when importing the pq module: _ \"github.com/lib/pq\" The empty identifier is used to avoid the \"unused import\" error, as in this case, we only need the driver to be registered in database/sql. The fmt package is required to output data to the standard output stream, for example, to the console. To open a connection to the database, the sql.Open function is used, which takes the connection string (connStr) and the driver name (postgres). The connection string specifies the username, database name, password, and host address: package main import ( \"database/sql\" \"fmt\" \"log\" _ \"github.com/lib/pq\" ) func main() { connStr := \"user=golang dbname=db_for_golang password=Golanguserfordb0206$ host=47.45.249.146 sslmode=disable\" db, err := sql.Open(\"postgres\", connStr) if err != nil { log.Fatal(err) } defer db.Close() err = db.Ping() if err != nil { log.Fatal(err) } fmt.Println(\"Successfully connected to PostgreSQL!\") } Compile and run: go run main.go If everything works correctly, the terminal will display the message Successfully connected to PostgreSQL! Now, let's look at an example of how to insert data into a table. First, we need to create a table in the database. When using Hostman cloud databases, you can copy the PostgreSQL connection string displayed in the \"Connections\" section of the Hostman web interface. Make sure that the postgresql-client utility is installed on your device beforehand. Enter the psql shell and connect to the previously created database: \\c db_for_golang Create a table named Cities with three fields — city_id, city_name, and city_population: CREATE TABLE Cities ( city_id INT PRIMARY KEY, city_name VARCHAR(45) NOT NULL, city_population INT NOT NULL); Grant full privileges to the created table for the user: GRANT ALL PRIVILEGES ON TABLE cities TO golang; The function db.Prepare is used to prepare data. It specifies the query for insertion in advance. To insert data, use the function stmt.Exec. In Go, it's common to use plain SQL without using the ORM (Object-Relational Mapping) approach. stmt, err := db.Prepare(\"INSERT INTO Cities(city_id, city_name, city_population) VALUES($1, $2, $3)\") if err != nil { log.Fatal(err) } defer stmt.Close() _, err = stmt.Exec(1, \"Toronto\", 279435) if err != nil { log.Fatal(err) } fmt.Println(\"Data inserted successfully!\") } If all works correctly, you will see: Data inserted successfully! Redis and Go To connect to Redis, you need to use the go-redis driver. Сreate a new directory: mkdir connect-to-redis && cd connect-to-redis Prepare the dependency file: go mod init golang-connect-redis And optimize them: go mod tidy Download the go-redis module: go get github.com/go-redis/redis/v8 To connect to Redis, use the redis.Options function to specify the address and port of the Redis server. Since Redis does not use authentication by default, you can leave the Password field empty and use the default database (database 0): package main import ( \"context\" \"fmt\" \"log\" \"github.com/go-redis/redis/v8\" ) func main() { rdb := redis.NewClient(&redis.Options{ Addr: \"91.206.179.128:6379\", Password: \"\", DB: 0, }) ctx := context.Background() _, err := rdb.Ping(ctx).Result() if err != nil { log.Fatalf(\"Couldn't connect to Redis: %v\", err) } fmt.Println(\"Successfully connected to Redis!\") } You should see the message «Successfully connected to Redis!» MongoDB and Go To work with MongoDB, we'll use the mongo driver. Create a new directory to store the project structure: mkdir connect-to-mongodb && cd connect-to-mongodb Initialize the dependency file: go mod init golang-connect-mongodb Download the mongo library: go get go.mongodb.org/mongo-driver/mongo Connect to MongoDB using the options.Client().ApplyURI method. It takes a connection string such as mongodb://91.206.179.29:27017, where 91.206.179.29 is the MongoDB server address and 27017 is the port for connecting to MongoDB. The options.Client().ApplyURI string is used only for specifying connection data. To check the connection status, you can use another function, client.Ping, which shows the success or failure of the connection: package main import ( \"context\" \"fmt\" \"log\" \"time\" \"go.mongodb.org/mongo-driver/mongo\" \"go.mongodb.org/mongo-driver/mongo/options\" ) func main() { clientOptions := options.Client().ApplyURI(\"mongodb://91.206.179.29:27017\") client, err := mongo.Connect(context.TODO(), clientOptions) if err != nil { log.Fatalf(\"Couldn't connect to MongoDB server: %v\", err) } fmt.Println(\"successfully connected to MongoDB!\") ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second) defer cancel() err = client.Ping(ctx, nil) if err != nil { log.Fatalf(\"Could not ping MongoDB server: %v\", err) } fmt.Println(\"Ping MongoDB server successfully!\") } You should see the message: successfully connected to MongoDB!Ping MongoDB server successfully MongoDB uses collections to store data. You can create collections using the .Collection function. Below, we will create a database called first-database and a collection called first-collection. The collection will have a new document, containing three keys: user-name, user-age, and user-email. collection := client.Database(\"first-database\").Collection(\"first-collection\") document := map[string]interface{}{ \"user-name\": \"Alice\", \"user-age\": 25, \"user-email\": \"alice@corporate.com\", } insertResult, err := collection.InsertOne(ctx, document) if err != nil { log.Fatalf(\"Couldn't insert new document: %v\", err) } fmt.Printf(\"Inserted new document with ID: %v\n\n\", insertResult.InsertedID) if err := client.Disconnect(ctx); err != nil { log.Fatalf(\"Could not disconnect from MongoDB: %v\", err) } fmt.Println(\"Disconnected from MongoDB!\") } If successful, you will see the Inserted new document message with the document ID. ClickHouse and Go To work with ClickHouse, use the clickhouse-go driver. Create a new directory to store the project files and navigate to it: clickhouse-connect && cd clickhouse-connect Create a go.mod file to store the dependencies: go mod init golang-connect-clickhouse Download the Clickhouse driver using the command: go get github.com/ClickHouse/clickhouse-go/v2 Create a new file named main.go, where you will specify the connection data to ClickHouse. package main import ( \"database/sql\" \"log\" \"github.com/ClickHouse/clickhouse-go/v2\" ) func main() { dsn := \"tcp://localhost:9000?username=user1&password=PasswordForuser175465&database=new_db\" db, err := sql.Open(\"clickhouse\", dsn) if err != nil { log.Fatal(err) } defer db.Close() if err := db.Ping(); err != nil { log.Fatal(err) } log.Println(\"Connected to ClickHouse!\") } Database Connection in JavaScript In JavaScript, all connections to external services are made using the Node.js platform. Make sure that you have Node.js and the npm package manager installed on your device. MySQL and JavaScript To work with MySQL, use the mysql2 driver. Create a directory where we will store the project files: mkdir js-mysql-connect && cd js-mysql-connect Initialize the project: npm init -y Install the mysql2 library: npm install mysql2 Use the following code to connect to MySQL: const mysql = require('mysql2'); const connection_to_mysql = mysql.createConnection({ host: 'localhost', user: 'root', password: 'PasswordForRoot74463', database: db1, }); connection_to_mysql.connect((err) => { if (err) { console.error('Error connecting to MySQL:', err.message); return; } console.log('Successfully connected to MySQL Server!'); connection_to_mysql.end((endErr) => { if (endErr) { console.error('Error closing the connection_to_mysql:', endErr.message); } else { console.log('Connection closed.'); } }); }); PostgreSQL and JavaScript Connecting to PostgreSQL is done using the pg library. Create a directory where we will store the project files: mkdir js-postgres-connect && cd js-postgres-connect Initialize the project: npm init -y Install the pg library: npm install pg To connect to PostgreSQL, first import the pg library. Then, create a constant where you specify variables for the database address, username, password, database name, and port. Use the new pg.Client class to pass the connection data. We will create a table called cities and add two records into it. To do this, we will use the queryDatabase function, which contains the SQL queries. const pg = require('pg'); const config = { postgresql_server_host: '91.206.179.29', postgresql_user: 'gen_user', postgresql_user_password: 'PasswordForGenUser56467$', postgresql_database_name: 'default_db', postgresql_database_port: 5432, }; const client = new pg.Client(config); client.connect(err => { if (err) throw err; else { queryDatabase(); } }); function queryDatabase() { const query = ` DROP TABLE IF EXISTS cities; CREATE TABLE cities (id serial PRIMARY KEY, name VARCHAR(80), population INTEGER); INSERT INTO cities (name, population) VALUES ('Berlin', 3645000); INSERT INTO cities (name, population) VALUES ('Paris', 2161000); `; client .query(query) .then(() => { console.log('Table created successfully!'); client.end(console.log('Closed client connection')); }) .catch(err => console.log(err)) .then(() => { console.log('Finished execution, exiting now'); process.exit(); }); } Use this command to run the code: node connect-to-postgres.js Redis and JavaScript To work with Redis, use the ioredis library. Create a directory to store the project files: mkdir js-redis-connect && cd js-redis-connect Initialize the project: npm init -y Install the ioredis library: npm install ioredis To connect to Redis, import the ioredis library. Then create a constant named redis and specify the Redis server address. Inserting data, i.e., creating key-value objects, is done using an asynchronous function named setData, which takes two values — key and value, corresponding to the data format of the Redis system. const Redis = require('ioredis'); const redis = new Redis({ host: '91.206.179.29', port: 6379, password: 'UY+p8e?Kxmqqfa', }); async function setData(key, value) { try { await redis.set(key, value); console.log('Data successfully set'); } catch (error) { console.error('Error setting data:', error); } } async function getData(key) { try { const value = await redis.get(key); console.log('Data retrieved'); return value; } catch (error) { console.error('Error getting data:', error); } } (async () => { await redis.select(1); await setData('user', 'alex'); await getData('user'); redis.disconnect(); })(); Run: node connect-to-redis.js MongoDB and JavaScript To work with MongoDB, use the mongodb driver. Create a directory for storing the project files: mkdir js-mongodb-connect && cd js-mongodb-connect Initialize the project: npm init -y Install the mongodb library: npm install mongodb To connect to MongoDB, import the mongodb library. Specify the database address in the constant uri and pass the address into the MongoClient class. const { MongoClient } = require('mongodb'); const uri = \"mongodb://91.206.179.29:27017\"; const client = new MongoClient(uri, { useNewUrlParser: true, useUnifiedTopology: true }); async function connectToDatabase() { try { await client.connect(); console.log(\"Successfully connected to MongoDB!\"); const database = client.db(\"myDatabase\"); const collection = database.collection(\"myCollection\"); const documents = await collection.find({}).toArray(); console.log(\"Documents found:\", documents); } catch (error) { console.error(\"Error connecting to MongoDB:\", error); } finally { await client.close(); console.log(\"Connection closed.\"); } } connectToDatabase(); ClickHouse and JavaScript To work with ClickHouse, use the clickhouse/client driver. Create a directory where we will store the project files: mkdir js-clickhouse-connect && cd js-clickhouse-connect Initialize the project: npm init -y Install the @clickhouse/client library: npm install @clickhouse/client To connect to ClickHouse, use the code below where we set the connection details and execute a simple SQL query that will return the first 10 records from the system table named system.tables: const { ClickHouse } = require('@clickhouse/client'); const client = new ClickHouse({ host: 'http://localhost:8123', username: 'default', password: 'PasswordforDefaultUser45435', database: 'default', }); async function connectAndQuery() { try { console.log('Successfully connected to ClickHouse Server!'); const rows = await client.query({ query: 'SELECT * FROM system.tables LIMIT 10', format: 'JSON', }).then((result) => result.json()); console.log('Query results:', rows); } catch (error) { console.error('Error Successfully connected to ClickHouse Server! or running the query:', error); } finally { console.log('Done.'); } } connectAndQuery(); Conclusion In today's article, we thoroughly explored how to connect to PostgreSQL, Redis, MongoDB, MySQL, and ClickHouse databases using Python, Go, and JavaScript. These languages can be used to create both web applications and microservices that utilize databases in their operation."
    },
    {
        "link": "https://stackoverflow.com/questions/56660756/creating-my-own-array-prototype-map-method-how-can-i-access-the-array",
        "document": "So I am trying to create a method that mimic exactly what the method does and there is a lot I am confused about. The main problem I suppose comes down to its syntax. I know there are many different ways to utilitize the method for instance:\n\nlet say I have an array of objects -\n\nLets say I want to make a function that returns a list of objects that contains only the title of the movie and its imdbRating. In this case, I can use the method:\n\nthe above line of code satisfies what i need to achieve my objective using the map method. However, the syntax can be different for other cases\n\nusing the map function s2 will return an array that has for each element double the value of each element in the s array. Now, going back to the theme of this post, the problem I am working on gave me this outline to start with:\n\nI understand that when an array calls on the method, it is inserting 2 arguments, the array and a function. But I cannot wrap my head around how I can concretely assign the value of each callback function on the element to the in the method. Especially because I do not know how to access the original array.\n\nOne of my attempts that I know is ridiculous because I do not know how I can access the length of the array as well as the array itself which calls on the method-\n\nthe way I've understood the method thus far, is it takes 3 arguments, an array, a function, and the element that will be put thru the function and I do not know the syntax well enough to iterate over the array that calls on the method and nowhere in my course have I been taught how to do this and I have not found any online resource either that offers a solution to this problem."
    }
]