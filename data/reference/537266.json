[
    {
        "link": "https://javadoc.io/doc/com.fasterxml.uuid/java-uuid-generator/4.0.1/com/fasterxml/uuid/Generators.html",
        "document": ""
    },
    {
        "link": "https://javadoc.io/doc/com.fasterxml.uuid/java-uuid-generator/3.1.0/com/fasterxml/uuid/Generators.html",
        "document": ""
    },
    {
        "link": "https://github.com/cowtowncoder/java-uuid-generator/blob/master/src/main/java/com/fasterxml/uuid/impl/TimeBasedGenerator.java",
        "document": "* Implementation of UUID generator that uses time/location based generation\n\n* As all JUG provided implementations, this generator is fully thread-safe.\n\n* Additionally, it can also be made externally synchronized with other\n\n* instances (even ones running on other JVMs); to do this,\n\n* Object used for synchronizing access to timestamps, to guarantee\n\n* that timestamps produced by this generator are unique and monotonically increasings.\n\n* Some implementations offer even stronger guarantees, for example that\n\n* same guarantee holds between instances running on different JVMs (or\n\n* Base values for the second long (last 8 bytes) of UUID to construct\n\n* @param ethAddr Hardware address (802.1) to use for generating\n\n* spatially unique part of UUID. If system has more than one NIC,\n\n* Method that will construct actual {@link UUID} instance for given\n\n* timestamp: called by {@link #generate()} but may alternatively be\n\n* called directly to construct an instance with known timestamp.\n\n// last detail: must force 2 MSB to be '10'"
    },
    {
        "link": "https://cowtowncoder.github.io/java-uuid-generator/javadoc/3.1.3/com/fasterxml/uuid/impl/TimeBasedGenerator.html",
        "document": "Implementation of UUID generator that uses time/location based generation method (variant 1).\n\nAs all JUG provided implementations, this generator is fully thread-safe. Additionally it can also be made externally synchronized with other instances (even ones running on other JVMs); to do this, use (or equivalent)."
    },
    {
        "link": "https://github.com/cowtowncoder/java-uuid-generator",
        "document": "JUG is a set of Java classes for working with UUIDs: generating UUIDs using any of standard methods, outputting efficiently, sorting and so on. It generates UUIDs according to the UUID specification (RFC-9562) (see Wikipedia UUID page for more explanation)\n\nJUG was written by Tatu Saloranta (tatu.saloranta@iki.fi) originally in 2002 and has been updated over the years. In addition, many other individuals have helped fix bugs and implement new features: please see for the complete list.\n\nand newly (in 2022-) proposed (see uuid6 and RFC-9562 variants:\n\nJUG can be used as a command-line tool (via class ), or as a pluggable component.\n\nThe only dependency for JUG is the logging library:\n• For versions up to 3.x, is used, optionally (runtime dependency)\n• For versions 4.x and up, API is used: logging implementation to be provided by calling application\n\nSince version , JUG defines JDK9+ compatible , with module name of .\n\nThe original use case for JUG was generation of UUID values. This is done by first selecting a kind of generator to use, and then calling its method. For example:\n\nIf you want customize generators, you may also just want to hold on to generator instance:\n\nIf your machine has a standard IP networking setup, the (added in JUG 4.2) factory method will try to determine which network interface corresponds to the default route for all outgoing network traffic, and use that for creating a time based generator. This is likely a good choice for common usage scenarios if you want a version 1 UUID generator.\n\nGenerators are fully thread-safe, so a single instance may be shared among multiple threads.\n\nJavadocs for further information can be found from Project Wiki.\n\nSometimes you may want to convert from into external serialization: for example, as s or byte arrays ( ). Conversion to is easy with (provided by JDK), but there is no similar functionality for converting into .\n\nBut class provides methods for efficient conversions:\n\nvalues are often passed as java s or s (byte arrays), and conversion is needed to get to actual instances. JUG has optimized conversion functionality available via class (package ), used as follows:\n\nNote that while JDK has functionality for constructing from , like so:\n\nit is rather slower than JUG version: for more information, read Measuring performance of Java UUID.fromString().\n\ncan also be used as a simple Command-line UUID generation tool.\n\nTo see usage you can do something like:\n\nand get full instructions, but to generate 5 Random-based UUIDs, you would use:\n\nNOTE: this functionality is included as of JUG 4.1 -- with earlier versions you would need a bit longer invocation as Jar metadata did not specify \"Main-Class\". If so, you would need to use\n\nJUG versions 3.1 and later require JDK 1.6 to work, mostly to be able to access local Ethernet MAC address. Earlier versions (3.0 and before) worked on 1.4 (which introduced ).\n\nJUG versions 5.0 and later require JDK 8 to work.\n\nJDK's has flawed implementation of , which uses naive comparison of 64-bit values. This does NOT work as expected, given that underlying content is for all purposes unsigned. For example two UUIDs:\n\nwould be ordered with second one first, due to sign extension (second value is considered to be negative, and hence \"smaller\").\n\nBecause of this, you should always use external comparator, such as , which implements expected sorting order that is simple unsigned sorting, which is also same as lexicographic (alphabetic) sorting of UUIDs (when assuming uniform capitalization).\n\nAvailable as part of the Tidelift Subscription.\n\nThe maintainers of and thousands of other packages are working with Tidelift to deliver commercial support and maintenance for the open source dependencies you use to build your applications. Save time, reduce risk, and improve code health, while paying the maintainers of the exact dependencies you use. Learn more.\n\nFor simple bug reports and fixes, and feature requests, please simply use projects Issue Tracker, with exception of security-related issues for which we recommend filing Tidelift security contact (NOTE: you do NOT have to be a subscriber to do this).\n\nThere are many other publicly available UUID generators. For example:\n• JDK has included since 1.4, but omits generation methods (esp. time/location based ones), has sub-standard performance for many operations and implements comparison in useless way\n\nNote that although some packages claim to be faster than others, it is not clear:\n• whether claims have been properly verified (or, if they have, can be independently verified), OR\n• whether performance differences truly matter: JUG, for example, can generate millions of UUID per second per core (sometimes hitting the theoretical limit of 10 million per second) -- and it seems unlikely that generation will be bottleneck for any actual use case\n\nso it is often best to choose based on stability of packages and API."
    },
    {
        "link": "https://stackoverflow.com/questions/18244897/how-to-generate-time-based-uuids",
        "document": "Version 1 UUIDs actually represent a point in space and in time.\n\nThe \"space\" part is the MAC address taken from the networking port of the computer to uniquely identify where the id was generated (nearly unique, there have been some infamous screw-ups in assigning MAC addresses by the networking hardware manufacturers).\n\nThe \"time\" part is a 60-bit timestamp, being the number of 100-nanosecond intervals since midnight 15 October 1582 Coordinated Universal Time (UTC).\n\nAs you have noticed, no implementation of Version 1 UUID is required by the Java specifications.\n\nPresumably this is because of the security and privacy concerns from potentially divulging your MAC address and the moment of creation.\n\nAs seen on the other Answers, there are 3rd-party implementations of Version 1 UUIDs available.\n\nAsking for library recommendations is off-topic here on Stack Overflow. So I asked on the sister site, Software Recommendations Stack Exchange, the question Library to generate Version 1 UUIDs to be called from Java.\n\nAnd here is a condensed list of the implementations mentioned in other Answers here and elsewhere that seem to still be actively supported.\n• or class source code, part of the Apache Cassandra project. This source code is published under the Apache 2 license.\n\nFYI, work has been underway in recent years to define new versions of UUID. The most critically important is Version 6, rearranging the date-time bits to make them friendlier to database indexing."
    },
    {
        "link": "https://baeldung.com/java-generating-time-based-uuids",
        "document": "In this article, we’ll learn about UUIDs and time-based UUIDs.\n\nWe’ll see the advantages and disadvantages of time-based UUIDs and when to choose them.\n\nWe’ll also explore and compare some libraries that will help us implement these different algorithms for producing UUIDs.\n\nUUID stands for Universally Unique Identifier. It’s a 128-bit identifier expected to be unique every time we generate it.\n\nWe use them to identify something uniquely, even if that thing has no inherent identifier. We can use them in various contexts, such as computer systems, databases, and distributed systems, where we require unique identification of objects.\n\nThe likelihood of two UUIDs being the same is so tiny that it is considered statistically impossible, making them a reliable way to identify objects in distributed systems.\n\nA time-based UUID, also known as the version 1 UUID, is generated using the current time and a unique identifier specific to the computer or network that produces the UUID. The timestamp ensures the UUID is unique, even if multiple UUIDs are generated simultaneously.\n\nWe’ll find two new versions of the standard (v6 and v7) that are time-related in the libraries implemented below.\n\nVersion 1 presents several advantages – the time sorted id is fitter to be a primary key in a table, and containing the creation timestamp can help with analysis and debugging. It also has some disadvantages – the chance of collision is slightly higher when generating multiple IDs from the same host. We’ll see if this is an issue later on.\n\nAlso, including the host address may present some security flaws, which is why version 6 of the standard attempted to improve security.\n\nTo make our comparison more straightforward, let’s write a benchmark program to compare the chance of collision and the generation time of the UUIDs. We start by initializing all the necessary variables:\n\nWe’ll run the benchmark on a number of 128 threads with 100.000 iterations each. Also, we’ll use a ConcurentHashMap to store all UUID generated. Besides that, we’ll use a counter for the collisions. To check the speed performance, we store the current timestamp at the start of execution to compare it with the timestamp at the final. And, at the final, we declare a latch to wait for all threads to finish.\n\nAfter initializing all the variables necessary for our test, we’ll loop and start every thread:\n\nFor every line of execution, we’ll integrate again and start generating UUIDs using java.util.UUID class. We’ll insert all the ids with their corresponding count in the map. The UUID will be the key of the map.\n\nSo, if we try to insert an existing UUID in the map, the put() method will return us the already existing key. When we get a duplicate UUID, we’ll increment the collision count. At the end of the iteration, we’ll decrement the countdown.\n\nIn the end, we’ll use the await() method of the CountDownLatch class to wait until all threads are finished. We’ll print the result of our benchmark consisting of the number of UUIDs generated, the number of collisions, and the execution time.\n\nNow, let’s run the benchmark against the JDK’s built-in UUID generator:\n\nWe can see that all ids were generated without collision. In the following sections, we’ll compare this with the other generators.\n\nThe Java UUID Creator library is valuable and flexible for generating UUIDs. It provides various options for generating UUIDs, and its simple API makes it easy to use in a wide range of applications. We can add the library to our project:\n\nThis library provides us with three ways to generate time-based UUIDs:\n• UuidCreator.getTimeBased() – the time-based version with gregorian epoch specified in RFC-4122\n• UuidCreator.getTimeOrdered() – the time-ordered version with gregorian epoch proposed as a new UUID format\n• UuidCreator.getTimeOrderedEpoch() – the time-ordered version with Unix epoch proposed as a new UUID format\n\nWe can use them directly in our code after adding the dependency:\n\nAnd we can see in the output that all three have the same classic UUID format:\n\nThis article will focus on the getTimeBased() method that uses the traditional version 1 UUID. It has three parts: timestamp, clock sequence, and node identifier.\n\nIn this section, we’ll run the benchmark from the previous part, but we’ll generate de UUIDs with the UuidCreator.getTimeBased() method. After that, we get the result:\n\nWe can see that this algorithm also managed to generate all the UUIDs without duplicates. Besides this, it even managed to get a better time than the JDK one. This is just a basic benchmark, though there are more detailed benchmarks available.\n\nJava UUID Generator (JUG) is a set of Java classes for working with UUIDs. It includes generating UUIDs using standard methods, efficiently outputting, sorting, etc. It generates UUIDs according to the UUID specification (RFC-4122).\n\nTo use the library, we should add the Maven dependency:\n\nThis library also provides three methods to create time-based UUIDs (the classic version 1 and the new versions 6 and 7). We can generate them by selecting a kind of generator and then calling its generate() method:\n\nThen we can check the UUIDs in the console:\n\nLike the previous section, we’ll focus on the first variant of UUID offered by this library. We can also test the chance of a collision by replacing the generation of the UUID from the previous example with the following:\n\nAnd after running the code, we can see the results:\n\nFrom this, we can see that we also got no duplicates of UUID, like in the previous example. But also, we see a difference in the execution time. Even if the difference seems large, both libraries generated many IDs quickly.\n\nThe documentation of this library tells us that generation speed is unlikely to be a bottleneck, and choosing based on the stability of packages and API is better.\n\nIn this tutorial, we saw the time-based UUIDs’ structure, advantages, and disadvantages. We implemented them in our code using two of the most popular libraries for UUIDs and compared them afterward.\n\nWe saw that choosing a type of UUID or library might depend on our needs."
    },
    {
        "link": "https://github.com/cowtowncoder/java-uuid-generator",
        "document": "JUG is a set of Java classes for working with UUIDs: generating UUIDs using any of standard methods, outputting efficiently, sorting and so on. It generates UUIDs according to the UUID specification (RFC-9562) (see Wikipedia UUID page for more explanation)\n\nJUG was written by Tatu Saloranta (tatu.saloranta@iki.fi) originally in 2002 and has been updated over the years. In addition, many other individuals have helped fix bugs and implement new features: please see for the complete list.\n\nand newly (in 2022-) proposed (see uuid6 and RFC-9562 variants:\n\nJUG can be used as a command-line tool (via class ), or as a pluggable component.\n\nThe only dependency for JUG is the logging library:\n• For versions up to 3.x, is used, optionally (runtime dependency)\n• For versions 4.x and up, API is used: logging implementation to be provided by calling application\n\nSince version , JUG defines JDK9+ compatible , with module name of .\n\nThe original use case for JUG was generation of UUID values. This is done by first selecting a kind of generator to use, and then calling its method. For example:\n\nIf you want customize generators, you may also just want to hold on to generator instance:\n\nIf your machine has a standard IP networking setup, the (added in JUG 4.2) factory method will try to determine which network interface corresponds to the default route for all outgoing network traffic, and use that for creating a time based generator. This is likely a good choice for common usage scenarios if you want a version 1 UUID generator.\n\nGenerators are fully thread-safe, so a single instance may be shared among multiple threads.\n\nJavadocs for further information can be found from Project Wiki.\n\nSometimes you may want to convert from into external serialization: for example, as s or byte arrays ( ). Conversion to is easy with (provided by JDK), but there is no similar functionality for converting into .\n\nBut class provides methods for efficient conversions:\n\nvalues are often passed as java s or s (byte arrays), and conversion is needed to get to actual instances. JUG has optimized conversion functionality available via class (package ), used as follows:\n\nNote that while JDK has functionality for constructing from , like so:\n\nit is rather slower than JUG version: for more information, read Measuring performance of Java UUID.fromString().\n\ncan also be used as a simple Command-line UUID generation tool.\n\nTo see usage you can do something like:\n\nand get full instructions, but to generate 5 Random-based UUIDs, you would use:\n\nNOTE: this functionality is included as of JUG 4.1 -- with earlier versions you would need a bit longer invocation as Jar metadata did not specify \"Main-Class\". If so, you would need to use\n\nJUG versions 3.1 and later require JDK 1.6 to work, mostly to be able to access local Ethernet MAC address. Earlier versions (3.0 and before) worked on 1.4 (which introduced ).\n\nJUG versions 5.0 and later require JDK 8 to work.\n\nJDK's has flawed implementation of , which uses naive comparison of 64-bit values. This does NOT work as expected, given that underlying content is for all purposes unsigned. For example two UUIDs:\n\nwould be ordered with second one first, due to sign extension (second value is considered to be negative, and hence \"smaller\").\n\nBecause of this, you should always use external comparator, such as , which implements expected sorting order that is simple unsigned sorting, which is also same as lexicographic (alphabetic) sorting of UUIDs (when assuming uniform capitalization).\n\nAvailable as part of the Tidelift Subscription.\n\nThe maintainers of and thousands of other packages are working with Tidelift to deliver commercial support and maintenance for the open source dependencies you use to build your applications. Save time, reduce risk, and improve code health, while paying the maintainers of the exact dependencies you use. Learn more.\n\nFor simple bug reports and fixes, and feature requests, please simply use projects Issue Tracker, with exception of security-related issues for which we recommend filing Tidelift security contact (NOTE: you do NOT have to be a subscriber to do this).\n\nThere are many other publicly available UUID generators. For example:\n• JDK has included since 1.4, but omits generation methods (esp. time/location based ones), has sub-standard performance for many operations and implements comparison in useless way\n\nNote that although some packages claim to be faster than others, it is not clear:\n• whether claims have been properly verified (or, if they have, can be independently verified), OR\n• whether performance differences truly matter: JUG, for example, can generate millions of UUID per second per core (sometimes hitting the theoretical limit of 10 million per second) -- and it seems unlikely that generation will be bottleneck for any actual use case\n\nso it is often best to choose based on stability of packages and API."
    },
    {
        "link": "https://stackoverflow.com/questions/69117931/how-to-get-timebaseduuid-using-fasterxml-for-a-specific-date-or-for-24hrs-before",
        "document": "You can override the UUIDClock to return a date 24 hours before. The author explicitly allows overriding that class.\n\nThis is an exemple using your code:\n\nThis example can generate UUIDs for specific time or for 24h before using fasterxml and java-8.\n\nIf you can add another dependency to your project, maybe you can use uuid-creator. This is another example with 2 lines:"
    },
    {
        "link": "https://mccue.dev/pages/12-21-23-java-library-of-the-day-21",
        "document": ""
    }
]