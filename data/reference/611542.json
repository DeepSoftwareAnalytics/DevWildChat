[
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/round",
        "document": "If the fractional portion of the argument is greater than 0.5, the argument is rounded to the integer with the next higher absolute value. If it is less than 0.5, the argument is rounded to the integer with the lower absolute value. If the fractional portion is exactly 0.5, the argument is rounded to the next integer in the direction of +∞.\n\nNote: This differs from many languages' functions, which often round half-increments away from zero, giving a different result in the case of negative numbers with a fractional part of exactly 0.5.\n\nis not exactly the same as . When is -0, or -0.5 ≤ x < 0, returns -0, while returns 0. However, neglecting that difference and potential precision errors, and are generally equivalent.\n\nBecause is a static method of , you always use it as , rather than as a method of a object you created ( has no constructor)."
    },
    {
        "link": "https://w3schools.com/jsref/jsref_round.asp",
        "document": "W3Schools offers a wide range of services and products for beginners and professionals, helping millions of people everyday to learn and master new skills."
    },
    {
        "link": "https://sitepoint.com/rounding-numbers-javascript",
        "document": "In this article, we’ll explore various ways of rounding numbers in JavaScript. This will include using JavaScript math functions, and other methods for rounding to decimal places. We’ll also cover gotchas to watch out for when rounding numbers.\n• JavaScript provides several methods for rounding numbers, including Math.round, Math.floor, Math.ceil, and Math.trunc. Math.round rounds to the nearest integer, Math.floor rounds down, Math.ceil rounds up, and Math.trunc truncates the decimal part of the number.\n• For rounding numbers to a certain number of decimal places or significant figures, JavaScript offers Number.toFixed and Number.toPrecision methods. These methods return the rounded number as a string.\n• Math.round, Math.floor, Math.ceil, and Math.trunc behave differently when dealing with negative numbers. For instance, Math.floor rounds a negative number down to the next lowest integer, while Math.trunc truncates the decimal part, effectively rounding it up.\n• Precision issues can occur in JavaScript due to the binary representation of numbers. Some base 10 numbers can’t be accurately represented in base 2, causing rounding errors. The Math.fround method can be used to find the closest representable number in 32-bits.\n• The choice of rounding method depends on the specific use case. Math.round is a good general choice for rounding to the nearest integer, but Math.floor, Math.ceil, or Math.trunc might be better for always rounding down or up, or dealing with negative numbers. Number.toFixed or Number.toPrecision should be used for rounding to a specific number of decimal places or significant figures.\n\nWhen dealing with numerical values, we can sometimes perform calculations that end up with fractional parts that need rounding to a whole number — such as when you’re working out an average price, or dealing with random numbers. Thankfully, JavaScript’s object provides a number of ways to round numbers to an integer value.\n\nIn our examples, we’ll use two of the most important mathematical constants to demonstrate different types of rounding: Pi, which is the ratio of the circumference of a circle to its diameter, and e, which is the base of natural logarithms and also known as “Euler’s number”. Both of these values are properties of the object, but let’s assign them to some variables to make them easier to deal with:\n\nPro tip: you can also make this assignment in a single line using object destructuring:\n\nNow we have these constants defined, let’s take a look at some of the methods for rounding numbers in JavaScript.\n\nThe first method we’ll look at is . This is the most straightforward option, and simply rounds any number with a decimal part to the nearest integer. It uses this rule: if a number is exactly halfway between two integers, it will be rounded up. For example, 2.5 will round up to 3.\n\nTo use this method, we simply provide the number we want to round as the argument:\n\ncomes in handy if you want to round a number to the nearest integer value. For example, if you were calculating the average score over three tests, you’d add the three scores up and divide by three. This might not result in a whole number, so you’d use to round it to the closest value:\n\nThe next method we’ll look at is . This always rounds a value down to the integer below (the name implies the number is being pushed down to the floor):\n\nA common use of is when creating random integers . Rounding down ensures that the integer will start at zero and that each integer will have an equal chance of being returned. Starting at zero is generally useful, as arrays in JavaScript are zero-indexed, so rounding down will make sure that the first element in the array could be selected. The example below shows how a random element could be selected from an array using :\n\nRounding down using in the code above ensures that an index between 0 and 4 is returned, so every element in the array has an equal chance of being selected.\n\nSpeaking of rounding up, this is exactly what does. The name comes from ceiling and is the opposite of floor, implying the value is going up. The method works in the same way as all the others. Just provide the number you want to round up as an argument:\n\nBut when would you need to round a number up? A common usage is if you need to work out how many containers you need for something. For example, say you have a music site that includes playlists, and each playlist has ten songs on it. If somebody uploads 82 songs, you need to work out how many playlists to create. This is done by dividing the number of songs by (the number of songs on each playlist):\n\nUsing would round this down to … but then we wouldn’t have a playlist for the last two songs! In cases like this, we always need to round up in order to have an extra container for any remainders:\n\nThe next method we’ll look at is . This isn’t strictly speaking a rounding function; it actually truncates the number provided as an argument. It basically just removes the decimal part of the number, leaving just the integer part, as can be seen in the examples below:\n\nAt first glance, seems to be identical to ; certainly the examples given so far all give the same results. These two methods behave differently, however, when a negative value is provided as an argument, as can be seen in the example below:\n\nThe difference occurs because, when a negative number is rounded down using , it goes down to the next lowest integer, whereas truncating a negative value is the equivalent of rounding it up.\n\nreturns the same value as when the argument is a negative number:\n\nAll of these methods can be very useful, but they have the limitation that they always return integer values. What if we want to round a number to a certain number of decimal places or significant figures?\n\nWe’ve already seen that will round numbers to the nearest integer. Unfortunately, the object doesn’t provide any methods to round numbers more accurately to a certain number of decimal places. Thankfully, the type has a couple of built-in methods that can do this. Let’s take a look at them.\n\nThis is a number method, which means that it’s called by the number itself. It rounds a decimal number to a given number of decimal places, which is provided as an argument:\n\nOne thing to note is that the value is returned as a string. You can get around this by wrapping the method call in the function, which will convert the result back into a number:\n\nSomething else to watch out for: if you try to apply this method to a number that’s already an integer, you’ll get an error if you just use a single dot to call the method:\n\nYou can’t call methods on integers using a single dot, because it isn’t clear if the dot is a method call operator or a decimal point. To get around this, you can either place the integer in parentheses or use two dots so that it’s clear that you’re calling a method rather than writing out a number literal with a decimal point:\n\nIf no argument is provided, the number will be rounded to the nearest integer (but returned as a string):\n\nA common use case for rounding to a set number of decimal places is when dealing with currency — for example, if you want to provide the price of something in US dollars to the nearest cent. Let’s say you had an ecommerce site that was running a promotion of 15% off anything in the shopping cart. The discounted price might need rounding before it’s displayed:\n\nThis can easily be fixed using :\n\nNote: for more on issues you might face with , see Number().toFixed() Rounding Errors: Broken But Fixable.\n\nThe method works in a similar way to the method, but it rounds numbers to a fixed number of significant figures.\n\nIf you need a quick reminder of significant figures, it basically means to only use the first non-zero digits. For large numbers, the final answer will also be padded out with zeroes as well. For example, the number 53,863 rounded to two significant figures will become 54,000. This is because 5 and 3 are the first two non-zero digits, and it rounds up because the next digit is 8. We need to add zeroes at the end to ensure the rounded value is a reasonable approximation to the original number.\n\nYou can also round decimals in a similar way. For example, 0.00000623978 will round to 0.0000062 to two significant figures because 6 and 2 are the first non-zero digits and it rounds down because the next digit is 3.\n\nTo use this method, simply call it on the number, providing the number of significant figures as an argument (remember that integers need to be placed in parentheses before calling a method on them):\n\nNote that all values are returned as strings, and exponential notation can be used — such as “5.4e+4” instead of “54000”.\n\nAs before, we can ensure that a number is returned by wrapping the method call in the function:\n\nA common use for rounding to a given number of significant figures is when you’re dealing with large numbers and you’re not sure just how big they’re going to be. For example, say you want to report how many times your latest post has been “liked”, do you round it to the nearest 10, 100 or 1000? In a way, this depends how popular it is; you don’t want to round it to the nearest 100 if it only gets 8 likes, but if it gets thousands of likes then it seems silly to round it to the nearest 10. The solution is to round it to one significant figure:\n\nThere are a few things to watch out for when rounding numbers in JavaScript (or any programming language, for that matter). As you probably know, computers store all data — including numbers — as a binary representation. JavaScript stores numbers as 32-bit single precision binary values.\n\nThe problem with this is that some base 10 numbers can’t be accurately represented in base 2. This doesn’t usually cause any problems, but it does cause some strange results such as this:\n\nThis is because 0.1 and 0.2 can’t be represented exactly in binary, and a slight error is made when adding them up.\n\nThe object has another method called , which returns the closest number that can be represented using 32-bits. For example, 0.6125 can be represented exactly in binary as 0.101, so this will return the same value:\n\nBut, as we saw above, 0.1 can’t be represented exactly in 32-bits. shows us the closest number that can be represented:\n\nAs you can see, it’s very close to 0.1, but very slightly higher. In most practical cases, this won’t cause any problems, but it can occasionally cause some strange behavior when you try to round some numbers:\n\nThis happens because the decimal 3.55 can’t be accurately represented in using 32-bits. We can use to see how it’s actually represented:\n\nAs you can see, it’s actually represented by the floating point number 3.549999952316284, which rounds down to 3.5.\n\nThese problems with rounding numbers in JavaScript don’t occur too often, but they’re definitely something you should be aware of if you’re doing a lot of rounding — especially when it’s important that the result is accurate.\n\nWhich Methods Should I Use for Rounding Numbers?\n\nWith all the rounding methods presenting in this rounding roundup, you might be asking which is the best to use. As always, the answer is, “It depends”.\n\nIf you simply want to round a number to the nearest integer, you can’t go far wrong with , but you should also consider using or if you always want to round down or up, regardless of what the decimal part is. And consider using instead if you’re also planning on rounding negative numbers.\n\nIf you need to round to a given number of decimal places or significant figures, you’ll have to use or . But be aware that these two methods are called by the number and return a string.\n\nYou can see an example of all the different types of rounding covered in this article in the following CodePen demo.\n\nSee the Pen \n\n SitePoint Rounding by SitePoint (@SitePoint)\n\n on CodePen.\n\nWith all these different methods available, you should have no problem rounding numbers from now on.\n\nIf you found this article useful, you may also like these:\n• Quick Tip: How to Convert Numbers to Ordinals in JavaScript"
    },
    {
        "link": "https://shecodes.io/athena/102649-how-to-use-math-round-function-in-javascript",
        "document": "const toggleInfo = (index, event) => { setVisibleLightIndexes((prev) => { if (prev.includes(index)) { return prev.filter((i) => i !== index); } else { return [...prev, index]; } }); const clickedElement = event.target.closest(\".chauvetLights\"); if (clickedElement) { clickedElement.classList.toggle(\"expanded\"); } toggleBackgroundColor(event); }; TypeError: Cannot read properties of undefined (reading 'target') at k (home-OO3WpeNb.js:1:102576) at onClick (home-OO3WpeNb.js:1:104620) at Object.Em (index-h-qGlws7.js:38:9852) at km (index-h-qGlws7.js:38:10006) at Cm (index-h-qGlws7.js:38:10063) at Wa (index-h-qGlws7.js:38:31422) at fd (index-h-qGlws7.js:38:31839) at index-h-qGlws7.js:38:36751 at Vs (index-h-qGlws7.js:41:36768) at Df (index-h-qGlws7.js:38:8988)\n\nAdd a value attribute to both radio buttons. For convenience, set the button's value attribute to the same value as its id attribute."
    },
    {
        "link": "https://docs.vultr.com/javascript/standard-library/Math/round",
        "document": "The function in JavaScript is a method used to round a number to the nearest integer. This method is essential when you need to eliminate the decimal parts of numbers during calculations, which is particularly useful in financial transactions, score calculations in games, and data analysis where precision to whole numbers is required.\n\nIn this article, you will learn how to effectively utilize the function in your JavaScript projects. Explore practical examples that demonstrate how this function behaves with different types of numeric inputs, including positive numbers, negative numbers, and decimals.\n• None Consider a positive decimal number that you want to round to the nearest integer.\n• None Use the function to perform the rounding operation. This code rounds the number down to because is less than .\n• None Apply the to see how it handles negative values. In this case, rounds up to because is closer to than to .\n• None Sometimes, rounding to the nearest integer isn't sufficient, and you might need to round to the nearest ten or hundred.\n• None Combine with multiplication and division to achieve this. This script takes , divides it by to shift the decimal place, rounds it, and then multiplies it back by . The result is .\n• None Edge cases include numbers exactly halfway between two integers.\n• For , the function rounds up to , and for , it rounds up to , demonstrating that applies the round half up strategy.\n\nin JavaScript serves as a straightforward yet powerful tool for rounding numbers to the nearest integer. Its versatility extends from basic rounding of positive and negative values to more complex scenarios where arithmetic manipulation is required for rounding to tens, hundreds, or beyond. Understanding how to apply these techniques allows for precise value control in your applications, ensuring that numerical data conforms to desired accuracy standards. Employ strategically to maintain clarity and efficiency in your numerical computations."
    },
    {
        "link": "https://stackoverflow.com/questions/15762768/javascript-math-round-to-two-decimal-places",
        "document": "NOTE - See Edit 4 if 3 digit precision is important\n\ntoFixed will round up or down for you depending on the values beyond 2 decimals.\n\nEdit - As mentioned by others this converts the result to a string. To avoid this:\n\nEdit 2- As also mentioned in the comments this function fails in some precision, in the case of 1.005 for example it will return 1.00 instead of 1.01. If accuracy to this degree is important I've found this answer: https://stackoverflow.com/a/32605063/1726511 Which seems to work well with all the tests I've tried.\n\nThere is one minor modification required though, the function in the answer linked above returns whole numbers when it rounds to one, so for example 99.004 will return 99 instead of 99.00 which isn't ideal for displaying prices.\n\nEdit 3 - Seems having the toFixed on the actual return was STILL screwing up some numbers, this final edit appears to work. Geez so many reworks!\n\nSee Fiddle example here: https://jsfiddle.net/calder12/3Lbhfy5s/\n\nEdit 4 - You guys are killing me. Edit 3 fails on negative numbers, without digging into why it's just easier to deal with turning a negative number positive before doing the rounding, then turning it back before returning the result."
    },
    {
        "link": "https://stackoverflow.com/questions/11832914/how-to-round-to-at-most-2-decimal-places-if-necessary",
        "document": "Suppose we have a function, , that takes a float as an argument and returns a value rounded to 2 decimal places. What should each of these expressions evaluate to?\n\nThe 'obvious' answer is that the first example should round to 0.01 (because it's closer to 0.01 than to 0.02) while the other two should round to 0.02 (because 0.0150000000000000001 is closer to 0.02 than to 0.01, and because 0.015 is exactly halfway between them and there is a mathematical convention that such numbers get rounded up).\n\nThe catch, which you may have guessed, is that cannot possibly be implemented to give those obvious answers, because all three numbers passed to it are the same number. IEEE 754 binary floating point numbers (the kind used by JavaScript) can't exactly represent most non-integer numbers, and so all three numeric literals above get rounded to a nearby valid floating point number. This number, as it happens, is exactly\n\nwhich is closer to 0.01 than to 0.02.\n\nYou can see that all three numbers are the same at your browser console, Node shell, or other JavaScript interpreter. Just compare them:\n\nSo when I write , the exact value of that I end up with is closer to than it is to . And yet, if I convert to a String...\n\n... I get 0.015, which should round to 0.02, and which is noticeably not the 56-decimal-place number I earlier said that all of these numbers were exactly equal to. So what dark magic is this?\n\nThe answer can be found in the ECMAScript specification, in section 7.1.12.1: ToString applied to the Number type. Here the rules for converting some Number m to a String are laid down. The key part is point 5, in which an integer s is generated whose digits will be used in the String representation of m:\n\nThe key part here is the requirement that \"k is as small as possible\". What that requirement amounts to is a requirement that, given a Number , the value of must have the least possible number of digits while still satisfying the requirement that . Since we already know that , it's now clear why must be true.\n\nOf course, none of this discussion has directly answered what should return. If 's exact value is 0.01499999999999999944488848768742172978818416595458984375, but its String representation is '0.015', then what is the correct answer - mathematically, practically, philosophically, or whatever - when we round it to two decimal places?\n\nThere is no single correct answer to this. It depends upon your use case. You probably want to respect the String representation and round upwards when:\n• The value being represented is inherently discrete, e.g. an amount of currency in a 3-decimal-place currency like dinars. In this case, the true value of a Number like 0.015 is 0.015, and the 0.0149999999... representation that it gets in binary floating point is a rounding error. (Of course, many will argue, reasonably, that you should use a decimal library for handling such values and never represent them as binary floating point Numbers in the first place.)\n• The value was typed by a user. In this case, again, the exact decimal number entered is more 'true' than the nearest binary floating point representation.\n\nOn the other hand, you probably want to respect the binary floating point value and round downwards when your value is from an inherently continuous scale - for instance, if it's a reading from a sensor.\n\nThese two approaches require different code. To respect the String representation of the Number, we can (with quite a bit of reasonably subtle code) implement our own rounding that acts directly on the String representation, digit by digit, using the same algorithm you would've used in school when you were taught how to round numbers. Below is an example which respects the OP's requirement of representing the number to 2 decimal places \"only when necessary\" by stripping trailing zeroes after the decimal point; you may, of course, need to tweak it to your precise needs.\n\nThe function above is probably what you want to use to avoid users ever witnessing numbers that they have entered being rounded wrongly.\n\nBut what if you have the second kind of Number - a value taken from a continuous scale, where there's no reason to think that approximate decimal representations with fewer decimal places are more accurate than those with more? In that case, we don't want to respect the String representation, because that representation (as explained in the spec) is already sort-of-rounded; we don't want to make the mistake of saying \"0.014999999...375 rounds up to 0.015, which rounds up to 0.02, so 0.014999999...375 rounds up to 0.02\".\n\nHere we can simply use the built-in method. Note that by calling on the String returned by , we get a Number whose String representation has no trailing zeroes (thanks to the way JavaScript computes the String representation of a Number, discussed earlier in this answer)."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/pow",
        "document": "is equivalent to the operator, except only accepts numbers.\n\n(and the equivalent ) is the only case where doesn't propagate through mathematical operations — it returns despite the operand being . In addition, the behavior where is 1 and is non-finite (±Infinity or ) is different from IEEE 754, which specifies that the result should be 1, whereas JavaScript returns to preserve backward compatibility with its original behavior.\n\nBecause is a static method of , use it as , rather than as a method of a object you created ( is not a constructor)."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/round",
        "document": "If the fractional portion of the argument is greater than 0.5, the argument is rounded to the integer with the next higher absolute value. If it is less than 0.5, the argument is rounded to the integer with the lower absolute value. If the fractional portion is exactly 0.5, the argument is rounded to the next integer in the direction of +∞.\n\nNote: This differs from many languages' functions, which often round half-increments away from zero, giving a different result in the case of negative numbers with a fractional part of exactly 0.5.\n\nis not exactly the same as . When is -0, or -0.5 ≤ x < 0, returns -0, while returns 0. However, neglecting that difference and potential precision errors, and are generally equivalent.\n\nBecause is a static method of , you always use it as , rather than as a method of a object you created ( has no constructor)."
    },
    {
        "link": "https://medium.com/@ryan_forrester_/how-to-round-to-2-decimal-places-in-javascript-053a869b2ce8",
        "document": "The method formats a number using fixed-point notation. It returns a string representation of the number rounded to a specified number of decimal places.\n• Use when you need a string representation of the rounded number.\n• Be aware that returns a string, not a number.\n\nrounds a number to the nearest integer. To round to a specific number of decimal places, you can multiply the number, round it, and then divide it.\n• Use for a more precise numerical result.\n• This method returns a number, making it suitable for further calculations.\n\nThe method formats a number to a specified length. It can be useful when you need a specific number of significant digits.\n• Use when working with significant digits rather than decimal places.\n• Ensure the output meets your precision requirements, as it might not always align with decimal place rounding.\n\nCreating a custom helper function can provide more control and clarity for rounding operations.\n• Encapsulate rounding logic in a helper function for reusability and maintainability.\n\nFirst, install the library using npm:\n\nThen, use it in your JavaScript code:\n• Use external libraries like for robust and tested utility functions.\n• Ensure you only include necessary library components to keep your codebase lean."
    }
]