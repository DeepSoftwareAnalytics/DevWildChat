[
    {
        "link": "https://css-tricks.com/snippets/css/a-guide-to-flexbox",
        "document": "The (Flexible Box) module (a W3C Candidate Recommendation as of October 2017) aims at providing a more efficient way to lay out, align and distribute space among items in a container, even when their size is unknown and/or dynamic (thus the word “flex”). The main idea behind the flex layout is to give the container the ability to alter its items’ width/height (and order) to best fill the available space (mostly to accommodate to all kind of display devices and screen sizes). A flex container expands items to fill available free space or shrinks them to prevent overflow. Most importantly, the flexbox layout is direction-agnostic as opposed to the regular layouts (block which is vertically-based and inline which is horizontally-based). While those work well for pages, they lack flexibility (no pun intended) to support large or complex applications (especially when it comes to orientation changing, resizing, stretching, shrinking, etc.). Note: Flexbox layout is most appropriate to the components of an application, and small-scale layouts, while the Grid layout is intended for larger scale layouts.\n\nSince flexbox is a whole module and not a single property, it involves a lot of things including its whole set of properties. Some of them are meant to be set on the container (parent element, known as “flex container”) whereas the others are meant to be set on the children (said “flex items”). If “regular” layout is based on both block and inline flow directions, the flex layout is based on “flex-flow directions”. Please have a look at this figure from the specification, explaining the main idea behind the flex layout. Items will be laid out following either the (from to ) or the cross axis (from to ).\n• main axis – The main axis of a flex container is the primary axis along which flex items are laid out. Beware, it is not necessarily horizontal; it depends on the property (see below).\n• main-start | main-end – The flex items are placed within the container starting from main-start and going to main-end.\n• main size – A flex item’s width or height, whichever is in the main dimension, is the item’s main size. The flex item’s main size property is either the ‘width’ or ‘height’ property, whichever is in the main dimension.\n• cross axis – The axis perpendicular to the main axis is called the cross axis. Its direction depends on the main axis direction.\n• cross-start | cross-end – Flex lines are filled with items and placed into the container starting on the cross-start side of the flex container and going toward the cross-end side.\n• cross size – The width or height of a flex item, whichever is in the cross dimension, is the item’s cross size. The cross size property is whichever of ‘width’ or ‘height’ that is in the cross dimension.\n\nThis defines a flex container; inline or block depending on the given value. It enables a flex context for all its direct children. Note that CSS columns have no effect on a flex container. \n\nThis establishes the main-axis, thus defining the direction flex items are placed in the flex container. Flexbox is (aside from optional wrapping) a single-direction layout concept. Think of flex items as primarily laying out either in horizontal rows or vertical columns.\n• (default): left to right in ; right to left in\n• : right to left in ; left to right in\n• : same as but top to bottom\n• : same as but bottom to top By default, flex items will all try to fit onto one line. You can change that and allow the items to wrap as needed with this property.\n• (default): all flex items will be on one line\n• : flex items will wrap onto multiple lines, from top to bottom.\n• : flex items will wrap onto multiple lines from bottom to top. There are some visual demos of here. This is a shorthand for the and properties, which together define the flex container’s main and cross axes. The default value is . \n\nThis defines the alignment along the main axis. It helps distribute extra free space leftover when either all the flex items on a line are inflexible, or are flexible but have reached their maximum size. It also exerts some control over the alignment of items when they overflow the line.\n• (default): items are packed toward the start of the flex-direction.\n• : items are packed toward the end of the flex-direction.\n• : items are packed toward the start of the direction.\n• : items are packed toward the end of the direction.\n• : items are packed toward left edge of the container, unless that doesn’t make sense with the , then it behaves like .\n• : items are packed toward right edge of the container, unless that doesn’t make sense with the , then it behaves like .\n• : items are centered along the line\n• : items are evenly distributed in the line; first item is on the start line, last item on the end line\n• : items are evenly distributed in the line with equal space around them. Note that visually the spaces aren’t equal, since all the items have equal space on both sides. The first item will have one unit of space against the container edge, but two units of space between the next item because that next item has its own spacing that applies.\n• : items are distributed so that the spacing between any two items (and the space to the edges) is equal. Note that that browser support for these values is nuanced. For example, never got support from some versions of Edge, and start/end/left/right aren’t in Chrome yet. MDN has detailed charts. The safest values are , , and . There are also two additional keywords you can pair with these values: and . Using ensures that however you do this type of positioning, you can’t push an element such that it renders off-screen (e.g. off the top) in such a way the content can’t be scrolled too (called “data loss”). \n\nThis defines the default behavior for how flex items are laid out along the cross axis on the current line. Think of it as the version for the cross-axis (perpendicular to the main-axis).\n• / / : items are placed at the start of the cross axis. The difference between these is subtle, and is about respecting the rules or the rules.\n• / / : items are placed at the end of the cross axis. The difference again is subtle and is about respecting rules vs. rules.\n• : items are centered in the cross-axis\n• : items are aligned such as their baselines align The and modifier keywords can be used in conjunction with all the rest of these keywords (although note browser support), and deal with helping you prevent aligning elements such that the content becomes inaccessible. \n\nThis aligns a flex container’s lines within when there is extra space in the cross-axis, similar to how aligns individual items within the main-axis. Note: This property only takes effect on multi-line flexible containers, where is set to either or ). A single-line flexible container (i.e. where is set to its default value, ) will not reflect .\n• (default): items are packed in their default position as if no value was set.\n• / : items packed to the start of the container. The (more supported) honors the while honors the direction.\n• / : items packed to the end of the container. The (more support) honors the while end honors the direction.\n• : items evenly distributed; the first line is at the start of the container while the last one is at the end\n• : items evenly distributed with equal space around each line\n• : items are evenly distributed with equal space around them\n• : lines stretch to take up the remaining space The and modifier keywords can be used in conjunction with all the rest of these keywords (although note browser support), and deal with helping you prevent aligning elements such that the content becomes inaccessible. The property explicitly controls the space between flex items. It applies that spacing only between items not on the outer edges. The behavior could be thought of as a minimum gutter, as if the gutter is bigger somehow (because of something like ) then the gap will only take effect if that space would end up smaller. It is not exclusively for flexbox, works in grid and multi-column layout as well. \n\nBy default, flex items are laid out in the source order. However, the property controls the order in which they appear in the flex container. Items with the same revert to source order. \n\nThis defines the ability for a flex item to grow if necessary. It accepts a unitless value that serves as a proportion. It dictates what amount of the available space inside the flex container the item should take up. If all items have set to , the remaining space in the container will be distributed equally to all children. If one of the children has a value of , that child would take up twice as much of the space as either one of the others (or it will try, at least). This defines the ability for a flex item to shrink if necessary. This defines the default size of an element before the remaining space is distributed. It can be a length (e.g. 20%, 5rem, etc.) or a keyword. The keyword means “look at my width or height property” (which was temporarily done by the keyword until deprecated). The keyword means “size it based on the item’s content” – this keyword isn’t well supported yet, so it’s hard to test and harder to know what its brethren , , and do. If set to , the extra space around content isn’t factored in. If set to , the extra space is distributed based on its value. See this graphic. This is the shorthand for and combined. The second and third parameters ( and ) are optional. The default is , but if you set it with a single number value, like , that changes the to 0%, so it’s like setting . It is recommended that you use this shorthand property rather than set the individual properties. The shorthand sets the other values intelligently. \n\nThis allows the default alignment (or the one specified by ) to be overridden for individual flex items. Please see the explanation to understand the available values. Note that , and have no effect on a flex item.\n\nFlexbox requires some vendor prefixing to support the most browsers possible. It doesn’t just include prepending properties with the vendor prefix, but there are actually entirely different property and value names. This is because the Flexbox spec has changed over time, creating an “old”, “tweener”, and “new” versions. Perhaps the best way to handle this is to write in the new (and final) syntax and run your CSS through Autoprefixer, which handles the fallbacks very well. Alternatively, here’s a Sass to help with some of the prefixing, which also gives you an idea of what kind of things need to be done:\n\nLet’s start with a very very simple example, solving an almost daily problem: perfect centering. It couldn’t be any simpler if you use flexbox. .parent { display: flex; height: 300px; /* Or whatever */ } .child { width: 100px; /* Or whatever */ height: 100px; /* Or whatever */ margin: auto; /* Magic! */ } This relies on the fact a margin set to in a flex container absorb extra space. So setting a margin of will make the item perfectly centered in both axes. Now let’s use some more properties. Consider a list of 6 items, all with fixed dimensions, but can be auto-sized. We want them to be evenly distributed on the horizontal axis so that when we resize the browser, everything scales nicely, and without media queries. .flex-container { /* We first create a flex layout context */ display: flex; /* Then we define the flow direction and if we allow the items to wrap * Remember this is the same as: * flex-direction: row; * flex-wrap: wrap; */ flex-flow: row wrap; /* Then we define how is distributed the remaining space */ justify-content: space-around; } Done. Everything else is just some styling concern. Below is a pen featuring this example. Be sure to go to CodePen and try resizing your windows to see what happens. Let’s try something else. Imagine we have a right-aligned navigation element on the very top of our website, but we want it to be centered on medium-sized screens and single-columned on small devices. Easy enough. /* Large */ .navigation { display: flex; flex-flow: row wrap; /* This aligns items to the end line on main-axis */ justify-content: flex-end; } /* Medium screens */ @media all and (max-width: 800px) { .navigation { /* When on medium sized screens, we center it by evenly distributing empty space around items */ justify-content: space-around; } } /* Small screens */ @media all and (max-width: 500px) { .navigation { /* On small screens, we are no longer using row direction but column */ flex-direction: column; } } Let’s try something even better by playing with flex items flexibility! What about a mobile-first 3-columns layout with full-width header and footer. And independent from source order. .wrapper { display: flex; flex-flow: row wrap; } /* We tell all items to be 100% width, via flex-basis */ .wrapper > * { flex: 1 100%; } /* We rely on source order for mobile-first approach * in this case: * 1. header * 2. article * 3. aside 1 * 4. aside 2 * 5. footer */ /* Medium screens */ @media all and (min-width: 600px) { /* We tell both sidebars to share a row */ .aside { flex: 1 auto; } } /* Large screens */ @media all and (min-width: 800px) { /* We invert order of first sidebar and main * And tell the main element to take twice as much width as the other two sidebars */ .main { flex: 3 0px; } .aside-1 { order: 1; } .main { order: 2; } .aside-2 { order: 3; } .footer { order: 4; } }"
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_flexible_box_layout/Basic_concepts_of_flexbox",
        "document": "The flexible box layout module (usually referred to as flexbox) is a one-dimensional layout model for distributing space between items and includes numerous alignment capabilities. This article gives an outline of the main features of flexbox, which we will explore in more detail in the rest of these guides. When we describe flexbox as being one-dimensional we are describing the fact that flexbox deals with layout in one dimension at a time — either as a row or as a column. This can be contrasted with the two-dimensional model of CSS Grid Layout, which controls columns and rows together.\n\nAnother vital area of understanding is how flexbox makes no assumption about the writing mode of the document. Flexbox doesn't just assume that all lines of text start at the top left of a document and run towards the right-hand side, with new lines appearing one under the other. Rather, it supports all writing modes, like other logical properties and values. You can read more about the relationship between flexbox and writing modes in a later article; however, the following description should help explain why we do not talk about left and right and top and bottom when we describe the direction that our flex items flow in. If the is and I am working in English, then the start edge of the main axis will be on the left, the end edge on the right. If I were to work in Arabic, then the start edge of my main axis would be on the right and the end edge on the left. In both cases the start edge of the cross-axis is at the top of the flex container and the end edge at the bottom, as both languages have a horizontal writing mode. After a while, thinking about start and end rather than left and right becomes natural, and will be useful to you when dealing with other layout methods such as CSS Grid Layout which follow the same patterns.\n\nWhile flexbox is a one dimensional model, it is possible to make flex items wrap across multiple lines. If you do this, you should consider each line as a new flex container. Any space distribution will happen across each line, without reference to the previous or subsequent lines. To cause wrapping behavior add the property with a value of . Now, if your items are too large to all display in one line, they will wrap onto another line. The live sample below contains items that have been given a . The total width of the items is too wide for the flex container. As is set to , the items wrap across multiple lines. If you set it to , which is the initial value, they will shrink to fit the container. They shrink because they are using initial flexbox values, including , that allows items to shrink. Using would cause an overflow if the items were not able to shrink, or could not shrink small enough to fit. Find out more about wrapping flex items in the guide Mastering wrapping of flex items.\n\nTo control the inline-size of each flex item, we target them directly via three properties: We will take a brief look at these properties below, but if you want more comprehensive information, take a look at the Controlling ratios of flex items on the main axis guide. Before we can make sense of these properties we need to consider the concept of available space. What we are doing when we change the value of these flex properties is to change the way that available space is distributed amongst our items. This concept of available space is also important when we come to look at aligning items. If we have three 100 pixel-wide items in a container which is 500 pixels wide, then the space we need to lay out our items is 300 pixels. This leaves 200 pixels of available space. If we don't change the initial values then flexbox will put that space after the last item. If we instead would like the items to grow and fill the space, then we need to have a method of distributing the leftover space between the items. The properties that we apply to the items themselves, enable dictating how that available space should be distributed among the sibling flex items.\n\nWith the property set to a positive integer, if there is available space, the flex item can grow along the main axis from its . Whether the item stretches to take up all the available space on that axis, or just a portion of the available space depends on if the other items are allowed to grow too and the value of their properties. Each item with a positive value consumes a portion of any available space based on their value. If we gave all of our items in the example above a value of 1 then the available space in the flex container would be equally shared between our items and they would stretch to fill the container on the main axis. If we give our first item a value of 2, and the other items a value of 1 each, there are a total of 4 parts; 2 parts of the available space will be given to the first item (100px out of 200px in the case of the example above) and 1 part each the other two (50px each out of the 200px total).\n\nWhere the property deals with adding space in the main axis, the property controls how it is taken away. If we do not have enough space in the container to lay out our items, and is set to a positive integer, then the item can become smaller than the . As with , different values can be assigned in order to cause one item to shrink faster than others — an item with a higher value set for will shrink faster than its siblings that have lower values. An item can shrink down to its size. This minimum size is taken into account while working out the actual amount of shrinkage that will happen, which means that has the potential to appear less consistent than in behavior. We'll therefore take a more detailed look at how this algorithm works in the article Controlling ratios of items along the main axis. Note: These values for and are proportions. Typically if we had all of our items set to and then wanted one item to grow at twice the rate, we would set that item to . However you could also use and if you wanted.\n\nYou will very rarely see the , , and properties used individually; instead they are combined into the shorthand. The shorthand allows you to set the three values in this order — , , . The live sample below allows you to test out the different values of the flex shorthand; remember that the first value is . Giving this a positive value means the item can grow. The second is — with a positive value the items can shrink, but only if their total values overflow the main axis. The final value is ; this is the value the items are using as their base value to grow and shrink from. .box > * { border: 2px solid rgb(96 139 168); border-radius: 5px; background-color: rgb(96 139 168 / 0.2); } .box { border: 2px dotted rgb(96 139 168); display: flex; } .one { flex: 1 1 auto; } .two { flex: 1 1 auto; } .three { flex: 1 1 auto; } There are also some predefined shorthand values which cover most of the use cases. You will often see these used in tutorials, and in many cases these are all you will need to use. The predefined values are as follows: The value is a CSS-wide keyword that represents the initial value for a property. Setting resets the item to the initial values of the three longhand properties, which is the same as . The initial value of is , so items will not grow larger than their size. The initial value of is , so items can shrink if they need to rather than overflowing. The initial value of is . Items will either use any size set on the item in the main dimension, or they will get their size from the content size. Using is the same as using ; this is similar to , except that the items can grow and fill the container as well as shrink if needed. Using will create fully inflexible flex items. It is as if you wrote . The items cannot grow or shrink and will be laid out using flexbox with a of . The shorthand you often see in tutorials is or and so on. This is the same as writing or and so on, respectively. The items get minimum size due to and then proportionally grow to fill the available space. In this case, the value of is redundant because the items start with minimum size — they're not given any size that could cause them to overflow the flex container. Try these shorthand values in the live sample below. .box > * { border: 2px solid rgb(96 139 168); border-radius: 5px; background-color: rgb(96 139 168 / 0.2); } .box { border: 2px dotted rgb(96 139 168); display: flex; } .one { flex: 1; } .two { flex: 1; } .three { flex: 1; }"
    },
    {
        "link": "https://w3schools.com/css/css3_flexbox.asp",
        "document": "W3Schools offers a wide range of services and products for beginners and professionals, helping millions of people everyday to learn and master new skills."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_flexible_box_layout",
        "document": "In the following example, a container has been set to , which means that the three child items become flex items. The value of has been set to in order to space the items out evenly on the main axis. An equal amount of space is placed between each item with the left and right items being flush with the edges of the flex container. You can also see that the items are stretching on the cross axis, due to the default value of being . The items stretch to the height of the flex container, making them each appear as tall as the tallest item."
    },
    {
        "link": "https://w3.org/TR/css-flexbox-1",
        "document": "The specification describes a CSS box model optimized for user interface design. In the flex layout model, the children of a flex container can be laid out in any direction, and can “flex” their sizes, either growing to fill unused space or shrinking to avoid overflowing the parent. Both horizontal and vertical alignment of the children can be easily manipulated. Nesting of these boxes (horizontal inside vertical, or vertical inside horizontal) can be used to build layouts in two dimensions.\n\nFor changes since the last draft, see the Changes section.\n\nThis document was produced by a group operating under the W3C Patent Policy . W3C maintains a public list of any patent disclosures made in connection with the deliverables of the group; that page also includes instructions for disclosing a patent. An individual who has actual knowledge of a patent which the individual believes contains Essential Claim(s) must disclose the information in accordance with section 6 of the W3C Patent Policy .\n\nPublication as a Candidate Recommendation does not imply endorsement by the W3C Membership. This is a draft document and may be updated, replaced or obsoleted by other documents at any time. It is inappropriate to cite this document as other than work in progress.\n\nGitHub Issues are preferred for discussion of this specification. When filing an issue, please put the text “css-flexbox” in the title, preferably like this: “[css-flexbox] …summary of comment… ”. All issues and comments are archived , and there is also a historical archive .\n\nThis document was produced by the CSS Working Group as a Candidate Recommendation. This document is intended to become a W3C Recommendation. This document will remain a Candidate Recommendation at least until 19 December 2018 in order to ensure the opportunity for wide review.\n\nThis section describes the status of this document at the time of its publication. Other documents may supersede this document. A list of current W3C publications and the latest revision of this technical report can be found in the W3C technical reports index at https://www.w3.org/TR/.\n\nThis section is not normative.\n\nCSS 2.1 defined four layout modes — algorithms which determine the size and position of boxes based on their relationships with their sibling and ancestor boxes:\n• table layout, designed for laying out 2D data in a tabular format\n• positioned layout, designed for very explicit positioning without much regard for other elements in the document\n\nThis module introduces a new layout mode, , which is designed for laying out more complex applications and webpages.\n\nThis section is not normative.\n\nFlex layout is superficially similar to block layout. It lacks many of the more complex text- or document-centric properties that can be used in block layout, such as floats and columns. In return it gains simple and powerful tools for distributing space and aligning content in ways that web apps and complex web pages often need. The contents of a flex container:\n• can be laid out in any flow direction (leftwards, rightwards, downwards, or even upwards!)\n• can have their display order reversed or rearranged at the style layer (i.e., visual order can be independent of source and speech order)\n• can be laid out linearly along a single (main) axis or wrapped into multiple lines along a secondary (cross) axis\n• can “flex” their sizes to respond to the available space\n• can be aligned with respect to their container or each other on the secondary (cross)\n• can be dynamically collapsed or uncollapsed along the main axis while preserving the container’s cross size\n\nThis module extends the definition of the display property [CSS21], adding a new block-level and new inline-level display type, and defining a new type of formatting context along with properties to control its layout. None of the properties defined in this module apply to the ::first-line or ::first-letter pseudo-elements.\n\nThe CSS Box Alignment Module extends and supercedes the definitions of the alignment properties (justify-content, align-items, align-self, align-content) introduced here.\n\nA is the box generated by an element with a computed display of flex or inline-flex. In-flow children of a flex container are called and are laid out using the flex layout model.\n\nUnlike block and inline layout, whose layout calculations are biased to the block and inline flow directions, flex layout is biased to the . To make it easier to talk about flex layout, this section defines a set of flex flow–relative terms. The flex-flow value and the writing mode determine how these terms map to physical directions (top/right/bottom/left), axes (vertical/horizontal), and sizes (width/height).\n\nAdditional sizing terminology used in this specification is defined in CSS Intrinsic and Extrinsic Sizing. [CSS-SIZING-3]\n\nA flex container establishes a new for its contents. This is the same as establishing a block formatting context, except that flex layout is used instead of block layout. For example, floats do not intrude into the flex container, and the flex container’s margins do not collapse with the margins of its contents. Flex containers form a containing block for their contents exactly like block containers do. [CSS21] The overflow property applies to flex containers.\n\nFlex containers are not block containers, and so some properties that were designed with the assumption of block layout don’t apply in the context of flex layout. In particular:\n• float and clear do not create floating or clearance of flex item, and do not take it out-of-flow.\n• vertical-align has no effect on a flex item.\n• the ::first-line and ::first-letter pseudo-elements do not apply to flex containers, and flex containers do not contribute a first formatted line or first letter to their ancestors.\n\nIf an element’s specified display is inline-flex, then its display property computes to flex in certain circumstances: the table in CSS 2.1 Section 9.7 is amended to contain an additional row, with inline-flex in the \"Specified Value\" column and flex in the \"Computed Value\" column.\n\nLoosely speaking, the flex items of a flex container are boxes representing its in-flow contents.\n\nEach in-flow child of a flex container becomes a flex item, and each contiguous sequence of child text runs is wrapped in an anonymous block container flex item. However, if the entire sequence of child text runs contains only white space (i.e. characters that can be affected by the white-space property) it is instead not rendered (just as if its text nodes were ).\n\nA flex item establishes an independent formatting context for its contents. However, flex items themselves are boxes, not block-level boxes: they participate in their container’s flex formatting context, not in a block formatting context.\n\nAuthors reading this spec may want to skip past the following box-generation and static position details.\n\nThe display value of a flex item is blockified: if the specified display of an in-flow child of an element generating a flex container is an inline-level value, it computes to its block-level equivalent. (See CSS2.1§9.7 [CSS21] and CSS Display [CSS3-DISPLAY] for details on this type of display value conversion.)\n\nSome values of display normally trigger the creation of anonymous boxes around the original box. If such a box is a flex item, it is blockified first, and so anonymous box creation will not happen. For example, two contiguous flex items with display: table-cell will become two separate display: block flex items, instead of being wrapped into a single anonymous table.\n\nIn the case of flex items with display: table, the table wrapper box becomes the flex item, and the order and align-self properties apply to it. The contents of any caption boxes contribute to the calculation of the table wrapper box’s min-content and max-content sizes. However, like width and height, the flex longhands apply to the table box as follows: the flex item’s final size is calculated by performing layout as if the distance between the table wrapper box’s edges and the table box’s content edges were all part of the table box’s border+padding area, and the table box were the flex item.\n\nAs it is out-of-flow, an absolutely-positioned child of a flex container does not participate in flex layout.\n\nThe static position of an absolutely-positioned child of a flex container is determined such that the child is positioned as if it were the sole flex item in the flex container, assuming both the child and the flex container were fixed-size boxes of their used size. For this purpose, margins are treated as zero.\n\nThe margins of adjacent flex items do not collapse.\n\nPercentage margins and paddings on flex items, like those on block boxes, are resolved against the inline size of their containing block, e.g. left/right/top/bottom percentages all resolve against their containing block’s in horizontal writing modes.\n\nAuto margins expand to absorb extra space in the corresponding dimension. They can be used for alignment, or to push adjacent flex items apart. See Aligning with margins.\n\nFlex items paint exactly the same as inline blocks [CSS21], except that order-modified document order is used in place of raw document order, and z-index values other than auto create a stacking context even if position is static (behaving exactly as if position were relative).\n\nDescendants that are positioned outside a flex item still participate in any stacking context established by the flex item.\n\nSpecifying on a flex item causes it to become a , producing an effect similar to on a table-row or table-column: the collapsed flex item is removed from rendering entirely, but leaves behind a \"strut\" that keeps the flex line’s cross-size stable. Thus, if a flex container has only one flex line, dynamically collapsing or uncollapsing items may change the flex container’s main size, but is guaranteed to have no effect on its cross size and won’t cause the rest of the page’s layout to \"wobble\". Flex line wrapping re-done after collapsing, however, so the cross-size of a flex container with multiple lines might or might not change.\n\nThough collapsed flex items aren’t rendered, they do appear in the formatting structure. Therefore, unlike on items [CSS21], effects that depend on a box appearing in the formatting structure (like incrementing counters or running animations and transitions) still operate on collapsed items.\n\nTo compute the size of the strut, flex layout is first performed with all items uncollapsed, and then re-run with each collapsed item replaced by a strut that maintains the original cross-size of the item’s original line. See the Flex Layout Algorithm for the normative definition of how interacts with flex layout.\n\nUsing on any flex items will cause the flex layout algorithm to repeat partway through, re-running the most expensive steps. It’s recommended that authors continue to use to hide items if the items will not be dynamically collapsed and uncollapsed, as that is more efficient for the layout engine. (Since only part of the steps need to be repeated when visibility is changed, however, 'visibility: collapse' is still recommended for dynamic cases.)\n\nThe auto keyword, representing an automatic minimum size, is the new initial value of the min-width and min-height properties. The keyword was previously defined in this specification, but is now defined in the CSS Sizing module.\n\nTo provide a more reasonable default minimum size for flex items, the used value of a main axis automatic minimum size on a flex item that is not a scroll container is a ; for scroll containers the automatic minimum size is zero, as usual.\n\nIn general, the content-based minimum size of a flex item is the smaller of its content size suggestion and its specified size suggestion. However, if the box has an aspect ratio and no specified size, its content-based minimum size is the smaller of its content size suggestion and its transferred size suggestion. If the box has neither a specified size suggestion nor an aspect ratio, its content-based minimum size is the content size suggestion.\n\nThe content size suggestion, specified size suggestion, and transferred size suggestion used in this calculation account for the relevant min/max/preferred size properties so that the content-based minimum size does not interfere with any author-provided constraints, and are defined below:\n\nFor the purpose of calculating an intrinsic size of the box (e.g. the box’s min-content size), a content-based minimum size causes the box’s size in that axis to become indefinite (even if e.g. its width property specifies a definite size). Note this means that percentages calculated against this size will behave as auto.\n\nNonetheless, although this may require an additional layout pass to re-resolve percentages in some cases, this value (like the min-content, max-content, and values defined in [CSS-SIZING-3]) does not prevent the resolution of percentage sizes within the item.\n\nThe contents of a flex container can be laid out in any direction and in any order. This allows an author to trivially achieve effects that would previously have required complex or fragile methods, such as hacks using the float and clear properties. This functionality is exposed through the flex-direction, flex-wrap, and order properties.\n\nThe reordering capabilities of flex layout intentionally affect , leaving speech order and navigation based on the source order. This allows authors to manipulate the visual presentation while leaving the source order intact for non-CSS UAs and for linear models such as speech and sequential navigation. See Reordering and Accessibility and the Flex Layout Overview for examples that use this dichotomy to improve accessibility.\n\nAuthors use order or the values of flex-flow/flex-direction as a substitute for correct source ordering, as that can ruin the accessibility of the document.\n\nThe flex-direction property specifies how flex items are placed in the flex container, by setting the direction of the flex container’s main axis. This determines the direction in which flex items are laid out.\n\nThe reverse values do not reverse box ordering: like writing-mode and direction [CSS3-WRITING-MODES], they only change the direction of flow. Painting order, speech order, and sequential navigation orders are not affected.\n\nThe flex-wrap property controls whether the flex container is single-line or multi-line, and the direction of the cross-axis, which determines the direction new lines are stacked in.\n\nFor the values that are not wrap-reverse, the cross-start direction is equivalent to either the inline-start or block-start direction of the current writing mode (whichever is in the cross axis) and the cross-end direction is the opposite direction of cross-start. When flex-wrap is wrap-reverse, the cross-start and cross-end directions are swapped.\n\nThe flex-flow property is a shorthand for setting the flex-direction and flex-wrap properties, which together define the flex container’s main and cross axes.\n\nFlex items are, by default, displayed and laid out in the same order as they appear in the source document. The order property can be used to change this ordering.\n\nThe order property controls the order in which flex items appear within the flex container, by assigning them to ordinal groups. It takes a single value, which specifies which ordinal group the flex item belongs to.\n\nA flex container lays out its content in , starting from the lowest numbered ordinal group and going up. Items with the same ordinal group are laid out in the order they appear in the source document. This also affects the painting order [CSS21], exactly as if the flex items were reordered in the source document. Absolutely-positioned children of a flex container are treated as having order: 0 for the purpose of determining their painting order relative to flex items.\n\nUnless otherwise specified by a future specification, this property has no effect on boxes that are not flex items.\n\nThe order property affect ordering in non-visual media (such as speech). Likewise, order does not affect the default traversal order of sequential navigation modes (such as cycling through links, see e.g. [HTML]).\n\nAuthors use order only for visual, not logical, reordering of content. Style sheets that use order to perform logical reordering are non-conforming.\n\nThis is so that non-visual media and non-CSS UAs, which typically present content linearly, can rely on a logical source order, while order is used to tailor the visual order. (Since visual perception is two-dimensional and non-linear, the desired visual order is not always logical.)\n\nIn order to preserve the author’s intended ordering in all presentation modes, authoring tools—including WYSIWYG editors as well as Web-based authoring aids— must reorder the underlying document source and not use order to perform reordering unless the author has explicitly indicated that the underlying document order (which determines speech and navigation order) should be with the visual order.\n\nUser agents, including browsers, accessible technology, and extensions, may offer spatial navigation features. This section does not preclude respecting the order property when determining element ordering in such spatial navigation modes; indeed it would need to be considered for such a feature to work. But order is not the only (or even the primary) CSS property that would need to be considered for such a spatial navigation feature. A well-implemented spatial navigation feature would need to consider all the layout features of CSS that modify spatial relationships.\n\nFlex items in a flex container are laid out and aligned within , hypothetical containers used for grouping and alignment by the layout algorithm. A flex container can be either single-line or multi-line, depending on the flex-wrap property:\n• A (i.e. one with flex-wrap: nowrap) lays out all of its children in a single line, even if that would cause its contents to overflow.\n• A (i.e. one with flex-wrap: wrap or flex-wrap: wrap-reverse) breaks its flex items across multiple lines, similar to how text is broken onto a new line when it gets too wide to fit on the existing line. When additional lines are created, they are stacked in the flex container along the cross axis according to the flex-wrap property. Every line contains at least one flex item, unless the flex container itself is completely empty.\n\nOnce content is broken into lines, each line is laid out independently; flexible lengths and the justify-content and align-self properties only consider the items on a single line at a time.\n\nIn a multi-line flex container (even one with only a single line), the cross size of each line is the minimum size necessary to contain the flex items on the line (after alignment due to align-self), and the lines are aligned within the flex container with the align-content property. In a single-line flex container, the cross size of the line is the cross size of the flex container, and align-content has no effect. The main size of a line is always the same as the main size of the flex container’s content box.\n\nThe defining aspect of flex layout is the ability to make the flex items “flex”, altering their width/height to fill the available space in the main dimension. This is done with the flex property. A flex container distributes free space to its items (proportional to their flex grow factor) to fill the container, or shrinks them (proportional to their flex shrink factor) to prevent overflow.\n\nA flex item is if both its flex-grow and flex-shrink values are zero, and otherwise.\n\nThe flex property specifies the components of a : the (grow and shrink) and the flex basis. When a box is a flex item, flex is consulted the main size property to determine the main size of the box. If a box is not a flex item, flex has no effect.\n\nThe initial values of the flex components are equivalent to flex: 0 1 auto.\n\nThe initial values of flex-grow and flex-basis are different from their defaults when omitted in the flex shorthand. This is so that the flex shorthand can better accommodate the most common cases.\n\nA unitless zero that is not already preceded by two flex factors must be interpreted as a flex factor. To avoid misinterpretation or invalid declarations, authors must specify a zero <‘flex-basis’> component with a unit or precede it by two flex factors.\n\nThe list below summarizes the effects of the four flex values that represent most commonly-desired effects:\n\nBy default, flex items won’t shrink below their minimum content size (the length of the longest word or fixed-size element). To change this, set the min-width or min-height property. (See §4.5 Automatic Minimum Size of Flex Items.)\n\nIndividual components of flexibility can be controlled by independent longhand properties.\n\nAuthors are encouraged to control flexibility using the flex shorthand rather than with its longhand properties directly, as the shorthand correctly resets any unspecified components to accommodate common uses.\n\nAuthors are encouraged to control flexibility using the flex shorthand rather than with flex-grow directly, as the shorthand correctly resets any unspecified components to accommodate common uses.\n\nThe flex-grow property sets the flex grow factor to the provided . Negative numbers are invalid.\n\nAuthors are encouraged to control flexibility using the flex shorthand rather than with flex-shrink directly, as the shorthand correctly resets any unspecified components to accommodate common uses.\n\nThe flex-shrink property sets the flex shrink factor to the provided . Negative numbers are invalid.\n\nAuthors are encouraged to control flexibility using the flex shorthand rather than with flex-basis directly, as the shorthand correctly resets any unspecified components to accommodate common uses.\n\nThe flex-basis property sets the flex basis. It accepts the same values as the width and height property, plus content.\n\nFor all values other than auto and content (defined above), flex-basis is resolved the same way as width in horizontal writing modes [CSS21], except that if a value would resolve to auto for width, it instead resolves to content for flex-basis. For example, percentage values of flex-basis are resolved against the flex item’s containing block (i.e. its flex container); and if that containing block’s size is indefinite, the used value for flex-basis is content. As another corollary, flex-basis determines the size of the content box, unless otherwise specified such as by box-sizing [CSS3UI].\n\nAfter a flex container’s contents have finished their flexing and the dimensions of all flex items are finalized, they can then be aligned within the flex container.\n\nThe margin properties can be used to align items in a manner similar to, but more powerful than, what margins can do in block layout. Flex items also respect the alignment properties from CSS Box Alignment, which allow easy keyword-based alignment of items in both the main axis and cross axis. These properties make many common types of alignment trivial, including some things that were very difficult in CSS 2.1, like horizontal and vertical centering.\n\nWhile the alignment properties are defined in CSS Box Alignment [CSS-ALIGN-3], Flexible Box Layout reproduces the definitions of the relevant ones here so as to not create a normative dependency that may slow down advancement of the spec. These properties apply only to flex layout until CSS Box Alignment Level 3 is finished and defines their effect for other layout modes. Additionally, any new values defined in the Box Alignment module will apply to Flexible Box Layout; in otherwords, the Box Alignment module, once completed, will supercede the definitions here.\n\nThis section is non-normative. The normative definition of how margins affect flex items is in the Flex Layout Algorithm section.\n\nAuto margins on flex items have an effect very similar to auto margins in block flow:\n• During calculations of flex bases and flexible lengths, auto margins are treated as .\n• Prior to alignment via justify-content and align-self, any positive free space is distributed to auto margins in that dimension.\n• Overflowing boxes ignore their auto margins and overflow in the end direction.\n\nIf free space is distributed to auto margins, the alignment properties will have no effect in that dimension because the margins will have stolen all the free space left over after flexing.\n\nThe justify-content property aligns flex items along the main axis of the current line of the flex container. This is done any flexible lengths and any auto margins have been resolved. Typically it helps distribute extra free space leftover when either all the flex items on a line are inflexible, or are flexible but have reached their maximum size. It also exerts some control over the alignment of items when they overflow the line.\n\nFlex items can be aligned in the cross axis of the current line of the flex container, similar to justify-content but in the perpendicular direction. align-items sets the default alignment for all of the flex container’s items, including anonymous flex items. align-self allows this default alignment to be overridden for individual flex items. (For anonymous flex items, align-self always matches the value of align-items on their associated flex container.)\n\nIf either of the flex item’s cross-axis margins are auto, align-self has no effect.\n\nValues have the following meanings:\n\nThe align-content property aligns a flex container’s lines within the flex container when there is extra space in the cross-axis, similar to how justify-content aligns individual items within the main-axis. Note, this property has no effect on a single-line flex container. Values have the following meanings:\n\nOnly multi-line flex containers ever have free space in the cross-axis for lines to be aligned in, because in a single-line flex container the sole line automatically stretches to fill the space.\n\nIn order for a flex container to itself participate in baseline alignment (e.g. when the flex container is itself a flex item in an outer flex container), it needs to submit the position of the baselines that will best represent its contents. To this end, the baselines of a flex container are determined as follows (after reordering with order, and taking flex-direction into account):\n\nWhen calculating the baseline according to the above rules, if the box contributing a baseline has an overflow value that allows scrolling, the box must be treated as being in its initial scroll position for the purpose of determining its baseline.\n\nWhen determining the baseline of a table cell, a flex container provides a baseline just as a line box or table-row does. [CSS21]\n\nSee CSS Writing Modes 3 §4.1 Introduction to Baselines and CSS Box Alignment 3 §9 Baseline Alignment Details for more information on baselines.\n\nThis section contains normative algorithms detailing the exact layout behavior of a flex container and its contents. The algorithms here are written to optimize readability and theoretical simplicity, and may not necessarily be the most efficient. Implementations may use whatever actual algorithms they wish, but must produce the same results as the algorithms described here.\n\nThis section is mainly intended for implementors. Authors writing web pages should generally be served well by the individual property descriptions, and do not need to read this section unless they have a deep-seated urge to understand arcane details of CSS layout.\n\nThe following sections define the algorithm for laying out a flex container and its contents.\n\nFlex layout works with the flex items in order-modified document order, not their original document order.\n• Generate anonymous flex items as described in §4 Flex Items.\n• Determine the available main and cross space for the flex items. For each dimension, if that dimension of the flex container’s content box is a definite size, use that; if that dimension of the flex container is being sized under a min or max-content constraint, the available space in that dimension is that constraint; otherwise, subtract the flex container’s margin, border, and padding from the space available to the flex container in that dimension and use that value. This might result in an infinite value. For example, the available space to a flex item in a floated auto-sized flex container is:\n• the width of the flex container’s containing block minus the flex container’s margin, border, and padding in the horizontal dimension\n• Determine the and of each item:\n• If the item has a definite used flex basis, that’s the flex base size.\n• If the flex item has ...\n• a used flex basis of content, and then the flex base size is calculated from its inner cross size and the flex item’s intrinsic aspect ratio.\n• If the used flex basis is content or depends on its available space, and the flex container is being sized under a min-content or max-content constraint (e.g. when performing automatic table layout [CSS21]), size the item under that constraint. The flex base size is the item’s resulting main size.\n• Otherwise, if the used flex basis is content or depends on its available space, the available main size is infinite, and the flex item’s inline axis is parallel to the main axis, lay the item out using the rules for a box in an orthogonal flow [CSS3-WRITING-MODES]. The flex base size is the item’s max-content main size. This case occurs, for example, in an English document (horizontal writing mode) containing a column flex container containing a vertical Japanese (vertical writing mode) flex item.\n• Otherwise, size the item into the available space using its used flex basis in place of its main size, treating a value of content as max-content. If a cross size is needed to determine the main size (e.g. when the flex item’s main size is in its block axis) and the flex item’s cross size is auto and not definite, in this calculation use as the flex item’s cross size. The flex base size is the item’s resulting main size. When determining the flex base size, the item’s min and max main sizes are ignored (no clamping occurs). Furthermore, the sizing calculations that floor the content box size at zero when applying box-sizing are also ignored. (For example, an item with a specified size of zero, positive padding, and box-sizing: border-box will have an outer flex base size of zero— and hence a negative inner flex base size.) The hypothetical main size is the item’s flex base size clamped according to its used min and max main sizes (and flooring the content box size at zero).\n• Determine the main size of the flex container using the rules of the formatting context in which it participates. For this computation, auto margins on flex items are treated as .\n• Collect flex items into flex lines:\n• If the flex container is single-line, collect all the flex items into a single flex line.\n• Otherwise, starting from the first uncollected item, collect consecutive items one by one until the first time that the collected item would not fit into the flex container’s inner main size (or until a forced break is encountered, see §10 Fragmenting Flex Layout). If the very first uncollected item wouldn’t fit, collect just it into the line. For this step, the size of a flex item is its outer hypothetical main size. Repeat until all flex items have been collected into flex lines. Note that the \"collect as many\" line will collect zero-sized flex items onto the end of the previous line even if the last non-zero item exactly \"filled up\" the line.\n• Resolve the flexible lengths of all the flex items to find their used main size. See §9.7 Resolving Flexible Lengths.\n• Determine the of each item by performing layout with the used main size and the available space, treating auto as .\n• Calculate the cross size of each flex line. If the flex container is single-line and has a definite cross size, the cross size of the flex line is the flex container’s inner cross size. Otherwise, for each flex line:\n• Collect all the flex items whose inline-axis is parallel to the main-axis, whose align-self is baseline, and whose cross-axis margins are both non-auto. Find the largest of the distances between each item’s baseline and its hypothetical outer cross-start edge, and the largest of the distances between each item’s baseline and its hypothetical outer cross-end edge, and sum these two values.\n• Among all the items not collected by the previous step, find the largest outer hypothetical cross size.\n• The used cross-size of the flex line is the largest of the numbers found in the previous two steps and zero. If the flex container is single-line, then clamp the line’s cross-size to be within the container’s computed min and max cross sizes. Note that if CSS 2.1’s definition of min/max-width/height applied more generally, this behavior would fall out automatically.\n• Handle 'align-content: stretch'. If the flex container has a definite cross size, align-content is stretch, and the sum of the flex lines' cross sizes is less than the flex container’s inner cross size, increase the cross size of each flex line by equal amounts such that the sum of their cross sizes exactly equals the flex container’s inner cross size.\n• Collapse items. If any flex items have visibility: collapse, note the cross size of the line they’re in as the item’s , and restart layout from the beginning. In this second layout round, when collecting items into lines, treat the collapsed items as having zero main size. For the rest of the algorithm following that step, ignore the collapsed items entirely (as if they were ) except that after calculating the cross size of the lines, if any line’s cross size is less than the largest among all the collapsed items in the line, set its cross size to that . Skip this step in the second layout round.\n• Determine the used cross size of each flex item. If a flex item has align-self: stretch, its computed cross size property is auto, and neither of its cross-axis margins are auto, the used outer cross size is the used cross size of its flex line, clamped according to the item’s used min and max cross sizes. Otherwise, the used cross size is the item’s hypothetical cross size. If the flex item has align-self: stretch, redo layout for its contents, treating this used size as its definite cross size so that percentage-sized children can be resolved. Note that this step does not affect the main size of the flex item, even if it has an intrinsic aspect ratio.\n• Distribute any remaining free space. For each flex line:\n• If the remaining free space is positive and at least one main-axis margin on this line is auto, distribute the free space equally among these margins. Otherwise, set all auto margins to zero.\n• Align the items along the main-axis per justify-content.\n• Resolve cross-axis auto margins. If a flex item has auto cross-axis margins:\n• If its outer cross size (treating those auto margins as zero) is less than the cross size of its flex line, distribute the difference in those sizes equally to the auto margins.\n• Otherwise, if the block-start or inline-start margin (whichever is in the cross axis) is auto, set it to zero. Set the opposite margin so that the outer cross size of the item equals the cross size of its flex line.\n• Align all flex items along the cross-axis per align-self, if neither of the item’s cross-axis margins are auto.\n• Determine the flex container’s used cross size:\n• If the cross size property is a definite size, use that, clamped by the used min and max cross sizes of the flex container.\n• Otherwise, use the sum of the flex lines' cross sizes, clamped by the used min and max cross sizes of the flex container.\n\nTo resolve the flexible lengths of the items within a flex line:\n• Determine the used flex factor. Sum the outer hypothetical main sizes of all items on the line. If the sum is less than the flex container’s inner main size, use the flex grow factor for the rest of this algorithm; otherwise, use the flex shrink factor.\n• Size inflexible items. Freeze, setting its to its hypothetical main size…\n• any item that has a flex factor of zero\n• if using the flex grow factor: any item that has a flex base size greater than its hypothetical main size\n• if using the flex shrink factor: any item that has a flex base size smaller than its hypothetical main size\n• Calculate . Sum the outer sizes of all items on the line, and subtract this from the flex container’s inner main size. For frozen items, use their outer target main size; for other items, use their outer flex base size.\n• Loop:\n• Check for flexible items. If all the flex items on the line are frozen, free space has been distributed; exit this loop.\n• Calculate the as for initial free space, above. If the sum of the unfrozen flex items’ flex factors is less than one, multiply the initial free space by this sum. If the magnitude of this value is less than the magnitude of the remaining free space, use this as the remaining free space.\n• Distribute free space proportional to the flex factors. If the remaining free space is zero If using the flex grow factor Find the ratio of the item’s flex grow factor to the sum of the flex grow factors of all unfrozen items on the line. Set the item’s target main size to its flex base size plus a fraction of the remaining free space proportional to the ratio. If using the flex shrink factor For every unfrozen item on the line, multiply its flex shrink factor by its inner flex base size, and note this as its . Find the ratio of the item’s scaled flex shrink factor to the sum of the scaled flex shrink factors of all unfrozen items on the line. Set the item’s target main size to its flex base size minus a fraction of the absolute value of the remaining free space proportional to the ratio. Note this may result in a negative inner main size; it will be corrected in the next step.\n• Fix min/max violations. Clamp each non-frozen item’s target main size by its used min and max main sizes and floor its content-box size at zero. If the item’s target main size was made smaller by this, it’s a max violation. If the item’s target main size was made larger by this, it’s a min violation.\n• Freeze over-flexed items. The total violation is the sum of the adjustments from the previous step . If the total violation is: Freeze all the items with min violations. Freeze all the items with max violations.\n• Return to the start of this loop.\n• Set each item’s used main size to its target main size.\n\nAlthough CSS Sizing [CSS-SIZING-3] defines definite and indefinite lengths, Flexbox has several additional cases where a length can be considered :\n• If a single-line flex container has a definite cross size, the outer cross size of any stretched flex items is the flex container’s inner cross size (clamped to the flex item’s min and max cross size) and is considered definite.\n• If the flex container has a definite main size, a flex item’s post-flexing main size is treated as definite, even though it can rely on the indefinite sizes of any flex items in the same line.\n• Once the cross size of a flex line has been determined, items in auto-sized flex containers are also considered definite for the purpose of layout; see step 11.\n\nThe main size of a fully inflexible item with a definite flex basis is, by definition, definite.\n\nThe intrinsic sizing of a flex container is used to produce various types of content-based automatic sizing, such as shrink-to-fit logical widths (which use the formula) and content-based logical heights (which use the max-content size).\n\nSee [CSS-SIZING-3] for a definition of the terms in this section.\n\nThe max-content main size of a flex container is the smallest size the flex container can take while maintaining the max-content contributions of its flex items, insofar as allowed by the items’ own flexibility:\n• For each flex item, subtract its outer flex base size from its max-content contribution size. If that result is positive, divide by its flex grow factor floored at 1; if negative, divide by its scaled flex shrink factor having floored the flex shrink factor at 1. This is the item’s .\n• Place all flex items into lines of infinite length.\n• Within each line, find the largest among all the flex items. Add each item’s flex base size to the product of its flex grow factor (or scaled flex shrink factor, if the chosen was negative) and the chosen , then clamp that result by the max main size floored by the min main size.\n• The flex container’s max-content size is the largest sum of the afore-calculated sizes of all items within a single line.\n\nThe min-content main size of a flex container is calculated identically to the max-content main size, except that the flex item’s min-content contribution is used instead of its max-content contribution. However, for a container, it is simply the largest min-content contribution of all the flex items in the flex container.\n\nThe min-content/max-content cross size of a flex container is the largest min-content contribution/max-content contribution (respectively) of its flex items.\n\nFor a flex container, the min-content/max-content cross size is the sum of the flex line cross sizes resulting from sizing the flex container under a cross-axis min-content constraint/max-content constraint (respectively). However, if the flex container is flex-flow: column wrap;, then it’s sized by first finding the largest min-content/max-content cross-size contribution among the flex items (respectively), then using that size as the available space in the cross axis for each of the flex items during layout.\n\nThis heuristic for flex containers gives a reasonable approximation of the size that the flex container should be, with each flex item ending up as min( , ), and each flex line no larger than its largest flex item. It’s not a fit in some cases, but doing it completely correct is insanely expensive, and this works reasonably well.\n\nThe main-size min-content contribution of a flex item is the larger of its min-content size and outer preferred size (its width/height as appropriate) if that is not auto, clamped by its flex base size as a maximum (if it is not growable) and/or as a minimum (if it is not shrinkable), and then further clamped by its min/max main size.\n\nThe main-size max-content contribution of a flex item is the larger of its max-content size and outer preferred size (its width/height as appropriate) clamped by its flex base size as a maximum (if it is not growable) and/or as a minimum (if it is not shrinkable), and then further clamped by its min/max main size.\n\nFlex containers can break across pages between items, between lines of items (in multi-line mode), and inside items. The break-* properties apply to flex containers as normal for block-level or inline-level boxes. This section defines how they apply to flex items and the contents of flex items. See the CSS Fragmentation Module for more context [CSS3-BREAK].\n\nThe following breaking rules refer to the fragmentation container as the “page”. The same rules apply in any other fragmentation context. (Substitute “page” with the appropriate fragmentation container type as needed.) For readability, in this section the terms \"row\" and \"column\" refer to the relative orientation of the flex container with respect to the block flow direction of the fragmentation context, rather than to that of the flex container itself.\n\nThe exact layout of a fragmented flex container is not defined in this level of Flexible Box Layout. However, breaks inside a flex container are subject to the following rules (interpreted using order-modified document order):\n• In a row flex container, the break-before and break-after values on flex items are propagated to the flex line. The break-before values on the first line and the break-after values on the last line are propagated to the flex container. Break propagation (like text-decoration propagation) does not affect computed values.\n• In a column flex container, the break-before values on the first item and the break-after values on the last item are propagated to the flex container. Forced breaks on other items are applied to the item itself.\n• A forced break inside a flex item effectively increases the size of its contents; it does not trigger a forced break inside sibling items.\n• In a row flex container, Class A break opportunities occur between sibling flex lines, and Class C break opportunities occur between the first/last flex line and the flex container’s content edges. In a column flex container, Class A break opportunities occur between sibling flex items, and Class C break opportunities occur between the first/last flex items on a line and the flex container’s content edges. [CSS3-BREAK]\n• When a flex container is continued after a break, the space available to its flex items (in the block flow direction of the fragmentation context) is reduced by the space consumed by flex container fragments on previous pages. The space consumed by a flex container fragment is the size of its content box on that page. If as a result of this adjustment the available space becomes negative, it is set to zero.\n• If the first fragment of the flex container is not at the top of the page, and none of its flex items fit in the remaining space on the page, the entire fragment is moved to the next page.\n• When a multi-line column flex container breaks, each fragment has its own \"stack\" of flex lines, just like each fragment of a multi-column container has its own row of column boxes.\n• Aside from the rearrangement of items imposed by the previous point, UAs should attempt to minimize distortion of the flex container with respect to unfragmented flow.\n\nThis informative section presents a possible fragmentation algorithm for flex containers. Implementors are encouraged to improve on this algorithm and provide feedback to the CSS Working Group.\n\nThanks for feedback and contributions to\n\nThis section documents the changes since previous publications.\n\nChanges since the 16 October 2017 CR\n\nA Disposition of Comments is also available.\n• Removed the option for flex-item block-axis margins and paddings to be resolved against the block dimension; they must be resolved against the inline dimension, as for blocks. (Issue 2085)\n• Floored flex item’s min-content contribution by their preferred size (Issue 2353) and cleaned up associated wording to be more precise. The main-size min-content contribution of a flex item is the larger of its min-content size and outer preferred size (its width/height as appropriate) if that is not auto , clamped by its flex base size as a maximum (if it is not growable) and/or as a minimum (if it is not shrinkable), and then further clamped by its min/max main size properties. The main-size max-content contribution of a flex item is the larger of its max-content size and size (its width/height as appropriate if that is , clamped by its flex base size as a maximum (if it is not growable) and/or as a minimum (if it is not shrinkable), and then further clamped by its min/max main size properties.\n• Added some (effectively informative) prose and a cross-reference to more clearly define flex-basis: content. Indicates based on the flex item’s content.\n• Moved the definition of the auto keyword for min-width and min-height to [CSS-SIZING-3]. The definition of what an automatic minimum size for flex items is remains here. (Issue 1920, Issue 2103)\n• Altered the computation of auto in min-width and min-height such that it always computes to itself— although its resolved value remains zero on CSS2 display types. (Issue 2230, Issue 2248)\n• Clarified that min/max clamping is according to the used value of the min/max size properties— which in the case of tables with layout, is floored by the table’s min-content size. (Issue 2442)\n• Clarified that break propagation does not affect computed values and that order-modified document order is used. (Issue 2614) The exact layout of a fragmented flex container is not defined in this level of Flexible Box Layout. However, breaks inside a flex container are subject to the following rules :\n• In a row flex container, the break-before and break-after values on flex items are propagated to the flex line. The break-before values on the first line and the break-after values on the last line are propagated to the flex container. Break propagation (like text-decoration propagation) does not affect computed values.\n• Clarified that if the automatic minimum size resolves directly to zero rather than being a content-based minimum size, it does not cause indefiniteness. For the purpose of calculating an intrinsic size of the element (e.g. the element’s min-content size), causes the element’s size in that axis to become indefinite (even if e.g. its width property specifies a definite size).\n• Some minor editorial fixes and clarifications, including updates to vocabulary to match updates to other CSS modules.\n\nChanges since the 26 May 2016 CR\n\nA Disposition of Comments is also available.\n• To allow flex factors to actually represent absolute ratios of flex item sizes as was originally intended (see various examples), removed the flooring of content-box sizes at zero for the purpose of finding the item’s flex base size, since this type of ratio requires a flex base size of zero, which would otherwise only be possible if margins, borders, and padding are also all zero. (The flooring remains in effect, alongside the min and max size constraints, in calculating the hypothetical and final sizes of the item.) (Issue 316) When determining the flex base size, the item’s min and max main size properties are ignored (no clamping occurs). Furthermore, the sizing calculations that floor the content box size at zero when applying box-sizing are also ignored. (For example, an item with a specified size of zero, positive padding, and box-sizing: border-box will have an outer flex base size of zero— and hence a negative inner flex base size.) The hypothetical main size is the item’s flex base size clamped according to its min and max main size properties . Fix min/max violations. Clamp each non-frozen item’s target main size by its min and max main size properties and floor its content-box size at zero . If the item’s target main size was made smaller by this, it’s a max violation. If the item’s target main size was made larger by this,\n• To prevent empty flex items in shrink-to-fit containers from collapsing to zero even when given a specified size, the specified size is now accounted for in calculating its max-content contribution in §9.9.3 Flex Item Intrinsic Size Contributions. (Issue 1435) The main-size max-content contribution of a flex item is its max-content size and specified size (its width/height as appropriate, if that is definite) , clamped by its flex base size as a maximum (if it is not growable) and/or as a minimum (if it is not shrinkable), and then further clamped by its min/max main size properties.\n• Since at least two implementations ended up allowing percentages inside flex items with indefinite flex basis to resolve anyway, removed the condition requiring definite flex basis. (Issue 1679) If the flex container has a definite main size, post-flexing main size is treated as definite (even though it might technically rely on the sizes of indefinite siblings to resolve its flexed main size the indefinite sizes of any flex items in the same line).\n• For ease of implementation, auto value of align-self now computes to itself always. See related previous change requiring this computation for absolutely-positioned elements. (Issue 440, Issue 644) auto computes to parent’s align-items value; otherwise as specified … On absolutely positioned elements, a value of auto computes to itself. On all other elements, a value of for align-self computes to the value of align-items on the element’s parent, or stretch if the element has no parent.\n• Change flex items in orthogonal flows and flex items without a baseline to both synthesize their alignment baseline from the flex item’s border box. (Issue 373)\n• Fix main/cross error in definition of cross-axis baseline set. (Issue 792) Otherwise, the flex container has no first/last -axis baseline set…\n• Restore accidentally-deleted text about tables as flex items. See anonymous box change. (Issue 547) In the case of flex items with display: table, the table wrapper box becomes the flex item, and the order and align-self properties apply to it. The contents of any caption boxes contribute to the calculation of the table wrapper box’s min-content and max-content sizes. However, like width and height, the flex longhands apply to the table box as follows: the flex item’s final size is calculated by performing layout as if the distance between the table wrapper box’s edges and the table box’s content edges were all part of the table box’s border+padding area, and the table box were the flex item.\n• Clarified that auto margins are treated as zero for the purpose of calculating a absolutely-positioned flex container child’s static position. (Issue 665) For this purpose, a value of align-self: auto is treated identically to , and margins are treated as zero .\n• When clamping by the max main size property in the calculation of the flex container’s intrinsic size, be sure to floor by the min main size property. (Issue 361) Within each line, find the largest among all the flex items. Add each item’s flex base size to the product of its flex grow factor (or scaled flex shrink factor, if the chosen was negative) and the chosen , then clamp that result\n• Added missing edits for change that made order not apply to absolutely-positioned children of a flex container. (Issue 1439) The order property controls the order in which appear within the flex container, by assigning them to ordinal groups. … Absolutely-positioned children of a flex container are treated as having order: 0 for the purpose of determining their painting order relative to flex items. Unless otherwise specified by a future specification, this property has no effect on boxes that are not .\n• Take flex-direction into account when determining first/last baseline of the flex container. (Issue 995) To this end, the baselines of a flex container are determined as follows (after reordering with order ):\n• If any of the flex items on the flex container’s flex line participate in baseline alignment, the flex container’s first/last main-axis baseline set …\n• Otherwise, if the flex container has at least one flex item, the flex container’s first/last main-axis baseline set is generated from the alignment baseline of the flex item. …\n• Otherwise, the flex container has no first/last main-axis baseline set, …\n• If the flex container has at least one flex item, the flex container’s first/last cross-axis baseline set is generated from the alignment baseline of the flex item. …\n• Define align-content: space-between handling of a single flex line as equivalent to . (Issue 718) Lines are evenly distributed in the flex container. If the leftover free-space is negative or there is only a single flex line in the flex container, this value is identical to flex-start.\n• Restored definition of the automatic minimum size of boxes with neither specified size nor aspect ratio, which was lost in earlier rewrite. (Issue 671)\n• Made sure that main size and cross size are defined for flex containers as well as for flex items. (Issue 981)\n• Tweaked final clarifying sentence of note about spatial navigation. (Issue 1677) User agents, including browsers, accessible technology, and extensions, may offer spatial navigation features. This section does not preclude respecting the order property when determining element ordering in such spatial navigation modes; indeed it would need to be considered for such a feature to work. However a UA that uses order in determining sequential navigation, but does not otherwise account for spatial relationships among elements (as expressed by the various layout features of CSS including and not limited to flex layout), is non-conforming. But order is not the only (or even the primary) CSS property that would need to be considered for such a spatial navigation feature. A well-implemented spatial navigation feature would need to consider all the layout features of CSS that modify spatial relationships.\n\nChanges since the 1 March 2016 CR\n\nA Disposition of Comments is also available.\n• Define how percentages are handled when calculating intrinsic automatic minimum sizes. (Issue 3) For the purpose of calculating an intrinsic size of the element (e.g. the element’s min-content size), this value causes the element’s size in that axis to become indefinite (even if e.g. its width property specifies a definite size). Note this means that percentages calculated against this size will be treated as auto. although this may require an additional layout pass to re-resolve percentages in some cases, this value (like the min-content, max-content, and values defined in [CSS-SIZING-3]) does not prevent the resolution of percentage sizes within the item.\n• Switched definite and indefinite to refer to the (more correct) definitions in [CSS-SIZING-3] instead of defining them inline in this module. (Issue 10)\n• Abspos children of a flexbox no longer respond to the order property. (Issue 12)\n• Updated §8.5 Flex Container Baselines to account for baseline sets and last-baseline alignment. (Issue 13))\n• Clarify that spatial navigation modes are allowed to handle order. (Issue 1) User agents, including browsers, accessible technology, and extensions, may offer spatial navigation features. This section does not preclude respecting the order property when determining element ordering in such spatial navigation modes; indeed it would need to be considered for such a feature to work. However a UA that uses order in determining sequential navigation, but does not otherwise account for spatial relationships among elements (as expressed by the various layout features of CSS including and not limited to flex layout), is non-conforming.\n• Cross-reference an additional case of definiteness in §9.8 Definite and Indefinite Sizes (Issue 2) Once the cross size of a flex line has been determined, items in auto-sized flex containers are also considered definite for the purpose of layout; see step 11.\n• Improve wording for how unresolveable percentage flex basis values transmute to content. (Issue 6) For all values other than auto and content (defined above), flex-basis is resolved the same way as width in horizontal writing modes [CSS21], except that if a value would resolve to auto for width, it instead resolves to content for flex-basis . For example, percentage values of flex-basis are resolved against the flex item’s containing block (i.e. its flex container); and if that containing block’s size is indefinite, the result is the same as a main size of auto (which in this case is treated as content) the used value for flex-basis is content .\n• Clarify that inflexible items with a definite flex basis have a definite size. (Issue 8, Issue 11) A flex item is fully inflexible if both its flex-grow and flex-shrink values are zero, and flexible otherwise. The main size of a fully inflexible item with a definite flex basis is, by definition, definite.\n• Reworded definition of the auto value to be easier to understand. (Issue 9) On a flex item whose overflow is visible in the main axis, when specified on the flex item’s main-axis min-size property, the following table gives the minimum size … In general, the automatic minimum size … defined below:\n• Slightly reworded the section on determining the static position of absolutely-positioned children to be clearer.\n• Adjusted format of Animatable lines to be clearer about animating keywords.\n\nChanges since the 14 May 2015 LCWD\n\nA Disposition of Comments is also available.\n• Revert flex shorthand change of omitted flex-basis back to , since that was a hacky way of solving an intrinsic size problem, and isn’t needed (and gives bad results) given a correct implementation of §9.9 Intrinsic Sizes. (Issue 13) When omitted from the flex shorthand, its specified value is .\n• Changed flex item determination to operate on each element directly, and not on its anonymous wrapper box, if any. (Issue 6)\n• float and clear have no effect on a flex item, float and clear do not create floating or clearance of flex item, and do not take it out-of-flow. However, the float property can still affect box generation by influencing the display property’s computed value. Some values of display trigger the creation of anonymous boxes around the original box. It’s the outermost box—the direct child of the flex container box—that becomes a flex item. For example, given two contiguous child elements with display: table-cell, the anonymous table wrapper box generated around them [CSS21] becomes the flex item. In the case of flex items with display: table, the table wrapper box becomes the flex item, and the order and align-self properties apply to it. The contents of any caption boxes contribute to the calculation of the table wrapper box’s min-content and max-content sizes. However, like width and height, the flex longhands apply to the table box as follows: the flex item’s final size is calculated by performing layout as if the distance between the table wrapper box’s edges and the table box’s content edges were all part of the table box’s border+padding area, and the table box were the flex item. Note: Some values of display normally trigger the creation of anonymous boxes around the original box. If such a box is a flex item, it is blockified first, and so anonymous box creation will not happen. For example, two contiguous flex items with display: table-cell will become two separate display: block flex items, instead of being wrapped into a single anonymous table.\n• Defined that any size adjustment imposed by a box’s is consulted when percentage-sizing any of its contents. (Issue 3) In order to prevent cycling sizing, the auto value of min-height and max-height does not factor into the percentage size resolution of the box’s contents. For example, a percentage-height block whose flex item parent has height: 120em; min-height: auto will size itself against height: 120em regardless of the impact that min-height might have on the used size of the flex item. Although this may require an additional layout pass to re-resolve percentages in some cases, the auto value of min-width and min-height (like the min-content, max-content, and values defined in [CSS-SIZING-3]) does not prevent the resolution of percentage sizes within the item.\n• Correct instrinsic sizing rules to handle inflexible items. (Issue 1) The main-size min-content/max-content contribution of a flex item is its outer hypothetical main size when sized under a min-content/max-content constraint (respectively) The main-size min-content/max-content contribution of a flex item is its min-content/max-content size, clamped by its flex base size as a maximum (if it is not growable) and/or as a minimum (if it is not shrinkable), and then further clamped by its min/max main size properties .\n• Correct errors in flex container main-axis intrinsic sizing. (Issue 1) The max-content main size of a flex container is the smallest size the flex container can take while maintaining the max-content contributions of its flex items:\n• For each flex item, subtract its flex base size from its max-content contribution size , then divide by its flex grow factor, floored at 1, or by its scaled flex shrink factor (if the result was negative, flooring the flex shrink factor at 1 if necessary) . If that result is not zero, divide it by (if the result was positive) its flex grow factor floored at 1, or (if the result was negative) by its scaled flex shrink factor, having floored the flex shrink factor at 1. This is the item’s .\n• Correct errors in flex container cross-axis intrinsic sizing, and specify commonly-implemented min-content sizing heuristic for multi-line column flex containers. (Issue 12) The min-content cross size and max-content cross size of a flex container are the cross size of the flex container after performing layout into the given available main-axis space and infinite available cross-axis space. The min-content/max-content cross size of a flex container is the largest min-content contribution/max-content contribution (respectively) of its flex items. For a flex container, the min-content/max-content cross size is the sum of the flex line cross sizes resulting from sizing the flex container under a cross-axis min-content constraint/max-content constraint (respectively). However, if the flex container is flex-flow: column wrap;, then it’s sized by first finding the largest min-content/max-content cross-size contribution among the flex items (respectively), then using that size as the available space in the cross axis for each of the flex items during layout. This heuristic for flex containers gives a reasonable approximation of the size that the flex container should be, with each flex item ending up as min( , ), and each flex line no larger than its largest flex item. It’s not a fit in some cases, but doing it completely correct is insanely expensive, and this works reasonably well.\n• Add explicit conformance criteria on authoring tools to keep presentation and DOM order in sync unless author explicitly indicates a desire to make them out-of-sync. (Issue 8) In order to preserve the author’s intended ordering in all presentation modes, authoring tools—including WYSIWYG editors as well as Web-based authoring aids— must reorder the underlying document source and not use order to perform reordering unless the author has explicitly indicated that the underlying document order (which determines speech and navigation order) should be with the visual order. For example, a tool might offer both drag-and-drop reordering of flex items as well as handling of media queries for alternate layouts per screen size range. Since most of the time, reordering should affect all screen ranges as well as navigation and speech order, the tool would perform drag-and-drop reordering at the DOM layer. In some cases, however, the author may want different visual orderings per screen size. The tool could offer this functionality by using order together with media queries, but also tie the smallest screen size’s ordering to the underlying DOM order (since this is most likely to be a logical linear presentation order) while using order to determine the visual presentation order in other size ranges. This tool would be conformant, whereas a tool that only ever used order to handle drag-and-drop reordering (however convenient it might be to implement it that way) would be non-conformant.\n• Defined that an align-self or justify-self value of auto computes to itself on absolutely-positioned elements, for consistency with future extensions of these properties in [CSS-ALIGN-3]. (Issue 5) On absolutely positioned elements, a value of auto computes to itself. On all other elements, a value of auto for align-self computes to the value of align-items on the element’s parent, or stretch if the element has no parent.\n• Revert change to make percentage margins and padding relative to their own axes; instead allow both behaviors. (Issue 11, Issue 16) Percentage margins and paddings on flex items are always resolved against their respective dimensions; unlike blocks, they do not always resolve against the inline dimension of their containing block. Percentage margins and paddings on flex items can be resolved against either:\n• their own axis (left/right percentages resolve against width, top/bottom resolve against height), or,\n• the inline axis (left/right/top/bottom percentages all resolve against width) A User Agent must choose one of these two behaviors. Note: This variance sucks, but it accurately captures the current state of the world (no consensus among implementations, and no consensus within the CSSWG). It is the CSSWG’s intention that browsers will converge on one of the behaviors, at which time the spec will be amended to require that. Authors should avoid using percentages in paddings or margins on flex items entirely, as they will get different behavior in different browsers.\n• Handle min/max constraints in sizing flex items.\n• Determine the available main and cross space for the flex items. For each dimension, if that dimension of the flex container’s content box is a definite size, use that; if that dimension of the flex container is being sized under a min or max-content constraint, the available space in that dimension is that constraint; otherwise, subtract the flex container’s margin, border, and padding from the space available to the flex container in that dimension and use that value.\n• Correct negation in flex container fragmentation rule: previous definition implied break-inside: avoid behavior in all cases. (Issue 5)\n• If the first fragment of the flex container is not at the top of the page, and of its flex items fit in the remaining space on the page, the entire fragment is moved to the next page.\n• Miscellaneous minor editorial improvements and fixes to errors in examples.\n\nChanges since the 25 September 2014 LCWD\n\nA Disposition of Comments is also available.\n• Reverted flex-basis: auto to its original meaning. Added flex-basis: content keyword to explicitly specify automatic content-based sizing. (Issue 10)\n• Made applicability of align-content depend on wrappability rather than number of resulting flex lines. (Issue 4) In a multi-line flex container (even one with only a single line), the cross size of each line is the minimum size necessary [...] When a flex container (even a multi-line one) has only one line, the cross size of the line is the cross size of the flex container, and align-content has no effect. Note, this property has no effect when the flex container has only a single line. Only ever have free space in the cross-axis for lines to be aligned in, because in a the sole line automatically stretches to fill the space. If the flex container has only one flex line (even if it’s a multi-line flex container) and has a definite cross size, the cross size of the flex line is the flex container’s inner cross size. If the flex container has only one flex line (even if it’s a multi-line flex container), then clamp the line’s cross-size to be within the container’s computed min and max cross-size properties.\n• Removed text that asserted forced breaking behavior, replaced with reference to fragmentation section. This resolves a conflict in the spec. (Issue 18) collect consecutive items one by one until the first time that the next collected item would not fit into the flex container’s inner main size, or until a forced break is encountered . [...] A break is forced wherever the CSS2.1 page-break-before/page-break-after [CSS21] or the CSS3 break-before/break-after [CSS3-BREAK] properties specify a fragmentation break.\n• Change the flex shrink factor to multiply by the (not outer) flex base size. (Issue 9) For every unfrozen item on the line, multiply its flex shrink factor by its flex base size, and note this as its scaled flex shrink factor.\n• Add back in missing “n” in “neither”... (Issue 6) If the cross size property of the flex item computes to auto, and either of the cross-axis margins are , the flex item is stretched.\n• Specify that the flex container’s main size must also be definite for a flex item’s flexed main size to be definite. (Issue 20) [If] ... the flex item has a definite flex basis, and the flex container has a definite main size, the flex item’s main size must be treated as definite ...\n• Remove the requirement that the flex basis be content for the specified size to be defined. The specified size should always win if it is smaller than the intrinsic size. This is particularly important to maintain author expectations for, e.g. . (Issue 25) If the item’s computed flex-basis is content and its computed main size property is definite, then the specified size is that size\n• Remove the requirement that anonymous block creation (for things like display: table-cell) occur flex item blockification. (Instead, all children now blockify immediately, consistent with abspos/float behavior.)\n• Clarify that flex base size is unclamped. (Issue 21) When determining the flex base size, the item’s min and max main size properties are ignored (no clamping occurs). The hypothetical main size is the item’s flex base size clamped according to its min and max main size properties.\n• Restored normative status of note about table wrapper boxes normative; it had been accidentally changed in the previous draft. (Issue 2)\n• Removed references to display property longhands, since they will be removed from CSS Display Level 3.\n• Change wording to not imply an unnecessary layout pass. (Issue 22) Otherwise, the item into the available space using its used flex basis in place of its main size, treating a value of content as max-content.\n• Renamed “clamped size” to “specified size” in the definition of .\n\nChanges since the 25 March 2014 LCWD\n\nA Disposition of Comments is also available.\n\nThe following significant changes were made since the 25 March 2014 Last Call Working Draft\n• Fixed errors (missing negation, unspecified axis) in definition of . (Issues 11, 18, 30) On a flex item whose overflow is visible ,\n• Expanded and rewrote definition of to add special handling of items with intrinsic ratios. (Issues 16 and 28) On a flex item whose overflow is not visible, the following table gives the minimum size: [see table] \n\n this keyword specifies as the minimum size the smaller of:\n• the computed width/height, if that value is definite.\n• Adjusted to only apply the computed main size as a minimum in cases where the flex basis was retrieved from the main size property. (Issue 19) … is defined if the item’s computed flex-basis is auto and its computed main size property is definite …\n• Defined that any size adjustment imposed by a box’s is not consulted when percentage-sizing any of its contents. (Issue 27) This change was later reverted with an opposite definition. In order to prevent cycling sizing, the auto value of min-height and max-height does not factor into the percentage size resolution of the box’s contents. For example, a percentage-height block whose flex item parent has height: 120em; min-height: auto will size itself against height: 120em regardless of the impact that min-height might have on the used size of the flex item.\n• Introduced extra keyword to flex-basis so that “lookup from main-size property” and “automatic sizing” behaviors could each be explicitly specified. (Issue 20) This change was later reverted with an alternative proposal solving the same problem by instead introducing the content keyword.\n• Defined flex items with a definite flex basis to also be definite in the main axis, allowing resolution of percentage-sized children even when the item itself is flexible. (Issue 26) If a percentage is going to be resolved against a flex item’s main size, and the flex item has a definite flex basis, the main size must be treated as definite for the purpose of resolving the percentage, and the percentage must resolve against the flexed main size of the flex item (that is, after the layout algorithm below has been completed for the flex item’s flex container, and the flex item has acquired its final size).\n• Clamp a single line flexbox’s line cross size to the container’s own min/max, even when the container’s size is indefinite. (Issue 9)\n• The used cross-size of the flex line is the largest of the numbers found in the previous two steps and zero. If the flex container has only one flex line (even if it’s a multi-line flex container), then clamp the line’s cross-size to be within the container’s computed min and max cross-size properties. Note that if CSS 2.1’s definition of min/max-width/height applied more generally, this behavior would fall out automatically.\n• Fixed various errors in the new Resolving Flexible Lengths section (see March 2014 rewrite to create continuity between and ) and reverted the editorial structure to match the old Candidate Recommendation. (Issues 3, 4, 8, 10, 15)\n• Fixed max-content sizing of flex containers to account for flexing behavior by normalizing per flex fraction rather than merely summing the max-content sizes of the flex items. (Issue 39)\n• Updated flex property to accept animations always, now that the discontinuity between 0 and non-0 values has been fixed. (Issue 5)\n\nThe following significant changes were made since the 25 March 2014 Last Call Working Draft\n• Clarified how the static position of an absolutely-positioned child of a flex container is calculated by introducing an explanation of the effect more closely tied with CSS2.1 concepts and terminology. (Issue 12) static position of an absolutely-positioned child of a flex container is calculated by first doing full flex layout without the absolutely-positioned children, then positioning each absolutely-positioned child determined such that the child is positioned as if it were the sole flex item in the flex container, assuming both the child and the flex container were fixed-size boxes of their used size. In other words, the static position of an absolutely positioned child of a flex container is determined by setting the child’s static-position rectangle to the flex container’s content box, then aligning the absolutely positioned child within this rectangle according to the justify-content value of the flex container and the align-self value of the child itself.\n• Clarified application of order to absolutely-positioned children of the flex container. (Note, this behavior was later rescinded.) An absolutely-positioned child of a flex container does not participate in flex layout . However, it does participate in the reordering step (see order), which has an effect in their painting order. The order property controls the order in which appear within their flex container… Unless otherwise specified by a future specification, this property has no effect on boxes that are not . Note: Absolutely-positioned children of a flex container do not participate in flex layout, but are reordered together with any flex item children.\n• Clarified what a stretched flex item is for the purposes of special behavior (like definiteness). (Issue 25) If the cross size property of the flex item computes to auto, and either of the cross-axis margins are auto, the flex item is stretched. Its used value …\n\nChanges since the 18 September 2012 Candidate Recommendation\n\nA Disposition of Comments is also available.\n\nThe following significant changes were made since the 18 September 2012 Candidate Recommendation:\n• Changed the behavior of the new auto initial value of min-width/min-height to\n• Take into account whether overflow is visible, since when overflow is explicitly handled, it is confusing (and unnecessary) to force enough size to show all the content.\n• Take into account the specified width/height, so that the implied minimum is never greater than the specified size.\n• Compute to itself (not to min-content) on flex items, since they are no longer equivalent (due to above changes). (Issue 19) When used as the value of a flex item’s min main size property, this keyword indicates a minimum of the min-content size, to help ensure that the item is large enough to fit its contents. It is intended that this will compute to the min-content keyword when the specification defining it ([CSS-SIZING-3]) is sufficiently mature. On a flex item whose overflow is not visible, this keyword specifies as the minimum size the smaller of:\n• the computed width/height, if that value is definite.\n• Specified that percentage margins/paddings on flex items are resolved against their respective dimensions, not the inline dimension of the containing block like blocks do. (Issue 16) Percentage margins and paddings on flex items are always resolved against their respective dimensions; unlike blocks, they do not always resolve against the inline dimension of their containing block.\n• Pass definiteness of a single-line flex container’s size through to any stretched items. (Issue 3) As a special case for handling stretched flex items, if a single-line flex container has a definite cross size, the outer cross size of any flex items with align-self: stretch is the flex container’s inner cross size (clamped to the flex item’s min and max cross size) and is considered definite.\n• Allow percentages inside a stretched auto-height flex item to resolve by requiring a relayout pass. (Issue 3) If the flex item has align-self: stretch, redo layout for its contents, treating this used size as its definite cross size so that percentage-sized children can be resolved. Note that this step does not affect the main size of the flex item, even if it has an intrinsic aspect ratio.\n• Allow intrinsic aspect ratios to inform the main-size calculation. (Issue 8) If the flex item has ... then the flex base size is calculated from its inner cross size and the flex item’s intrinsic aspect ratio.\n• Define hypothetical main size when the main size depends on the cross size. (Issue 23) If a cross size is needed to determine the main size (e.g. when the flex item’s main size is in its block axis) and the flex item’s cross size is auto and not definite, in this calculation use as the flex item’s cross size.\n• Defined the intrinsic sizes of flex containers. Determine the main size of the flex container using its main size property. In this calculation, the min content main size of the flex container is the maximum of the flex container’s items' min-content size contributions, and the max content main size of the flex container is the sum of the flex container’s items' max-content size contributions. The min-content/max-content main size contribution of an item is its outer hypothetical main size when sized under a min-content/max-content constraint (respectively). For this computation, ‘auto’ margins on flex items are treated as ‘0’. The max-content main size of a flex container is the sum of the flex container’s items' max-content contributions in the main axis. The min-content main size of a single-line flex container is the sum of the flex container’s items' min-content contributions in the main axis; for a multi-line container, it is the largest of those contributions. The min-content cross size and max-content cross size of a flex container are the cross size of the flex container after performing layout into the given available main-axis space and infinite available cross-axis space. The main-size min-content/max-content contribution of a flex item is its outer hypothetical main size when sized under a min-content/max-content constraint (respectively). See [CSS-SIZING-3] for a definition of the terms in this section.\n• Correct an omission in the flex-line size determination, so a single-line flexbox will size to its contents if it doesn’t have a definite size. If the flex container has only one flex line (even if it’s a multi-line flex container) , the cross size of the flex line is the flex container’s inner cross size.\n• Flex lines have their size floored at 0. (Issue 2) The used cross-size of the flex line is the of the numbers found in the previous two steps .\n• Flex items paint like inline blocks rather than blocks. (Issue 18) Flex items paint exactly the same as .\n• An omitted flex-basis component of the flex shorthand now resolves to instead of . Because percentages resolved against indefinite sizes behave as auto, this gives better behavior in shrink-wrapped flex containers. (Issue 20) When omitted from the flex shorthand, its specified value is . Note: This change was reverted.\n• Defined that an unresolvable percentage flex base size is treated as auto. percentage values of flex-basis are resolved against the flex item’s containing block, i.e. its flex container, and if that containing block’s size is indefinite, the result is the same as a main size of auto .\n• Simplified the static position of abspos children of flex containers to be consistent with Grid Layout. (Issue 6) An absolutely-positioned child of a flex container does not participate in flex layout beyond the reordering step. However, if both left and right or both top and bottom are auto, then the used value of those properties are computed from its static position, as follows: If both left and right are auto, the flex item must be positioned so that its main-start or cross-start edge (whichever is in the horizontal axis) is aligned with the static position. If both top and bottom are auto, the flex item must be positioned so that its main-start or cross-start edge (whichever is in the vertical axis) is aligned with the static position.\n• If there is a subsequent in-flow flex item on the same flex line, the static position is the outer main-start edge of that flex item.\n• Otherwise, if there is a preceding in-flow flex item on the same flex line, the static position is the outer main-end edge of that flex item.\n• Otherwise, the static position is determined by the value of justify-content on the flex container as if the static position were represented by a zero-sized flex item.\n• If there is a preceding in-flow flex item, the static position is the cross-start edge of the flex line that item is in.\n• Otherwise, the static position is the cross-start edge of the first flex line. The static position is intended to more-or-less match the position of an anonymous 0×0 in-flow flex-start-aligned flex item that participates in flex layout, the primary difference being that any packing spaces due to justify-content: space-around or justify-content: space-between are suppressed around the hypothetical item: between it and the next item if there is a real item after it, else between it and the previous item (if any) if there isn’t. Its static position is calculated by first doing full flex layout without the absolutely-positioned children, then positioning each absolutely-positioned child as if it were the sole flex item in the flex container, assuming both the child and the flex container were fixed size boxes of their used size. For example, by default, the static position of an absolutely positioned child aligns it to the main-start/cross-start corner, corresponding to the default values of justify-content and align-content on the flex container. Setting on the flex container, however, would center it in the main axis.\n• Changed algorithm for resolving flexible lengths to make behavior continuous as the sum of the flex factors approaches zero. (No change for a sum ≥ 1.) (Issue 30) Replaces this section with this one.\n\nThe following significant clarifications were also made:\n• Absolutely positioned children of a flex container are no longer called \"flex items\" (to avoid terminology confusion). (??) Re-order the flex items according to their order.\n• Clarified that float still affects the computed display (which may affect box-fixup rules that run prior to flex item determination). (Issue 7) float and clear have no effect on a flex item , and do not take it out-of-flow. However, the float property can still affect box generation by influencing the display property’s computed value.\n• Clarify what is meant by “white space”. (Issue 26) However, an anonymous flex item that contains only white space is not rendered, as if it were .\n• Clarified that table anonymous box generation occurs in place of computed value conversion for internal table elements.\n• Clarified interaction of flex item determination with / (the new longhands of display defined in the CSS Display Module Level 3). If the specified of an in-flow child of an element that generates a flex container is , it computes to . (This effectively converts any inline display values to their block equivalents.) Note: This change was reverted.\n• Clarified that ::first-line and ::first-letter pseudo-elements do not apply to flex containers (because they are not block containers).\n• Clarify that stretch checks for the value of the cross-size property being auto, which means that percentage cross-sizes that behave as auto (because they don’t resolve against definite sizes) aren’t stretched. (Issue 5) If the cross size property of the flex item auto, its used value is … Determine the used cross size of each flex item. If a flex item has align-self: stretch, its cross size property is auto, and …\n• Clarify that the rules of the formatting context are used for determining the flex container’s main size. Determine the main size of the flex container using the rules of the formatting context in which it participates .\n• Clarified that order-modified document order is used instead of raw document order when painting. (This was already stated in the order section, but not in the section explicitly about painting order.)\n• Clarified line-breaking to precisely handle negatively-sized flex items and zero-size items at the end of a line. (Issue 1) Otherwise, starting from the first uncollected item, collect consecutive items one by one until the first time that the collected item would not fit into the flex container’s inner main size, or until a forced break is encountered. If the very first uncollected item wouldn’t fit, collect just it into the line as many consecutive flex items as will fit or until a forced break is encountered (but collect at least one) into the flex container’s inner main size into a flex line . Note that items with zero main size will never start a line unless they’re the very first items in the flex container, or they’re preceded by a forced break. The \"collect as many\" line will collect onto the end of the previous line even if the last non-zero item exactly \"filled up\" the line.\n• Clarified that flex container cross sizes are still clamped by the flex container’s min/max properties. (Issue 24)\n• If the cross size property is a definite size, use that, clamped by the min and max cross size properties of the flex container .\n• Otherwise, use the sum of the flex lines' cross sizes, clamped by the min and max cross size properties of the flex container .\n\nFlexbox introduces no new privacy leaks, or security considerations beyond \"implement it correctly\"."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/CSS/display",
        "document": "This feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015 . * Some parts of this feature may have varying levels of support.\n\nThe CSS property sets whether an element is treated as a block or inline box and the layout used for its children, such as flow layout, grid or flex. Formally, the property sets an element's inner and outer display types. The outer type sets an element's participation in flow layout; the inner type sets the layout of children. Some values of are fully defined in their own individual specifications; for example the detail of what happens when is declared is defined in the CSS Flexible Box Model specification.\n\nThese keywords specify the element's outer display type, which is essentially its role in flow layout: The element generates a block box, generating line breaks both before and after the element when in the normal flow. The element generates one or more inline boxes that do not generate line breaks before or after themselves. In normal flow, the next element will be on the same line if there is space. Note: When browsers that support multi-keyword syntax encounter a display property that only has an outer value (e.g., or ), the inner value is set to (e.g., and ). Note: To be sure layouts work on older browsers, you may use single-value syntax, for example could have the following fallback See Using the multi-keyword syntax with CSS display for more information.\n\nThese keywords specify the element's inner display type, which defines the type of formatting context that its contents are laid out in (assuming it is a non-replaced element): The element lays out its contents using flow layout (block-and-inline layout). If its outer display type is , and it is participating in a block or inline formatting context, then it generates an inline box. Otherwise it generates a block box. Depending on the value of other properties (such as , , or ) and whether it is itself participating in a block or inline formatting context, it either establishes a new block formatting context (BFC) for its contents or integrates its contents into its parent formatting context. The element generates a block box that establishes a new block formatting context, defining where the formatting root lies. These elements behave like HTML elements. It defines a block-level box. The element behaves like a block-level element and lays out its content according to the flexbox model. The element behaves like a block-level element and lays out its content according to the grid model. The element behaves like an inline-level element and lays out its content according to the ruby formatting model. It behaves like the corresponding HTML elements. Note: When browsers that support multi-keyword syntax encounter a display property that only has an inner value (e.g., or ), the outer value is set to (e.g., and ).\n\nThe element generates a block box for the content and a separate list-item inline box. A single value of will cause the element to behave like a list item. This can be used together with and . can also be combined with any keyword and the or keyword. Note: In browsers that support the multi-keyword syntax, if no inner value is specified, it will default to . If no outer value is specified, the principal box will have an outer display type of .\n\nWhich syntax should you use? The CSS display module describes a multi-keyword syntax for values you can use with the property to explicitly define outer and inner display. The single keyword values (precomposed values) are supported for backward-compatibility. For example, using two values you can specify an inline flex container as follows: This can also be specified using the legacy single value: For more information on these changes, see the Using the multi-keyword syntax with CSS display guide.\n\nSupporting browsers animate with a discrete animation type. This generally means that the property will flip between two values 50% through animating between the two. There is one exception, which is when animating to or from . In this case, the browser will flip between the two values so that the animated content is shown for the entire animation duration. So for example:\n• When animating from to (or another visible value), the value will flip to at of the animation duration so it is visible throughout.\n• When animating from (or another visible value) to , the value will flip to at of the animation duration so it is visible throughout. This behavior is useful for creating entry/exit animations where you want to for example remove a container from the DOM with , but have it fade out with rather than disappearing immediately. When animating with CSS animations, you need to provide the starting value in an explicit keyframe (for example using or ). See Using CSS animations for an example. When animating with CSS transitions, two additional features are needed:\n• provides starting values for properties you want to transition from when the animated element is first shown. This is needed to avoid unexpected behavior. By default, CSS transitions are not triggered on an element's first style update or when the type changes from to another type.\n• needs to be set on the declaration (or the shorthand) to enable transitions. For examples of transitioning the property, see the and pages.\n\nIn this example we have two block-level container elements, each one with three inline children. Below that, we have a select menu that allows you to apply different values to the containers, allowing you to compare and contrast how the different values affect the element's layout, and that of their children. We have included and on the containers and their children, so that it is easier to see the effect the display values are having. Note that some multi-keyword values are added for illustration which have the following equivalents: You can find more examples in the pages for each separate display type under Grouped values."
    },
    {
        "link": "https://w3schools.com/html/html_css.asp",
        "document": "CSS saves a lot of work. It can control the layout of multiple web pages all at once.\n\nCascading Style Sheets (CSS) is used to format the layout of a webpage.\n\nWith CSS, you can control the color, font, the size of text, the spacing between elements, how elements are positioned and laid out, what background images or background colors are to be used, different displays for different devices and screen sizes, and much more!\n\nTip: The word cascading means that a style applied to a parent element will also apply to all children elements within the parent. So, if you set the color of the body text to \"blue\", all headings, paragraphs, and other text elements within the body will also get the same color (unless you specify something else)!\n\nCSS can be added to HTML documents in 3 ways:\n• Inline - by using the attribute inside HTML elements\n• Internal - by using a element in the section\n• External - by using a element to link to an external CSS file\n\nThe most common way to add CSS, is to keep the styles in external CSS files. However, in this tutorial we will use inline and internal styles, because this is easier to demonstrate, and easier for you to try it yourself.\n\nAn inline CSS is used to apply a unique style to a single HTML element.\n\nAn inline CSS uses the attribute of an HTML element.\n\nThe following example sets the text color of the element to blue, and the text color of the element to red:\n\nAn internal CSS is used to define a style for a single HTML page.\n\nAn internal CSS is defined in the section of an HTML page, within a element.\n\nThe following example sets the text color of ALL the elements (on that page) to blue, and the text color of ALL the elements to red. In addition, the page will be displayed with a \"powderblue\" background color:\n\nAn external style sheet is used to define the style for many HTML pages.\n\nTo use an external style sheet, add a link to it in the section of each HTML page:\n\nThe external style sheet can be written in any text editor. The file must not contain any HTML code, and must be saved with a .css extension.\n\nHere is what the \"styles.css\" file looks like:\n\nHere, we will demonstrate some commonly used CSS properties. You will learn more about them later.\n\nThe CSS property defines the text color to be used.\n\nThe CSS property defines the font to be used.\n\nThe CSS property defines the text size to be used.\n\nThe CSS property defines a border around an HTML element.\n\nTip: You can define a border for nearly all HTML elements.\n\nThe CSS property defines a padding (space) between the text and the border.\n\nThe CSS property defines a margin (space) outside the border.\n\nExternal style sheets can be referenced with a full URL or with a path relative to the current web page.\n• Use the HTML attribute for inline styling\n• Use the HTML element to define internal CSS\n• Use the HTML element to refer to an external CSS file\n• Use the HTML element to store <style> and <link> elements\n• Use the CSS property for text colors\n• Use the CSS property for text fonts\n• Use the CSS property for text sizes\n• Use the CSS property for borders\n• Use the CSS property for space inside the border\n• Use the CSS property for space outside the border"
    },
    {
        "link": "https://stackoverflow.com/questions/20086008/proper-way-of-styling-html-elements",
        "document": "I know you can do this:\n\nI don't use this first method, because I know external stylesheets are meant to seperate the CSS from the HTML code. And I like to keep it that way.\n\nSometimes I use this method, but when I look at some of the professional HTML coding of big sites like Facebook, Instagram or Twitter I see that they use a lot of container s, which makes me unsure whether I'm doing it right or not.\n\nI found that I mostly use this method for some reason I actually don't really know. But in this case I just add styling to the and not directly to the . Or when I do, I directly add styling to the element by selecting it with in the CSS.\n\nUsually I do it this way if a container is just necessary to get the job done, where I would have some styling on the and some on the element.\n\nI know there probably are more ways, but it's mainly these last two methods I'm not too sure about when to use them. I know there are other HTML elements out there but I just took a and for demonstration.\n\nWith that being said, I would like to know what are the pros and cons of each and which method should be a good practise?"
    },
    {
        "link": "https://help.heap.io/data-management/code-and-framework-management/html-css-best-practices",
        "document": ""
    },
    {
        "link": "https://stackoverflow.com/questions/50165584/what-is-best-practice-in-regards-to-html-propertys-or-css-styling",
        "document": "Are there any downsides or advantages to using html property such as width=\"\" as opposed to CSS?\n\nWhen validating code W3 gives the error 'The “width” attribute on the “img” element is obsolete. Use CSS instead.'\n\nI default to using CSS but my coworkers seem to default to the other way. Before bringing it up with them I wanted to make sure that i had my facts straight that setting the width in html is leftover from a old html version and that for future proofing and best practice we should be using CSS.\n\n*clarity : I normal use a Style Sheet however in the example for a more direct comparison I used inline styles."
    }
]