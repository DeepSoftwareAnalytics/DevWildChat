[
    {
        "link": "https://vuejs.org/guide/essentials/template-refs",
        "document": "While Vue's declarative rendering model abstracts away most of the direct DOM operations for you, there may still be cases where we need direct access to the underlying DOM elements. To achieve this, we can use the special attribute:\n\nis a special attribute, similar to the attribute discussed in the chapter. It allows us to obtain a direct reference to a specific DOM element or child component instance after it's mounted. This may be useful when you want to, for example, programmatically focus an input on component mount, or initialize a 3rd party library on an element.\n\nTo obtain the reference with Composition API, we can use the helper: // the first argument must match the ref value in the template When using TypeScript, Vue's IDE support and will automatically infer the type of based on what element or component the matching attribute is used on. In versions before 3.5 where was not introduced, we need to declare a ref with a name that matches the template ref attribute's value: // the name must match template ref value If not using , make sure to also return the ref from :\n\nNote that you can only access the ref after the component is mounted. If you try to access in a template expression, it will be on the first render. This is because the element doesn't exist until after the first render!\n\nIt should be noted that the ref array does not guarantee the same order as the source array.\n\nInstead of a string key, the attribute can also be bound to a function, which will be called on each component update and gives you full flexibility on where to store the element reference. The function receives the element reference as the first argument:\n\nNote we are using a dynamic binding so we can pass it a function instead of a ref name string. When the element is unmounted, the argument will be . You can, of course, use a method instead of an inline function.\n\ncan also be used on a child component. In this case the reference will be that of a component instance:\n\nIf the child component is using Options API or not using , theThe referenced instance will be identical to the child component's , which means the parent component will have full access to every property and method of the child component. This makes it easy to create tightly coupled implementation details between the parent and the child, so component refs should be only used when absolutely needed - in most cases, you should try to implement parent / child interactions using the standard props and emit interfaces first.\n\nAn exception here is that components using are private by default: a parent component referencing a child component using won't be able to access anything unless the child component chooses to expose a public interface using the macro: // Compiler macros, such as defineExpose, don't need to be imported When a parent gets an instance of this component via template refs, the retrieved instance will be of the shape (refs are automatically unwrapped just like on normal instances). Note that defineExpose must be called before any await operation. Otherwise, properties and methods exposed after the await operation will not be accessible."
    },
    {
        "link": "https://stackoverflow.com/questions/54836341/how-to-reference-child-elements-in-a-component",
        "document": "I'm trying to build a parent-child tree in Vue, and I want to pass the parent's DOM/element ID down to the child so that they can append to it. Here is a simple example of what I am trying to achieve as the DOM structure in the browser:\n\nThe only way I have been able to do this so far is to duplicate the into another property and pass them both down the tree. This seems messy. See my sample code:\n\nI'm guessing there must be a better way to achieve this? It seems like it should be a simple task? Thanks."
    },
    {
        "link": "https://stackoverflow.com/questions/73753350/how-to-get-the-ref-which-is-in-a-child-component-in-vue",
        "document": "I'm trying to access a ref from a parent component which is defined in the child component. I've got a file where I call the parent component and inside of the component I call 2 child components like so:\n\nInside I've got a and no other html, but that is where I need to call a ref which is listed in the . Here is my file:\n\nHow will I be able to call the ref inside the parent? I've tried calling the ref like this:\n\nBut these resulted in an undefined, an empty object and a cannot read properties of undefined (reading '$refs'). Any help would be appreciated!"
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Learn_web_development/Core/Frameworks_libraries/Vue_refs_focus_management",
        "document": "We are nearly done with Vue. The last bit of functionality to look at is focus management, or put another way, how we can improve our app's keyboard accessibility. We'll look at using Vue refs to handle this — an advanced feature that allows you to have direct access to the underlying DOM nodes below the virtual DOM, or direct access from one component to the internal DOM structure of a child component. Familiarity with the core HTML, CSS, and JavaScript languages, knowledge of the terminal/command line. Vue components are written as a combination of JavaScript objects that manage the app's data and an HTML-based template syntax that maps to the underlying DOM structure. For installation, and to use some of the more advanced features of Vue (like Single File Components or render functions), you'll need a terminal with node + npm installed. To learn how to handle focus management using Vue refs.\n\nWhile we do have working edit functionality, we aren't providing a great experience for non-mouse users. Specifically, when a user activates the \"Edit\" button, we remove the \"Edit\" button from the DOM, but we don't move the user's focus anywhere, so in effect it just disappears. This can be disorienting for keyboard and non-visual users.\n• Reload your page, then press . You should see a focus outline on the input for adding new to-do items.\n• Press again. The focus should move to the \"Add\" button.\n• Hit it again, and it'll be on the first checkbox. One more time, and focus should be on the first \"Edit\" button.\n• Activate the \"Edit\" button by pressing . The checkbox will be replaced with our edit component, but the focus outline will be gone. This behavior can be jarring. In addition, what happens when you press again varies depending on the browser you're using. Similarly, if you save or cancel your edit, focus will disappear again as you move back to the non-edit view. To give users a better experience, we'll add code to control the focus so that it gets set to the edit field when the edit form is shown. We'll also want to put focus back on the \"Edit\" button when a user cancels or saves their edit. In order to set focus, we need to understand a little bit more about how Vue works internally.\n\nVue, like some other frameworks, uses a virtual DOM (VDOM) to manage elements. This means that Vue keeps a representation of all of the nodes in our app in memory. Any updates are first performed on the in-memory nodes, and then all the changes that need to be made to the actual nodes on the page are synced in a batch. Since reading and writing actual DOM nodes is often more expensive than virtual nodes, this can result in better performance. However, it also means you often should not edit your HTML elements directly through native browser APIs (like ) when using frameworks, because it results in the VDOM and real DOM going out of sync. Instead, if you need to access the underlying DOM nodes (like when setting focus), you can use Vue refs. For custom Vue components, you can also use refs to directly access the internal structure of a child component, however this should be done with caution as it can make code harder to reason about and understand. To use a ref in a component, you add a attribute to the element that you want to access, with a string identifier for the value of the attribute. It's important to note that a ref needs to be unique within a component. No two elements rendered at the same time should have the same ref.\n\nWe want to set focus on the \"Edit\" button when a user saves or cancels their edit. To do that, we need to handle focus in the component's and methods. For convenience, create a new method which takes no arguments called . Inside it, assign your to a variable, and then call the method on the ref. Next, add a call to at the end of the and methods: Try editing and then saving/cancelling a to-do item via your keyboard. You'll notice that focus isn't being set, so we still have a problem to solve. If you open your console, you'll see an error raised along the lines of \"can't access property \"focus\", editButtonRef is undefined\". This seems weird. Your button ref was defined when you activated the \"Edit\" button, but now it's not. What is going on? Well, remember that when we change to , we no longer render the section of the component featuring the \"Edit\" button. This means there's no element to bind the ref to, so it becomes . You might now be thinking \"hey, don't we set before we try to access the , so therefore shouldn't the now be displaying the button?\" This is where the virtual DOM comes into play. Because Vue is trying to optimize and batch changes, it won't immediately update the DOM when we set to . So when we call , the \"Edit\" button has not been rendered yet. Instead, we need to wait until after Vue undergoes the next DOM update cycle. To do that, Vue components have a special method called . This method accepts a callback function, which then executes after the DOM updates. Since the method needs to be invoked after the DOM has updated, we can wrap the existing function body inside a call. Now when you activate the \"Edit\" button and then cancel or save your changes via the keyboard, focus should be returned to the \"Edit\" button. Success!\n\nNext, we need to move focus to the edit form's element when the \"Edit\" button is clicked. However, because our edit form is in a different component to our \"Edit\" button, we can't just set focus inside the \"Edit\" button's click event handler. Instead, we can use the fact that we remove and re-mount our component whenever the \"Edit\" button is clicked to handle this. So how does this work? Well, Vue components undergo a series of events, known as a lifecycle. This lifecycle spans from all the way before elements are created and added to the VDOM (mounted), until they are removed from the VDOM (destroyed). Vue lets you run methods at various stages of this lifecycle using lifecycle methods. This can be useful for things like data fetching, where you may need to get your data before your component renders, or after a property changes. The list of lifecycle methods are below, in the order that they fire.\n• — Runs before the instance of your component is created. Data and events are not yet available.\n• — Runs after your component is initialized but before the component is added to the VDOM. This is often where data fetching occurs.\n• — Runs after your template is compiled, but before your component is rendered to the actual DOM.\n• — Runs after your component is mounted to the DOM. Can access here.\n• — Runs whenever data in your component changes, but before the changes are rendered to the DOM.\n• — Runs whenever data in your component has changed and after the changes are rendered to the DOM.\n• — Runs before a component is removed from the DOM.\n• — Runs after a component has been removed from the DOM.\n• — Only used in components wrapped in a special tag. Runs after the component is activated.\n• — Only used in components wrapped in a special tag. Runs after the component is deactivated. Note: The Vue Docs provide a nice diagram for visualizing when these hooks happen. This article from the DigitalOcean Community Blog dives into the lifecycle methods more deeply. Now that we've gone over the lifecycle methods, let's use one to trigger focus when our component is mounted. In , attach to the element, like so: Next, add a property just inside your component object — note that this should not be put inside the property, but rather at the same hierarchy level as , , and . Lifecycle methods are special methods that sit on their own, not alongside the user-defined methods. This should take no inputs. Note that you cannot use an arrow function here since we need access to to access our ref. Inside your method, assign your ref to a variable, and then call the function of the ref. You don't have to use here because the component has already been added to the DOM when is called. Now when you activate the \"Edit\" button with your keyboard, focus should immediately be moved to the edit .\n\nThere's one more place we need to consider focus management: when a user deletes a to-do. When clicking the \"Edit\" button, it makes sense to move focus to the edit name text box, and back to the \"Edit\" button when canceling or saving from the edit screen. However, unlike with the edit form, we don't have a clear location for focus to move to when an element is deleted. We also need a way to provide assistive technology users with information that confirms that an element was deleted. We're already tracking the number of elements in our list heading — the in — and it's associated with our list of to-do items. This makes it a reasonable place to move focus to when we delete a node. First, we need to add a ref to our list heading. We also need to add a to it — this makes the element programmatically focusable (i.e. it can be focused via JavaScript), when by default it is not. Inside , update your as follows: Note: is a really powerful tool for handling certain accessibility problems. However, it should be used with caution. Over-using can cause problems for all sorts of users, so only use it exactly where you need to. You should also almost never use > = , as it can cause problems for users since it can make the DOM flow and the tab-order mismatch, and/or add non-interactive elements to the tab order. This can be confusing to users, especially those using screen readers and other assistive technology. Now that we have a and have let browsers know that we can programmatically focus the , we need to set focus on it. At the end of , use the ref to set focus on the . Since the is always rendered in the app, you do not need to worry about using or lifecycle methods to handle focusing it. Now, when you delete an item from your list, focus should be moved up to the list heading. This should provide a reasonable focus experience for all of our users."
    },
    {
        "link": "https://blog.logrocket.com/understanding-vue-refs",
        "document": "Editor’s note: This article was last updated by Ikeh Akinyemi on 30 May 2024 to discuss using refs with Vue’s reactivity system and using Vue watchers to watch refs and reactive state.\n\nIn this tutorial, we’ll demonstrate how to reference HTML elements in your Vue.js components. Vue.js is a progressive JavaScript framework that focuses on the view layer, and refs are an important feature in Vue that allows you to easily interact with and manipulate DOM elements. This tutorial is suited for all levels of Vue experience, including beginners.\n\nHere are a few prerequisites before we get started:\n• Node.js version 10.x or above. Verify your version by running in your terminal/command prompt\n• Vue CLI 3.0 installed on your machine. To do this, uninstall the old CLI version first with , then install the new one using\n• Unzip the downloaded project, navigate into it, and run to keep all the dependencies up to date\n\nRefs are Vue.js instance properties used to register or indicate a reference to HTML elements or child elements in the template of your application.\n\nIf a attribute is added to an HTML element in your Vue template, you’ll be able to reference that element or even a child element in your Vue instance. You can also access the DOM element directly; it is a read-only attribute and returns an object.\n\nVue’s helps you “reference” DOM elements more efficiently than JavaScript’s , which is known to create performance issues.\n\nThe attribute makes a DOM element selectable by serving as the key in the parent attribute. Putting a attribute in an input element, for example, will expose the parent DOM node as , or you can format it as .\n\nFor a visual guide on referencing with in Vue.js, check out this video tutorial.\n\nYou can manipulate a DOM element by defining methods on the element’s reference. For example, you could focus on an input element using :\n\nIn this way, refs can be used just like the in JavaScript or the in jQuery. While performs some of the same functions as refs, refs are more efficient because they give you direct access to the specific element you need. On the other hand, simply returns the first element in your DOM that matches the selector you specified.\n\ncan be accessed both inside the Vue.js instance and outside of it. However, they are not data properties, so they are not reactive. On template inspection in your browser, does not show up at all because it is not an HTML attribute; it is only a Vue template attribute.\n\nIf you followed this post from the start, you should have downloaded the Vue starter project and opened it up on VS Code. Open the folder and copy this into the file:\n\nAfter copying the provided code into your file, run the following command in your terminal to start the development server:\n\nOnce the development server is running, open your browser and navigate to the provided local URL (e.g., ). You should see a simpler counter application with an input field and a button. You will see that the counter gets updated on click, but when you open your developer tools in the browser, you will notice that it logs :\n\nIt is important to get the syntax right when accessing refs in Vue. In the code example above, when we log inside the method, it returns . This means that Vue doesn’t raise an error for , even though it is incorrect syntax.\n\nCopy the code below into the file:\n\nWhen you run restart the development server and inspect the result of the new code implementation, you will notice that it now returns an object:\n\nA quick look at the code block will reveal the correct syntax: inside the template, it is called , but when we referred to it inside the script, it was called . This is important to note so we don’t get an undefined return.\n\nThe syntax that is used inside the template is an attribute given to an element. , on the other hand, is a collection of the elements in your application that have been given the attribute. You can access every single possible property of the referenced element, including the element, as it is in the template.\n\nUsing in the Composition API\n\nIn Vue 3’s Composition API, you can create refs using the function. By using refs in the Composition API, you can easily access and manipulate DOM elements, store reactive values, and integrate with other Composition API features like and .\n\nIn Vue 3, the reactivity system is built on top of the and functions. Both and allow you to create reactive state in your components, but they have some differences in their usage and behavior.\n\nHere’s an example that demonstrates the usage of and in a component:\n\nThe function takes an initial value and returns a reactive reference to that value. And the s can hold any value type, including primitives, objects, and arrays:\n\nIn the above example, we used in the template to create a reference to the element. Then, in the function, we used to create a that would store the reference to the element.\n\nNext, we have , which creates another ref that is used to store the value of the element and is bound to the directive in the template. With these two references, you can automatically call inside the lifecycle Hook, focusing the element when the component is mounted. Then the function is defined to programmatically focus the element when the button is clicked.\n\nLet’s try logging some of the properties that might be of interest to us. Your file should look like this:\n\nThe application on your browser should look like this:\n\nTo display the HTML element as it is in the DOM, go into the method and change the code to the following:\n\nThe input here is the reference name you created earlier inside the element ( ). It can be any name of your choice.\n\nTo display the HTML element input value — the string that was typed into the text box in the user interface — go into the method and change the code like so:\n\nThis displays exactly the string you type in, demonstrating functionality similar to what can be achieved using in vanilla JavaScript or jQuery’s selector methods.\n\nThe webpage in which the element can be found is also one of the many things that can be displayed with the Vue . Go into the method and change the code to this:\n\nThere are many other things you can both access and log with the just by the information on the returned object.\n\nVue.js refs can also be used inside elements that generate multiple items in the DOM, like conditional statements where directives are used. Instead of returning a single object, refs return an array of the items when called. To illustrate this, let’s create a simple list:\n\nWhen you run it in the development server again, it will look like this:\n\nVue watchers allow you to observe changes in reactive data and perform actions based on those changes. In Vue 3, you can use the function to watch refs and reactive state.\n\nTo watch a ref, you can pass the ref directly as the first argument to the function. Here’s an example:\n\nIn this example, we have a ref that is bound to an input field using . We also have a ref that will display the reversed version of the message.\n\nWe use the function to watch the ref. Whenever the value of changes, the callback function is triggered, and it reverses the message and assigns it to . You can also watch multiple refs or a combination of refs and reactive state by passing an array to the function:\n\nUse cases for Vue with refs\n• Computed properties: Watchers can be used as an alternative to computed properties. If you have a complex computation that depends on multiple refs or reactive state, you can use a watcher to perform the computation whenever any of the dependencies change\n• Side effects: Watchers are useful for triggering side effects based on changes in refs or reactive state. For example, you can use a watcher to make an API call whenever a specific ref value changes\n• Validation: Watchers can be used to validate user input in real time. You can watch a ref that represents user input and perform validation checks whenever the input value changes\n• Data synchronization: Watchers can be used to synchronize data between different parts of your application. For example, if you have a ref that represents a selected item, you can use a watcher to update other parts of the UI based on the selected item\n• Animations: Watchers can be used to trigger animations based on changes in refs or reactive state. You can watch a ref and apply animations whenever its value changes\n\nHere’s an example that demonstrates using a watcher for data synchronization:\n\nIn this example, we have a ref bound to a select dropdown using . We also have a ref that will display a message based on the selected option. We use a watcher to watch the ref. Whenever the selected option changes, the watcher callback function is triggered and updates the ref based on the selected value.\n\nBy integrating refs with watchers, you can perform reactive updates and trigger actions based on changes in your component’s state. Watchers provide a powerful way to observe and respond to data changes in Vue 3.\n\nChanges and best practices for Refs in Vue 3\n\nLet’s see some changes and improvements introduced in Vue 3 that changed the ways we use refs:\n• The Composition API was introduced in Vue 3 with : is considered the best way to use refs. To use the Composition API, acts as your point of entry whereby you can define your component’s reactive state and methods\n• Template refs: If you are familiar with Vue 2, it is easy to understand what template refs in Vue 3 should look like. In the Composition API, you need to declare the ref using the function and expose it to the template\n• References with reactivity: Refs in Vue 3 are reactive by default. When you change the value of a ref by using the property to the ref object, it results in a reactive update inside the component, causing the automatic re-render of respective parts of the template\n• Ref typing: Vue 3 provides improved TypeScript support, including better type inference for refs. You can specify the type of a ref using generics,\n\nThis article explored referencing HTML elements in your DOM in Vue.js. You can now access and log these elements by all the element properties, including value, child node, data attributes, and even the base URL that houses it.\n\nIt is important to note that refs get populated after the Vue instance has initialized and the component has been rendered, so using refs in computed properties is discouraged because it can directly manipulate child nodes."
    },
    {
        "link": "https://stackoverflow.com/questions/54355375/vue-js-refs-are-undefined-even-though-this-refs-shows-theyre-there",
        "document": "Main solution is to make sure your component is not imported dynamically\n\nYou'd still need to also avoid wrapping your component with and use in , instead of\n\nI wasn't using Vue Google Maps plugin/component, but my own custom component\n\nUse in instead of .\n\nThis way, and not needed\n\nDo not wrap child component using , use instead.\n\nOther Methods (not proper & not a solution)\n\nThe following are methods I tried but didn't work until I used the methods on top (stopped using dynamic import)\n\nI already put in tried to wrap it with and 2 layers of .\n\nIt works only on hot reload, but no longer works after a page refresh\n\nThanks to this comment in another answer: How to access to a child method from the parent in vue.js"
    },
    {
        "link": "https://stackoverflow.com/questions/53820217/vuejs-components-ref-is-undefined-at-all-stages",
        "document": "I'm learning VueJS using it with a rails app and I'm having issues trying to access a component from a parent component. It's possible I'm doing this wrong but I can't figure out what the problem is.\n\nI've tried to boil down my problem to a simple html example:\n\nI get the following console logs:\n\nI've tried to follow the syntax in https://v2.vuejs.org/v2/api/#ref, but I've also tried using instead of and it doesn't work any better.\n\nI get that there is \"ref registration timing\" complication even if I don't fully understand it. However shouldn't the timing be good when clicking on the H3 ? I was hoping it'd be even resolved by like in https://stackoverflow.com/a/40884455/2730032.\n\nBonus question : My question is really about how ref works. However I do have a more general problem that might benefit with advice not using ref.\n\nI have an component I'm pleased with that wraps an input field for a client_id with a search field that gives some select-like options from an API and sets the input field client_id to the selected option. I want to re-use that component in an component that would use the client_id (whenever it is changed by ) to call an API and fill a bunch of other form fields in the component (those fields being given with to through slots). If that makes any sense.\n\nI figured the best way to do that is put the client_id as a data field of and have access it through . So here I am trying to get to work.\n\nEDIT1: There was a copy mistake, sorry about that. The test1 tag was from a previous version. But I get the problem regardless.\n\nEDIT2: I accepted Roy J second answer because I feel it best answers the question and even though it is not good design it's probably a valid solution for some people. However in my actual implementation I used Roy J first answer and anyone reading this question probably should too (I also managed to add to 's template in order to avoid using )."
    },
    {
        "link": "https://github.com/vuejs/composition-api/issues/6",
        "document": "As a follow-up to liximomo/vue-function-api#10 (comment), the refs are now injected, but they can only be accessed inside of a lifecycle method. I don't believe this is the desired usage.\n\nFor example, I have a custom hook that binds and removes an event listener to the DOM node passed into it as a parameter. Because my custom hook cannot be called inside of a lifecycle method (because it has lifecycle methods inside of it), I can only call my custom hook at the first level of setup(). I like this functionality, and the errors were clear.\n\nSee my CodeSandbox example\n\nMy problem is that the ref is when passing it into the custom hook."
    },
    {
        "link": "https://jefrydco.id/en/blog/safe-access-vue-refs-undefined",
        "document": "The attribute is our last shot to manipulate DOM if any other way can't be used. Some of explanations of attribute are also listed under Handling Edge Cases section on Vue documentation. And it also stated that we have to avoid manipulating DOM elements directly as best as we can.\n\nSo, please check thoroughly if you want to use feature in Vue. It doesn't mean we can't use that feature. It is just as a reminder that we have to make sure it will be worked as our expected.\n\nWe have a Vue component as follow:\n\nIt has an input which attribute is set and a paragraph containing data binding.\n\nLet say we want to make the input focused programmatically. We can do that by calling .\n\nThe problem is, sometimes we can't get the access to the corresponding input refs we want. Because itself is created as a result of the render function. More about this explanation, you can learn more on Ref API - Vue.js.\n\nBefore jump into the next section, let's refresh our understanding about the and a little bit.\n\nis an HTML attribute or component props. Its value will be the name of the reference. On the other hands, is an instance property. We can access the reference name we already declared using from this property.\n\nUsing the example above, we give as attribute value. So we can access it using this way, .\n\nWe have to know where and when we access that property. Here some examples of accessing from different places:\n\nAccessing directly on is undefined. As I described earlier above, the is created as a result of the render function. And is called before render function.\n\nBut, a weird thing happens if we only print . The console output will show the input property. Why does that happen? Dion DiFelice gave a concise explanation on StackOverflow thread, Vue.js refs are undefined, even though this.$refs show they're there:\n\nThat explanation also applies if we access on another Vue.js lifecycle except and .\n\nAccessing directly in computed property will yield the following error on the console:\n\nIt is because the property itself is undefined, so we can't get access to the property.\n\nBesides that, this error also raises:\n\nThat is because of the previous error happens during component rendering. So the computed will be undefined as well.\n\nWatching change on input value won't do anything, because are not reactive. On the subsection of Handling Edge Cases, Accessing Child Component Instances & Child Elements, it states that:\n\nThat will be the same if we only watch the input because the property itself is not reactive.\n\nAccessing in is a little bit tricky. Because it also depends on when and where we call that method. So make sure to not call the method where is undefined.\n\nProbably the safest place to access is on . Accessing and will yield value.\n\nBut if we want to add attribute to a component, we have to confirm that our component isn't loaded as a asynchronous component. Even though we access on , it will return undefined.\n\nWe usually use to overcome getting undefined value problem. But for this case, even though we use multiple levels of . It still won't solve the problem. Learn more about on Async Update Queue - Vue.js.\n\nUsing will delay the execution of the callback function for a certain amount of time. It can work as expected if we know how much delay we can have. And the delay itself depends on the user connectivity as well. The slower internet, the longer the delay will be.\n\nLet say we can't rely on all the previous method we have. So what can we do if we need to access safely?\n\nBefore we continue, let me tell the story of how I found the solution.\n\nA couple days ago, I discovered that the interactive demo on \"Create a Simplified Version of Vue.js Reactivity System\", both on Part 1 and Part 2 weren't worked on a production build. I was suspicious, it was caused by tag that can't be executed inside on production.\n\nI seek another method to inject and run JavaScript after the browser finish loads the chunk.\n\nI decided to use . But the problem was the component is loaded asynchronously. So I have to use, either or to delay the injection script. Unfortunately, none of them works as I expected.\n\nThen I recalled, I've used an NPM Package called wait-for-expect. The package is useful for waiting Jest expectation if we run asynchronous code until the result is expected.\n\nThe idea behind the package is, it runs the callback function containing the expectation code continuously for a certain period. It will stop when the callback function is resolved or not throws any error.\n\nPerhaps I use that mechanism to get value without getting undefined.\n\nStarting from the safest place to get value, we create a variable called and assigned it to calls. It will run the callback function every 50ms.\n\nWe can adjust that 50ms time according to our needs, but here I just follow what did.\n\nInside the callback function, we do checking if exists, we do something with it, print it to the console output for instance. Then, we call function and pass variable to clear up the memory and stop the callback function invocation.\n\nBy doing that, we don't have to know how long the delay until is available. As long as the interval is running, it will execute the callback and do if checking for that.\n\nIf you want to know the implementation in the interactive demo, please take a look at AppDemo10En.vue.\n\nis one of the tricky features to use in Vue.js. To use it we have to do it at the right time and the right place. Even if we already did, sometimes the value is still undefined.\n\nThe safest place to use is on . Other than that, it is prone to be undefined. So, we have to be careful before using it.\n\nTo solve that problem, we can make use of . We put that in the safest place to access , which is in . Inside the callback function we do checking if is already available, then we can do anything with it and the most important thing is stop the timer using .\n• StackOverflow: Vue.js refs are undefined, even though this.$refs show they're there"
    },
    {
        "link": "https://michaelnthiessen.com/this-is-undefined",
        "document": ""
    }
]