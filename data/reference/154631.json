[
    {
        "link": "https://w3schools.com/python/ref_string_format.asp",
        "document": "The method formats the specified value(s) and insert them inside the string's placeholder.\n\nThe placeholder is defined using curly brackets: {}. Read more about the placeholders in the Placeholder section below.\n\nThe placeholders can be identified using named indexes , numbered indexes , or even empty placeholders .\n\nInside the placeholders you can add a formatting type to format the result:"
    },
    {
        "link": "https://docs.python.org/3/tutorial/inputoutput.html",
        "document": "There are several ways to present the output of a program; data can be printed in a human-readable form, or written to a file for future use. This chapter will discuss some of the possibilities.\n\nSo far we’ve encountered two ways of writing values: expression statements and the function. (A third way is using the method of file objects; the standard output file can be referenced as . See the Library Reference for more information on this.) Often you’ll want more control over the formatting of your output than simply printing space-separated values. There are several ways to format output.\n• None To use formatted string literals, begin a string with or before the opening quotation mark or triple quotation mark. Inside this string, you can write a Python expression between and characters that can refer to variables or literal values.\n• None The method of strings requires more manual effort. You’ll still use and to mark where a variable will be substituted and can provide detailed formatting directives, but you’ll also need to provide the information to be formatted. In the following code block there are two examples of how to format variables: Notice how the are padded with spaces and a negative sign only for negative numbers. The example also prints multiplied by 100, with 2 decimal places and followed by a percent sign (see Format Specification Mini-Language for details).\n• None Finally, you can do all the string handling yourself by using string slicing and concatenation operations to create any layout you can imagine. The string type has some methods that perform useful operations for padding strings to a given column width. When you don’t need fancy output but just want a quick display of some variables for debugging purposes, you can convert any value to a string with the or functions. The function is meant to return representations of values which are fairly human-readable, while is meant to generate representations which can be read by the interpreter (or will force a if there is no equivalent syntax). For objects which don’t have a particular representation for human consumption, will return the same value as . Many values, such as numbers or structures like lists and dictionaries, have the same representation using either function. Strings, in particular, have two distinct representations. The value of x is 32.5, and y is 40000... # The repr() of a string adds string quotes and backslashes: # The argument to repr() may be any Python object: The module contains a class that offers yet another way to substitute values into strings, using placeholders like and replacing them with values from a dictionary, but offers much less control of the formatting. Formatted string literals (also called f-strings for short) let you include the value of Python expressions inside a string by prefixing the string with or and writing expressions as . An optional format specifier can follow the expression. This allows greater control over how the value is formatted. The following example rounds pi to three places after the decimal: 'The value of pi is approximately The value of pi is approximately 3.142. Passing an integer after the will cause that field to be a minimum number of characters wide. This is useful for making columns line up. Other modifiers can be used to convert the value before it is formatted. applies , applies , and applies : 'My hovercraft is full of My hovercraft is full of eels. 'My hovercraft is full of My hovercraft is full of 'eels'. The specifier can be used to expand an expression to the text of the expression, an equal sign, then the representation of the evaluated expression: See self-documenting expressions for more information on the specifier. For a reference on these format specifications, see the reference guide for the Format Specification Mini-Language. Basic usage of the method looks like this: We are the knights who say \"Ni!\" The brackets and characters within them (called format fields) are replaced with the objects passed into the method. A number in the brackets can be used to refer to the position of the object passed into the method. If keyword arguments are used in the method, their values are referred to by using the name of the argument. Positional and keyword arguments can be arbitrarily combined: The story of Bill, Manfred, and Georg. If you have a really long format string that you don’t want to split up, it would be nice if you could reference the variables to be formatted by name instead of by position. This can be done by simply passing the dict and using square brackets to access the keys. This could also be done by passing the dictionary as keyword arguments with the notation. This is particularly useful in combination with the built-in function , which returns a dictionary containing all local variables: __name__: __main__; __doc__: None; __package__: None; __loader__: ... As an example, the following lines produce a tidily aligned set of columns giving integers and their squares and cubes: For a complete overview of string formatting with , see Format String Syntax. Here’s the same table of squares and cubes, formatted manually: # Note use of 'end' on previous line The method of string objects right-justifies a string in a field of a given width by padding it with spaces on the left. There are similar methods and . These methods do not write anything, they just return a new string. If the input string is too long, they don’t truncate it, but return it unchanged; this will mess up your column lay-out but that’s usually better than the alternative, which would be lying about a value. (If you really want truncation you can always add a slice operation, as in .) There is another method, , which pads a numeric string on the left with zeros. It understands about plus and minus signs: The % operator (modulo) can also be used for string formatting. Given (where format is a string), conversion specifications in format are replaced with zero or more elements of values. This operation is commonly known as string interpolation. For example: 'The value of pi is approximately The value of pi is approximately 3.142. More information can be found in the printf-style String Formatting section.\n\nreturns a file object, and is most commonly used with two positional arguments and one keyword argument: The first argument is a string containing the filename. The second argument is another string containing a few characters describing the way in which the file will be used. mode can be when the file will only be read, for only writing (an existing file with the same name will be erased), and opens the file for appending; any data written to the file is automatically added to the end. opens the file for both reading and writing. The mode argument is optional; will be assumed if it’s omitted. Normally, files are opened in text mode, that means, you read and write strings from and to the file, which are encoded in a specific encoding. If encoding is not specified, the default is platform dependent (see ). Because UTF-8 is the modern de-facto standard, is recommended unless you know that you need to use a different encoding. Appending a to the mode opens the file in binary mode. Binary mode data is read and written as objects. You can not specify encoding when opening file in binary mode. In text mode, the default when reading is to convert platform-specific line endings ( on Unix, on Windows) to just . When writing in text mode, the default is to convert occurrences of back to platform-specific line endings. This behind-the-scenes modification to file data is fine for text files, but will corrupt binary data like that in or files. Be very careful to use binary mode when reading and writing such files. It is good practice to use the keyword when dealing with file objects. The advantage is that the file is properly closed after its suite finishes, even if an exception is raised at some point. Using is also much shorter than writing equivalent - blocks: # We can check that the file has been automatically closed. If you’re not using the keyword, then you should call to close the file and immediately free up any system resources used by it. Calling without using the keyword or calling might result in the arguments of not being completely written to the disk, even if the program exits successfully. After a file object is closed, either by a statement or by calling , attempts to use the file object will automatically fail. The rest of the examples in this section will assume that a file object called has already been created. To read a file’s contents, call , which reads some quantity of data and returns it as a string (in text mode) or bytes object (in binary mode). size is an optional numeric argument. When size is omitted or negative, the entire contents of the file will be read and returned; it’s your problem if the file is twice as large as your machine’s memory. Otherwise, at most size characters (in text mode) or size bytes (in binary mode) are read and returned. If the end of the file has been reached, will return an empty string ( ). 'This is the entire file.\n\n' reads a single line from the file; a newline character ( ) is left at the end of the string, and is only omitted on the last line of the file if the file doesn’t end in a newline. This makes the return value unambiguous; if returns an empty string, the end of the file has been reached, while a blank line is represented by , a string containing only a single newline. 'This is the first line of the file.\n\n' 'Second line of the file\n\n' For reading lines from a file, you can loop over the file object. This is memory efficient, fast, and leads to simple code: This is the first line of the file. If you want to read all the lines of a file in a list you can also use or . writes the contents of string to the file, returning the number of characters written. Other types of objects need to be converted – either to a string (in text mode) or a bytes object (in binary mode) – before writing them: returns an integer giving the file object’s current position in the file represented as number of bytes from the beginning of the file when in binary mode and an opaque number when in text mode. To change the file object’s position, use . The position is computed from adding offset to a reference point; the reference point is selected by the whence argument. A whence value of 0 measures from the beginning of the file, 1 uses the current file position, and 2 uses the end of the file as the reference point. whence can be omitted and defaults to 0, using the beginning of the file as the reference point. # Go to the 6th byte in the file # Go to the 3rd byte before the end In text files (those opened without a in the mode string), only seeks relative to the beginning of the file are allowed (the exception being seeking to the very file end with ) and the only valid offset values are those returned from the , or zero. Any other offset value produces undefined behaviour. File objects have some additional methods, such as and which are less frequently used; consult the Library Reference for a complete guide to file objects. Strings can easily be written to and read from a file. Numbers take a bit more effort, since the method only returns strings, which will have to be passed to a function like , which takes a string like and returns its numeric value 123. When you want to save more complex data types like nested lists and dictionaries, parsing and serializing by hand becomes complicated. Rather than having users constantly writing and debugging code to save complicated data types to files, Python allows you to use the popular data interchange format called JSON (JavaScript Object Notation). The standard module called can take Python data hierarchies, and convert them to string representations; this process is called serializing. Reconstructing the data from the string representation is called deserializing. Between serializing and deserializing, the string representing the object may have been stored in a file or data, or sent over a network connection to some distant machine. The JSON format is commonly used by modern applications to allow for data exchange. Many programmers are already familiar with it, which makes it a good choice for interoperability. If you have an object , you can view its JSON string representation with a simple line of code: Another variant of the function, called , simply serializes the object to a text file. So if is a text file object opened for writing, we can do this: To decode the object again, if is a binary file or text file object which has been opened for reading: JSON files must be encoded in UTF-8. Use when opening JSON file as a text file for both of reading and writing. This simple serialization technique can handle lists and dictionaries, but serializing arbitrary class instances in JSON requires a bit of extra effort. The reference for the module contains an explanation of this. Contrary to JSON, pickle is a protocol which allows the serialization of arbitrarily complex Python objects. As such, it is specific to Python and cannot be used to communicate with applications written in other languages. It is also insecure by default: deserializing pickle data coming from an untrusted source can execute arbitrary code, if the data was crafted by a skilled attacker."
    },
    {
        "link": "https://docs.python.org/3/library/string.html",
        "document": "A string containing all ASCII characters that are considered whitespace. This includes the characters space, tab, linefeed, return, formfeed, and vertical tab.\n\nBy design, string.printable.isprintable() returns False . In particular, string.printable is not printable in the POSIX sense (see LC_CTYPE ).\n\nString of ASCII characters which are considered printable by Python. This is a combination of digits , ascii_letters , punctuation , and whitespace .\n\nString of ASCII characters which are considered punctuation characters in the C locale: !\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~ .\n\nThe uppercase letters 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' . This value is not locale-dependent and will not change.\n\nThe lowercase letters 'abcdefghijklmnopqrstuvwxyz' . This value is not locale-dependent and will not change.\n\nThe concatenation of the ascii_lowercase and ascii_uppercase constants described below. This value is not locale-dependent.\n\nConverts the value (returned by get_field() ) given a conversion type (as in the tuple returned by the parse() method). The default version understands ‘s’ (str), ‘r’ (repr) and ‘a’ (ascii) conversion types.\n\nformat_field() simply calls the global format() built-in. The method is provided so that subclasses can override it.\n\nImplement checking for unused arguments if desired. The arguments to this function is the set of all argument keys that were actually referred to in the format string (integers for positional arguments, and strings for named arguments), and a reference to the args and kwargs that was passed to vformat. The set of unused args can be calculated from these parameters. check_unused_args() is assumed to raise an exception if the check fails.\n\nIf the index or keyword refers to an item that does not exist, then an IndexError or KeyError should be raised.\n\nSo for example, the field expression ‘0.name’ would cause get_value() to be called with a key argument of 0. The name attribute will be looked up after get_value() returns by calling the built-in getattr() function.\n\nFor compound field names, these functions are only called for the first component of the field name; subsequent components are handled through normal attribute and indexing operations.\n\nThe args parameter is set to the list of positional arguments to vformat() , and the kwargs parameter is set to the dictionary of keyword arguments.\n\nRetrieve a given field value. The key argument will be either an integer or a string. If it is an integer, it represents the index of the positional argument in args; if it is a string, then it represents a named argument in kwargs.\n\nGiven field_name as returned by parse() (see above), convert it to an object to be formatted. Returns a tuple (obj, used_key). The default version takes strings of the form defined in PEP 3101 , such as “0[name]” or “label.title”. args and kwargs are as passed in to vformat() . The return value used_key has the same meaning as the key parameter to get_value() .\n\nThe values in the tuple conceptually represent a span of literal text followed by a single replacement field. If there is no literal text (which can happen if two replacement fields occur consecutively), then literal_text will be a zero-length string. If there is no replacement field, then the values of field_name, format_spec and conversion will be None .\n\nLoop over the format_string and return an iterable of tuples (literal_text, field_name, format_spec, conversion). This is used by vformat() to break the string into either literal text, or replacement fields.\n\nIn addition, the Formatter defines a number of methods that are intended to be replaced by subclasses:\n\nThis function does the actual work of formatting. It is exposed as a separate function for cases where you want to pass in a predefined dictionary of arguments, rather than unpacking and repacking the dictionary as individual arguments using the *args and **kwargs syntax. vformat() does the work of breaking up the format string into character data and replacement fields. It calls the various methods described below.\n\nThe primary API method. It takes a format string and an arbitrary set of positional and keyword arguments. It is just a wrapper that calls vformat() .\n\nThe built-in string class provides the ability to do complex variable substitutions and value formatting via the format() method described in PEP 3101 . The Formatter class in the string module allows you to create and customize your own string formatting behaviors using the same implementation as the built-in format() method.\n\nThe method and the class share the same syntax for format strings (although in the case of , subclasses can define their own format string syntax). The syntax is related to that of formatted string literals, but it is less sophisticated and, in particular, does not support arbitrary expressions.\n\nFormat strings contain “replacement fields” surrounded by curly braces . Anything that is not contained in braces is considered literal text, which is copied unchanged to the output. If you need to include a brace character in the literal text, it can be escaped by doubling: and .\n\nThe grammar for a replacement field is as follows:\n\nIn less formal terms, the replacement field can start with a field_name that specifies the object whose value is to be formatted and inserted into the output instead of the replacement field. The field_name is optionally followed by a conversion field, which is preceded by an exclamation point , and a format_spec, which is preceded by a colon . These specify a non-default format for the replacement value.\n\nSee also the Format Specification Mini-Language section.\n\nThe field_name itself begins with an arg_name that is either a number or a keyword. If it’s a number, it refers to a positional argument, and if it’s a keyword, it refers to a named keyword argument. An arg_name is treated as a number if a call to on the string would return true. If the numerical arg_names in a format string are 0, 1, 2, … in sequence, they can all be omitted (not just some) and the numbers 0, 1, 2, … will be automatically inserted in that order. Because arg_name is not quote-delimited, it is not possible to specify arbitrary dictionary keys (e.g., the strings or ) within a format string. The arg_name can be followed by any number of index or attribute expressions. An expression of the form selects the named attribute using , while an expression of the form does an index lookup using .\n\nThe conversion field causes a type coercion before formatting. Normally, the job of formatting a value is done by the method of the value itself. However, in some cases it is desirable to force a type to be formatted as a string, overriding its own definition of formatting. By converting the value to a string before calling , the normal formatting logic is bypassed.\n\nThree conversion flags are currently supported: which calls on the value, which calls and which calls .\n\nThe format_spec field contains a specification of how the value should be presented, including such details as field width, alignment, padding, decimal precision and so on. Each value type can define its own “formatting mini-language” or interpretation of the format_spec.\n\nMost built-in types support a common formatting mini-language, which is described in the next section.\n\nA format_spec field can also include nested replacement fields within it. These nested replacement fields may contain a field name, conversion flag and format specification, but deeper nesting is not allowed. The replacement fields within the format_spec are substituted before the format_spec string is interpreted. This allows the formatting of a value to be dynamically specified.\n\nSee the Format examples section for some examples.\n\n“Format specifications” are used within replacement fields contained within a format string to define how individual values are presented (see Format String Syntax and f-strings). They can also be passed directly to the built-in function. Each formattable type may define how the format specification is to be interpreted. Most built-in types implement the following options for format specifications, although some of the formatting options are only supported by the numeric types. A general convention is that an empty format specification produces the same result as if you had called on the value. A non-empty format specification typically modifies the result. The general form of a standard format specifier is: If a valid align value is specified, it can be preceded by a fill character that can be any character and defaults to a space if omitted. It is not possible to use a literal curly brace (” ” or “ ”) as the fill character in a formatted string literal or when using the method. However, it is possible to insert a curly brace with a nested replacement field. This limitation doesn’t affect the function. The meaning of the various alignment options is as follows: Forces the field to be left-aligned within the available space (this is the default for most objects). Forces the field to be right-aligned within the available space (this is the default for numbers). Forces the padding to be placed after the sign (if any) but before the digits. This is used for printing fields in the form ‘+000000120’. This alignment option is only valid for numeric types, excluding . It becomes the default for numbers when ‘0’ immediately precedes the field width. Forces the field to be centered within the available space. Note that unless a minimum field width is defined, the field width will always be the same size as the data to fill it, so that the alignment option has no meaning in this case. The sign option is only valid for number types, and can be one of the following: indicates that a sign should be used for both positive as well as negative numbers. indicates that a sign should be used only for negative numbers (this is the default behavior). indicates that a leading space should be used on positive numbers, and a minus sign on negative numbers. The option coerces negative zero floating-point values to positive zero after rounding to the format precision. This option is only valid for floating-point presentation types. Changed in version 3.11: Added the option (see also PEP 682). The option causes the “alternate form” to be used for the conversion. The alternate form is defined differently for different types. This option is only valid for integer, float and complex types. For integers, when binary, octal, or hexadecimal output is used, this option adds the respective prefix , , , or to the output value. For float and complex the alternate form causes the result of the conversion to always contain a decimal-point character, even if no digits follow it. Normally, a decimal-point character appears in the result of these conversions only if a digit follows it. In addition, for and conversions, trailing zeros are not removed from the result. The option signals the use of a comma for a thousands separator for floating-point presentation types and for integer presentation type . For other presentation types, this option is an error. For a locale aware separator, use the integer presentation type instead. Changed in version 3.1: Added the option (see also PEP 378). The option signals the use of an underscore for a thousands separator for floating-point presentation types and for integer presentation type . For integer presentation types , , , and , underscores will be inserted every 4 digits. For other presentation types, specifying this option is an error. Changed in version 3.6: Added the option (see also PEP 515). width is a decimal integer defining the minimum total field width, including any prefixes, separators, and other formatting characters. If not specified, then the field width will be determined by the content. When no explicit alignment is given, preceding the width field by a zero ( ) character enables sign-aware zero-padding for numeric types, excluding . This is equivalent to a fill character of with an alignment type of . Changed in version 3.10: Preceding the width field by no longer affects the default alignment for strings. The precision is a decimal integer indicating how many digits should be displayed after the decimal point for presentation types and , or before and after the decimal point for presentation types or . For string presentation types the field indicates the maximum field size - in other words, how many characters will be used from the field content. The precision is not allowed for integer presentation types. Finally, the type determines how the data should be presented. The available string presentation types are: String format. This is the default type for strings and may be omitted. The available integer presentation types are: Character. Converts the integer to the corresponding unicode character before printing. Hex format. Outputs the number in base 16, using lower-case letters for the digits above 9. Hex format. Outputs the number in base 16, using upper-case letters for the digits above 9. In case is specified, the prefix will be upper-cased to as well. Number. This is the same as , except that it uses the current locale setting to insert the appropriate number separator characters. In addition to the above presentation types, integers can be formatted with the floating-point presentation types listed below (except and ). When doing so, is used to convert the integer to a floating-point number before formatting. The available presentation types for and values are: Scientific notation. For a given precision , formats the number in scientific notation with the letter ‘e’ separating the coefficient from the exponent. The coefficient has one digit before and digits after the decimal point, for a total of significant digits. With no precision given, uses a precision of digits after the decimal point for , and shows all coefficient digits for . If , the decimal point is omitted unless the option is used. Scientific notation. Same as except it uses an upper case ‘E’ as the separator character. Fixed-point notation. For a given precision , formats the number as a decimal number with exactly digits following the decimal point. With no precision given, uses a precision of digits after the decimal point for , and uses a precision large enough to show all coefficient digits for . If , the decimal point is omitted unless the option is used. Fixed-point notation. Same as , but converts to and to . General format. For a given precision , this rounds the number to significant digits and then formats the result in either fixed-point format or in scientific notation, depending on its magnitude. A precision of is treated as equivalent to a precision of . The precise rules are as follows: suppose that the result formatted with presentation type and precision would have exponent . Then, if , where is -4 for floats and -6 for , the number is formatted with presentation type and precision . Otherwise, the number is formatted with presentation type and precision . In both cases insignificant trailing zeros are removed from the significand, and the decimal point is also removed if there are no remaining digits following it, unless the option is used. With no precision given, uses a precision of significant digits for . For , the coefficient of the result is formed from the coefficient digits of the value; scientific notation is used for values smaller than in absolute value and values where the place value of the least significant digit is larger than 1, and fixed-point notation is used otherwise. Positive and negative infinity, positive and negative zero, and nans, are formatted as , , , and respectively, regardless of the precision. General format. Same as except switches to if the number gets too large. The representations of infinity and NaN are uppercased, too. Number. This is the same as , except that it uses the current locale setting to insert the appropriate number separator characters. Percentage. Multiplies the number by 100 and displays in fixed ( ) format, followed by a percent sign. For this is like the type, except that when fixed-point notation is used to format the result, it always includes at least one digit past the decimal point, and switches to the scientific notation when . When the precision is not specified, the latter will be as large as needed to represent the given value faithfully. For , this is the same as either or depending on the value of for the current decimal context. The overall effect is to match the output of as altered by the other format modifiers. The result should be correctly rounded to a given precision of digits after the decimal point. The rounding mode for matches that of the builtin. For , the rounding mode of the current context will be used. The available presentation types for are the same as those for ( is not allowed). Both the real and imaginary components of a complex number are formatted as floating-point numbers, according to the specified presentation type. They are separated by the mandatory sign of the imaginary part, the latter being terminated by a suffix. If the presentation type is missing, the result will match the output of (complex numbers with a non-zero real part are also surrounded by parentheses), possibly altered by other format modifiers.\n\nThis section contains examples of the syntax and comparison with the old -formatting. In most of the cases the syntax is similar to the old -formatting, with the addition of the and with used instead of . For example, can be translated to . The new format syntax also supports new and different options, shown in the following examples. is formed from the real part 'The complex number (3-5j) is formed from the real part 3.0 and the imaginary part -5.0.' Aligning the text and specifying a width: Replacing , , and and specifying a sign: # show only the minus -- same as '{:f}; {:f}' Replacing and and converting the value to different bases: # with 0x, 0o, or 0b as prefix: Using the comma as a thousands separator:"
    },
    {
        "link": "https://realpython.com/python-formatted-output",
        "document": "In modern Python, you have f-strings and the method to approach the tasks of interpolating and formatting strings. These tools help you embed variables and expressions directly into strings, control text alignment, and use custom format specifiers to modify how values appear. You can apply these techniques to create well-structured and readable Python code.\n\nBy the end of this tutorial, you’ll understand that:\n• String interpolation in Python involves embedding variables and expressions into strings.\n• You create an f-string in Python by prepending a string literal with an or and using curly braces to include variables or expressions.\n• You can use variables in Python’s method by placing them inside curly braces and passing them as arguments.\n• Format specifiers in Python control how values appear when formatted, using components like fill, align, sign, width, and type.\n• You align text in Python string formatting using the align component, which can justify text to the left, right, or center within a specified width.\n\nWhen working with strings in Python, you can leverage these formatting techniques to create dynamic and readable output. To get the most out of this tutorial, you should know the basics of Python programming and the string data type.\n\nPython has a string formatting tool called f-strings, which stands for formatted string literals. F-strings are string literals that you can create by prepending an or to the literal. They allow you to do string interpolation and formatting by inserting variables or expressions directly into the literal. Here you’ll take a look at how you can create an f-string by prepending the string literal with an or : Using either or has the same effect. However, it’s a more common practice to use a lowercase to create f-strings. Just like with regular string literals, you can use single, double, or triple quotes to define an f-string: Up to this point, your f-strings look pretty much the same as regular strings. However, if you create f-strings like those in the examples above, you’ll get complaints from your code linter if you have one. The remarkable feature of f-strings is that you can embed Python variables or expressions directly inside them. To insert the variable or expression, you must use a replacement field, which you create using a pair of curly braces. The variable that you insert in a replacement field is evaluated and converted to its string representation. The result is interpolated into the original string at the replacement field’s location: In this example, you’ve interpolated the variable into your string. Note that Python treats anything outside the curly braces as a regular string. Also, keep in mind that Python retrieves the value of when it runs the string literal, so if isn’t defined at that time, then you get a exception. Therefore, f-strings are appropriate for eager string interpolation. Note: You’ll typically find two different types of string interpolation:\n• Eager interpolation, where Python inserts the values into the string at execution time in the same place where you define the string.\n• Lazy interpolation, where Python delays the value insertion until the string is needed. In lazy interpolation, you typically create string templates at one point in your code and fill the template with values at another point. To do this type of interpolation, you can use the method, as you’ll see in a moment. Now that you’ve learned how to embed a variable into an f-string, you can look into embedding Python expressions into your f-string literals. You can embed almost any Python expression in an f-string, including arithmetic, Boolean, and conditional expressions. You can also include function calls, attribute access, common sequence operations like indexing and slicing, and more. Note: To learn more about using f-strings in Python, check out the Python’s F-String for String Interpolation and Formatting tutorial. Here’s an example that uses an arithmetic operation: The expressions that you embed in an f-string can be almost arbitrarily complex. The examples below show some of the possibilities. You can also do indexing and slicing on sequences and look up keys in dictionaries: \"First fruit in the list is ' \"First fruit in the list is 'apple'\" \"Last two fruits in the list are \"Last two fruits in the list are ['mango', 'grape']\" \"Dict value for key 'one' is \"Dict value for key 'one' is 1\" In this example, the first two embedded expressions run indexing and slicing operations in a list. The last expression runs a dictionary key lookup. Note: Before Python 3.12, f-strings had a few limitations that restricted the expressions that you could embed. These limitations were overcome with the arrival of Python 3.12. To explore the details, check out the Python 3.12 Preview: More Intuitive and Consistent F-Strings tutorial. To include curly braces in an f-string, you need to escape it by doubling it: In this example, the outer pair of curly braces tells Python to treat the inner braces as literal characters rather than part of the expression so they can appear in the resulting string.\n\nUsing the Method for String Interpolation In many ways, the Python string method is similar to the older string modulo operator, but goes well beyond it in terms of versatility. The general form of a call is shown below: You typically call the method on a string template, which is a string containing replacement fields. The and arguments allow you to specify the values to insert into the template. The resulting string is returned from the method. In the template string, replacement fields are enclosed in curly braces ( ). Anything outside of the curly braces is literal text that’s copied directly from the template to the output. To interpolate values into a string template using , you can use positional arguments in the method call. You can then use integer indices to determine which replacement field to insert each value into: In this example, is the string , which includes three replacement fields. The replacement fields , , and contain numbers that correspond to the zero-based positional arguments , , and . Each positional argument is inserted into the template according to its index. The following diagram shows the complete process: Using the String .format() Method With Positional Arguments and Indices The arguments to are inserted into the string template in the corresponding position. The first argument goes into the replacement field with index , the second argument goes into the replacement field with index , and so on. It’s important to note that the indices don’t have to follow a strict consecutive order or be unique in the template. This allows you to customize the position of each argument in the final string. When you specify a replacement field number that’s out of range, you’ll get an error. In the following example, the positional arguments are numbered , , and , but you specify in the template: : Replacement index 3 out of range for positional args tuple This call to raises an exception because index is out of range. You can also omit the indices in the replacement fields, in which case Python will assume a sequential order. This is referred to as automatic field numbering: In this example, you’ve removed the indices from your template. In this situation, Python inserts every argument into the replacement field following the same order you used in the call to . When you specify automatic field numbering, you must provide at least as many arguments as there are replacement fields. Here’s a toy example with four replacement fields and only three arguments: : Replacement index 3 out of range for positional args tuple In this example, you have four replacement fields in the template but only three arguments in the call to . So, you get an exception. Finally, it’s fine if the arguments outnumber the replacement fields. The excess arguments aren’t used: Here, Python ignores the argument and builds the final string using only and . Note that you can’t mix these two techniques: When you use Python to format strings with positional arguments, you must choose between either automatic or explicit replacement field numbering. You can also use keyword arguments instead of positional argument to produce the same result: In this case, the replacement fields are , , and . These fields specify keywords corresponding to the keyword arguments , , and . Each keyword value is inserted into the template in place of its corresponding replacement field by name. Keyword arguments are inserted into the template string in place of keyword replacement fields with the same name: In this example, the values of the keyword arguments , , and take the place of the replacement fields , , and , respectively. If you refer to a keyword argument that’s missing, then you’ll get an error: In this example, you specify the replacement field, but no corresponding keyword argument is named in the call to , so Python raises a exception. You can specify keyword arguments in any arbitrary order: In the first example, the replacement fields are in alphabetical order and the arguments aren’t. In the second example, it’s the other way around. You can specify positional and keyword arguments in one call. In this case, all of the positional arguments must appear before any of the keyword arguments: The requirement that all positional arguments appear before any keyword arguments doesn’t only apply to the method. This is generally true for any function or method call in Python. In all the examples so far, the values you passed to have been literal values, but you can specify variables as well: In this example, you pass the variables and as positional arguments and as a keyword argument.\n\nNow that you know the basics of how to interpolate values into your strings using f-strings or , you’re ready to learn about formatting. When you call Python’s method, the template string contains replacement fields. A replacement field consists of three components. Here’s the BNF notation for the replacement fields syntax: The three components are interpreted as shown in the table below: Specifies the source of the value to be formatted Indicates which standard Python function to use to perform the type conversion Specifies the format specifier to use when formatting the input value Each component is optional and may be omitted. The component can be a name or an index as you’ve already learned. F-strings also have replacement fields. Their syntax is similar: As shown here, f-strings have up to four components. The interpretation is mostly the same as with the method. However, in an f-string, the component can hold a variable or expression. The equal sign ( ) is optional and allows you to create self-documenting strings. Up to this point, you’ve coded examples that show how to use the component in f-strings and the component in . In the following sections, you’ll learn about the other two components, which work similarly in f-strings and . The component defines the function to use when converting the input value into a string. Python can do this conversion using built-in functions like the following: By default, both f-strings and the method use . However, in some situations, you may want to use . You can do this with the component of a replacement field. The possible values for are shown in the table below: To illustrate the difference between these two values, consider the following class: This class implements the special methods and , which internally support the built-in and functions. Now consider how this class works in the context of f-strings and the method: When you use the value for the component, you get the user-friendly string representation of the interpolated object. Similarly, when you use the value, you get the developer-friendly string representation. The component is the last portion of a replacement field. This component represents the guts of Python’s string formatting functionality. It contains information that exerts fine control over how to format the input values before inserting them into the template string. The BNF notation that describes the syntax of this component is shown below: The components of are listed in order in the following table: Specifies the character to use for padding values that don’t occupy the entire field width Specifies how to justify values that don’t occupy the entire field width Controls whether a leading sign is included for numeric values Selects an alternate output form for certain presentation types, such as integers Causes values to be padded on the left with zeros instead of ASCII space characters Specifies the minimum width of the output Specifies the number of digits after the decimal point for floating-point presentation types, and the maximum output width for string presentations types Specifies the presentation type, which is the type of conversion performed on the corresponding argument In the following section, you’ll learn how these components work in practice and how you can use them to format your strings either with f-string literals or with the method.\n\nIn practice, when you’re creating format specifiers to format the values that you interpolate into your strings, you can use different components according to your specific needs. In the following sections, you’ll learn about the format specifier components and how to use them. To kick things off, you’ll start with the component, which is the final portion of a . The component specifies the presentation type, which is the type of conversion that’s performed on the corresponding value to produce the output. The possible values for are described below: The first presentation type you have is , which designates binary integer conversion: In these examples, you use the conversion type to represent the decimal number as a binary number. The presentation type allows you to convert an input integer into its associated Unicode character: As shown above, you can convert a given integer value into its associated Unicode character with the presentation type. Note that you can use the built-in function to confirm the conversion. The conversion type chooses either floating-point or exponential output, depending on the magnitude of the exponent: The exact rules governing the choice might seem slightly complicated. Generally, you can trust that the choice will make sense. The conversion type is identical to except for when the output is exponential, in which case the will be displayed in uppercase: The result is the same as in the previous example, but this time with an uppercase . You’ll find a couple of other situations where you’ll see a difference between the and presentation types. For example, under some circumstances, a floating-point operation can result in a value that’s essentially infinite. The string representation of such a number in Python is . A floating-point operation may also produce a value that can’t be represented as a number. Python represents this value with the string , which stands for Not a Number. When you pass these values to an f-string or the method, the presentation type produces lowercase output, and produces uppercase output: You’ll see similar behavior with the and presentation types. For more information on floating-point representation, , and , check out the Wikipedia page on IEEE 754. To learn more about other representation types, take a look at the Converting Between Type Representations section of Python’s Format Mini-Language for Tidy Strings. The component specifies the minimum width of the output field: Note that this is a minimum field width. Suppose you specify a value that’s longer than the minimum: In this example, is effectively ignored and the final string displays the input value as is. The and components allow you to control how the formatted output is padded and positioned within the specified field width. These components only make a difference when the input value doesn’t occupy the entire field width, which can only happen if a minimum field width is specified. If isn’t specified, then and are effectively ignored. Here are the possible values for the subcomponent: Aligns the value to the left Aligns the value to the right A format specifier that uses the less than sign ( ) indicates that the output will be left-justified: Aligning the value to the left is the default behavior with strings like . A format specifier that uses the greater than sign ( ) indicates that the output will be right-justified: Aligning to the right is the default behavior for numeric values like . A format specifier that uses a caret ( ) indicates that the output will be centered in the output field: With the caret character, you can center the input value in the output field. Finally, you can specify a value for the component using the equal sign ( ) . This sign only has meaning for numeric values with signs included. When numeric output includes a sign, it’s normally placed directly to the left of the first digit in the number: In these examples, you’ve used the component, which you’ll learn about in detail in the next section. If you set to the equal sign ( ), then the sign appears at the left of the output field: As you can see, the sign now appears on the left and the padding is added in between the sign and the number. The component allows you to replace the extra space when the input value doesn’t completely fill the output width. It can be any character except for curly braces ( ). Some examples of using are shown below: Keep in mind that if you specify a value for , then you should also include a value for . You can control whether a sign appears in numeric output with the component of your format specifiers. In the following example, the plus sign ( ) indicates that the value should always display a leading sign: In these examples, you use the plus sign to always include a leading sign for both positive and negative values. If you use the minus sign ( ), then only negative numeric values will include a leading sign: The sign lets you display the sign when the input value is negative. If the input value is positive, then no sign is displayed. Finally, you can also use a space ( ) for the component. A space means that a sign is included for negative values and a space character for positive values. To make this behavior evident in the example below, you use an asterisk as the fill character: As you can see in these examples, positive values include a space rather than a plus sign. On the other hand, negative values include the actual minus sign. When you include a hash character ( ) in the component, Python will select an alternate output form for certain presentation types. For binary ( ), octal ( ), and hexadecimal ( ) presentation types, the hash character causes the inclusion of an explicit base indicator to the left of the value: The base indicators are , , and for binary, octal, and hexadecimal representations, respectively. For floating-point ( or ) and exponential ( or ) presentation types, the hash character forces the output to contain a decimal point, even if the input consists of a whole number: For any presentation type other than those covered above, the hash character ( ) has no effect. If the output is smaller than the indicated field width and you start the component with a zero ( ), then the input value will be padded on the left with zeros instead of space characters: You’ll typically use the component for numeric values, as shown above. However, it works for string values as well: If you specify both and , then overrides the component: The and components essentially control the same thing, so there isn’t any need to specify both at the same time. In practice, is superfluous and was probably included as a convenience for developers who are familiar with the string modulo operator’s similar conversion flag. The component allows you to include a grouping separator character in numeric outputs. For decimal and floating-point presentation types, may be either a comma ( ) or an underscore ( ). That character then separates each group of three digits in the output: In these examples, you’ve used a comma and an underscore as thousand separators for integer and floating-point values. Setting the component to an underscore ( ) may also be useful with the binary, octal, and hexadecimal presentation types. In those cases, each group of four digits is separated by an underscore character in the output: If you try to specify with any presentation type other than those listed above, then your code will raise an exception. The component specifies the number of digits after the decimal point for floating-point presentation types: In these examples, you use different precision values to display the output number. The is separated from the by a literal dot ( ). For string representation types, specifies the maximum width of the output: If the input value is longer than the specified value, then the output will be truncated."
    },
    {
        "link": "https://geeksforgeeks.org/python-string-format-method",
        "document": "The method is a powerful tool that allows developers to create formatted strings by embedding variables and values into placeholders within a template string. This method offers a flexible and versatile way to construct textual output for a wide range of applications. Python string format() function has been introduced for handling complex string formatting more efficiently. Sometimes we want to make generalized print statements in that case instead of writing print statements every time we use the concept of formatting.\n\nThis method of the built-in string class provides functionality for complex variable substitutions and value formatting. This new formatting technique is regarded as more elegant. The general syntax of format() method is string.format(var1, var2,…). Here we will try to understand how to Format A String That Contains Curly Braces In Python.\n\nIn this example, we will use the string bracket notation program to demonstrate the str. format() method. Formatters work by putting in one or more replacement fields and placeholders defined by a pair of curly braces { } into a string and calling the str.format().\n\nMultiple pairs of curly braces can be used while formatting the string in Python. Let’s say another variable substitution is needed in the sentence, which can be done by adding a second pair of curly braces and passing a second value into the method. Python will replace the placeholders with values in order.\n\nPython program demonstrating Index error number of placeholders is four but there are only three values passed.\n\nYou can use two or more specially designated characters within a string to format a string or perform a command. These characters are called escape sequences. An Escape sequence in Python starts with a backslash (\\). For example, \n\n is an escape sequence in which the common meaning of the letter n is literally escaped and given an alternative meaning – a new line.\n\nWhen placeholders { } are empty, Python will replace the values passed through str.format() in order. The values that exist within the str.format() method are essentially tuple data types and each individual value contained in the tuple can be called by its index number, which starts with the index number 0. These index numbers can be passed into the curly braces that serve as the placeholders in the original string.\n\nExample: To demonstrate the use of formatters with positional key arguments.\n\nMore parameters can be included within the curly braces of our syntax. Use the format code syntax {field_name: conversion}, where field_name specifies the index number of the argument to the str.format() method, and conversion refers to the conversion code of the data type.\n\nUsing %c prior to formatting\n\nAnother useful Type Specifying\n\nYou can also specify formatting symbols. The only change is using a colon (:) instead of %.\n\nFor example, instead of %s use {:s} and instead of %d use (:d}\n\nDemonstration of spacing when strings are passed as parameters\n\nBy default, strings are left-justified within the field, and numbers are right-justified. We can modify this by placing an alignment code just following the colon.\n\nFormatters are generally used to Organize Data. Formatters can be seen in their best light when they are being used to organize a lot of data in a visual way. If we are showing databases to users, using formatters to increase field size and modify alignment can make the output more readable.\n\nExample: To demonstrate the organization of large data using format()\n\nUsing a dictionary to unpack values into the placeholders in the string that needs to be formatted. We basically use ** to unpack the values. This method can be useful in string substitution while preparing an SQL query.\n\nGiven a list of float values, the task is to truncate all float values to 2 decimal digits. Let’s see the different methods to do the task.\n\nWhat is the\n\nWhat is the Use of Format Operator in Python?"
    },
    {
        "link": "https://stackoverflow.com/questions/28204936/python-format-best-practices",
        "document": "I'm just coming up to speed with Python and had a question about best practices (or at least common practices) around using .format on a string.\n\nMy question is mostly around when you would use blank curly brackets vs. an index number vs. a name.\n\nFor example if you had a single variable that you wanted to include in a string which one would you do?\n\nDoes this change if you have multiple variables you want to include? Maybe it's OK to include {} for a single var, but never for multiple vars?\n\nAny thoughts or insights here would be greatly appreciated."
    },
    {
        "link": "https://digitalocean.com/community/tutorials/how-to-use-string-formatters-in-python-3",
        "document": "Python’s method of the string class allows you to do variable substitutions and value formatting. This lets you concatenate elements together within a string through positional formatting.\n\nThis tutorial will guide you through some of the common uses of formatters in Python, which can help make your code and program more readable and user friendly.\n\nYou should have Python 3 installed and a programming environment set up on your computer or server. If you don’t have a programming environment set up, you can refer to the installation and setup guides for a local programming environment or for a programming environment on your server appropriate for your operating system (Ubuntu, CentOS, Debian, etc.)\n\nFormatters work by putting in one or more replacement fields or placeholders — defined by a pair of curly braces — into a string and calling the method. You’ll pass into the method the value you want to concatenate with the string. This value will be passed through in the same place that your placeholder is positioned when you run the program.\n\nLet’s print out a string that uses a formatter:\n\nIn the example above, we constructed a string with a pair of curly braces as a placeholder:\n\nWe then added the method and passed the value of the integer to that method. This places the value of into the string where the curly braces were:\n\nWe can also assign a variable to be equal to the value of a string that has formatter placeholders:\n\nIn this second example, we concatenated the string with the larger string, replacing the curly braces in the original string.\n\nFormatters in Python allow you to use curly braces as placeholders for values that you’ll pass through with the method.\n\nYou can use multiple pairs of curly braces when using formatters. If we’d like to add another variable substitution to the sentence above, we can do so by adding a second pair of curly braces and passing a second value into the method:\n\nTo add another substitution, we added a second pair of curly braces into the original string. Then, we passed two strings into the method, separating them by a comma.\n\nFollowing the same syntax, we can add additional substitutions:\n\nIn we added 4 pairs of curly braces as placeholders for variable substitution. We then passed 4 values into the method, mixing string and integer data types. Each of these values are separated by a comma.\n\nWhen we leave curly braces empty without any parameters, Python will replace the values passed through the method in order. As we have seen, so far, a formatter construction with two empty curly braces with two values passed through will look like this:\n\nThe first pair of curly braces is substituted with the string value of , and the second pair is substituted with the string value of .\n\nThe values that exist within the method look like this:\n\nThey are essentially the tuple data type and each individual value contained in the tuple can be called by its index number, which starts with the index number 0.\n\nWe can pass these index numbers into the curly braces that serve as the placeholders in the original string:\n\nIn the above example, the output will be what we get without passing index numbers into the braces as we are calling the values in the tuple in order:\n\nBut, if we reverse the index numbers with the parameters of the placeholders we can reverse the values being passed into the string:\n\nIf you call an index number of 2 in a tuple that has values at index positions 0 and 1, then you are calling on a value that is out of range. When you call an index number that is out of range, you’ll receive an error message:\n\nThe error message we see refers to the tuple only having values at index numbers 0 and 1, therefore placing index number 2 out of range.\n\nLet’s add a few more placeholders and a few more values to pass to them, so we can understand how we can reorder formatters a little better. First, here is a new string with four placeholders:\n\nWithout parameters, the values that are passed into the method are concatenated into the string in order.\n\nThe string values contained in the tuple correspond to the following index numbers:\n\nLet’s use the index numbers of the values to change the order that they appear in the string:\n\nSince we started with index number 3, we called the last value of first. The other index numbers included as parameters change the order of how the words appear within the original string.\n\nIn addition to positional arguments, we can also introduce keyword arguments that are called by their keyword name:\n\nThis example shows the use of a keyword argument being used with positional arguments. We can fill in the keyword argument alongside positional arguments, and can move these arguments around to change the resulting string:\n\nPositional and keyword arguments used with string formatters give us more control over manipulating our original strings through reordering.\n\nWe can include more parameters within the curly braces of our syntax. We’ll use the format code syntax , where specifies the index number of the argument to the method that we went through in the reordering section, and refers to the conversion code of the data type that you’re using with the formatter.\n\nThe conversion type refers to the the single-character type code that Python uses. The codes that we’ll be using here are for string, to display decimal integers (10-base), and which we’ll use to display floats with decimal places. You can read more about the Format-Specification Mini-Language through Python 3’s official documentation.\n\nLet’s look at an example where we have an integer passed through the method, but want to display it as a float by adding the conversion type argument:\n\nWe used the syntax of for the first curly brace replacement field to output a float. The second curly braces only uses the first parameter .\n\nIn the example above, there are a lot of numbers displaying after the decimal point, but you can limit those. When you are specifying for float values, you can additionally specify the precision of that value by including a full stop followed by the number of digits after the decimal you would like to include.\n\nIf Sammy ate 75.765367% of the pizza, but we don’t need to have a high level of accuracy, we can limit the places after the decimal to 3 by adding before the conversion type :\n\nIf we only want one decimal place, we can rewrite the string and method like so:\n\nNote that modifying precision will cause the number to be rounded.\n\nAlthough we display a number with no decimal places as a float, if we try to change the float to an integer by using the conversion type, we will receive an error:\n\nIf you would like no decimal places to be shown, you can write your formatter like so:\n\nThis will not convert your float to an integer, but instead limit the number of places shown after the decimal point.\n\nBecause the placeholders are replacement fields, you can pad or create space around an element by increasing field size through additional parameters. This can be useful when we need to organize a lot of data visually.\n\nWe can add a number to indicate field size (in terms of characters) after the colon in the curly braces of our syntax:\n\nIn the example above, we gave the number a character field size of 4, and the string a character field size of 16 (because it is a long string).\n\nAs we see, by default strings are left-justified within the field, and numbers are right-justified. You can modify this by placing an alignment code following the colon. will left-align the text in a field, will center the text in the field, and will right-align it.\n\nLet’s left-align the number and center the string:\n\nNow we see that is left-aligned, providing space in the field before , and is centered in its field with space to the left and right of it.\n\nBy default, when we make a field larger with formatters, Python will fill the field with whitespace characters. We can modify that to be a different character by specifying the character we want it to be directly following the colon:\n\nWe are accepting the string being passed to in the index position of 0 since we did not specify otherwise, including the colon, and specifying that we will use instead of space to fill up the field. We’re centering the string with , specifying that the field is 20 characters in size, and also indicating that we are working with a string conversion type by including .\n\nWe can combine these parameters with other parameters we’ve used before:\n\nIn the parameters within the curly braces, we specified the index field number of the float and included the colon, indicated the size of the field number and included the full stop, wrote in the number of places after the decimal place, and then specified the conversion type of .\n\nSo far, we have passed integers, floats, and strings into the method, but we can also pass variables through the method. This works like any other variable.\n\nWe can use variables for both the original string and what is passed into the method :\n\nVariables can be easily substituted for each part of our formatter syntax construction. This makes it easier to work with when we are taking in user-generated input and assigning those values to variables.\n\nFormatters can be seen in their best light when they are being used to organize a lot of data in a visual way. If we are showing databases to users, using formatters to increase field size and modify alignment can make your output more readable.\n\nLet’s look at a typical for loop in Python that will print out , , and in the range from 3 to 12:\n\nWhile the output is organized in a way, the numbers overflow into each other’s columns, making the bottom of the output less readable. If you are working with a bigger data set with many small and big numbers, this can pose a problem.\n\nLet’s use formatters to give more space to these numbers:\n\nHere, in our curly braces, we didn’t add the field name for index number and started with the colon, followed by the number for the field size, and a conversion type since we’re working with integers. In this example, we accommodated for the size of each expected output, giving 2 extra character spaces for each, depending on the maximum possible number size, so our output looks like this:\n\nWe can specify a consistent field size number in order to have even columns, making sure that we accommodate the larger numbers:\n\nWe can also manipulate the alignment of the columns by adding , , and for text alignment, change to to add decimal places, change field name index numbers, and more to ensure that we are displaying the data as we would like.\n\nUsing formatters for variable substitution can be an effective way to concatenate strings and organize values and data. Formatters represent a basic but non-descriptive way for passing variable substitutions into a string, and are useful for making sure output is readable and user friendly."
    },
    {
        "link": "https://docs.python.org/3/tutorial/inputoutput.html",
        "document": "There are several ways to present the output of a program; data can be printed in a human-readable form, or written to a file for future use. This chapter will discuss some of the possibilities.\n\nSo far we’ve encountered two ways of writing values: expression statements and the function. (A third way is using the method of file objects; the standard output file can be referenced as . See the Library Reference for more information on this.) Often you’ll want more control over the formatting of your output than simply printing space-separated values. There are several ways to format output.\n• None To use formatted string literals, begin a string with or before the opening quotation mark or triple quotation mark. Inside this string, you can write a Python expression between and characters that can refer to variables or literal values.\n• None The method of strings requires more manual effort. You’ll still use and to mark where a variable will be substituted and can provide detailed formatting directives, but you’ll also need to provide the information to be formatted. In the following code block there are two examples of how to format variables: Notice how the are padded with spaces and a negative sign only for negative numbers. The example also prints multiplied by 100, with 2 decimal places and followed by a percent sign (see Format Specification Mini-Language for details).\n• None Finally, you can do all the string handling yourself by using string slicing and concatenation operations to create any layout you can imagine. The string type has some methods that perform useful operations for padding strings to a given column width. When you don’t need fancy output but just want a quick display of some variables for debugging purposes, you can convert any value to a string with the or functions. The function is meant to return representations of values which are fairly human-readable, while is meant to generate representations which can be read by the interpreter (or will force a if there is no equivalent syntax). For objects which don’t have a particular representation for human consumption, will return the same value as . Many values, such as numbers or structures like lists and dictionaries, have the same representation using either function. Strings, in particular, have two distinct representations. The value of x is 32.5, and y is 40000... # The repr() of a string adds string quotes and backslashes: # The argument to repr() may be any Python object: The module contains a class that offers yet another way to substitute values into strings, using placeholders like and replacing them with values from a dictionary, but offers much less control of the formatting. Formatted string literals (also called f-strings for short) let you include the value of Python expressions inside a string by prefixing the string with or and writing expressions as . An optional format specifier can follow the expression. This allows greater control over how the value is formatted. The following example rounds pi to three places after the decimal: 'The value of pi is approximately The value of pi is approximately 3.142. Passing an integer after the will cause that field to be a minimum number of characters wide. This is useful for making columns line up. Other modifiers can be used to convert the value before it is formatted. applies , applies , and applies : 'My hovercraft is full of My hovercraft is full of eels. 'My hovercraft is full of My hovercraft is full of 'eels'. The specifier can be used to expand an expression to the text of the expression, an equal sign, then the representation of the evaluated expression: See self-documenting expressions for more information on the specifier. For a reference on these format specifications, see the reference guide for the Format Specification Mini-Language. Basic usage of the method looks like this: We are the knights who say \"Ni!\" The brackets and characters within them (called format fields) are replaced with the objects passed into the method. A number in the brackets can be used to refer to the position of the object passed into the method. If keyword arguments are used in the method, their values are referred to by using the name of the argument. Positional and keyword arguments can be arbitrarily combined: The story of Bill, Manfred, and Georg. If you have a really long format string that you don’t want to split up, it would be nice if you could reference the variables to be formatted by name instead of by position. This can be done by simply passing the dict and using square brackets to access the keys. This could also be done by passing the dictionary as keyword arguments with the notation. This is particularly useful in combination with the built-in function , which returns a dictionary containing all local variables: __name__: __main__; __doc__: None; __package__: None; __loader__: ... As an example, the following lines produce a tidily aligned set of columns giving integers and their squares and cubes: For a complete overview of string formatting with , see Format String Syntax. Here’s the same table of squares and cubes, formatted manually: # Note use of 'end' on previous line The method of string objects right-justifies a string in a field of a given width by padding it with spaces on the left. There are similar methods and . These methods do not write anything, they just return a new string. If the input string is too long, they don’t truncate it, but return it unchanged; this will mess up your column lay-out but that’s usually better than the alternative, which would be lying about a value. (If you really want truncation you can always add a slice operation, as in .) There is another method, , which pads a numeric string on the left with zeros. It understands about plus and minus signs: The % operator (modulo) can also be used for string formatting. Given (where format is a string), conversion specifications in format are replaced with zero or more elements of values. This operation is commonly known as string interpolation. For example: 'The value of pi is approximately The value of pi is approximately 3.142. More information can be found in the printf-style String Formatting section.\n\nreturns a file object, and is most commonly used with two positional arguments and one keyword argument: The first argument is a string containing the filename. The second argument is another string containing a few characters describing the way in which the file will be used. mode can be when the file will only be read, for only writing (an existing file with the same name will be erased), and opens the file for appending; any data written to the file is automatically added to the end. opens the file for both reading and writing. The mode argument is optional; will be assumed if it’s omitted. Normally, files are opened in text mode, that means, you read and write strings from and to the file, which are encoded in a specific encoding. If encoding is not specified, the default is platform dependent (see ). Because UTF-8 is the modern de-facto standard, is recommended unless you know that you need to use a different encoding. Appending a to the mode opens the file in binary mode. Binary mode data is read and written as objects. You can not specify encoding when opening file in binary mode. In text mode, the default when reading is to convert platform-specific line endings ( on Unix, on Windows) to just . When writing in text mode, the default is to convert occurrences of back to platform-specific line endings. This behind-the-scenes modification to file data is fine for text files, but will corrupt binary data like that in or files. Be very careful to use binary mode when reading and writing such files. It is good practice to use the keyword when dealing with file objects. The advantage is that the file is properly closed after its suite finishes, even if an exception is raised at some point. Using is also much shorter than writing equivalent - blocks: # We can check that the file has been automatically closed. If you’re not using the keyword, then you should call to close the file and immediately free up any system resources used by it. Calling without using the keyword or calling might result in the arguments of not being completely written to the disk, even if the program exits successfully. After a file object is closed, either by a statement or by calling , attempts to use the file object will automatically fail. The rest of the examples in this section will assume that a file object called has already been created. To read a file’s contents, call , which reads some quantity of data and returns it as a string (in text mode) or bytes object (in binary mode). size is an optional numeric argument. When size is omitted or negative, the entire contents of the file will be read and returned; it’s your problem if the file is twice as large as your machine’s memory. Otherwise, at most size characters (in text mode) or size bytes (in binary mode) are read and returned. If the end of the file has been reached, will return an empty string ( ). 'This is the entire file.\n\n' reads a single line from the file; a newline character ( ) is left at the end of the string, and is only omitted on the last line of the file if the file doesn’t end in a newline. This makes the return value unambiguous; if returns an empty string, the end of the file has been reached, while a blank line is represented by , a string containing only a single newline. 'This is the first line of the file.\n\n' 'Second line of the file\n\n' For reading lines from a file, you can loop over the file object. This is memory efficient, fast, and leads to simple code: This is the first line of the file. If you want to read all the lines of a file in a list you can also use or . writes the contents of string to the file, returning the number of characters written. Other types of objects need to be converted – either to a string (in text mode) or a bytes object (in binary mode) – before writing them: returns an integer giving the file object’s current position in the file represented as number of bytes from the beginning of the file when in binary mode and an opaque number when in text mode. To change the file object’s position, use . The position is computed from adding offset to a reference point; the reference point is selected by the whence argument. A whence value of 0 measures from the beginning of the file, 1 uses the current file position, and 2 uses the end of the file as the reference point. whence can be omitted and defaults to 0, using the beginning of the file as the reference point. # Go to the 6th byte in the file # Go to the 3rd byte before the end In text files (those opened without a in the mode string), only seeks relative to the beginning of the file are allowed (the exception being seeking to the very file end with ) and the only valid offset values are those returned from the , or zero. Any other offset value produces undefined behaviour. File objects have some additional methods, such as and which are less frequently used; consult the Library Reference for a complete guide to file objects. Strings can easily be written to and read from a file. Numbers take a bit more effort, since the method only returns strings, which will have to be passed to a function like , which takes a string like and returns its numeric value 123. When you want to save more complex data types like nested lists and dictionaries, parsing and serializing by hand becomes complicated. Rather than having users constantly writing and debugging code to save complicated data types to files, Python allows you to use the popular data interchange format called JSON (JavaScript Object Notation). The standard module called can take Python data hierarchies, and convert them to string representations; this process is called serializing. Reconstructing the data from the string representation is called deserializing. Between serializing and deserializing, the string representing the object may have been stored in a file or data, or sent over a network connection to some distant machine. The JSON format is commonly used by modern applications to allow for data exchange. Many programmers are already familiar with it, which makes it a good choice for interoperability. If you have an object , you can view its JSON string representation with a simple line of code: Another variant of the function, called , simply serializes the object to a text file. So if is a text file object opened for writing, we can do this: To decode the object again, if is a binary file or text file object which has been opened for reading: JSON files must be encoded in UTF-8. Use when opening JSON file as a text file for both of reading and writing. This simple serialization technique can handle lists and dictionaries, but serializing arbitrary class instances in JSON requires a bit of extra effort. The reference for the module contains an explanation of this. Contrary to JSON, pickle is a protocol which allows the serialization of arbitrarily complex Python objects. As such, it is specific to Python and cannot be used to communicate with applications written in other languages. It is also insecure by default: deserializing pickle data coming from an untrusted source can execute arbitrary code, if the data was crafted by a skilled attacker."
    },
    {
        "link": "https://realpython.com/python-string-formatting",
        "document": "String formatting is essential in Python for creating dynamic and well-structured text by inserting values into strings. This tutorial covers various methods, including f-strings, the method, and the modulo operator ( ). Each method has unique features and benefits for different use cases. The string formatting mini-language provides additional control over the output format, allowing for aligned text, numeric formatting, and more.\n\nBy the end of this tutorial, you’ll understand that:\n• String formatting in Python involves inserting and formatting values within strings using interpolation.\n• Python supports different types of string formatting, including f-strings, the method, and the modulo operator ( ).\n• F-strings are generally the most readable and efficient option for eager interpolation in Python.\n• While f-strings are more readable and efficient compared to and the operator, the method supports lazy evaluation.\n\nTo get the most out of this tutorial, you should be familiar with Python’s string data type and the available string interpolation tools. Having a basic knowledge of the string formatting mini-language is also a plus.\n\nString interpolation involves generating strings by inserting other strings or objects into specific places in a base string or template. For example, here’s how you can do some string interpolation using an f-string: In this quick example, you first have a Python variable containing a string object, . Then, you create a new string using an f-string. In this string, you insert the content of your variable using a replacement field. When you run this last line of code, Python builds a final string, . The insertion of into the f-string is an interpolation. Note: To dive deeper into string interpolation, check out the String Interpolation in Python: Exploring Available Tools tutorial. When you do string interpolation, you may need to format the interpolated values to produce a well-formatted final string. To do this, you can use different string interpolation tools that support string formatting. In Python, you have these three tools: The first two tools support the string formatting mini-language, a feature that allows you to fine-tune your strings. The third tool is a bit old and has fewer formatting options. However, you can use it to do some minimal formatting. Note: The built-in function is yet another tool that supports the format specification mini-language. This function is typically used for date and number formatting, but you won’t cover it in this tutorial. In the following sections, you’ll start by learning a bit about the string formatting mini-language. Then, you’ll dive into using this language, f-strings, and the method to format your strings. Finally, you’ll learn about the formatting capabilities of the modulo operator.\n\nPython 3.6 added a string interpolation and formatting tool called formatted string literals, or f-strings for short. As you’ve already learned, f-strings let you embed Python objects and expressions inside your strings. To create an f-string, you must prefix the string with an or and insert replacement fields in the string literal. Each replacement field must contain a variable, object, or expression: In the first example, you define an f-string that embeds the number directly into the resulting string. In the second example, you insert two variables and an expression into the string. Formatted string literals are a Python parser feature that converts f-strings into a series of string constants and expressions. These are then joined up to build the final string. Using the Formatting Mini-Language With F-Strings When you use f-strings to create strings through interpolation, you need to use replacement fields. In f-strings, you can define a replacement field using curly brackets ( ) as in the examples below: Inside the brackets, you can insert Python objects and expressions. In this example, you’d like the resulting string to display the currency values using a proper format. However, you get a string that shows the currency values with at most one digit on its decimal part. To format the values and always display two digits on its decimal part, you can use a format specifier: In this example, note that each replacement field contains a string that starts with a colon. That’s a format specifier. The part tells Python that you want to format the value as a floating-point number ( ) with two decimal places ( ). Note: To learn more about the formatting mini-language and its syntax, check out the Python’s Format Mini-Language for Tidy Strings tutorial. If you’re interested in formatting floating-point numbers specifically, then you can also read How to Format Floats Within F-Strings in Python. The string formatting mini-language is a powerful tool with several cool features, including the following: In the following sections, you’ll explore how to use f-strings, the method, and the string formatting mini-language to format the values that you insert into your strings through interpolation. You can use f-strings and the string formatting mini-language to format the values that you interpolate into your strings in multiple ways. To illustrate, say that you want to write a Python function to build a grades report for your students. The student data is in a dictionary that looks like the following: \"Needs to participate more.\" The dictionary has the key to store the student’s name. Then, it has the key to hold a list of dictionaries containing the student’s performance in each subject. Your function may look like the following: Thank you for reviewing the progress report. In this function, you’re doing several things. Here’s a line-by-line breakdown:\n• Line 5 computes the average of the grades.\n• Line 6 defines the average grade subreport. In this part of the report, you use the format specifier to express the average grade as a floating-point number with two decimal places.\n• Line 8 defines the first line of the subject subreport.\n• Line 10 adds more information to the subject subreport.\n• Line 11 formats the subject’s name. To do this, you use the format specifier, which tells Python to align the name to the left within characters.\n• Line 12 formats the grade. In this case, the format specifier tells Python to display the grade using up to three characters. A leading space is used if the grade doesn’t have three digits.\n• Lines 16 to 21 build the final report and return it to the caller. Now that you’ve gone through the complete code, it’s time to try out your function. Go ahead and run the following code: History Grade: 78 Comment: Needs to participate more. Thank you for reviewing the progress report. Your report looks pretty nice! It provides general information about the student at the top and grade details for every subject.\n\nYou can also use the method to format values during string interpolation. In most cases, you’d use the method for lazy interpolation. In this type of interpolation, you define a template string in some part of your code and then interpolate values in another part: In both examples, you create a string template and then use the method to interpolate the required values. Using the Formatting Mini-Language With The method also supports the string formatting mini-language. This feature allows you to nicely format the interpolated values when you create strings through interpolation. To illustrate, consider the example you wrote in the section about using the formatting mini-language with f-strings. Here’s how to do it with the method: Again, the resulting string displays the currency values using a proper format that shows two decimal places. Now it’s time for a couple of practical examples of using the method and the string formatting mini-language to format your strings. For the first example, say that you need to create a sales report for your company. You’d like to create a report template and fill it with the appropriate data when someone requires it. In this situation, you can create the following report template: In this report template, you have a few format specifiers. Here’s a summary of their specific meanings:\n• displays the interpolated value aligned to the right within a space of characters. The dot after the colon works as the fill character. The other format specifiers, and , have a similar effect. Note that the field widths were chosen by trial and error to make the report line up nicely.\n• displays the preceding number using a comma as the thousands separator.\n• shows a value as a floating-point number using two decimal places and a comma as the thousands separator. Now, you can code a function to generate the actual report: This function takes the sales data and the report template as arguments. Then, it computes the required values and calls on the template. Go ahead and give this function a try by running the following code: Cool! You have a nicely formatted sales report. You can experiment on your own and tweak the format specifiers further as an exercise. For example, you can improve the date format. However, note that dates have their own formatting, which you can learn about in the Formatting Dates section of the tutorial about Python’s string formatting mini-language. You can also take advantage of the method when your data is stored in dictionaries. For example, here’s how you can update the function using the method: Thank you for reviewing the progress report. In the first lines of code, you create string templates to display the information about each subject and also the final report. In , you create a dictionary with the required data to build the student report. Next, you interpolate the data into the report template using with the dictionary as an argument. Note that to fill the string templates, you use the operator to unpack the data from the input dictionary.\n\nStrings in Python have a built-in operation that you can access with the modulo operator ( ). This operator lets you do positional and named string interpolation. If you’ve ever worked with the function in C, then the syntax will be familiar. Here’s a toy example: The substring is a conversion specifier that works as a replacement field. It tells Python where to substitute the value of , represented as a string. To build a conversion specifier, you need two or more characters. Here’s a quick summary of the accepted characters and their corresponding order in the specifier:\n• The character marks the start of the specifier.\n• An optional mapping key in parentheses allows you to use named replacement fields like .\n• An optional conversion flag affects how some conversion types display.\n• An optional minimum field width allows you to define the number of characters to display.\n• An optional precision consists of a dot character ( ) followed by the desired precision.\n• An optional length modifier is an or for long and short integers.\n• A conversion type specifies how the output string will be formatted, mimicking different data types. Several conversion types are available for the modulo operator in Python. They allow you to control the output’s format in some way. For example, you can convert numbers to hexadecimal notation or add whitespace padding to generate nicely formatted tables and reports. Here’s a summary of the conversion types currently available in Python: A percentage character ( ) in the result if no argument is converted With all these conversion types, you can process your interpolated values to display them using different representation types. Note: It’s important to note that f-strings and the method also support the conversion types listed above. For details on this topic, check out the Converting Between Type Representations section in the Python’s Format Mini-Language for Tidy Strings tutorial. Here are a few examples of how to use some of the above specifiers in your strings: In these examples, you’ve used different conversion types to display values using different type representations. Now, check out the examples below to see other formatting options in action: In the first example, you use named replacement fields in parentheses and a dictionary to provide the values you want to interpolate. In the second example, you provide a minimum width for your string in characters. The third example is a dynamic variation of the second. Note how the symbol allows you to insert the desired width dynamically. Finally, you use the precision option to display a floating-point number using different precisions. You use two, four, and eight digits after the decimal separator, respectively. Unfortunately, the modulo operator doesn’t support the string formatting mini-language, so if you use this tool to interpolate and format your strings, then your formatting options are more limited than when you use f-strings or . The modulo operator also supports what’s known as conversion flags. Here’s a quick summary of the currently available flags: Left-justifies the value (overrides the conversion if both are given) Adds a sign character ( or ) before the value These flags help you apply some additional formatting options to your strings. Consider the following quick examples: In these examples, you demonstrate the effect of the flag, which prepends the appropriate prefix to the input number depending on the base you use. This flag is mostly used with integer values. Here are some more examples of using different flags: In the first example, you add zero padding to the input value. Next, you have an example of how to use the minus sign to align a value to the left in a width of ten characters. The space flag allows you to add a space before positive numbers. This space disappears when the value is negative. Finally, you use the plus sign so the string always displays whether the input value is positive or negative.\n\nDeciding Which String Formatting Tool to Use You’ve learned about three different tools for string formatting up to this point. Having several choices for one task can be confusing. In the end, what tool should you use? If you want readable syntax, good performance, and you’re doing eager interpolation, then f-strings are for you. On the other hand, if you need a tool for doing lazy string interpolation, then the method is the way to go. In contrast, the modulo operator ( ) is an old-fashioned tool not commonly used in modern Python. You could say that this tool is almost dead. However, you may find it in legacy Python code, so it’s good to know how it works. The following table compares the three tools using several comparison criteria: F-strings are the clear winner in terms of readability. However, they don’t allow you to do lazy interpolation. There’s no way to use an f-string to create a reusable string template that you can interpolate later in your code. If you want a universal tool with all the features, then the method is the way to go.\n\nNow that you have some experience with string formatting tools in Python, you can use the questions and answers below to check your understanding and recap what you’ve learned. These FAQs are related to the most important concepts you’ve covered in this tutorial. Click the Show/Hide toggle beside each question to reveal the answer: What is string formatting in Python?Show/Hide String formatting in Python is the process of applying a specific format to a given value when creating a new string through interpolation. This allows you to embed variables and expressions into strings and control the appearance of the resulting output. How do you format a string in Python?Show/Hide You can format a string in Python using several methods: f-strings, the method, and the modulo operator ( ). What are the different types of string formatting in Python?Show/Hide The different types of string formatting in Python include f-strings for embedding expressions inside string literals, the method for creating string templates and filling them with values, and the modulo operator ( ), an older method used in legacy code similar to C’s function. Which string formatting method is best in Python?Show/Hide The string formatting method you choose will depend on the use case. While f-strings are best for readability and performance in modern Python and ideal for eager interpolation, the method is useful for lazy interpolation and when you need reusable templates. The modulo operator ( ), on the other hand, is mostly for maintaining legacy code and isn’t recommended for new projects. Python’s string formatting mini-language offers several features, including string alignment, type conversion, numeric formatting, and dynamic formatting. These features provide enhanced control over how interpolated values are presented in the final string. Get Your Code: Click here to download the free sample code you’ll use to learn about Python’s string formatting tools. Test your knowledge with our interactive “Python String Formatting: Available Tools and Their Features” quiz. You’ll receive a score upon completion to help you track your learning progress: Python String Formatting: Available Tools and Their Features You can take this quiz to test your understanding of the available tools for string formatting in Python, as well as their strengths and weaknesses. These tools include f-strings, the .format() method, and the modulo operator."
    },
    {
        "link": "https://mehedi-khan.medium.com/python-string-formatting-best-practices-4765104bc243",
        "document": "Below is an example tutorial on Python string formatting best practices with code examples. This tutorial assumes a basic understanding of Python programming.\n\nString formatting is a crucial aspect of Python programming and there are multiple ways to achieve it. In This tutorial, we’ll explore the best practices for string formatting is Python, focusing on readability, flexibility, and performance.\n\nThe old-style formatting using is still valid, but it’s considered outdated. However, it’s essential to be aware of it for understanding legacy code.\n\nThe method provides a more flexible and readable way to format strings. It allows for positional and keyword arguments.\n\nF-strings are a concise and efficient way to format strings introduced in Python 3.6. They allow embedding expressions inside string literals.\n\nTemplate string provide a simple and safe way for string formatting. They are less powerful than f-string but useful in certain scenarios.\n\nF-strings are concise and offer better readability. Use them whenever possible, especially in Python 3.6 and above.\n\nWhen using , consider using named placeholders for improved readability.\n\nc. Be Mindful of Escape Characters\n\nEscape characters (\n\n, \\t, etc.) may behave differently in different formatting methods. Be cautious and double-check when using them.\n\nIn performance-critical scenarios, f-strings are generally faster than other formatting methods. However, the difference might be negligible for most applications.\n\nString formatting in Python offers multiple approaches, each with its strengths. Choose the method that aligns with your Python version and project requirements. F-strings are recommended for modern Python projects due to their readability and efficiency.\n\nFeel free to experiment with the examples and incorporate these best practices into your Python projects!"
    }
]