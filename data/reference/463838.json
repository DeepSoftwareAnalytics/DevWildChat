[
    {
        "link": "https://geeksforgeeks.org/implementation-of-quick-sort-in-php",
        "document": "Quick Sort is a widely used sorting algorithm known for its efficiency and speed. It follows the divide-and-conquer paradigm, sorting an array by selecting a pivot element and partitioning the other elements into two sub-arrays according to whether they are less than or greater than the pivot. In this article, we will explore the implementation of Quick Sort in PHP.\n\nQuick Sort is a sorting algorithm based on the Divide and Conquer algorithm. It picks an element as a pivot and partitions the given array around the picked pivot by placing the pivot in its correct position in the sorted array.\n\nThere are many different choices for picking pivots.\n• None Always pick the first element as a pivot.\n• None Always pick the last element as a pivot (implemented below)\n• None Pick the middle as the pivot.\n\nThe basic Quick Sort algorithm involves selecting a pivot, partitioning the array, and recursively sorting the sub-arrays."
    },
    {
        "link": "https://stackoverflow.com/questions/990301/building-quicksort-with-php",
        "document": "In fact I did this for a data point on a presentation I am putting together. The test sorts an array of 250,000 integers using the native sort function and an implementation of the quicksort algorithm written in php. The contents of the array are exactly the same for both runs, the data is randomized, and the time reported is only for performing the sort, not other processing necessary to invoke the php interpreter.\n\nDefinitely use the native implementation. That should be the case for any interpreted language.\n\nThe results for the other languages I tested with the same conditions using the same implementation on the same hardware and OS, provide an interesting performance comparison and put the PHP result in perspective:\n\nNotably, Chrome and Safari performed much faster for the JavaScript test, but I don't include those here because those tests were recorded in a different environment."
    },
    {
        "link": "https://geeksforgeeks.org/quick-sort-algorithm",
        "document": "QuickSort is a sorting algorithm based on the Divide and Conquer that picks an element as a pivot and partitions the given array around the picked pivot by placing the pivot in its correct position in the sorted array.\n\nQuickSort works on the principle of divide and conquer, breaking down the problem into smaller sub-problems.\n\nThere are mainly three steps in the algorithm:\n• Choose a Pivot: Select an element from the array as the pivot. The choice of pivot can vary (e.g., first element, last element, random element, or median).\n• Partition the Array: Rearrange the array around the pivot. After partitioning, all elements smaller than the pivot will be on its left, and all elements greater than the pivot will be on its right. The pivot is then in its correct position, and we obtain the index of the pivot.\n• Recursively Call: Recursively apply the same process to the two partitioned sub-arrays (left and right of the pivot).\n• Base Case: The recursion stops when there is only one element left in the sub-array, as a single element is already sorted.\n\nHere’s a basic overview of how the QuickSort algorithm works.\n\nThere are many different choices for picking pivots.\n• None Always pick the first (or last) element as a pivot . The below implementation picks the last element as pivot. The problem with this approach is it ends up in the worst case when array is already sorted.\n• None . This is a preferred approach because it does not have a pattern for which the worst case happens.\n• None Pick the median element is pivot. This is an ideal approach in terms of time complexity as we can find median in linear time and the partition function will always divide the input array into two halves. But it takes more time on average as median finding has high constants.\n\nThe key process in quickSort is a partition(). There are three common algorithms to partition. All these algorithms have O(n) time complexity.\n• Naive Partition : Here we create copy of the array. First put all smaller elements and then all greater. Finally we copy the temporary array back to original array. This requires O(n) extra space.\n• Lomuto Partition : We have used this partition in this article. This is a simple algorithm, we keep track of index of smaller elements and keep swapping. We have used it here in this article because of its simplicity.\n• Hoare’s Partition : This is the fastest of all. Here we traverse array from both sides and keep swapping greater element on left with smaller on right while the array is not partitioned. Please refer\n\nLet us understand the working of partition algorithm with the help of the following example:\n\nIn the previous step, we looked at how the partitioning process rearranges the array based on the chosen pivot. Next, we apply the same method recursively to the smaller sub-arrays on the left and right of the pivot. Each time, we select new pivots and partition the arrays again. This process continues until only one element is left, which is always sorted. Once every element is in its correct position, the entire array is sorted.\n\nBelow image illustrates, how the recursive method calls for the smaller sub-arrays on the left and right of the pivot:\n\nQuick Sort is a crucial algorithm in the industry, but there are other sorting algorithms that may be more optimal in different cases.\n\n// Index of smaller element and indicates // the right position of pivot found so far // elements on left side. Elements from low to // i are smaller after every iteration // pi is the partition return index of pivot // Index of smaller element and indicates // the right position of pivot found so far // elements to the left side. Elements from low to // i are smaller after every iteration // pi is the partition return index of pivot // Index of smaller element and indicates // the right position of pivot found so far // elements to the left side. Elements from low to // i are smaller after every iteration // pi is the partition return index of pivot # Index of smaller element and indicates # the right position of pivot found so far # elements to the left side. Elements from low to # i are smaller after every iteration # pi is the partition return index of pivot // Index of smaller element and indicates // the right position of pivot found so far // elements to the left side. Elements from low to // i are smaller after every iteration // pi is the partition return index of pivot // Index of smaller element and indicates // the right position of pivot found so far // elements to the left side. Elements from low to // i are smaller after every iteration // pi is the partition return index of pivot // Index of smaller element and indicates // the right position of pivot found so far // elements to the left side. Elements from low to // i are smaller after every iteration // pi is the partition return index of pivot\n• Best Case: (Ω(n log n)), Occurs when the pivot element divides the array into two equal halves.\n• Average Case (θ(n log n)), On average, the pivot divides the array into two parts, but not necessarily equal.\n• Worst Case: (O(n²)), Occurs when the smallest or largest element is always chosen as the pivot (e.g., sorted arrays).\n\nPlease refer Time and Space Complexity Analysis of Quick Sort for more details.\n• None It is a divide-and-conquer algorithm that makes it easier to solve problems.\n• None It is efficient on large data sets.\n• None It has a low overhead, as it only requires a small amount of memory to function.\n• None It is Cache Friendly as we work on the same array to sort and do not copy data to any auxiliary array.\n• None Fastest general purpose algorithm for large data when stability is not required.\n• tail recursive and hence all the can be done.\n• None It has a worst-case time complexity of O(n ), which occurs when the pivot is chosen poorly.\n• None It is not a good choice for small data sets.\n• None It is not a stable sort, meaning that if two elements have the same key, their relative order will not be preserved in the sorted output in case of quick sort, because here we are swapping elements according to the pivot’s position (without considering their original positions).\n• None Efficient for sorting large datasets with O(n log n) average-case time complexity.\n• None Used in partitioning problems like finding the kth smallest element or dividing arrays by pivot.\n• None Integral to randomized algorithms, offering better performance than deterministic approaches.\n• None Applied in cryptography for generating random permutations and unpredictable encryption keys.\n• None Partitioning step can be parallelized for improved performance in multi-core or distributed systems.\n• None Important in theoretical computer science for analyzing average-case complexity and developing new techniques.\n\nPlease refer Application of Quicksort for more details."
    },
    {
        "link": "https://w3schools.com/dsa/dsa_algo_quicksort.php",
        "document": "As the name suggests, Quicksort is one of the fastest sorting algorithms.\n\nThe Quicksort algorithm takes an array of values, chooses one of the values as the 'pivot' element, and moves the other values so that lower values are on the left of the pivot element, and higher values are on the right of it.\n\nIn this tutorial the last element of the array is chosen to be the pivot element, but we could also have chosen the first element of the array, or any element in the array really.\n\nThen, the Quicksort algorithm does the same operation recursively on the sub-arrays to the left and right side of the pivot element. This continues until the array is sorted.\n\nThe algorithm can be described like this:\n\nContinue reading to fully understand the Quicksort algorithm and how to implement it yourself.\n\nBefore we implement the Quicksort algorithm in a programming language, let's manually run through a short array, just to get the idea.\n\nStep 1: We start with an unsorted array.\n\nStep 2: We choose the last value 3 as the pivot element.\n\nStep 3: The rest of the values in the array are all greater than 3, and must be on the right side of 3. Swap 3 with 11.\n\nStep 4: Value 3 is now in the correct position. We need to sort the values to the right of 3. We choose the last value 11 as the new pivot element.\n\nStep 5: The value 7 must be to the left of pivot value 11, and 12 must be to the right of it. Move 7 and 12.\n\nStep 6: Swap 11 with 12 so that lower values 9 and 7 are on the left side of 11, and 12 is on the right side.\n\nStep 7: 11 and 12 are in the correct positions. We choose 7 as the pivot element in sub-array [ 9, 7], to the left of 11.\n\nStep 8: We must swap 9 with 7.\n\nAnd now, the array is sorted.\n\nRun the simulation below to see the steps above animated:\n\nBefore we implement the algorithm in a programming language we need to go through what happened above in more detail.\n\nWe have already seen that last value of the array is chosen as the pivot element, and the rest of the values are arranged so that the values lower than the pivot value are to the left, and the higher values are to the right.\n\nAfter that, the pivot element is swapped with the first of the higher values. This splits the original array in two, with the pivot element in between the lower and the higher values.\n\nNow we need to do the same as above with the sub-arrays on the left and right side of the old pivot element. And if a sub-array has length 0 or 1, we consider it finished sorted.\n\nTo sum up, the Quicksort algorithm makes the sub-arrays become shorter and shorter until array is sorted.\n\nTo write a 'quickSort' method that splits the array into shorter and shorter sub-arrays we use recursion. This means that the 'quickSort' method must call itself with the new sub-arrays to the left and right of the pivot element. Read more about recursion here.\n\nTo implement the Quicksort algorithm in a programming language, we need:\n• An array with values to sort.\n• A method that calls itself (recursion) if the sub-array has a size larger than 1.\n• A method that receives a sub-array, moves values around, swaps the pivot element into the sub-array and returns the index where the next split in sub-arrays happens.\n\nThe resulting code looks like this:\n\nThe worst case scenario for Quicksort is \\(O(n^2) \\). This is when the pivot element is either the highest or lowest value in every sub-array, which leads to a lot of recursive calls. With our implementation above, this happens when the array is already sorted.\n\nBut on average, the time complexity for Quicksort is actually just \\(O(n \\log n) \\), which is a lot better than for the previous sorting algorithms we have looked at. That is why Quicksort is so popular.\n\nBelow you can see the significant improvement in time complexity for Quicksort in an average scenario \\(O(n \\log n) \\), compared to the previous sorting algorithms Bubble, Selection and Insertion Sort with time complexity \\(O(n^2) \\):\n\nThe recursion part of the Quicksort algorithm is actually a reason why the average sorting scenario is so fast, because for good picks of the pivot element, the array will be split in half somewhat evenly each time the algorithm calls itself. So the number of recursive calls do not double, even if the number of values \\(n \\) double.\n\nRun Quicksort on different kinds of arrays with different number of values in the simulation below:"
    },
    {
        "link": "https://stackoverflow.com/questions/63185281/quick-sort-in-php",
        "document": "Arrays are not passed by reference by default in PHP. (They're not simply pointers like they would be in C.) So your functions aren't actually changing the input array.\n\nI've modified your function declarations below and it now works as expected.\n\nAlso, you need to be ;\n\nIt's worth noting that the sort functions for arrays that PHP provides already use an implementation of QuickSort."
    },
    {
        "link": "https://php.net/manual/en/ref.array.php",
        "document": "permanovd at gmail dot com ¶ A simple trick that can help you to guess what diff/intersect or sort function does by name.\n\n\n\n[suffix] assoc - additional index check. Compares both value and index.\n\n\n\nExample: array_diff_assoc, array_intersect_assoc.\n\n\n\n[suffix] key - index only check. Ignores value of array, compares only indexes.\n\n\n\nExample: array_diff_key, array_intersect_key.\n\n\n\n[suffix] **empty** - no \"key\" or \"assoc\" word in suffix. Compares values only. Ignores indexes of array.\n\n\n\nExample: array_diff, array_intersect.\n\n\n\n[prefix] u - will do comparison with user defined function. Letter u can be used twice in some functions (like array_udiff_uassoc), this means that you have to use 2 functions (one for value, one for index).\n\n\n\nExample: array_udiff_uassoc, array_uintersect_assoc.\n\n\n\nThis also works with array sort functions:\n\n\n\n[prefix] a - associative. Will preserve keys.\n\n\n\nExample: arsort, asort.\n\n\n\n[prefix] k - key sort. Will sort array by keys.\n\n\n\nExample: uksort, ksort.\n\n\n\n[prefix] r - reverse. Will sort array in reverse order.\n\n\n\nExample: rsort, krsort.\n\n\n\n[prefix] u - sort by user defined function (same as for diff/intersect). \n\n\n\nExample: usort, uasort.\n\net2225zas14 at susu dot ru ¶ Be careful with type hints in callbacks when using array-traverse functions. In some cases, this may silently cause the data type of elements to change. \n\n\n\n\n\nThe above example will output (PHP version 8.3.6, error_reporting E_ALL):\n\n\n\n\n\nrenatonascto at gmail dot com ¶ Big arrays use a lot of memory possibly resulting in memory limit errors. You can reduce memory usage on your script by destroying them as soon as you´re done with them. I was able to get over a few megabytes of memory by simply destroying some variables I didn´t use anymore. \n\nYou can view the memory usage/gain by using the funcion memory_get_usage(). Hope this helps!\n\nindioeuropeo at driverop dot com ¶ I need to take an element from the Array and change its position within the Array by moving the rest of the elements as required.\n\nThis is the function that does it. The first parameter is the working Array. The second is the position of the element to move and the third is the position where to move the element.\n\nThe function returns the modified Array.\n\n Examples:\n\n Return:"
    },
    {
        "link": "https://php.net/manual/en/function.array-merge.php",
        "document": "array_merge — Merge one or more arrays If the input arrays have the same string keys, then the later value for that key will overwrite the previous one. If, however, the arrays contain numeric keys, the later value will not overwrite the original value, but will be appended. Values in the input arrays with numeric keys will be renumbered with incrementing keys starting from zero in the result array. Returns the resulting array. If called without any arguments, returns an empty array. This function can now be called without any parameter. Formerly, at least one parameter has been required. The above example will output: Don't forget that numeric keys will be renumbered! If you want to append array elements from the second array to the first array while not overwriting the elements from the first array and not re-indexing, use the array union operator: The keys from the first array will be preserved. If an array key exists in both arrays, then the element from the first array will be used and the matching key's element from the second array will be ignored. The above example will output:\n• None - Merge one or more arrays recursively array_merge_recursive() - Merge one or more arrays recursively\n• None - Replaces elements from passed arrays into the first array array_replace() - Replaces elements from passed arrays into the first array\n• None - Creates an array by using one array for keys and another for its values array_combine() - Creates an array by using one array for keys and another for its values\n\nJulian Egelstaff ¶ In some situations, the union operator ( + ) might be more useful to you than array_merge. The array_merge function does not preserve numeric key values. If you need to preserve the numeric keys, then using + will do that.\n\n\n\nie:\n\n\n\n\n\nNote the implicit \"array_unique\" that gets applied as well. In some situations where your numeric keys matter, this behaviour could be useful, and better than array_merge.\n\n\n\n--Julian ChrisM ¶ I wished to point out that while other comments state that the spread operator should be faster than array_merge, I have actually found the opposite to be true for normal arrays. This is the case in both PHP 7.4 as well as PHP 8.0. The difference should be negligible for most applications, but I wanted to point this out for accuracy.\n\n\n\nBelow is the code used to test, along with the results:\n\n\n\n\n\nPHP 7.4:\n\n1.2135608196259 sec for spread\n\n1.1402177810669 sec for array_merge\n\n\n\nPHP 8.0:\n\n1.1952061653137 sec for spread\n\n1.099925994873 sec for array_merge Andreas Hofmann ¶ In addition to the text and Julian Egelstaffs comment regarding to keep the keys preserved with the + operator:\n\nWhen they say \"input arrays with numeric keys will be renumbered\" they MEAN it. If you think you are smart and put your numbered keys into strings, this won't help. Strings which contain an integer will also be renumbered! I fell into this trap while merging two arrays with book ISBNs as keys. So let's have this example:\n\n\n\n\n\nYou will get both:\n\n\n\narray(4) {\n\n [0]=>\n\n string(4) \"Mary\"\n\n [1]=>\n\n string(4) \"John\"\n\n [2]=>\n\n string(4) \"Phil\"\n\n [3]=>\n\n string(7) \"Brandon\"\n\n}\n\n\n\nUse the + operator or array_replace, this will preserve - somewhat - the keys:\n\n\n\n\n\nYou will get both:\n\n\n\narray(4) {\n\n [24]=>\n\n string(4) \"Mary\"\n\n [17]=>\n\n string(4) \"John\"\n\n [67]=>\n\n string(4) \"Phil\"\n\n [33]=>\n\n string(7) \"Brandon\"\n\n}\n\n\n\nThe keys will keep the same, the order will keep the same, but with a little caveat: The keys will be converted to integers. fsb at thefsb dot org ¶ \n\n\n\n [...$a, ...$b]\n\n\n\ndoes the same as\n\n\n\n array_merge($a, $b)\n\n\n\nand can be faster too.\n\n\n\nhttps://wiki.php.net/rfc/spread_operator_for_array#advantages_over_array_merge We no longer need array_merge() as of PHP 7.4.[...$a, ...$b]does the same asarray_merge($a, $b)and can be faster too."
    },
    {
        "link": "https://stackoverflow.com/questions/44441575/how-can-i-sort-the-result-of-array-merge-function",
        "document": "Here is my code:\n\nAlways there is one item which has empty value. In example above, that item is . Now I need to put that item as the last one. How can I do that?\n\nNote: I don't care about the order of other items.\n\nSo this is expected result:"
    },
    {
        "link": "https://geeksforgeeks.org/php-program-to-merge-two-sorted-arrays",
        "document": "Given two sorted arrays, i.e. arr1, and arr2, the task is to merge both sorted arrays and make a single sorted array.\n\nBelow are the methods to merge both arrays:\n\nHere, we iterate through both arrays and compare array elements to merge them into a new sorted array.\n\nThe array_merge() function is used to merge two or more arrays into a single array. After merging the both arrays, we use sort() function to sort the merged array in ascending order.\n\nExample 1: In this example, we will merge two sorted array to make a single sorted array.\n\nExample 2: In this example, merge two sorted array.\n\nThis program merges two sorted arrays using array_merge() function to combine them and array_unique() function to remove duplicates, ensuring the merged array remains sorted with unique elements.\n\nThis approach combines array_merge() function to merge the arrays and array_unique() function to remove duplicates while keeping the array sorted."
    },
    {
        "link": "https://stackoverflow.com/questions/9775562/sorting-an-array-and-merging-algorithm",
        "document": "I have two array of strings: one ordered array - Array X, and one unordered array - array Y\n\nWhat the new array should have: all items should only be from array Y, and the ones that overlap between X and Y should be ordered based on the order in X, and then the rest (if any) should just be at the end in the same order as they were originally in Y. It is possible that X contains entries that are not in Y, and we just want to ignore those.\n\nWhat is an efficient way of doing this (in php)?\n\nSo the idea is: we want to take the 2nd array (array Y), and sort the elements in it based on the ordering given to us in array X. Since Array Y might have more extra elements, we just want to put those extra elements at the end of this new resultant array. Makes sense?"
    }
]