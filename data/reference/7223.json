[
    {
        "link": "https://man7.org/linux/man-pages/man1/ssh-keygen.1.html",
        "document": "Pages that refer to this page: systemd-vmspawn(1)"
    },
    {
        "link": "https://ssh.com/academy/ssh/keygen",
        "document": "is a tool for creating new authentication key pairs for SSH. Such key pairs are used for automating logins, single sign-on, and for authenticating hosts.\n\nThe SSH protocol uses public key cryptography for authenticating hosts and users. The authentication keys, called SSH keys, are created using the program.\n\nSSH introduced public key authentication as a more secure alternative to the older authentication. It improved security by avoiding the need to have password stored in files, and eliminated the possibility of a compromised server stealing the user's password.\n\nHowever, SSH keys are authentication credentials just like passwords. Thus, they must be managed somewhat analogously to user names and passwords. They should have a proper termination process so that keys are removed when no longer needed.\n\nThe simplest way to generate a key pair is to run without arguments. In this case, it will prompt for the file in which to store keys. Here's an example:\n\nFirst, the tool asked where to save the file. SSH keys for user authentication are usually stored in the user's directory under the home directory. However, in enterprise environments, the location is often different. The default key file name depends on the algorithm, in this case when using the default RSA algorithm. It could also be, for example, or .\n\nThen it asks to enter a passphrase. The passphrase is used for encrypting the key, so that it cannot be used even if someone obtains the private key file. The passphrase should be cryptographically strong. Our online random password generator is one possible tool for generating strong passphrases.\n\nSSH supports several public key algorithms for authentication keys. These include:\n• - an old algorithm based on the difficulty of factoring large numbers. A key size of at least 2048 bits is recommended for RSA; 4096 bits is better. RSA is getting old and significant advances are being made in factoring. Choosing a different algorithm may be advisable. It is quite possible the RSA algorithm will become practically breakable in the foreseeable future. All SSH clients support this algorithm.\n• - an old US government Digital Signature Algorithm. It is based on the difficulty of computing discrete logarithms. A key size of 1024 would normally be used with it. DSA in its original form is no longer recommended.\n• - a new Digital Signature Algorithm standarized by the US government, using elliptic curves. This is probably a good algorithm for current applications. Only three key sizes are supported: 256, 384, and 521 (sic!) bits. We would recommend always using it with 521 bits, since the keys are still small and probably more secure than the smaller keys (even though they should be safe as well). Most SSH clients now support this algorithm.\n• - this is a new algorithm added in OpenSSH. Support for it in clients is not yet universal. Thus its use in general purpose applications may not yet be advisable.\n\nThe algorithm is selected using the option and key size using the option. The following commands illustrate:\n\nSpecifying the File Name\n\nNormally, the tool prompts for the file in which to store the key. However, it can also be specified on the command line using the option.\n\nCopying the Public Key to the Server\n\nTo use public key authentication, the public key must be copied to a server and installed in an authorized_keys file. This can be conveniently done using the ssh-copy-id tool. Like this:\n\nOnce the public key has been configured on the server, the server will allow any connecting user that has the private key to log in. During the login process, the client proves possession of the private key by digitally signing the key exchange.\n\nis a program that can hold a user's private key, so that the private key passphrase only needs to be supplied once. A connection to the agent can also be forwarded when logging into a server, allowing SSH commands on the server to use the agent running on the user's desktop.\n\nFor more information on using and configuring the SSH agent, see the ssh-agent page.\n\nThe tool is also used for creating host authentication keys. Host keys are stored in the directory.\n\nHost keys are just ordinary SSH key pairs. Each host can have one host key for each algorithm. The host keys are almost always stored in the following files:\n\nThe host keys are usually automatically generated when an SSH server is installed. They can be regenerated at any time. However, if host keys are changed, clients may warn about changed keys. Changed keys are also reported when someone tries to perform a man-in-the-middle attack. Thus it is not advisable to train your users to blindly accept them. Changing the keys is thus either best done using an SSH key management tool that also changes them on clients, or using certificates.\n\nOpenSSH does not support X.509 certificates. Tectia SSH does support them. X.509 certificates are widely used in larger organizations for making it easy to change host keys on a period basis while avoiding unnecessary warnings from clients. They also allow using strict host key checking, which means that the clients will outright refuse a connection if the host key has changed.\n\nOpenSSH has its own proprietary certificate format, which can be used for signing host certificates or user certificates. For user authentication, the lack of highly secure certificate authorities combined with the inability to audit who can access a server by inspecting the server makes us recommend against using OpenSSH certificates for user authentication.\n\nHowever, OpenSSH certificates can be very useful for server authentication and can achieve similar benefits as the standard X.509 certificates. However, they need their own infrastructure for certificate issuance.\n\nIt is easy to create and configure new SSH keys. In the default configuration, OpenSSH allows any user to configure new keys. The keys are permanent access credentials that remain valid even after the user's account has been deleted.\n\nIn organizations with more than a few dozen users, SSH keys easily accumulate on servers and service accounts over the years. We have seen enterprises with several million keys granting access to their production servers. It only takes one leaked, stolen, or misconfigured key to gain access.\n\nIn any larger organization, use of SSH key management solutions is almost necessary. SSH keys should also be moved to root-owned locations with proper provisioning and termination processes. For more information, see how to manage SSH keys. A widely used SSH key management tool for OpenSSH is Universal SSH Key Manager.\n\nPractically all cybersecurity regulatory frameworks require managing who can access what. SSH keys grant access, and fall under this requirement. This, organizations under compliance mandates are required to implement proper management processes for the keys. NIST IR 7966 is a good starting point.\n\nMake Sure There Is Enough Randomness\n\nIt is important to ensure there is enough unpredictable entropy in the system when SSH keys are generated. There have been incidents when thousands of devices on the Internet have shared the same host key when they were improperly configured to generate the key without proper randomness.\n\nOn general purpose computers, randomness for SSH key generation is usually not a problem. It may be something of an issue when initially installing the SSH server and generating host keys, and only people building new Linux distributions or SSH installation packages generally need to worry about it.\n\nOur recommendation is to collect randomness during the whole installation of the operating system, save that randomness in a random seed file. Then boot the system, collect some more randomness during the boot, mix in the saved randomness from the seed file, and only then generate the host keys. This maximizes the use of the available randomness. And make sure the random seed file is periodically updated, in particular make sure that it is updated after generating the SSH host keys.\n\nMany modern general-purpose CPUs also have hardware random number generators. This helps a lot with this problem. The best practice is to collect some entropy in other ways, still keep it in a random seed file, and mix in some entropy from the hardware random number generator. This way, even if one of them is compromised somehow, the other source of randomness should keep the keys secure.\n\nAvailable entropy can be a real problem on small IoT devices that don't have much other activity on the system. They may just not have the mechanical randomness from disk drive mechanical movement timings, user-caused interrupts, or network traffic. Furthermore, embedded devices often run on low-end processors that may not have a hardware random number generator.\n\nThe availability of entropy is also critically important when such devices generate keys for HTTPS.\n\nOur recommendation is that such devices should have a hardware random number generator. If the CPU does not have one, it should be built onto the motherboard. The cost is rather small.\n\nHere's a summary of commonly used options to the keygen tool:\n\n-b “Bits” This option specifies the number of bits in the key. The regulations that govern the use case for SSH may require a specific key length to be used. In general, 2048 bits is considered to be sufficient for RSA keys.\n\n-e “Export” This option allows reformatting of existing keys between the OpenSSH key file format and the format documented in RFC 4716, “SSH Public Key File Format”.\n\n-p “Change the passphrase” This option allows changing the passphrase of a private key file with and , .\n\n-t “Type” This option specifies the type of key to be created. Commonly used values are: - rsa for RSA keys - dsa for DSA keys - ecdsa for elliptic curve DSA keys\n\n-i \"Input\" When ssh-keygen is required to access an existing key, this option designates the file.\n\n-f \"File\" Specifies name of the file in which to store the created key.\n\n-N \"New\" Provides a new passphrase for the key.\n\n-P \"Passphrase\" Provides the (old) passphrase when reading a key.\n\n-c \"Comment\" Changes the comment for a keyfile.\n\n-l \"Fingerprint\" Print the fingerprint of the specified public key.\n\n-F Search for a specified hostname in a known_hosts file.\n\n-R Remove all keys belonging to a hostname from a known_hosts file.\n\n-y Read a private OpenSSH format file and print an OpenSSH public key to stdout.\n\nThis only listed the most commonly used options. For full usage, including the more exotic and special-purpose options, use the command."
    },
    {
        "link": "https://docs.github.com/en/authentication/connecting-to-github-with-ssh/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent",
        "document": "You can access and write data in repositories on GitHub using SSH (Secure Shell Protocol). When you connect via SSH, you authenticate using a private key file on your local machine. For more information, see About SSH.\n\nWhen you generate an SSH key, you can add a passphrase to further secure the key. Whenever you use the key, you must enter the passphrase. If your key has a passphrase and you don't want to enter the passphrase every time you use the key, you can add your key to the SSH agent. The SSH agent manages your SSH keys and remembers your passphrase.\n\nIf you don't already have an SSH key, you must generate a new SSH key to use for authentication. If you're unsure whether you already have an SSH key, you can check for existing keys. For more information, see Checking for existing SSH keys.\n\nIf you want to use a hardware security key to authenticate to GitHub, you must generate a new SSH key for your hardware security key. You must connect your hardware security key to your computer when you authenticate with the key pair. For more information, see the OpenSSH 8.2 release notes.\n\nYou can generate a new SSH key on your local machine. After you generate the key, you can add the public key to your account on GitHub.com to enable authentication for Git operations over SSH.\n\nAs of that date, DSA keys ( ) are no longer supported. You cannot add new DSA keys to your personal account on GitHub. RSA keys ( ) with a before November 2, 2021 may continue to use any signature algorithm. RSA keys generated after that date must use a SHA-2 signature algorithm. Some older clients may need to be upgraded in order to use SHA-2 signatures.\n• Paste the text below, replacing the email used in the example with your GitHub email address. If you are using a legacy system that doesn't support the Ed25519 algorithm, use: This creates a new SSH key, using the provided email as a label. When you're prompted to \"Enter a file in which to save the key\", you can press Enter to accept the default file location. Please note that if you created SSH keys previously, ssh-keygen may ask you to rewrite another key, in which case we recommend creating a custom-named SSH key. To do so, type the default file location and replace id_ALGORITHM with your custom key name. > Enter file which to save the key (/c/Users/YOU/.ssh/id_ALGORITHM):[ ]\n• At the prompt, type a secure passphrase. For more information, see Working with SSH key passphrases. Enter same passphrase again: [Type passphrase again]\n\nAdding your SSH key to the ssh-agent\n\nBefore adding a new SSH key to the ssh-agent to manage your keys, you should have checked for existing SSH keys and generated a new SSH key. When adding your SSH key to the agent, use the default macOS command, and not an application installed by macports, homebrew, or some other external source.\n• Start the ssh-agent in the background. Depending on your environment, you may need to use a different command. For example, you may need to use root access by running before starting the ssh-agent, or you may need to use or to run the ssh-agent.\n• If you're using macOS Sierra 10.12.2 or later, you will need to modify your file to automatically load keys into the ssh-agent and store passphrases in your keychain.\n• First, check to see if your file exists in the default location. The file /Users/YOU/.ssh/config does not exist.\n• If the file doesn't exist, create the file.\n• Open your file, then modify the file to contain the following lines. If your SSH key file has a different name or path than the example code, modify the filename or path to match your current setup.\n• If you chose not to add a passphrase to your key, you should omit the line.\n• If you see a error, add an additional line to the configuration's' section.\n• Add your SSH private key to the ssh-agent and store your passphrase in the keychain. If you created your key with a different name, or if you are adding an existing key that has a different name, replace id_ed25519 in the command with the name of your private key file. The option stores the passphrase in your keychain for you when you add an SSH key to the ssh-agent. If you chose not to add a passphrase to your key, run the command without the option. The option is in Apple's standard version of . In macOS versions prior to Monterey (12.0), the and flags used the syntax and , respectively. If you don't have Apple's standard version of installed, you may receive an error. For more information, see Error: ssh-add: illegal option -- apple-use-keychain. If you continue to be prompted for your passphrase, you may need to add the command to your file (or your file for bash).\n• Add the SSH public key to your account on GitHub. For more information, see Adding a new SSH key to your GitHub account.\n\nIf you are using macOS or Linux, you may need to update your SSH client or install a new SSH client prior to generating a new SSH key. For more information, see Error: Unknown key type.\n• Insert your hardware security key into your computer.\n• Paste the text below, replacing the email address in the example with the email address associated with your GitHub account. If the command fails and you receive the error or you may be using a hardware security key that does not support the Ed25519 algorithm. Enter the following command instead.\n• When you are prompted, touch the button on your hardware security key.\n• When you are prompted to \"Enter a file in which to save the key,\" press Enter to accept the default file location.\n• When you are prompted to type a passphrase, press Enter. Enter same passphrase again: [Type passphrase again]\n• Add the SSH public key to your account on GitHub. For more information, see Adding a new SSH key to your GitHub account."
    },
    {
        "link": "https://linux.die.net/man/1/ssh-keygen",
        "document": ""
    },
    {
        "link": "https://docs.oracle.com/cd/E36784_01/html/E36870/ssh-keygen-1.html",
        "document": "The utility generates, manages, and converts authentication keys for ssh(1). can create RSA keys for use by SSH protocol version 1 and RSA or DSA keys for use by SSH protocol version 2. The type of key to be generated is specified with the option. can also generate fingerprints or convert the public keys from the X.509v3 certificates specified as PKCS#11 URIs.\n\nNormally, each user wishing to use SSH with RSA or DSA authentication runs this once to create the authentication key in , , or . The system administrator can also use this to generate host keys..\n\nOrdinarily, this program generates the key and asks for a file in which to store the private key. The public key is stored in a file with the same name but with the `` '' extension appended. The program also asks for a passphrase. The passphrase can be empty to indicate no passphrase (host keys must have empty passphrases), or it can be a string of arbitrary length. Good passphrases are 10-30 characters long, are not simple sentences or otherwise easy to guess, and contain a mix of uppercase and lowercase letters, numbers, and non-alphanumeric characters. (English prose has only 1-2 bits of entropy per word and provides very poor passphrases.) If a passphrase is set, it must be at least 4 characters long.\n\nThe passphrase can be changed later by using the option.\n\nThere is no way to recover a lost passphrase. If the passphrase is lost or forgotten, you have to generate a new key and copy the corresponding public key to other machines.\n\nFor RSA, there is also a comment field in the key file that is only for convenience to the user to help identify the key. The can tell what the key is for, or whatever is useful. The comment is initialized to `` '' when the key is created, but can be changed using the option.\n\nAfter a key is generated, instructions below detail where to place the keys to activate them.\n\nThe following options are supported:\n\nSpecifies the number of bits in the key to create. The minimum number is 512 bits. Generally, 2048 bits is considered sufficient. Key sizes above that no longer improve security but make things slower. The default is 2048 bits. Shows the bubblebabble digest of the specified private or public key file. Requests changing the comment in the private and public key files. The program prompts for the file containing the private keys, for the passphrase if the key has one, and for the new comment. This option only applies to ( ) keys. Provides the new comment. This option reads a private or public OpenSSH key file and prints the key in a “SECSH” Public Key File Format to stdout. This option allows exporting keys for use by several other SSH implementations. Specifies the filename of the key file. Search for the specified in a file, listing any occurrences found. This option is useful to find hashed host names or addresses and can also be used in conjunction with the option to print found keys in a hashed format. Hash a file. This replaces all host names and addresses with hashed representations within the specified file. The original content is moved to a file with a suffix. These hashes may be used normally by and , but they do not reveal identifying information should the file's contents be disclosed. This option does not modify existing hashed host names and is therefore safe to use on files that mix hashed and non-hashed names. This option reads an unencrypted private (or public) key file in SSH2-compatible format and prints an OpenSSH compatible private (or public) key to stdout. also reads the “SECSH” Public Key File Format. This option allows importing keys from several other SSH implementations. Shows the fingerprint of the specified private or public key file. Provides the new passphrase. Requests changing the passphrase of a private key file instead of creating a new private key. The program prompts for the file containing the private key, for the old passphrase, and prompts twice for the new passphrase. Provides the (old) passphrase. Specifies the algorithm used for the key, where is one of , , and . Type is used only for the SSHv1 protocol. Removes all keys belonging to from a file. This option is useful to delete hashed hosts. See . This option reads a private OpenSSH format file and prints an OpenSSH public key to stdout. Specifies that will generate the keys in PKCS#8 format. The supported type of key to be generated is or .\n\nThe following exit values are returned:\n\nThis file contains the RSA private key for the SSHv1 protocol. This file should not be readable by anyone but the user. It is possible to specify a passphrase when generating the key; that passphrase is used to encrypt the private part of this file using 128–bit AES. This file is not automatically accessed by , but it is offered as the default file for the private key. (1M) reads this file when a login attempt is made. This file contains the RSA public key for the SSHv1 protocol. The contents of this file should be added to on all machines where you wish to log in using RSA authentication. There is no need to keep the contents of this file secret. These files contain, respectively, the DSA or RSA private key for the SSHv2 protocol. These files should not be readable by anyone but the user. It is possible to specify a passphrase when generating the key; that passphrase is used to encrypt the private part of the file using 3DES. Neither of these files is automatically accessed by but is offered as the default file for the private key. (1M) reads this file when a login attempt is made. These files contain, respectively, the DSA or RSA public key for the SSHv2 protocol. The contents of these files should be added, respectively, to on all machines where you wish to log in using DSA or RSA authentication. There is no need to keep the contents of these files secret.\n\nSee (5) for descriptions of the following attributes:"
    },
    {
        "link": "https://beyondtrust.com/blog/entry/ssh-key-management-overview-6-best-practices",
        "document": ""
    },
    {
        "link": "https://security.stackexchange.com/questions/143442/what-are-ssh-keygen-best-practices",
        "document": "Stack Exchange network consists of 183 Q&A communities including Stack Overflow, the largest, most trusted online community for developers to learn, share their knowledge, and build their careers."
    },
    {
        "link": "https://brandonchecketts.com/archives/its-2023-you-should-be-using-an-ed25519-ssh-key-and-other-current-best-practices",
        "document": "UPDATE: I’ve got an updated post containing SSH Key Best Practices for 2025\n\nI often have to ask other IT professionals for the Public SSH key for access to a server or for other tasks. I really cringe when they ask me what that is or how to create one. I kindof cringe when they give me one from PuttyGen in its native format. I feel a little better when they provide a 4096-bit RSA key without needing an explanation. When somebody provides an Ed25519 key, I feel like I’m working with somebody who knows what they are doing.\n\nA 4096-bit RSA Keys look like this:\n\nAnd for comparison, an Ed25519 Key looks like this:\n\nThe Ed25519 key is much shorter, so initially you might think it is less secure. But these keys use a totally different algorithm, so although the key has fewer characters, it is, for all practical purposes, as secure as the RSA key above. You can ask your favorite search engine or AI for more details about the differences.\n\nThe Ed25519 algorithm has been around for ~10 years now. It is widely supported by any modern software, and as such is the current standard for most professional users. Creating a key is simple with the ssh-keygen command. But before jumping to the actual command, I wanted to also explain a couple other tips that I use, and think others should pick up as well.\n\nKeys should be issued to individuals, not groups\n\nYou should never, ever share your private key with anybody. Ever. If a key is ever shared, you have to assume that the other party can impersonate you on any system in which it is used.\n\nI’ve seen some organizations who create a new machine and use a new SSH Key on it. Then share the key with all of the individuals who need to access the machine. Perhaps this practice comes from AWS or other hosting providers who create an SSH key for you, along with a new machine, and the user not knowing any better.\n\nAlthough it kindof works, that’s the backwards way of doing it. Individuals should own their own keys. They should be private. And you can add multiple public keys to resources where multiple people need access. You then revoke access by removing the public key, instead of having to re-issue a new key whenever the group changes. (Or worse, not changing the key at all!)\n\nYou should rotate your SSH keys on some kind of schedule. The main risk you are trying to avoid here is that if you have used the same key for 20 years, and then your laptop with your private key gets lost, or your key compromised, every machine that you’ve been granted access to over that time is potentially at risk, because administrators are notoriously bad about revoking access. By changing out your key regularly, you limit the potential access in the case of a compromised key. Generating a new SSH key also ensures that you are using more modern algorithms and key sizes.\n\nI like to start a new key about every year. To remind my self to do this, I embed the year I created the key within its name. So I last created a key in March 2023, which I have named brandon+2022-03@roundsphere. When it gets to be 2024, I’ll be subtly reminded each time I use it that it’s time to create a new key. I keep all of my older keys if I need them. But they aren’t in memory or in my SSH-Agent. If I do need to use one, it is enough of a process to find the old one, that the first thing I’ll do is update my key as soon as I get in a system where an old key was needed.\n\nMake the comment meaningful. If you don’t provide a comment, it defaults to your_username@you_machine name which just might be silly or meaningless. In a professional setting, it should clearly identify you. For example BrandonChecketts as a comment is better than me00101@billys2017_macbook_air. It should be meaningful both to you, and to whomever you are sharing it.\n\nI mentioned including the creation month above, which I like because when sharing it, it subtly demonstrates that I am at least somewhat security conscious and I know what I’m doing. The comment at the end of the key isn’t necessary for the key to work correctly, so you can change it when sharing it. I often change the comment to be more meaningful if someone provides me with a key that doesn’t clearly indicate its owner.\n\nYour SSH key is just a tiny file on disk. If your machine is ever lost, stolen, or compromised in any way by an attacker, the file is pretty easy for them to copy. Without it being encrypted with a pass phrase, it is directly usable. And if someone has access to your SSH private key, they probably have access to your history and would know where to use it.\n\nAs such, it is important to protect your SSH private key with a decent pass phrase. Note that you can use SSH-Agent so you don’t need to type the passphrase every time you need to use the key.\n\nThis is the command you should use to create your ED25519 Key:\n\nThat will ask you for a pass phrase and then show you a cool randomart image that represents your public key when it is created\n\nI maybe have spent 10 minutes creating a key over an over until I found a key that ended in a few character that I like. One of my keys ends in 7srus, so I think of it as my “7’s ‘R’ Us” key. You can do that over and over again until you find a key that you like with this one-liner:\n\nThat creates a key without a passphrase, so you can do it over and over quickly until you find a public key that you “like”. Then protect it with a passphrase with the command\n\nAnd obviously, then you rename it from newkey to something more meaningful.\n\nWhat else? Any other tips for creating an SSH key and looking like a professional in 20223?"
    },
    {
        "link": "https://venafi.com/blog/ssh-keys-overview-and-best-practices",
        "document": "Safety and security are of the utmost importance in both personal practices and business practices. Knowing that your accounts and systems are safe and managed in an organized and protected manner will put you and all those you work with at ease. That’s why knowing about SSH keys —how they work, how you can implement them, and who you can trust to keep them secure—is imperative to keeping your organization’s private information protected from hackers. Before we go into the details of what SSH keys are used for and how they can best be managed, first let's ask, what are they? SSH keys are an authentication system that allows users to access encrypted connections between systems. In other words, it is the secure bridge between two systems that only allows users with certain code/keys to access said system. These keys are vital to having a safe and secure network of systems. ManagingManagement of SSH keys means maintaining controlled access to resources and credentials by allowing differing levels of access and control, tracking which keys are compromised during attacks, and controlling the provision and the decommission of the key. The process of managing and securely administering cryptographic keys in a crypto ecosystem is commonly referred to as SSH key management. Companies require SSH key management to oversee the creation, generation, storage, exchange, protection, replacement, and crypto shredding of SSH keys to maintain crypto ecosystem security. SSH key management also includes recording who has access to keys, what context keys are used in, and where these keys are used. SSH key management is a difficult task, but managing the SSH keys is vital for system and company security. SSH keys provide the same access as usernames and passwords and they often grant access to privileged accounts on the operating system level and to resources such as production servers, databases, routers, firewalls, disaster recovery systems, financial data, payment systems, intellectual property, and patient information.\n\n \n\n However, in many cases, SSH key hygiene is completely overlooked in identity and access management planning. For that reason, it is important to start with an SSH key audit. Over the last few years most large organizations such as the banking sector, retailers and healthcare organizations, have amassed large numbers of SSH keys in their environment. This has led to violations of corporate access policies and dangerous backdoors.\n\n \n\n Information security starts from controlling who is given access to systems and data. If there is no control over access, there is no security, no confidentiality, no integrity, and no guarantees of continued operation. Identity and access management is the foundation of information security as it addresses the basic need of any organization to be able to reliably identify users, and to be able to control which users get access to which resources. These two basic controls, identity and access, lay the foundation of security in the corporate environment. It is the basis of information security. A key management system or KMS can really assist in overcoming the risks of poor SSH key management and can help in protecting keys and metadata for the crypto ecosystem. While key management can be performed manually, this will create a lot of concerns and a hassle of workload. This is because manual management of SSH keys is a time-consuming process which is prone to user errors, let alone it is extremely difficult to compile information during mandatory audits.\n\n \n\n A key management system is designed to help manage symmetric and asymmetric encryption keys throughout their lifecycle. A KMS caters to automated distribution and key updates, support for business processes, and easy access to information, making audits and compliance easier. A KMS also helps with the main challenges of SSH key management, including reducing repetitive tasks for personnel, orchestrating key delivery between systems, and setting clear key responsibilities to avoid confusion. A good key management system can help businesses save time and money by streamlining the organization and management of SSH keys. SSH is a secure way to initiate remote computer access and enable terminal sessions. Although SSH can be used with passwords and IDs to log in to the network, it’s more common to use public key authentication because it provides greater security. SSH stands for Secure Socket Shell which means its basic use is to enable secure access to remote servers and devices over an unsecured network. It is highly recommended to use SSH keys. The difference between root SSH and SSH keys is that SSH can support basic password authentication, whereas SSH keys are a more secure authentication process when logging into an SSH server. This is because there is an encrypted connection between the systems which makes the data harder to hack and get access to. Having this extra safety provides confidence in knowing that your systems are safe from even the most aggressive attacks. SSH keys are proven to be a vital resource when it comes to managing systems securely.\n\nThe risk of poorly managed SSH keys in SSH key management Poorly managed access exposes organizations to significant risks that could, in the worst case, bring down critical information systems for months. Unmanaged keys risk systemic failure of critical infrastructure because the likelihood of keys being misused, stolen, or used as part of an attack is high. One single key can be enough to gain undetected root access to critical systems and data. An attacker getting root access means they can do anything on the server, including gaining unauthorized access, “pivoting”, circumventing security controls to inject fraudulent data, subvert encryption software, install persistent malware, or actually destroy the system. Confidentiality, integrity, and continuity of operations are all compromised. This could cause billions of dollars of damage to shareholders. For modern society, a coordinated attack across critical infrastructure with the intention to destroy and confuse is a real possibility and an actual threat to national security. Poorly managed SSH keys can and will lead to access that is in violation of the compliance regimes such as PCI Security Standards, Sarbanes-Oxley, or NIST 800-53, that require controlling who can access what systems and data, segregation of duties, and enforcing boundaries. Private keys and public keys — What are they? When we’re looking at a physical house key, there are certain notches and patterns that link a key and a doorknob together. If you own the home, you want to be 100% certain that only those that you give a house key can have access. SSH keys work very similarly in that they typically come in pairs — a public key and a private key. The public key is linked to a system which then can grant system access to anyone who has a private key that matches the public key. Just like a physical key, there is specific code and encryption on each of the public and private keys. For this type of authentication, you don’t necessarily need password access since it is already a more secure method, though it is recommended for additional security. This process of using SSH keys to share information further ensures that only people with the authority to access the systems are able to. Know the differences between SSH and SSL/TLS For SSL (also known as TLS) machine identities, the essential purpose is to secure connections between a website and a web server. Whereas SSH keys are used to create a secure connection between two individual remote systems over the internet. SSH keys are overall better for this specific purpose due to their ability to be far more functional in that they are both symmetric and asymmetric in their encryption. SSL/TLS keys and certificates are typically used to manage high quantities of customers and data, whereas SSH keys are more specific to individual connections between clients and an organization's system. Best practices for SSH key management: How should organizations manage SSH Keys? It is crucial to manage SSH keys securely and effectively to ensure that they are working in favor of your organization. These keys are the bridge to a corporation's vital digital assets and need to be protected from those who were not given access. In addition to security, properly managed SSH keys are necessary to prevent SSH audit failures. Failing an audit can result in large fines and additional costs to clean up key sprawl. Some main points to consider when managing SSH keys are:\n• It is incredibly difficult to manually manage several hundred or thousand SSH keys alone.\n• Managing SSH keys properly will prevent SSH audit failures by regularly reviewing SSH entitlements, assessing risk, and avoiding compliance violations.\n• Proper management of SSH keys will also monitor policy violations and track when a key was used and by whom. This tracking solidifies that whoever had the authorization to use your systems are actually the people they claim to be.\n• It is also important when organizing SSH keys to rotate them regularly to make them harder to exploit. In other words, you’ll want to replace old keys consistently for added security. In order to address the problem of poor SSH key management, it is advised to map the various best practices to the risks of SSH key management so as to understand which practice addresses each risk. On a high level, the best practice recommendations that pave the way to better security and compliance are the following: The definition of policies should explicitly assign roles and responsibilities to prevent misunderstandings that result in security lapses and to ensure accountability. In addition, we should ensure that organizational policy is comprehensive enough to support SSH. Organizations should perform a periodic review of documented procedures to ensure they are extant and complete, and reflect the environment accurately. Furthermore, they should align policies and procedures to IT controls to support continuous compliance. Finally, organizations should incorporate SSH into risk management processes and should consider conducting a risk assessment of SSH usage throughout the organization. Organizations should create a hardened configuration that reflects the goals of the organization. The hardened configuration should enable SSH server functionality where required, should keep SSH server and client implementations fully up to date, and enforce least privileged access. In addition, the organizations should periodically review the configuration to ensure that SSH client and server software is configured in line with the defined, hardened configuration. Organizations should map all trust relationships and identify and remove any orphaned and duplicate authorized keys. They should ensure passphrase protection, key length, and algorithms. Furthermore, they should assign ownership of all access granting keys, and monitor and analyze key-based access usage. These controls should enforce minimum key length and approved algorithms and should provide for a maximum time a key may be used before replacement. It is essential that identity keys should not be duplicated, and that SSH keys should be changed when a compromise is suspected. Finally, SSH key-based access should be reviewed regularly for appropriateness and should terminate SSH key-based access for decommissioned processes and terminated or transferred users. Most organizations have many years’ accumulation of SSH keys in their environments, managing and controlling access to tasks and processes that aren’t always obvious. That’s why it’s critical to monitor existing keys to establish how often they are used, what systems they connect to and how any copies of the keys are used. Automation is a key factor for proper SSH key management. Organizations should strongly consider using automated tools to technically enforce the desired configuration or to discover and report upon inappropriate configuration (e.g., legacy versions or inappropriate cipher use). The automated tools should include file integrity monitoring tools to validate that administrators are alerted to changes in critical files. In addition, these automated tools should be used during the deployment process to ensure security goals such as the creation of a standard configuration to apply to all automated deployments, the enforcement of configuration standard to deployed services, the restriction of certain SSH services, the set-up of strong protocol versions, the cipher/algorithm configuration, and the establishment of key restrictions and authorizations. Although these practices might seem difficult to implement, the truth is that the initial steps in dealing with these issues are not difficult or costly at all. Initially organizations must find out to what extent their environments are exposed to the risks identified. Skilled personnel with the right tools can accomplish these initial steps within a matter of days. Organizations that acquire and use automated SSH key management products will be able to significantly decrease their risks related to SSH access with a reasonable amount of effort. How Venafi can help with your SSH key management After understanding SSH keys and the importance of managing them properly, what can you do to be proactive about eliminating risk at your company? What if managing SSH keys the right way with no team or no experience is too much to take on? Venafi is a highly reputable organization that specializes in machine identity and SSH key management. Some of the largest companies in the world have benefited from our expert management of machine-to-machine communication. If you have SSH keys that you need assistance managing, we have the SSH key management platform that will help ensure your systems are safe and secure. Want to learn more about how your organization can pass your next SSH audit? Download our solution brief on Preventing SSH Audit Failures."
    },
    {
        "link": "https://cloud.google.com/compute/docs/connect/ssh-best-practices/credentials",
        "document": "This document describes best practices for protecting SSH credentials.\n\nBy default, Compute Engine uses public key-based SSH authentication: Users are authenticated by something they have, which is an SSH private key. If users' private keys aren't properly secured, they might fall into the hands of bad actors who might use these keys to access your VM instances.\n\nThe following sections contains best practices that can help you avoid key leakage and reduce the potential impact of leaked private keys:\n• Use host keys to authenticate the host\n\nThe document focuses on practices that are either specific to Google Cloud or of particular relevance when using SSH on Google Cloud. The document doesn't cover best practices for specific SSH client or server implementations.\n\nSome of your VM instances may have an attached service account. Attaching a service account to a VM lets workloads running on these VMs request short-lived access tokens from the metadata server so that they can access Google Cloud APIs and resources.\n\nWhen you connect to a VM with an attached service account by using SSH, you can also request short-lived access tokens from the metadata server. Granting a user SSH access to a VM is therefore similar to granting the user permission to act as the attached service account. Because of that similarity, treat SSH private keys, especially when they're not passphrase-protected, like service account keys: Both kinds of keys, if leaked, might grant a bad actor access to Google Cloud resources.\n\nDeployment pipelines or automation processes might require SSH access to VM instances to perform deployments or apply configuration changes. Instead of letting these workloads use a long-lived SSH key pair, let them use a new, ephemeral SSH key every time they run.\n\nTo use ephemeral SSH keys, let your deployment pipelines or automation processes perform the following steps:\n• Authenticate as a service account in a way that doesn't involve a key or secret, for example by using an attached service account or workload identity federation.\n• Generate a temporary SSH key pair by using a tool such as .\n• None Publish the public key to Google Cloud, specifying a near-future expiry date (such as 1h in the future). OS Login lets you specify a key expiration date when you publish a key. Similarly, you can specify an expiry date when you publish an SSH public key to project or VM metadata.\n• None Use the private key to establish SSH connections to VM instances.\n• None Optionally, unpublish the public key and delete the private key.\n\nWhile an ephemeral SSH private key might still be leaked, it can only be used for a short time. Using ephemeral SSH keys can therefore reduce your risk of credential leakage, and lets you use Cloud IAM as the primary means of authentication and authorization.\n\nBy default, SSH private keys can be used independently of Google credentials: If a user's private SSH key is leaked, a bad actor can use the key to connect and authenticate to any VM instances that the key is authorized to access. It's not necessary for the bad actor to know the user's username or password, or to even possess any Google credential.\n\nSecurity controls such as two-step verification and limiting the session length for Google Cloud services can be effective ways to reduce the risk of credential theft, but these controls only apply to resources that require Google credentials.\n\nTo ensure that SSH keys can't be used without valid Google credentials, use IAP to govern SSH access and use firewall policies to enforce that all SSH access is performed through IAP.\n\nIAP acts as a reverse proxy and only permits users to establish SSH connections to VM instances if they successfully authenticated using their Google credentials. Additionally, IAP lets you restrict which VMs users can connect to, and enforce context-aware access.\n\nUsing IAP to govern SSH access makes it more difficult for a bad actor to access VM instances using leaked credentials, but doesn't make it impossible: For example, a bad actor might compromise a workstation and find both, a private SSH key and cached gcloud CLI credentials – enough to pass IAP's authentication and authorization checks, and connect to the user's VM instances.\n\nYou can reduce the possible impact of such credential theft attacks by configuring Cloud Identity or Google Workspace to require multi-factor authentication (MFA).\n\nIf you Cloud Identity or Google Workspace is your primary identity provider, do the following enforce MFA:\n• Limit the session length for Google Cloud services so that cached credentials are automatically invalidated and users have to periodically re-authenticate and perform MFA.\n\nIf you use single sign-on with an external IdP, do the following instead:\n• Configure Cloud Identity or Google Workspace to limit the session length for Google Cloud services so that cached credentials are automatically invalidated and users have to periodically re-authenticate using the external IdP.\n• Configure your external IdP to require MFA, and limit its session length so that users have to perform MFA every time their Google Cloud session expires.\n\nTo ensure that MFA also applies to SSH access, you must also do at least one of the following:\n• Use IAP to control network access so that users have to periodically perform MFA to refresh their Google credentials.\n• Enable OS Login 2FA for individual VM instances or entire projects so that users have to perform MFA every time they establish an SSH connection.\n\nUsers that have the Compute Instance Admin or an equivalent role for a VM instance or project can disable OS Login 2FA by modifying instance metadata. The effectiveness of OS Login 2FA is therefore limited if you don't also enforce MFA in Cloud Identity or your external IdP.\n\nMany SSH clients default to storing SSH private keys as files on disk. For example, generates an SSH key pair on first use, and stores it in your home directory. Your operating system might protect your files from being accessed by other users, but if a bad actor can overcome file system permissions (for example, by copying and mounting the disk on another machine), they can copy the key elsewhere, and use it without your knowledge.\n\nSome SSH clients let you avoid using file-based keys and offer alternative options to manage SSH private keys, such as:\n• Using a hardware-backed key: Modern versions of OpenSSH let you use FIDO2 security keys for authentication, and you can configure OS Login so that it only permits security keys that are enrolled in Cloud Identity or Google Workspace. Using hardware-backed keys helps you avoid storing any private key material on your computer's file system.\n• Using your operating system's key storage facilities: For example, IAP Desktop avoids using file-based keys and instead uses Windows CNG to protect your SSH keys.\n\nIf using hardware-backed or operating system-managed keys isn't an option, you can use a passphrase to protect your SSH private key: To use a passphrase-protected SSH key, a bad actor not only needs a copy of the private key, but also needs to know the key's passphrase.\n\nUse host keys to authenticate the host\n\nWhen you create an SSH connection to a VM instance, you identify the VM instance by its name or IP address. Names and IP addresses can be reassigned and reused, and the name that referred to a certain VM instance yesterday might not refer to the same VM instance today. Bad actors might deliberately reassign or reuse names or IP addresses to spoof VM instances and lure users into connecting to a compromised VM.\n\nSSH clients can detect situations where a previously-trusted VM instance was replaced with a different VM instance by using SSH host keys: A VM's SSH host key is generated on first boot and is used to identify the instance. SSH clients typically request and store a VM's host key on the first connection and verify that the VM's host key hasn't changed on subsequent connections.\n\nSSH host keys work based on the trust on first use scheme. The effectiveness of SSH host keys can be undermined if a bad actor uses a man in the middle (MITM) attack to let a client connect to and trust the wrong VM on first use. A better way to obtain a host key is to obtain it over a trusted side channel before connecting to a VM for the first time.\n\nYou can let the gcloud CLI obtain host keys over a back channel by enabling guest attributes in your project. The gcloud CLI then reads a VM's host key before you first connect to it, and saves them on your local computer.\n\nWhen you authorize the gcloud CLI, the tool obtains an OAuth refresh token and stores it in your local home directory. When you subsequently run a gcloud CLI command, the gcloud CLI uses the refresh token to authenticate you automatically.\n\nYour local computer might be inaccessible to other users, but on a VM instance, your home directory can also be accessed by other users that have sudo privileges on the VM.\n\nIf a bad actor manages to obtain sudo privileges on a VM, they might scan for refresh tokens and other credentials in other users' home directories, and use these credentials to escalate their privileges or extend their access to other resources (lateral movement).\n\nWhen you're connected to a VM instance over SSH, avoid authorizing the gcloud CLI or Application Default Credentials (ADC) with your personal credentials, and let the gcloud CLI use the VM's attached service account instead. Similarly, avoid running other tools that might store personal credentials in your home directory.\n\nYou can further reduce risks by limiting the session length for Google Cloud services so that stored OAuth refresh tokens automatically expire after a certain amount of time.\n\nSome automation tools like Ansible use SSH to access and manage VM instances. Because such tools might have access to many VM instances (and their attached service accounts), the SSH private keys used by such tools can be particularly sensitive.\n\nIf you submit an SSH private key to a source code repository, there is an increased risk that the key becomes accessible to unauthorized users and bad actors:\n• Bad actors might scan the source code of public source repositories for leaked keys.\n• In the future, you might decide to turn a private source repository into a public repository, without checking it for keys first.\n• Other team members might store copies of the source code on their workstation.\n\nTo mitigate these risks, store the SSH private key in a secure location that's separate from the source code and use ephemeral SSH keys when possible.\n• Continue reading about best practices for auditing SSH access"
    }
]