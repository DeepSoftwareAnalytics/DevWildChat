[
    {
        "link": "https://cmaher.github.io/posts/working-with-simplex-noise",
        "document": "Recently, I’ve been getting into procedural content generation (PCG), with the end-goal of procedurally generating entire worlds. When you consider the fact that my artistic abilities are incredibly lacking, it only makes sense that I would consider having algorithms make things for me. Add in the coolness (read: geek) factor, and it’s a wonder that I actually managed to get my other work done before plunging head-first into some PCG experimentation.\n\nBeing new to the world of PCG, I decided to do some research. The first thing I learned was that I would need a decent noise implementation to generate random values. Ken Perlin seems to be the name in noise functions. He made his original algorithm for Perlin noise while working on the original Tron, and he released an improved noise function, simplex noise, back in 2001. These noise functions produce pseudo-random smooth gradients. This noise results in a very natural appearance, so you might have come across it if you’ve done work with terrain heightmaps or particle effects.\n\nFor my project, I decided to use simplex noise, since it’s less computationally expensive and gives better results. I’m not going to go into the details of the algorithm– an excellent paper by Stefan Gustavson already does the job far better than I ever could. But for a high-level overview, it’s enough to know that the algorithm uses something known as a simplex grid to add nearby values and produce numbers between -1 and 1 that look linearly-interpolated like classic Perlin noise.\n\nSimplex noise is a complicated beast. It’s a straight-up math algorithm involving simplices and is designed to be implemented in hardware. To make matters worse, Ken Perlin’s sample implementation (appendix B) is near-indecipherable for the common mind. Thankfully, Gustavson comes to the rescue again by providing implementations in C and C++, as well as in Java, Lua, and GLSL. The implementations provide noise values for up to four dimensions (generally used as three dimensions + time).\n\nWith all of the hard work done for us, we really just need to figure out how to use the provided simplex noise functionality. The various implementations provide a noise function that takes a coordinate and returns a floating-point noise value between -1 and 1, inclusive, where coordinates that are close to each other have similar values. To make a general-purpose heightmap, we need to fill an MxN matrix with luminosity (light) values, between 0 and 255. Let’s normalize the simplex noise to our light range and populate our array:\n\nThat’s all we need, right? Well, it turns out that this produces an image that doesn’t look much better than white noise (that awful static you get on you TV when it doesn’t get a proper signal). How can we smooth this out? First recall that the term “noise” is related to sound, and sound is just a wave. So to simplify matters, we can think of our noise as a wave. Our current noise changes quickly from one value to another. In wave terms, this means that our noise has a very high frequency. What we want is noise with a low-frequency, so that values change gradually.\n\nFrom physics, we know that, for a wave, \\(\\textrm{frequency} = \\frac{\\textrm{velocity}}{\\textrm{wavelength}}\\). We don’t have a convenient method of changing the wave length, so this means that we have to change our noise’s velocity. But what is the current velocity of our noise? Recall that \\(\\textrm{velocity} = \\frac{\\textrm{distance}}{\\textrm{time}}\\). In the sample code, i and j (the distance) are increased by one in each (time) step, so the velocity is one. In order to decrease our frequency, we need to decrease our velocity, and to do that, we need to scale the values that we send to our noise function by some small value:\n\nIt turns out that we need to use a very small scale in order to produce good smooth noise like the type shown above. I use .007, because I like to imagine a very small James Bond making things smooth and suave, but other values around .01 work well for my project. You’ll have to experiment with the scale to see what suits your purposes best.\n\nSo now we have the smooth noise shown above, but it still seems kind of boring and unsatisfying. Instead of purely smooth noise we want something a bit more chaotic and organic. To get this, we’re going to need to use another technique: fractal Brownian motion. This method works by using our noise function for multiple iterations, decreasing the amplitude and increasing the frequency in each successive iteration. It then sums all these iterations together and takes the average. From there, we can normalize the value and add the result to our array.\n\nThis finally gets us the results we want. In the above code, each iteration is called an octave, because it is twice the frequency of the iteration before it, just like musical notes double in frequency as you go up an octave. The amplitude is the relative importance of the octave in the sum of the octaves, and persistence is is the scale factor in each iteration. We want the amplitude to decrease, so our persistence is less than 1. Additionally, the above method allows us to scale our noise from low to high instead of just 0 to 255.\n\nSo we have some good-looking noise that we can apply to textures or make a heightmap, etc. But using fractal Brownian motion isn’t the only way to get cool results out of noise. By using different techniques, you can use basic simplex noise to procedurally generate textures that look remarkably like dust, fire, marble, or even wood. You can try to figure these out on your own, or look around on the internet (note: techniques for using Perlin noise will pretty much get the same results with simplex noise). If you want to learn more, the links throughout the article, and below should help you.\n\nIt turns out that Simplex Noise is patented. OpenSimplexNoise is a free alternative.\n\nC and C++ implementations\n\nThe more technical paper by Ken Perlin"
    },
    {
        "link": "https://reddit.com/r/proceduralgeneration/comments/bz4pt8/can_someone_run_me_through_the_basics_of_using",
        "document": "Hi! Some of you may have seen my WIP terrain generator, and I have come to realize I need to switch how I’m doing it. I’ve read up on Perlin and Simplex noise, but it just isn’t clicking. Conceptually I understand it, but the implementation is making my head hurt. Could someone explain to me the basics on how to make and implement my own algorithm in Java?"
    },
    {
        "link": "https://gpfault.net/posts/perlin-noise.txt.html",
        "document": "Using Perlin Noise to Generate 2D Terrain and Water\n\nThis post is going to be the Perlin noise tutorial that I've always wanted to see. By the end of it, we'll procedurally generate 2D terrain and water with GLSL.\n\nPerlin noise was invented in the eighties and has since been used countless times to generate natural-looking visual effects in films and games.\n\nIf you google \"perlin noise\", you will get a trove of articles and code. However, in my opinion, a beginner will have a hard time figuring out how it really works. I think that a lot of articles on the subject don't provide enough context, jump into too much detail too quickly and use scary terminology like \"surflets\". I've even stumbled upon some articles presenting blurred white noise as perlin noise, which is not the case!\n\nAnd that's why I decided to try and write a more beginner-friendly article on the subject, that starts from a simple and easy to understand case, and builds up towards a more advanced one. Hopefully, people who read this tutorial won't have to struggle any more!\n\nBefore we go any further, I want to make sure a simple, but very important point is understood: noise is a mathematical function, just like the sine or the exponent. The gray, amorphous, lumpy fog that you see in most pictures is just one of the possible graphical representations of said function. The reason I want to make this explicit is that some people may think about calculating noise in terms of pixels being affected by neighbor pixels, which really isn't the correct way to think about Perlin noise.\n\nMost of us are familiar with mathematical functions of a single variable (again, sine for example), but functions can depend on multiple variables. It's fairly easy to visually represent a function of two variables. For a function of three variables, you can imagine the time, t, as the third variable, and the graphical representation would be animated: the values of the function along the z at each point (x, y) would change with the passage of time.\n\nNow, if you image-search for perlin noise, what you'll usually see is the graphical representation of a two-dimensional function, where lighter pixels correspond to higher values at particular x and y coordinates. But the thing is, perlin noise doesn't have to be two-dimensional. The concept can be extended to any number of dimensions. But more importantly for us, it can be reduced to just a single dimension! And, for us mere mortals, it's much easier to understand how the one-dimensional case works. Armed with that knowledge, we'll be ready to tackle the more complex cases. That is the approach that this post is going to take.\n\nRegardless of dimensionality, the noise function must be continuous, smooth and random-looking. Of course, there are strict mathematical definitions for what things like \"continuous\" and \"smooth\" mean, but you needn't worry about that right now - just go with your intuitive understanding.\n\nIn the one-dimensional case, the graph of a function possessing the above-mentioned properties will look like a neat squiggly line. Our first goal will be to construct such a function.\n\nIt should be noted that there are multiple methods to construct a function fitting these criteria, Perlin's technique is just one of them.\n\nConstructing the Noise Function of One Variable\n\nAs promised, we're going to consider the single-variable case first. Thus, our noise function n is defined in the domain of real numbers, R.\n\nNow, let's imagine that for each integer, a value of either 1 or -1 is chosen randomly. For a given integer i, we're going to denote the corresponding randomly chosen value as g(i). We'll call these values gradients.\n\nThe noise function is defined as follows:\n• p = floor(p) (largest integer smaller than or equal to p)\n• g(p ) and g(p ) are the gradients at p and p respectively\n• F(t) = t3(t(t-15)+10), a fade function, the purpose of which will be explained a bit later\n\nAs you can see, it's just interpolating between two values, g(p )(p-p ) and g(p )(p-p ), with the interpolation parameter given by applying the fade function to p-p . The noise function turns out to have a number of interesting properties (the rigorous proof of which isn't within the scope of the article):\n• The values of this function at integer points are zero (this property is actually easy to see)\n• The value of the function will decrease as its argument approaches an integer for which -1 was randomly chosen as the gradient value.\n• Conversely, the value of the function will increase as its argument approaches an integer for which 1 was chosen as the gradient value.\n• The function is continuous and smooth\n\nExplained in a handwavy kind of way, the technique boils down to randomly specifying the desired kind of growth (positive or negative) in the neighborhood of each integer point of the function's domain and then fitting a nice smooth curve that satisfies the growth requirements, with the caveat that the function's values must be 0 at integer points.\n\nOf course, showing is better than telling, so I suggest you play with the following interactive demo to get an intuitive sense of how the function works (javascript must be enabled):\n\nI still owe you an explanation for that \"fade function\" polynomial. I won't go too deep into it for the sake of brevity, but I'll try to give you an idea.\n\nFirst, try unchecking the \"apply fade function\" checkbox in the demo and observe the results. Doesn't look very smooth, does it? Look at these sharp corners!\n\nWithout the fade function, our noise becomes constant 0 between integer points with the same gradient values. On the surface, it's easy to see why: if you just plug in the same gradient values for p and p into the expression for noise without the fade function, it'll be zero. But there's a bit more to it than that, and we'll need just a bit of calculus to explain it.\n\nBefore we proceed with the explanation, we need to strictly define what it means for a function to be \"smooth\". A function is called Ci-smooth if it has continuous derivatives of up to i-th order (in case your calculus is rusty, or these words don't sound familiar at all, I suggest consulting your favorite calculus textbook or Wikipedia).\n\nNow, if you don't apply the fade function to the interpolation parameter and instead use p-p directly, the resulting function will not be smooth enough. You can try doing it yourself: replace F(p-p ) with just p-p in the noise function definition, simplify the expression and try working out the derivative. The equation for the derivative between p and p is going to look like (some constant value)*p + (some other constant value), in other words it'll be a straight line. The constants depend on p and p , so the derivative for the overall noise function will look like a bunch of various straight lines. We don't even have a continuous first-order derivative, so our function isn't smooth at all!\n\nBasically, applying the fade gives our noise function continuous higher-order derivatives which makes it look nice and smooth. Instead of varying the interpolation parameter from 0 to 1 linearly, the fade function varies it along an s-shaped curve.\n\nAssigning a Random Value to Each Integer\n\nBefore we move on to the implementation, something needs to be mentioned about how we're going to randomly pick gradient values for each integer point of the noise function's domain. The way it's done in the \"classic\" implementation (and the way you'll most likely encounter in other Perlin noise write-ups) goes something like this:\n• An array P of integers from 0 to 256 is permutated at random. Of course, this isn't done at runtime; usually the random permutation is simply hardcoded. Also, it is repeated 2 times in a row, so that Perlin ends up containing 512 elements (this is needed to simplify the next step).\n• A value is looked up from P based on the point the gradient of which we're trying to determinine (i.e. for single-dimensional case it will be P[x & 0xff], for 2-dimensional it will be P[P[P[x & 0xff] + (y & 0xff)] ], etc.)\n• The value from the previous lookup is used to look up into an array of uniformly distributed gradient values\n\nI don't want you to dwell on this too much though, because it is an implementation detail that is not critical to understanding how the overall technique works. Different methods can be used for this. For example, if you're trying to implement Perlin noise in a shader using WebGL, you cannot use the described method because WebGL shaders can't use variable indices with arrays. Instead, you can read the values from a texture filled with random RGB values, and it'll pretty much work the same.\n\nNow we've got everything ready to implement one-dimensional perlin noise. I'm going to use GLSL for this, because then I can paste the code into Shadertoy which is very handy for online demos like this. The code should be portable to other languages with minimal changes though.\n\nThe function is straightforward, so I'm not going to explain it.\n\nNow comes the function. It returns a gradient value for a given integer p. We're using WebGL and can't do variable indexes into arrays, so we're going to sample from a random RGB texture and return 1 if the red channel is > 0.5, and -1 otherwise.\n• The texture needs to be repeated (i.e. both and options need to be set to ) so that values that are greater than the pixel size of the texture (or even negative values) can be used with .\n• The texture needs to use nearest-neighbor filtering.\n\nFinally, let's take a closer look at the main function of the shader where we actually use the noise function.\n\nMaking the Noise Look More Interesting\n\nAt this point, we've covered the core of what makes Perlin noise work. Now is the time to apply it to make something interesting-looking. The trick is to sample the noise function multiple times, with different frequencies and amplitudes, and add the results up. That is called \"fractal noise\".\n\nThe bulk of the shader stays the same, the only part that changes is the main function:\n\nBy manipulating frequencies and amplitudes, you can control how the result looks: lower frequencies give you gently sloped hills, while higher frequencies with higher amplitudes give you more jagged, spiky look. Play with the demo yourself:\n\nUsing the stuff covered that we covered so far, it's easy to put together a simple demo that endlessly flies you past a 2d mountain range! The demo below uses the time counter (shadertoy-specific) for scrolling, and it uses different factors for it on the foreground and background mountains to achieve a nice parallax effect.\n\nJump to the Second Dimension\n\nHopefully by now you have a solid understanding of the the one-dimensional case. You should be well-equipped then to deal with the two-dimensional case.\n\nAt this point I should explain why we call those random values corresponding to integer points \"gradients\". In mathematics, the term gradient is used to refer to the direction in which a function experiences the fastest growth at a given point. In other words, \"gradient at a given point p\" answers the question: \"from a given point p, which direction should the argument go in order for the function to grow the most?\". In case of single-variable functions, the argument can either go forwards (corresponding to gradient value of 1) or backwards (corresponding to gradient value -1). In the case of two-dimensional functions, the gradient has to be a unit 2d vector, because the argument can change in any direction on the XY plane.\n\nSo the first thing we should do is modify our function to give us a random two-dimensional unit vector:\n\nThe function requires a little more changes. But first, let's recap what we did to calculate noise at point p in the 1D case:\n• We determined the integers p and p surrounding the point p\n• For both p and p , we calculated the product between the gradient at that point, and the difference between p and that point.\n• Finally, we did an interpolation between the values calculated in the previous step\n• Determine the four integer points on the plane p , p , p and p surrounding the point p (\"lattice points\")\n• For each of those four lattice points, calculate the dot product between the gradient at the lattice point and the direction from the lattice point to the point p\n• Do something similar to bilinear interpolation: interpolate between the dot products corresponding to the top two lattice points, then interpolate between the dot products corresponding to the two bottom lattice points. Finally, interpolate between the results of the previous two interpolations.\n\nSo, overall, the idea is pretty much the same as in the 1D case, it's just that scalar values have become 2D vectors!\n\nHere is the code:\n\nIf you render 2D noise in the exact same way we did with the 1D noise in the mountains example, but vary the y coordinate with time, you can get a neat effect, resembling rising and falling waves in a body of water. If you also vary the x coordinate with time, you'll get the appearance of rolling waves. You can enhance the effect even further, if you advance the x coordinate for larger, low frequency waves at a slower rate than for smaller, high frequency waves. Check out the demo below:\n\nAt this point, you should be able to figure out how to extend the noise function to 3 variables yourself. The only difference now is that the interpolation becomes more involved: the lattice is now three-dimensional, so there are now 8 integer points surrounding the point p. You do the same interpolation as in the 2D case twice: once for the top 4 vertices, once for the bottom 4 vertices, and finally you interpolate between those two results.\n\nHere is the modified version of the function.\n\nSimilarly to what we did in the 2D case, we can move a 2D slice through the 3D noise by varying the third argument with the time counter and get an animated image. With some coloring we can get an effect reselmbling lava or maybe the surface of a glowing star. Demo:\n\nNow you too can use perlin noise for your game, demo or whatever it is you're making! The code should be fairly easy to adapt to your language of choice. If you have questions or found something incorrect, let me know in the comments.\n\nLike this post? Follow me on bluesky for more!"
    },
    {
        "link": "https://stackoverflow.com/questions/15628039/simplex-noise-shader",
        "document": "If your application is not using the noise mesh and textures dynamically then you should keep the offline creation that you currently use for your mesh. If however you would like to have your mesh and textures dynamically change over time (think deformable terrain) then it would be necessary to change it to a shader implementation if a high fps is important to you. It can be done, however im not sure of your level of ability to claim it to be easy. It would involve the use of geometry shaders (and maybe stream-out) for the case of your terrain mesh, and pixel shaders to create your textures.\n\nAs for using 2d or 3d noise for textures, it depends on your usage needs. 3d textures are good for representing things like force fields, voxel fields etc. They are however expensive create dynamically. If you just want to use the texture as a regular mesh material then 2d is the way to go."
    },
    {
        "link": "https://redblobgames.com/maps/terrain-from-noise",
        "document": "A common way to generate 2D maps is to use a bandwidth-limited noise function, such as Simplex or Perlin noise, as a building block. This is what the noise function looks like: We assign each location on the map a number from 0.0 to 1.0. In this image, 0.0 is black and 1.0 is white. Here’s how to set the color at each grid location in C-like syntax: The loop will work the same in Javascript, Python, Haxe, C++, C#, Java, and most other popular languages, so I’ll show it in C-like syntax and you can convert it to the language you’re using. In the rest of the tutorial, I’ll show how the loop body (the line) changes as we add more features. At the end, I’ll show a complete example. Depending on the library you use, you may have to shift or multiply the values you get back to fit into the 0.0 to 1.0 range. Some libraries return 0.0 to 1.0; some return -1.0 to +1.0; some return other ranges like -0.7 to +0.7. Some don’t say what they return, so you may have to look at the return values to figure out the range.\n\nNoise by itself is just a bunch of numbers. We need to assign meaning to it. The first thing we might think of is to make the noise correspond to elevation (also called a “height map”). Let’s take the noise from earlier and draw it as elevation: The code is almost the same, except for what’s inside the inner loop; it now looks like this: Yes, that’s it. The map data is the same, but now I call it instead of . Lots of hills, but not much else. What’s wrong? Noise can be generated at any frequency. I’ve only picked one frequency so far. Let’s look at the effect of frequency. Try moving the slider to see what happens at different frequencies: It’s just zooming in and out. That doesn’t seem very useful at first glance, but it is. It’s sometimes useful to think of wavelength, which is the inverse of frequency. Frequency is measured in oscillations per distance. Doubling the frequency makes everything half the size. Wavelength is measured in distance per oscillation, measured in pixels or tiles or meters etc. Doubling the wavelength makes everything twice the size. Wavelength is related to frequency: . I have another tutorial that explains the concepts: frequency, wavelength, amplitude, octaves, pink and blue and white noise, etc. To make the height map more interesting we’re going add noise at different frequencies: Let’s mix big low frequency hills and small high frequency hills into the same map. Move the slider to add smaller hills to the mix: Now that looks a lot more like the fractal terrain we want! We can now get hills and rugged mountains, but we still don’t get flat valleys. We need something else for that. There’s a potential problem though. Since can go from 0 to 1, the sum can go from 0 to 1.75. The numbers are called the amplitudes. The simplest thing to do is to divide by the sum of amplitudes: In practice, you may want to experiment to find the best divisor. Although the sum of amplitudes guarantees the elevation stays in the range 0–1, the elevation values may not be distributed the way you want. Amplitudes are commonly set to be an array , where each amplitude is ½ the previous one. This ratio is called gain or persistence. However we’re not limited to using a fixed ratio. I use amplitudes for many examples on this page to bring out more fine detail than the conventional amplitudes would do. Amplitudes can also be calculated dynamically, either from previous noise values (e.g. octave 1’s noise can affect octave 2’s amplitude), or by using an independent noise field, or by using player/simulation data. Another possible issue: by using and and , what happens when nx and ny are near 0? These noise values are correlated. To get the best results we want these to be independent. If your noise library allows seeding, you can use separate seeds for each of the octaves. If it does not allow seeding, you can add an offset to each of the octaves, such as and and . That way each octave is sampling from different parts of the noise space and they will be independent instead of correlated. And yet another possible issue: these noise values may be aligned along the same directions, which can sometimes cause visible artifacts, especially when using Perlin noise. To reduce this, rotate the output of some of the octaves, or switch to Simplex noise. The noise function gives us values between 0 and 1. To make flat valleys, we can raise the elevation to a power. Move the slider to try different exponents. Higher values push middle elevations down into valleys and lower values pull middle elevations up towards mountain peaks. We want to push them down. In practice it may work better to use , where the fudge factor is some number near 1. For the above demo I used 1.2. Try different values and see what works best for you. The pow() function is only one way to reshape the elevations. There are many other functions you can try. You aren’t limited to mathematical functions; consider drawing curves yourself, like the “curves” tool in a photo editor. Now that we have a reasonable elevation map, let’s add some biomes!\n\nNoise gives us numbers but we want a map with forests, deserts, and oceans. The first thing to do is to make low elevations into water: function biome(e) { // a threshold between 0.2 and 0.5 work well in the demo // but each generator will need its own parameter tuning if (e < ) return WATER; else return LAND; } Hey, that’s starting to look like a procedurally generated world! We have water, grass, and snow. What if we want more things? Let’s make the sequence water, beach, grassland, forest, savannah, desert, snow: function biome(e) { // these thresholds will need tuning to match your generator if (e < 0.1) return WATER; else if (e < 0.2) return BEACH; else if (e < 0.3) return FOREST; else if (e < 0.5) return JUNGLE; else if (e < 0.7) return SAVANNAH; else if (e < 0.9) return DESERT; else return SNOW; } Hey, looks cool! You’ll want to change the numbers and biomes for your game. Crysis will have more jungles; Skyrim will have more ice and snow. But no matter what you change the numbers to, this approach is a bit limited. The terrain types line up with the elevations, so they form bands. To make it more interesting, we need to choose biomes with something other than elevation. Let’s create a second noise map for “moisture”: Elevation noise on left; moisture noise on right Now let’s use both elevation and moisture. In the diagram on the left below, the y-axis is the elevation (first diagram above) and the x-axis is the moisture (second diagram above). It produces a reasonable looking map: Low elevations are oceans and beaches. High elevations are rocky or snowy. In between we get a wide range of biomes. The code looks like this: function biome(e, m) { // these thresholds will need tuning to match your generator if (e < 0.1) return OCEAN; if (e < 0.12) return BEACH; if (e > 0.8) { if (m < 0.1) return SCORCHED; if (m < 0.2) return BARE; if (m < 0.5) return TUNDRA; return SNOW; } if (e > 0.6) { if (m < 0.33) return TEMPERATE_DESERT; if (m < 0.66) return SHRUBLAND; return TAIGA; } if (e > 0.3) { if (m < 0.16) return TEMPERATE_DESERT; if (m < 0.50) return GRASSLAND; if (m < 0.83) return TEMPERATE_DECIDUOUS_FOREST; return TEMPERATE_RAIN_FOREST; } if (m < 0.16) return SUBTROPICAL_DESERT; if (m < 0.33) return GRASSLAND; if (m < 0.66) return TROPICAL_SEASONAL_FOREST; return TROPICAL_RAIN_FOREST; } These are example threshold numbers. In every project I’ve worked on I’ve had to change them, not only for predominant biomes (Dagobah will have more swamp, Hoth will have more tundra, Tatooine will have more desert) but also because it depends on the noise library being used and how the octaves are mixed together. Plan to tweak these numbers! Alternatively if you don’t need biomes, smooth gradients (see cartographer Tom Patterson’s article[2]) can produce colors: With either biomes or gradients, one noise value doesn’t produce enough diversity, but two is pretty good. Two is what ecologist Robert Whittaker[3] used when he was studying biomes.\n\nFor some projects I want the boundaries of the map to be water. One way to do this is to generate a map as above and then reshape it. Looking from the side, what is stopping the map from being an island? The border areas that are on land need to be pushed down into water, and the center areas that are in water need to be pushed up to become land. Need this below water Need this above water Need this below water How does this work? There are two ingredients:\n• A distance function assigns a distance to every position on the map, from 0 at the center to 1 at the border.\n• A shaping function (as used in the Redistribution section) takes an elevation as input and chooses a new output elevation. At the center of the map (distance 0), we’ll use a shaping function that always outputs land. At the border of the map (distance 1), we’ll use a shaping function that always outputs water. In between, we’ll allow both land and water. For simplicity, I’ll assume the water level is 0.5, so ≥0.5 means land and <0.5 means water. To calculate the distance , set and . These will range from -1 to +1. Then choose one of these distance functions recommended by /u/KdotJPG[4]: , when you have a square map and want to make the island fill as much of the space possible without reaching the borders. , when you want the island to be round, and plan to embed it in a larger world. The simplest way to shape the elevation is to linearly mix in . At the center of the map, is 0, and we want the elevation to be high (1). At the edges of the map, is 1, and we want the elevation to be low (0). Linear interpolation can do this: , for some value of between 0 and 1. Move the slider to 0 to see the original map and move it to 1 to see the constraining shape. There are many more things to try. Try shifting the distance function up or down by adding a constant, or slope it more or less by multiplying by a constant, or change the exponent from 2 to 4 or 6. Try applying the elevation reshaping to only the lower frequency octaves of the noise generator, and allow the high frequencies to work equally across the map. Try choosing the amount of land area you want, and then push all elevations up or down until you get the desired island size. Try using noise to create the island shape but use some other approach to assign the elevation. Try using a lookup table to allow arbitrary (piecewise linear) reshaping or distance functions. It will take some experimentation to find a combination you like. Try non-linear shaping functions to mix and .\n\nWe usually use fractal noise for elevation and moisture, but it can also be used for placing irregularly spaced objects like trees and rocks. For elevation we have higher amplitudes with lower frequencies (“red noise”). For object placement we want to use higher amplitudes with higher frequencies (“blue noise”). On the left is a blue noise pattern; on the right are the locations where the noise is greater than the nearby values: for (int y = 0; y < height; y++) { for (int x = 0; x < width; x++) { double nx = x/width - 0.5, ny = y/height - 0.5; // blue noise is high frequency; try varying this bluenoise[y][x] = noise(50 * nx, 50 * ny); } } for (int yc = 0; yc < height; yc++) { for (int xc = 0; xc < width; xc++) { double max = 0; // there are more efficient algorithms than this for (int dy = -R; dy <= R; dy++) { for (int dx = -R; dx <= R; dx++) { int xn = dx + xc, yn = dy + yc; // optionally check that (dx*dx + dy*dy <= R * (R + 1)) if (0 <= yn && yn < height && 0 <= xn && xn < width) { double e = bluenoise[yn][xn]; if (e > max) { max = e; } } } } if (bluenoise[yc][xc] == max) { // place tree at xc,yc } } } KDotJPG recommends checking to change the square overlap check to a circular overlap check, and also to allow non-integer radius values. Also consider that the radius doesn’t have to be a constant. By choosing a different R for each biome we can get a variable density of trees: Although it’s cool that Simplex/Perlin noise can be used to place trees, other algorithms are more efficient and produce a better distribution of trees. For trees and other object placement, I recommend using Poisson Disc[6] or a jittered grid instead of high frequency Simplex/Perlin noise as shown here. For Javascript, I use poisson-disk-sampling[7], fast-2d-poisson-disk-sampling[8], or jittered-hexagonal-grid-sampling[9]. Wang tiles and graphics dithering algorithms are also worth a look.\n\nSometimes we want the east edge of the map to match up with the west edge. This corresponds to a cylinder in 3D space. We can implement this with a minor change. We’ll interpret the x value on the flat map as an angle in the cylinder world. Then we convert the angle to cartesian coordinates. To also make the north and south edges match up, we can apply the same pattern again to turn the y value into an angle, and look things up in a 4D noise space. Let’s see how the maps look adjacent to copies of themselves: The first one wraps east-west but not north-south. The second one wraps in all four directions. Here’s some code: const TAU = 2 * M_PI; function cylindernoise(double nx, double ny) { double angle_x = TAU * nx; /* In \"noise parameter space\", we need nx and ny to travel the same distance. The circle created from nx needs to have circumference=1 to match the length=1 line created from ny, which means the circle's radius is 1/2π, or 1/tau */ return noise3D(cos(angle_x) / TAU, sin(angle_x) / TAU, ny); } function torusnoise(double nx, double ny) { double angle_x = TAU * nx, angle_y = TAU * ny; return noise4D(cos(angle_x) / TAU, sin(angle_x) / TAU, cos(angle_y) / TAU, sin(angle_y) / TAU); } In practice, you will probably have to scale these noise values up. Higher dimensional noise tends to have a narrower range of values than lower dimensional noise, so if your biome constants are tuned for 2D noise, then you can try multiplying noise3D by √1.5, and noise4D by √2, but you may have to tweak these values further to match your needs. See Rudi Chen’s article on Perlin Noise range[10]. For more on tileable noise, see Ron Valstar’s guide[11]. Another thing that may affect the quality is that the octaves may “bleed” into each other’s frequency ranges, according to the paper Wavelet Noise[12] by Cook and DeRose: When rendering, it is common to texture 2D surfaces by sampling a 3D noise function, but the resulting 2D texture will in general not be band-limited, even if the 3D function is perfectly band-limited.\n\nUsing noise for generating terrain is a popular technique, and you can find tutorials for many different languages and platforms. The map generation code is pretty similar across languages. Here’s the simplest loop, in three different languages:\n• Javascript: import { createNoise2D } from 'simplex-noise'; let gen = createNoise2D(); function noise(nx, ny) { // Rescale from -1.0:+1.0 to 0.0:1.0 return gen(nx, ny) / 2 + 0.5; } let value = []; for (let y = 0; y < height; y++) { value[y] = []; for (let x = 0; x < width; x++) { let nx = x/width - 0.5, ny = y/height - 0.5; value[y][x] = noise(nx, ny); } }\n• C++: module::Perlin gen; // if using libnoise double noise(double nx, double ny) { // if using libnoise // Rescale from -1.0:+1.0 to 0.0:1.0 return gen.GetValue(nx, ny, 0) / 2.0 + 0.5; } FastNoiseLite gen; // if using fastnoiselite double noise(double nx, double ny) { // if using fastnoiselite // Rescale from -1.0:+1.0 to 0.0:1.0 return gen.GetNoise(nx, ny) / 2.0 + 0.5; } double value[height][width]; for (int y = 0; y < height; y++) { for (int x = 0; x < width; x++) { double nx = x/width - 0.5, ny = y/height - 0.5; value[y][x] = noise(nx, ny); } }\n• Python: from opensimplex import OpenSimplex gen = OpenSimplex() def noise(nx, ny): # Rescale from -1.0:+1.0 to 0.0:1.0 return gen.noise2d(nx, ny) / 2.0 + 0.5 value = [] for y in range(height): value.append([0] * width) for x in range(width): nx = x/width - 0.5 ny = y/height - 0.5 value[y][x] = noise(nx, ny) Once you have a noise library, the code is similar. Beward: some libraries combine multiple octaves automatically, which is convenient but makes it hard to mix them in your own way.\n• C++: SimplexNoise[14] or FastNoiseLite[15] or libnoise[16] There are lots of noise libraries for most popular languages. Alternatively, you may want to spend time studying how Simplex/Perlin/OpenSimplex noise works, or implementing it yourself. I didn’t. I used the existing libraries. Once you have found a noise library for your favorite language, the details will vary (some will return numbers from 0.0 to 1.0 and others from -1.0 to +1.0) but the basic idea is the same. For a real project you may want to wrap the function and the object into a class but those details aren’t relevant here so I made them global. For this simple project it doesn’t matter that much whether you use Simplex noise, OpenSimplex noise, Perlin noise, value noise, midpoint displacement, diamond square[21] displacement, or an inverse Fourier transform. There are pros and cons of each of these but they all produce similar enough output for this type of map generator. The drawing of the map is going to be platform-specific and game-specific so I’m not providing that; this code is to generate the elevations and biomes, which you’ll want to draw yourself in whatever style your game uses. Feel free to copy, port, and use it for your own projects.\n\nThere are lots of cool things you can do with noise functions. If you search the web you’ll see variants such as turbulence, billow, ridged multifractal, amplitude damping, terraced, voronoi noise, analytical derivatives, domain warping, and others. Take a look at this page[34] for inspiration. I’m not covering them here; instead I’m focused on simplicity for this article. My previous map generation projects that influenced this one:\n• I used generic Perlin noise for my first Realm of the Mad God map generator[35]. We used that for the first six months of alpha testing, and then replaced it with a custom-designed Voronoi polygon map generator[36] based on the gameplay needs we identified during the alpha testing. The biomes in this article and their colors come from those projects.\n• While studying signal processing for audio, I wrote a tutorial on noise that covers concepts like frequency, amplitude, octaves, and “colors” of noise. The same concepts that work for audio also apply to noise-based map generation. I made some unpolished terrain generation demos at the time but never finished them.\n• Sometimes I experiment to find limits. I wanted to see how little code I could get away with while still producing reasonable maps. In this mini-project I got down to zero lines of code— it’s all image filters (turbulence, threshold, color gradients). I was both pleased and disturbed by this. How much of map generation can be done with image filters? Quite a lot. Everything in the “smooth gradient color scheme” I described earlier came from this experiment. The noise layer is a turbulence image filter; the octaves are images layered on top of each other; the exponent is called the “curves adjustment” tool in Photoshop. It bothers me somewhat that most of the code we game developers write for noise-based terrain generation (including midpoint displacement) turns out to be the same as audio and image filters. On the other hand, it produces decent results with very little code, so that’s why I wrote the article you’re reading. It’s a quick & easy starting point. I usually don’t use these types of maps for long; I’ll replace them with a custom map generator once more of the game is built and I have a better sense of what types of maps best match that game’s design. That’s a common pattern for me: start with something extremely simple, then replace it only after I better understand the system I’m working on. There are a lot of cool things you can do with noise, and I’ve barely explored them here. Try out the Noise Studio[37] to interactively explore lots of possibilities. Also:\n• Building Worlds Using Maths[39] - Sean Murray of No Man’s Sky; skip to 20 minutes in."
    },
    {
        "link": "https://thebookofshaders.com/glossary?search=mix",
        "document": "Constrain a value to lie between two further values\n\nSpecify the start of the range in which to interpolate.\n\nSpecify the end of the range in which to interpolate.\n\nSpecify the value to use to interpolate between x and y.\n\nperforms a linear interpolation between and using to weight between them. The return value is computed as ."
    },
    {
        "link": "https://stackoverflow.com/questions/24063247/color-interpolation-in-glsl-fragment-shader",
        "document": "I need to map a scalar value to color that ranges 0 to 1. It will go from GREEN to RED (from 0 to 1) Linear Interpolation using the texture co-ordinates (also ranges from 0 to 1)\n\nI have figured out that I need to write color value in which is a vector of dimension 4. I'm not sure how I can calculate the R, G and B channels for just by one scalar value that ranges for 0 to 1.0 (It will from GREEN to RED and at 0.5 it will be WHITE)"
    },
    {
        "link": "https://reddit.com/r/opengl/comments/6nghtj/glsl_mix_implementation_incorrect",
        "document": "This minute physics video https://youtu.be/LKnqECcg6Gw bought to my attention how software often handles colors incorrectly. I made a comparison of the built in mix function and my fixed implementation here.\n\nDid you know about this? Which one looks better to you and what is the performance impact of using this implementation?"
    },
    {
        "link": "https://registry.khronos.org/OpenGL-Refpages/gl4/html/mix.xhtml",
        "document": "Specify the value to use to interpolate between x and y .\n\nperforms a linear interpolation between and using to weight between them. The return value is computed as $x \\times (1 - a) + y \\times a$.\n\nThe variants of where is select which vector each returned component comes from. For a component of that is false, the corresponding component of is returned. For a component of that is true, the corresponding component of is returned. Components of and that are not selected are allowed to be invalid floating-point values and will have no effect on the results."
    },
    {
        "link": "https://stackoverflow.com/questions/60212615/how-to-properly-blend-colors-across-two-triangles-and-remove-diagonal-smear",
        "document": "The issue is the top right triangle has no knowledge of the bottom left corner so the top right triangle is not including any of the blue from the bottom left (and visa versa)\n\nA couple of ways to fix that.\n\nOne is to use a 2x2 texture with linear sampling. You have to do some extra math to get the interpolation correct because a texture only interpolates between pixels\n\nAbove is a 4 pixel texture stretched to 14 by 6. Sampling happens between pixels so only this center area will get the gradient. Outside that area would be sampled with pixels outside the texture so using CLAMP_TO_EDGE or on the opposite side of the texture using REPEAT.\n\nNote: to see what I mean about the extra math needed for the texture coordinates here is the same example without the extra math\n\nAlso of course, rather than do the math in the fragment shader we could fix the texture coordinates in JavaScript\n\nAnother way is to do the interpolation yourself based on those corners (which is effectively doing what the texture sampler is doing in the previous example, bi-linear interpolation of the 4 colors)."
    }
]