[
    {
        "link": "https://learn.unity.com/tutorial/unit-2-vr-game-development-and-prototyping",
        "document": "Ruth Bram, Producer at Oculus Studios and Mari Kyle, Content Launch Manager from the Oculus Store, team up to explore different approaches to ideation and prototyping to help set you up for success in this course. You’ll gain a solid understanding of how to strategically evaluate your VR game within each stage of VR game development and at each key milestone. You’ll learn how to identify your target audience, how to best position your title to consumers, and how to build a following. With the exercises and templates provided, you’ll create a game design document (GDD), a player profile report, and a press kit."
    },
    {
        "link": "https://medium.com/@Brian_David/unity-vr-teleport-reticle-setup-customization-8fc8cb544842",
        "document": "Teleporting in VR is a basic movement mechanic, but without clear visual feedback that identifies where to teleport to, Users may find it disorienting. Why not take the guess work out of the mechanic and use a visual marker, a teleport reticle, that identifies the exact destination to improve navigation?\n\nA teleport reticle is like a stepping stone in a foggy path — just as stepping stones provide a clear and stable place to land while crossing uncertain terrain, the reticle gives players a concrete visual marker in the virtual space, making each teleportation step feel precise.\n\nIn the context of VR in Unity, a reticle is a visual marker that helps Users identify their teleportation destination.\n\nThis concept is adapted to display a teleportation target indicator on the ground, helping users gauge exact positioning before movement. The reticle’s appearance and behavior can be customized using Unity’s XR Interaction Toolkit, allowing changes to the shape, color, and directional alignment.\n\nThe teleportation system in Unity comes with three default reticles (see below, i.e., Blocking Teleportation Reticle, Directional Teleport Reticle, Reticle Torus), but developers can replace it with custom objects. This allows for creative decisions to be made that match the context of the narrative and character involved in the Scene. To select one:\n• Select the dropdown for the XR Interactor Line Visual component\n• Left-click on the radio button of the object picker (1) beside the field labeled Reticle\n• Search for (2) “reticle” and select the (3) Directional Teleport Reticle\n• Look in the bottom of the Select Object window to confirm it is the Directional Teleport Reticle\n\nThis built-in option provides a quick way to implement a reticle, but the reticle is not enabled to recieve input from User input about direction.\n\nA problem with newly configured teleport reticles is incorrect alignment but in my particular case it remains fixed and pointing forward. What if I want to teleport and face in a specific direction so that when I land I’m facing the action? To fix this:\n• Click on the Teleportation Area in the Hierarchy or Scene View.\n• Locate “Match Directional Input” in the Teleportation Area component > tick the box\n\nBy adjusting this setting, the teleport reticle will now rotate based on input from my Right Controller joystick before teleporting.\n\nThe default gray color of the reticle isn’t ideal for every environment so its color will probably need adjusted for better visibility, maybe add animations for visual feedback, or change the shape based on game aesthetics and circumstances but for now I’ll leave this to be explored for stories in the near future.\n\nHave you tried customizing teleport reticles in Unity? Let us know your favorite approach in the comments!"
    },
    {
        "link": "https://csteachers.org/beginner-unity-projects-for-your-game-development-classroom",
        "document": "This is a CSTA Partner Post submitted by Mastery Coding\n\n\n\nGetting started with game development can be both exciting and daunting for both students and educators who are new to coding. Unity, a powerful and accessible game engine, provides an ideal development platform for beginners to build technical and creative skills through hands-on projects while learning coding with C#. Starting out by recreating their favorite video games is a foundational first step for many experienced game developers. By creating simplified versions of popular games, your students too can explore core game mechanics while infusing their unique ideas and personalities into each project. For educators teaching game design, these beginner-friendly Unity projects offer structured yet flexible opportunities to guide students in applying game design principles and programming skills.\n\nThe Virtual Rube Goldberg Machine project introduces students to Unity’s 3D Physics Engine, a vital tool for simulating real-world behaviors such as gravity, collisions, and acceleration. In this project, students create complex chain reactions by manipulating objects using Unity’s intuitive physics tools. With no coding requirements, this project is perfect for helping students get comfortable with the Unity interface using simple shapes or freely available assets.\n• Understand Physics Components: Learn to use Rigidbody and Colliders for object movement and interaction.\n• Experiment with Physical Properties: Explore mass, friction, drag, and bounce to influence object behavior.\n\nCreating a projectile-based physics puzzle game, similar to Angry Birds, allows students to merge coding skills with Unity’s scripting API. Students develop a fun, interactive arcade experience by launching projectiles to destroy structures, reinforcing both programming fundamentals and physics concepts.\n• Scoring System: Track performance based on shots fired or time taken to clear levels.\n• Shot Limitation: Introduce strategic depth by limiting the number of projectiles available.\n• Level Progression: Add increasing difficulty and variety with new levels and complex structures.\n• Master Unity’s Scripting API: Build familiarity with the API through hands-on scripting.\n\nStudents create a 2D endless runner where characters navigate obstacles and collect items in a continuously scrolling environment, similar to Flappy Bird, reinforcing efficient coding practices and optimization techniques.\n• Power-ups: Enhance gameplay with temporary abilities like invincibility or speed boosts.\n• Optimize Program Structure: Apply best practices for coding efficiency and performance.\n\nAn escape room game challenges students to create an immersive 3D environment where players solve puzzles and uncover clues to escape the locked environment. This project emphasizes level design, interactive gameplay, and event-driven programming.\n• Timer: Introduce urgency with a countdown for players to complete challenges.\n• Develop Player Input and Interaction: Create responsive controls and object interactions in C#.\n\n\n\nProject-based learning with the Unity game engine not only strengthens your students’ skills in coding and game design but also fosters creativity, teamwork, and critical thinking. By guiding your students through the hands-on projects in this article, you can help them build robust portfolios of their work. Moreover, using a turn-key resource like Mastery Coding’s Game Development courses offers a comprehensive curriculum that prepares students to attain up to four industry-recognized Unity certifications, without the need for the educator to be a subject-matter expert."
    },
    {
        "link": "https://u.osu.edu/levinegamedevelopment",
        "document": "While it’s been almost three weeks, a combination of life, differing responsibilities with work (both at my internship and with a freelance project), and troubleshooting countless bugs in my current prototype, I have had trouble finding time to make serious progress on my game development plans. As a result, I’d like to use this post to detail progress, restructure plans, and also recap a Game Dev meetup.\n\nTo start, let’s talk about successes: one mechanic I implemented successfully was a tree destruction mechanism, along with bullet damage and monster deaths. The tree destruction mechanism didn’t take me too much time to actually write, as I had a simple implementation in mind. Debugging it and getting it to work, however, was much more challenging. I started by writing a class titled “TreeHealth,” which is attached on all tree objects in the game. It contains two instance variables which keep track of the health, and when the player is on a tree. There are two getter methods to access these variables as needed, and OnTriggerEnter and OnTriggerExit methods which check for a collision with the player and sets isPlayerOnTree to the appropriate value. Another class, entitled GroundMonsterHealthDamage, is attached on all monster objects. Here, there is a private instance variable of type TreeHealth called “treeToAttack.” In its OnTriggerEnter method, we check if it collides with a tree object. If it does, we grab the TreeHealth component on it, and use a getter for isPlayerOnTree. If the player is on that tree, we set an instance variable in the GroundMonsterHealthDamage script to true which allows us to attack the tree as long as the treeToAttack variable is not null. Once OnTriggerExit is called, treeToAttack is set equal to null. For the bullet damage implementation, all bullets are simply tagged with the string “Bullet.” If the collision that occurs in OnTriggerEnter has a tag of bullet, then the monster takes damage, and is destroyed when its health is set less than or equal to zero.\n\nMy issues with the tree destruction mechanisms stemmed less from the code, and more from setting up colliders on the player, trees, and monsters. I had to do a lot of experimenting to get the player to collide with the cylinder, and even did this by fiddling with the transportation technique. One issue I have is where the player teleports to after they hit the tree, as sometimes it seems as though you’ll land right on the tree or float in the air slightly away from the tree. This is because the teleportation mechanic teleports you forward every 5 chain links, and there’s no guarantee how close you’ll land to the tree as a result. To fix this, I modified the delegates in the Arrow class to also pass a reference to the arrow object. From there, I grab the transform attached to tip of the arrow, and get the vector representing the direction of the Y axis (see below – this is the green axis that points away from where the cylinder hits, which is the direction we want to offset the player). I then use this vector and place it’s x and z values into a new Vector 3, and add an offset specified in a public instance variable. This ends up being the last position you teleport to once the teleportation co-routine responsible for movement is called. Teleportation feels a little more consistent now, but sometimes it feels like you teleport to the other side of the pillar – I will come back to this topic later on in this blog post.\n\nWhen I planned on implementing a monster navigation system, I was only expecting it to take a handful of days to complete. At the time of writing, I’ve spent about a week trying to get a monster spawning system working reasonably with a wide variety of successes and setbacks. I’ve used the navigation mesh a couple of times in some tutorials before I started my step project, and assumed that it would be fairly simple to implement it as my terrain is mostly flat with some obstacles. However, I didn’t account for the fact that navigation meshes (also refered to as nav meshes) are usually baked (a term used to refer to the creation the actual navigation mesh) before starting the game. Since my game is generated at run time, the traditional method of baking a navigation mesh is not applicable. However, I was very lucky to discover that Unity recently added an update which allows for you to build navigation meshes at run time. Initially, I couldn’t find any resources on building run time nav meshes, so I spent a few hours using the scripting API trying to build my own implementation. After trying to debug why my implementation wasn’t working, I ended up looking for more information again on run time baking, which led me to this video. It quickly details how to build a run time nav mesh using some external scripts provided by Unity. In the implementation from the tutorial, you simply take the NavMeshSourceTag script and attach it to all terrain you want to generate, and then use the LocalNavMeshSource script to create an invisible box which sets the bounds of the navigation mesh. I actually resize this box at run time to fit the entire play area depending on the terrain generator specifications. Then, you can simply add navigation mesh agents to your monsters mand script their movements. For this, I used Unity’s manual to actually set up and script the movement. My current issue stems from the fact that monster movement is very jittery, as the monsters simply start moving and then suddenly stop, before restarting movement. I spent a lot of time just testing out and tweaking a bunch of things to try to fix this issue, but couldn’t isolate the issue.\n\nAt this point, I decided to hold off on working on it until the Central Ohio Game Development Prototype, Play, and Build Workshop, which I had actually planned to take a prototype of my game to as one of my goals. Unfortunately, I didn’t have anything playable, but I thought that I would at least take my current build to the meetup and get help on my current nav mesh bug. I actually met an OSU graduate who had done work in Unity and was more than willing to help me out, but unfortunately (or maybe fortunately?) I couldn’t reproduce the bug while at the workshop. That being said, I was able to get some feedback about the game itself from him. His general notes involved it being somewhat disorienting being suspended above the air without a platform under him and having the player potentially teleport to the top of the tree instead of the sides for greater visibility. I also wanted feedback on the teleportation system, and he said it mostly felt normal. However, I had a detailed discussion with him about the teleportation modification I was making, and he was able to pick up on one small nuance that I was missing. While it is possible to get the Y axis direction of the arrow, you need to actually check the direction it is pointing in world space to see whether you need to add or subtract it. For example if the player moves in the -X direction towards a tree, you’ll want to add the offset when adjusting the X direction, while doing the opposite when moving towards the +X direction. I do not know if I will have time to apply this fix (or how I would go about doing it), but it’s something to consider if I have additional time to fix up my game.\n\nI’m essentially going to break my VR project down into a list of things I need for a finished game prototype, and scale back on some of my goals in the game design document I made. This is to ensure that I at least have something playable by the time school starts this August and I won’t have to worry about developing on top of classes.\n• Spawn monsters from sky falling (a change from my initial monster spawning plans that prevents a monster from just appearing in front of your eyes) – 7/22/2017\n• Script player falling and dying as an end game condition – 7/23/2017\n\nI am most likely going to delay my Unity Coursework tutorials until my prototype is completed, as I really want to just sit down and finish this without worrying about doing tutorials as well. Beyond that, I don’t have anything else to report, except that I hope I have a new blog post next week with a lot more successes than setbacks!"
    },
    {
        "link": "https://discussions.unity.com/t/wip-3d-puzzle-game-with-cubes-and-cat/498049",
        "document": ""
    },
    {
        "link": "https://docs.unity3d.com/Manual/CollidersOverview.html",
        "document": "In Unity, a collision happens when two GameObjectsThe fundamental object in Unity scenes, which can represent characters, props, scenery, cameras, waypoints, and more. A GameObject’s functionality is defined by the Components attached to it. More info\n\nSee in Glossary that are configured for collision occupy the same physical space. Collision is a foundational part of most games, and many interactive applications and simulators.\n\nTo handle collision between GameObjects, Unity uses colliders. A collider is a Unity component that defines the shape of a GameObject for the purposes of physical collisions. Colliders are invisible, and do not need to be the same shape as the GameObject’s mesh.\n\nFor guidance on how to add components to a GameObject, see Use Components.\n\nEach 3D collider has a 2D equivalent. In Unity, 2D and 3D physics run on different physics simulation systems. For guidance on 2D physics colliders, see Collider 2D.\n\nA collider’s type is based on the configuration of its GameObject’s Collider and RigidbodyA component that allows a GameObject to be affected by simulated gravity and other forces. More info\n\nSee in Glossary components. This configuration determines how a collider behaves, and how it interacts with other colliders.\n• Static colliders: The GameObject has a collider but no Rigidbody.\n• Rigidbody colliders: The GameObject has a collider and a Rigidbody.\n• Dynamic colliders: The Rigidbody is dynamic (that is, it has Is Kinematic disabled).\n• Kinematic colliders: The Rigidbody is kinematic (that is, it has Is Kinematic enabled).\n\nThere is also a sub-type of collider called a Trigger collider. Trigger colliders do not physically collide with other colliders; instead, Unity calls a function when other colliders pass through them.\n\nTrigger colliders don’t cause collisions. Instead, they detect other Colliders that pass through them, and call functions that you can use to initiate events (see Use collisions to trigger other events).\n\nTo turn a collider into a trigger collider, enable the Is Trigger property on the Collider component. A trigger collider does not collide with other colliders; instead, other colliders pass through it.\n\nFor a trigger collider to work, at least one GameObject involved in the collision must have a Rigidbody. Trigger colliders can be any collider type (static or Rigidbody), but in most cases it’s good practice to make the trigger collider a static collider. and add a Rigidbody to the GameObject that passes through the trigger. If several GameObjects are passing through one trigger, there must be a Rigidbody on at least one GameObject in each collision pair.\n\nTriggers can be any collider shape (see Collider shapes), and they can be visible or invisible. To make a trigger invisible, add the collider to an empty GameObject. Only add a trigger to a visible GameObject if it is okay for other GameObjects to visibly pass through it.\n\nFor gameplay and simulation, triggers might need some adjustment to make them feel intuitive for the player. For example, you could experiment with making a trigger collider slightly larger than its associated visible GameObject, so that it has a wider radius.\n\nFor information on how different collider types interact with each other on collision, see Interaction between collider types.\n\nCollider components are available in different shape configurations. There are three main shape types for colliders:\n\nPrimitive colliders are built-in simple shapes that you can attach to your GameObject and scale to approximately the same size and shape. You can also combine several primitive collider shapes to create compound colliders. Mesh collidersA free-form collider component which accepts a mesh reference to define its collision surface shape. More info\n\nSee in Glossary exactly match the shape of the GameObject’s MeshThe main graphics primitive of Unity. Meshes make up a large part of your 3D worlds. Unity supports triangulated or Quadrangulated polygon meshes. Nurbs, Nurms, Subdiv surfaces must be converted to polygons. More info\n\nSee in Glossary. They are more accurate than primitive colliders for complex shapes, but require more computational resources. Wheel collidersA special collider for grounded vehicles. It has built-in collision detection, wheel physics, and a slip-based tire friction model. It can be used for objects other than wheels, but it is specifically designed for vehicles with wheels. More info\n\nSee in Glossary are raycast-based Colliders specifically for in-game items that have physics-simulated wheels (for example, vehicles). They have built-in wheel physics, and controls for friction.\n\nYou can control the friction and bounciness of a collider’s surface. When two colliders meet, the physics system uses the properties of each surface to calculate the friction and bounce between them.\n\nFor more information, see Collider surfaces."
    },
    {
        "link": "https://reddit.com/r/Unity2D/comments/64mq79/any_good_guides_on_2d_collision_detection",
        "document": "A few months ago I had a play with a 2D platformer, and following some tutorials I had a demo with all the basic mechanics implemented. This included raycasting for collision detection, as well as handling sloped surfaces.\n\nI've picked up a new project, and I'm trying to do the collision detection again - this time I'm looking at a top-down style game. However I wasn't able to rework my old platformer code as the collision detection didn't extend well to detecting from four sides (if that makes sense).\n\nI understand the basic principles of raycasting, but I'm having some difficulties getting my head around a sensible way of using raycasting to prevent collisions. The platform tutorial I used (can't find a link to it any more) had horizontal and vertical rays cast separately, which then resolved completely independently of each other. I've been trying to do something more like this:\n\nWhere the rays are being cast in the direction that the object is moving. I feel like this introduces a lot of problems however, and that there must be a simpler way.\n\nIs it better to cast only along the x/y axis and do separate calculations? Can this not introduce issues if one direction is calculated before the other? Are there any good tutorials or example scripts that I can look at to get a better idea?"
    },
    {
        "link": "https://medium.com/@Brian_David/how-to-use-unitys-layer-collision-matrix-to-prevent-collisions-and-optimize-game-mechanics-4014e2aba19e",
        "document": "Enemies explode as they approach the Player. The Player hasn’t fired a shot. As Enemy Lasers seek out the Player, several suddenly collide blindsiding their comrades, blowing them to smithereens. Friendly fire has helped the Player increase the total score but defeats the purpose of having the Player being able to fire a Laser. As the number of enemies and game mechanics that overlap movement patterns increase the potential for a situation where they collide with each other increases.\n\nOptimizing how game mechanics interact is extremely important, especially when dealing with complex interactions. Fortunately, Unity offers a powerful tool called the Layer Collision Matrix, allowing developers to filter and control collisions. In this story, I explain how to assign layers, configure Unity’s collision settings, and prevent friendly fire between enemy lasers while ensuring smooth interaction between players and enemies.\n\nHow to fix a situation where Enemies are attacking each other?\n\nI have an enemy game object. I do not want the enemy laser to collide with other enemies and trigger any of their OntriggerEnter2D methods but the enemies OnTriggerEnter2D method must be triggered by the players laser and collider.\n\nTo prevent enemy lasers from colliding with other enemies, but still allow collisions between the player’s laser and enemies, I discovered the Layer Collision Matrix in Unity and will use Layer-based collision filtering to prevent the friendly-fire from occurring.\n\nFirst I need to assign the prefab to it’s own layer. Select the Enemy_Laser and then in it’s Inspector, left-click on the dropdown list and left-click on Add Layer.\n\nWhen the Tags & Layers panel opens, select an empty User Layer and name the layer after the game object or prefab of the game object (i.e., Enemy_Laser).\n\nThen close the prefab, and a notification will appear in if you are applying the layer to a prefab. I want set this layer, Enemy Laser, for all child objects as well. Left-click, Yes, change children.\n\nAfter returning to the Hierarchy View, I select the prefab, Enemy_Laser, in the Prefab folder. Within the Inspector, I set it’s Layer to Enemy Laser.\n\nI repeat the process of selecting the game object/prefab, creating a layer, and assigning it to the layer for the Enemy prefab.\n\nTo access the Layer Collision Matrix, Go to Edit > Project Settings > Physics 2D (or Physics for 3D).\n\nIn the Layer Collision Matrix, uncheck the box that allows “Enemy” to collide with “EnemyLaser”. Currently, the Enemy prefabs are not colliding with each other so I will ignore the collision matrix identifying the “Enemy”/”Enemy” setting.\n\nWith the Layer Collision Matrix set, it’s time to test and make sure that the “Enemy” can still collide with “Player” and the Player’s Laser and that the Enemy Laser still can collide with the Player but not with other Enemies.\n\nWith this understanding of Unity’s Layer Collision Matrix, any developer can continue their production process with confidence and prevent unnecessary collisions among enemies. By properly assigning layers and configuring the matrix, you can optimize game performance, indirectly reinforcing the role of the Players game mechanics. Whether you’re working on a 2D or 3D project, these techniques will help you fine-tune interactions and create a smoother gameplay experience.\n\nThanks for reading! If you find this story helpful, please clap, comment, follow or subscribe."
    },
    {
        "link": "https://gamedev.stackexchange.com/questions/82119/simple-collision-detection-in-unity-2d",
        "document": "Stack Exchange network consists of 183 Q&A communities including Stack Overflow, the largest, most trusted online community for developers to learn, share their knowledge, and build their careers."
    },
    {
        "link": "https://reddit.com/r/Unity3D/comments/1di4m64/what_is_the_correct_unity_way_to_handle",
        "document": "A subreddit for News, Help, Resources, and Conversation regarding Unity, the game engine. Do NOT use your phone to take screenshots. Video and photos of computer screens taken by phones are NOT allowed. All screenshots must be grabbed from the computer itself."
    }
]