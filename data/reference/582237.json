[
    {
        "link": "https://ibm.com/docs/en/i/7.5?topic=extensions-standard-c-library-functions-table-by-name",
        "document": "1 This function is not supported for files opened with type=record. 2 This function is not supported for files opened with type=record and mode=ab+, rb+, or wb+. 3 The ILE C compiler only supports fully buffered and line-buffered streams. Since a block and a line are equal to the record length of the opened file, fully buffered and line-buffered streams are supported in the same way. The and functions have no effect. 4 This function is not available when LOCALETYPE(*CLD) is specified on the compilation command. 5 This function is available only when SYSIFCOPT(*IFSIO) is specified on the CRTCMOD or CRTBNDC command. 6 This function is not available when either LOCALETYPE(*CLD) or SYSIFCOPT(*NOIFSIO) is specified on the compilation command."
    },
    {
        "link": "https://tutorialspoint.com/c_standard_library/c_function_fopen.htm",
        "document": "The C library function FILE *fopen(const char *filename, const char *mode) opens the filename pointed to, by filename using the given mode. It opens a file and returns a pointer to a FILE object that can be used to access the file.\n\nFollowing is the C library syntax of the fopen() function −\n\nThis function accepts the following parameters −\n• filename: A string representing the name of the file to be opened. This can include an absolute or relative path.\n• mode: A string representing the mode in which the file should be opened. Common modes include:\n• \"r\": Open for reading. The file must exist.\n• \"w\": Open for writing. Creates an empty file or truncates an existing file.\n• \"a\": Open for appending. Writes data at the end of the file. Creates the file if it does not exist.\n• r+\": Open for reading and writing. The file must exist.\n• \"w+\": Open for reading and writing. Creates an empty file or truncates an existing file.\n• a+\": Open for reading and appending. The file is created if it does not exist.\n\nThe fopen function returns a FILE pointer if the file is successfully opened. If the file cannot be opened, it returns NULL.\n\nThis example opens a file named example.txt in read mode and prints its contents to the console character by character.\n\nBelow is the illustration of C library fopen() function.\n\nThe above code produces following result−\n\nHere, we open a file named log.txt in append mode, adds a new log entry to the end of the file, and then closes the file.\n\nAfter execution of above code, we get the following result"
    },
    {
        "link": "https://gnu.org/s/libc/manual/html_mono/libc.html",
        "document": "This is , for version 2.38.\n\nPermission is granted to copy, distribute and/or modify this document under the terms of the GNU Free Documentation License, Version 1.3 or any later version published by the Free Software Foundation; with the Invariant Sections being “Free Software Needs Free Documentation” and “GNU Lesser General Public License”, the Front-Cover texts being “A GNU Manual”, and with the Back-Cover Texts as in (a) below. A copy of the license is included in the section entitled \"GNU Free Documentation License\".\n\n(a) The FSF’s Back-Cover Text is: “You have the freedom to copy and modify this GNU manual. Buying copies from the FSF supports it in developing GNU and promoting software freedom.”"
    },
    {
        "link": "https://eecs.wsu.edu/~aofallon/cpts122/CLibraryReferenceGuide.pdf",
        "document": ""
    },
    {
        "link": "https://geeksforgeeks.org/c-fopen-function-with-examples",
        "document": "In C, the fopen() function is used to open a file in the specified mode. The function returns a file pointer (FILE *) which is used to perform further operations on the file, such as reading from or writing to it. If the file exists then the fopen() function opens the particular file else a new file is created in some cases.\n\nLet’s take a look at an example:\n\nOn running the following program, a new file will be created by the name “demo_file.txt” with the following content:\n• filename: Name of the file to be opened (with extension)\n• mode: For what purpose file is to be opened.\n• None Returns a FILE pointer if the file is successfully opened.\n\nThe below table lists valid mode values for feof() function with their meaning:\n\nSearches file. Opens the file for reading only. If the file is opened successfully fopen() loads it into memory and sets up a pointer that points to the first character in it. If the file cannot be opened fopen() returns NULL. Searches file. If the file exists already, its contents are overwritten. If the file doesn’t exist, a new file is created. Returns NULL, if unable to open the file. It creates a new file for writing only(no reading). Searches file. If the file is opened successfully fopen() loads it into memory and sets up a pointer that points to the last character in it. If the file doesn’t exist, a new file is created. Returns NULL, if unable to open the file. The file is opened only for appending(writing at the end of the file). Searches file. Opens the file for both reading and writing. If opened successfully, fopen() loads it into memory and sets up a pointer that points to the first character in it. Returns NULL, if unable to open the file. Searches file. If the file exists, its contents are overwritten. If the file doesn’t exist, a new file is created. Returns NULL, if unable to open the file. The difference between w and w+ is that we can also read the file created using w+. Searches file. If the file is opened successfully fopen( ) loads it into memory and sets up a pointer that points to the last character in it. If the file doesn’t exist, a new file is created. Returns NULL, if unable to open the file. The file is opened for reading and appending(writing at the end of the file). Open the binary file in read mode. If the file does not exist, the open() function returns NULL. Open the binary file in write mode. As the pointer is set to the start of the file, the contents are overwritten. If the file does not exist, a new file is created. Open the binary file in append mode. The file pointer is set after the last character in the file. A new file is created if no file exists with the name. Open the binary file in read and write mode. If the file does not exist, the open() function returns NULL. Open the binary file in read and write mode. Contents are overwritten if the file exists. It will be created if the file does not exist. Open the binary file in read and append mode. A file will be created if the file does not exist.\n\nIt is recommended to close the opened file after doing the required operations using fclose().\n\nThe below examples demonstrate how to use the fopen() for opening files in different modes:\n\nExplanation: The file example.txt is opened in read mode (“r”). If the file exists, it opens successfully. If the file doesn’t exist, fopen() returns NULL, and the program outputs an error message.\n\nExplanation: The file output.txt is opened in write mode (“w”). If the file does not exist, it is created. The program writes a string to the file using fprintf(). After writing, the file is closed using fclose().\n\nExplanation: The file append_example.txt is opened in append mode (“a”). If the file exists, the new content is appended to the end of the file. If the file does not exist, it is created. The program appends the text using fprintf().\n\nExplanation: This code tries to open a non-existent file non_existent_file.txt in read mode (“r”). If the file doesn’t exist, fopen() returns NULL. The perror() function is used to print a detailed error message explaining why the file could not be opened."
    },
    {
        "link": "https://stackoverflow.com/questions/16075233/reading-and-processing-wav-file-data-in-c-c",
        "document": "My first recommendation would be to use some kind of library to help you out. Most sound solutions seem overkill, so a simple library (like the one recommended in the comment of your question, libsndfile) should do the trick.\n\nIf you just want to know how to read WAV files so you can write your own (since your school might turn its nose up at having you use a library like any other regular person), a quick google search will give you all the info you need plus some people who have already wrote many tutorials on reading the .wav format.\n\nIf you still don't get it, here's some of my own code where I read the header and all other chunks of the WAV/RIFF data file until I get to the data chunk. It's based exclusively off the WAV Format Specification. Extracting the actual sound data is not very hard: you can either read it raw and use it raw or do a conversion to a format you'd have more comfort with internally (32-bit PCM uncompressed data or something).\n\nWhen looking at the below code, replace with equivalent calls for integer values and byte sizes of the indicated type. is an enum that is the Little Endian values of the IDs inside of a WAV file chunk, and the variable is one of the types of the Wav Format Types that can be contained in the WAV File Format:"
    },
    {
        "link": "https://truelogic.org/wordpress/2015/09/04/parsing-a-wav-file-in-c",
        "document": "The WAV (or PCM) audio format is the most basic format for storing audio. WAV files can be of different extended formats , but PCM is the most popular and common. The other formats are A-law and Mu-law. The PCM format stores raw audio data without any compression or conversion, thus leading to the largest file sizes, as compared to other formats like AIFF or MP3 or OGG.\n\nWhile there are existing libraries in several languages which allow you to work with WAV files, this post is an attempt to understand how to read the WAV file format without any external library. The language used here is C, and has been compiled using GCC under Linux, but it can be easily run under Windows also with minimal modifications. Most likely for VC++ you will have to replace #include <unistd.h> with #include <io.h>\n\nThe header structure is 44 bytes long and has the following structure:\n\nIt is important to note that the WAV format uses little-endian format to store bytes, so you need to convert the bytes to big-endian in code for the values to make sense.\n\nThanks to a bug pointed out by Kalpathi Subramanian, the code has been updated to rectify the bug. He has adapted this code into a C++ implementation which is available on https://github.com/BridgesUNCC/bridges-cxx/blob/master/src/AudioClip.h\n\nThe code consists of a header file wave.h which is included in wave.c . Once you compile it and run it, it accepts the path of a wav file from the command line and dumps the structure information including the size of each sample and the total duration of the wav audio.\n\nA sample run is given below:"
    },
    {
        "link": "https://github.com/franciscohanna92/wav_reader",
        "document": "Clone the repository. Build the project by into de folder and run . Execute the binary, passing as a argument a path to a WAV file. The content of the header will be printed in the standard output.\n\nFollowing the specification for the WAV header format, the task of reading this part of a WAV file is trivial. It's only matter of following the bytes per section. Checkout the methods in . They're pretty much self explainable."
    },
    {
        "link": "https://stackoverflow.com/questions/33727201/c-how-to-read-a-wav-file-format",
        "document": "I'm trying to read a wav file in c, but still no results. I have tried to read using and . I really have no idea what to do to read this file type.\n\nThis is my code in c:\n\nAll i need is just read the file and then print it to screen. Can someone please help me?\n\nEDIT: I want to read the bytes and see the result"
    },
    {
        "link": "https://mmsp.ece.mcgill.ca/Documents/AudioFormats/WAVE/WAVE.html",
        "document": "The WAVE file specifications came from Microsoft. The WAVE file format use RIFF chunks, each chunk consisting of a chunk identifier, chunk length and chunk data.\n• WAVE update (Revision: 3.0), 1994-04-15: Multimedia Registration Kit Revision 3.0 (Q120253) (broken link)\n\n Local copy: New Multimedia Data Types and Data Techniques (see pages 12-22)\n\nThe European Broadcast Union (EBU) has standardized on an extension to the WAVE format that they call Broadcast WAVE format (BWF). It is aimed at carrying PCM or MPEG audio data. In its simplest form, it adds a <bext> chunk with additional metadata. Full documentation is available on line from the EBU.\n\nThe data in WAVE files can be of many different types. Data format codes are listed in the following:\n• Microsoft include files (part of the MSVC compiler or the DirectX SDK: from Microsoft Download Center). For new installations of Visual Studio, the mmreg.h include file is installed into C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.15063.0\\shared. This document shows a huge number of (proprietary) compressed formats, most of which are now obsolete.\n\n Local copy: mmreg.h (extract of Version 1.58)\n\n\n\nWave files have a master RIFF chunk which includes a WAVE identifier followed by sub-chunks. The data is stored in little-endian byte order.\n\nThe specifies the format of the data. There are 3 variants of the Format chunk for sampled data. These differ in the extensions to the basic chunk.\n\nThe standard format codes for waveform data are given below. The references above give more format codes for compressed data, a good fraction of which are now obsolete.\n\nThe first part of the Format chunk is used to describe PCM data.\n• For PCM data, the Format chunk in the header declares the number of bits/sample in each sample ( ). The original documentation (Revision 1) specified that the number of bits per sample is to be rounded up to the next multiple of 8 bits. This rounded-up value is the container size. This information is redundant in that the container size (in bytes) for each sample can also be determined from the block size divided by the number of channels ( / ).\n• This redundancy has been appropriated to define new formats. For instance, Cool Edit uses a format which declares a sample size of 24 bits together with a container size of 4 bytes (32 bits) determined from the block size and number of channels. With this combination, the data is actually stored as 32-bit IEEE floats. The normalization (full scale 223) is however different from the standard float format.\n• PCM data is two's-complement except for resolutions of 1-8 bits, which are represented as offset binary.\n\nAn extended Format chunk is used for non-PCM data. The field gives the size of the extension.\n• For all formats other than PCM, the Format chunk must have an extended portion. The extension can be of zero length, but the size field (with value 0) must be present.\n• For float data, full scale is 1. The bits/sample would normally be 32 or 64.\n• For the log-PCM formats (µ-law and A-law), the Rev. 3 documentation indicates that the bits/sample field ( ) should be set to 8 bits.\n• The non-PCM formats must have a chunk.\n\nThe format code indicates that there is an extension to the Format chunk. The extension has one field which declares the number of bits/sample ( ). Another field ( ) contains bits which indicate the mapping from channels to loudspeaker positions. The last field ( ) is a 16-byte globally unique identifier (GUID).\n• With the format, the original bits/sample field ( ) must match the container size ( ). This means that must be a multiple of 8. Reduced precision within the container size is now specified by .\n• The number of valid bits ( ) is informational only. The data is correctly represented in the precision of the container size. The number of valid bits can be any value from 1 to the container size in bits.\n• The loudspeaker position mask uses 18 bits, each bit corresponding to a speaker position (e.g. Front Left or Top Back Right), to indicate the channel to speaker mapping. More details are in the document cited above. This field is informational. An all-zero field indicates that channels are mapped to outputs in order: first channel to first output, second channel to second output, etc.\n• The first two bytes of the GUID form the sub-code specifying the data format code, e.g. . The remaining 14 bytes contain a fixed string, .\n\nThe format should be used whenever:\n• PCM data has more than 16 bits/sample.\n• The number of channels is more than 2.\n• The actual number of bits/sample is not equal to the container size.\n• The mapping from channels to speakers needs to be specified.\n\nAll (compressed) non-PCM formats must have a chunk (Rev. 3 documentation). The chunk contains at least one value, the number of samples in the file.\n• The Rev. 3 documentation states that the Fact chunk is required for all new new WAVE formats , but for the standard file. One presumes that files with IEEE float data (introduced after the Rev. 3 documention) need a chunk.\n• The number of samples field is redundant for sampled data, since the Data chunk indicates the length of the data. The number of samples can be determined from the length of the data and the container size as determined from the Format chunk.\n• There is an ambiguity as to the meaning of for multichannel data. The implication in the Rev. 3 documentation is that it should be interpreted to be . The statement in the Rev. 3 documentation is: The field from the wave format header is used in conjunction with the field to determine the length of the data in seconds. With no mention of the number of channels in this computation, this implies that is the number of samples per channel.\n• There is a question as to whether the chunk should be used for (including those with PCM) files. One example of a with PCM data from Microsoft, does not have a chunk.\n\nThe chunk contains the sampled data.\n\nConsider sampled data with the following parameters,\n• The total number of blocks is . Each block consists of samples.\n• WAVE files often have information chunks that precede or follow the sound data ( chunk). Some programs (naively) assume that for PCM data, the preamble in the file header is exactly 44 bytes long (as in the table above) and that the rest of the file contains sound data. This is not a safe assumption.\n• Microsoft Windows Media Player will not play non-PCM data (e.g. µ-law data) if the chunk does not have the extension size field ( ) or a chunk is not present.\n• The chunk can normally be omitted if the sampled data is in PCM format.\n• In some cases, Microsoft Windows Media Player enforces the use of the format code. For instance a file with 24-bit data declared as a standard format code will not play, but a file with 24-bit data declared as a file with a subcode can be played."
    }
]