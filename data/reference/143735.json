[
    {
        "link": "https://docs.djangoproject.com/en/5.1/topics/http/file-uploads",
        "document": "When Django handles a file upload, the file data ends up placed in (for more on the object see the documentation for request and response objects). This document explains how files are stored on disk and in memory, and how to customize the default behavior.\n\nA view handling this form will receive the file data in , which is a dictionary containing a key for each (or , or other subclass) in the form. So the data from the above form would be accessible as . Note that will only contain data if the request method was , at least one file field was actually posted, and the that posted the request has the attribute . Otherwise, will be empty. Most of the time, you’ll pass the file data from into the form as described in Binding uploaded files to a form. This would look something like: Notice that we have to pass into the form’s constructor; this is how file data gets bound into a form. Here’s a common way you might handle an uploaded file: Looping over instead of using ensures that large files don’t overwhelm your system’s memory. There are a few other methods and attributes available on objects; see for a complete reference. If you’re saving a file on a with a , using a makes this process much easier. The file object will be saved to the location specified by the argument of the corresponding when calling : If you are constructing an object manually, you can assign the file object from to the file field in the model: If you are constructing an object manually outside of a request, you can assign a like object to the : If you want to upload multiple files using one form field, create a subclass of the field’s widget and set its class attribute to . In order for such files to be all validated by your form (and have the value of the field include them all), you will also have to subclass . See below for an example. Django is likely to have a proper multiple file field support at some point in the future. Then override the method of your subclass to handle multiple file uploads: # Replace with your URL or reverse(). # Do something with each file. This will allow you to handle multiple files at the form level only. Be aware that you cannot use it to put multiple files on a single model instance (in a single field), for example, even if the custom widget is used with a form field related to a model .\n\nWhen a user uploads a file, Django passes off the file data to an upload handler – a small class that handles file data as it gets uploaded. Upload handlers are initially defined in the setting, which defaults to: Together and provide Django’s default file upload behavior of reading small files into memory and large ones onto disk. You can write custom handlers that customize how Django handles files. You could, for example, use custom handlers to enforce user-level quotas, compress data on the fly, render progress bars, and even send data to another storage location directly without storing it locally. See Writing custom upload handlers for details on how you can customize or completely replace upload behavior. Before you save uploaded files, the data needs to be stored somewhere. By default, if an uploaded file is smaller than 2.5 megabytes, Django will hold the entire contents of the upload in memory. This means that saving the file involves only a read from memory and a write to disk and thus is very fast. However, if an uploaded file is too large, Django will write the uploaded file to a temporary file stored in your system’s temporary directory. On a Unix-like platform this means you can expect Django to generate a file called something like . If an upload is large enough, you can watch this file grow in size as Django streams the data onto disk. These specifics – 2.5 megabytes; ; etc. – are “reasonable defaults” which can be customized as described in the next section. There are a few settings which control Django’s file upload behavior. See File Upload Settings for details. Sometimes particular views require different upload behavior. In these cases, you can override upload handlers on a per-request basis by modifying . By default, this list will contain the upload handlers given by , but you can modify the list as you would any other list. For instance, suppose you’ve written a that provides feedback on upload progress to some sort of AJAX widget. You’d add this handler to your upload handlers like this: You’d probably want to use in this case (instead of ) because a progress bar handler would need to run before any other handlers. Remember, the upload handlers are processed in order. If you want to replace the upload handlers completely, you can assign a new list: You can only modify upload handlers before accessing or – it doesn’t make sense to change upload handlers after upload handling has already started. If you try to modify after reading from or Django will throw an error. Thus, you should always modify uploading handlers as early in your view as possible. Also, is accessed by which is enabled by default. This means you will need to use on your view to allow you to change the upload handlers. You will then need to use on the function that actually processes the request. Note that this means that the handlers may start receiving the file upload before the CSRF checks have been done. Example code: If you are using a class-based view, you will need to use on its method and on the method that actually processes the request. Example code:"
    },
    {
        "link": "https://docs.djangoproject.com/fr/2.2/topics/http/file-uploads",
        "document": "When Django handles a file upload, the file data ends up placed in (for more on the object see the documentation for request and response objects). This document explains how files are stored on disk and in memory, and how to customize the default behavior.\n\nA view handling this form will receive the file data in , which is a dictionary containing a key for each (or , or other subclass) in the form. So the data from the above form would be accessible as . Note that will only contain data if the request method was and the that posted the request has the attribute . Otherwise, will be empty. Most of the time, you’ll simply pass the file data from into the form as described in Liaison de fichiers téléversés avec un formulaire. This would look something like: Notice that we have to pass into the form’s constructor; this is how file data gets bound into a form. There are a few other methods and attributes available on objects; see for a complete reference. If you’re saving a file on a with a , using a makes this process much easier. The file object will be saved to the location specified by the argument of the corresponding when calling : If you are constructing an object manually, you can simply assign the file object from to the file field in the model: If you want to upload multiple files using one form field, set the HTML attribute of field’s widget: Then override the method of your subclass to handle multiple file uploads:\n\nWhen a user uploads a file, Django passes off the file data to an upload handler – a small class that handles file data as it gets uploaded. Upload handlers are initially defined in the setting, which defaults to: Together and provide Django’s default file upload behavior of reading small files into memory and large ones onto disk. You can write custom handlers that customize how Django handles files. You could, for example, use custom handlers to enforce user-level quotas, compress data on the fly, render progress bars, and even send data to another storage location directly without storing it locally. See Écriture de gestionnaires de téléversement personnalisés for details on how you can customize or completely replace upload behavior. Before you save uploaded files, the data needs to be stored somewhere. By default, if an uploaded file is smaller than 2.5 megabytes, Django will hold the entire contents of the upload in memory. This means that saving the file involves only a read from memory and a write to disk and thus is very fast. However, if an uploaded file is too large, Django will write the uploaded file to a temporary file stored in your system’s temporary directory. On a Unix-like platform this means you can expect Django to generate a file called something like . If an upload is large enough, you can watch this file grow in size as Django streams the data onto disk. These specifics – 2.5 megabytes; ; etc. – are simply « reasonable defaults » which can be customized as described in the next section. There are a few settings which control Django’s file upload behavior. See File Upload Settings for details. Sometimes particular views require different upload behavior. In these cases, you can override upload handlers on a per-request basis by modifying . By default, this list will contain the upload handlers given by , but you can modify the list as you would any other list. For instance, suppose you’ve written a that provides feedback on upload progress to some sort of AJAX widget. You’d add this handler to your upload handlers like this: You’d probably want to use in this case (instead of ) because a progress bar handler would need to run before any other handlers. Remember, the upload handlers are processed in order. If you want to replace the upload handlers completely, you can just assign a new list: You can only modify upload handlers before accessing or – it doesn’t make sense to change upload handlers after upload handling has already started. If you try to modify after reading from or Django will throw an error. Thus, you should always modify uploading handlers as early in your view as possible. Also, is accessed by which is enabled by default. This means you will need to use on your view to allow you to change the upload handlers. You will then need to use on the function that actually processes the request. Note that this means that the handlers may start receiving the file upload before the CSRF checks have been done. Example code:"
    },
    {
        "link": "https://stackoverflow.com/questions/15990716/upload-file-with-filefield-and-nginx-just-throw-errors",
        "document": "I'm new to Django, I'm learning how to handle uploading file with django, I did the same things with the document, but my nginx just throw out errors,\n\nhere is my views.py:\n\nif I upload some text-based file (size is very small), everything is OK, when upload other formats, or large csv file, the code failed on\n\nSorry, the page you are looking for is currently unavailable. Please try again later.\n\nI use nginx+uwsgi+django, so is it related to the uwsgi and nginx setup?"
    },
    {
        "link": "https://stackoverflow.com/questions/61790324/error-while-uploading-file-through-form-in-django",
        "document": "You are not passing in your form. You should pass it like this:\n\nMore information on file uploads can be found in documentation."
    },
    {
        "link": "https://docs.djangoproject.com/en/5.1/ref/files/uploads",
        "document": "During file uploads, the actual file data is stored in . Each entry in this dictionary is an object (or a subclass) – a wrapper around an uploaded file. You’ll usually use one of these methods to access the uploaded content: Read the entire uploaded data from the file. Be careful with this method: if the uploaded file is huge it can overwhelm your system if you try to read it into memory. You’ll probably want to use instead; see below. Returns if the uploaded file is big enough to require reading in multiple chunks. By default this will be any file larger than 2.5 megabytes, but that’s configurable; see below. A generator returning chunks of the file. If is , you should use this method in a loop instead of . In practice, it’s often easiest to use all the time. Looping over instead of using ensures that large files don’t overwhelm your system’s memory. Here are some useful attributes of : The name of the uploaded file (e.g. ). The size, in bytes, of the uploaded file. The content-type header uploaded with the file (e.g. text/plain or application/pdf). Like any data supplied by the user, you shouldn’t trust that the uploaded file is actually this type. You’ll still need to validate that the file contains the content that the content-type header claims – “trust but verify.” A dictionary containing extra parameters passed to the header. This is typically provided by services, such as Google App Engine, that intercept and handle file uploads on your behalf. As a result your handler may not receive the uploaded file content, but instead a URL or other pointer to the file (see RFC 2388). For text/* content-types, the character set (i.e. ) supplied by the browser. Again, “trust but verify” is the best policy here. Like regular Python files, you can read the file line-by-line by iterating over the uploaded file: Lines are split using universal newlines. The following are recognized as ending a line: the Unix end-of-line convention , the Windows convention , and the old Macintosh convention . A file uploaded to a temporary location (i.e. stream-to-disk). This class is used by the . In addition to the methods from , it has one additional method: Returns the full path to the temporary uploaded file. A file uploaded into memory (i.e. stream-to-memory). This class is used by the .\n\nTogether the and provide Django’s default file upload behavior of reading small files into memory and large ones onto disk. They are located in . File upload handler to stream uploads into memory (used for small files). Upload handler that streams data into a temporary file using .\n\nAll file upload handlers should be subclasses of . You can define upload handlers wherever you wish. Custom file upload handlers must define the following methods: Receives a “chunk” of data from the file upload. is a bytestring containing the uploaded data. is the position in the file where this chunk begins. The data you return will get fed into the subsequent upload handlers’ methods. In this way, one handler can be a “filter” for other handlers. Return from to short-circuit remaining upload handlers from getting this chunk. This is useful if you’re storing the uploaded data yourself and don’t want future handlers to store a copy of the data. If you raise a or a exception, the upload will abort or the file will be completely skipped. The handler should return an object that will be stored in . Handlers may also return to indicate that the object should come from subsequent upload handlers. Custom upload handlers may also define any of the following optional methods or attributes: Size, in bytes, of the “chunks” Django should store into memory and feed into the handler. That is, this attribute controls the size of chunks fed into . For maximum performance the chunk sizes should be divisible by and should not exceed 2 GB (231 bytes) in size. When there are multiple chunk sizes provided by multiple handlers, Django will use the smallest chunk size defined by any handler. The default is 64*210 bytes, or 64 KB. Callback signaling that a new file upload is starting. This is called before any data has been fed to any upload handlers. is a string name of the file field. is the filename provided by the browser. is the MIME type provided by the browser – E.g. . is the length of the image given by the browser. Sometimes this won’t be provided and will be . is the character set (i.e. ) given by the browser. Like , this sometimes won’t be provided. is extra information about the file from the header. See . This method may raise a exception to prevent future handlers from handling this file. Callback signaling that the entire upload (all files) has completed. Callback signaling that the upload was interrupted, e.g. when the user closed their browser during file upload. Allows the handler to completely override the parsing of the raw HTTP input. is the same object as . is the length of the data in . Don’t read more than bytes from . is the MIME boundary for this request. is the encoding of the request. Return if you want upload handling to continue, or a tuple of if you want to return the new data structures suitable for the request directly."
    },
    {
        "link": "https://stackoverflow.com/questions/58543617/how-to-support-optional-or-empty-filefield-with-django-rest-framework",
        "document": "I added a new FileField 'photo' to my existing model and migrated the database. When I try to return data using DRF, I get the error message \"ValueError: The 'photo' attribute has no file associated with it.\" Photo column contains empty values.\n\nThe field should be optional.\n\nEDIT: problem persists also I set the fields null = True and make the column null. Also, including required = False to serializers.ReadOnlyField didn't help.\n\nThe problem only happens with MyModel_l10n. If I serialize MyModel, the missing file is not on issue."
    },
    {
        "link": "https://stackoverflow.com/questions/8609192/what-is-the-difference-between-null-true-and-blank-true-in-django",
        "document": "in respect to different ( CharField , ForeignKey , ManyToManyField , DateTimeField ) fields? What are the advantages/disadvantages of using option 1, 2, or 3?\n\nThe same is done with ForeignKey , DecimalField etc. What is the basic difference between:\n\nWant to improve this post? Provide detailed answers to this question, including citations and an explanation of why your answer is correct. Answers without enough detail may be edited or deleted.\n\nsets (versus ) on the column in your DB. Blank values for Django field types such as or will be stored as in the DB. determines whether the field will be required in forms. This includes the admin and your custom forms. If then the field will not be required, whereas if it's the field cannot be blank. The combo of the two is so frequent because typically if you're going to allow a field to be blank in your form, you're going to also need your database to allow values for that field. The exception is s and s, which in Django are never saved as . Blank values are stored in the DB as an empty string ( ). models.DateTimeField(blank=True) # raises IntegrityError if blank models.DateTimeField(null=True) # NULL allowed, but must be filled out in a form Obviously, Those two options don't make logical sense to use (though there might be a use case for if you want a field to always be required in forms, optional when dealing with an object through something like the shell.) models.CharField(blank=True) # No problem, blank is stored as '' models.CharField(null=True) # NULL allowed, but will never be set as NULL and types are never saved as by Django, so is unnecessary. However, you can manually set one of these fields to to force set it as . If you have a scenario where that might be necessary, you should still include .\n\nIt's crucial to understand that the options in a Django model field definition serve (at least) two purposes: defining the database tables, and defining the default format and validation of model forms. (I say \"default\" because the values can always be overridden by providing a custom form.) Some options affect the database, some options affect forms, and some affect both. When it comes to and , other answers have already made clear that the former affects the database table definition and the latter affects model validation. I think the distinction can be made even clearer by looking at use cases for all four possible configurations:\n• None , : This is the default configuration and means that the value is required in all circumstances.\n• None , : This means that the field is optional in all circumstances. As noted below, though, this is not the recommended way to make string-based fields optional.\n• None , : This means that the form doesn't require a value but the database does. There are a number of use cases for this:\n• None The most common use is for optional string-based fields. As noted in the documentation, the Django idiom is to use the empty string to indicate a missing value. If was also allowed you would end up with two different ways to indicate a missing value. (If the field is also , though, you'll have to use to prevent multiple empty strings from failing the uniqueness check.)\n• None Another common situation is that you want to calculate one field automatically based on the value of another (in your method, say). You don't want the user to provide the value in a form (hence ), but you do want the database to enforce that a value is always provided ( ).\n• None Another use is when you want to indicate that a is optional. Because this field is implemented as a separate table rather than a database column, is meaningless. The value of will still affect forms, though, controlling whether or not validation will succeed when there are no relations.\n• None , : This means that the form requires a value but the database doesn't. This may be the most infrequently used configuration, but there are some use cases for it:\n• None It's perfectly reasonable to require your users to always include a value even if it's not actually required by your business logic. After all, forms are only one way of adding and editing data. You may have code that is generating data that doesn't need the same stringent validation you want to require of a human editor.\n• None Another use case that I've seen is when you have a for which you don't wish to allow cascade deletion. That is, in normal use the relation should always be there ( ), but if the thing it points to happens to be deleted, you don't want this object to be deleted too. In that case you can use and to implement a simple kind of soft deletion.\n\nUnderstanding the difference between and in Django is crucial for beginners, as it affects both database integrity and how forms validate data. Here's a table summarising their key differences and uses: Let me explain it in detail with possible advantages & disadvantages. Allows storing values in the database. It's a database schema-related setting. Advantages: This provides flexibility in database design for non-string fields, allowing \"no data\" to be explicitly stored. Disadvantages: For string fields, can lead to a mix of and empty strings for \"no data\", which is inconsistent also this does not affect the form validation, the field will still be required on forms. Allows the field to be left blank in the forms. It's related to validation in Django forms and the admin interface. This is applicable to all field types, it makes a field optional in forms. Advantages: Enhances user experience by not requiring input in forms for optional fields. Disadvantages: When used with non-string fields, without can lead to upon form submission, as the database expects a value. Also, it does not alter the database schema, so the database layer still expects data. Allows NULL values in the database and makes the field optional in forms. Advantages: This combination offers the greatest flexibility, allowing fields to be optional in both database and form contexts. It's particularly beneficial for non-string fields where a lack of data is best represented by . Disadvantages: For string fields, combining and is generally discouraged to prevent a mix of and empty strings in the database, which can lead to inconsistencies in data representation."
    },
    {
        "link": "https://docs.djangoproject.com/en/5.1/ref/models/fields",
        "document": "This document contains all the API references of including the field options and field types Django offers.\n\nThe following arguments are available to all field types. All are optional. If , Django will store empty values as in the database. Default is . Avoid using on string-based fields such as and . If a string-based field has , that means it has two possible values for “no data”: , and the empty string. In most cases, it’s redundant to have two possible values for “no data;” the Django convention is to use the empty string, not . One exception is when a has both and set. In this situation, is required to avoid unique constraint violations when saving multiple objects with blank values. For both string-based and non-string-based fields, you will also need to set if you wish to permit empty values in forms, as the parameter only affects database storage (see ). When using the Oracle database backend, the value will be stored to denote the empty string regardless of this attribute. If , the field is allowed to be blank. Default is . Note that this is different than . is purely database-related, whereas is validation-related. If a field has , form validation will allow entry of an empty value. If a field has , the field will be required. can be used with fields having , but this will require implementing on the model in order to programmatically supply any missing values. A mapping or iterable in the format described below to use as choices for this field. If choices are given, they’re enforced by model validation and the default form widget will be a select box with these choices instead of the standard text field. If a mapping is given, the key element is the actual value to be set on the model, and the second element is the human readable name. For example: You can also pass a sequence consisting itself of iterables of exactly two items (e.g. ). The first element in each tuple is the actual value to be set on the model, and the second element is the human-readable name. For example: can also be defined as a callable that expects no arguments and returns any of the formats described above. For example: Passing a callable for can be particularly handy when, for example, the choices are:\n• None the result of I/O-bound operations (which could potentially be cached), such as querying a table in the same or an external database, or accessing the choices from a static file.\n• None a list that is mostly stable but could vary from time to time or from project to project. Examples in this category are using third-party apps that provide a well-known inventory of values, such as currencies, countries, languages, time zones, etc. Support for mappings and callables was added. Generally, it’s best to define choices inside a model class, and to define a suitably-named constant for each value: Though you can define a choices list outside of a model class and then refer to it, defining the choices and names for each choice inside the model class keeps all of that information with the class that uses it, and helps reference the choices (e.g, will work anywhere that the model has been imported). You can also collect your available choices into named groups that can be used for organizational purposes: The key of the mapping is the name to apply to the group and the value is the choices inside that group, consisting of the field value and a human-readable name for an option. Grouped options may be combined with ungrouped options within a single mapping (such as the option in this example). You can also use a sequence, e.g. a list of 2-tuples: Note that choices can be any sequence object – not necessarily a list or tuple. This lets you construct choices dynamically. But if you find yourself hacking to be dynamic, you’re probably better off using a proper database table with a . is meant for static data that doesn’t change much, if ever. A new migration is created each time the order of changes. For each model field that has set, Django will normalize the choices to a list of 2-tuples and add a method to retrieve the human-readable name for the field’s current value. See in the database API documentation. Unless is set on the field along with a then a label containing will be rendered with the select box. To override this behavior, add a tuple to containing ; e.g. . Alternatively, you can use an empty string instead of where this makes sense - such as on a . In addition, Django provides enumeration types that you can subclass to define choices in a concise way: These work similar to from Python’s standard library, but with some modifications:\n• None Enum member values are a tuple of arguments to use when constructing the concrete data type. Django supports adding an extra string value to the end of this tuple to be used as the human-readable name, or . The can be a lazy translatable string. Thus, in most cases, the member value will be a 2-tuple. See below for an example of subclassing choices using a more complex data type. If a tuple is not provided, or the last item is not a (lazy) string, the is automatically generated from the member name.\n• None A property is added on values, to return the human-readable name.\n• None A number of custom properties are added to the enumeration classes – , , , and – to make it easier to access lists of those separate parts of the enumeration. These property names cannot be used as member names as they would conflict.\n• None The use of is enforced to ensure that values cannot be defined multiple times. This is unlikely to be expected in choices for a field. Note that using , , or to access or lookup enum members work as expected, as do the and properties on the members. If you don’t need to have the human-readable names translated, you can have them inferred from the member name (replacing underscores with spaces and using title-case): Since the case where the enum values need to be integers is extremely common, Django provides an class. For example: It is also possible to make use of the Enum Functional API with the caveat that labels are automatically generated as highlighted above: [(1, 'First'), (2, 'Second'), (3, 'Third')] If you require support for a concrete data type other than or , you can subclass and the required concrete data type, e.g. for use with : There are some additional caveats to be aware of:\n• None Because an enumeration with a concrete data type requires all values to match the type, overriding the blank label cannot be achieved by creating a member with a value of . Instead, set the attribute on the class: Support for using enumeration types directly in the was added. The name of the database column to use for this field. If this isn’t given, Django will use the field’s name. If your database column name is an SQL reserved word, or contains characters that aren’t allowed in Python variable names – notably, the hyphen – that’s OK. Django quotes column and table names behind the scenes. The database-computed default value for this field. This can be a literal value or a database function, such as : More complex expressions can be used, as long as they are made from literals and database functions: Database defaults cannot reference other fields or models. For example, this is invalid: If both and are set, will take precedence when creating instances in Python code. will still be set at the database level and will be used when inserting rows outside of the ORM or when adding a new field in a migration. If a field has a without a set and no value is assigned to the field, a object is returned as the field value on unsaved model instances. The actual value for the field is determined by the database when the model instance is saved. If , a database index will be created for this field. Use the option instead. Where possible, use the option instead. In nearly all cases, provides more functionality than . may be deprecated in the future. The name of the database tablespace to use for this field’s index, if this field is indexed. The default is the project’s setting, if set, or the of the model, if any. If the backend doesn’t support tablespaces for indexes, this option is ignored. The default value for the field. This can be a value or a callable object. If callable it will be called every time a new object is created. The default can’t be a mutable object (model instance, , , etc.), as a reference to the same instance of that object would be used as the default value in all new model instances. Instead, wrap the desired default in a callable. For example, if you want to specify a default for , use a function: s can’t be used for field options like because they can’t be serialized by migrations. See that documentation for other caveats. For fields like that map to model instances, defaults should be the value of the field they reference ( unless is set) instead of model instances. The default value is used when new model instances are created and a value isn’t provided for the field. When the field is a primary key, the default is also used when the field is set to . The default value can also be set at the database level with . If , the field will not be displayed in the admin or any other . It will also be skipped during model validation. Default is . The argument lets you override the default messages that the field will raise. Pass in a dictionary with keys matching the error messages you want to override. Error message keys include , , , , , and . Additional error message keys are specified for each field in the Field types section below. These error messages often don’t propagate to forms. See Considerations regarding model’s error_messages. Extra “help” text to be displayed with the form widget. It’s useful for documentation even if your field isn’t used on a form. Note that this value is not HTML-escaped in automatically-generated forms. This lets you include HTML in if you so desire. For example: \"Please use the following format: <em>YYYY-MM-DD</em>.\" Alternatively you can use plain text and to escape any HTML special characters. Ensure that you escape any help text that may come from untrusted users to avoid a cross-site scripting attack. If , this field is the primary key for the model. If you don’t specify for any field in your model, Django will automatically add a field to hold the primary key, so you don’t need to set on any of your fields unless you want to override the default primary-key behavior. The type of auto-created primary key fields can be specified per app in or globally in the setting. For more, see Automatic primary key fields. implies and . Only one primary key is allowed on an object. The primary key field is read-only. If you change the value of the primary key on an existing object and then save it, a new object will be created alongside the old one. The primary key field is set to when an object. If , this field must be unique throughout the table. This is enforced at the database level and by model validation. If you try to save a model with a duplicate value in a field, a will be raised by the model’s method. This option is valid on all field types except and . Note that when is , you don’t need to specify , because implies the creation of an index. Like , but requires the field to be unique with respect to the month. A human-readable name for the field. If the verbose name isn’t given, Django will automatically create it using the field’s attribute name, converting underscores to spaces. See Verbose field names. A list of validators to run for this field. See the validators documentation for more information."
    },
    {
        "link": "https://reddit.com/r/django/comments/1hr5nez/understanding_nulltrue_vs_blanktrue",
        "document": "What is the difference between null=True and blank=True in Django models? Can they be used together?"
    },
    {
        "link": "https://medium.com/@maruthurnavin/handling-empty-and-optional-fields-in-django-b7ef7979e83e",
        "document": "Django, a popular web framework for Python, offers a robust and flexible way to define database models for your applications. When working with Django models, you’ll often come across two attributes, null=True and blank=True, used to define the behavior of fields. But what exactly do they mean, and when should you use one over the other?\n\nLet’s delve into the distinctions and practical applications of null=True and blank=True.\n\nThe null attribute is all about how the field is treated at the database level. When you set null=True, you’re telling Django that the database should allow this field to have empty or missing values, typically represented as NULL in the database.\n\nHere are some scenarios where null=True is commonly used:\n• Optional Fields: Fields that don’t need to be filled for every database record. For example, a user’s middle name may be optional, so it can be set as null=True.\n• Foreign Keys: When defining foreign key relationships, null=True is useful if you want to allow records to exist without a related foreign key.\n\nIn contrast, blank is a validation-level attribute that primarily affects form and model form validation. Setting blank=True means that a field is not required when a form is submitted, allowing users to leave it empty without triggering a validation error.\n• Optional Form Fields: If you want to make certain fields optional in forms, use blank=True. For instance, a user registration form might allow users to leave their “Phone Number” field empty.\n• Model Forms: When creating forms based on models using Django’s ModelForm class, blank=True ensures that the field is not mandatory in the generated form.\n• User Profiles: Fields like a user’s biography or optional personal information can be made optional in forms using blank=True.\n\nUsing Both null=True and blank=True\n\nIn some situations, it makes sense to use both attributes. For example, consider a Article model:\n\nIn this example, it is possible for an article to not have a publication date. For example, an article may be a draft and not yet have a publication date. By setting the field to and , we are allowing authors to optionally enter a publication date in forms and to store it as in the database.In general, it is a good practice to use and for fields that may not always have a value. This allows your database to be more flexible and to accommodate different types of data.\n\nIt is important to note that CharFields and TextFields are never saved as in the Django database. Instead, blank values are stored as an empty string (''). Using an empty string in CharFields and TextFields keeps the data type consistent. All values in the field are strings, which can simplify data processing and avoid potential issues with different data types.\n\nIn conclusion, understanding when to use null=True and blank=True is crucial for building efficient and user-friendly Django applications. These attributes give you fine-grained control over how your data is stored in the database and how it’s validated in forms, ensuring your application behaves exactly as intended.\n\nSo, when defining your Django models, consider your data storage requirements and form validation needs, and make use of null=True and blank=True accordingly to create a well-rounded and adaptable application."
    }
]