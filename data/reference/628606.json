[
    {
        "link": "https://geeksforgeeks.org/input-validation-in-python-string",
        "document": "In Python, string input validation helps ensure that the data provided by the user or an external source is clean, secure and matches the required format. In this article, we'll explore how to perform input validation in Python and best practices for ensuring that strings are correctly validated.\n\nPython offers several techniques for string input validation. Depending on the requirement, the type of validation may vary. Here are the common types of string validation:\n\nThe first step in validating any input is ensuring that it is of the correct type. In Python, we can use the isinstance() function to check if the input is a string.\n\nThis basic validation ensures that the input is a string. However, more complex validations are often needed as strings can also contain unwanted characters or formats.\n\nSometimes, we need to ensure that the user provides a non-empty input. This is useful, for example, in user registration forms where certain fields must not be left blank.\n\nIn this case, the strip() method removes leading and trailing spaces, ensuring that the input is not just spaces.\n\nFor many applications such as password creation, usernames or IDs, strings should fall within a certain length range. We can use Python’s built-in len() function to validate string length.\n\nThis validation ensures that the input length is within the defined limits.\n\nOften inputs need to follow a particular pattern such as email addresses, phone numbers or zip codes. Python's re module (regular expressions) is a powerful tool for such validations.\n\nIn this example, the regular expression checks if the string is a valid email address format. Regular expressions can be tailored to any validation pattern such as phone numbers, dates and more."
    },
    {
        "link": "https://geeksforgeeks.org/password-validation-in-python",
        "document": "Let’s take a password as a combination of alphanumeric characters along with special characters, and check whether the password is valid or not with the help of few conditions. Conditions for a valid password are:\n• Should have at least one number.\n• Should have at least one uppercase and one lowercase character.\n• Should have at least one special symbol.\n• Should be between 6 to 20 characters long.\n\nWe can check if a given string is eligible to be a password or not using multiple ways. Method #1: Naive Method (Without using Regex).\n\nThis code used boolean functions to check if all the conditions were satisfied or not. We see that though the complexity of the code is basic, the length is considerable. Method #2: Using regex compile() method of Regex module makes a Regex object, making it possible to execute regex functions onto the pat variable. Then we check if the pattern defined by pat is followed by the input string passwd. If so, the search method returns true, which would allow the password to be valid.\n\nUsing ascii values and for loop:\n\nThis code uses a function that checks if a given password satisfies certain conditions. It uses a single for loop to iterate through the characters in the password string, and checks if the password contains at least one digit, one uppercase letter, one lowercase letter, and one special symbol from a predefined list and based on ascii values. It sets a boolean variable “val” to True if all these conditions are satisfied, and returns “val” at the end of the function.\n\nThe time complexity of this code is O(n), where n is the length of the password string. The space complexity is O(1), as the size of the variables used in the function does not depend on the size of the input."
    },
    {
        "link": "https://stackoverflow.com/questions/75297067/username-and-password-validation-with-user-input",
        "document": "Im very new to python and I am creating a user login system, I am currently on a bit of creating a username and password with user input that must meet some conditions e.g\n• Cannot contain any spaces\n• Must be at least 5 characters\n\nYour system must display a message to the user telling them what they did wrong if they did not meet one or more of these criteria (so you will need at least 4 error messages).\n\nMy code is as below, but surely theress a better way to do this?"
    },
    {
        "link": "https://reddit.com/r/learnpython/comments/riija3/what_is_the_correct_way_to_validate_user_input",
        "document": "What is the optimal way in which one would validate and handle invalid input for something like the following example?\n\netc. How do you efficiently validate the input and ask again? Without countless if statements etc."
    },
    {
        "link": "https://linkedin.com/advice/3/how-do-you-use-python-string-methods-validate-jv8ge",
        "document": ""
    },
    {
        "link": "https://flask.palletsprojects.com/en/stable/patterns/wtforms",
        "document": "When you have to work with form data submitted by a browser view, code quickly becomes very hard to read. There are libraries out there designed to make this process easier to manage. One of them is WTForms which we will handle here. If you find yourself in the situation of having many forms, you might want to give it a try.\n\nWhen you are working with WTForms you have to define your forms as classes first. I recommend breaking up the application into multiple modules (Large Applications as Packages) for that and adding a separate module for the forms.\n\nGetting the most out of WTForms with an Extension The Flask-WTF extension expands on this pattern and adds a few little helpers that make working with forms and Flask more fun. You can get it from PyPI.\n\nIn the view function, the usage of this form looks like this: Notice we’re implying that the view is using SQLAlchemy here (SQLAlchemy in Flask), but that’s not a requirement, of course. Adapt the code as necessary.\n• None create the form from the request value if the data is submitted via the HTTP method and if the data is submitted as .\n• None to validate the data, call the method, which will return if the data validates, otherwise.\n• None to access individual values from the form, access .\n\nNow to the template side. When you pass the form to the templates, you can easily render them there. Look at the following example template to see how easy this is. WTForms does half the form generation for us already. To make it even nicer, we can write a macro that renders a field with label and a list of errors if there are any. Here’s an example template with such a macro: This macro accepts a couple of keyword arguments that are forwarded to WTForm’s field function, which renders the field for us. The keyword arguments will be inserted as HTML attributes. So, for example, you can call to add a class to the input element. Note that WTForms returns standard Python strings, so we have to tell Jinja2 that this data is already HTML-escaped with the filter. Here is the template for the function we used above, which takes advantage of the template: For more information about WTForms, head over to the WTForms website."
    },
    {
        "link": "https://docs.djangoproject.com/en/5.1/topics/forms",
        "document": "Unless you’re planning to build websites and applications that do nothing but publish content, and don’t accept input from your visitors, you’re going to need to understand and use forms.\n\nDjango provides a range of tools and libraries to help you build forms to accept input from site visitors, and then process and respond to the input.\n\nIn HTML, a form is a collection of elements inside that allow a visitor to do things like enter text, select options, manipulate objects or controls, and so on, and then send that information back to the server. Some of these form interface elements - text input or checkboxes - are built into HTML itself. Others are much more complex; an interface that pops up a date picker or allows you to move a slider or manipulate controls will typically use JavaScript and CSS as well as HTML form elements to achieve these effects. As well as its elements, a form must specify two things:\n• None where: the URL to which the data corresponding to the user’s input should be returned\n• None how: the HTTP method the data should be returned by As an example, the login form for the Django admin contains several elements: one of for the username, one of for the password, and one of for the “Log in” button. It also contains some hidden text fields that the user doesn’t see, which Django uses to determine what to do next. It also tells the browser that the form data should be sent to the URL specified in the ’s attribute - - and that it should be sent using the HTTP mechanism specified by the attribute - . When the element is triggered, the data is returned to . and are the only HTTP methods to use when dealing with forms. Django’s login form is returned using the method, in which the browser bundles up the form data, encodes it for transmission, sends it to the server, and then receives back its response. , by contrast, bundles the submitted data into a string, and uses this to compose a URL. The URL contains the address where the data must be sent, as well as the data keys and values. You can see this in action if you do a search in the Django documentation, which will produce a URL of the form . and are typically used for different purposes. Any request that could be used to change the state of the system - for example, a request that makes changes in the database - should use . should be used only for requests that do not affect the state of the system. would also be unsuitable for a password form, because the password would appear in the URL, and thus, also in browser history and server logs, all in plain text. Neither would it be suitable for large quantities of data, or for binary data, such as an image. A web application that uses requests for admin forms is a security risk: it can be easy for an attacker to mimic a form’s request to gain access to sensitive parts of the system. , coupled with other protections like Django’s CSRF protection offers more control over access. On the other hand, is suitable for things like a web search form, because the URLs that represent a request can easily be bookmarked, shared, or resubmitted.\n\nHandling forms is a complex business. Consider Django’s admin, where numerous items of data of several different types may need to be prepared for display in a form, rendered as HTML, edited using a convenient interface, returned to the server, validated and cleaned up, and then saved or passed on for further processing. Django’s form functionality can simplify and automate vast portions of this work, and can also do it more securely than most programmers would be able to do in code they wrote themselves. Django handles three distinct parts of the work involved in forms:\n• None preparing and restructuring data to make it ready for rendering\n• None receiving and processing submitted forms and data from the client It is possible to write code that does all of this manually, but Django can take care of it all for you.\n\nWe’ve described HTML forms briefly, but an HTML is just one part of the machinery required. In the context of a web application, ‘form’ might refer to that HTML , or to the Django that produces it, or to the structured data returned when it is submitted, or to the end-to-end working collection of these parts. At the heart of this system of components is Django’s class. In much the same way that a Django model describes the logical structure of an object, its behavior, and the way its parts are represented to us, a class describes a form and determines how it works and appears. In a similar way that a model class’s fields map to database fields, a form class’s fields map to HTML form elements. (A maps a model class’s fields to HTML form elements via a ; this is what the Django admin is based upon.) A form’s fields are themselves classes; they manage form data and perform validation when a form is submitted. A and a handle very different kinds of data and have to do different things with it. A form field is represented to a user in the browser as an HTML “widget” - a piece of user interface machinery. Each field type has an appropriate default Widget class, but these can be overridden as required. When rendering an object in Django, we generally:\n• None get hold of it in the view (fetch it from the database, for example)\n• None pass it to the template context\n• None expand it to HTML markup using template variables Rendering a form in a template involves nearly the same work as rendering any other kind of object, but there are some key differences. In the case of a model instance that contained no data, it would rarely if ever be useful to do anything with it in a template. On the other hand, it makes perfect sense to render an unpopulated form - that’s what we do when we want the user to populate it. So when we handle a model instance in a view, we typically retrieve it from the database. When we’re dealing with a form we typically instantiate it in the view. When we instantiate a form, we can opt to leave it empty or prepopulate it, for example with:\n• None data from a saved model instance (as in the case of admin forms for editing)\n• None data that we have collated from other sources The last of these cases is the most interesting, because it’s what makes it possible for users not just to read a website, but to send information back to it too.\n\nThe work that needs to be done¶ Suppose you want to create a simple form on your website, in order to obtain the user’s name. You’d need something like this in your template: This tells the browser to return the form data to the URL , using the method. It will display a text field, labeled “Your name:”, and a button marked “OK”. If the template context contains a variable, that will be used to pre-fill the field. You’ll need a view that renders the template containing the HTML form, and that can supply the field as appropriate. When the form is submitted, the request which is sent to the server will contain the form data. Now you’ll also need a view corresponding to that URL which will find the appropriate key/value pairs in the request, and then process them. This is a very simple form. In practice, a form might contain dozens or hundreds of fields, many of which might need to be prepopulated, and we might expect the user to work through the edit-submit cycle several times before concluding the operation. We might require some validation to occur in the browser, even before the form is submitted; we might want to use much more complex fields, that allow the user to do things like pick dates from a calendar and so on. At this point it’s much easier to get Django to do most of this work for us. We already know what we want our HTML form to look like. Our starting point for it in Django is this: This defines a class with a single field ( ). We’ve applied a human-friendly label to the field, which will appear in the when it’s rendered (although in this case, the we specified is actually the same one that would be generated automatically if we had omitted it). The field’s maximum allowable length is defined by . This does two things. It puts a on the HTML (so the browser should prevent the user from entering more than that number of characters in the first place). It also means that when Django receives the form back from the browser, it will validate the length of the data. A instance has an method, which runs validation routines for all its fields. When this method is called, if all fields contain valid data, it will:\n• None place the form’s data in its attribute. The whole form, when rendered for the first time, will look like: Note that it does not include the tags, or a submit button. We’ll have to provide those ourselves in the template. Form data sent back to a Django website is processed by a view, generally the same view which published the form. This allows us to reuse some of the same logic. To handle the form we need to instantiate it in the view for the URL where we want it to be published: # if this is a POST request we need to process the form data # create a form instance and populate it with data from the request: # process the data in form.cleaned_data as required # if a GET (or any other method) we'll create a blank form If we arrive at this view with a request, it will create an empty form instance and place it in the template context to be rendered. This is what we can expect to happen the first time we visit the URL. If the form is submitted using a request, the view will once again create a form instance and populate it with data from the request: This is called “binding data to the form” (it is now a bound form). We call the form’s method; if it’s not , we go back to the template with the form. This time the form is no longer empty (unbound) so the HTML form will be populated with the data previously submitted, where it can be edited and corrected as required. If is , we’ll now be able to find all the validated form data in its attribute. We can use this data to update the database or do other processing before sending an HTTP redirect to the browser telling it where to go next. We don’t need to do much in our template: All the form’s fields and their attributes will be unpacked into HTML markup from that by Django’s template language. Django ships with an easy-to-use protection against Cross Site Request Forgeries. When submitting a form via with CSRF protection enabled you must use the template tag as in the preceding example. However, since CSRF protection is not directly tied to forms in templates, this tag is omitted from the following examples in this document. If your form includes a , an or any integer field type, Django will use the , and HTML5 input types. By default, browsers may apply their own validation on these fields, which may be stricter than Django’s validation. If you would like to disable this behavior, set the attribute on the tag, or specify a different widget on the field, like . We now have a working web form, described by a Django , processed by a view, and rendered as an HTML . That’s all you need to get started, but the forms framework puts a lot more at your fingertips. Once you understand the basics of the process described above, you should be prepared to understand other features of the forms system and ready to learn a bit more about the underlying machinery.\n\nAll form classes are created as subclasses of either or . You can think of as a subclass of . and actually inherit common functionality from a (private) class, but this implementation detail is rarely important. In fact if your form is going to be used to directly add or edit a Django model, a ModelForm can save you a great deal of time, effort, and code, because it will build a form, along with the appropriate fields and their attributes, from a class. The distinction between Bound and unbound forms is important:\n• None An unbound form has no data associated with it. When rendered to the user, it will be empty or will contain default values.\n• None A bound form has submitted data, and hence can be used to tell if that data is valid. If an invalid bound form is rendered, it can include inline error messages telling the user what data to correct. The form’s attribute will tell you whether a form has data bound to it or not. Consider a more useful form than our minimal example above, which we could use to implement “contact me” functionality on a personal website: Our earlier form used a single field, , a . In this case, our form has four fields: , , and . , and are just three of the available field types; a full list can be found in Form fields. Each form field has a corresponding Widget class, which in turn corresponds to an HTML form widget such as . In most cases, the field will have a sensible default widget. For example, by default, a will have a widget, that produces an in the HTML. If you needed instead, you’d specify the appropriate widget when defining your form field, as we have done for the field. Whatever the data submitted with a form, once it has been successfully validated by calling (and has returned ), the validated form data will be in the dictionary. This data will have been nicely converted into Python types for you. You can still access the unvalidated data directly from at this point, but the validated data is better. In the contact form example above, will be a boolean value. Likewise, fields such as and convert values to a Python and respectively. Here’s how the form data could be processed in the view that handles this form: For more on sending email from Django, see Sending email. Some field types need some extra handling. For example, files that are uploaded using a form need to be handled differently (they can be retrieved from , rather than ). For details of how to handle file uploads with your form, see Binding uploaded files to a form.\n\nAll you need to do to get your form into a template is to place the form instance into the template context. So if your form is called in the context, will render its and elements appropriately. Don’t forget that a form’s output does not include the surrounding tags, or the form’s control. You will have to provide these yourself. The HTML output when rendering a form is itself generated via a template. You can control this by creating an appropriate template file and setting a custom to use that site-wide. You can also customize per-form by overriding the form’s attribute to render the form using the custom template, or by passing the template name directly to . The example below will result in being rendered as the output of the template. # In your template: # In form_snippet.html: Then you can configure the setting: … or for a single render of a form instance, passing in the template name to the . Here’s an example of this being used in a view: See Outputting forms as HTML for more details. Each field is available as an attribute of the form, using in a template. A field has a method which renders the related elements of the field as a group, its label, widget, errors, and help text. This allows generic templates to be written that arrange fields elements in the required layout. For example: By default Django uses the template which is designed for use with the default form style. The default template can be customized by setting in your project-level : … or on a per-request basis by calling and supplying a template name: More fine grained control over field rendering is also possible. Likely this will be in a custom field template, to allow the template to be written once and reused for each field. However, it can also be directly accessed from the field attribute on the form. For example: Email subject: Your message: Your email address: CC yourself? Complete elements can also be generated using the . For example: The price of this flexibility is a bit more work. Until now we haven’t had to worry about how to display form errors, because that’s taken care of for us. In this example we have had to make sure we take care of any errors for each field and any errors for the form as a whole. Note at the top of the form and the template lookup for errors on each field. Using displays a list of form errors, rendered as an unordered list. This might look like: The list has a CSS class of to allow you to style its appearance. If you wish to further customize the display of errors you can do so by looping over them: Non-field errors (and/or hidden field errors that are rendered at the top of the form when using helpers like ) will be rendered with an additional class of to help distinguish them from field-specific errors. For example, would look like: See The Forms API for more on errors, styling, and working with form attributes in templates. If you’re using the same HTML for each of your form fields, you can reduce duplicate code by looping through each field in turn using a loop: Outputs a containing any validation errors corresponding to this field. You can customize the presentation of the errors with a loop. In this case, each object in the loop is a string containing the error message. The instance from the form class that this wraps. You can use it to access attributes, e.g. . Any help text that has been associated with the field. The name of the field that will be used in the input element’s name field. This takes the form prefix into account, if it has been set. The ID that will be used for this field ( in the example above). If you are constructing the label manually, you may want to use this in lieu of . It’s also useful, for example, if you have some inline JavaScript and want to avoid hardcoding the field’s ID. This attribute is if the form field is a hidden field and otherwise. It’s not particularly useful as a template variable, but could be useful in conditional tests such as: The label of the field, e.g. . The field’s label wrapped in the appropriate HTML tag. This includes the form’s . For example, the default is a colon: Similar to but uses a tag in place of , for widgets with multiple inputs wrapped in a . This attribute is if the form field’s widget contains multiple inputs that should be semantically grouped in a with a to improve accessibility. An example use in a template: The value of the field. e.g . For a complete list of attributes and methods, see . If you’re manually laying out a form in a template, as opposed to relying on Django’s default form layout, you might want to treat fields differently from non-hidden fields. For example, because hidden fields don’t display anything, putting error messages “next to” the field could cause confusion for your users – so errors for those fields should be handled differently. Django provides two methods on a form that allow you to loop over the hidden and visible fields independently: and . Here’s a modification of an earlier example that uses these two methods: This example does not handle any errors in the hidden fields. Usually, an error in a hidden field is a sign of form tampering, since normal form interaction won’t alter them. However, you could easily insert some error displays for those form errors, as well."
    },
    {
        "link": "https://scrapeops.io/python-web-scraping-playbook/python-how-to-submit-forms",
        "document": "How To Submit a Form With Python: Exploring Various Methods\n\nForm submission is a fundamental aspect of web development and automation. It allows you to interact with web applications and automate repetitive tasks. Python offers a multitude of methods for programmatically submitting forms. Each of these methods caters to different use cases and requirements.\n\nIn this article, we will dive into various approaches for submitting forms using Python and provide detailed steps and examples for each method.\n• TL :DR - How To Submit A Form With Python\n\nHere is a simple script to submit a form with Python:\n\nIn the script above:\n• First, we import the necessary libraries, mainly , which allows us to make HTTP requests in Python.\n• Next, we prepare the headers. These headers provide essential information about our request. For instance, we specify the content type as , which is sometimes required for form submissions.\n• Then, we gather the form data we want to submit. This includes the username and password that we want to use for logging in. We identify the URL where we want to submit this form data. This is usually the endpoint where the login form is processed.\n• With everything set up, we initiate a session using . This helps us manage cookies and maintain the session state as we interact with the website.\n• Now, we send a POST request to the URL, supplying the form data and headers we prepared earlier. This simulates filling out and submitting the login form on the website.\n• Once we receive a response from the server, we check if the status code is 200, indicating a successful request. If it is, we examine the response text to see if it contains the expected message confirming that the login was successful.\n\nLet us dive into the next sections for more more explanation and ways to submit forms with Python.\n\nForm submission is a fundamental aspect of web development, allowing users to send data to the server. This process typically involves HTML forms on the front end and server-side scripts that process the submitted data.\n\nAt the heart of user interaction lies the HTML form – a quintessential component that enables users to input data and transmit it to a server for processing.\n\nIt comprises various elements that facilitate this exchange, each serving a distinct purpose in gathering user information:\n\nThese are the building blocks of forms, allowing you to input text, numbers, dates, and more.\n\nInput fields come in diverse types such as text, password, checkbox, radio, and file upload, catering to different data requirements.\n\nFor example, the following screenshot shows an input text and password, respectively, on the test login page.\n\nThe inputs are build from the following part of the code:\n\nButtons within forms serve as triggers for actions like form submission, reset, or custom JavaScript functions. It is essential in initiating the transmission of form data to the server.\n\nDropdown menus and selection boxes offer users predefined choices, streamlining data input and ensuring consistency in submitted information.\n\nLabels provide descriptive text accompanying form elements, enhancing accessibility and user understanding. Additionally, descriptive elements like placeholders and tooltips offer further guidance to users.\n\nThese include elements like checkboxes, radio buttons, and switches, allowing users to make selections or toggle options within the form.\n\nWhen a user fills out a form and clicks the submit button, a series of behind-the-scenes processes come into play, orchestrated by the Hypertext Transfer Protocol (HTTP).\n\nAmong the various HTTP methods, the POST method stands out as the primary mechanism for transmitting form data to a web server.\n\nUnlike the GET method , which appends form data to the URL, exposing it to potential security risks and size limitations, the POST method discreetly sends data within the body of the HTTP request.\n\nBy not showing on the URL the data being submitted, POST ensures privacy and security, making it ideal for transmitting sensitive information like passwords or payment details.\n\nUpon submitting a form using the POST method, the browser constructs an HTTP request containing the form data and dispatches it to the designated server endpoint.\n\nThe server then processes the incoming data, executing predefined actions such as storing it in a database, performing calculations, or generating dynamic content based on user inputs.\n\nWe'll explore multiple methods for submitting forms with Python. These methods cater to various scenarios, from simple HTTP requests to complex browser automation tasks. The methods include:\n• Using the Requests library: Using the Requests library for making HTTP requests and directly submitting forms.\n• Browser Automation with Selenium WebDriver: Automating browser interactions to locate form elements, fill out forms, and submit them programmatically.\n• Automating Browser Interactions with Mechanize Library: Utilizing the Mechanize library to automate browser interactions and handle form submissions.\n• Web Scraping Approach with Beautiful Soup and Requests: Leveraging Beautiful Soup and Requests for parsing HTML forms and submitting form data during web scraping.\n• Headless Browsing with Pyppeteer and Playwright: Exploring headless browser automation using Pyppeteer and Playwright libraries for form submission.\n• Form Submission in Web Scraping with Scrapy Framework: Integrating form submission into Scrapy spiders for web scraping tasks.s\n• Advanced Techniques and Libraries: Exploring additional methods and libraries for form submission in Python.\n\nThe requests library is a powerful tool for making HTTP requests in Python, known for its simplicity and ease of use.\n\nIn this section, we'll demonstrate how to submit forms directly using Requests, covering essential concepts such as POST requests, form parameters, and headers.\n\nAdditionally, we'll illustrate how to handle form submissions with different authentication mechanisms and discuss strategies for handling file uploads and multipart form data submissions.\n\nTo submit a form using the Requests library, use the method. Here's a basic example of how to submit a form:\n\nIn this example, we define the form URL and the form data as a dictionary. The function sends a POST request to the specified URL with the provided data. The response object contains the server's response to the HTTP request.\n\nIf you would like to master POST requests in requests library, check our Python Requests: How to Send POST Requests article.\n\nA object allows you to persist certain parameters across multiple requests. It is particularly useful when you need to maintain cookies or set headers that should be included with every request. Here's how you can use to submit a form:\n• In this example, we use a object to persist headers across requests.\n• This is particularly useful for maintaining the same header, which some websites check to identify the client making the request.\n• Without the header, the server might respond with a status code, indicating that the server cannot produce a response matching the list of acceptable values defined in the request's headers.\n\nAuthentication is a crucial aspect of web application security. It ensures that only authorized users can access certain resources.\n\nTwo common methods of authentication are Basic Authentication and Token-Based Authentication.\n\nBasic authentication involves sending a username and password with your HTTP request. Requests makes this straightforward:\n• In this example, we use to add basic authentication to our request.\n• We include the credentials by passing to the parameter in .\n\nToken-Based Authentication involves issuing a token to the user after a successful login. The token is then used to authenticate subsequent requests.\n\nFor token-based authentication, you include a token in the request headers. Here's how to do it:\n• We retrieve the value of the environment variable using and include it in the header as a Bearer token.\n• This token is crucial as it allows the server to verify our identity and permissions.\n• We then call the method with the URL, form data, and headers, making the authenticated request to the server.\n\nWhen dealing with file uploads, you need to use multi-part form data. Requests simplifies this with its support for file uploads:\n\nIn this example, the parameter is a dictionary where the key is the form field name, and the value is a file object. The parameter is used to send additional form data.\n\nIf you want to learn more about how to use requests or web scraping with Python in general then check out our Requests Guide or our Python Beginners Web Scraping Guide.\n\nSelenium WebDriver stands out as a top contender in the realm of automating browser interactions. Whether it's testing web applications or scraping data, Selenium's flexibility and robustness make it a go-to choice for developers and testers alike.\n\nIn this section, we'll use the power of Selenium WebDriver to streamline form interactions within your automated workflows.\n\nBefore we can interact with any form, we need to locate its elements on the webpage. Selenium provides various methods to accomplish this, such as .\n\nYou can either use CSS selectors or XPath selectors to locate elements in Selenium.\n\nLet's take a look at a simple example of locating and interacting with a text input field using Python:\n• To locate a form element on the webpage, we use Selenium's method with the class to specify the locating strategy.\n• In this example, we target a text input field using . Specifically, we call , which tells Selenium to find the element with the attribute \"username\".\n• Once located, we can interact with this element, such as sending text to it with the method.\n\nOnce we've located the form elements, filling out and submitting the form programmatically is straightforward. We use the method to input data into the form fields and the or button methods to submit the form.\n\nHere's how we can achieve this:\n\nModern web applications often rely on JavaScript to dynamically generate form elements. Selenium excels in handling such scenarios by allowing us to wait for specific conditions to be met before interacting with the elements.\n\nWe can use explicit waits or implicit waits to ensure that the elements are present, visible, or clickable before proceeding.\n\nHere's an example using explicit wait when bypassing DataDome using Selenium:\n\nIn some cases, forms may require interaction with multiple elements or iFrames. Selenium provides methods to switch between frames and interact with nested elements seamlessly.\n\nHere's a basic example of switching to an iframe and interacting with its elements:\n\nYou can check out our extensive Submitting Forms with Selenium in Python guide to harness the full potential of Selenium to navigate and interact with web forms.\n\nWhen it comes to automating browser interactions with ease and flexibility, the Mechanize library emerges as a reliable solution. Built on top of Python, Mechanize offers a convenient interface for simulating browser sessions, navigating webpages, and interacting with HTML forms programmatically.\n\nMechanize simplifies the process of handling form submission by providing intuitive methods for locating form elements, filling them out, and submitting them seamlessly.\n\nLet's dive into a basic example demonstrating how to submit a form using Mechanize:\n• In this example, we use to create a browser instance that can simulate a web browser.\n• We open the target webpage using .\n• We select the form on the page using , where indicates the first form on the page.\n• We fill out the form fields by assigning values to and .\n• We submit the form using , which sends the filled-out form data to the server.\n• Finally, we print the server's response using to see the result of the form submission.\n\nMechanize simplifies handling authentication challenges and redirects encountered during form submission. It automatically manages cookies and sessions, allowing seamless navigation through authentication prompts and redirections.\n\nDealing with form validation errors is a common challenge in web automation. Mechanize provides mechanisms to detect and handle such errors gracefully. By inspecting the response after form submission, we can identify validation errors and adjust our automation logic accordingly.\n\nHere's an example demonstrating error handling with Mechanize:\n\nCross-Site Request Forgery (CSRF) is a security vulnerability that tricks a user into performing actions they did not intend to on a different website where they are authenticated.\n\nTo protect against CSRF, web applications often include tokens or special headers in forms and requests to ensure that the request is legitimate and originated from the correct user.\n\nWhen automating form submissions with a tool like Mechanize, bypassing these CSRF protections can be challenging because the automation script must replicate the behavior of a legitimate user. Here’s how you can handle it:\n• CSRF Tokens: These are unique, secret values included in forms. When a form is submitted, the server checks that the token matches what it expects. If it doesn’t, the request is rejected.\n• Custom Headers: Some web applications use custom HTTP headers that must be included in requests to validate them.\n• Fetch the Form: First, you need to make a GET request to the page containing the form. This request should retrieve the CSRF token embedded in the form.\n• Extract the CSRF Token: Parse the response to extract the CSRF token from the form. This typically involves parsing the HTML to find the token value.\n• Submit the Form: Use Mechanize to fill in the form fields, including the extracted CSRF token, and submit the form.\n\nLet's say you have a web page with a form that includes a CSRF token as a hidden input field:\n\nHere’s how you can automate this with Mechanize in Python:\n• We open the login page using .\n• We read the response and parse it with to easily extract the CSRF token.\n• We find the CSRF token in the form by searching for the input field with the name and get its value.\n• We select the form on the page using .\n• We fill in the form fields by setting , , and the extracted .\n\nBeautiful Soup, in conjunction with Requests, offers a powerful solution for web scraping and form submission. This combination allows you to easily extract and manipulate HTML content from web pages.\n\nTo start with, you need to fetch the HTML content of a web page using the Requests library. Once you have the HTML content, you can use Beautiful Soup to parse the HTML and extract the necessary form data.\n• In this example, we use Requests to fetch the HTML content of the form page.\n• Beautiful Soup is then used to parse the HTML, allowing us to locate the form using .\n• We then extract all input fields and their values into a dictionary, making it easy to manipulate or submit the form data later.\n\nOnce you have the form data, you can submit the form using the Requests library. The following example shows how to achieve this:\n\nIn this case, we modify the form data by adding or updating fields as necessary. We then determine the form's action URL, which specifies where to submit the form. Using , we submit the form data to the server and handle the response.\n\nWeb pages often have complex HTML structures, making it necessary to navigate through multiple levels of nested elements to locate and interact with form elements. Beautiful Soup provides several methods to handle this effectively:\n\nIn this example, we locate the form by its ID and find specific input fields (within the form) by their name attributes.\n\nWe prepare the form data, including any hidden inputs, ensuring that all necessary fields are included for the form submission.\n\nIf you would like to learn more about how to use BeautifulSoup then check out our other BeautifulSoup Guide: Scraping HTML Pages With Python guide.\n\nIn the world of headless browser automation, Pyppeteer and Playwright are two standout libraries that have simplified the task significantly. These tools are perfect for scenarios where graphical user interface (GUI) interaction is unnecessary, such as automated testing, scraping, and form submission.\n\nPlaywright, a newer and more versatile library compared to Pyppeteer, supports multiple browser engines including Chromium, Firefox, and WebKit.\n\nThis makes it a powerful tool for ensuring your web applications work across different browsers.\n\nLet's start with setting up a headless browser using Playwright. First, install Playwright then download headless browsers using the following commands:\n\nHere's a simple example of launching a Chromium browser, navigating to a webpage, and interacting with a form:\n\nIn this example, we launch a Chromium browser in headless mode, navigate to the OpenCart admin login page, fill in the username and password fields, and submit the form.\n\nSubmitting forms programmatically is straightforward with Playwright. The method allows us to input data into form fields, and the method is used to simulate clicking the submit button.\n\nThese methods ensure that the form is filled and submitted just as if a user were interacting with it. The headless mode of the browser means these actions happen in the background without any GUI.\n\nDifferent browsers can behave differently due to variations in their rendering engines and JavaScript implementations. Playwright's support for multiple browsers helps us address these quirks by allowing us to test our automation scripts across various browser engines.\n\nFor instance, to test the same form submission in Firefox, we only need to change the browser initialization:\n\nBy running our scripts in different browsers, we can identify and handle browser-specific issues early in the development cycle. Playwright also offers a parameter, which can slow down the automation speed to help us observe what’s happening:\n\nSetting to and adding can be incredibly useful for debugging, allowing us to see the browser actions as they occur in real-time.\n\nWhen it comes to web scraping, the Scrapy framework is a game-changer. Not only does it make extracting data from static pages a breeze, but it also handles more complex tasks like form submissions with ease.\n\nTo begin, we'll need to set up a Scrapy spider capable of handling form submissions. The following example demonstrates how to integrate form submission into a Scrapy spider.\n\nFirst, we need to install Scrapy if we haven't done so already:\n\nWithin our project, we'll generate a new spider:\n\nHere's how we can modify our spider to handle form submissions:\n\nIn this example, our starts by navigating to a form page. Using the method, we submit the form with the necessary credentials. The method handles the response, checking for successful authentication before stopping the crawling engine.\n\nTo process the data extracted after form submission, we can use Scrapy pipelines. Pipelines allow us to clean, validate, and store the data as needed. Let's set up a simple pipeline:\n\nFirst, we enable the pipeline in our :\n\nNext, we create the pipeline class in :\n\nThis pipeline processes each item, performing any necessary cleaning or transformations before storing it.\n\nIn some cases, we might need to schedule form submissions to avoid overloading the server or to mimic human behavior. Scrapy's and classes can help with this.\n\nHere's an example of how to schedule form submissions using :\n\nIn this example, we use with rules to schedule form submissions and subsequent data extraction. The method handles the form submission, and continues the scraping process upon successful login.\n\nScrapy supports asynchronous requests, which can be particularly useful for handling form submissions that involve AJAX or other asynchronous interactions. By using Scrapy's in conjunction with callbacks, we can manage these asynchronous processes efficiently.\n\nIn this example, submits a form asynchronously and handles the response in . This method allows us to handle complex interactions that occur after form submission, ensuring we capture all relevant data.\n\nIf you would like to learn more about logging into websites using Scrapy, then be sure to check out Python Scrapy Login Forms guide.\n\nIn this section, we'll cover advanced techniques and lesser-known libraries for form submission in Python. By exploring these methods, we'll help you choose the most suitable approach for your projects based on performance and complexity.\n\nis a modern, user-friendly, and high-performance HTTP client library that provides a clean and intuitive API for making HTTP requests. It supports both synchronous and asynchronous programming styles, making it suitable for various use cases, including web scraping, API consumption, and more.\n\nNot only does it support GET and POST requests. Here is an example code snippet showing you how to submit forms with Python's library:\n• In this example, we submit form data in Python using the library combined with asyncio for asynchronous HTTP requests.\n• We define an asynchronous function, , which utilizes an to post form data to the specified URL, .\n• Within the function, we use the method to send a POST request with the form data containing a username and password.\n• Upon receiving a response, we check if the status code is 200, indicating a successful request.\n• If the status code is not 200, we print an error message with the status code.\n\nFor projects that require high concurrency, we can combine HTTPX with Trio, an asynchronous I/O framework for Python. This combination allows us to handle multiple form submissions concurrently.\n\nWe define an asynchronous function, , which utilizes an to post form data to the specified URL, .\n\nWithin the function, we use the method to send a POST request with the form data containing a username and password. Upon receiving a response, we check if the status code is 200, indicating a successful request. If the response text contains the expected success message, \"Congratulations student. You successfully logged in!\", we print a success message; otherwise, we print a failure message. If the status code is not 200, we print an error message with the status code.\n\nWe then define the function, which creates an instance and a list of form data dictionaries. Using Trio's context manager, we start the tasks concurrently for each set of form data.\n\nBelow is a table comparing the performance and complexity of using for asynchronous form submission versus using with for concurrent form submissions. We will evaluate based on code complexity, ease of use, and performance in terms of time taken to complete the form submissions.\n\nTo provide an evidence-based comparison, we ran both scripts to measure the duration for a single login attempt and for multiple concurrent login attempts.\n• It measures the time taken for the request and prints whether the login was successful based on the response content.\n• It uses to execute multiple POST requests concurrently and then checks the responses to count successful logins. It also measures and prints the total time taken for all login attempts.\n• The function is responsible for sending the POST request to the login URL and checking the response to determine if the login was successful.\n• The function manages the concurrency using . It prepares the form data, starts multiple concurrent login attempts, and measures the time taken for these attempts.\n• The call initiates the whole process with concurrent login attempts.\n\nHere are our findings:\n• Code Complexity and Ease of Use:\n• (Asyncio): The code is straightforward and easy to understand for those familiar with basic asynchronous programming in Python. This method is best for beginners or for tasks where the overhead of setting up more complex concurrency is not justified.\n• with : This method introduces additional complexity due to the need to understand and implement concepts. However, it provides significant performance benefits for handling a high number of concurrent tasks.\n• Concurrency Handling and Performance:\n• (Asyncio): While it performs well for a moderate number of tasks, its performance degrades as the number of concurrent submissions increases. The sequential nature of handling tasks with can become a bottleneck.\n• with : Designed for high concurrency, allows for more efficient task management. It significantly reduces the total duration for multiple concurrent submissions, making it ideal for large-scale applications.\n\nFor projects with simple requirements and moderate concurrency needs, using with is sufficient and easier to implement.\n\nHowever, for high-concurrency applications where performance is critical, combining with offers substantial benefits in terms of speed and efficiency. Despite the added complexity, the performance gains make it a worthwhile investment for scalable applications.\n\nIn this comprehensive guide, we explored various methods for submitting forms with Python, each offering distinct advantages tailored to different use cases. From the simplicity of the Requests library to the power of browser automation frameworks like Selenium and Playwright, we covered a wide range of techniques to streamline form interactions.\n\nBeautiful Soup combined with Requests provides parsing and extraction capabilities for web scraping tasks involving forms. Mechanize offers an intuitive interface for automating browser sessions, while Pyppeteer and Playwright excel in headless browser automation. The Scrapy framework shines with built-in support for form submissions and data extraction pipelines.\n\nBy understanding the strengths and limitations of each approach, you can make an informed decision that aligns with your specific project goals.\n\nFor more information, check out the official documentation of the all libraries:\n\nIf you would like to learn more about Web Scraping with Python, then be sure to check out The Python Web Scraping Playbook.\n\nOr check out one of our more in-depth guides:\n• The Python Pyppeteer Guide - Using Puppeteer With Python"
    },
    {
        "link": "https://thejimmyg.github.io/pylonsbook/en/1.1/working-with-forms-and-validators.html",
        "document": "Form handling is one of those areas that at first glance appears very simple but in real applications can quickly become rather complicated. There are generally two approaches to dealing with forms. The first is to code all your forms, validation, and logic manually to give you complete control over how your forms work. The alternative approach is to use a form framework where ready-made classes exist for each of the field types you might want to use. The form framework then automates the generation of HTML, the validation of data, and the display of error messages for you.\n\nAt first glance, it might appear that a form framework would save you a lot of time, but in reality, form frameworks are rarely flexible enough to deal with all the situations you might want to develop, and in the long run you can sometimes find yourself spending more time creating custom fields for your form framework than it would have taken if you had coded all your forms manually.\n\nBecause of this, Pylons encourages you to do a lot of the work of generating forms yourself, but it does provide four sets of tools to make form handling as painless as possible:\n\nThese four tools can help make handling forms much simpler without in any way constraining your creativity as a developer. Pylons does support an alternative approach with a tool, called ToscaWidgets, although it won’t be covered in this chapter. ToscaWidgets is a full form framework developed from the original widgets code in TurboGears that automates every aspect of form handling. ToscaWidgets is still officially in prerelease, but if you are interested in its approach, you should visit http://toscawidgets.org to find out more. The majority of developers prefer the flexibility of the approach you’ll use in this chapter.\n\nWhen a user submits a form on a web site, the data is submitted to the URL specified in the attribute of the tag. The data can be submitted either via HTTP GET or POST as specified by the attribute of the tag. If your form doesn’t specify an , then it’s submitted to the current URL, but generally you’ll want to specify an attribute. This is a simple form coded in HTML and without any Pylons-specific features: If your form contains a file upload field such as , you will also need to specify an attribute, and you have to choose the method. Many people put the value of the attribute in uppercase. If your HTML page uses XHTML, the attribute value is supposed to be lowercase, which is why in this example it is specified as , not , as many examples will show. Later in the chapter, you’ll see how you can improve this example by using the helper in the form action and by using Pylons’ field helpers to generate most of the HTML for the form automatically. First, though, let’s create a new Pylons project to test this example as it stands: Accept the default options by pressing Enter to choose Mako as the template engine and no SQLAlchemy or Google App Engine support. Once the project has been created, let’s create a simple template in to use as a basis for the examples in this chapter: Create a new template called with the following content to test the example form: You’ll remember from the previous chapter that the tag allows the body of a template to be inserted into a parent template. Add two actions to the controller that look like this: Visit http://localhost:5000/formtest/form, and you will see the form. In this case, the generated HTML looks like this: Try entering the e-mail address and clicking Submit. The URL should change to http://localhost:5000/formtest/submit?email=test%40example.com&submit=Submit, and you should see the text . Pylons has parsed and decoded the query string and set up the object you saw in Chapter 3. As you’ll recall, this object behaves a bit like a dictionary where the keys are the names of the fields in the form, and their corresponding values are Unicode strings, with all the characters in the query string properly decoded ready for you to use. If you have two fields with the same name in the form, then using the dictionary interface will return the first string. You can get all the strings returned as a list by using the method. If you expect only one value and want to enforce this, you should use , which raises an error if more than one value with the same name is submitted. By default, if a field is submitted without a value, the dictionary interface returns an empty string. This means that using on will return a default only if the value was not present in the form. Forms can be submitted using either GET or POST HTTP methods depending on the value you set for the attribute of the tag. The GET method results in the form data being sent to the server via the URL query string, and the POST method sends the data as part of the HTTP body. Figure 6-1 and Figure 6-2 show the LiveHTTPHeaders information for both types of requests. As you can see, the request method (in the first line of both figures) is different in each. You’ll also see that the POST request has the e-mail address sent as extra content in the body rather than as part of the URL. It is possible to send very large amounts of data in the request body, but most browsers and servers can cope only with URLs that are less than 1,024 characters in length. This is why if you are using a file upload field, you should use the POST method, because the data is then sent in the body of the request. You can test the POST method by editing the template so that the method is changed to . If you rerun the example, you will see the same message is displayed as before, but the URL displayed in the browser after you submit the form is simply http://localhost:5000/formtest/submit without the query string. If you are writing forms that contain password fields, you should usually use POST to prevent the password from being visible to anyone who might be looking at the user’s screen. If you are ever in any doubt as to which method to use in a particular circumstance, it is normally safer to use POST. Regardless of whether the form data is submitted as a GET or a POST request, Pylons still makes the values available in your controllers using the same interface through . You might be wondering how Pylons copes if you submit a form with a POST method to a URL containing a query string. The answer is that both sets of values get merged into the object. Occasionally you might want to access the query string data separately from the POST data, so Pylons also provides two other objects that behave in the same way as to allow you to do just that. They are accessed as and , respectively. When writing form-based applications, you will occasionally find that users will press Refresh immediately after submitting a form. This has the effect of repeating whatever actions were performed the first time the form was submitted, but this might not always be the behavior your users expect. If your form was submitted with a POST, most browsers will display a message to the user asking them whether they want to resubmit the data (see Figure 6-3). This will not happen with a GET, so POST is preferable to GET in those circumstances. Of course, the best way to solve this issue is to structure your code in such a way that if the user refreshes the page, the data isn’t resubmitted. Here’s one way of achieving this with an HTTP redirect: # in the controller def form(self): return render('/simpleform.html') def submit(self): # Code to perform some action based on the form data # ... h.redirect_to(controller='formtest', action='result') def result(self): return 'Your data was successfully submitted.' This code requires the use of the helper. Add the following import to the project’s file: Then in the controller, import the module by adding this line at the top: Now you can test the controller. In this case, once the form is submitted, the data is saved, and an HTTP redirect occurs so that the browser redirects to http://localhost:5000/formtest/result. If the user then refreshes the page, it simply redisplays the message rather than reperforming the action. One issue with this approach is that if you want to display some of the submitted data, you will need to load it again in the action because the request that calls that action doesn’t contain any of the submitted data. In Chapter 8, I’ll cover how these sorts of messages can be displayed by storing information in a session store.\n\nForms can also be created with Pylons’ built-in helpers. You’ve already seen the helpers in Chapter 3 and learned about how they escape data to avoid security problems in Chapter 5; in this section, you’ll learn how to use the HTML helpers to create forms. The WebHelpers package from which the Pylons helpers are imported changed significantly in version 0.6. All the old helpers from Rails were deprecated in favor of the new-style literal approach documented in Chapter 5. All the JavaScript integration with Prototype and Script.aculo.us was also removed because the majority of developers preferred to use their own JavaScript framework. You’ll learn more about Pylons integration with JavaScript frameworks in Chapter 15. Let’s update the form you’ve been working on to use some of the HTML form helpers. Change the file to look like this: You can see that you are using the , , , and helpers. The helper actually comes from Routes, but the other helpers come from the module. You’ll need to add all these helpers to your sample project’s file too in order for this example to work: The built-in form helpers simply generate fragments of HTML to help you build forms. There are no built-in checks to ensure that you have closed an open form tag, so it is up to you to ensure that you produce valid HTML. Of course, this is actually very useful because it gives you a lot of flexibility. For example, you are free to mix and match HTML and helpers in whichever way you see fit, or you could even define the start of a form in one template and the end of a form in another without the helpers getting in your way. The helpers do correctly escape any string or Unicode values you pass them, but they don’t modify any values that have already been escaped with . It is worth becoming familiar with the form helpers available because using them can save a lot of time (particularly with more complex fields such as selects), and they will also ensure all your data is properly escaped. The HTML helpers are well documented at http://docs.pylonshq.com/thirdparty/webhelpers/html/html/#webhelpers-html-tags, so you can always refer to the documentation for the details of how a particular helper works. Let’s take a look at the definition of the helper as an example: This creates a standard text field. is a string, the content of the text field. The following are the options: If set to , the user will not be able to use this input. This is the number of visible characters that will fit in the input. This is the maximum number of characters that the browser will allow the user to enter. The remaining keyword options are standard HTML options for the tag. All form helpers start with a argument, which should be a string representing the name of the field, and they also have an argument. In Python, is a notation that means that any extra keyword arguments passed to the function should be put in a dictionary called where the keys are the parameter names and the values are their corresponding values. Any extra parameters you pass to any of these helpers are treated as extra attributes to be added to the HTML tag generated. Here’s an example where you specify an attribute that isn’t part of the HTML specification to an field. Again, the helpers won’t flag this as an error; it is up to you to decide what is right for your application and be responsible for the attributes you set. One common use for this functionality is to specify the CSS class the field should have. The problem is that is a reserved word in Python, so to specify the attribute, you need to pass in the parameter with a trailing character. The helper has a special behavior for the attributes , , and . All the single value field helpers behave in a similar way. They are , , , , , , , and . There is also a helper, and it behaves slightly differently. If you look at the documentation for , you’ll see it is defined like this: Instead of taking a argument, it has a argument and an argument: A string or list of strings or integers giving the value(s) that should be preselected. An iterable of pairs. The value is what is returned to the application if this option is chosen; the label is what is shown in the form. You can also pass an iterable of strings, in which case the labels will be identical to the values. If you are used to the helper from an earlier version of WebHelpers, you might expect to be able to use . This has been deprecated and is not available in Pylons 0.9.7. Instead, you just pass in the list of tuples directly via . You’ll also notice that the order of items in the tuple is reversed. expects arguments in the form , but this isn’t how most Python objects are generated. The following shows in action:\n\nFile upload fields are created by using the input field type. The helper provides a shortcut for creating these form fields: To use the file field, you need to import it into the project’s file: The HTML form must have its attribute set to to enable the browser to upload the file. The helper’s keyword argument provides a shortcut for setting the appropriate value. You don’t need to explicitly mark the form to use a POST because the helper automatically sets the attribute to when you specify the for a file upload. Let’s add a new controller to the form named : Change the action so it looks like this: Then add this new template to the directory as : If you visit http://localhost:5000/upload/index, you should see the form. Now let’s think about how to handle the upload. When a file upload has succeeded, the (or ) will contain a object as the value of the field. objects have three important attributes for file uploads: This is the name of the file uploaded as it appeared on the uploader’s filesystem. This is a Python object from which the file can be read. For example: This is the content of the uploaded file, eagerly read directly from the file object. The easiest way to gain access to the file’s data is via the attribute, which returns the entire contents of the file: However, reading the entire contents of the file into memory is undesirable, especially for large file uploads. A common means of handling file uploads is to store the file somewhere on the filesystem. The instance already reads the file onto the filesystem; however, it’s to a nonpermanent location, via a Python object. Here’s an example that uses to perform an efficient copy of the temp file’s data to a permanent location specified by the variable in the config file: For this example to work, you’ll need to add some imports at the top of the file: You’ll also need to edit the config file and add this to the end of the section: You’ll remember from the discussion of config files in Chapter 3 that is replaced with the location of the config file, so this example would upload files to the project’s directory used as a cache for templates and sessions. You’ll need to create the directory within the directory because it won’t exist yet. This basic example allows any file uploaded to overwrite any file in the directory to which your web application has permissions. Also note the use of to ensure that the file name doesn’t start with a character. This is a simple security measure to help prevent specially crafted file names resulting in other files on your system being overwritten. You should always be suspicious of all data coming from a user’s web browser and take appropriate steps to try to ensure that the data is safe. Now that you can handle files being uploaded to the server, you might also want to provide a way for your users to download those files again. First you’ll need to import the module to guess the content type of the file, so you should add the following import to the top of your controller: You can then provide the download with an action like this: You can test this by uploading a text file called and then visiting the URL http://localhost:5000/upload/download?requested_filename=somefile. The example so far will correctly send the file to the browser, but the browser will try to display it if it is a type it recognizes such as a JPEG or a PNG file. If you want to force the browser to download the file as an attachment, you can add another HTTP header to the response like this just before you return the data: This time the browser will treat the file as an attachment and prompt the user to ask how the file should be handled (see Figure 6-4). Notice how in this example because the name given for the file name in the HTTP header was , the browser automatically tried to name the file on the user’s computer. Internet Explorer 6 has trouble downloading certain files as attachments over sites using a secure connection (see http://support.microsoft.com/default.aspx?scid=kb;en-us;812935). If you are writing a secure application that will be accessed by users with Internet Explorer, you should also add the following headers to the response to correct the problem: Note that this an issue with Internet Explorer 6, not with Pylons!\n\nIn the initial example in this chapter, I described how to create a simple form that enables a user to enter their e-mail address and to redisplay the value that was entered in a Pylons application. In most situations, it is important to be able to validate the information the user has entered. If you were asking for an e-mail address with an intention to use it to contact someone, it is important the e-mail address is a real address, so you would want to run some basic checks to ensure the e-mail wasn’t obviously entered incorrectly. For example, the e-mail address should contain two strings separated by an character, and the domain name portion should contain a character that should be followed by at least two characters representing the top-level domain. There are even more checks you could make, including ensuring the domain portion of the e-mail was a real domain name, but this probably isn’t necessary for most situations. If a user did enter an invalid e-mail, you would need to redisplay the form together with the e-mail address entered and an error message explaining what was wrong so that the user could correct their mistake. Let’s create a controller to demonstrate this process manually. Later in the chapter, you’ll learn how the Pylons tools make this process a lot simpler. Let’s update the controller from earlier in the chapter to demonstrate this. Update the action to look like this, and remove the action: \"An email address must contain at least one '@' character.\" \"An email address domain must contain \" \"at least one '.' character.\" \"Please specify a domain type after the '.' character\" Update the template to look like this: You’ve used the Pylons’ helpers to generate the fields in this example; remember, you are free to use the helpers or to code your own HTML. If you visit http://localhost:5000/formtest/form, you will see that it achieves the desired result. If a user enters an invalid e-mail address, it will result in the form being redisplayed to show the error with the incorrect value still present in the text field ready to be corrected. To make the error show up better, it would be sensible to add some Cascading Style Sheets (CSS) so that the error appears in red. The of the page is defined in the template, so you better add the CSS there. Edit so that you include the following line in the section: Then create a directory in your project’s directory, and create a file called with the following content: You should find that all the error messages now appear in red, which will make the error much more obvious to your users (see Figure 6-5). Although the approach you’ve used here to manually validate the form works perfectly well, it would quickly become very complex if you were to also write code to handle many other types of fields in the same way. Luckily, Pylons comes with tools to make the processes you have just used much simpler.\n\nThe recommended tool for validating forms in Pylons is FormEncode. FormEncode has two parts:\n• A set of validators used together to create schemas, which convert form data back and forth between Python objects and their corresponding form values\n• A tool called HTML Fill that takes an HTML form and parses it for form fields, filling in values and error messages as it goes from Python objects Pylons provides a decorator, which can make the process of validating form data and redisplaying the form if necessary very easy, but in order to really understand what is going on during the validation process, I’ll first explain the process in full. For each form you create, you also create a validation schema. Here is the validation schema for the form you’ve been using so far. The example also includes a date field so I can later demonstrate how you can use schemas to convert data from one type to another as well as just validate input. Although the form now has three fields—an e-mail text field, a date validator, and a submit button—you are interested only in validating the e-mail address and the date. If extra fields are submitted, FormEncode’s default behavior is to consider the form invalid, so you specify so that the value of the submit button is not validated. Since you don’t want to use the value of the submit button, you also specify so that the value is ignored completely. The third line specifies that the e-mail field should be validated with an validator. In creating the validator, you also specify so that the e-mail field will require input. The final line specifies your date field and also that this particular date field should not be empty either. Table 6-1 outlines the options that can be used in a schema in addition to the validators themselves. These validators will be applied before the schema. These validators will be applied after the schema. If , then it is not an error when keys that aren’t associated with a validator are present. If , then keys that aren’t associated with a validator are removed. If this is given, then any keys that aren’t available but are expected will be replaced with this value (and then validated). This does not override a present attribute on validators. is a special FormEncode class to mean that no default values have been specified and therefore missing keys shouldn’t take a default value. If , then missing keys will be missing in the result, if the validator doesn’t have on it already. Table 6-1. Additional Options That Can Be Used in a FormEncode Schema It is usually best to keep form schemas together so that you have a single place you can go to update them. It’s also convenient for inheritance since you can make new form schemas that build on existing ones. If you put your forms in a file, you can easily use them throughout your controllers. However, if you are creating a schema that is going to be used in only one controller, it is often more convenient to keep the schema with the controller. This is what you’ll do here. Add the schema to the top of the controller. Now that you have added the schema, you need to be able to use it in your controller to validate the submitted form data that comes in via and to convert the validated values from the format in which they are submitted to Python objects that can be used in the controller. This is very straightforward because each base class (and therefore the class) has a method to handle the validation and conversion. If any of the validators fail to be able to convert the data, they raise a special exception type called a exception, which contains information about why the validation and conversion failed. Let’s see it in practice. Be sure you’ve added the schema and line to the top of the controller file, and then update the action to look like this: You’ll also need to update the template to add the date field: This new template is much simpler, but you’ll notice that it doesn’t contain any logic for setting the value of the e-mail field or displaying an error message. This will be handled separately using HTML Fill, which I’ll discuss later in the chapter. If the values entered in the form are valid, the schema’s method returns a dictionary of the validated and coerced data, in this case assigned to . This means you can guarantee that the dictionary contains values that are valid and correct Python objects for the data types desired. In this case, the e-mail address is a string, so happens to be the same as , but for the date field, is a string in the form , whereas is a Python object representing the date the user entered. For even more complex data types, this ability of FormEncode to coerce data becomes very valuable. Try entering some dates and e-mail addresses, both valid and invalid, and see the error messages FormEncode produces. As an example, if you entered the e-mail address and the date , you would get the following errors: Invalid: date: That month only has 31 days email: An email address must contain a single @ Now try entering some valid data such as and and change the end of the action to look like this: ... else: raise Exception(form_result) return 'Your email is: %s'%form_result.get('email') From the exception that occurs, you can see that actually contains the following: As you can see, FormEncode has done more than simply validate the data; it has also converted it to the appropriate Python type so that you can easily work with it. The validator has converted the text entered in the form into a Python object, and the validator has returned a Unicode string. This is useful if you want to convert Python objects from your database to display in a table as part of your web application, for example. It is also used by HTML Fill to automatically repopulate form data if your form contains errors. Here are some of the most frequently used FormEncode validators. For the full list, see the Available Validators documentation on the FormEncode web site: The submitted value is invalid if it is longer than the argument. It uses , so it can work for strings, lists, or anything with length. The submitted value is invalid if it is shorter than the argument. It uses , so it can work for strings, lists, or anything with length. The submitted value is invalid if it doesn’t match the regular expression . This is useful for matching phone numbers or postal codes, for example. This validator ensures that the field contains only letters, numbers, underscores, and hyphens. It subclasses . This validates and converts a date represented as a string, such as mm/yy, dd/mm/yy, dd-mm-yy, and so on. By using the argument you can support mm/dd/yyyy or dd/mm/yyyy. Only these two general styles are supported. This converts times in the format HH:MM:SSampm to (h, m, s). Seconds are optional. This converts a string such as or to a boolean. This converts a value to an integer. This converts a value to a float or integer. It tries to convert it to an integer if no information is lost. This converts things to string but treats empty things as the empty string. This converts things to Unicode strings. This is a specialization of the class. This validates a URL, either or . If is , then you’ll actually make a request for the page. This validates an e-mail address with the facility to check that the domain entered actually exists. This tests that the value is one of the members of a given list. This is particularly useful when validating an option from a select field because you can use it to check that the value submitted was one of the original values. This tests that the given fields match, that is, are identical. It is useful for password+confirmation fields. Pass the list of field names in as . Use this to apply a validator/converter to each item in a list. This class is like an operator for validators. All validators must work, and the results are passed in turn through all validators for conversion. This class is like an operator for validators. The first validator/converter that validates the value will be used. It can sometimes be difficult to work out the arguments that each validator will accept. The best way to find out is to look at the example usage for each type of validator on the FormEncode site. In addition to these arguments, validators also accept common arguments to configure their error messages and behavior. You’ll learn about these next. Each of the validators will have a number of messages as well as a number of configuration options. Here are some examples of the sorts of messages available; these are for the validator: To override the default value for an error message, you pass a argument to the validator’s constuctor. For example: In each of these examples, constructs such as and are standard Python string-formatting terms. They are replaced by a string representation of the value to which they are referring. Terms ending in result in the object being converted to a string with , and terms ending in result in the objects being converted to a string with the function that displays a Python representation of the value. You can use these same terms in your own custom messages if you like. You don’t need to specify messages for every error; FormEncode will use its defaults for any you don’t specify. Messages often take arguments, such as the number of characters, the invalid portion of the field, and so on. These are always substituted as a dictionary (by name). So, you will use placeholders like for each substitution. This way you can reorder or even ignore placeholders in your new message. Later you’ll see how to create your own validator. When you are creating a validator, for maximum flexibility you should use the function: Most validators support the following options (including your own validators, if you subclass from ): If set, then this value will be returned if the input evaluates to (an empty list, empty string, , and so on), but not a 0 or objects. This applies only to . If , then if an empty value is given, this raises an error (both with and also if is ). If and the input is a string, strip it (occurs before empty tests). If set, then this validator will raise during ; instead, return this value. If set, when the Python value (converted with ) is invalid, this value will be returned. If (the default), then and will not be called when is used. The values of the configuration options are stored as class attributes. As an example, look at the you used earlier. It is documented at http://formencode.org/class-formencode.validators.DateConverter.html, where you can see that the class has a number of attributes including , which defaults to mm/dd/yyyy. There are two ways to set these attributes. The first is to pass the name of the attribute as an argument to the validator’s constructor when you create it. You’ve already seen an example of this technique when you passed to the and validators in your schema. The other way to configure a validator is by using inheritance. You can create a new validator derived from the old one but with different default values for the attributes. As an example, here is a , which uses the U.K. format for the date by default: You could then update your schema to look like this: You’ll learn more about creating your own validators later in this chapter.\n\nNow that you have learned how to use FormEncode to validate and coerce data, you will still need to display error messages along with a repopulated form should the user have entered any invalid data. This is from the HTML Fill documentation: is a library to fill out forms, both with default values and error messages. It’s like a template library, but more limited, and it can be used with the output from other templates. It has no prerequesites and can be used without any other parts of FormEncode. The basic usage looks something like this: The parser looks for HTML input elements (including and ) and fills in the defaults. HTML Fill is therefore very useful in processing forms because you can return the form to the user with the values they entered, in addition to errors. Let’s update the controller to use HTML Fill. Change the action to look like this: and the date selected was You’ll also need to import HTML Fill. Add this import to the top of the controller: In this example, when an error occurs, you use Pylons’ function to render the HTML of the original form as it was before the user submitted it. You then pass the HTML, as well as the form result values and the error messages dictionary, into HTML Fill’s method. HTML Fill then parses the HTML, adding any error messages and field values for you automatically. The filled HTML is then returned so that the user can correct the errors as before. Notice that you don’t need the template code for the error messages and that none of the fields have values specified directly. HTML Fill populates the fields with the correct values and inserts any error messages automatically. Being able to use plain HTML in this manner is actually very useful because it means any designers working on your project are able to use visual tools such as Dreamweaver (or the open source Nvu program based on Mozilla project code) and HTML Fill will still work perfectly, whereas these tools are not designed to visually display fields generated in templates with the helper functions. The decision as to whether you should use the field helpers or code HTML fields directly will depend largely on whether you want to use such tools. If you run the example, you will see that the result is very similar to what was generated when you handled the form manually earlier in the chapter. The HTML generated for the error messages is slightly different, though. It includes some comments added by HTML Fill. This is the generated HTML: <html> <head> <title>FormDemo</title> <link rel=\"stylesheet\" type=\"text/css\" href=\"/style/style.css\" /> </head> <body> <h1>Enter Your E-mail Address</h1> <form action=\"/formtest/submit\" method=\"get\"> <p>E-mail Address: <!-- for: email --> <span class=\"error-message\">An email address must contain a single @</span><br /> <input name=\"email\" type=\"text\" class=\"error\" value=\"test_example.com\" /></p> <p>Date: <!-- for: date --> <span class=\"error-message\">That month only has 31 days</span><br /> <input name=\"date\" type=\"text\" class=\"error\" value=\"1/40/2008\" /></p> <p> <input name=\"submit\" type=\"submit\" value=\"Submit\" /></p> </form> </form> </body> </html> The error message formatting might not be quite what you were after, so HTML Fill defines two special tags that can be used to customize how the error messages are displayed: This tag is eliminated completely if there is no error for the named field. Otherwise, the error is passed through the given formatter ( if no attribute is given). If the named field doesn’t have an error, everything between the tags will be eliminated. Use to invert the behavior (in other words, include text only if there are no errors for the field). Formatters are functions that take the error text as a single argument and return a string that is inserted into the template. Formatters are specified as arguments to the function, which I will describe next. The default formatter returns the following: where is replaced with the error message concerned. Most of the time it is best to use a formatter because the second form displays the static HTML you’ve specified, not the actual error message generated. If any errors are generated for fields that don’t exist, they are added at the top of the form. HTML Fill’s function has the following arguments that you can use to customize how the form is rendered: It is important to note that HTML Fill’s function has nothing to do with the function you’ve been using to render templates; it is just unfortunate that both have the same name. The example so far has used the , and arguments, but other options can be useful too: If this is , if there are any extra fields from defaults or errors that couldn’t be used in the form, it will be an error. This is a dictionary of formatter names to one-argument functions that format an error into HTML. Some default formatters are provided if you don’t provide this. This is a dictionary of field names to a dictionary of attribute name/values. If the name starts with , then the value will be appended to any existing attribute (for example, ). If this is (the default), then any errors for which tags can’t be found will be put just above the associated input field, or at the top of the form if no field can be found. This is used to create the HTML that goes above the fields. By default, it wraps the error message in a span and adds a . If this is (the default is ), then will be treated as text inputs. This can be an object that watches fields pass; the only one currently is in .\n\nFormEncode comes with a useful set of validators, but you can also easily create your own. One common reason for wanting to do this is if you are populating a select field with values from a database and you want to ensure the value submitted is one of the values in the database. For this example, imagine you have a function called that interacts with a database every time it is called and returns a list of valid integers. When the validator is used in a schema and checked, an error message will be displayed if the value submitted isn’t one of the options returned by . You might use it like this: Let’s have a look at the implementation in more detail. Notice that the method also takes a argument. It’s used for very little in the validation system but provides a mechanism for passing information from Pylons to any custom validators you write. The global is used in Pylons for storing per-request state information, so it makes sense to also use it as the state argument to your validators, although you are free to use other objects if you prefer. As an example, let’s imagine that relied on a database connection that was set up on each request. You couldn’t pass the connection as an argument to because the connection wouldn’t exist at the point Python created the schema. The connection exists only during the request, so you would attach it to the global during the request and pass the global as the argument when instantiating the schema. Here’s how the start of the action might look from the full FormEncode and HTML Fill example earlier: # Imagine we have a connection object now: You could now update the example like this: In this way, the validator can use request-specific information even though it is defined before the request starts. The previous implementation uses the method, which simply raises an exception if it needs to do so. This is useful in this example because the conversion needs to be done by the validator when converting to and from Python. This won’t be the case for all the validators you create, though. The and methods are provided for you to implement any conversion code to convert to or from Python, respectively. The method is called after so that the argument will be a normal Python object by the time it comes to being validated. is called before . Both and take the same arguments as . You’ll remember from earlier in the chapter that validators can be customized when you instantiate them in a schema. At the moment, the validator you’ve created always displays the message . Let’s update the validator to allow it to be customized: You can also include values in the message itself like this: The message string specified gets interpolated with a dictionary made from the keyword arguments you pass to the function. This system is designed to make the messages easy to format for different environments or replaceable for different languages. You’ll also notice that you use a special exception class, , to raise an error. This is the same exception class you catch in the controller action and use to obtain the values to pass to . Besides the string error message, exceptions have a few other instance variables: This is the input to the validator that failed. This is the associated state. This is the error message ( returns this). If the exception happened in a (list) validator, then this will contain a list of exceptions. Each item from the list will have an entry, either for no error or an exception. If the exception happened in a (dictionary) validator, then this will contain exceptions for each failing field. This method returns a set of lists and dictionaries containing strings for each error. It’s an unpacking of , , and . If you get an exception from a , you probably want to call this method on the exception object. If you are interested in writing your own validators, it is useful to see the source code for the class. It is in the module and explains all the options and methods validators have. There are other types of validators too such as compound validators and chained validators. Generally speaking, the best way to implement your own validator is to look at the source code of an existing validator that behaves in a similar manner and implement your own validator in the same way.\n\nIn real-world examples, you rarely just need a form that can be populated from a flat dictionary structure. Forms that contain subforms or repeating sets of fields are actually very common. Let’s imagine a situation where you are writing a form to allow a researcher to add information about a research project they are conducting. They might need to provide the following information:\n• The title of the study\n• When it is going to start and end\n• The contact details of the people who are participating Contact details consist of the following information: Let’s also imagine that a research project requires at least one person to be added and also that there can be only one person with the role of chief investigator. You can easily provide a form to enter the study title, start date, and end date, but providing a form to allow an unknown number of people’s contact details to be entered is slightly trickier. You can take one of two approaches:\n• Design the form in a wizard format. The user enters the title, start date, and end date on the first screen and clicks Submit. The data is saved, and the second screen is displayed, allowing the user to add the contact details of the first person. Once they have submitted the form, they are asked whether they want to add another person. This continues until they have added all the necessary data.\n• Display a single form containing the title, start date, and end date as before but with a button to allow the user to add fields to add a person. When the user clicks the Add New Person button, a set of fields to enter the first person are shown. The user can submit the form or click the Add New Person button again to add another set of fields. Finally, once they have completed the whole form containing the study and person data, they click Save, and the data is validated and saved in one go. The advantage of the first approach is that at any one time you are dealing with only one set of fields that can be submitted as simple name/value pairs, so the data structure is very straightforward. The disadvantage is that at each step in the wizard you need to store the data that has already been submitted, and this has its own problems. Imagine, for example, you save the study information in the first step but the user changes their mind and never completes the second step of adding a person. One of the requirements was that studies should have at least one person associated with them, but now you have saved a study that doesn’t have any people. Say, instead, that the user does add a person and gives them a role of chief investigator. Now let’s imagine they add another person and give them a role of chief investigator too. You can’t have more than one chief investigator, so the validation code will display an error explaining the problem. Imagine, though, that the user really does want the second person to be the chief investigator and made a mistake in giving the first person the chief investigator role. The user has no choice but to start the form again. Obviously, all the problems with the wizard approach can be solved. You can store the data in a temporary location or a session store and save it properly only at the end of the wizard, or you can provide Back buttons so the user can go back through the wizard and make changes, but it can be a surprising amount of work to program the logic and validation code for this sort of workflow. The major advantage of the second approach is that all the required data is stored client-side throughout the submission and validation cycles, which means your Pylons controller needs to store the data only once, after all the input has been validated. This can greatly reduce the complexity of your controller logic. FormEncode provides the necessary tools to help you with this. The first thing you need to do is define the schema. Here’s what the main study schema might look like: As you can see, the schema has , , and fields, which use ordinary validators as you would expect, but there is also a field that takes a validator. The validator takes a single argument, which is another validator or schema it should validate. In this case, you want it to validate people, so you’ve specified an instance of a schema. The schema looks like this: The field will be a select drop-down that takes the values in Table 6-2. The validator checks that the value submitted for the is one of the values specified. Now turn your attention to the template defs to produce the fields. You’ll create a working example as you go through this chapter, so let’s create a project for it (accept the default values when prompted): Create two directories named and in the directory, and add a file that looks like this: Then create a new template called with the following content: <%inherit file=\"/base/index.html\" /> <%def name=\"study()\"> <fieldset><legend>Study</legend> <label for=\"title\">Title</label><br /> ${h.text(name=\"title\", id=\"title\")}<br /> <label for=\"start_date\">Start Date</label><br /> ${h.text(name=\"start_date\", id=\"startdate\")}<br /> <label for=\"end_date\">End Date</label><br /> ${h.text(name=\"end_date\", id=\"enddate\")}<br /> </fieldset><br /> % for id in range(c.number_of_people): ${person(id=id)} % endfor </%def> <%def name=\"person(id)\"> <fieldset><legend>Person</legend> <label for=\"person-${id}.title\">Title</label><br /> ${h.text(name=\"person-%s.title\"%(id), id=\"person-%s.title\"%(id))}<br /> <label for=\"person-${id}.firstname\">First Name</label><br /> ${h.text( name=\"person-%s.firstname\"%(id), id=\"person-%s.firstname\"%(id ))}<br /> <label for=\"person-${id}.surname\">Surname</label><br /> ${h.text(name=\"person-%s.surname\"%(id), id=\"person-%s.surname\"%(id))}<br /> <label for=\"person-${id}.role\">Role</label><br /> ${h.select( \"person-%s.role\"%(id), [], [ ['1', 'Chief Investigator'], ['2', 'Assistant'], ['3', 'Student'], ], id=\"person-%s.role\"%(id), )}<br /> ${h.submit(name=\"action\", value=\"Remove %s\"%(id))} </fieldset><br /> </%def> <h1>Create a Study</h1> ${h.form(h.url_for(controller='study', action='process'))} ${study()} ${h.submit(name=\"action\", value=\"Save\")} ${h.submit(name=\"action\", value=\"Add New Person\")} ${h.end_form()} Rendering this template would result in the def being called, and this in turn would call the def to create a set of fields for the number of people specified in , which you will set in the controller in a minute. The template you’ve created uses and HTML tags to create the form rather than creating a layout with tables or other HTML structures. This is considered best practice because the attributes of the tags clearly associate the text of the label with the field itself so that people who use screen readers will still be able to fill in your form. Using this technique also makes your forms much easier to style using CSS. The schema expects nested data structures, but HTML forms produce flat structures with keys (field names) and their associated values. To solve this problem, FormEncode provides a class in the module that provides a way of converting nested data structures to and from a flat set of field names. To do this, it uses keys with for nested dictionaries and for (ordered) lists. A structure like this: can therefore be mapped to form fields with the names and values in Table 6-3. Table 6-3. Field Names Used in the Example and Their Corresponding Values Notice how the value is associated directly with rather than . This is so that if the dictionary contained a key and a key , they could both be handled correctly. Returning to the example, notice how in the def you just created the field names that make up each person follow this naming convention so that FormEncode can automatically convert the values submitted from the HTML form into the nested data structure the schema requires. To make this conversion happen automatically, you need to add a prevalidator to the schema so it looks like this: Prevalidators are validators that are run on the values before the values are passed to each of the other validators for validation and conversion. Schemas also take a attribute, which you’ll see later is for performing validation on the whole form after the prevalidators and individual field validators have been run. The form also includes buttons for adding new people and removing ones the user added by mistake. These fields aren’t part of the schema and don’t need to be included in the validated and converted output, so you can also add the attributes and to the schema. At this stage, you can start adding content including the finished schemas to the controller you created earlier. At the top of the file after is set up, add the following: One of the requirements was that a study should have at least one person. The validator you are using to validate people takes the same argument that validators such as take, so you might think that adding to the validator constructor would be all you had to do. Unfortunately, this isn’t the case; the validator is set up to return the value if the field is missing, so FormEncode doesn’t notice the problem. There are two ways to fix this depending on what you want to achieve:\n• Use , but always specify a hidden field such as so that a value is always submitted and FormEncode is forced to validate the field. When the value is received, the argument means the standard message gets displayed and the user is aware of the problem. When people are added, the hidden field still gets submitted, but overwrites the value with the decoded people values, so everything works as it should.\n• Use to tell FormEncode not to return an empty list, , if no people are submitted (which is the default behavior). Instead, because there is no default, the schema will display its message . You can also customize the message using the second approach like this: Another requirement is that there should be only one chief investigator. You can check this condition by creating a custom validator to check for the presence of the one chief investigator. You could implement this as a normal validator, but here you are going to implement it as a chained validator. Chained validators are slightly different from normal validators because they are checked only once all the individual fields have been validated. They are usually used when a validation rule depends on more than one field. Ordinary validators are passed the raw unconverted value from the field they are validating. Chained validators are passed the validated and converted dictionary of data generated after all the other validators have been run. Here’s what the validator looks like: \"Only one Chief Investigator is allowed, not Add this validator to the schema like this: The schema and templates are now in place, so turn your attention to the controller code that will tie everything together. The first thing to notice is that the user will expect very different behavior depending on the button that is clicked. There are buttons to do the following: To rerender the form after any of these actions, you need to calculate the number of people so that the form is regenerated with the correct number of sets of person fields. Here’s a function to do that: You’ll also need a function to render the template and fill it with the correct values and error messages: You can add these two functions beneath the schema definitions in your controller. All the buttons have the same name, , so the action you’ll create can determine which button has been pressed by looking at the value of the URL parameter. Here is the complete code including the schemas, validators, and controller: \"Only one Chief Investigator is allowed, not # Don't use the values field for repopulation # Render the form with one extra set of person fields # Get the ID of the set of person fields to remove # Create a new set of values without those fields # Render the form with the new values # Assume we are trying to save the form # You would save the data here before redirecting # which shouldn't need any further conversion. # In this case we just display the result Since this is a new project, you’ll need to add some helpers to the file before this example will work. Add these lines: To test this example, start the development server with the command, and visit http://localhost:5000/study/index. If the Add New Person button is clicked, the form is rerendered with its submitted values and an extra set of person fields. No validation takes place at this stage, so the values redisplayed are the same as those entered. If the user clicks one of the Remove Person buttons, the ID of the set of person fields to be removed is obtained from the button value, and that set of fields is manually removed from the dictionary of values that is used to repopulate the form when it is rendered. If the action isn’t recognized, it is assumed the user clicked the Save button. The schema is used to validate and convert the data. The prevalidator converts the flat HTML form data into a nested data structure. Each of the fields in turn is then checked against its validator. In the case of , this means each of the sets of person fields is itself validated against the schema. If there are no errors, the chained validator is run to ensure there is only one chief investigator. If any of the validation checks fail, the form errors are encoded into a flat data structure using the function so that each of the keys associated with the errors can be understood by and redisplayed next to the fields to which they refer. Finally, if all the validation checks pass, the method returns the decoded, validated, and converted values ready for your program to handle the data in whichever way it sees fit. Ordinarily, this would most likely be to save the data to a database before using to redirect the user to a page confirming the data had been saved. This example simply prints a message and displays the converted data structure. Figure 6-6 shows the example during validation and with only one set of person fields added. If you were to add some valid data, the result would be structured as shown here (although I’ve added some whitespace for clarity):"
    },
    {
        "link": "https://browserstack.com/guide/web-development-in-python-guide",
        "document": "Web development in Python is a versatile and popular choice for building dynamic websites and web applications. Python provides a robust ecosystem of frameworks, libraries, and tools that simplify the development process and enable developers to create scalable and efficient web solutions. In this ultimate guide, we will explore web development with Python and different libraries for it and one example of web development.\n\nWeb development refers to the process of creating and building websites and web applications that are accessible over the Internet. It involves the use of various technologies, programming languages, and tools to design, develop, and maintain websites that cater to different purposes and functionalities.\n\nAt its core, web development encompasses two main aspects:\n\nFront-end development focuses on the visual and interactive elements of a website that users directly interact with. This includes designing the user interface (UI) and user experience (UX), creating the layout, and implementing the visual components using technologies such as HTML (Hypertext Markup Language), CSS (Cascading Style Sheets), and JavaScript. Front-end developers ensure that websites are visually appealing, responsive, and user-friendly.\n\nBack-end development, on the other hand, deals with the server-side functionality of a website. It involves creating the logic and infrastructure that support the website’s functionality, handle data processing, and interact with databases. Back-end developers work with programming languages such as Python, Ruby, Java, or PHP to build the server-side components of a web application.\n\nPython web development refers to the process of creating web applications and websites using the Python programming language. Python is a versatile and popular programming language known for its simplicity, readability, and vast ecosystem of libraries and frameworks.\n\nIn Python web development, developers use Python to write the server-side logic that powers web applications. This includes handling HTTP requests and responses, managing data storage and retrieval, implementing business logic, and rendering dynamic content.\n\nWhy use Python for Web Development?\n\nPython is a popular programming language that has gained significant traction in web development. It offers several advantages, making it an excellent choice for building robust and scalable web applications. Here are some compelling reasons why Python is widely used for web development:\n• Readability and Simplicity : Python’s syntax is designed to be easy to read and write, emphasizing code readability and maintainability. Its clean and intuitive syntax allows developers to express concepts in fewer lines of code, making development faster and more efficient. Python’s simplicity enables both beginners and experienced developers to work with ease and collaborate effectively.\n• Large and Active Community : Python has a vast and active community of developers who contribute to its growth and offer support. The community provides numerous libraries, frameworks, and resources specifically tailored for web development. This abundance of community-driven tools and resources makes Python a powerful choice for web development, offering solutions for a wide range of requirements.\n• Extensive Libraries and Frameworks : Python offers a rich ecosystem of libraries and frameworks that simplify web development tasks. Django, one of the most popular Python web frameworks, provides a complete and robust set of tools for building complex web applications. It follows the Model-View-Controller (MVC) architectural pattern and offers features like authentication, database ORM (Object-Relational Mapping), and URL routing out of the box. Flask is another lightweight and flexible micro-framework that allows developers to have more control over the application’s structure and components. These frameworks, along with others like Pyramid and Bottle, provide a solid foundation and enhance productivity in web development.\n• Scalability and Performance : Python is known for its scalability and performance, making it suitable for handling high-traffic web applications. With advancements like asynchronous programming, Python frameworks like Django asyncio can efficiently handle concurrent requests and maximize server resources. Additionally, Python’s integration capabilities allow easy integration with other languages, enabling developers to leverage high-performance libraries written in C or C++ when needed.\n• Integration and Compatibility : Python seamlessly integrates with other technologies, making it flexible for web development. It supports various databases, including SQL-based databases like MySQL, PostgreSQL, and SQLite, as well as NoSQL databases like MongoDB. Python’s compatibility extends to web servers, message queues, caching systems, and APIs, allowing developers to integrate different components and services smoothly.\n• Testing and Debugging unittest pytest , which simplify the process of writing and executing tests for web applications. Its debugging tools, like pdb\n• Rapid Development : Python’s focus on simplicity and productivity enables developers to build web applications quickly. The availability of pre-built modules and libraries allows developers to leverage existing solutions and avoid reinventing the wheel. This rapid development approach is particularly beneficial for startups and small-scale projects, where time-to-market is crucial.\n\nHow to use Python for Web Development\n\nPython is a versatile programming language that can be used for python web application development. With its simplicity, readability, and vast ecosystem of libraries and frameworks, Python has become a popular choice for building web applications. Here are the key steps to get started with Python for web development:\n• Install Python : Start by installing Python on your machine. Visit the official Python website ( ) and download the latest version compatible with your operating system. Follow the installation instructions to complete the setup.\n• Choose a Web Framework : Python offers various web frameworks that provide tools and structures to streamline web development. Popular frameworks include Django, Flask, Pyramid, and Bottle. Research and choose a framework that aligns with your project requirements and familiarity.\n• Set Up a Development Environment : Create a dedicated folder for your project and set up a virtual environment to isolate its dependencies. Virtual environments help manage project-specific packages and prevent conflicts with other Python installations. You can use tools like virtualenv or Python’s built-in venv\n• Install Framework and Dependencies : Once your virtual environment is activated, use the package manager pip to install the chosen web framework and any other required dependencies. For example, if you’re using Django, run “ pip install Django”\n• Project Initialization : Each web framework has its own way of creating a new project structure. Refer to the framework’s documentation for detailed instructions. For Django, you can use the command “django-admin startproject projectname”\n• Configure Settings : Most web frameworks have configuration files where you can specify settings for your project, such as database connections, static files, and security options. Locate and modify the configuration file for your chosen framework according to your needs.\n• Define Models : Models represent the structure and relationships of your data. In frameworks like Django, you define models using a declarative syntax that maps to database tables. Define your models to represent the data entities in your application.\n• Create Views and Templates : Views handle the logic of processing requests and generating responses. Templates provide the structure and presentation of the web pages. Define your views to handle specific URL routes and connect them to corresponding templates.\n• Define URL Routes : Configure the URL routing mechanism provided by your web framework. This maps incoming URLs to specific views or functions within your application. Define URL patterns to handle different routes and specify the corresponding view or function to invoke.\n• Handle Forms and User Input : If your web application requires user input and form submissions, use the features provided by the framework to handle form processing, validation, and data persistence.\n• Integrate with Databases : Python web frameworks typically provide built-in support for interacting with databases. Configure your database connection settings in the framework’s configuration file and use ORM (Object-Relational Mapping) techniques to interact with the database using Python code.\n• Implement Business Logic : Write the necessary code to implement the business logic of your web application. This may involve handling user authentication, implementing business rules, processing data, and integrating with external services or APIs.\n• Test and Debug : Write tests to ensure the functionality and correctness of your web application. Most Python frameworks provide testing frameworks and tools to simplify the testing process. Use debugging tools and techniques to identify and fix any issues or errors during development.\n• Deploy and Maintain : Once your web application is ready, choose an appropriate hosting environment and deploy your application. Ensure that the server environment meets the necessary requirements and considers aspects such as security, performance optimization, and scalability. Regularly maintain and update your application as needed.\n\nPython provides a number of web frameworks to meet a variety of purposes and tastes. Here are some popular Python web development frameworks:\n• Django : Django is a high-level, full-featured framework known for its “batteries included” approach.It offers a rich collection of tools and functionality for swiftly developing complicated web applications. Django includes an ORM (Object-Relational Mapping) for database management, URL routing, form handling, authentication, and more. It follows the Model-View-Controller (MVC) architectural pattern.\n• Flask : Flask is a lightweight and flexible framework, often referred to as a micro-framework. It provides the essentials for , allowing developers to have more control over their application’s structure. Flask supports URL routing, template rendering, and request handling, but leaves other functionalities like database management and authentication to extensions and libraries. It follows a minimalist approach and is ideal for small to medium-sized projects.\n• Pyramid : Pyramid is a flexible and scalable web framework that aims to strike a balance between simplicity and power. It follows a minimalist philosophy and allows developers to choose the components they need. Pyramid supports various templating engines, and URL dispatching, and includes tools for authentication, caching, and internationalization. It is suitable for projects of any size, from small applications to large-scale enterprise systems.\n• Bottle : Bottle is a minimalistic web framework with a small footprint. It is designed to be easy to learn and use, making it a good choice for beginners or small projects. Despite its simplicity, Bottle provides routing, template rendering, and basic tools for handling HTTP requests and responses. It is a single-file module with no external dependencies, making it easy to deploy and distribute.\n• CherryPy : CherryPy is a minimalist web framework that aims to be fast, stable, and scalable. It provides a simple and intuitive API for handling HTTP requests, URL routing, and session management. CherryPy can run as a standalone HTTP server or be integrated with other servers. It is suitable for building small to medium-sized applications and APIs.\n• Tornado : Tornado is a powerful and scalable web framework with a focus on performance and handling high-traffic applications. It is designed for building asynchronous web servers and supports non-blocking I/O operations. Tornado can handle thousands of simultaneous connections efficiently and is suitable for applications that require real-time functionality, such as chat servers or streaming platforms.\n\nThese are just a few examples of Python web frameworks, and each has its own strengths and use cases. Consider your project requirements, scalability needs, learning curve, and community support when choosing the framework that best fits your development goals.\n\nWeb development using Python offers a wide range of tools and libraries that can enhance your productivity and simplify the development process. Here are some commonly used tools & libraries in Python web development:\n• Requests : Requests is a simple and user-friendly library for making HTTP requests. It simplifies interacting with web APIs and handling HTTP methods, headers, cookies, and authentication.\n• Beautiful Soup : Beautiful Soup is an HTML and XML parsing library. It provides a simple API for exploring and modifying the parsed data, making it suitable for\n• Pillow : Pillow is a powerful library for image processing and manipulation. It provides functionalities like resizing, cropping, applying filters, and adding text or overlays to images. The pillow is often used in web applications for image handling and manipulation.\n• SQLAlchemy : SQLAlchemy is a feature-rich ORM (Object-Relational Mapping) library that simplifies database management in Python. It supports multiple database engines and provides a high-level API for interacting with databases, making it easier to work with databases in web applications.\n• Celery : Celery is a distributed task queue library that enables asynchronous task execution in web applications. It allows you to offload time-consuming or resource-intensive tasks to be processed in the background, improving the responsiveness of your application.\n• Flask-SQLAlchemy : Flask-SQLAlchemy is an extension that integrates SQLAlchemy with the Flask web framework. It provides seamless integration between Flask and SQLAlchemy, making it easier to work with databases in Flask applications.\n• Flask-WTF : Flask-WTF is an extension for handling web forms in Flask applications. It provides utilities for rendering forms, handling form submissions, and performing form validation. Flask-WTF simplifies the process of working with forms and managing user input.\n• PyJWT : PyJWT is a library for JSON Web Tokens (JWT) authentication. It simplifies the creation, decoding, and verification of JWTs, which are commonly used for authentication and authorization in web applications.\n• Redis-py : Redis-py is a Python client for Redis, an in-memory data structure store. It allows you to interact with Redis databases and perform operations like storing and retrieving data, caching, and pub/sub messaging.\n• Pydantic : Pydantic is a data validation and parsing library that simplifies working with complex data structures in Python. It allows you to define data models with type hints and provides automatic data validation, serialization, and deserialization. Pydantic is commonly used in web applications for validating and handling incoming request data.\n• Jinja2 : Jinja2 is a powerful and flexible template engine for Python. It provides a syntax for defining templates with placeholders and logic, which can be rendered dynamically with data. Jinja2 is widely used in web frameworks like Flask and Django to generate HTML pages, emails, and other dynamic content.\n\nThese are just a few examples of the many libraries available in the Python ecosystem for web development. Depending on your specific project requirements, you can explore and leverage these libraries to enhance your web development workflow.\n\nA roadmap for web development with Python that outlines the key steps and concepts involved in web development with Python:\n• Learn the basics of Python : Familiarize yourself with the fundamentals of Python programming, including syntax, data types, control structures, and functions. You can refer to online tutorials or books to get started.\n• Understand HTML, CSS, and JavaScript : Learn the basics of web technologies like HTML for markup, CSS for styling, and JavaScript for client-side interactivity. These are essential for understanding and creating web pages.\n• Choose a web framework : Select a Python web framework that suits your project requirements. Popular options include Django, Flask, and Pyramid. Each framework has its own strengths and learning curve, so explore their documentation and resources to make an informed decision.\n• Front-end development : Enhance your web development skills by learning popular front-end libraries and frameworks such as React, Vue.js, or Angular. These frameworks allow you to build interactive user interfaces and communicate with back-end APIs.\n• RESTful API development : If building an API is part of your project, learn about RESTful principles and design patterns. Use your chosen web framework to create APIs that expose data and functionality to other applications or front-end interfaces.\n• Authentication and authorization : Understand the concepts of user authentication and authorization. Learn how to implement secure user registration, login, and access control mechanisms using your web framework’s built-in features or extensions.\n• Testing and debugging : Gain proficiency in testing your web applications. Learn about , or the testing frameworks provided by your chosen web framework to write and execute tests.\n• Deployment and hosting : Learn how to deploy your web application to a web server or a cloud platform. Understand concepts such as server configuration, deployment automation, security considerations, and scalability. Platforms like Heroku, AWS, or PythonAnywhere are commonly used for web application hosting.\n\nRemember that this roadmap provides a general outline, and you can tailor it based on your project requirements and interests. It’s important to engage in hands-on projects and explore real-world examples to solidify your understanding and gain practical experience.\n\nHow to create your first web application in Python\n\nTo create your first Python web development example, Need to follow the below steps:\n• Install Python : Ensure you have Python installed on your system. You can download the latest version from the official Python website (\n• Choose a Web Framework : Select a web framework that suits your needs. Flask and Django are popular choices for beginners. In this example, we’ll use Flask.\n• Install Flask : Open your terminal or command prompt and run the following command to install Flask using pip (Python package installer):\n• Create a Project Folder : Create a new folder for your project. This will be the root directory for your web application.\n• Create a Python File : Inside your project folder, create a new Python file. For example, app.py\n• Import Flask and Create an App Instance app.py , import the Flask module and create an instance of the Flask class. Add the following code in the app.py\n• Define a Route and View Function : Define a route (URL) and a view function to handle the request. The view function will return the response that will be displayed in the browser. Add the following code:\n• Create a Login HTML Template: Inside your project folder, create a new folder named templates. Inside the templates folder, create an HTML file named login.html . Add the following code to login.html\n• Run the Application : At the end of app.py , add the following code to run the Flask application:\n• Start the Development Server : Before start server, we need to compile above steps code together, Here is an entire script for app.py file :\n\nIn your terminal or command prompt, navigate to the project folder and run the following command:\n• Open the Login Page http://localhost:5000/login in the address bar. You should see a login page with a username and password field.\n• Test Login Functionality admin ” as the username and “ password ” as the password, and click the “ Login ” button. You should see a “ Login successful! ” message. If you enter any other username or password combination, you will see an “Invalid username or password” message.\n\nThis example demonstrates a basic login page using Flask. You can expand on this by adding database integration, user authentication, session management, and other security measures based on your project requirements.\n\nWhen it comes to Python web development, there are several best practices you can follow to ensure clean, efficient, and maintainable code. Here are six essential points to consider:\n• Use a Web Framework: Python offers a wide range of web frameworks like Django, Flask, and Pyramid. These frameworks provide essential tools and features for web development, such as routing, request handling, and template engines. Choosing a framework helps you structure your codebase and promotes code reuse.\n• Follow the MVC Pattern: Model-View-Controller (MVC) is a software architectural pattern commonly used in web development. It helps separate the concerns of your application by dividing it into three components: models (representing data and business logic), views (handling user interface), and controllers (managing the flow between models and views). Adhering to this pattern makes your code more modular and maintainable.\n• Use Virtual Environments: Virtual environments create isolated Python environments for your projects, allowing you to manage dependencies and avoid conflicts between packages. Tools like virtualenv or Python’s built-in venv module enable you to create and activate virtual environments. This practice ensures project-specific dependencies and avoids cluttering your global Python installation.\n• Employ Database Abstraction Layers : When working with databases, use an ORM (Object-Relational Mapping) library like SQLAlchemy. ORM libraries abstract the database layer, allowing you to interact with the database using Python objects and queries. This approach simplifies database operations, improves security by preventing SQL injection, and facilitates switching between different database systems.\n• Write Unit Tests: Unit testing is crucial for maintaining code quality and catching potential bugs early. Python has a built-in testing framework called unittest, along with third-party libraries like pytest. Write comprehensive unit tests for your web application’s components, including models, views, and controllers. Automating tests helps ensure that future code changes don’t introduce unexpected issues.\n• Handle Security: Web applications are vulnerable to various security threats. Some essential security practices include:\n• Input Validation : Validate and sanitize all user inputs to prevent common attacks like SQL injection and cross-site scripting (XSS).\n• Password Security : Store passwords securely using techniques like hashing and salting to protect user credentials.\n• Secure Session Management : Use secure session management techniques to protect user sessions, such as using session cookies with secure flags and implementing session timeouts.\n• Regularly Update Dependencies : Keep your Python packages and web frameworks up to date to ensure you’re using the latest security patches.\n\nThese are just a few best practices to consider when developing web applications in Python. Remember to adhere to the principles of code readability, maintainability, and scalability throughout your development process.\n\nWeb development involves creating websites and web applications, and Python is a powerful language that is well-suited for this purpose. Python’s simplicity, readability, and extensive ecosystem make it an excellent choice for web development projects. Python provides a solid foundation for web development, enabling developers to build feature-rich and scalable web applications efficiently. After completing your application, you can test it with end-to-end flow with BrowserStack which provides a different range of browsers and also parallel test execution."
    }
]