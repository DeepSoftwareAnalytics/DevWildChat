[
    {
        "link": "https://sysprog21.github.io/lkmpg",
        "document": "The Linux Kernel Module Programming Guide is a free book; you may reproduce and/or modify it under the terms of the Open Software License, version 3.0.\n\nThis book is distributed in the hope that it would be useful, but without any warranty, without even the implied warranty of merchantability or fitness for a particular purpose.\n\nThe author encourages wide distribution of this book for personal or commercial use, provided the above copyright notice remains intact and the method adheres to the provisions of the Open Software License. In summary, you may copy and distribute this book free of charge or for a profit. No explicit permission is required from the author for reproduction of this book in any medium, physical or electronic.\n\nDerivative works and translations of this document must be placed under the Open Software License, and the original copyright notice must remain intact. If you have contributed new material to this book, you must make the material and source code available for your revisions. Please make revisions and updates available directly to the document maintainer, Jim Huang <jserv@ccns.ncku.edu.tw>. This will allow for the merging of updates and provide consistent revisions to the Linux community.\n\nIf you publish or distribute this book commercially, donations, royalties, and/or printed copies are greatly appreciated by the author and the Linux Documentation Project (LDP). Contributing in this way shows your support for free software and the LDP. If you have questions or comments, please contact the address above.\n\nThe Linux Kernel Module Programming Guide was initially authored by Ori Pomerantz for Linux v2.2. As the Linux kernel evolved, Ori’s availability to maintain the document diminished. Consequently, Peter Jay Salzman assumed the role of maintainer and updated the guide for Linux v2.4. Similar constraints arose for Peter when tracking developments in Linux v2.6, leading to Michael Burian joining as a co-maintainer to bring the guide up to speed with Linux v2.6. Bob Mottram contributed to the guide by updating examples for Linux v3.8 and later. Jim Huang then undertook the task of updating the guide for recent Linux versions (v5.0 and beyond), along with revising the LaTeX document.\n\nThe following people have contributed corrections or good suggestions:\n\nInvolvement in the development of Linux kernel modules requires a foundation in the C programming language and a track record of creating conventional programs intended for process execution. This pursuit delves into a domain where an unregulated pointer, if disregarded, may potentially trigger the total elimination of an entire file system, resulting in a scenario that necessitates a complete system reboot.\n\nA Linux kernel module is precisely defined as a code segment capable of dynamic loading and unloading within the kernel as needed. These modules enhance kernel capabilities without necessitating a system reboot. A notable example is seen in the device driver module, which facilitates kernel interaction with hardware components linked to the system. In the absence of modules, the prevailing approach leans toward monolithic kernels, requiring direct integration of new functionalities into the kernel image. This approach leads to larger kernels and necessitates kernel rebuilding and subsequent system rebooting when new functionalities are desired.\n\nLinux distributions provide the commands , and within a package.\n\nWhat Modules are in my Kernel?\n\nTo discover what modules are already loaded within your current kernel use the command .\n\nModules are stored within the file /proc/modules, so you can also see them with:\n\nThis can be a long list, and you might prefer to search for something particular. To search for the fat module:\n\nIs there a need to download and compile the kernel?\n\nTo effectively follow this guide, there is no obligatory requirement for performing such actions. Nonetheless, a prudent approach involves executing the examples within a test distribution on a virtual machine, thus mitigating any potential risk of disrupting the system.\n\nBefore delving into code, certain matters require attention. Variances exist among individuals’ systems, and distinct personal approaches are evident. The achievement of successful compilation and loading of the inaugural “hello world” program may, at times, present challenges. It is reassuring to note that overcoming the initial obstacle in the first attempt paves the way for subsequent endeavors to proceed seamlessly.\n• Modversioning. A module compiled for one kernel will not load if a different kernel is booted, unless is enabled in the kernel. Module versioning will be discussed later in this guide. Until module versioning is covered, the examples in this guide may not work correctly if running a kernel with modversioning turned on. However, most stock Linux distribution kernels come with modversioning enabled. If difficulties arise when loading the modules due to versioning errors, consider compiling a kernel with modversioning turned off.\n• Using X Window System. It is highly recommended to extract, compile, and load all the examples discussed in this guide from a console. Working on these tasks within the X Window System is discouraged. Modules cannot directly print to the screen like can, but they can log information and warnings that are eventually displayed on the screen, specifically within a console. If a module is loaded from an , the information and warnings will be logged, but solely within the systemd journal. These logs will not be visible unless consulting the . Refer to 4 for more information. For instant access to this information, it is advisable to perform all tasks from the console.\n• SecureBoot. Numerous modern computers arrive pre-configured with UEFI SecureBoot enabled—an essential security standard ensuring booting exclusively through trusted software endorsed by the original equipment manufacturer. Certain Linux distributions even ship with the default Linux kernel configured to support SecureBoot. In these cases, the kernel module necessitates a signed security key. Failing this, an attempt to insert your first “hello world” module would result in the message: “ERROR: could not insert module”. If this message Lockdown: insmod: unsigned module loading is restricted; see man kernel lockdown.7 appears in the output, the simplest approach involves disabling UEFI SecureBoot from the boot menu of your PC or laptop, allowing the successful insertion of “hello world” module. Naturally, an alternative involves undergoing intricate procedures such as generating keys, system key installation, and module signing to achieve functionality. However, this intricate process is less appropriate for beginners. If interested, more detailed steps for SecureBoot can be explored and followed.\n\nBefore building anything, it is necessary to install the header files for the kernel.\n\nThe following command provides information on the available kernel header files. Then for example:\n\nAll the examples from this document are available within the examples subdirectory.\n\nShould compile errors occur, it may be due to a more recent kernel version being in use, or there might be a need to install the corresponding kernel header files.\n\nMost individuals beginning their programming journey typically start with some variant of a hello world example. It is unclear what the outcomes are for those who deviate from this tradition, but it seems prudent to adhere to it. The learning process will begin with a series of hello world programs that illustrate various fundamental aspects of writing a kernel module.\n\nPresented next is the simplest possible module.\n\nPaste this into your favorite editor and save it as hello-1.c:\n\nNow you will need a Makefile. If you copy and paste this, change the indentation to use tabs, not spaces.\n\nIn Makefile, $(CURDIR) can set to the absolute pathname of the current working directory(after all -C options are processed, if any). See more about CURDIR in GNU make manual.\n\nIf there is no PWD := $(CURDIR) statement in Makefile, then it may not compile correctly with sudo make. Because some environment variables are specified by the security policy, they can’t be inherited. The default security policy is sudoers. In the sudoers security policy, env_reset is enabled by default, which restricts environment variables. Specifically, path variables are not retained from the user environment, they are set to default values (For more information see: sudoers manual). You can see the environment variable settings by:\n\nHere is a simple Makefile as an example to demonstrate the problem mentioned above.\n\nThen, we can use -p flag to print out the environment variable values from the Makefile.\n\nThe PWD variable won’t be inherited with sudo.\n\nHowever, there are three ways to solve this problem.\n• You can use the -E flag to temporarily preserve them.\n• You can set the env_reset disabled by editing the /etc/sudoers with root and visudo. ## Change env_reset to !env_reset in previous line to keep all environment variables You can view and compare these logs to find differences between env_reset and !env_reset.\n• You can preserve environment variables by appending them to env_keep in /etc/sudoers. After applying the above change, you can check the environment variable settings by:\n\nIf all goes smoothly you should then find that you have a compiled hello-1.ko module. You can find info on it with the command:\n\nAt this point the command:\n\nshould return nothing. You can try loading your shiny new module with:\n\nThe dash character will get converted to an underscore, so when you again try:\n\nYou should now see your loaded module. It can be removed again with:\n\nNotice that the dash was replaced by an underscore. To see what just happened in the logs:\n\nYou now know the basics of creating, compiling, installing and removing modules. Now for more of a description of how this module works.\n\nKernel modules must have at least two functions: a \"start\" (initialization) function called which is called when the module is ed into the kernel, and an \"end\" (cleanup) function called which is called just before it is removed from the kernel. Actually, things have changed starting with kernel 2.3.13. You can now use whatever name you like for the start and end functions of a module, and you will learn how to do this in Section 4.2. In fact, the new method is the preferred method. However, many people still use and for their start and end functions.\n\nTypically, either registers a handler for something with the kernel, or it replaces one of the kernel functions with its own code (usually code to do something and then call the original function). The function is supposed to undo whatever did, so the module can be unloaded safely.\n\nLastly, every kernel module needs to include <linux/module.h>. We needed to include <linux/printk.h> only for the macro expansion for the log level, which you’ll learn about in Section 2.\n• A point about coding style. Another thing which may not be immediately obvious to anyone getting started with kernel programming is that indentation within your code should be using and . It is one of the coding conventions of the kernel. You may not like it, but you’ll need to get used to it if you ever submit a patch upstream.\n• Introducing print macros. In the beginning there was , usually followed by a priority such as or . More recently this can also be expressed in abbreviated form using a set of print macros, such as and . This just saves some mindless keyboard bashing and looks a bit neater. They can be found within include/linux/printk.h. Take time to read through the available priority macros.\n• About Compiling. Kernel modules need to be compiled a bit differently from regular userspace apps. Former kernel versions required us to care much about these settings, which are usually stored in Makefiles. Although hierarchically organized, many redundant settings accumulated in sublevel Makefiles and made them large and rather difficult to maintain. Fortunately, there is a new way of doing these things, called kbuild, and the build process for external loadable modules is now fully integrated into the standard kernel build mechanism. To learn more on how to compile modules which are not part of the official kernel (such as all the examples you will find in this guide), see file Documentation/kbuild/modules.rst. Additional details about Makefiles for kernel modules are available in Documentation/kbuild/makefiles.rst. Be sure to read this and the related files before starting to hack Makefiles. It will probably save you lots of work. Here is another exercise for the reader. See that comment above the return statement in ? Change the return value to something negative, recompile and load the module again. What happens?\n\nIn early kernel versions you had to use the and functions, as in the first hello world example, but these days you can name those anything you want by using the and macros. These macros are defined in include/linux/module.h. The only requirement is that your init and cleanup functions must be defined before calling those macros, otherwise you’ll get compilation errors. Here is an example of this technique:\n\nSo now we have two real kernel modules under our belt. Adding another module is as simple as this:\n\nNow have a look at drivers/char/Makefile for a real world example. As you can see, some things got hardwired into the kernel (obj-y) but where have all those obj-m gone? Those familiar with shell scripts will easily be able to spot them. For those who are not, the obj-$(CONFIG_FOO) entries you see everywhere expand into obj-y or obj-m, depending on whether the CONFIG_FOO variable has been set to y or m. While we are at it, those were exactly the kind of variables that you have set in the .config file in the top-level directory of Linux kernel source tree, the last time when you said or something like that.\n\nThe macro causes the init function to be discarded and its memory freed once the init function finishes for built-in drivers, but not loadable modules. If you think about when the init function is invoked, this makes perfect sense.\n\nThere is also an which works similarly to but for init variables rather than functions.\n\nThe macro causes the omission of the function when the module is built into the kernel, and like , has no effect for loadable modules. Again, if you consider when the cleanup function runs, this makes complete sense; built-in drivers do not need a cleanup function, while loadable modules do.\n\nThese macros are defined in include/linux/init.h and serve to free up kernel memory. When you boot your kernel and see something like Freeing unused kernel memory: 236k freed, this is precisely what the kernel is freeing.\n\nHonestly, who loads or even cares about proprietary modules? If you do then you might have seen something like this:\n\nYou can use a few macros to indicate the license for your module. Some examples are \"GPL\", \"GPL v2\", \"GPL and additional rights\", \"Dual BSD/GPL\", \"Dual MIT/GPL\", \"Dual MPL/GPL\" and \"Proprietary\". They are defined within include/linux/module.h.\n\nTo reference what license you’re using a macro is available called . This and a few other macros describing the module are illustrated in the below example.\n\nModules can take command line arguments, but not with the argc/argv you might be used to.\n\nTo allow arguments to be passed to your module, declare the variables that will take the values of the command line arguments as global and then use the macro, (defined in include/linux/moduleparam.h) to set the mechanism up. At runtime, will fill the variables with any command line arguments that are given, like . The variable declarations and macros should be placed at the beginning of the module for clarity. The example code should clear up my admittedly lousy explanation.\n\nThe macro takes 3 arguments: the name of the variable, its type and permissions for the corresponding file in sysfs. Integer types can be signed as usual or unsigned. If you’d like to use arrays of integers or strings see and .\n\nArrays are supported too, but things are a bit different now than they were in the olden days. To keep track of the number of parameters you need to pass a pointer to a count variable as third parameter. At your option, you could also ignore the count and pass instead. We show both possibilities here:\n\nA good use for this is to have the module variable’s default values set, like a port or IO address. If the variables contain the default values, then perform autodetection (explained elsewhere). Otherwise, keep the current value. This will be made clear later on.\n\nLastly, there is a macro function, , that is used to document arguments that the module can take. It takes two parameters: a variable name and a free form string describing that variable.\n\nIt is recommended to experiment with the following code:\n\nSometimes it makes sense to divide a kernel module between several source files.\n\nHere is an example of such a kernel module.\n\nThis is the complete makefile for all the examples we have seen so far. The first five lines are nothing special, but for the last example we will need two lines. First we invent an object name for our combined module, second we tell what object files are part of that module.\n\nObviously, we strongly suggest you to recompile your kernel, so that you can enable a number of useful debugging features, such as forced module unloading ( ): when this option is enabled, you can force the kernel to unload a module even when it believes it is unsafe, via a command. This option can save you a lot of time and a number of reboots during the development of a module. If you do not want to recompile your kernel then you should consider running the examples within a test distribution on a virtual machine. If you mess anything up then you can easily reboot or restore the virtual machine (VM).\n\nThere are a number of cases in which you may want to load your module into a precompiled running kernel, such as the ones shipped with common Linux distributions, or a kernel you have compiled in the past. In certain circumstances you could require to compile and insert a module into a running kernel which you are not allowed to recompile, or on a machine that you prefer not to reboot. If you can’t think of a case that will force you to use modules for a precompiled kernel you might want to skip this and treat the rest of this chapter as a big footnote.\n\nNow, if you just install a kernel source tree, use it to compile your kernel module and you try to insert your module into the kernel, in most cases you would obtain an error as follows:\n\nLess cryptic information is logged to the systemd journal:\n\nIn other words, your kernel refuses to accept your module because version strings (more precisely, version magic, see include/linux/vermagic.h) do not match. Incidentally, version magic strings are stored in the module object in the form of a static string, starting with . Version data are inserted in your module when it is linked against the kernel/module.o file. To inspect version magics and other strings stored in a given module, issue the command :\n\nTo overcome this problem we could resort to the --force-vermagic option, but this solution is potentially unsafe, and unquestionably unacceptable in production modules. Consequently, we want to compile our module in an environment which was identical to the one in which our precompiled kernel was built. How to do this, is the subject of the remainder of this chapter.\n\nFirst of all, make sure that a kernel source tree is available, having exactly the same version as your current kernel. Then, find the configuration file which was used to compile your precompiled kernel. Usually, this is available in your current boot directory, under a name like config-5.14.x. You may just want to copy it to your kernel source tree: .\n\nLet’s focus again on the previous error message: a closer look at the version magic strings suggests that, even with two configuration files which are exactly the same, a slight difference in the version magic could be possible, and it is sufficient to prevent insertion of the module into the kernel. That slight difference, namely the custom string which appears in the module’s version magic and not in the kernel’s one, is due to a modification with respect to the original, in the makefile that some distributions include. Then, examine your Makefile, and make sure that the specified version information matches exactly the one used for your current kernel. For example, your makefile could start as follows:\n\nIn this case, you need to restore the value of symbol EXTRAVERSION to -rc2. We suggest keeping a backup copy of the makefile used to compile your kernel available in /lib/modules/5.14.0-rc2/build. A simple command as following should suffice.\n\nHere is the Linux kernel source you are attempting to build.\n\nNow, please run to update configuration and version headers and objects:\n\nIf you do not desire to actually compile the kernel, you can interrupt the build process (CTRL-C) just after the SPLIT line, because at that time, the files you need are ready. Now you can turn back to the directory of your module and compile it: It will be built exactly according to your current kernel settings, and it will load into it without any errors.\n\nA typical program starts with a function, executes a series of instructions, and terminates after completing these instructions. Kernel modules, however, follow a different pattern. A module always begins with either the function or a function designated by the call. This function acts as the module’s entry point, informing the kernel of the module’s functionalities and preparing the kernel to utilize the module’s functions when necessary. After performing these tasks, the entry function returns, and the module remains inactive until the kernel requires its code.\n\nAll modules conclude by invoking either or a function specified through the call. This serves as the module’s exit function, reversing the actions of the entry function by unregistering the previously registered functionalities.\n\nIt is mandatory for every module to have both an entry and an exit function. While there are multiple methods to define these functions, the terms “entry function” and “exit function” are generally used. However, they may occasionally be referred to as and , which are understood to mean the same.\n\nProgrammers use functions they do not define all the time. A prime example of this is . You use these library functions which are provided by the standard C library, libc. The definitions for these functions do not actually enter your program until the linking stage, which ensures that the code (for for example) is available, and fixes the call instruction to point to that code.\n\nKernel modules are different here, too. In the hello world example, you might have noticed that we used a function, but did not include a standard I/O library. That is because modules are object files whose symbols get resolved upon running or . The definition for the symbols comes from the kernel itself; the only external functions you can use are the ones provided by the kernel. If you’re curious about what symbols have been exported by your kernel, take a look at /proc/kallsyms.\n\nOne point to keep in mind is the difference between library functions and system calls. Library functions are higher level, run completely in user space and provide a more convenient interface for the programmer to the functions that do the real work — system calls. System calls run in kernel mode on the user’s behalf and are provided by the kernel itself. The library function may look like a very general printing function, but all it really does is format the data into strings and write the string data using the low-level system call , which then sends the data to standard output.\n\nWould you like to see what system calls are made by ? It is easy! Compile the following program:\n\nwith . Run the executable with . Are you impressed? Every line you see corresponds to a system call. strace is a handy program that gives you details about what system calls a program is making, including which call is made, what its arguments are and what it returns. It is an invaluable tool for figuring out things like what files a program is trying to access. Towards the end, you will see a line which looks like . There it is. The face behind the mask. You may not be familiar with write, since most people use library functions for file I/O (like , , ). If that is the case, try looking at man 2 write. The 2nd man section is devoted to system calls (like and ). The 3rd man section is devoted to library calls, which you would probably be more familiar with (like and ).\n\nYou can even write modules to replace the kernel’s system calls, which we will do shortly. Crackers often make use of this sort of thing for backdoors or trojans, but you can write your own modules to do more benign things, like have the kernel write Tee hee, that tickles! every time someone tries to delete a file on your system.\n\nThe kernel primarily manages access to resources, be it a video card, hard drive, or memory. Programs frequently vie for the same resources. For instance, as a document is saved, updatedb might commence updating the locate database. Sessions in editors like vim and processes like updatedb can simultaneously utilize the hard drive. The kernel’s role is to maintain order, ensuring that users do not access resources indiscriminately.\n\nTo manage this, CPUs operate in different modes, each offering varying levels of system control. The Intel 80386 architecture, for example, featured four such modes, known as rings. Unix, however, utilizes only two of these rings: the highest ring (ring 0, also known as “supervisor mode”, where all actions are permissible) and the lowest ring, referred to as “user mode”.\n\nRecall the discussion about library functions vs system calls. Typically, you use a library function in user mode. The library function calls one or more system calls, and these system calls execute on the library function’s behalf, but do so in supervisor mode since they are part of the kernel itself. Once the system call completes its task, it returns and execution gets transferred back to user mode.\n\nWhen you write a small C program, you use variables which are convenient and make sense to the reader. If, on the other hand, you are writing routines which will be part of a bigger problem, any global variables you have are part of a community of other peoples’ global variables; some of the variable names can clash. When a program has lots of global variables which aren’t meaningful enough to be distinguished, you get namespace pollution. In large projects, effort must be made to remember reserved names, and to find ways to develop a scheme for naming unique variable names and symbols.\n\nWhen writing kernel code, even the smallest module will be linked against the entire kernel, so this is definitely an issue. The best way to deal with this is to declare all your variables as static and to use a well-defined prefix for your symbols. By convention, all kernel prefixes are lowercase. If you do not want to declare everything as static, another option is to declare a symbol table and register it with the kernel. We will get to this later.\n\nThe file /proc/kallsyms holds all the symbols that the kernel knows about and which are therefore accessible to your modules since they share the kernel’s codespace.\n\nMemory management is a very complicated subject and the majority of O’Reilly’s Understanding The Linux Kernel exclusively covers memory management! We are not setting out to be experts on memory managements, but we do need to know a couple of facts to even begin worrying about writing real modules.\n\nIf you have not thought about what a segfault really means, you may be surprised to hear that pointers do not actually point to memory locations. Not real ones, anyway. When a process is created, the kernel sets aside a portion of real physical memory and hands it to the process to use for its executing code, variables, stack, heap and other things which a computer scientist would know about. This memory begins with 0x00000000 and extends up to whatever it needs to be. Since the memory space for any two processes do not overlap, every process that can access a memory address, say 0xbffff978, would be accessing a different location in real physical memory! The processes would be accessing an index named 0xbffff978 which points to some kind of offset into the region of memory set aside for that particular process. For the most part, a process like our Hello, World program can’t access the space of another process, although there are ways which we will talk about later.\n\nThe kernel has its own space of memory as well. Since a module is code which can be dynamically inserted and removed in the kernel (as opposed to a semi-autonomous object), it shares the kernel’s codespace rather than having its own. Therefore, if your module segfaults, the kernel segfaults. And if you start writing over data because of an off-by-one error, then you’re trampling on kernel data (or code). This is even worse than it sounds, so try your best to be careful.\n\nIt should be noted that the aforementioned discussion applies to any operating system utilizing a monolithic kernel. This concept differs slightly from “building all your modules into the kernel”, although the underlying principle is similar. In contrast, there are microkernels, where modules are allocated their own code space. Two notable examples of microkernels include the GNU Hurd and the Zircon kernel of Google’s Fuchsia.\n\nOne class of module is the device driver, which provides functionality for hardware like a serial port. On Unix, each piece of hardware is represented by a file located in /dev named a device file which provides the means to communicate with the hardware. The device driver provides the communication on behalf of a user program. So the es1370.ko sound card device driver might connect the /dev/sound device file to the Ensoniq IS1370 sound card. A userspace program like mp3blaster can use /dev/sound without ever knowing what kind of sound card is installed.\n\nLet’s look at some device files. Here are device files which represent the first three partitions on the primary master IDE hard drive:\n\nNotice the column of numbers separated by a comma. The first number is called the device’s major number. The second number is the minor number. The major number tells you which driver is used to access the hardware. Each driver is assigned a unique major number; all device files with the same major number are controlled by the same driver. All the above major numbers are 3, because they’re all controlled by the same driver.\n\nThe minor number is used by the driver to distinguish between the various hardware it controls. Returning to the example above, although all three devices are handled by the same driver they have unique minor numbers because the driver sees them as being different pieces of hardware.\n\nDevices are divided into two types: character devices and block devices. The difference is that block devices have a buffer for requests, so they can choose the best order in which to respond to the requests. This is important in the case of storage devices, where it is faster to read or write sectors which are close to each other, rather than those which are further apart. Another difference is that block devices can only accept input and return output in blocks (whose size can vary according to the device), whereas character devices are allowed to use as many or as few bytes as they like. Most devices in the world are character, because they don’t need this type of buffering, and they don’t operate with a fixed block size. You can tell whether a device file is for a block device or a character device by looking at the first character in the output of . If it is ‘b’ then it is a block device, and if it is ‘c’ then it is a character device. The devices you see above are block devices. Here are some character devices (the serial ports):\n\nIf you want to see which major numbers have been assigned, you can look at Documentation/admin-guide/devices.txt.\n\nWhen the system was installed, all of those device files were created by the command. To create a new char device named coffee with major/minor number 12 and 2, simply do . You do not have to put your device files into /dev, but it is done by convention. Linus put his device files in /dev, and so should you. However, when creating a device file for testing purposes, it is probably OK to place it in your working directory where you compile the kernel module. Just be sure to put it in the right place when you’re done writing the device driver.\n\nA few final points, although implicit in the previous discussion, are worth stating explicitly for clarity. When a device file is accessed, the kernel utilizes the file’s major number to identify the appropriate driver for handling the access. This indicates that the kernel does not necessarily rely on or need to be aware of the minor number. It is the driver that concerns itself with the minor number, using it to differentiate between various pieces of hardware.\n\nIt is important to note that when referring to “hardware”, the term is used in a slightly more abstract sense than just a physical PCI card that can be held in hand. Consider the following two device files:\n\nBy now you can look at these two device files and know instantly that they are block devices and are handled by same driver (block major 8). Sometimes two device files with the same major but different minor number can actually represent the same piece of physical hardware. So just be aware that the word “hardware” in our discussion can mean something very abstract.\n\nThe structure is defined in include/linux/fs.h, and holds pointers to functions defined by the driver that perform various operations on the device. Each field of the structure corresponds to the address of some function defined by the driver to handle a requested operation.\n\nFor example, every character driver needs to define a function that reads from the device. The structure holds the address of the module’s function that performs that operation. Here is what the definition looks like for kernel 5.4:\n\nSome operations are not implemented by a driver. For example, a driver that handles a video card will not need to read from a directory structure. The corresponding entries in the structure should be set to .\n\nThere is a gcc extension that makes assigning to this structure more convenient. You will see it in modern drivers, and may catch you by surprise. This is what the new way of assigning to the structure looks like:\n\nHowever, there is also a C99 way of assigning to elements of a structure, designated initializers, and this is definitely preferred over using the GNU extension. You should use this syntax in case someone wants to port your driver. It will help with compatibility:\n\nThe meaning is clear, and you should be aware that any member of the structure which you do not explicitly assign will be initialized to by gcc.\n\nAn instance of containing pointers to functions that are used to implement , , , … system calls is commonly named .\n\nSince Linux v3.14, the read, write and seek operations are guaranteed for thread-safe by using the specific lock, which makes the file position update to become the mutual exclusion. So, we can safely implement those operations without unnecessary locking.\n\nAdditionally, since Linux v5.6, the structure was introduced to replace the use of the structure when registering proc handlers. See more information in the 7.1 section.\n\nEach device is represented in the kernel by a file structure, which is defined in include/linux/fs.h. Be aware that a file is a kernel level structure and never appears in a user space program. It is not the same thing as a , which is defined by glibc and would never appear in a kernel space function. Also, its name is a bit misleading; it represents an abstract open ‘file’, not a file on a disk, which is represented by a structure named .\n\nAn instance of struct file is commonly named . You’ll also see it referred to as a struct file object. Resist the temptation.\n\nGo ahead and look at the definition of file. Most of the entries you see, like struct dentry are not used by device drivers, and you can ignore them. This is because drivers do not fill file directly; they only use structures contained in file which are created elsewhere.\n\nAs discussed earlier, char devices are accessed through device files, usually located in /dev. This is by convention. When writing a driver, it is OK to put the device file in your current directory. Just make sure you place it in /dev for a production driver. The major number tells you which driver handles which device file. The minor number is used only by the driver itself to differentiate which device it is operating on, just in case the driver handles more than one device.\n\nAdding a driver to your system means registering it with the kernel. This is synonymous with assigning it a major number during the module’s initialization. You do this by using the function, defined by include/linux/fs.h.\n\nWhere unsigned int major is the major number you want to request, is the name of the device as it will appear in /proc/devices and is a pointer to the table for your driver. A negative return value means the registration failed. Note that we didn’t pass the minor number to . That is because the kernel doesn’t care about the minor number; only our driver uses it.\n\nNow the question is, how do you get a major number without hijacking one that’s already in use? The easiest way would be to look through Documentation/admin-guide/devices.txt and pick an unused one. That is a bad way of doing things because you will never be sure if the number you picked will be assigned later. The answer is that you can ask the kernel to assign you a dynamic major number.\n\nIf you pass a major number of 0 to , the return value will be the dynamically allocated major number. The downside is that you can not make a device file in advance, since you do not know what the major number will be. There are a couple of ways to do this. First, the driver itself can print the newly assigned number and we can make the device file by hand. Second, the newly registered device will have an entry in /proc/devices, and we can either make the device file by hand or write a shell script to read the file in and make the device file. The third method is that we can have our driver make the device file using the function after a successful registration and during the call to .\n\nHowever, would occupy a range of minor numbers associated with the given major. The recommended way to reduce waste for char device registration is using cdev interface.\n\nThe newer interface completes the char device registration in two distinct steps. First, we should register a range of device numbers, which can be completed with or .\n\nThe choice between two different functions depends on whether you know the major numbers for your device. Using if you know the device major number and if you would like to allocate a dynamically-allocated major number.\n\nSecond, we should initialize the data structure for our char device and associate it with the device numbers. To initialize the , we can achieve by the similar sequence of the following codes.\n\nHowever, the common usage pattern will embed the within a device-specific structure of your own. In this case, we’ll need for the initialization.\n\nOnce we finish the initialization, we can add the char device to the system by using the .\n\nTo find an example using the interface, you can see ioctl.c described in section 9.\n\nWe can not allow the kernel module to be ’ed whenever root feels like it. If the device file is opened by a process and then we remove the kernel module, using the file would cause a call to the memory location where the appropriate function (read/write) used to be. If we are lucky, no other code was loaded there, and we’ll get an ugly error message. If we are unlucky, another kernel module was loaded into the same location, which means a jump into the middle of another function within the kernel. The results of this would be impossible to predict, but they can not be very positive.\n\nNormally, when you do not want to allow something, you return an error code (a negative number) from the function which is supposed to do it. With that’s impossible because it is a void function. However, there is a counter which keeps track of how many processes are using your module. You can see what its value is by looking at the 3rd field with the command or . If this number isn’t zero, will fail. Note that you do not have to check the counter within because the check will be performed for you by the system call , defined in include/linux/syscalls.h. You should not use this counter directly, but there are functions defined in include/linux/module.h which let you increase, decrease and display this counter:\n• : Return the value of reference count of current module.\n\nIt is important to keep the counter accurate; if you ever do lose track of the correct usage count, you will never be able to unload the module; it’s now reboot time, boys and girls. This is bound to happen to you sooner or later during a module’s development.\n\nThe next code sample creates a char driver named chardev. You can dump its device file.\n\n(or open the file with a program) and the driver will put the number of times the device file has been read from into the file. We do not support writing to the file (like ), but catch these attempts and tell the user that the operation is not supported. Don’t worry if you don’t see what we do with the data we read into the buffer; we don’t do much with it. We simply read in the data and print a message acknowledging that we received it.\n\nIn the multiple-threaded environment, without any protection, concurrent access to the same memory may lead to the race condition, and will not preserve the performance. In the kernel module, this problem may happen due to multiple instances accessing the shared resources. Therefore, a solution is to enforce the exclusive access. We use atomic Compare-And-Swap (CAS) to maintain the states, and , to determine whether the file is currently opened by someone or not. CAS compares the contents of a memory location with the expected value and, only if they are the same, modifies the contents of that memory location to the desired value. See more concurrency details in the 12 section.\n\nThe system calls, which are the major interface the kernel shows to the processes, generally stay the same across versions. A new system call may be added, but usually the old ones will behave exactly like they used to. This is necessary for backward compatibility – a new kernel version is not supposed to break regular processes. In most cases, the device files will also remain the same. On the other hand, the internal interfaces within the kernel can and do change between versions.\n\nThere are differences between different kernel versions, and if you want to support multiple kernel versions, you will find yourself having to code conditional compilation directives. The way to do this to compare the macro to the macro . In version a.b.c of the kernel, the value of this macro would be .\n\nIn Linux, there is an additional mechanism for the kernel and kernel modules to send information to processes — the /proc file system. Originally designed to allow easy access to information about processes (hence the name), it is now used by every bit of the kernel which has something interesting to report, such as /proc/modules which provides the list of modules and /proc/meminfo which gathers memory usage statistics.\n\nThe method to use the proc file system is very similar to the one used with device drivers — a structure is created with all the information needed for the /proc file, including pointers to any handler functions (in our case there is only one, the one called when somebody attempts to read from the /proc file). Then, registers the structure with the kernel and unregisters it.\n\nNormal file systems are located on a disk, rather than just in memory (which is where /proc is), and in that case the index-node (inode for short) number is a pointer to a disk location where the file’s inode is located. The inode contains information about the file, for example the file’s permissions, together with a pointer to the disk location or locations where the file’s data can be found.\n\nBecause we don’t get called when the file is opened or closed, there’s nowhere for us to put and in this module, and if the file is opened and then the module is removed, there’s no way to avoid the consequences.\n\nHere a simple example showing how to use a /proc file. This is the HelloWorld for the /proc filesystem. There are three parts: create the file /proc/helloworld in the function , return a value (and a buffer) when the file /proc/helloworld is read in the callback function , and delete the file /proc/helloworld in the function .\n\nThe /proc/helloworld is created when the module is loaded with the function . The return value is a pointer to , and it will be used to configure the file /proc/helloworld (for example, the owner of this file). A null return value means that the creation has failed.\n\nEvery time the file /proc/helloworld is read, the function is called. Two parameters of this function are very important: the buffer (the second parameter) and the offset (the fourth one). The content of the buffer will be returned to the application which read it (for example the command). The offset is the current position in the file. If the return value of the function is not null, then this function is called again. So be careful with this function, if it never returns zero, the read function is called endlessly.\n\nThe structure is defined in include/linux/proc_fs.h in Linux v5.6+. In older kernels, it used for custom hooks in /proc file system, but it contains some members that are unnecessary in VFS, and every time VFS expands set, /proc code comes bloated. On the other hand, not only the space, but also some operations were saved by this structure to improve its performance. For example, the file which never disappears in /proc can set the as to save 2 atomic ops, 1 allocation, 1 free in per open/read/close sequence.\n\nWe have seen a very simple example for a /proc file where we only read the file /proc/helloworld. It is also possible to write in a /proc file. It works the same way as read, a function is called when the /proc file is written. But there is a little difference with read, data comes from user, so you have to import data from user space to kernel space (with or )\n\nThe reason for or is that Linux memory (on Intel architecture, it may be different under some other processors) is segmented. This means that a pointer, by itself, does not reference a unique location in memory, only a location in a memory segment, and you need to know which memory segment it is to be able to use it. There is one memory segment for the kernel, and one for each of the processes.\n\nThe only memory segment accessible to a process is its own, so when writing regular programs to run as processes, there is no need to worry about segments. When you write a kernel module, normally you want to access the kernel memory segment, which is handled automatically by the system. However, when the content of a memory buffer needs to be passed between the currently running process and the kernel, the kernel function receives a pointer to the memory buffer which is in the process segment. The and macros allow you to access that memory. These functions handle only one character, you can handle several characters with and . As the buffer (in read or write function) is in kernel space, for write function you need to import data because it comes from user space, but not for the read function because data is already in kernel space.\n\nWe have seen how to read and write a /proc file with the /proc interface. But it is also possible to manage /proc file with inodes. The main concern is to use advanced functions, like permissions.\n\nIn Linux, there is a standard mechanism for file system registration. Since every file system has to have its own functions to handle inode and file operations, there is a special structure to hold pointers to all those functions, , which includes a pointer to .\n\nThe difference between file and inode operations is that file operations deal with the file itself whereas inode operations deal with ways of referencing the file, such as creating links to it.\n\nIn /proc, whenever we register a new file, we’re allowed to specify which will be used to access to it. This is the mechanism we use, a which includes a pointer to a which includes pointers to our and functions.\n\nAnother interesting point here is the function. This function is called whenever a process tries to do something with the /proc file, and it can decide whether to allow access or not. Right now it is only based on the operation and the uid of the current user (as available in current, a pointer to a structure which includes information on the currently running process), but it could be based on anything we like, such as what other processes are doing with the same file, the time of day, or the last input we received.\n\nIt is important to note that the standard roles of read and write are reversed in the kernel. Read functions are used for output, whereas write functions are used for input. The reason for that is that read and write refer to the user’s point of view — if a process reads something from the kernel, then the kernel needs to output it, and if a process writes something to the kernel, then the kernel receives it as input.\n\nStill hungry for procfs examples? Well, first of all keep in mind, there are rumors around, claiming that procfs is on its way out, consider using sysfs instead. Consider using this mechanism, in case you want to document something kernel related yourself.\n\nAs we have seen, writing a /proc file may be quite “complex”. So to help people writing /proc file, there is an API named that helps formatting a /proc file for output. It is based on sequence, which is composed of 3 functions: , , and . The API starts a sequence when a user read the /proc file.\n\nA sequence begins with the call of the function . If the return is a non value, the function is called; otherwise, the function is called directly. This function is an iterator, the goal is to go through all the data. Each time is called, the function is also called. It writes data values in the buffer read by the user. The function is called until it returns . The sequence ends when returns , then the function is called.\n\nBE CAREFUL: when a sequence is finished, another one starts. That means that at the end of function , the function is called again. This loop finishes when the function returns . You can see a scheme of this in the Figure 1.\n\nThe provides basic functions for , such as , , and some others. But nothing to write in the /proc file. Of course, you can still use the same way as in the previous example.\n\nIf you want more information, you can read this web page:\n\nYou can also read the code of fs/seq_file.c in the linux kernel.\n\nsysfs allows you to interact with the running kernel from userspace by reading or setting variables inside of modules. This can be useful for debugging purposes, or just as an interface for applications or scripts. You can find sysfs directories and files under the /sys directory on your system.\n\nAttributes can be exported for kobjects in the form of regular files in the filesystem. Sysfs forwards file I/O operations to methods defined for the attributes, providing a means to read and write kernel attributes.\n\nFor example, the driver model defines like:\n\nTo read or write attributes, or method must be specified when declaring the attribute. For the common cases include/linux/sysfs.h provides convenience macros ( , , , etc.) to make defining attributes easier as well as making code more concise and readable.\n\nAn example of a hello world module which includes the creation of a variable accessible via sysfs is given below.\n\nWhat is the current value of ?\n\nSet the value of and check that it changed.\n\nIn the above case, we use a simple kobject to create a directory under sysfs, and communicate with its attributes. Since Linux v2.6.0, the structure made its appearance. It was initially meant as a simple way of unifying kernel code which manages reference counted objects. After a bit of mission creep, it is now the glue that holds much of the device model and its sysfs interface together. For more information about kobject and sysfs, see Documentation/driver-api/driver-model/driver.rst and https://lwn.net/Articles/51437/.\n\nDevice files are supposed to represent physical devices. Most physical devices are used for output as well as input, so there has to be some mechanism for device drivers in the kernel to get the output to send to the device from processes. This is done by opening the device file for output and writing to it, just like writing to a file. In the following example, this is implemented by .\n\nThis is not always enough. Imagine you had a serial port connected to a modem (even if you have an internal modem, it is still implemented from the CPU’s perspective as a serial port connected to a modem, so you don’t have to tax your imagination too hard). The natural thing to do would be to use the device file to write things to the modem (either modem commands or data to be sent through the phone line) and read things from the modem (either responses for commands or the data received through the phone line). However, this leaves open the question of what to do when you need to talk to the serial port itself, for example to configure the rate at which data is sent and received.\n\nThe answer in Unix is to use a special function called (short for Input Output ConTroL). Every device can have its own commands, which can be read ioctl’s (to send information from a process to the kernel), write ioctl’s (to return information to a process), both or neither. Notice here the roles of read and write are reversed again, so in ioctl’s read is to send information to the kernel and write is to receive information from the kernel.\n\nThe ioctl function is called with three parameters: the file descriptor of the appropriate device file, the ioctl number, and a parameter, which is of type long so you can use a cast to use it to pass anything. You will not be able to pass a structure this way, but you will be able to pass a pointer to the structure. Here is an example:\n\nYou can see there is an argument called in function. It is the ioctl number. The ioctl number encodes the major device number, the type of the ioctl, the command, and the type of the parameter. This ioctl number is usually created by a macro call ( , , or — depending on the type) in a header file. This header file should then be included both by the programs which will use ioctl (so they can generate the appropriate ioctl’s) and by the kernel module (so it can understand it). In the example below, the header file is chardev.h and the program which uses it is userspace_ioctl.c.\n\nIf you want to use ioctls in your own kernel modules, it is best to receive an official ioctl assignment, so if you accidentally get somebody else’s ioctls, or if they get yours, you’ll know something is wrong. For more information, consult the kernel source tree at Documentation/userspace-api/ioctl/ioctl-number.rst.\n\nAlso, we need to be careful that concurrent access to the shared resources will lead to the race condition. The solution is using atomic Compare-And-Swap (CAS), which we mentioned at 6.5 section, to enforce the exclusive access.\n\nSo far, the only thing we’ve done was to use well defined kernel mechanisms to register /proc files and device handlers. This is fine if you want to do something the kernel programmers thought you’d want, such as write a device driver. But what if you want to do something unusual, to change the behavior of the system in some way? Then, you are mostly on your own.\n\nShould one choose not to use a virtual machine, kernel programming can become risky. For example, while writing the code below, the system call was inadvertently disrupted. This resulted in an inability to open any files, run programs, or shut down the system, necessitating a restart of the virtual machine. Fortunately, no critical files were lost in this instance. However, if such modifications were made on a live, mission-critical system, the consequences could be severe. To mitigate the risk of file loss, even in a test environment, it is advised to execute right before using and .\n\nForget about /proc files, forget about device files. They are just minor details. Minutiae in the vast expanse of the universe. The real process to kernel communication mechanism, the one used by all processes, is system calls. When a process requests a service from the kernel (such as opening a file, forking to a new process, or requesting more memory), this is the mechanism used. If you want to change the behaviour of the kernel in interesting ways, this is the place to do it. By the way, if you want to see which system calls a program uses, run .\n\nIn general, a process is not supposed to be able to access the kernel. It can not access kernel memory and it can’t call kernel functions. The hardware of the CPU enforces this (that is the reason why it is called “protected mode” or “page protection”).\n\nSystem calls are an exception to this general rule. What happens is that the process fills the registers with the appropriate values and then calls a special instruction which jumps to a previously defined location in the kernel (of course, that location is readable by user processes, it is not writable by them). Under Intel CPUs, this is done by means of interrupt 0x80. The hardware knows that once you jump to this location, you are no longer running in restricted user mode, but as the operating system kernel — and therefore you’re allowed to do whatever you want.\n\nThe location in the kernel a process can jump to is called system_call. The procedure at that location checks the system call number, which tells the kernel what service the process requested. Then, it looks at the table of system calls ( ) to see the address of the kernel function to call. Then it calls the function, and after it returns, does a few system checks and then return back to the process (or to a different process, if the process time ran out). If you want to read this code, it is at the source file arch/$(architecture)/kernel/entry.S, after the line .\n\nSo, if we want to change the way a certain system call works, what we need to do is to write our own function to implement it (usually by adding a bit of our own code, and then calling the original function) and then change the pointer at to point to our function. Because we might be removed later and we don’t want to leave the system in an unstable state, it’s important for to restore the table to its original state.\n\nTo modify the content of , we need to consider the control register. A control register is a processor register that changes or controls the general behavior of the CPU. For x86 architecture, the cr0 register has various control flags that modify the basic operation of the processor. The WP flag in cr0 stands for write protection. Once the WP flag is set, the processor disallows further write attempts to the read-only sections Therefore, we must disable the WP flag before modifying . Since Linux v5.3, the function cannot be used because of the sensitive cr0 bits pinned by the security issue, the attacker may write into CPU control registers to disable CPU protections like write protection. As a result, we have to provide the custom assembly routine to bypass it.\n\nHowever, symbol is unexported to prevent misuse. But there have few ways to get the symbol, manual symbol lookup and . Here we use both depend on the kernel version.\n\nBecause of the control-flow integrity, which is a technique to prevent the redirect execution code from the attacker, for making sure that the indirect calls go to the expected addresses and the return addresses are not changed. Since Linux v5.7, the kernel patched the series of control-flow enforcement (CET) for x86, and some configurations of GCC, like GCC versions 9 and 10 in Ubuntu Linux, will add with CET (the -fcf-protection option) in the kernel by default. Using that GCC to compile the kernel with retpoline off may result in CET being enabled in the kernel. You can use the following command to check out the -fcf-protection option is enabled or not:\n\nBut CET should not be enabled in the kernel, it may break the Kprobes and bpf. Consequently, CET is disabled since v5.11. To guarantee the manual symbol lookup worked, we only use up to v5.4.\n\nUnfortunately, since Linux v5.7 is also unexported, it needs certain trick to get the address of . If is enabled, we can facilitate the retrieval of function addresses by means of Kprobes to dynamically break into the specific kernel routine. Kprobes inserts a breakpoint at the entry of function by replacing the first bytes of the probed instruction. When a CPU hits the breakpoint, registers are stored, and the control will pass to Kprobes. It passes the addresses of the saved registers and the Kprobe struct to the handler you defined, then executes it. Kprobes can be registered by symbol name or address. Within the symbol name, the address will be handled by the kernel.\n\nOtherwise, specify the address of from /proc/kallsyms and /boot/System.map into parameter. Following is the sample usage for /proc/kallsyms:\n\nUsing the address from /boot/System.map, be careful about KASLR (Kernel Address Space Layout Randomization). KASLR may randomize the address of kernel code and data at every boot time, such as the static address listed in /boot/System.map will offset by some entropy. The purpose of KASLR is to protect the kernel space from the attacker. Without KASLR, the attacker may find the target address in the fixed address easily. Then the attacker can use return-oriented programming to insert some malicious codes to execute or receive the target data by a tampered pointer. KASLR mitigates these kinds of attacks because the attacker cannot immediately know the target address, but a brute-force attack can still work. If the address of a symbol in /proc/kallsyms is different from the address in /boot/System.map, KASLR is enabled with the kernel, which your system running on.\n\nIf KASLR is enabled, we have to take care of the address from /proc/kallsyms each time we reboot the machine. In order to use the address from /boot/System.map, make sure that KASLR is disabled. You can add the nokaslr for disabling KASLR in next booting time:\n\nFor more information, check out the following:\n\nThe source code here is an example of such a kernel module. We want to “spy” on a certain user, and to a message whenever that user opens a file. Towards this end, we replace the system call to open a file with our own function, called . This function checks the uid (user’s id) of the current process, and if it is equal to the uid we spy on, it calls to display the name of the file to be opened. Then, either way, it calls the original function with the same parameters, to actually open the file.\n\nThe function replaces the appropriate location in and keeps the original pointer in a variable. The function uses that variable to restore everything back to normal. This approach is dangerous, because of the possibility of two kernel modules changing the same system call. Imagine we have two kernel modules, A and B. A’s openat system call will be and B’s will be . Now, when A is inserted into the kernel, the system call is replaced with , which will call the original when it is done. Next, B is inserted into the kernel, which replaces the system call with , which will call what it thinks is the original system call, , when it’s done.\n\nNow, if B is removed first, everything will be well — it will simply restore the system call to , which calls the original. However, if A is removed and then B is removed, the system will crash. A’s removal will restore the system call to the original, , cutting B out of the loop. Then, when B is removed, it will restore the system call to what it thinks is the original, , which is no longer in memory. At first glance, it appears we could solve this particular problem by checking if the system call is equal to our open function and if so not changing it at all (so that B won’t change the system call when it is removed), but that will cause an even worse problem. When A is removed, it sees that the system call was changed to so that it is no longer pointing to , so it will not restore it to before it is removed from memory. Unfortunately, will still try to call which is no longer there, so that even without removing B the system would crash.\n\nFor x86 architecture, the system call table cannot be used to invoke a system call after commit 1e3ad78 since v6.9. This commit has been backported to long term stable kernels, like v5.15.154+, v6.1.85+, v6.6.26+ and v6.8.5+, see this answer for more details. In this case, thanks to Kprobes, a hook can be used instead on the system call entry to intercept the system call.\n\nNote that all the related problems make syscall stealing unfeasible for production use. In order to keep people from doing potential harmful things is no longer exported. This means, if you want to do something more than a mere dry run of this example, you will have to patch your current kernel in order to have exported.\n\nWhat do you do when somebody asks you for something you can not do right away? If you are a human being and you are bothered by a human being, the only thing you can say is: \"Not right now, I’m busy. Go away!\". But if you are a kernel module and you are bothered by a process, you have another possibility. You can put the process to sleep until you can service it. After all, processes are being put to sleep by the kernel and woken up all the time (that is the way multiple processes appear to run on the same time on a single CPU).\n\nThis kernel module is an example of this. The file (called /proc/sleep) can only be opened by a single process at a time. If the file is already open, the kernel module calls . The easiest way to keep a file open is to open it with:\n\nThis function changes the status of the task (a task is the kernel data structure which holds information about a process and the system call it is in, if any) to , which means that the task will not run until it is woken up somehow, and adds it to WaitQ, the queue of tasks waiting to access the file. Then, the function calls the scheduler to context switch to a different process, one which has some use for the CPU.\n\nWhen a process is done with the file, it closes it, and is called. That function wakes up all the processes in the queue (there’s no mechanism to only wake up one of them). It then returns and the process which just closed the file can continue to run. In time, the scheduler decides that that process has had enough and gives control of the CPU to another process. Eventually, one of the processes which was in the queue will be given control of the CPU by the scheduler. It starts at the point right after the call to .\n\nThis means that the process is still in kernel mode - as far as the process is concerned, it issued the open system call and the system call has not returned yet. The process does not know somebody else used the CPU for most of the time between the moment it issued the call and the moment it returned.\n\nIt can then proceed to set a global variable to tell all the other processes that the file is still open and go on with its life. When the other processes get a piece of the CPU, they’ll see that global variable and go back to sleep.\n\nSo we will use to keep the file open in the background, while trying to access it with another process (again in the background, so that we need not switch to a different vt). As soon as the first background process is killed with kill %1 , the second is woken up, is able to access the file and finally terminates.\n\nTo make our life more interesting, does not have a monopoly on waking up the processes which wait to access the file. A signal, such as Ctrl +c (SIGINT) can also wake up a process. This is because we used . We could have used instead, but that would have resulted in extremely angry users whose Ctrl+c’s are ignored.\n\nIn that case, we want to return with immediately. This is important so users can, for example, kill the process before it receives the file.\n\nThere is one more point to remember. Some times processes don’t want to sleep, they want either to get what they want immediately, or to be told it cannot be done. Such processes use the flag when opening the file. The kernel is supposed to respond by returning with the error code from operations which would otherwise block, such as opening the file in this example. The program , available in the examples/other directory, can be used to open a file with .\n\nSometimes one thing should happen before another within a module having multiple threads. Rather than using commands, the kernel has another way to do this which allows timeouts or interrupts to also happen.\n\nCompletions as code synchronization mechanism have three main parts, initialization of struct completion synchronization object, the waiting or barrier part through , and the signalling side through a call to .\n\nIn the subsequent example, two threads are initiated: crank and flywheel. It is imperative that the crank thread starts before the flywheel thread. A completion state is established for each of these threads, with a distinct completion defined for both the crank and flywheel threads. At the exit point of each thread the respective completion state is updated, and is used by the flywheel thread to ensure that it does not begin prematurely. The crank thread uses the function to update the completion, which lets the flywheel thread continue.\n\nSo even though is started first you should notice when you load this module and run , that turning the crank always happens first because the flywheel thread waits for the crank thread to complete.\n\nThere are other variations of the function, which include timeouts or being interrupted, but this basic mechanism is enough for many common situations without adding a lot of complexity.\n\nIf processes running on different CPUs or in different threads try to access the same memory, then it is possible that strange things can happen or your system can lock up. To avoid this, various types of mutual exclusion kernel functions are available. These indicate if a section of code is \"locked\" or \"unlocked\" so that simultaneous attempts to run it can not happen.\n\nYou can use kernel mutexes (mutual exclusions) in much the same manner that you might deploy them in userland. This may be all that is needed to avoid collisions in most cases.\n\nAs the name suggests, spinlocks lock up the CPU that the code is running on, taking 100% of its resources. Because of this you should only use the spinlock mechanism around code which is likely to take no more than a few milliseconds to run and so will not noticeably slow anything down from the user’s point of view.\n\nThe example here is \"irq safe\" in that if interrupts happen during the lock then they will not be forgotten and will activate when the unlock happens, using the variable to retain their state.\n\nTaking 100% of a CPU’s resources comes with greater responsibility. Situations where the kernel code monopolizes a CPU are called atomic contexts. Holding a spinlock is one of those situations. Sleeping in atomic contexts may leave the system hanging, as the occupied CPU devotes 100% of its resources doing nothing but sleeping. In some worse cases the system may crash. Thus, sleeping in atomic contexts is considered a bug in the kernel. They are sometimes called “sleep-in-atomic-context” in some materials.\n\nNote that sleeping here is not limited to calling the sleep functions explicitly. If subsequent function calls eventually invoke a function that sleeps, it is also considered sleeping. Thus, it is important to pay attention to functions being used in atomic context. There’s no documentation recording all such functions, but code comments may help. Sometimes you may find comments in kernel source code stating that a function “may sleep”, “might sleep”, or more explicitly “the caller should not hold a spinlock”. Those comments are hints that a function may implicitly sleep and must not be called in atomic contexts.\n\nRead and write locks are specialised kinds of spinlocks so that you can exclusively read from something or write to something. Like the earlier spinlocks example, the one below shows an \"irq safe\" situation in which if other functions were triggered from irqs which might also read and write to whatever you are concerned with then they would not disrupt the logic. As before it is a good idea to keep anything done within the lock as short as possible so that it does not hang up the system and cause users to start revolting against the tyranny of your module.\n\nOf course, if you know for sure that there are no functions triggered by irqs which could possibly interfere with your logic then you can use the simpler and or the corresponding write functions.\n\nIf you are doing simple arithmetic: adding, subtracting or bitwise operations, then there is another way in the multi-CPU and multi-hyperthreaded world to stop other parts of the system from messing with your mojo. By using atomic operations you can be confident that your addition, subtraction or bit flip did actually happen and was not overwritten by some other shenanigans. An example is shown below.\n\nBefore the C11 standard adopts the built-in atomic types, the kernel already provided a small set of atomic types by using a bunch of tricky architecture-specific codes. Implementing the atomic types by C11 atomics may allow the kernel to throw away the architecture-specific codes and letting the kernel code be more friendly to the people who understand the standard. But there are some problems, such as the memory model of the kernel doesn’t match the model formed by the C11 atomics. For further details, see:\n\nIn Section 1.7, it was noted that the X Window System and kernel module programming are not conducive to integration. This remains valid during the development of kernel modules. However, in practical scenarios, the necessity emerges to relay messages to the tty (teletype) originating the module load command.\n\nThe term “tty” originates from teletype, which initially referred to a combined keyboard-printer for Unix system communication. Today, it signifies a text stream abstraction employed by Unix programs, encompassing physical terminals, xterms in X displays, and network connections like SSH.\n\nTo achieve this, the “current” pointer is leveraged to access the active task’s tty structure. Within this structure lies a pointer to a string write function, facilitating the string’s transmission to the tty.\n\nIn certain conditions, you may desire a simpler and more direct way to communicate to the external world. Flashing keyboard LEDs can be such a solution: It is an immediate way to attract attention or to display a status condition. Keyboard LEDs are present on every hardware, they are always visible, they do not need any setup, and their use is rather simple and non-intrusive, compared to writing to a tty or a file.\n\nFrom v4.14 to v4.15, the timer API made a series of changes to improve memory safety. A buffer overflow in the area of a structure may be able to overwrite the and fields, providing the attacker with a way to use return-oriented programming (ROP) to call arbitrary functions within the kernel. Also, the function prototype of the callback, containing a argument, will prevent work from any type checking. Furthermore, the function prototype with argument may be an obstacle to the forward-edge protection of control-flow integrity. Thus, it is better to use a unique prototype to separate from the cluster that takes an argument. The timer callback should be passed a pointer to the structure rather than an argument. Then, it wraps all the information the callback needs, including the structure, into a larger structure, and it can use the macro instead of the value. For more information see: Improving the kernel timers API.\n\nBefore Linux v4.14, was used to initialize the timer and the structure looked like:\n\nSince Linux v4.14, is adopted and the kernel step by step converting to from . One of the reasons why API was changed is it need to coexist with the old version interface. Moreover, the was implemented by at first.\n\nThe was then removed since v4.15. As a result, the structure had changed to the following.\n\nThe following source code illustrates a minimal kernel module which, when loaded, starts blinking the keyboard LEDs until it is unloaded.\n\nIf none of the examples in this chapter fit your debugging needs, there might yet be some other tricks to try. Ever wondered what in is good for? If you activate that you get low level access to the serial port. While this might not sound very powerful by itself, you can patch kernel/printk.c or any other essential syscall to print ASCII characters, thus making it possible to trace virtually everything what your code does over a serial line. If you find yourself porting the kernel to some new and former unsupported architecture, this is usually amongst the first things that should be implemented. Logging over a netconsole might also be worth a try.\n\nWhile you have seen lots of stuff that can be used to aid debugging here, there are some things to be aware of. Debugging is almost always intrusive. Adding debug code can change the situation enough to make the bug seem to disappear. Thus, you should keep debug code to a minimum and make sure it does not show up in production code.\n\nGeneral Purpose Input/Output (GPIO) appears on the development board as pins. It acts as a bridge for communication between the development board and external devices. You can think of it like a switch: users can turn it on or off (Input), and the development board can also turn it on or off (Output).\n\nTo implement a GPIO device driver, you use the function to enable a specific GPIO pin. After successfully enabling it, you can check that the pin is being used by looking at /sys/kernel/debug/gpio.\n\nThere are other ways to register GPIOs. For example, you can use to register a GPIO while setting its direction (input or output) and initial state at the same time. You can also use to register multiple GPIOs at once. However, note that has been removed since Linux v6.10+.\n\nWhen using GPIO, you must set it as either output with or input with .\n• when the GPIO is set as output, you can use to choose to set it to high voltage or low voltage.\n• when the GPIO is set as input, you can use to read whether the voltage is high or low.\n\nIn Section 9, we learned how to communicate with device files. Therefore, we will further use device files to control the LED on and off.\n\nIn the implementation, a pull-down resistor is used. The anode of the LED is connected to GPIO4, and the cathode is connected to GND. For more details about the Raspberry Pi pin assignments, refer to Raspberry Pi Pinout. The materials used include a Raspberry Pi 5, an LED, jumper wires, and a 220Ω resistor.\n\nThere are two main ways of running tasks: tasklets and work queues. Tasklets are a quick and easy way of scheduling a single function to be run. For example, when triggered from an interrupt, whereas work queues are more complicated but also better suited to running multiple things in a sequence.\n\nIt is possible that in future tasklets may be replaced by threaded irqs. However, discussion about that has been ongoing since 2007 (Eliminating tasklets), so do not hold your breath. See the section 16.1 if you wish to avoid the tasklet debate.\n\nHere is an example tasklet module. The function runs for a few seconds. In the meantime, execution of the function may continue to the exit point, depending on whether it is interrupted by softirq.\n\nSo with this example loaded should show:\n\nAlthough tasklet is easy to use, it comes with several drawbacks, and developers are discussing about getting rid of tasklet in linux kernel. The tasklet callback runs in atomic context, inside a software interrupt, meaning that it cannot sleep or access user-space data, so not all work can be done in a tasklet handler. Also, the kernel only allows one instance of any given tasklet to be running at any given time; multiple different tasklet callbacks can run in parallel.\n\nIn recent kernels, tasklets can be replaced by workqueues, timers, or threaded interrupts. While the removal of tasklets remains a longer-term goal, the current kernel contains more than a hundred uses of tasklets. Now developers are proceeding with the API changes and the macro exists for compatibility. For further information, see https://lwn.net/Articles/830964/.\n\nTo add a task to the scheduler we can use a workqueue. The kernel then uses the Completely Fair Scheduler (CFS) to execute work within the queue.\n\nExcept for the last chapter, everything we did in the kernel so far we have done as a response to a process asking for it, either by dealing with a special file, sending an , or issuing a system call. But the job of the kernel is not just to respond to process requests. Another job, which is every bit as important, is to speak to the hardware connected to the machine.\n\nThere are two types of interaction between the CPU and the rest of the computer’s hardware. The first type is when the CPU gives orders to the hardware, the other is when the hardware needs to tell the CPU something. The second, called interrupts, is much harder to implement because it has to be dealt with when convenient for the hardware, not the CPU. Hardware devices typically have a very small amount of RAM, and if you do not read their information when available, it is lost.\n\nUnder Linux, hardware interrupts are called IRQ’s (Interrupt ReQuests). There are two types of IRQ’s, short and long. A short IRQ is one which is expected to take a very short period of time, during which the rest of the machine will be blocked and no other interrupts will be handled. A long IRQ is one which can take longer, and during which other interrupts may occur (but not interrupts from the same device). If at all possible, it is better to declare an interrupt handler to be long.\n\nWhen the CPU receives an interrupt, it stops whatever it is doing (unless it is processing a more important interrupt, in which case it will deal with this one only when the more important one is done), saves certain parameters on the stack and calls the interrupt handler. This means that certain things are not allowed in the interrupt handler itself, because the system is in an unknown state. Linux kernel solves the problem by splitting interrupt handling into two parts. The first part executes right away and masks the interrupt line. Hardware interrupts must be handled quickly, and that is why we need the second part to handle the heavy work deferred from an interrupt handler. Historically, BH (Linux naming for Bottom Halves) statistically book-keeps the deferred functions. Softirq and its higher level abstraction, Tasklet, replace BH since Linux 2.3.\n\nThe way to implement this is to call to get your interrupt handler called when the relevant IRQ is received.\n\nIn practice IRQ handling can be a bit more complex. Hardware is often designed in a way that chains two interrupt controllers, so that all the IRQs from interrupt controller B are cascaded to a certain IRQ from interrupt controller A. Of course, that requires that the kernel finds out which IRQ it really was afterwards and that adds overhead. Other architectures offer some special, very low overhead, so called \"fast IRQ\" or FIQs. To take advantage of them requires handlers to be written in assembly language, so they do not really fit into the kernel. They can be made to work similar to the others, but after that procedure, they are no longer any faster than \"common\" IRQs. SMP enabled kernels running on systems with more than one processor need to solve another truckload of problems. It is not enough to know if a certain IRQs has happened, it’s also important to know what CPU(s) it was for. People still interested in more details, might want to refer to \"APIC\" now.\n\nThis function receives the IRQ number, the name of the function, flags, a name for /proc/interrupts and a parameter to be passed to the interrupt handler. Usually there is a certain number of IRQs available. How many IRQs there are is hardware-dependent.\n\nThe flags can be used for specify behaviors of the IRQ. For example, use to indicate you are willing to share the IRQ with other interrupt handlers (usually because a number of hardware devices sit on the same IRQ); use the to indicate that the IRQ is not reenabled after the handler finished. It should be noted that in some materials, you may encounter another set of IRQ flags named with the prefix. For example, the and the . Those are the the IRQ flags in the older kernels. They have been removed completely. Today only the flags are in use. This function will only succeed if there is not already a handler on this IRQ, or if you are both willing to share.\n\nMany popular single board computers, such as Raspberry Pi or Beagleboards, have a bunch of GPIO pins. Attaching buttons to those and then having a button press do something is a classic case in which you might need to use interrupts, so that instead of having the CPU waste time and battery power polling for a change in input state, it is better for the input to trigger the CPU to then run a particular handling function.\n\nHere is an example where buttons are connected to GPIO numbers 17 and 18 and an LED is connected to GPIO 4. You can change those numbers to whatever is appropriate for your board.\n\nSuppose you want to do a bunch of stuff inside of an interrupt routine. A common way to do that without rendering the interrupt unavailable for a significant duration is to combine it with a tasklet. This pushes the bulk of the work off into the scheduler.\n\nThe example below modifies the previous example to also run an additional task when an interrupt is triggered.\n\nThreaded IRQ is a mechanism to organize both top-half and bottom-half of an IRQ at once. A threaded IRQ splits the one handler in into two: one for the top-half, the other for the bottom-half. The is the function for using threaded IRQs. Two handlers are registered at once in the .\n\nThose two handlers run in different context. The top-half handler runs in interrupt context. It’s the equivalence of the handler passed to the . The bottom-half handler on the other hand runs in its own thread. This thread is created on registration of a threaded IRQ. Its sole purpose is to run this bottom-half handler. This is where a threaded IRQ is “threaded”. If is returned by the top-half handler, that bottom-half serving thread will wake up. The thread then runs the bottom-half handler.\n\nHere is an example of how to do the same thing as before, with top and bottom halves, but using threads.\n\nA threaded IRQ is registered using . This function only takes one additional parameter than the – the bottom-half handling function that runs in its own thread. In this example it is the . Usage of other parameters are the same as .\n\nPresence of both handlers is not mandatory. If either of them is not needed, pass the instead. A top-half handler implies that no action is taken except to wake up the bottom-half serving thread, which runs the bottom-half handler. Similarly, a bottom-half handler effectively acts as if were used. In fact, this is how is implemented.\n\nNote that passing to both handlers is considered an error and will make registration fail.\n\nThe input device driver is a module that provides a way to communicate with the interaction device via the event. For example, the keyboard can send the press or release event to tell the kernel what we want to do. The input device driver will allocate a new input structure with and sets up input bitfields, device id, version, etc. After that, registers it by calling .\n\nHere is an example, vinput, It is an API to allow easy development of virtual input drivers. The drivers needs to export a that contains the virtual device name and structure that describes:\n\nThen using and will add a new device to the list of support virtual input devices.\n\nThis function is passed a already initialized with an allocated . The function is responsible for initializing the capabilities of the input device and register it.\n\nThis function will receive a user string to interpret and inject the event using the or call. The string is already copied from user.\n\nThis function is used for debugging and should fill the buffer parameter with the last event sent in the virtual input device format. The buffer will then be copied to user.\n\nvinput devices are created and destroyed using sysfs. And, event injection is done through a /dev node. The device name will be used by the userland to export a new virtual input device.\n\nThe structure is similar to other attribute types we talked about in section 8:\n\nIn vinput.c, the macro defined in include/linux/device.h (in this case, device.h is included in include/linux/input.h) will generate the structures which are named class_attr_export/unexport. Then, put them into array and the macro will generate the that should be assigned in . Finally, call to create attributes in sysfs.\n\nTo unexport the device, just echo its id in unexport:\n\nHere the virtual keyboard is one of example to use vinput. It supports all keycodes. The injection format is the such as defined in include/linux/input.h. A positive value means while a negative value is a . The keyboard supports repetition when the key stays pressed for too long. The following demonstrates how simulation work.\n\nUp to this point we have seen all kinds of modules doing all kinds of things, but there was no consistency in their interfaces with the rest of the kernel. To impose some consistency such that there is at minimum a standardized way to start, suspend and resume a device model was added. An example is shown below, and you can use this as a template to add your own suspend, resume or other interface functions.\n\nLikely and Unlikely conditions\n\nSometimes you might want your code to run as quickly as possible, especially if it is handling an interrupt or doing something which might cause noticeable latency. If your code contains boolean conditions and if you know that the conditions are almost always likely to evaluate as either or , then you can allow the compiler to optimize for this using the and macros. For example, when allocating memory you are almost always expecting this to succeed.\n\nWhen the macro is used, the compiler alters its machine instruction output, so that it continues along the false branch and only jumps if the condition is true. That avoids flushing the processor pipeline. The opposite happens if you use the macro.\n\nStatic keys allow us to enable or disable kernel code paths based on the runtime state of key. Its APIs have been available since 2010 (most architectures are already supported), use self-modifying code to eliminate the overhead of cache and branch prediction. The most typical use case of static keys is for performance-sensitive kernel code, such as tracepoints, context switching, networking, etc. These hot paths of the kernel often contain branches and can be optimized easily using this technique. Before we can use static keys in the kernel, we need to make sure that gcc supports inline assembly, and the following kernel configurations are set:\n\nTo declare a static key, we need to define a global variable using the or macro defined in include/linux/jump_label.h. This macro initializes the key with the given initial value, which is either false or true, respectively. For example, to declare a static key with an initial value of false, we can use the following code:\n\nOnce the static key has been declared, we need to add branching code to the module that uses the static key. For example, the code includes a fastpath, where a no-op instruction will be generated at compile time as the key is initialized to false and the branch is unlikely to be taken.\n\nIf the key is enabled at runtime by calling , the fastpath will be patched with an unconditional jump instruction to the slowpath code , so the branch will always be taken until the key is disabled again.\n\nThe following kernel module derived from chardev.c, demonstrates how the static key works.\n\nTo check the state of the static key, we can use the /dev/key_state interface.\n\nThis will display the current state of the key, which is disabled by default.\n\nTo change the state of the static key, we can perform a write operation on the file:\n\nThis will enable the static key, causing the code path to switch from the fastpath to the slowpath.\n\nIn some cases, the key is enabled or disabled at initialization and never changed, we can declare a static key as read-only, which means that it can only be toggled in the module init function. To declare a read-only static key, we can use the or macro instead. Attempts to change the key at runtime will result in a page fault. For more information, see Static keys\n\nYou can not do that. In a kernel module, you can only use kernel functions which are the functions you can see in /proc/kallsyms.\n\nYou might need to do this for a short time and that is OK, but if you do not enable them afterwards, your system will be stuck and you will have to power it off.\n\nWhere To Go From Here?\n\nFor those deeply interested in kernel programming, kernelnewbies.org and the Documentation subdirectory within the kernel source code are highly recommended. Although the latter may not always be straightforward, it serves as a valuable initial step for further exploration. Echoing Linus Torvalds’ perspective, the most effective method to understand the kernel is through personal examination of the source code.\n\nContributions to this guide are welcome, especially if there are any significant inaccuracies identified. To contribute or report an issue, please initiate an issue at https://github.com/sysprog21/lkmpg. Pull requests are greatly appreciated."
    },
    {
        "link": "https://tldp.org/LDP/lkmpg/2.6/lkmpg.pdf",
        "document": ""
    },
    {
        "link": "https://oreilly.com/library/view/linux-device-drivers/0596000081/ch03s03.html",
        "document": "In the next few sections, we’ll look at the various operations a driver can perform on the devices it manages. An open device is identified internally by a structure, and the kernel uses the structure to access the driver’s functions. The structure, defined in , is an array of function pointers. Each file is associated with its own set of functions (by including a field called that points to a structure). The operations are mostly in charge of implementing the system calls and are thus named open, read, and so on. We can consider the file to be an “object” and the functions operating on it to be its “methods,” using object-oriented programming terminology to denote actions declared by an object to act on itself. This is the first sign of object-oriented programming we see in the Linux kernel, and we’ll see more in later chapters.\n\nConventionally, a structure or a pointer to one is called (or some variation thereof); we’ve already seen one such pointer as an argument to the register_chrdev call. Each field in the structure must point to the function in the driver that implements a specific operation, or be left for unsupported operations. The exact behavior of the kernel when a pointer is specified is different for each function, as the list later in this section shows.\n\nThe structure has been slowly getting bigger as new functionality is added to the kernel. The addition of new operations can, of course, create portability problems for device drivers. Instantiations of the structure in each driver used to be declared using standard C syntax, and new operations were normally added to the end of the structure; a simple recompilation of the drivers would place a value for that operation, thus selecting the default behavior, usually what you wanted.\n\nSince then, kernel developers have switched to a “tagged” initialization format that allows initialization of structure fields by name, thus circumventing most problems with changed data structures. The tagged initialization, however, is not standard C but a (useful) extension specific to the GNU compiler. We will look at an example of tagged structure initialization shortly.\n\nThe following list introduces all the operations that an application can invoke on a device. We’ve tried to keep the list brief so it can be used as a reference, merely summarizing each operation and the default kernel behavior when a pointer is used. You can skip over this list on your first reading and return to it later.\n\nThe rest of the chapter, after describing another important data structure (the , which actually includes a pointer to its own ), explains the role of the most important operations and offers hints, caveats, and real code examples. We defer discussion of the more complex operations to later chapters because we aren’t ready to dig into topics like memory management, blocking operations, and asynchronous notification quite yet.\n\nThe following list shows what operations appear in for the 2.4 series of kernels, in the order in which they appear. Although there are minor differences between 2.4 and earlier kernels, they will be dealt with later in this chapter, so we are just sticking to 2.4 for a while. The return value of each operation is 0 for success or a negative error code to signal an error, unless otherwise noted.\n\nThe llseek method is used to change the current read/write position in a file, and the new position is returned as a (positive) return value. The is a “long offset” and is at least 64 bits wide even on 32-bit platforms. Errors are signaled by a negative return value. If the function is not specified for the driver, a seek relative to end-of-file fails, while other seeks succeed by modifying the position counter in the structure (described in Section 3.4 later in this chapter). Used to retrieve data from the device. A null pointer in this position causes the read system call to fail with (“Invalid argument”). A non-negative return value represents the number of bytes successfully read (the return value is a “signed size” type, usually the native integer type for the target platform). Sends data to the device. If missing, is returned to the program calling the write system call. The return value, if non-negative, represents the number of bytes successfully written. This field should be for device files; it is used for reading directories, and is only useful to filesystems. The poll method is the back end of two system calls, poll and select, both used to inquire if a device is readable or writable or in some special state. Either system call can block until a device becomes readable or writable. If a driver doesn’t define its poll method, the device is assumed to be both readable and writable, and in no special state. The return value is a bit mask describing the status of the device. The ioctl system call offers a way to issue device-specific commands (like formatting a track of a floppy disk, which is neither reading nor writing). Additionally, a few ioctl commands are recognized by the kernel without referring to the table. If the device doesn’t offer an ioctl entry point, the system call returns an error for any request that isn’t predefined ( , “No such ioctl for device”). If the device method returns a non-negative value, the same value is passed back to the calling program to indicate successful completion. mmap is used to request a mapping of device memory to a process’s address space. If the device doesn’t implement this method, the mmap system call returns . Though this is always the first operation performed on the device file, the driver is not required to declare a corresponding method. If this entry is , opening the device always succeeds, but your driver isn’t notified. The flush operation is invoked when a process closes its copy of a file descriptor for a device; it should execute (and wait for) any outstanding operations on the device. This must not be confused with the fsync operation requested by user programs. Currently, flush is used only in the network file system (NFS) code. If flush is , it is simply not invoked. This operation is invoked when the structure is being released. Like open, release can be missing.[ ] This method is the back end of the fsync system call, which a user calls to flush any pending data. If not implemented in the driver, the system call returns . This operation is used to notify the device of a change in its flag. Asynchronous notification is an advanced topic and is described in Chapter 5. The field can be if the driver doesn’t support asynchronous notification. The lock method is used to implement file locking; locking is an indispensable feature for regular files, but is almost never implemented by device drivers. These methods, added late in the 2.3 development cycle, implement scatter/gather read and write operations. Applications occasionally need to do a single read or write operation involving multiple memory areas; these system calls allow them to do so without forcing extra copy operations on the data. This field isn’t a method like everything else in the structure. Instead, it is a pointer to the module that “owns” this structure; it is used by the kernel to maintain the module’s usage count.\n\nThe scull device driver implements only the most important device methods, and uses the tagged format to declare its structure:\n\nThis declaration uses the tagged structure initialization syntax, as we described earlier. This syntax is preferred because it makes drivers more portable across changes in the definitions of the structures, and arguably makes the code more compact and readable. Tagged initialization allows the reordering of structure members; in some cases, substantial performance improvements have been realized by placing frequently accessed members in the same hardware cache line.\n\nIt is also necessary to set the field of the structure. In some kernel code, you will often see initialized with the rest of the structure, using the tagged syntax as follows:\n\nThat approach works, but only on 2.4 kernels. A more portable approach is to use the macro, which is defined in . scull performs this initialization as follows:\n\nThis macro works on any structure that has an field; we will encounter this field again in other contexts later in the book."
    },
    {
        "link": "https://tldp.org/LDP/lkmpg/2.6/html/lkmpg.html",
        "document": "When the first caveman programmer chiseled the first program on the walls of the first cave computer, it was a program to paint the string `Hello, world' in Antelope pictures. Roman programming textbooks began with the `Salut, Mundi' program. I don't know what happens to people who break with this tradition, but I think it's safer not to find out. We'll start with a series of hello world programs that demonstrate the different aspects of the basics of writing a kernel module. Here's the simplest module possible. Don't compile it yet; we'll cover module compilation in the next section. /* * hello-1.c - The simplest kernel module. */ #include <linux/module.h> /* Needed by all modules */ #include <linux/kernel.h> /* Needed for KERN_INFO */ int init_module(void) { printk(KERN_INFO \"Hello world 1.\n\n\"); /* * A non 0 return means init_module failed; module can't be loaded. */ return 0; } void cleanup_module(void) { printk(KERN_INFO \"Goodbye world 1.\n\n\"); } Kernel modules must have at least two functions: a \"start\" (initialization) function called which is called when the module is insmoded into the kernel, and an \"end\" (cleanup) function called which is called just before it is rmmoded. Actually, things have changed starting with kernel 2.3.13. You can now use whatever name you like for the start and end functions of a module, and you'll learn how to do this in Section 2.3. In fact, the new method is the preferred method. However, many people still use and for their start and end functions. Typically, either registers a handler for something with the kernel, or it replaces one of the kernel functions with its own code (usually code to do something and then call the original function). The function is supposed to undo whatever did, so the module can be unloaded safely. Lastly, every kernel module needs to include . We needed to include only for the macro expansion for the log level, , which you'll learn about in Section 2.1.1. Despite what you might think, was not meant to communicate information to the user, even though we used it for exactly this purpose in hello-1! It happens to be a logging mechanism for the kernel, and is used to log information or give warnings. Therefore, each statement comes with a priority, which is the and you see. There are 8 priorities and the kernel has macros for them, so you don't have to use cryptic numbers, and you can view them (and their meanings) in . If you don't specify a priority level, the default priority, , will be used. Take time to read through the priority macros. The header file also describes what each priority means. In practise, don't use number, like . Always use the macro, like . If the priority is less than , the message is printed on your current terminal. If both syslogd and klogd are running, then the message will also get appended to , whether it got printed to the console or not. We use a high priority, like , to make sure the messages get printed to your console rather than just logged to your logfile. When you write real modules, you'll want to use priorities that are meaningful for the situation at hand. Kernel modules need to be compiled a bit differently from regular userspace apps. Former kernel versions required us to care much about these settings, which are usually stored in Makefiles. Although hierarchically organized, many redundant settings accumulated in sublevel Makefiles and made them large and rather difficult to maintain. Fortunately, there is a new way of doing these things, called kbuild, and the build process for external loadable modules is now fully integrated into the standard kernel build mechanism. To learn more on how to compile modules which are not part of the official kernel (such as all the examples you'll find in this guide), see file . So, let's look at a simple Makefile for compiling a module named : obj-m += hello-1.o all: make -C /lib/modules/$(shell uname -r)/build M=$(PWD) modules clean: make -C /lib/modules/$(shell uname -r)/build M=$(PWD) clean From a technical point of view just the first line is really necessary, the \"all\" and \"clean\" targets were added for pure convenience. Now you can compile the module by issuing the command make . You should obtain an output which resembles the following: Note that kernel 2.6 introduces a new file naming convention: kernel modules now have a extension (in place of the old extension) which easily distinguishes them from conventional object files. The reason for this is that they contain an additional .modinfo section that where additional information about the module is kept. We'll soon see what this information is good for. Use modinfo hello-*.ko to see what kind of information it is. Nothing spectacular, so far. That changes once we're using modinfo on one of our the later examples, . Lot's of useful information to see here. An author string for bugreports, license information, even a short description of the parameters it accepts. Additional details about Makefiles for kernel modules are available in . Be sure to read this and the related files before starting to hack Makefiles. It'll probably save you lots of work. Now it is time to insert your freshly-compiled module it into the kernel with insmod ./hello-1.ko (ignore anything you see about tainted kernels; we'll cover that shortly). All modules loaded into the kernel are listed in . Go ahead and cat that file to see that your module is really a part of the kernel. Congratulations, you are now the author of Linux kernel code! When the novelty wears off, remove your module from the kernel by using rmmod hello-1. Take a look at just to see that it got logged to your system logfile. Here's another exercise for the reader. See that comment above the return statement in ? Change the return value to something negative, recompile and load the module again. What happens? As of Linux 2.4, you can rename the init and cleanup functions of your modules; they no longer have to be called and respectively. This is done with the and macros. These macros are defined in . The only caveat is that your init and cleanup functions must be defined before calling the macros, otherwise you'll get compilation errors. Here's an example of this technique: /* * hello-2.c - Demonstrating the module_init() and module_exit() macros. * This is preferred over using init_module() and cleanup_module(). */ #include <linux/module.h> /* Needed by all modules */ #include <linux/kernel.h> /* Needed for KERN_INFO */ #include <linux/init.h> /* Needed for the macros */ static int __init hello_2_init(void) { printk(KERN_INFO \"Hello, world 2\n\n\"); return 0; } static void __exit hello_2_exit(void) { printk(KERN_INFO \"Goodbye, world 2\n\n\"); } module_init(hello_2_init); module_exit(hello_2_exit); So now we have two real kernel modules under our belt. Adding another module is as simple as this: Example 2-4. Makefile for both our modules obj-m += hello-1.o obj-m += hello-2.o all: make -C /lib/modules/$(shell uname -r)/build M=$(PWD) modules clean: make -C /lib/modules/$(shell uname -r)/build M=$(PWD) clean Now have a look at for a real world example. As you can see, some things get hardwired into the kernel (obj-y) but where are all those obj-m gone? Those familiar with shell scripts will easily be able to spot them. For those not, the obj-$(CONFIG_FOO) entries you see everywhere expand into obj-y or obj-m, depending on whether the CONFIG_FOO variable has been set to y or m. While we are at it, those were exactly the kind of variables that you have set in the file, the last time when you said make menuconfig or something like that. 2.4. Hello World (part 3): The and Macros This demonstrates a feature of kernel 2.2 and later. Notice the change in the definitions of the init and cleanup functions. The macro causes the init function to be discarded and its memory freed once the init function finishes for built-in drivers, but not loadable modules. If you think about when the init function is invoked, this makes perfect sense. There is also an which works similarly to but for init variables rather than functions. The macro causes the omission of the function when the module is built into the kernel, and like , has no effect for loadable modules. Again, if you consider when the cleanup function runs, this makes complete sense; built-in drivers don't need a cleanup function, while loadable modules do. These macros are defined in and serve to free up kernel memory. When you boot your kernel and see something like , this is precisely what the kernel is freeing. /* * hello-3.c - Illustrating the __init, __initdata and __exit macros. */ #include <linux/module.h> /* Needed by all modules */ #include <linux/kernel.h> /* Needed for KERN_INFO */ #include <linux/init.h> /* Needed for the macros */ static int hello3_data __initdata = 3; static int __init hello_3_init(void) { printk(KERN_INFO \"Hello, world %d\n\n\", hello3_data); return 0; } static void __exit hello_3_exit(void) { printk(KERN_INFO \"Goodbye, world 3\n\n\"); } module_init(hello_3_init); module_exit(hello_3_exit); If you're running kernel 2.4 or later, you might have noticed something like this when you loaded proprietary modules: # insmod xxxxxx.o Warning: loading xxxxxx.ko will taint the kernel: no license See http://www.tux.org/lkml/#export-tainted for information about tainted modules Module xxxxxx loaded, with warnings In kernel 2.4 and later, a mechanism was devised to identify code licensed under the GPL (and friends) so people can be warned that the code is non open-source. This is accomplished by the macro which is demonstrated in the next piece of code. By setting the license to GPL, you can keep the warning from being printed. This license mechanism is defined and documented in : /* * The following license idents are currently accepted as indicating free * software modules * * \"GPL\" [GNU Public License v2 or later] * \"GPL v2\" [GNU Public License v2] * \"GPL and additional rights\" [GNU Public License v2 rights and more] * \"Dual BSD/GPL\" [GNU Public License v2 * or BSD license choice] * \"Dual MIT/GPL\" [GNU Public License v2 * or MIT license choice] * \"Dual MPL/GPL\" [GNU Public License v2 * or Mozilla license choice] * * The following other idents are available * * \"Proprietary\" [Non free products] * * There are dual licensed components, but when running with Linux it is the * GPL that is relevant so this is a non issue. Similarly LGPL linked with GPL * is a GPL combined work. * * This exists for several reasons * 1. So modinfo can show license info for users wanting to vet their setup * is free * 2. So the community can ignore bug reports including proprietary modules * 3. So vendors can do likewise based on their own policies */ Similarly, is used to describe what the module does, declares the module's author, and declares what types of devices the module supports. These macros are all defined in and aren't used by the kernel itself. They're simply for documentation and can be viewed by a tool like objdump. As an exercise to the reader, try and search fo these macros in to see how module authors use these macros to document their modules. I'd recommend to use something like grep -inr MODULE_AUTHOR * in . People unfamiliar with command line tools will probably like some web base solution, search for sites that offer kernel trees that got indexed with LXR. (or setup it up on your local machine). Users of traditional Unix editors, like emacs or vi will also find tag files useful. They can be generated by make tags or make TAGS in . Once you've got such a tagfile in your kerneltree you can put the cursor on some function call and use some key combination to directly jump to the definition function. /* * hello-4.c - Demonstrates module documentation. */ #include <linux/module.h> /* Needed by all modules */ #include <linux/kernel.h> /* Needed for KERN_INFO */ #include <linux/init.h> /* Needed for the macros */ #define DRIVER_AUTHOR \"Peter Jay Salzman <p@dirac.org>\" #define DRIVER_DESC \"A sample driver\" static int __init init_hello_4(void) { printk(KERN_INFO \"Hello, world 4\n\n\"); return 0; } static void __exit cleanup_hello_4(void) { printk(KERN_INFO \"Goodbye, world 4\n\n\"); } module_init(init_hello_4); module_exit(cleanup_hello_4); /* * You can use strings, like this: */ /* * Get rid of taint message by declaring code as GPL. */ MODULE_LICENSE(\"GPL\"); /* * Or with defines, like this: */ MODULE_AUTHOR(DRIVER_AUTHOR); /* Who wrote this module? */ MODULE_DESCRIPTION(DRIVER_DESC); /* What does this module do */ /* * This module uses /dev/testdevice. The MODULE_SUPPORTED_DEVICE macro might * be used in the future to help automatic configuration of modules, but is * currently unused other than for documentation purposes. */ MODULE_SUPPORTED_DEVICE(\"testdevice\"); Modules can take command line arguments, but not with the / you might be used to. To allow arguments to be passed to your module, declare the variables that will take the values of the command line arguments as global and then use the macro, (defined in ) to set the mechanism up. At runtime, insmod will fill the variables with any command line arguments that are given, like ./insmod mymodule.ko myvariable=5. The variable declarations and macros should be placed at the beginning of the module for clarity. The example code should clear up my admittedly lousy explanation. The macro takes 3 arguments: the name of the variable, its type and permissions for the corresponding file in sysfs. Integer types can be signed as usual or unsigned. If you'd like to use arrays of integers or strings see and . Arrays are supported too, but things are a bit different now than they were in the 2.4. days. To keep track of the number of parameters you need to pass a pointer to a count variable as third parameter. At your option, you could also ignore the count and pass NULL instead. We show both possibilities here: int myintarray[2]; module_param_array(myintarray, int, NULL, 0); /* not interested in count */ int myshortarray[4]; int count; module_parm_array(myshortarray, short, , 0); /* put count into \"count\" variable */ A good use for this is to have the module variable's default values set, like an port or IO address. If the variables contain the default values, then perform autodetection (explained elsewhere). Otherwise, keep the current value. This will be made clear later on. Lastly, there's a macro function, , that is used to document arguments that the module can take. It takes two parameters: a variable name and a free form string describing that variable. /* * hello-5.c - Demonstrates command line argument passing to a module. */ #include <linux/module.h> #include <linux/moduleparam.h> #include <linux/kernel.h> #include <linux/init.h> #include <linux/stat.h> MODULE_LICENSE(\"GPL\"); MODULE_AUTHOR(\"Peter Jay Salzman\"); static short int myshort = 1; static int myint = 420; static long int mylong = 9999; static char *mystring = \"blah\"; static int myintArray[2] = { -1, -1 }; static int arr_argc = 0; /* * module_param(foo, int, 0000) * The first param is the parameters name * The second param is it's data type * The final argument is the permissions bits, * for exposing parameters in sysfs (if non-zero) at a later stage. */ module_param(myshort, short, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP); MODULE_PARM_DESC(myshort, \"A short integer\"); module_param(myint, int, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH); MODULE_PARM_DESC(myint, \"An integer\"); module_param(mylong, long, S_IRUSR); MODULE_PARM_DESC(mylong, \"A long integer\"); module_param(mystring, charp, 0000); MODULE_PARM_DESC(mystring, \"A character string\"); /* * module_param_array(name, type, num, perm); * The first param is the parameter's (in this case the array's) name * The second param is the data type of the elements of the array * The third argument is a pointer to the variable that will store the number * of elements of the array initialized by the user at module loading time * The fourth argument is the permission bits */ module_param_array(myintArray, int, &arr_argc, 0000); MODULE_PARM_DESC(myintArray, \"An array of integers\"); static int __init hello_5_init(void) { int i; printk(KERN_INFO \"Hello, world 5\n\n=============\n\n\"); printk(KERN_INFO \"myshort is a short integer: %hd\n\n\", myshort); printk(KERN_INFO \"myint is an integer: %d\n\n\", myint); printk(KERN_INFO \"mylong is a long integer: %ld\n\n\", mylong); printk(KERN_INFO \"mystring is a string: %s\n\n\", mystring); for (i = 0; i < (sizeof myintArray / sizeof (int)); i++) { printk(KERN_INFO \"myintArray[%d] = %d\n\n\", i, myintArray[i]); } printk(KERN_INFO \"got %d arguments for myintArray.\n\n\", arr_argc); return 0; } static void __exit hello_5_exit(void) { printk(KERN_INFO \"Goodbye, world 5\n\n\"); } module_init(hello_5_init); module_exit(hello_5_exit); I would recommend playing around with this code: satan# insmod hello-5.ko mystring=\"bebop\" mybyte=255 myintArray=-1 mybyte is an 8 bit integer: 255 myshort is a short integer: 1 myint is an integer: 20 mylong is a long integer: 9999 mystring is a string: bebop myintArray is -1 and 420 satan# rmmod hello-5 Goodbye, world 5 satan# insmod hello-5.ko mystring=\"supercalifragilisticexpialidocious\" \\ > mybyte=256 myintArray=-1,-1 mybyte is an 8 bit integer: 0 myshort is a short integer: 1 myint is an integer: 20 mylong is a long integer: 9999 mystring is a string: supercalifragilisticexpialidocious myintArray is -1 and -1 satan# rmmod hello-5 Goodbye, world 5 satan# insmod hello-5.ko mylong=hello hello-5.o: invalid argument syntax for mylong: 'h' Sometimes it makes sense to divide a kernel module between several source files. Here's an example of such a kernel module. /* * start.c - Illustration of multi filed modules */ #include <linux/kernel.h> /* We're doing kernel work */ #include <linux/module.h> /* Specifically, a module */ int init_module(void) { printk(KERN_INFO \"Hello, world - this is the kernel speaking\n\n\"); return 0; } /* * stop.c - Illustration of multi filed modules */ #include <linux/kernel.h> /* We're doing kernel work */ #include <linux/module.h> /* Specifically, a module */ void cleanup_module() { printk(KERN_INFO \"Short is the life of a kernel module\n\n\"); } obj-m += hello-1.o obj-m += hello-2.o obj-m += hello-3.o obj-m += hello-4.o obj-m += hello-5.o obj-m += startstop.o startstop-objs := start.o stop.o all: make -C /lib/modules/$(shell uname -r)/build M=$(PWD) modules clean: make -C /lib/modules/$(shell uname -r)/build M=$(PWD) clean This is the complete makefile for all the examples we've seen so far. The first five lines are nothing special, but for the last example we'll need two lines. First we invent an object name for our combined module, second we tell make what object files are part of that module. Obviously, we strongly suggest you to recompile your kernel, so that you can enable a number of useful debugging features, such as forced module unloading ( ): when this option is enabled, you can force the kernel to unload a module even when it believes it is unsafe, via a rmmod -f module command. This option can save you a lot of time and a number of reboots during the development of a module. Nevertheless, there is a number of cases in which you may want to load your module into a precompiled running kernel, such as the ones shipped with common Linux distributions, or a kernel you have compiled in the past. In certain circumstances you could require to compile and insert a module into a running kernel which you are not allowed to recompile, or on a machine that you prefer not to reboot. If you can't think of a case that will force you to use modules for a precompiled kernel you might want to skip this and treat the rest of this chapter as a big footnote. Now, if you just install a kernel source tree, use it to compile your kernel module and you try to insert your module into the kernel, in most cases you would obtain an error as follows: Less cryptical information are logged to : In other words, your kernel refuses to accept your module because version strings (more precisely, version magics) do not match. Incidentally, version magics are stored in the module object in the form of a static string, starting with . Version data are inserted in your module when it is linked against the file. To inspect version magics and other strings stored in a given module, issue the modinfo module.ko command: To overcome this problem we could resort to the --force-vermagic option, but this solution is potentially unsafe, and unquestionably inacceptable in production modules. Consequently, we want to compile our module in an environment which was identical to the one in which our precompiled kernel was built. How to do this, is the subject of the remainder of this chapter. First of all, make sure that a kernel source tree is available, having exactly the same version as your current kernel. Then, find the configuration file which was used to compile your precompiled kernel. Usually, this is available in your current directory, under a name like . You may just want to copy it to your kernel source tree: cp /boot/config-`uname -r` /usr/src/linux-`uname -r`/.config. Let's focus again on the previous error message: a closer look at the version magic strings suggests that, even with two configuration files which are exactly the same, a slight difference in the version magic could be possible, and it is sufficient to prevent insertion of the module into the kernel. That slight difference, namely the string which appears in the module's version magic and not in the kernel's one, is due to a modification with respect to the original, in the makefile that some distribution include. Then, examine your , and make sure that the specified version information matches exactly the one used for your current kernel. For example, you makefile could start as follows: In this case, you need to restore the value of symbol to . We suggest to keep a backup copy of the makefile used to compile your kernel available in . A simple cp /lib/modules/`uname -r`/build/Makefile /usr/src/linux-`uname -r` should suffice. Additionally, if you already started a kernel build with the previous (wrong) , you should also rerun make, or directly modify symbol in file according to contents of file , or overwrite the latter with the first. Now, please run make to update configuration and version headers and objects: If you do not desire to actually compile the kernel, you can interrupt the build process (CTRL-C) just after the line, because at that time, the files you need will be are ready. Now you can turn back to the directory of your module and compile it: It will be built exactly according your current kernel settings, and it will load into it without any errors.\n\nA program usually begins with a function, executes a bunch of instructions and terminates upon completion of those instructions. Kernel modules work a bit differently. A module always begin with either the or the function you specify with call. This is the entry function for modules; it tells the kernel what functionality the module provides and sets up the kernel to run the module's functions when they're needed. Once it does this, entry function returns and the module does nothing until the kernel wants to do something with the code that the module provides. All modules end by calling either or the function you specify with the call. This is the exit function for modules; it undoes whatever entry function did. It unregisters the functionality that the entry function registered. Every module must have an entry function and an exit function. Since there's more than one way to specify entry and exit functions, I'll try my best to use the terms `entry function' and `exit function', but if I slip and simply refer to them as and , I think you'll know what I mean. Programmers use functions they don't define all the time. A prime example of this is . You use these library functions which are provided by the standard C library, libc. The definitions for these functions don't actually enter your program until the linking stage, which insures that the code (for for example) is available, and fixes the call instruction to point to that code. Kernel modules are different here, too. In the hello world example, you might have noticed that we used a function, but didn't include a standard I/O library. That's because modules are object files whose symbols get resolved upon insmod'ing. The definition for the symbols comes from the kernel itself; the only external functions you can use are the ones provided by the kernel. If you're curious about what symbols have been exported by your kernel, take a look at . One point to keep in mind is the difference between library functions and system calls. Library functions are higher level, run completely in user space and provide a more convenient interface for the programmer to the functions that do the real work---system calls. System calls run in kernel mode on the user's behalf and are provided by the kernel itself. The library function may look like a very general printing function, but all it really does is format the data into strings and write the string data using the low-level system call , which then sends the data to standard output. Would you like to see what system calls are made by ? It's easy! Compile the following program: with gcc -Wall -o hello hello.c. Run the exectable with strace ./hello. Are you impressed? Every line you see corresponds to a system call. strace is a handy program that gives you details about what system calls a program is making, including which call is made, what its arguments are what it returns. It's an invaluable tool for figuring out things like what files a program is trying to access. Towards the end, you'll see a line which looks like . There it is. The face behind the mask. You may not be familiar with write, since most people use library functions for file I/O (like fopen, fputs, fclose). If that's the case, try looking at man 2 write. The 2nd man section is devoted to system calls (like and . The 3rd man section is devoted to library calls, which you would probably be more familiar with (like and ). You can even write modules to replace the kernel's system calls, which we'll do shortly. Crackers often make use of this sort of thing for backdoors or trojans, but you can write your own modules to do more benign things, like have the kernel write Tee hee, that tickles! everytime someone tries to delete a file on your system. A kernel is all about access to resources, whether the resource in question happens to be a video card, a hard drive or even memory. Programs often compete for the same resource. As I just saved this document, updatedb started updating the locate database. My vim session and updatedb are both using the hard drive concurrently. The kernel needs to keep things orderly, and not give users access to resources whenever they feel like it. To this end, a CPU can run in different modes. Each mode gives a different level of freedom to do what you want on the system. The Intel 80386 architecture has 4 of these modes, which are called rings. Unix uses only two rings; the highest ring (ring 0, also known as `supervisor mode' where everything is allowed to happen) and the lowest ring, which is called `user mode'. Recall the discussion about library functions vs system calls. Typically, you use a library function in user mode. The library function calls one or more system calls, and these system calls execute on the library function's behalf, but do so in supervisor mode since they are part of the kernel itself. Once the system call completes its task, it returns and execution gets transfered back to user mode. When you write a small C program, you use variables which are convenient and make sense to the reader. If, on the other hand, you're writing routines which will be part of a bigger problem, any global variables you have are part of a community of other peoples' global variables; some of the variable names can clash. When a program has lots of global variables which aren't meaningful enough to be distinguished, you get namespace pollution. In large projects, effort must be made to remember reserved names, and to find ways to develop a scheme for naming unique variable names and symbols. When writing kernel code, even the smallest module will be linked against the entire kernel, so this is definitely an issue. The best way to deal with this is to declare all your variables as static and to use a well-defined prefix for your symbols. By convention, all kernel prefixes are lowercase. If you don't want to declare everything as static, another option is to declare a and register it with a kernel. We'll get to this later. The file holds all the symbols that the kernel knows about and which are therefore accessible to your modules since they share the kernel's codespace. Memory management is a very complicated subject---the majority of O'Reilly's `Understanding The Linux Kernel' is just on memory management! We're not setting out to be experts on memory managements, but we do need to know a couple of facts to even begin worrying about writing real modules. If you haven't thought about what a segfault really means, you may be surprised to hear that pointers don't actually point to memory locations. Not real ones, anyway. When a process is created, the kernel sets aside a portion of real physical memory and hands it to the process to use for its executing code, variables, stack, heap and other things which a computer scientist would know about. This memory begins with 0x00000000 and extends up to whatever it needs to be. Since the memory space for any two processes don't overlap, every process that can access a memory address, say , would be accessing a different location in real physical memory! The processes would be accessing an index named which points to some kind of offset into the region of memory set aside for that particular process. For the most part, a process like our Hello, World program can't access the space of another process, although there are ways which we'll talk about later. The kernel has its own space of memory as well. Since a module is code which can be dynamically inserted and removed in the kernel (as opposed to a semi-autonomous object), it shares the kernel's codespace rather than having its own. Therefore, if your module segfaults, the kernel segfaults. And if you start writing over data because of an off-by-one error, then you're trampling on kernel data (or code). This is even worse than it sounds, so try your best to be careful. By the way, I would like to point out that the above discussion is true for any operating system which uses a monolithic kernel. There are things called microkernels which have modules which get their own codespace. The GNU Hurd and QNX Neutrino are two examples of a microkernel. One class of module is the device driver, which provides functionality for hardware like a TV card or a serial port. On unix, each piece of hardware is represented by a file located in named a which provides the means to communicate with the hardware. The device driver provides the communication on behalf of a user program. So the sound card device driver might connect the device file to the Ensoniq IS1370 sound card. A userspace program like mp3blaster can use without ever knowing what kind of sound card is installed. Let's look at some device files. Here are device files which represent the first three partitions on the primary master IDE hard drive: Notice the column of numbers separated by a comma? The first number is called the device's major number. The second number is the minor number. The major number tells you which driver is used to access the hardware. Each driver is assigned a unique major number; all device files with the same major number are controlled by the same driver. All the above major numbers are 3, because they're all controlled by the same driver. The minor number is used by the driver to distinguish between the various hardware it controls. Returning to the example above, although all three devices are handled by the same driver they have unique minor numbers because the driver sees them as being different pieces of hardware. Devices are divided into two types: character devices and block devices. The difference is that block devices have a buffer for requests, so they can choose the best order in which to respond to the requests. This is important in the case of storage devices, where it's faster to read or write sectors which are close to each other, rather than those which are further apart. Another difference is that block devices can only accept input and return output in blocks (whose size can vary according to the device), whereas character devices are allowed to use as many or as few bytes as they like. Most devices in the world are character, because they don't need this type of buffering, and they don't operate with a fixed block size. You can tell whether a device file is for a block device or a character device by looking at the first character in the output of ls -l. If it's `b' then it's a block device, and if it's `c' then it's a character device. The devices you see above are block devices. Here are some character devices (the serial ports): If you want to see which major numbers have been assigned, you can look at . When the system was installed, all of those device files were created by the mknod command. To create a new char device named `coffee' with major/minor number and , simply do mknod /dev/coffee c 12 2. You don't have to put your device files into , but it's done by convention. Linus put his device files in , and so should you. However, when creating a device file for testing purposes, it's probably OK to place it in your working directory where you compile the kernel module. Just be sure to put it in the right place when you're done writing the device driver. I would like to make a few last points which are implicit from the above discussion, but I'd like to make them explicit just in case. When a device file is accessed, the kernel uses the major number of the file to determine which driver should be used to handle the access. This means that the kernel doesn't really need to use or even know about the minor number. The driver itself is the only thing that cares about the minor number. It uses the minor number to distinguish between different pieces of hardware. By the way, when I say `hardware', I mean something a bit more abstract than a PCI card that you can hold in your hand. Look at these two device files: By now you can look at these two device files and know instantly that they are block devices and are handled by same driver (block major ). You might even be aware that these both represent your floppy drive, even if you only have one floppy drive. Why two files? One represents the floppy drive with MB of storage. The other is the same floppy drive with MB of storage, and corresponds to what some people call a `superformatted' disk. One that holds more data than a standard formatted floppy. So here's a case where two device files with different minor number actually represent the same piece of physical hardware. So just be aware that the word `hardware' in our discussion can mean something very abstract.\n\nThe file_operations structure is defined in , and holds pointers to functions defined by the driver that perform various operations on the device. Each field of the structure corresponds to the address of some function defined by the driver to handle a requested operation. For example, every character driver needs to define a function that reads from the device. The file_operations structure holds the address of the module's function that performs that operation. Here is what the definition looks like for kernel : Some operations are not implemented by a driver. For example, a driver that handles a video card won't need to read from a directory structure. The corresponding entries in the file_operations structure should be set to . There is a gcc extension that makes assigning to this structure more convenient. You'll see it in modern drivers, and may catch you by surprise. This is what the new way of assigning to the structure looks like: However, there's also a C99 way of assigning to elements of a structure, and this is definitely preferred over using the GNU extension. The version of gcc the author used when writing this, , supports the new C99 syntax. You should use this syntax in case someone wants to port your driver. It will help with compatibility: The meaning is clear, and you should be aware that any member of the structure which you don't explicitly assign will be initialized to by gcc. An instance of struct file_operations containing pointers to functions that are used to implement read, write, open, ... syscalls is commonly named . Each device is represented in the kernel by a file structure, which is defined in . Be aware that a file is a kernel level structure and never appears in a user space program. It's not the same thing as a FILE, which is defined by glibc and would never appear in a kernel space function. Also, its name is a bit misleading; it represents an abstract open `file', not a file on a disk, which is represented by a structure named inode. An instance of is commonly named . You'll also see it refered to as . Resist the temptation. Go ahead and look at the definition of . Most of the entries you see, like aren't used by device drivers, and you can ignore them. This is because drivers don't fill directly; they only use structures contained in which are created elsewhere. As discussed earlier, char devices are accessed through device files, usually located in . The major number tells you which driver handles which device file. The minor number is used only by the driver itself to differentiate which device it's operating on, just in case the driver handles more than one device. Adding a driver to your system means registering it with the kernel. This is synonymous with assigning it a major number during the module's initialization. You do this by using the function, defined by . where is the major number you want to request, is the name of the device as it'll appear in and is a pointer to the table for your driver. A negative return value means the registration failed. Note that we didn't pass the minor number to . That's because the kernel doesn't care about the minor number; only our driver uses it. Now the question is, how do you get a major number without hijacking one that's already in use? The easiest way would be to look through and pick an unused one. That's a bad way of doing things because you'll never be sure if the number you picked will be assigned later. The answer is that you can ask the kernel to assign you a dynamic major number. If you pass a major number of 0 to , the return value will be the dynamically allocated major number. The downside is that you can't make a device file in advance, since you don't know what the major number will be. There are a couple of ways to do this. First, the driver itself can print the newly assigned number and we can make the device file by hand. Second, the newly registered device will have an entry in , and we can either make the device file by hand or write a shell script to read the file in and make the device file. The third method is we can have our driver make the the device file using the system call after a successful registration and rm during the call to . We can't allow the kernel module to be rmmod'ed whenever root feels like it. If the device file is opened by a process and then we remove the kernel module, using the file would cause a call to the memory location where the appropriate function (read/write) used to be. If we're lucky, no other code was loaded there, and we'll get an ugly error message. If we're unlucky, another kernel module was loaded into the same location, which means a jump into the middle of another function within the kernel. The results of this would be impossible to predict, but they can't be very positive. Normally, when you don't want to allow something, you return an error code (a negative number) from the function which is supposed to do it. With that's impossible because it's a void function. However, there's a counter which keeps track of how many processes are using your module. You can see what it's value is by looking at the 3rd field of . If this number isn't zero, will fail. Note that you don't have to check the counter from within because the check will be performed for you by the system call , defined in . You shouldn't use this counter directly, but there are functions defined in which let you increase, decrease and display this counter: It's important to keep the counter accurate; if you ever do lose track of the correct usage count, you'll never be able to unload the module; it's now reboot time, boys and girls. This is bound to happen to you sooner or later during a module's development. The next code sample creates a char driver named . You can its device file (or the file with a program) and the driver will put the number of times the device file has been read from into the file. We don't support writing to the file (like echo \"hi\" > /dev/hello), but catch these attempts and tell the user that the operation isn't supported. Don't worry if you don't see what we do with the data we read into the buffer; we don't do much with it. We simply read in the data and print a message acknowledging that we received it. /* * chardev.c: Creates a read-only char device that says how many times * you've read from the dev file */ #include <linux/kernel.h> #include <linux/module.h> #include <linux/fs.h> #include <asm/uaccess.h> /* for put_user */ /* * Prototypes - this would normally go in a .h file */ int init_module(void); void cleanup_module(void); static int device_open(struct inode *, struct file *); static int device_release(struct inode *, struct file *); static ssize_t device_read(struct file *, char *, size_t, loff_t *); static ssize_t device_write(struct file *, const char *, size_t, loff_t *); #define SUCCESS 0 #define DEVICE_NAME \"chardev\" /* Dev name as it appears in /proc/devices */ #define BUF_LEN 80 /* Max length of the message from the device */ /* * Global variables are declared as static, so are global within the file. */ static int Major; /* Major number assigned to our device driver */ static int Device_Open = 0; /* Is device open? * Used to prevent multiple access to device */ static char msg[BUF_LEN]; /* The msg the device will give when asked */ static char *msg_Ptr; static struct file_operations fops = { .read = device_read, .write = device_write, .open = device_open, .release = device_release }; /* * This function is called when the module is loaded */ int init_module(void) { Major = register_chrdev(0, DEVICE_NAME, &fops); if (Major < 0) { printk(KERN_ALERT \"Registering char device failed with %d\n\n\", Major); return Major; } printk(KERN_INFO \"I was assigned major number %d. To talk to\n\n\", Major); printk(KERN_INFO \"the driver, create a dev file with\n\n\"); printk(KERN_INFO \"'mknod /dev/%s c %d 0'.\n\n\", DEVICE_NAME, Major); printk(KERN_INFO \"Try various minor numbers. Try to cat and echo to\n\n\"); printk(KERN_INFO \"the device file.\n\n\"); printk(KERN_INFO \"Remove the device file and module when done.\n\n\"); return SUCCESS; } /* * This function is called when the module is unloaded */ void cleanup_module(void) { /* * Unregister the device */ int ret = unregister_chrdev(Major, DEVICE_NAME); if (ret < 0) printk(KERN_ALERT \"Error in unregister_chrdev: %d\n\n\", ret); } /* * Methods */ /* * Called when a process tries to open the device file, like * \"cat /dev/mycharfile\" */ static int device_open(struct inode *inode, struct file *file) { static int counter = 0; if (Device_Open) return -EBUSY; Device_Open++; sprintf(msg, \"I already told you %d times Hello world!\n\n\", counter++); msg_Ptr = msg; try_module_get(THIS_MODULE); return SUCCESS; } /* * Called when a process closes the device file. */ static int device_release(struct inode *inode, struct file *file) { Device_Open--; /* We're now ready for our next caller */ /* * Decrement the usage count, or else once you opened the file, you'll * never get get rid of the module. */ module_put(THIS_MODULE); return 0; } /* * Called when a process, which already opened the dev file, attempts to * read from it. */ static ssize_t device_read(struct file *filp, /* see include/linux/fs.h */ char *buffer, /* buffer to fill with data */ size_t length, /* length of the buffer */ loff_t * offset) { /* * Number of bytes actually written to the buffer */ int bytes_read = 0; /* * If we're at the end of the message, * return 0 signifying end of file */ if (*msg_Ptr == 0) return 0; /* * Actually put the data into the buffer */ while (length && *msg_Ptr) { /* * The buffer is in the user data segment, not the kernel * segment so \"*\" assignment won't work. We have to use * put_user which copies data from the kernel data segment to * the user data segment. */ put_user(*(msg_Ptr++), buffer++); length--; bytes_read++; } /* * Most read functions return the number of bytes put into the buffer */ return bytes_read; } /* * Called when a process writes to dev file: echo \"hi\" > /dev/hello */ static ssize_t device_write(struct file *filp, const char *buff, size_t len, loff_t * off) { printk(KERN_ALERT \"Sorry, this operation isn't supported.\n\n\"); return -EINVAL; } The system calls, which are the major interface the kernel shows to the processes, generally stay the same across versions. A new system call may be added, but usually the old ones will behave exactly like they used to. This is necessary for backward compatibility -- a new kernel version is not supposed to break regular processes. In most cases, the device files will also remain the same. On the other hand, the internal interfaces within the kernel can and do change between versions. The Linux kernel versions are divided between the stable versions (n.$<$even number$>$.m) and the development versions (n.$<$odd number$>$.m). The development versions include all the cool new ideas, including those which will be considered a mistake, or reimplemented, in the next version. As a result, you can't trust the interface to remain the same in those versions (which is why I don't bother to support them in this book, it's too much work and it would become dated too quickly). In the stable versions, on the other hand, we can expect the interface to remain the same regardless of the bug fix version (the m number). There are differences between different kernel versions, and if you want to support multiple kernel versions, you'll find yourself having to code conditional compilation directives. The way to do this to compare the macro to the macro . In version of the kernel, the value of this macro would be $2^{16}a+2^{8}b+c$. While previous versions of this guide showed how you can write backward compatible code with such constructs in great detail, we decided to break with this tradition for the better. People interested in doing such might now use a LKMPG with a version matching to their kernel. We decided to version the LKMPG like the kernel, at least as far as major and minor number are concerned. We use the patchlevel for our own versioning so use LKMPG version 2.4.x for kernels 2.4.x, use LKMPG version 2.6.x for kernels 2.6.x and so on. Also make sure that you always use current, up to date versions of both, kernel and guide. Update: What we've said above was true for kernels up to and including 2.6.10. You might already have noticed that recent kernels look different. In case you haven't they look like 2.6.x.y now. The meaning of the first three items basically stays the same, but a subpatchlevel has been added and will indicate security fixes till the next stable patchlevel is out. So people can choose between a stable tree with security updates and use the latest kernel as developer tree. Search the kernel mailing list archives if you're interested in the full story.\n\nIn Linux, there is an additional mechanism for the kernel and kernel modules to send information to processes --- the file system. Originally designed to allow easy access to information about processes (hence the name), it is now used by every bit of the kernel which has something interesting to report, such as which provides the list of modules and which stats memory usage statistics. The method to use the proc file system is very similar to the one used with device drivers --- a structure is created with all the information needed for the file, including pointers to any handler functions (in our case there is only one, the one called when somebody attempts to read from the file). Then, registers the structure with the kernel and unregisters it. The reason we use is because we don't want to determine the inode number used for our file in advance, but to allow the kernel to determine it to prevent clashes. Normal file systems are located on a disk, rather than just in memory (which is where is), and in that case the inode number is a pointer to a disk location where the file's index-node (inode for short) is located. The inode contains information about the file, for example the file's permissions, together with a pointer to the disk location or locations where the file's data can be found. Because we don't get called when the file is opened or closed, there's nowhere for us to put and in this module, and if the file is opened and then the module is removed, there's no way to avoid the consequences. Here a simple example showing how to use a /proc file. This is the HelloWorld for the /proc filesystem. There are three parts: create the file in the function , return a value (and a buffer) when the file is read in the callback function , and delete the file in the function . The is created when the module is loaded with the function . The return value is a 'struct proc_dir_entry *', and it will be used to configure the file (for example, the owner of this file). A null return value means that the creation has failed. Each time, everytime the file is read, the function is called. Two parameters of this function are very important: the buffer (the first parameter) and the offset (the third one). The content of the buffer will be returned to the application which read it (for example the cat command). The offset is the current position in the file. If the return value of the function isn't null, then this function is called again. So be careful with this function, if it never returns zero, the read function is called endlessly. /* * procfs1.c - create a \"file\" in /proc * */ #include <linux/module.h> /* Specifically, a module */ #include <linux/kernel.h> /* We're doing kernel work */ #include <linux/proc_fs.h> /* Necessary because we use the proc fs */ #define procfs_name \"helloworld\" /** * This structure hold information about the /proc file * */ struct proc_dir_entry *Our_Proc_File; /* Put data into the proc fs file. * * Arguments * ========= * 1. The buffer where the data is to be inserted, if * you decide to use it. * 2. A pointer to a pointer to characters. This is * useful if you don't want to use the buffer * allocated by the kernel. * 3. The current position in the file * 4. The size of the buffer in the first argument. * 5. Write a \"1\" here to indicate EOF. * 6. A pointer to data (useful in case one common * read for multiple /proc/... entries) * * Usage and Return Value * ====================== * A return value of zero means you have no further * information at this time (end of file). A negative * return value is an error condition. * * For More Information * ==================== * The way I discovered what to do with this function * wasn't by reading documentation, but by reading the * code which used it. I just looked to see what uses * the get_info field of proc_dir_entry struct (I used a * combination of find and grep, if you're interested), * and I saw that it is used in <kernel source * directory>/fs/proc/array.c. * * If something is unknown about the kernel, this is * usually the way to go. In Linux we have the great * advantage of having the kernel source code for * free - use it. */ int procfile_read(char *buffer, char **buffer_location, off_t offset, int buffer_length, int *eof, void *data) { int ret; printk(KERN_INFO \"procfile_read (/proc/%s) called\n\n\", procfs_name); /* * We give all of our information in one go, so if the * user asks us if we have more information the * answer should always be no. * * This is important because the standard read * function from the library would continue to issue * the read system call until the kernel replies * that it has no more information, or until its * buffer is filled. */ if (offset > 0) { /* we have finished to read, return 0 */ ret = 0; } else { /* fill the buffer, return the buffer size */ ret = sprintf(buffer, \"HelloWorld!\n\n\"); } return ret; } int init_module() { Our_Proc_File = create_proc_entry(procfs_name, 0644, NULL); if (Our_Proc_File == NULL) { remove_proc_entry(procfs_name, &proc_root); printk(KERN_ALERT \"Error: Could not initialize /proc/%s\n\n\", procfs_name); return -ENOMEM; } Our_Proc_File->read_proc = procfile_read; Our_Proc_File->owner = THIS_MODULE; Our_Proc_File->mode = S_IFREG | S_IRUGO; Our_Proc_File->uid = 0; Our_Proc_File->gid = 0; Our_Proc_File->size = 37; printk(KERN_INFO \"/proc/%s created\n\n\", procfs_name); return 0; /* everything is ok */ } void cleanup_module() { remove_proc_entry(procfs_name, &proc_root); printk(KERN_INFO \"/proc/%s removed\n\n\", procfs_name); } We have seen a very simple example for a /proc file where we only read the file . It's also possible to write in a /proc file. It works the same way as read, a function is called when the /proc file is written. But there is a little difference with read, data comes from user, so you have to import data from user space to kernel space (with or ) The reason for or is that Linux memory (on Intel architecture, it may be different under some other processors) is segmented. This means that a pointer, by itself, does not reference a unique location in memory, only a location in a memory segment, and you need to know which memory segment it is to be able to use it. There is one memory segment for the kernel, and one for each of the processes. The only memory segment accessible to a process is its own, so when writing regular programs to run as processes, there's no need to worry about segments. When you write a kernel module, normally you want to access the kernel memory segment, which is handled automatically by the system. However, when the content of a memory buffer needs to be passed between the currently running process and the kernel, the kernel function receives a pointer to the memory buffer which is in the process segment. The and macros allow you to access that memory. These functions handle only one caracter, you can handle several caracters with and . As the buffer (in read or write function) is in kernel space, for write function you need to import data because it comes from user space, but not for the read function because data is already in kernel space. /** * procfs2.c - create a \"file\" in /proc * */ #include <linux/module.h> /* Specifically, a module */ #include <linux/kernel.h> /* We're doing kernel work */ #include <linux/proc_fs.h> /* Necessary because we use the proc fs */ #include <asm/uaccess.h> /* for copy_from_user */ #define PROCFS_MAX_SIZE 1024 #define PROCFS_NAME \"buffer1k\" /** * This structure hold information about the /proc file * */ static struct proc_dir_entry *Our_Proc_File; /** * The buffer used to store character for this module * */ static char procfs_buffer[PROCFS_MAX_SIZE]; /** * The size of the buffer * */ static unsigned long procfs_buffer_size = 0; /** * This function is called then the /proc file is read * */ int procfile_read(char *buffer, char **buffer_location, off_t offset, int buffer_length, int *eof, void *data) { int ret; printk(KERN_INFO \"procfile_read (/proc/%s) called\n\n\", PROCFS_NAME); if (offset > 0) { /* we have finished to read, return 0 */ ret = 0; } else { /* fill the buffer, return the buffer size */ memcpy(buffer, procfs_buffer, procfs_buffer_size); ret = procfs_buffer_size; } return ret; } /** * This function is called with the /proc file is written * */ int procfile_write(struct file *file, const char *buffer, unsigned long count, void *data) { /* get buffer size */ procfs_buffer_size = count; if (procfs_buffer_size > PROCFS_MAX_SIZE ) { procfs_buffer_size = PROCFS_MAX_SIZE; } /* write data to the buffer */ if ( copy_from_user(procfs_buffer, buffer, procfs_buffer_size) ) { return -EFAULT; } return procfs_buffer_size; } /** *This function is called when the module is loaded * */ int init_module() { /* create the /proc file */ Our_Proc_File = create_proc_entry(PROCFS_NAME, 0644, NULL); if (Our_Proc_File == NULL) { remove_proc_entry(PROCFS_NAME, &proc_root); printk(KERN_ALERT \"Error: Could not initialize /proc/%s\n\n\", PROCFS_NAME); return -ENOMEM; } Our_Proc_File->read_proc = procfile_read; Our_Proc_File->write_proc = procfile_write; Our_Proc_File->owner = THIS_MODULE; Our_Proc_File->mode = S_IFREG | S_IRUGO; Our_Proc_File->uid = 0; Our_Proc_File->gid = 0; Our_Proc_File->size = 37; printk(KERN_INFO \"/proc/%s created\n\n\", PROCFS_NAME); return 0; /* everything is ok */ } /** *This function is called when the module is unloaded * */ void cleanup_module() { remove_proc_entry(PROCFS_NAME, &proc_root); printk(KERN_INFO \"/proc/%s removed\n\n\", PROCFS_NAME); } We have seen how to read and write a /proc file with the /proc interface. But it's also possible to manage /proc file with inodes. The main interest is to use advanced function, like permissions. In Linux, there is a standard mechanism for file system registration. Since every file system has to have its own functions to handle inode and file operations, there is a special structure to hold pointers to all those functions, , which includes a pointer to . In /proc, whenever we register a new file, we're allowed to specify which will be used to access to it. This is the mechanism we use, a which includes a pointer to a which includes pointers to our and functions. Another interesting point here is the function. This function is called whenever a process tries to do something with the file, and it can decide whether to allow access or not. Right now it is only based on the operation and the uid of the current user (as available in , a pointer to a structure which includes information on the currently running process), but it could be based on anything we like, such as what other processes are doing with the same file, the time of day, or the last input we received. It's important to note that the standard roles of read and write are reversed in the kernel. Read functions are used for output, whereas write functions are used for input. The reason for that is that read and write refer to the user's point of view --- if a process reads something from the kernel, then the kernel needs to output it, and if a process writes something to the kernel, then the kernel receives it as input. /* * procfs3.c - create a \"file\" in /proc, use the file_operation way * to manage the file. */ #include <linux/kernel.h> /* We're doing kernel work */ #include <linux/module.h> /* Specifically, a module */ #include <linux/proc_fs.h> /* Necessary because we use proc fs */ #include <asm/uaccess.h> /* for copy_*_user */ #define PROC_ENTRY_FILENAME \"buffer2k\" #define PROCFS_MAX_SIZE 2048 /** * The buffer (2k) for this module * */ static char procfs_buffer[PROCFS_MAX_SIZE]; /** * The size of the data hold in the buffer * */ static unsigned long procfs_buffer_size = 0; /** * The structure keeping information about the /proc file * */ static struct proc_dir_entry *Our_Proc_File; /** * This funtion is called when the /proc file is read * */ static ssize_t procfs_read(struct file *filp, /* see include/linux/fs.h */ char *buffer, /* buffer to fill with data */ size_t length, /* length of the buffer */ loff_t * offset) { static int finished = 0; /* * We return 0 to indicate end of file, that we have * no more information. Otherwise, processes will * continue to read from us in an endless loop. */ if ( finished ) { printk(KERN_INFO \"procfs_read: END\n\n\"); finished = 0; return 0; } finished = 1; /* * We use put_to_user to copy the string from the kernel's * memory segment to the memory segment of the process * that called us. get_from_user, BTW, is * used for the reverse. */ if ( copy_to_user(buffer, procfs_buffer, procfs_buffer_size) ) { return -EFAULT; } printk(KERN_INFO \"procfs_read: read %lu bytes\n\n\", procfs_buffer_size); return procfs_buffer_size; /* Return the number of bytes \"read\" */ } /* * This function is called when /proc is written */ static ssize_t procfs_write(struct file *file, const char *buffer, size_t len, loff_t * off) { if ( len > PROCFS_MAX_SIZE ) { procfs_buffer_size = PROCFS_MAX_SIZE; } else { procfs_buffer_size = len; } if ( copy_from_user(procfs_buffer, buffer, procfs_buffer_size) ) { return -EFAULT; } printk(KERN_INFO \"procfs_write: write %lu bytes\n\n\", procfs_buffer_size); return procfs_buffer_size; } /* * This function decides whether to allow an operation * (return zero) or not allow it (return a non-zero * which indicates why it is not allowed). * * The operation can be one of the following values: * 0 - Execute (run the \"file\" - meaningless in our case) * 2 - Write (input to the kernel module) * 4 - Read (output from the kernel module) * * This is the real function that checks file * permissions. The permissions returned by ls -l are * for referece only, and can be overridden here. */ static int module_permission(struct inode *inode, int op, struct nameidata *foo) { /* * We allow everybody to read from our module, but * only root (uid 0) may write to it */ if (op == 4 || (op == 2 && current->euid == 0)) return 0; /* * If it's anything else, access is denied */ return -EACCES; } /* * The file is opened - we don't really care about * that, but it does mean we need to increment the * module's reference count. */ int procfs_open(struct inode *inode, struct file *file) { try_module_get(THIS_MODULE); return 0; } /* * The file is closed - again, interesting only because * of the reference count. */ int procfs_close(struct inode *inode, struct file *file) { module_put(THIS_MODULE); return 0; /* success */ } static struct file_operations File_Ops_4_Our_Proc_File = { .read = procfs_read, .write = procfs_write, .open = procfs_open, .release = procfs_close, }; /* * Inode operations for our proc file. We need it so * we'll have some place to specify the file operations * structure we want to use, and the function we use for * permissions. It's also possible to specify functions * to be called for anything else which could be done to * an inode (although we don't bother, we just put * NULL). */ static struct inode_operations Inode_Ops_4_Our_Proc_File = { .permission = module_permission, /* check for permissions */ }; /* * Module initialization and cleanup */ int init_module() { /* create the /proc file */ Our_Proc_File = create_proc_entry(PROC_ENTRY_FILENAME, 0644, NULL); /* check if the /proc file was created successfuly */ if (Our_Proc_File == NULL){ printk(KERN_ALERT \"Error: Could not initialize /proc/%s\n\n\", PROC_ENTRY_FILENAME); return -ENOMEM; } Our_Proc_File->owner = THIS_MODULE; Our_Proc_File->proc_iops = &Inode_Ops_4_Our_Proc_File; Our_Proc_File->proc_fops = &File_Ops_4_Our_Proc_File; Our_Proc_File->mode = S_IFREG | S_IRUGO | S_IWUSR; Our_Proc_File->uid = 0; Our_Proc_File->gid = 0; Our_Proc_File->size = 80; printk(KERN_INFO \"/proc/%s created\n\n\", PROC_ENTRY_FILENAME); return 0; /* success */ } void cleanup_module() { remove_proc_entry(PROC_ENTRY_FILENAME, &proc_root); printk(KERN_INFO \"/proc/%s removed\n\n\", PROC_ENTRY_FILENAME); } Still hungry for procfs examples? Well, first of all keep in mind, there are rumors around, claiming that procfs is on it's way out, consider using sysfs instead. Second, if you really can't get enough, there's a highly recommendable bonus level for procfs below . Use make help in your toplevel kernel directory for instructions about how to convert it into your favourite format. Example: make htmldocs . Consider using this mechanism, in case you want to document something kernel related yourself. As we have seen, writing a /proc file may be quite \"complex\". So to help people writting /proc file, there is an API named seq_file that helps formating a /proc file for output. It's based on sequence, which is composed of 3 functions: start(), next(), and stop(). The seq_file API starts a sequence when a user read the /proc file. A sequence begins with the call of the function start(). If the return is a non NULL value, the function next() is called. This function is an iterator, the goal is to go thought all the data. Each time next() is called, the function show() is also called. It writes data values in the buffer read by the user. The function next() is called until it returns NULL. The sequence ends when next() returns NULL, then the function stop() is called. BE CARREFUL: when a sequence is finished, another one starts. That means that at the end of function stop(), the function start() is called again. This loop finishes when the function start() returns NULL. You can see a scheme of this in the figure \"How seq_file works\". Seq_file provides basic functions for file_operations, as seq_read, seq_lseek, and some others. But nothing to write in the /proc file. Of course, you can still use the same way as in the previous example. /** * procfs4.c - create a \"file\" in /proc * This program uses the seq_file library to manage the /proc file. * */ #include <linux/kernel.h> /* We're doing kernel work */ #include <linux/module.h> /* Specifically, a module */ #include <linux/proc_fs.h> /* Necessary because we use proc fs */ #include <linux/seq_file.h> /* for seq_file */ #define PROC_NAME \"iter\" MODULE_AUTHOR(\"Philippe Reynes\"); MODULE_LICENSE(\"GPL\"); /** * This function is called at the beginning of a sequence. * ie, when: * - the /proc file is read (first time) * - after the function stop (end of sequence) * */ static void *my_seq_start(struct seq_file *s, loff_t *pos) { static unsigned long counter = 0; /* beginning a new sequence ? */ if ( *pos == 0 ) { /* yes => return a non null value to begin the sequence */ return &counter; } else { /* no => it's the end of the sequence, return end to stop reading */ *pos = 0; return NULL; } } /** * This function is called after the beginning of a sequence. * It's called untill the return is NULL (this ends the sequence). * */ static void *my_seq_next(struct seq_file *s, void *v, loff_t *pos) { unsigned long *tmp_v = (unsigned long *)v; (*tmp_v)++; (*pos)++; return NULL; } /** * This function is called at the end of a sequence * */ static void my_seq_stop(struct seq_file *s, void *v) { /* nothing to do, we use a static value in start() */ } /** * This function is called for each \"step\" of a sequence * */ static int my_seq_show(struct seq_file *s, void *v) { loff_t *spos = (loff_t *) v; seq_printf(s, \"%Ld\n\n\", *spos); return 0; } /** * This structure gather \"function\" to manage the sequence * */ static struct seq_operations my_seq_ops = { .start = my_seq_start, .next = my_seq_next, .stop = my_seq_stop, .show = my_seq_show }; /** * This function is called when the /proc file is open. * */ static int my_open(struct inode *inode, struct file *file) { return seq_open(file, &my_seq_ops); }; /** * This structure gather \"function\" that manage the /proc file * */ static struct file_operations my_file_ops = { .owner = THIS_MODULE, .open = my_open, .read = seq_read, .llseek = seq_lseek, .release = seq_release }; /** * This function is called when the module is loaded * */ int init_module(void) { struct proc_dir_entry *entry; entry = create_proc_entry(PROC_NAME, 0, NULL); if (entry) { entry->proc_fops = &my_file_ops; } return 0; } /** * This function is called when the module is unloaded. * */ void cleanup_module(void) { remove_proc_entry(PROC_NAME, NULL); } If you want more information, you can read this web page: You can also read the code of fs/seq_file.c in the linux kernel.\n\nDevice files are supposed to represent physical devices. Most physical devices are used for output as well as input, so there has to be some mechanism for device drivers in the kernel to get the output to send to the device from processes. This is done by opening the device file for output and writing to it, just like writing to a file. In the following example, this is implemented by . This is not always enough. Imagine you had a serial port connected to a modem (even if you have an internal modem, it is still implemented from the CPU's perspective as a serial port connected to a modem, so you don't have to tax your imagination too hard). The natural thing to do would be to use the device file to write things to the modem (either modem commands or data to be sent through the phone line) and read things from the modem (either responses for commands or the data received through the phone line). However, this leaves open the question of what to do when you need to talk to the serial port itself, for example to send the rate at which data is sent and received. The answer in Unix is to use a special function called (short for Input Output ConTroL). Every device can have its own commands, which can be read 's (to send information from a process to the kernel), write 's (to return information to a process), both or neither. The function is called with three parameters: the file descriptor of the appropriate device file, the ioctl number, and a parameter, which is of type long so you can use a cast to use it to pass anything. The ioctl number encodes the major device number, the type of the ioctl, the command, and the type of the parameter. This ioctl number is usually created by a macro call ( , , or --- depending on the type) in a header file. This header file should then be included both by the programs which will use (so they can generate the appropriate 's) and by the kernel module (so it can understand it). In the example below, the header file is and the program which uses it is . If you want to use s in your own kernel modules, it is best to receive an official assignment, so if you accidentally get somebody else's s, or if they get yours, you'll know something is wrong. For more information, consult the kernel source tree at . /* * chardev.c - Create an input/output character device */ #include <linux/kernel.h> /* We're doing kernel work */ #include <linux/module.h> /* Specifically, a module */ #include <linux/fs.h> #include <asm/uaccess.h> /* for get_user and put_user */ #include \"chardev.h\" #define SUCCESS 0 #define DEVICE_NAME \"char_dev\" #define BUF_LEN 80 /* * Is the device open right now? Used to prevent * concurent access into the same device */ static int Device_Open = 0; /* * The message the device will give when asked */ static char Message[BUF_LEN]; /* * How far did the process reading the message get? * Useful if the message is larger than the size of the * buffer we get to fill in device_read. */ static char *Message_Ptr; /* * This is called whenever a process attempts to open the device file */ static int device_open(struct inode *inode, struct file *file) { #ifdef DEBUG printk(KERN_INFO \"device_open(%p)\n\n\", file); #endif /* * We don't want to talk to two processes at the same time */ if (Device_Open) return -EBUSY; Device_Open++; /* * Initialize the message */ Message_Ptr = Message; try_module_get(THIS_MODULE); return SUCCESS; } static int device_release(struct inode *inode, struct file *file) { #ifdef DEBUG printk(KERN_INFO \"device_release(%p,%p)\n\n\", inode, file); #endif /* * We're now ready for our next caller */ Device_Open--; module_put(THIS_MODULE); return SUCCESS; } /* * This function is called whenever a process which has already opened the * device file attempts to read from it. */ static ssize_t device_read(struct file *file, /* see include/linux/fs.h */ char __user * buffer, /* buffer to be * filled with data */ size_t length, /* length of the buffer */ loff_t * offset) { /* * Number of bytes actually written to the buffer */ int bytes_read = 0; #ifdef DEBUG printk(KERN_INFO \"device_read(%p,%p,%d)\n\n\", file, buffer, length); #endif /* * If we're at the end of the message, return 0 * (which signifies end of file) */ if (*Message_Ptr == 0) return 0; /* * Actually put the data into the buffer */ while (length && *Message_Ptr) { /* * Because the buffer is in the user data segment, * not the kernel data segment, assignment wouldn't * work. Instead, we have to use put_user which * copies data from the kernel data segment to the * user data segment. */ put_user(*(Message_Ptr++), buffer++); length--; bytes_read++; } #ifdef DEBUG printk(KERN_INFO \"Read %d bytes, %d left\n\n\", bytes_read, length); #endif /* * Read functions are supposed to return the number * of bytes actually inserted into the buffer */ return bytes_read; } /* * This function is called when somebody tries to * write into our device file. */ static ssize_t device_write(struct file *file, const char __user * buffer, size_t length, loff_t * offset) { int i; #ifdef DEBUG printk(KERN_INFO \"device_write(%p,%s,%d)\", file, buffer, length); #endif for (i = 0; i < length && i < BUF_LEN; i++) get_user(Message[i], buffer + i); Message_Ptr = Message; /* * Again, return the number of input characters used */ return i; } /* * This function is called whenever a process tries to do an ioctl on our * device file. We get two extra parameters (additional to the inode and file * structures, which all device functions get): the number of the ioctl called * and the parameter given to the ioctl function. * * If the ioctl is write or read/write (meaning output is returned to the * calling process), the ioctl call returns the output of this function. * */ int device_ioctl(struct inode *inode, /* see include/linux/fs.h */ struct file *file, /* ditto */ unsigned int ioctl_num, /* number and param for ioctl */ unsigned long ioctl_param) { int i; char *temp; char ch; /* * Switch according to the ioctl called */ switch (ioctl_num) { case IOCTL_SET_MSG: /* * Receive a pointer to a message (in user space) and set that * to be the device's message. Get the parameter given to * ioctl by the process. */ temp = (char *)ioctl_param; /* * Find the length of the message */ get_user(ch, temp); for (i = 0; ch && i < BUF_LEN; i++, temp++) get_user(ch, temp); device_write(file, (char *)ioctl_param, i, 0); break; case IOCTL_GET_MSG: /* * Give the current message to the calling process - * the parameter we got is a pointer, fill it. */ i = device_read(file, (char *)ioctl_param, 99, 0); /* * Put a zero at the end of the buffer, so it will be * properly terminated */ put_user('\\0', (char *)ioctl_param + i); break; case IOCTL_GET_NTH_BYTE: /* * This ioctl is both input (ioctl_param) and * output (the return value of this function) */ return Message[ioctl_param]; break; } return SUCCESS; } /* Module Declarations */ /* * This structure will hold the functions to be called * when a process does something to the device we * created. Since a pointer to this structure is kept in * the devices table, it can't be local to * init_module. NULL is for unimplemented functions. */ struct file_operations Fops = { .read = device_read, .write = device_write, .ioctl = device_ioctl, .open = device_open, .release = device_release, /* a.k.a. close */ }; /* * Initialize the module - Register the character device */ int init_module() { int ret_val; /* * Register the character device (atleast try) */ ret_val = register_chrdev(MAJOR_NUM, DEVICE_NAME, &Fops); /* * Negative values signify an error */ if (ret_val < 0) { printk(KERN_ALERT \"%s failed with %d\n\n\", \"Sorry, registering the character device \", ret_val); return ret_val; } printk(KERN_INFO \"%s The major device number is %d.\n\n\", \"Registeration is a success\", MAJOR_NUM); printk(KERN_INFO \"If you want to talk to the device driver,\n\n\"); printk(KERN_INFO \"you'll have to create a device file. \n\n\"); printk(KERN_INFO \"We suggest you use:\n\n\"); printk(KERN_INFO \"mknod %s c %d 0\n\n\", DEVICE_FILE_NAME, MAJOR_NUM); printk(KERN_INFO \"The device file name is important, because\n\n\"); printk(KERN_INFO \"the ioctl program assumes that's the\n\n\"); printk(KERN_INFO \"file you'll use.\n\n\"); return 0; } /* * Cleanup - unregister the appropriate file from /proc */ void cleanup_module() { int ret; /* * Unregister the device */ ret = unregister_chrdev(MAJOR_NUM, DEVICE_NAME); /* * If there's an error, report it */ if (ret < 0) printk(KERN_ALERT \"Error: unregister_chrdev: %d\n\n\", ret); } /* * chardev.h - the header file with the ioctl definitions. * * The declarations here have to be in a header file, because * they need to be known both to the kernel module * (in chardev.c) and the process calling ioctl (ioctl.c) */ #ifndef CHARDEV_H #define CHARDEV_H #include <linux/ioctl.h> /* * The major device number. We can't rely on dynamic * registration any more, because ioctls need to know * it. */ #define MAJOR_NUM 100 /* * Set the message of the device driver */ #define IOCTL_SET_MSG _IOR(MAJOR_NUM, 0, char *) /* * _IOR means that we're creating an ioctl command * number for passing information from a user process * to the kernel module. * * The first arguments, MAJOR_NUM, is the major device * number we're using. * * The second argument is the number of the command * (there could be several with different meanings). * * The third argument is the type we want to get from * the process to the kernel. */ /* * Get the message of the device driver */ #define IOCTL_GET_MSG _IOR(MAJOR_NUM, 1, char *) /* * This IOCTL is used for output, to get the message * of the device driver. However, we still need the * buffer to place the message in to be input, * as it is allocated by the process. */ /* * Get the n'th byte of the message */ #define IOCTL_GET_NTH_BYTE _IOWR(MAJOR_NUM, 2, int) /* * The IOCTL is used for both input and output. It * receives from the user a number, n, and returns * Message[n]. */ /* * The name of the device file */ #define DEVICE_FILE_NAME \"char_dev\" #endif /* * ioctl.c - the process to use ioctl's to control the kernel module * * Until now we could have used cat for input and output. But now * we need to do ioctl's, which require writing our own process. */ /* * device specifics, such as ioctl numbers and the * major device file. */ #include \"chardev.h\" #include <stdio.h> #include <stdlib.h> #include <fcntl.h> /* open */ #include <unistd.h> /* exit */ #include <sys/ioctl.h> /* ioctl */ /* * Functions for the ioctl calls */ ioctl_set_msg(int file_desc, char *message) { int ret_val; ret_val = ioctl(file_desc, IOCTL_SET_MSG, message); if (ret_val < 0) { printf(\"ioctl_set_msg failed:%d\n\n\", ret_val); exit(-1); } } ioctl_get_msg(int file_desc) { int ret_val; char message[100]; /* * Warning - this is dangerous because we don't tell * the kernel how far it's allowed to write, so it * might overflow the buffer. In a real production * program, we would have used two ioctls - one to tell * the kernel the buffer length and another to give * it the buffer to fill */ ret_val = ioctl(file_desc, IOCTL_GET_MSG, message); if (ret_val < 0) { printf(\"ioctl_get_msg failed:%d\n\n\", ret_val); exit(-1); } printf(\"get_msg message:%s\n\n\", message); } ioctl_get_nth_byte(int file_desc) { int i; char c; printf(\"get_nth_byte message:\"); i = 0; do { c = ioctl(file_desc, IOCTL_GET_NTH_BYTE, i++); if (c < 0) { printf (\"ioctl_get_nth_byte failed at the %d'th byte:\n\n\", i); exit(-1); } putchar(c); } while (c != 0); putchar('\n\n'); } /* * Main - Call the ioctl functions */ main() { int file_desc, ret_val; char *msg = \"Message passed by ioctl\n\n\"; file_desc = open(DEVICE_FILE_NAME, 0); if (file_desc < 0) { printf(\"Can't open device file: %s\n\n\", DEVICE_FILE_NAME); exit(-1); } ioctl_get_nth_byte(file_desc); ioctl_get_msg(file_desc); ioctl_set_msg(file_desc, msg); close(file_desc); }\n\nSo far, the only thing we've done was to use well defined kernel mechanisms to register files and device handlers. This is fine if you want to do something the kernel programmers thought you'd want, such as write a device driver. But what if you want to do something unusual, to change the behavior of the system in some way? Then, you're mostly on your own. This is where kernel programming gets dangerous. While writing the example below, I killed the system call. This meant I couldn't open any files, I couldn't run any programs, and I couldn't shutdown the computer. I had to pull the power switch. Luckily, no files died. To ensure you won't lose any files either, please run sync right before you do the insmod and the rmmod. Forget about files, forget about device files. They're just minor details. The real process to kernel communication mechanism, the one used by all processes, is system calls. When a process requests a service from the kernel (such as opening a file, forking to a new process, or requesting more memory), this is the mechanism used. If you want to change the behaviour of the kernel in interesting ways, this is the place to do it. By the way, if you want to see which system calls a program uses, run strace <arguments>. In general, a process is not supposed to be able to access the kernel. It can't access kernel memory and it can't call kernel functions. The hardware of the CPU enforces this (that's the reason why it's called `protected mode'). System calls are an exception to this general rule. What happens is that the process fills the registers with the appropriate values and then calls a special instruction which jumps to a previously defined location in the kernel (of course, that location is readable by user processes, it is not writable by them). Under Intel CPUs, this is done by means of interrupt 0x80. The hardware knows that once you jump to this location, you are no longer running in restricted user mode, but as the operating system kernel --- and therefore you're allowed to do whatever you want. The location in the kernel a process can jump to is called system_call. The procedure at that location checks the system call number, which tells the kernel what service the process requested. Then, it looks at the table of system calls ( ) to see the address of the kernel function to call. Then it calls the function, and after it returns, does a few system checks and then return back to the process (or to a different process, if the process time ran out). If you want to read this code, it's at the source file , after the line . So, if we want to change the way a certain system call works, what we need to do is to write our own function to implement it (usually by adding a bit of our own code, and then calling the original function) and then change the pointer at to point to our function. Because we might be removed later and we don't want to leave the system in an unstable state, it's important for to restore the table to its original state. The source code here is an example of such a kernel module. We want to `spy' on a certain user, and to a message whenever that user opens a file. Towards this end, we replace the system call to open a file with our own function, called . This function checks the uid (user's id) of the current process, and if it's equal to the uid we spy on, it calls to display the name of the file to be opened. Then, either way, it calls the original function with the same parameters, to actually open the file. The function replaces the appropriate location in and keeps the original pointer in a variable. The function uses that variable to restore everything back to normal. This approach is dangerous, because of the possibility of two kernel modules changing the same system call. Imagine we have two kernel modules, A and B. A's open system call will be A_open and B's will be B_open. Now, when A is inserted into the kernel, the system call is replaced with A_open, which will call the original sys_open when it's done. Next, B is inserted into the kernel, which replaces the system call with B_open, which will call what it thinks is the original system call, A_open, when it's done. Now, if B is removed first, everything will be well---it will simply restore the system call to A_open, which calls the original. However, if A is removed and then B is removed, the system will crash. A's removal will restore the system call to the original, sys_open, cutting B out of the loop. Then, when B is removed, it will restore the system call to what it thinks is the original, A_open, which is no longer in memory. At first glance, it appears we could solve this particular problem by checking if the system call is equal to our open function and if so not changing it at all (so that B won't change the system call when it's removed), but that will cause an even worse problem. When A is removed, it sees that the system call was changed to B_open so that it is no longer pointing to A_open, so it won't restore it to sys_open before it is removed from memory. Unfortunately, B_open will still try to call A_open which is no longer there, so that even without removing B the system would crash. Note that all the related problems make syscall stealing unfeasiable for production use. In order to keep people from doing potential harmful things sys_call_table is no longer exported. This means, if you want to do something more than a mere dry run of this example, you will have to patch your current kernel in order to have sys_call_table exported. In the example directory you will find a README and the patch. As you can imagine, such modifications are not to be taken lightly. Do not try this on valueable systems (ie systems that you do not own - or cannot restore easily). You'll need to get the complete sourcecode of this guide as a tarball in order to get the patch and the README. Depending on your kernel version, you might even need to hand apply the patch. Still here? Well, so is this chapter. If Wyle E. Coyote was a kernel hacker, this would be the first thing he'd try. ;) /* * syscall.c * * System call \"stealing\" sample. */ /* * Copyright (C) 2001 by Peter Jay Salzman */ /* * The necessary header files */ /* * Standard in kernel modules */ #include <linux/kernel.h> /* We're doing kernel work */ #include <linux/module.h> /* Specifically, a module, */ #include <linux/moduleparam.h> /* which will have params */ #include <linux/unistd.h> /* The list of system calls */ /* * For the current (process) structure, we need * this to know who the current user is. */ #include <linux/sched.h> #include <asm/uaccess.h> /* * The system call table (a table of functions). We * just define this as external, and the kernel will * fill it up for us when we are insmod'ed * * sys_call_table is no longer exported in 2.6.x kernels. * If you really want to try this DANGEROUS module you will * have to apply the supplied patch against your current kernel * and recompile it. */ extern void *sys_call_table[]; /* * UID we want to spy on - will be filled from the * command line */ static int uid; module_param(uid, int, 0644); /* * A pointer to the original system call. The reason * we keep this, rather than call the original function * (sys_open), is because somebody else might have * replaced the system call before us. Note that this * is not 100% safe, because if another module * replaced sys_open before us, then when we're inserted * we'll call the function in that module - and it * might be removed before we are. * * Another reason for this is that we can't get sys_open. * It's a static variable, so it is not exported. */ asmlinkage int (*original_call) (const char *, int, int); /* * The function we'll replace sys_open (the function * called when you call the open system call) with. To * find the exact prototype, with the number and type * of arguments, we find the original function first * (it's at fs/open.c). * * In theory, this means that we're tied to the * current version of the kernel. In practice, the * system calls almost never change (it would wreck havoc * and require programs to be recompiled, since the system * calls are the interface between the kernel and the * processes). */ asmlinkage int our_sys_open(const char *filename, int flags, int mode) { int i = 0; char ch; /* * Check if this is the user we're spying on */ if (uid == current->uid) { /* * Report the file, if relevant */ printk(\"Opened file by %d: \", uid); do { get_user(ch, filename + i); i++; printk(\"%c\", ch); } while (ch != 0); printk(\"\n\n\"); } /* * Call the original sys_open - otherwise, we lose * the ability to open files */ return original_call(filename, flags, mode); } /* * Initialize the module - replace the system call */ int init_module() { /* * Warning - too late for it now, but maybe for * next time... */ printk(KERN_ALERT \"I'm dangerous. I hope you did a \"); printk(KERN_ALERT \"sync before you insmod'ed me.\n\n\"); printk(KERN_ALERT \"My counterpart, cleanup_module(), is even\"); printk(KERN_ALERT \"more dangerous. If\n\n\"); printk(KERN_ALERT \"you value your file system, it will \"); printk(KERN_ALERT \"be \\\"sync; rmmod\\\" \n\n\"); printk(KERN_ALERT \"when you remove this module.\n\n\"); /* * Keep a pointer to the original function in * original_call, and then replace the system call * in the system call table with our_sys_open */ original_call = sys_call_table[__NR_open]; sys_call_table[__NR_open] = our_sys_open; /* * To get the address of the function for system * call foo, go to sys_call_table[__NR_foo]. */ printk(KERN_INFO \"Spying on UID:%d\n\n\", uid); return 0; } /* * Cleanup - unregister the appropriate file from /proc */ void cleanup_module() { /* * Return the system call back to normal */ if (sys_call_table[__NR_open] != our_sys_open) { printk(KERN_ALERT \"Somebody else also played with the \"); printk(KERN_ALERT \"open system call\n\n\"); printk(KERN_ALERT \"The system may be left in \"); printk(KERN_ALERT \"an unstable state.\n\n\"); } sys_call_table[__NR_open] = original_call; }\n\nWhat do you do when somebody asks you for something you can't do right away? If you're a human being and you're bothered by a human being, the only thing you can say is: \"Not right now, I'm busy. Go away!\". But if you're a kernel module and you're bothered by a process, you have another possibility. You can put the process to sleep until you can service it. After all, processes are being put to sleep by the kernel and woken up all the time (that's the way multiple processes appear to run on the same time on a single CPU). This kernel module is an example of this. The file (called ) can only be opened by a single process at a time. If the file is already open, the kernel module calls . This function changes the status of the task (a task is the kernel data structure which holds information about a process and the system call it's in, if any) to , which means that the task will not run until it is woken up somehow, and adds it to WaitQ, the queue of tasks waiting to access the file. Then, the function calls the scheduler to context switch to a different process, one which has some use for the CPU. When a process is done with the file, it closes it, and is called. That function wakes up all the processes in the queue (there's no mechanism to only wake up one of them). It then returns and the process which just closed the file can continue to run. In time, the scheduler decides that that process has had enough and gives control of the CPU to another process. Eventually, one of the processes which was in the queue will be given control of the CPU by the scheduler. It starts at the point right after the call to . It can then proceed to set a global variable to tell all the other processes that the file is still open and go on with its life. When the other processes get a piece of the CPU, they'll see that global variable and go back to sleep. So we'll use tail -f to keep the file open in the background, while trying to access it with another process (again in the background, so that we need not switch to a different vt). As soon as the first background process is killed with kill %1 , the second is woken up, is able to access the file and finally terminates. To make our life more interesting, doesn't have a monopoly on waking up the processes which wait to access the file. A signal, such as Ctrl+c ( ) can also wake up a process. In that case, we want to return with immediately. This is important so users can, for example, kill the process before it receives the file. There is one more point to remember. Some times processes don't want to sleep, they want either to get what they want immediately, or to be told it cannot be done. Such processes use the flag when opening the file. The kernel is supposed to respond by returning with the error code from operations which would otherwise block, such as opening the file in this example. The program cat_noblock, available in the source directory for this chapter, can be used to open a file with . hostname:~/lkmpg-examples/09-BlockingProcesses# insmod sleep.ko hostname:~/lkmpg-examples/09-BlockingProcesses# cat_noblock /proc/sleep Last input: hostname:~/lkmpg-examples/09-BlockingProcesses# tail -f /proc/sleep & Last input: Last input: Last input: Last input: Last input: Last input: Last input: tail: /proc/sleep: file truncated [1] 6540 hostname:~/lkmpg-examples/09-BlockingProcesses# cat_noblock /proc/sleep Open would block hostname:~/lkmpg-examples/09-BlockingProcesses# kill %1 [1]+ Terminated tail -f /proc/sleep hostname:~/lkmpg-examples/09-BlockingProcesses# cat_noblock /proc/sleep Last input: hostname:~/lkmpg-examples/09-BlockingProcesses# /* * sleep.c - create a /proc file, and if several processes try to open it at * the same time, put all but one to sleep */ #include <linux/kernel.h> /* We're doing kernel work */ #include <linux/module.h> /* Specifically, a module */ #include <linux/proc_fs.h> /* Necessary because we use proc fs */ #include <linux/sched.h> /* For putting processes to sleep and waking them up */ #include <asm/uaccess.h> /* for get_user and put_user */ /* * The module's file functions */ /* * Here we keep the last message received, to prove that we can process our * input */ #define MESSAGE_LENGTH 80 static char Message[MESSAGE_LENGTH]; static struct proc_dir_entry *Our_Proc_File; #define PROC_ENTRY_FILENAME \"sleep\" /* * Since we use the file operations struct, we can't use the special proc * output provisions - we have to use a standard read function, which is this * function */ static ssize_t module_output(struct file *file, /* see include/linux/fs.h */ char *buf, /* The buffer to put data to (in the user segment) */ size_t len, /* The length of the buffer */ loff_t * offset) { static int finished = 0; int i; char message[MESSAGE_LENGTH + 30]; /* * Return 0 to signify end of file - that we have nothing * more to say at this point. */ if (finished) { finished = 0; return 0; } /* * If you don't understand this by now, you're hopeless as a kernel * programmer. */ sprintf(message, \"Last input:%s\n\n\", Message); for (i = 0; i < len && message[i]; i++) put_user(message[i], buf + i); finished = 1; return i; /* Return the number of bytes \"read\" */ } /* * This function receives input from the user when the user writes to the /proc * file. */ static ssize_t module_input(struct file *file, /* The file itself */ const char *buf, /* The buffer with input */ size_t length, /* The buffer's length */ loff_t * offset) { /* offset to file - ignore */ int i; /* * Put the input into Message, where module_output will later be * able to use it */ for (i = 0; i < MESSAGE_LENGTH - 1 && i < length; i++) get_user(Message[i], buf + i); /* * we want a standard, zero terminated string */ Message[i] = '\\0'; /* * We need to return the number of input characters used */ return i; } /* * 1 if the file is currently open by somebody */ int Already_Open = 0; /* * Queue of processes who want our file */ DECLARE_WAIT_QUEUE_HEAD(WaitQ); /* * Called when the /proc file is opened */ static int module_open(struct inode *inode, struct file *file) { /* * If the file's flags include O_NONBLOCK, it means the process doesn't * want to wait for the file. In this case, if the file is already * open, we should fail with -EAGAIN, meaning \"you'll have to try * again\", instead of blocking a process which would rather stay awake. */ if ((file->f_flags & O_NONBLOCK) && Already_Open) return -EAGAIN; /* * This is the correct place for try_module_get(THIS_MODULE) because * if a process is in the loop, which is within the kernel module, * the kernel module must not be removed. */ try_module_get(THIS_MODULE); /* * If the file is already open, wait until it isn't */ while (Already_Open) { int i, is_sig = 0; /* * This function puts the current process, including any system * calls, such as us, to sleep. Execution will be resumed right * after the function call, either because somebody called * wake_up(&WaitQ) (only module_close does that, when the file * is closed) or when a signal, such as Ctrl-C, is sent * to the process */ wait_event_interruptible(WaitQ, !Already_Open); /* * If we woke up because we got a signal we're not blocking, * return -EINTR (fail the system call). This allows processes * to be killed or stopped. */ /* * Emmanuel Papirakis: * * This is a little update to work with 2.2.*. Signals now are contained in * two words (64 bits) and are stored in a structure that contains an array of * two unsigned longs. We now have to make 2 checks in our if. * * Ori Pomerantz: * * Nobody promised me they'll never use more than 64 bits, or that this book * won't be used for a version of Linux with a word size of 16 bits. This code * would work in any case. */ for (i = 0; i < _NSIG_WORDS && !is_sig; i++) is_sig = current->pending.signal.sig[i] & ~current-> blocked.sig[i]; if (is_sig) { /* * It's important to put module_put(THIS_MODULE) here, * because for processes where the open is interrupted * there will never be a corresponding close. If we * don't decrement the usage count here, we will be * left with a positive usage count which we'll have no * way to bring down to zero, giving us an immortal * module, which can only be killed by rebooting * the machine. */ module_put(THIS_MODULE); return -EINTR; } } /* * If we got here, Already_Open must be zero */ /* * Open the file */ Already_Open = 1; return 0; /* Allow the access */ } /* * Called when the /proc file is closed */ int module_close(struct inode *inode, struct file *file) { /* * Set Already_Open to zero, so one of the processes in the WaitQ will * be able to set Already_Open back to one and to open the file. All * the other processes will be called when Already_Open is back to one, * so they'll go back to sleep. */ Already_Open = 0; /* * Wake up all the processes in WaitQ, so if anybody is waiting for the * file, they can have it. */ wake_up(&WaitQ); module_put(THIS_MODULE); return 0; /* success */ } /* * This function decides whether to allow an operation (return zero) or not * allow it (return a non-zero which indicates why it is not allowed). * * The operation can be one of the following values: * 0 - Execute (run the \"file\" - meaningless in our case) * 2 - Write (input to the kernel module) * 4 - Read (output from the kernel module) * * This is the real function that checks file permissions. The permissions * returned by ls -l are for reference only, and can be overridden here. */ static int module_permission(struct inode *inode, int op, struct nameidata *nd) { /* * We allow everybody to read from our module, but only root (uid 0) * may write to it */ if (op == 4 || (op == 2 && current->euid == 0)) return 0; /* * If it's anything else, access is denied */ return -EACCES; } /* * Structures to register as the /proc file, with pointers to all the relevant * functions. */ /* * File operations for our proc file. This is where we place pointers to all * the functions called when somebody tries to do something to our file. NULL * means we don't want to deal with something. */ static struct file_operations File_Ops_4_Our_Proc_File = { .read = module_output, /* \"read\" from the file */ .write = module_input, /* \"write\" to the file */ .open = module_open, /* called when the /proc file is opened */ .release = module_close, /* called when it's closed */ }; /* * Inode operations for our proc file. We need it so we'll have somewhere to * specify the file operations structure we want to use, and the function we * use for permissions. It's also possible to specify functions to be called * for anything else which could be done to an inode (although we don't bother, * we just put NULL). */ static struct inode_operations Inode_Ops_4_Our_Proc_File = { .permission = module_permission, /* check for permissions */ }; /* * Module initialization and cleanup */ /* * Initialize the module - register the proc file */ int init_module() { Our_Proc_File = create_proc_entry(PROC_ENTRY_FILENAME, 0644, NULL); if (Our_Proc_File == NULL) { remove_proc_entry(PROC_ENTRY_FILENAME, &proc_root); printk(KERN_ALERT \"Error: Could not initialize /proc/test\n\n\"); return -ENOMEM; } Our_Proc_File->owner = THIS_MODULE; Our_Proc_File->proc_iops = &Inode_Ops_4_Our_Proc_File; Our_Proc_File->proc_fops = &File_Ops_4_Our_Proc_File; Our_Proc_File->mode = S_IFREG | S_IRUGO | S_IWUSR; Our_Proc_File->uid = 0; Our_Proc_File->gid = 0; Our_Proc_File->size = 80; printk(KERN_INFO \"/proc/test created\n\n\"); return 0; } /* * Cleanup - unregister our file from /proc. This could get dangerous if * there are still processes waiting in WaitQ, because they are inside our * open function, which will get unloaded. I'll explain how to avoid removal * of a kernel module in such a case in chapter 10. */ void cleanup_module() { remove_proc_entry(PROC_ENTRY_FILENAME, &proc_root); printk(KERN_INFO \"/proc/test removed\n\n\"); } /* cat_noblock.c - open a file and display its contents, but exit rather than * wait for input */ /* Copyright (C) 1998 by Ori Pomerantz */ #include <stdio.h> /* standard I/O */ #include <fcntl.h> /* for open */ #include <unistd.h> /* for read */ #include <stdlib.h> /* for exit */ #include <errno.h> /* for errno */ #define MAX_BYTES 1024*4 main(int argc, char *argv[]) { int fd; /* The file descriptor for the file to read */ size_t bytes; /* The number of bytes read */ char buffer[MAX_BYTES]; /* The buffer for the bytes */ /* Usage */ if (argc != 2) { printf(\"Usage: %s <filename>\n\n\", argv[0]); puts(\"Reads the content of a file, but doesn't wait for input\"); exit(-1); } /* Open the file for reading in non blocking mode */ fd = open(argv[1], O_RDONLY | O_NONBLOCK); /* If open failed */ if (fd == -1) { if (errno = EAGAIN) puts(\"Open would block\"); else puts(\"Open failed\"); exit(-1); } /* Read the file and output its contents */ do { int i; /* Read characters from the file */ bytes = read(fd, buffer, MAX_BYTES); /* If there's an error, report it and die */ if (bytes == -1) { if (errno = EAGAIN) puts(\"Normally I'd block, but you told me not to\"); else puts(\"Another read error\"); exit(-1); } /* Print the characters */ if (bytes > 0) { for(i=0; i<bytes; i++) putchar(buffer[i]); } /* While there are no errors and the file isn't over */ } while (bytes > 0); }"
    },
    {
        "link": "http://dirac.org/linux/writing/lkmpg/2.6/lkmpg-2.6.0.html",
        "document": "When the first caveman programmer chiseled the first program on the walls of the first cave computer, it was a program to paint the string `Hello, world' in Antelope pictures. Roman programming textbooks began with the `Salut, Mundi' program. I don't know what happens to people who break with this tradition, but I think it's safer not to find out. We'll start with a series of hello world programs that demonstrate the different aspects of the basics of writing a kernel module. Here's the simplest module possible. Don't compile it yet; we'll cover module compilation in the next section. /* * hello-1.c - The simplest kernel module. */ #include <linux/module.h> /* Needed by all modules */ #include <linux/kernel.h> /* Needed for KERN_ALERT */ int init_module(void) { printk(\"<1>Hello world 1.\n\n\"); /* * A non 0 return means init_module failed; module can't be loaded. */ return 0; } void cleanup_module(void) { printk(KERN_ALERT \"Goodbye world 1.\n\n\"); } Kernel modules must have at least two functions: a \"start\" (initialization) function called which is called when the module is insmoded into the kernel, and an \"end\" (cleanup) function called which is called just before it is rmmoded. Actually, things have changed starting with kernel 2.3.13. You can now use whatever name you like for the start and end functions of a module, and you'll learn how to do this in Section 2.3. In fact, the new method is the preferred method. However, many people still use and for their start and end functions. Typically, either registers a handler for something with the kernel, or it replaces one of the kernel functions with its own code (usually code to do something and then call the original function). The function is supposed to undo whatever did, so the module can be unloaded safely. Lastly, every kernel module needs to include . We needed to include only for the macro expansion for the log level, , which you'll learn about in Section 2.1.1. Despite what you might think, was not meant to communicate information to the user, even though we used it for exactly this purpose in hello-1! It happens to be a logging mechanism for the kernel, and is used to log information or give warnings. Therefore, each statement comes with a priority, which is the and you see. There are 8 priorities and the kernel has macros for them, so you don't have to use cryptic numbers, and you can view them (and their meanings) in . If you don't specify a priority level, the default priority, , will be used. Take time to read through the priority macros. The header file also describes what each priority means. In practise, don't use number, like . Always use the macro, like . If the priority is less than , the message is printed on your current terminal. If both syslogd and klogd are running, then the message will also get appended to , whether it got printed to the console or not. We use a high priority, like , to make sure the messages get printed to your console rather than just logged to your logfile. When you write real modules, you'll want to use priorities that are meaningful for the situation at hand. Kernel modules need to be compiled with certain gcc options to make them work. In addition, they also need to be compiled with certain symbols defined. Former kernel versions required us to care much about these settings, which are usually stored in Makefiles. Although hierarchically organized, many redundant settings accumulated in sublevel Makefiles and made them large and rather difficult to maintain. Fortunately, there is a new way of doing these things, called kbuild, and the build process for external loadable modules is now fully integrated into the standard kernel build mechanism. To learn more on how to compile modules which are not part of the official kernel (as ours), see file . So, let's look at a simple Makefile for compiling a module named : Now you can compile the module by issuing the command make -C /usr/src/linux-`uname -r` SUBDIRS=$PWD modules . You should obtain an output which resembles the following: Please note that kernel 2.6 introduces a new file naming convention: kernel modules now have a extension (in place of the old extension) which easily distinguishes them from conventional object files. Additional details about Makefiles for kernel modules are available in . Be sure to read this and the related files before starting to dig into Makefiles. Now it is time to insert your freshly-compiled module it into the kernel with insmod ./hello-1.ko (ignore anything you see about tainted kernels; we'll cover that shortly). All modules loaded into the kernel are listed in . Go ahead and cat that file to see that your module is really a part of the kernel. Congratulations, you are now the author of Linux kernel code! When the novelty wares off, remove your module from the kernel by using rmmod hello-1. Take a look at just to see that it got logged to your system logfile. Here's another exercise to the reader. See that comment above the return statement in ? Change the return value to something non-zero, recompile and load the module again. What happens? As of Linux 2.4, you can rename the init and cleanup functions of your modules; they no longer have to be called and respectively. This is done with the and macros. These macros are defined in . The only caveat is that your init and cleanup functions must be defined before calling the macros, otherwise you'll get compilation errors. Here's an example of this technique: /* * hello-2.c - Demonstrating the module_init() and module_exit() macros. * This is preferred over using init_module() and cleanup_module(). */ #include <linux/module.h> /* Needed by all modules */ #include <linux/kernel.h> /* Needed for KERN_ALERT */ #include <linux/init.h> /* Needed for the macros */ static int __init hello_2_init(void) { printk(KERN_ALERT \"Hello, world 2\n\n\"); return 0; } static void __exit hello_2_exit(void) { printk(KERN_ALERT \"Goodbye, world 2\n\n\"); } module_init(hello_2_init); module_exit(hello_2_exit); So now we have two real kernel modules under our belt. Adding another module is as simple as this: Example 2-4. Makefile for both our modules Now have a look at for a real world example. As you can see, some things get hardwired into the kernel (obj-y) but where are all those obj-m gone? Those familiar with shell scripts will easily be able to spot them. For those not, the obj-$(CONFIG_FOO) entries you see everywhere expand into obj-y or obj-m, depending on whether the CONFIG_FOO variable has been set to y or m. While we are at it, those were exactly the kind of variables that you have set in the file, the last time when you said make menuconfig or something like that. 2.4. Hello World (part 3): The and Macros This demonstrates a feature of kernel 2.2 and later. Notice the change in the definitions of the init and cleanup functions. The macro causes the init function to be discarded and its memory freed once the init function finishes for built-in drivers, but not loadable modules. If you think about when the init function is invoked, this makes perfect sense. There is also an which works similarly to but for init variables rather than functions. The macro causes the omission of the function when the module is built into the kernel, and like , has no effect for loadable modules. Again, if you consider when the cleanup function runs, this makes complete sense; built-in drivers don't need a cleanup function, while loadable modules do. These macros are defined in and serve to free up kernel memory. When you boot your kernel and see something like , this is precisely what the kernel is freeing. /* * hello-3.c - Illustrating the __init, __initdata and __exit macros. */ #include <linux/module.h> /* Needed by all modules */ #include <linux/kernel.h> /* Needed for KERN_ALERT */ #include <linux/init.h> /* Needed for the macros */ static int hello3_data __initdata = 3; static int __init hello_3_init(void) { printk(KERN_ALERT \"Hello, world %d\n\n\", hello3_data); return 0; } static void __exit hello_3_exit(void) { printk(KERN_ALERT \"Goodbye, world 3\n\n\"); } module_init(hello_3_init); module_exit(hello_3_exit); If you're running kernel 2.4 or later, you might have noticed something like this when you loaded the previous example modules: # insmod hello-3.o Warning: loading hello-3.o will taint the kernel: no license See http://www.tux.org/lkml/#export-tainted for information about tainted modules Hello, world 3 Module hello-3 loaded, with warnings In kernel 2.4 and later, a mechanism was devised to identify code licensed under the GPL (and friends) so people can be warned that the code is non open-source. This is accomplished by the macro which is demonstrated in the next piece of code. By setting the license to GPL, you can keep the warning from being printed. This license mechanism is defined and documented in : /* * The following license idents are currently accepted as indicating free * software modules * * \"GPL\" [GNU Public License v2 or later] * \"GPL v2\" [GNU Public License v2] * \"GPL and additional rights\" [GNU Public License v2 rights and more] * \"Dual BSD/GPL\" [GNU Public License v2 * or BSD license choice] * \"Dual MPL/GPL\" [GNU Public License v2 * or Mozilla license choice] * * The following other idents are available * * \"Proprietary\" [Non free products] * * There are dual licensed components, but when running with Linux it is the * GPL that is relevant so this is a non issue. Similarly LGPL linked with GPL * is a GPL combined work. * * This exists for several reasons * 1. So modinfo can show license info for users wanting to vet their setup * is free * 2. So the community can ignore bug reports including proprietary modules * 3. So vendors can do likewise based on their own policies */ Similarly, is used to describe what the module does, declares the module's author, and declares what types of devices the module supports. These macros are all defined in and aren't used by the kernel itself. They're simply for documentation and can be viewed by a tool like objdump. As an exercise to the reader, try grepping through to see how module authors use these macros to document their modules. /* * hello-4.c - Demonstrates module documentation. */ #include <linux/module.h> #include <linux/kernel.h> #include <linux/init.h> #define DRIVER_AUTHOR \"Peter Jay Salzman <p@dirac.org>\" #define DRIVER_DESC \"A sample driver\" static int __init init_hello_4(void) { printk(KERN_ALERT \"Hello, world 4\n\n\"); return 0; } static void __exit cleanup_hello_4(void) { printk(KERN_ALERT \"Goodbye, world 4\n\n\"); } module_init(init_hello_4); module_exit(cleanup_hello_4); /* * You can use strings, like this: */ /* * Get rid of taint message by declaring code as GPL. */ MODULE_LICENSE(\"GPL\"); /* * Or with defines, like this: */ MODULE_AUTHOR(DRIVER_AUTHOR); /* Who wrote this module? */ MODULE_DESCRIPTION(DRIVER_DESC); /* What does this module do */ /* * This module uses /dev/testdevice. The MODULE_SUPPORTED_DEVICE macro might * be used in the future to help automatic configuration of modules, but is * currently unused other than for documentation purposes. */ MODULE_SUPPORTED_DEVICE(\"testdevice\"); Modules can take command line arguments, but not with the / you might be used to. To allow arguments to be passed to your module, declare the variables that will take the values of the command line arguments as global and then use the macro, (defined in ) to set the mechanism up. At runtime, insmod will fill the variables with any command line arguments that are given, like ./insmod mymodule.o myvariable=5. The variable declarations and macros should be placed at the beginning of the module for clarity. The example code should clear up my admittedly lousy explanation. The macro takes 2 arguments: the name of the variable and its type. The supported variable types are \" \": single byte, \" \": short int, \" \": integer, \" \": long int and \" \": string, and the integer types can be signed as usual or unsigned. Strings should be declared as \"char *\" and insmod will allocate memory for them. You should always try to give the variables an initial default value. This is kernel code, and you should program defensively. For example: Arrays are supported too. An integer value preceding the type in MODULE_PARM will indicate an array of some maximum length. Two numbers separated by a '-' will give the minimum and maximum number of values. For example, an array of shorts with at least 2 and no more than 4 values could be declared as: A good use for this is to have the module variable's default values set, like an port or IO address. If the variables contain the default values, then perform autodetection (explained elsewhere). Otherwise, keep the current value. This will be made clear later on. Lastly, there's a macro function, , that is used to document arguments that the module can take. It takes two parameters: a variable name and a free form string describing that variable. /* * hello-5.c - Demonstrates command line argument passing to a module. */ #include <linux/module.h> #include <linux/moduleparam.h> #include <linux/kernel.h> #include <linux/init.h> #include <linux/stat.h> MODULE_LICENSE(\"GPL\"); MODULE_AUTHOR(\"Peter Jay Salzman\"); static short int myshort = 1; static int myint = 420; static long int mylong = 9999; static char *mystring = \"blah\"; /* * module_param(foo, int, 0000) * The first param is the parameters name * The second param is it's data type * The final argument is the permissions bits, * for exposing parameters in sysfs (if non-zero) at a later stage. */ module_param(myshort, short, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP); MODULE_PARM_DESC(myshort, \"A short integer\"); module_param(myint, int, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH); MODULE_PARM_DESC(myint, \"An integer\"); module_param(mylong, long, S_IRUSR); MODULE_PARM_DESC(mylong, \"A long integer\"); module_param(mystring, charp, 0000); MODULE_PARM_DESC(mystring, \"A character string\"); static int __init hello_5_init(void) { printk(KERN_ALERT \"Hello, world 5\n\n=============\n\n\"); printk(KERN_ALERT \"myshort is a short integer: %hd\n\n\", myshort); printk(KERN_ALERT \"myint is an integer: %d\n\n\", myint); printk(KERN_ALERT \"mylong is a long integer: %ld\n\n\", mylong); printk(KERN_ALERT \"mystring is a string: %s\n\n\", mystring); return 0; } static void __exit hello_5_exit(void) { printk(KERN_ALERT \"Goodbye, world 5\n\n\"); } module_init(hello_5_init); module_exit(hello_5_exit); I would recommend playing around with this code: satan# insmod hello-5.o mystring=\"bebop\" mybyte=255 myintArray=-1 mybyte is an 8 bit integer: 255 myshort is a short integer: 1 myint is an integer: 20 mylong is a long integer: 9999 mystring is a string: bebop myintArray is -1 and 420 satan# rmmod hello-5 Goodbye, world 5 satan# insmod hello-5.o mystring=\"supercalifragilisticexpialidocious\" \\ > mybyte=256 myintArray=-1,-1 mybyte is an 8 bit integer: 0 myshort is a short integer: 1 myint is an integer: 20 mylong is a long integer: 9999 mystring is a string: supercalifragilisticexpialidocious myintArray is -1 and -1 satan# rmmod hello-5 Goodbye, world 5 satan# insmod hello-5.o mylong=hello hello-5.o: invalid argument syntax for mylong: 'h' Sometimes it makes sense to divide a kernel module between several source files. In this case, you need to:\n• None In all the source files but one, add the line #define __NO_VERSION__. This is important because normally includes the definition of , a global variable with the kernel version the module is compiled for. If you need , you need to include it yourself, because won't do it for you with .\n• None Compile all the source files as usual.\n• None Combine all the object files into a single one. Under x86, use ld -m elf_i386 -r -o <module name.o> <1st src file.o> <2nd src file.o>. The makefile will, once again, save us from having to get our hands dirty with compiling and linking the object files. Here's an example of such a kernel module. /* * start.c - Illustration of multi filed modules */ #include <linux/kernel.h> /* We're doing kernel work */ #include <linux/module.h> /* Specifically, a module */ int init_module(void) { printk(\"Hello, world - this is the kernel speaking\n\n\"); return 0; } /* * stop.c - Illustration of multi filed modules */ #include <linux/kernel.h> /* We're doing kernel work */ #include <linux/module.h> /* Specifically, a module */ void cleanup_module() { printk(\"<1>Short is the life of a kernel module\n\n\"); } Obviously, we strongly suggest you to recompile your kernel, so that you can enable a number of useful debugging features, such as forced module unloading ( ): when this option is enabled, you can force the kernel to unload a module even when it believes it is unsafe, via a rmmod -f module command. This option can save you a lot of time and a number of reboots during the development of a module. Nevertheless, there is a number of cases in which you may want to load your module into a precompiled running kernel, such as the ones shipped with common Linux distributions, or a kernel you have compiled in the past. In certain circumstances you could require to compile and insert a module into a running kernel which you are not allowed to recompile, or on a machine that you prefer not to reboot. If you can't think of a case that will force you to use modules for a precompiled kernel you might want to skip this and treat the rest of this chapter as a big footnote. Now, if you just install a kernel source tree, use it to compile your kernel module and you try to insert your module into the kernel, in most cases you would obtain an error as follows: Less cryptical information are logged to : In other words, your kernel refuses to accept your module because version strings (more precisely, version magics) do not match. Incidentally, version magics are stored in the module object in the form of a static string, starting with . Version data are inserted in your module when it is linked against the file. To inspect version magics and other strings stored in a given module, issue the modinfo module.ko command: To overcome this problem we could resort to the --force-vermagic option, but this solution is potentially unsafe, and unquestionably inacceptable in production modules. Consequently, we want to compile our module in an environment which was identical to the one in which our precompiled kernel was built. How to do this, is the subject of the remainder of this chapter. First of all, make sure that a kernel source tree is available, having exactly the same version as your current kernel. Then, find the configuration file which was used to compile your precompiled kernel. Usually, this is available in your current directory, under a name like . You may just want to copy it to your kernel source tree: cp /boot/config-`uname -r` /usr/src/linux-`uname -r`/.config. Let's focus again on the previous error message: a closer look at the version magic strings suggests that, even with two configuration files which are exactly the same, a slight difference in the version magic could be possible, and it is sufficient to prevent insertion of the module into the kernel. That slight difference, namely the string which appears in the module's version magic and not in the kernel's one, is due to a modification with respect to the original, in the makefile that some distribution include. Then, examine your , and make sure that the specified version information matches exactly the one used for your current kernel. For example, you makefile could start as follows: In this case, you need to restore the value of symbol to . We suggest to keep a backup copy of the makefile used to compile your kernel available in . A simple cp /lib/modules/`uname -r`/build/Makefile /usr/src/linux-`uname -r` should suffice. Additionally, if you already started a kernel build with the previous (wrong) , you should also rerun make, or directly modify symbol in file according to contents of file , or overwrite the latter with the first. Now, please run make to update configuration and version headers and objects: If you do not desire to actually compile the kernel, you can interrupt the build process (CTRL-C) just after the line, because at that time, the files you need will be are ready. Now you can turn back to the directory of your module and compile it: It will be built exactly according your current kernel settings, and it will load into it without any errors.\n\nA program usually begins with a function, executes a bunch of instructions and terminates upon completion of those instructions. Kernel modules work a bit differently. A module always begin with either the or the function you specify with call. This is the entry function for modules; it tells the kernel what functionality the module provides and sets up the kernel to run the module's functions when they're needed. Once it does this, entry function returns and the module does nothing until the kernel wants to do something with the code that the module provides. All modules end by calling either or the function you specify with the call. This is the exit function for modules; it undoes whatever entry function did. It unregisters the functionality that the entry function registered. Every module must have an entry function and an exit function. Since there's more than one way to specify entry and exit functions, I'll try my best to use the terms `entry function' and `exit function', but if I slip and simply refer to them as and , I think you'll know what I mean. Programmers use functions they don't define all the time. A prime example of this is . You use these library functions which are provided by the standard C library, libc. The definitions for these functions don't actually enter your program until the linking stage, which insures that the code (for for example) is available, and fixes the call instruction to point to that code. Kernel modules are different here, too. In the hello world example, you might have noticed that we used a function, but didn't include a standard I/O library. That's because modules are object files whose symbols get resolved upon insmod'ing. The definition for the symbols comes from the kernel itself; the only external functions you can use are the ones provided by the kernel. If you're curious about what symbols have been exported by your kernel, take a look at . One point to keep in mind is the difference between library functions and system calls. Library functions are higher level, run completely in user space and provide a more convenient interface for the programmer to the functions that do the real work---system calls. System calls run in kernel mode on the user's behalf and are provided by the kernel itself. The library function may look like a very general printing function, but all it really does is format the data into strings and write the string data using the low-level system call , which then sends the data to standard output. Would you like to see what system calls are made by ? It's easy! Compile the following program: with gcc -Wall -o hello hello.c. Run the exectable with strace hello. Are you impressed? Every line you see corresponds to a system call. strace is a handy program that gives you details about what system calls a program is making, including which call is made, what its arguments are what it returns. It's an invaluable tool for figuring out things like what files a program is trying to access. Towards the end, you'll see a line which looks like . There it is. The face behind the mask. You may not be familiar with write, since most people use library functions for file I/O (like fopen, fputs, fclose). If that's the case, try looking at man 2 write. The 2nd man section is devoted to system calls (like and . The 3rd man section is devoted to library calls, which you would probably be more familiar with (like and ). You can even write modules to replace the kernel's system calls, which we'll do shortly. Crackers often make use of this sort of thing for backdoors or trojans, but you can write your own modules to do more benign things, like have the kernel write Tee hee, that tickles! everytime someone tries to delete a file on your system. A kernel is all about access to resources, whether the resource in question happens to be a video card, a hard drive or even memory. Programs often compete for the same resource. As I just saved this document, updatedb started updating the locate database. My vim session and updatedb are both using the hard drive concurrently. The kernel needs to keep things orderly, and not give users access to resources whenever they feel like it. To this end, a can run in different modes. Each mode gives a different level of freedom to do what you want on the system. The Intel 80386 architecture has 4 of these modes, which are called rings. Unix uses only two rings; the highest ring (ring 0, also known as `supervisor mode' where everything is allowed to happen) and the lowest ring, which is called `user mode'. Recall the discussion about library functions vs system calls. Typically, you use a library function in user mode. The library function calls one or more system calls, and these system calls execute on the library function's behalf, but do so in supervisor mode since they are part of the kernel itself. Once the system call completes its task, it returns and execution gets transfered back to user mode. When you write a small C program, you use variables which are convenient and make sense to the reader. If, on the other hand, you're writing routines which will be part of a bigger problem, any global variables you have are part of a community of other peoples' global variables; some of the variable names can clash. When a program has lots of global variables which aren't meaningful enough to be distinguished, you get namespace pollution. In large projects, effort must be made to remember reserved names, and to find ways to develop a scheme for naming unique variable names and symbols. When writing kernel code, even the smallest module will be linked against the entire kernel, so this is definitely an issue. The best way to deal with this is to declare all your variables as static and to use a well-defined prefix for your symbols. By convention, all kernel prefixes are lowercase. If you don't want to declare everything as static, another option is to declare a and register it with a kernel. We'll get to this later. The file holds all the symbols that the kernel knows about and which are therefore accessible to your modules since they share the kernel's codespace. Memory management is a very complicated subject---the majority of O'Reilly's `Understanding The Linux Kernel' is just on memory management! We're not setting out to be experts on memory managements, but we do need to know a couple of facts to even begin worrying about writing real modules. If you haven't thought about what a segfault really means, you may be surprised to hear that pointers don't actually point to memory locations. Not real ones, anyway. When a process is created, the kernel sets aside a portion of real physical memory and hands it to the process to use for its executing code, variables, stack, heap and other things which a computer scientist would know about. This memory begins with $0$ and extends up to whatever it needs to be. Since the memory space for any two processes don't overlap, every process that can access a memory address, say , would be accessing a different location in real physical memory! The processes would be accessing an index named which points to some kind of offset into the region of memory set aside for that particular process. For the most part, a process like our Hello, World program can't access the space of another process, although there are ways which we'll talk about later. The kernel has its own space of memory as well. Since a module is code which can be dynamically inserted and removed in the kernel (as opposed to a semi-autonomous object), it shares the kernel's codespace rather than having its own. Therefore, if your module segfaults, the kernel segfaults. And if you start writing over data because of an off-by-one error, then you're trampling on kernel code. This is even worse than it sounds, so try your best to be careful. By the way, I would like to point out that the above discussion is true for any operating system which uses a monolithic kernel. There are things called microkernels which have modules which get their own codespace. The GNU Hurd and QNX Neutrino are two examples of a microkernel. One class of module is the device driver, which provides functionality for hardware like a TV card or a serial port. On unix, each piece of hardware is represented by a file located in named a which provides the means to communicate with the hardware. The device driver provides the communication on behalf of a user program. So the sound card device driver might connect the device file to the Ensoniq IS1370 sound card. A userspace program like mp3blaster can use without ever knowing what kind of sound card is installed. Let's look at some device files. Here are device files which represent the first three partitions on the primary master IDE hard drive: Notice the column of numbers separated by a comma? The first number is called the device's major number. The second number is the minor number. The major number tells you which driver is used to access the hardware. Each driver is assigned a unique major number; all device files with the same major number are controlled by the same driver. All the above major numbers are 3, because they're all controlled by the same driver. The minor number is used by the driver to distinguish between the various hardware it controls. Returning to the example above, although all three devices are handled by the same driver they have unique minor numbers because the driver sees them as being different pieces of hardware. Devices are divided into two types: character devices and block devices. The difference is that block devices have a buffer for requests, so they can choose the best order in which to respond to the requests. This is important in the case of storage devices, where it's faster to read or write sectors which are close to each other, rather than those which are further apart. Another difference is that block devices can only accept input and return output in blocks (whose size can vary according to the device), whereas character devices are allowed to use as many or as few bytes as they like. Most devices in the world are character, because they don't need this type of buffering, and they don't operate with a fixed block size. You can tell whether a device file is for a block device or a character device by looking at the first character in the output of ls -l. If it's `b' then it's a block device, and if it's `c' then it's a character device. The devices you see above are block devices. Here are some character devices (the serial ports): If you want to see which major numbers have been assigned, you can look at . When the system was installed, all of those device files were created by the mknod command. To create a new char device named `coffee' with major/minor number and , simply do mknod /dev/coffee c 12 2. You don't have to put your device files into , but it's done by convention. Linus put his device files in , and so should you. However, when creating a device file for testing purposes, it's probably OK to place it in your working directory where you compile the kernel module. Just be sure to put it in the right place when you're done writing the device driver. I would like to make a few last points which are implicit from the above discussion, but I'd like to make them explicit just in case. When a device file is accessed, the kernel uses the major number of the file to determine which driver should be used to handle the access. This means that the kernel doesn't really need to use or even know about the minor number. The driver itself is the only thing that cares about the minor number. It uses the minor number to distinguish between different pieces of hardware. By the way, when I say `hardware', I mean something a bit more abstract than a PCI card that you can hold in your hand. Look at these two device files: By now you can look at these two device files and know instantly that they are block devices and are handled by same driver (block major ). You might even be aware that these both represent your floppy drive, even if you only have one floppy drive. Why two files? One represents the floppy drive with of storage. The other is the same floppy drive with of storage, and corresponds to what some people call a `superformatted' disk. One that holds more data than a standard formatted floppy. So here's a case where two device files with different minor number actually represent the same piece of physical hardware. So just be aware that the word `hardware' in our discussion can mean something very abstract.\n\nThe file_operations structure is defined in , and holds pointers to functions defined by the driver that perform various operations on the device. Each field of the structure corresponds to the address of some function defined by the driver to handle a requested operation. For example, every character driver needs to define a function that reads from the device. The file_operations structure holds the address of the module's function that performs that operation. Here is what the definition looks like for kernel : Some operations are not implemented by a driver. For example, a driver that handles a video card won't need to read from a directory structure. The corresponding entries in the file_operations structure should be set to . There is a gcc extension that makes assigning to this structure more convenient. You'll see it in modern drivers, and may catch you by surprise. This is what the new way of assigning to the structure looks like: However, there's also a C99 way of assigning to elements of a structure, and this is definitely preferred over using the GNU extension. The version of gcc I'm currently using, , supports the new C99 syntax. You should use this syntax in case someone wants to port your driver. It will help with compatibility: The meaning is clear, and you should be aware that any member of the structure which you don't explicitly assign will be initialized to by gcc. Each device is represented in the kernel by a file structure, which is defined in . Be aware that a file is a kernel level structure and never appears in a user space program. It's not the same thing as a FILE, which is defined by glibc and would never appear in a kernel space function. Also, its name is a bit misleading; it represents an abstract open `file', not a file on a disk, which is represented by a structure named inode. A pointer to a is commonly named . You'll also see it refered to as . Resist the temptation. Go ahead and look at the definition of . Most of the entries you see, like aren't used by device drivers, and you can ignore them. This is because drivers don't fill directly; they only use structures contained in which are created elsewhere. As discussed earlier, char devices are accessed through device files, usually located in . The major number tells you which driver handles which device file. The minor number is used only by the driver itself to differentiate which device it's operating on, just in case the driver handles more than one device. Adding a driver to your system means registering it with the kernel. This is synonymous with assigning it a major number during the module's initialization. You do this by using the function, defined by . where is the major number you want to request, is the name of the device as it'll appear in and is a pointer to the table for your driver. A negative return value means the registertration failed. Note that we didn't pass the minor number to . That's because the kernel doesn't care about the minor number; only our driver uses it. Now the question is, how do you get a major number without hijacking one that's already in use? The easiest way would be to look through and pick an unused one. That's a bad way of doing things because you'll never be sure if the number you picked will be assigned later. The answer is that you can ask the kernel to assign you a dynamic major number. If you pass a major number of 0 to , the return value will be the dynamically allocated major number. The downside is that you can't make a device file in advance, since you don't know what the major number will be. There are a couple of ways to do this. First, the driver itself can print the newly assigned number and we can make the device file by hand. Second, the newly registered device will have an entry in , and we can either make the device file by hand or write a shell script to read the file in and make the device file. The third method is we can have our driver make the the device file using the system call after a successful registration and rm during the call to . We can't allow the kernel module to be rmmod'ed whenever root feels like it. If the device file is opened by a process and then we remove the kernel module, using the file would cause a call to the memory location where the appropriate function (read/write) used to be. If we're lucky, no other code was loaded there, and we'll get an ugly error message. If we're unlucky, another kernel module was loaded into the same location, which means a jump into the middle of another function within the kernel. The results of this would be impossible to predict, but they can't be very positive. Normally, when you don't want to allow something, you return an error code (a negative number) from the function which is supposed to do it. With that's impossible because it's a void function. However, there's a counter which keeps track of how many processes are using your module. You can see what it's value is by looking at the 3rd field of . If this number isn't zero, will fail. Note that you don't have to check the counter from within because the check will be performed for you by the system call , defined in . You shouldn't use this counter directly, but there are functions defined in which let you increase, decrease and display this counter: It's important to keep the counter accurate; if you ever do lose track of the correct usage count, you'll never be able to unload the module; it's now reboot time, boys and girls. This is bound to happen to you sooner or later during a module's development. The next code sample creates a char driver named . You can its device file (or the file with a program) and the driver will put the number of times the device file has been read from into the file. We don't support writing to the file (like echo \"hi\" > /dev/hello), but catch these attempts and tell the user that the operation isn't supported. Don't worry if you don't see what we do with the data we read into the buffer; we don't do much with it. We simply read in the data and print a message acknowledging that we received it. /* * chardev.c: Creates a read-only char device that says how many times * you've read from the dev file */ #include <linux/kernel.h> #include <linux/module.h> #include <linux/fs.h> #include <asm/uaccess.h> /* for put_user */ /* * Prototypes - this would normally go in a .h file */ int init_module(void); void cleanup_module(void); static int device_open(struct inode *, struct file *); static int device_release(struct inode *, struct file *); static ssize_t device_read(struct file *, char *, size_t, loff_t *); static ssize_t device_write(struct file *, const char *, size_t, loff_t *); #define SUCCESS 0 #define DEVICE_NAME \"chardev\" /* Dev name as it appears in /proc/devices */ #define BUF_LEN 80 /* Max length of the message from the device */ /* * Global variables are declared as static, so are global within the file. */ static int Major; /* Major number assigned to our device driver */ static int Device_Open = 0; /* Is device open? * Used to prevent multiple access to device */ static char msg[BUF_LEN]; /* The msg the device will give when asked */ static char *msg_Ptr; static struct file_operations fops = { .read = device_read, .write = device_write, .open = device_open, .release = device_release }; /* * Functions */ int init_module(void) { Major = register_chrdev(0, DEVICE_NAME, &fops); if (Major < 0) { printk(\"Registering the character device failed with %d\n\n\", Major); return Major; } printk(\"<1>I was assigned major number %d. To talk to\n\n\", Major); printk(\"<1>the driver, create a dev file with\n\n\"); printk(\"'mknod /dev/hello c %d 0'.\n\n\", Major); printk(\"<1>Try various minor numbers. Try to cat and echo to\n\n\"); printk(\"the device file.\n\n\"); printk(\"<1>Remove the device file and module when done.\n\n\"); return 0; } void cleanup_module(void) { /* * Unregister the device */ int ret = unregister_chrdev(Major, DEVICE_NAME); if (ret < 0) printk(\"Error in unregister_chrdev: %d\n\n\", ret); } /* * Methods */ /* * Called when a process tries to open the device file, like * \"cat /dev/mycharfile\" */ static int device_open(struct inode *inode, struct file *file) { static int counter = 0; if (Device_Open) return -EBUSY; Device_Open++; sprintf(msg, \"I already told you %d times Hello world!\n\n\", counter++); msg_Ptr = msg; try_module_get(THIS_MODULE); return SUCCESS; } /* * Called when a process closes the device file. */ static int device_release(struct inode *inode, struct file *file) { Device_Open--; /* We're now ready for our next caller */ /* * Decrement the usage count, or else once you opened the file, you'll * never get get rid of the module. */ module_put(THIS_MODULE); return 0; } /* * Called when a process, which already opened the dev file, attempts to * read from it. */ static ssize_t device_read(struct file *filp, /* see include/linux/fs.h */ char *buffer, /* buffer to fill with data */ size_t length, /* length of the buffer */ loff_t * offset) { /* * Number of bytes actually written to the buffer */ int bytes_read = 0; /* * If we're at the end of the message, * return 0 signifying end of file */ if (*msg_Ptr == 0) return 0; /* * Actually put the data into the buffer */ while (length && *msg_Ptr) { /* * The buffer is in the user data segment, not the kernel * segment so \"*\" assignment won't work. We have to use * put_user which copies data from the kernel data segment to * the user data segment. */ put_user(*(msg_Ptr++), buffer++); length--; bytes_read++; } /* * Most read functions return the number of bytes put into the buffer */ return bytes_read; } /* * Called when a process writes to dev file: echo \"hi\" > /dev/hello */ static ssize_t device_write(struct file *filp, const char *buff, size_t len, loff_t * off) { printk(\"<1>Sorry, this operation isn't supported.\n\n\"); return -EINVAL; } The system calls, which are the major interface the kernel shows to the processes, generally stay the same across versions. A new system call may be added, but usually the old ones will behave exactly like they used to. This is necessary for backward compatibility -- a new kernel version is not supposed to break regular processes. In most cases, the device files will also remain the same. On the other hand, the internal interfaces within the kernel can and do change between versions. The Linux kernel versions are divided between the stable versions (n.$<$even number$>$.m) and the development versions (n.$<$odd number$>$.m). The development versions include all the cool new ideas, including those which will be considered a mistake, or reimplemented, in the next version. As a result, you can't trust the interface to remain the same in those versions (which is why I don't bother to support them in this book, it's too much work and it would become dated too quickly). In the stable versions, on the other hand, we can expect the interface to remain the same regardless of the bug fix version (the m number). There are differences between different kernel versions, and if you want to support multiple kernel versions, you'll find yourself having to code conditional compilation directives. The way to do this to compare the macro to the macro . In version of the kernel, the value of this macro would be $2^{16}a+2^{8}b+c$. While previous versions of this guide showed how you can write backward compatible code with such constructs in great detail, we decided to break with this tradition for the better. People interested in doing such might now use a LKMPG with a version matching to their kernel. We decided to version the LKMPG like the kernel, at least as far as major and minor number are concerned. We use the patchlevel for our own versioning so use LKMPG version 2.4.x for kernels 2.4.x, use LKMPG version 2.6.x for kernels 2.6.x and so on. Also make sure that you always use current, up to date versions of both, kernel and guide.\n\nSo far we have two ways to generate output from kernel modules: we can register a device driver and mknod a device file, or we can create a file. This allows the kernel module to tell us anything it likes. The only problem is that there is no way for us to talk back. The first way we'll send input to kernel modules will be by writing back to the file. Because the proc filesystem was written mainly to allow the kernel to report its situation to processes, there are no special provisions for input. The doesn't include a pointer to an input function, the way it includes a pointer to an output function. Instead, to write into a file, we need to use the standard filesystem mechanism. In Linux there is a standard mechanism for file system registration. Since every file system has to have its own functions to handle inode and file operations, there is a special structure to hold pointers to all those functions, , which includes a pointer to . In /proc, whenever we register a new file, we're allowed to specify which will be used for access to it. This is the mechanism we use, a which includes a pointer to a which includes pointers to our and functions. It's important to note that the standard roles of read and write are reversed in the kernel. Read functions are used for output, whereas write functions are used for input. The reason for that is that read and write refer to the user's point of view --- if a process reads something from the kernel, then the kernel needs to output it, and if a process writes something to the kernel, then the kernel receives it as input. Another interesting point here is the function. This function is called whenever a process tries to do something with the file, and it can decide whether to allow access or not. Right now it is only based on the operation and the uid of the current user (as available in , a pointer to a structure which includes information on the currently running process), but it could be based on anything we like, such as what other processes are doing with the same file, the time of day, or the last input we received. The reason for and is that Linux memory (under Intel architecture, it may be different under some other processors) is segmented. This means that a pointer, by itself, does not reference a unique location in memory, only a location in a memory segment, and you need to know which memory segment it is to be able to use it. There is one memory segment for the kernel, and one of each of the processes. The only memory segment accessible to a process is its own, so when writing regular programs to run as processes, there's no need to worry about segments. When you write a kernel module, normally you want to access the kernel memory segment, which is handled automatically by the system. However, when the content of a memory buffer needs to be passed between the currently running process and the kernel, the kernel function receives a pointer to the memory buffer which is in the process segment. The and macros allow you to access that memory. /* * procfs.c - create a \"file\" in /proc, which allows both input and output. */ #include <linux/kernel.h> /* We're doing kernel work */ #include <linux/module.h> /* Specifically, a module */ #include <linux/proc_fs.h> /* Necessary because we use proc fs */ #include <asm/uaccess.h> /* for get_user and put_user */ /* * Here we keep the last message received, to prove * that we can process our input */ #define MESSAGE_LENGTH 80 static char Message[MESSAGE_LENGTH]; static struct proc_dir_entry *Our_Proc_File; #define PROC_ENTRY_FILENAME \"rw_test\" static ssize_t module_output(struct file *filp, /* see include/linux/fs.h */ char *buffer, /* buffer to fill with data */ size_t length, /* length of the buffer */ loff_t * offset) { static int finished = 0; int i; char message[MESSAGE_LENGTH + 30]; /* * We return 0 to indicate end of file, that we have * no more information. Otherwise, processes will * continue to read from us in an endless loop. */ if (finished) { finished = 0; return 0; } /* * We use put_user to copy the string from the kernel's * memory segment to the memory segment of the process * that called us. get_user, BTW, is * used for the reverse. */ sprintf(message, \"Last input:%s\", Message); for (i = 0; i < length && message[i]; i++) put_user(message[i], buffer + i); /* * Notice, we assume here that the size of the message * is below len, or it will be received cut. In a real * life situation, if the size of the message is less * than len then we'd return len and on the second call * start filling the buffer with the len+1'th byte of * the message. */ finished = 1; return i; /* Return the number of bytes \"read\" */ } static ssize_t module_input(struct file *filp, const char *buff, size_t len, loff_t * off) { int i; /* * Put the input into Message, where module_output * will later be able to use it */ for (i = 0; i < MESSAGE_LENGTH - 1 && i < len; i++) get_user(Message[i], buff + i); Message[i] = '\\0'; /* we want a standard, zero terminated string */ return i; } /* * This function decides whether to allow an operation * (return zero) or not allow it (return a non-zero * which indicates why it is not allowed). * * The operation can be one of the following values: * 0 - Execute (run the \"file\" - meaningless in our case) * 2 - Write (input to the kernel module) * 4 - Read (output from the kernel module) * * This is the real function that checks file * permissions. The permissions returned by ls -l are * for referece only, and can be overridden here. */ static int module_permission(struct inode *inode, int op, struct nameidata *foo) { /* * We allow everybody to read from our module, but * only root (uid 0) may write to it */ if (op == 4 || (op == 2 && current->euid == 0)) return 0; /* * If it's anything else, access is denied */ return -EACCES; } /* * The file is opened - we don't really care about * that, but it does mean we need to increment the * module's reference count. */ int module_open(struct inode *inode, struct file *file) { try_module_get(THIS_MODULE); return 0; } /* * The file is closed - again, interesting only because * of the reference count. */ int module_close(struct inode *inode, struct file *file) { module_put(THIS_MODULE); return 0; /* success */ } static struct file_operations File_Ops_4_Our_Proc_File = { .read = module_output, .write = module_input, .open = module_open, .release = module_close, }; /* * Inode operations for our proc file. We need it so * we'll have some place to specify the file operations * structure we want to use, and the function we use for * permissions. It's also possible to specify functions * to be called for anything else which could be done to * an inode (although we don't bother, we just put * NULL). */ static struct inode_operations Inode_Ops_4_Our_Proc_File = { .permission = module_permission, /* check for permissions */ }; /* * Module initialization and cleanup */ int init_module() { int rv = 0; Our_Proc_File = create_proc_entry(PROC_ENTRY_FILENAME, 0644, NULL); Our_Proc_File->owner = THIS_MODULE; Our_Proc_File->proc_iops = &Inode_Ops_4_Our_Proc_File; Our_Proc_File->proc_fops = &File_Ops_4_Our_Proc_File; Our_Proc_File->mode = S_IFREG | S_IRUGO | S_IWUSR; Our_Proc_File->uid = 0; Our_Proc_File->gid = 0; Our_Proc_File->size = 80; if (Our_Proc_File == NULL) { rv = -ENOMEM; remove_proc_entry(PROC_ENTRY_FILENAME, &proc_root); printk(KERN_INFO \"Error: Could not initialize /proc/test\n\n\"); } return rv; } void cleanup_module() { remove_proc_entry(PROC_ENTRY_FILENAME, &proc_root); } Still hungry for procfs examples? Well, first of all keep in mind, there are rumors around, claiming that procfs is on it's way out, consider using sysfs instead. Second, if you really can't get enough, there's a highly recommendable bonus level for procfs below . Use make help in your toplevel kernel directory for instructions about how to convert it into your favourite format. Example: make htmldocs . Consider using this mechanism, in case you want to document something kernel related yourself.\n\nDevice files are supposed to represent physical devices. Most physical devices are used for output as well as input, so there has to be some mechanism for device drivers in the kernel to get the output to send to the device from processes. This is done by opening the device file for output and writing to it, just like writing to a file. In the following example, this is implemented by . This is not always enough. Imagine you had a serial port connected to a modem (even if you have an internal modem, it is still implemented from the CPU's perspective as a serial port connected to a modem, so you don't have to tax your imagination too hard). The natural thing to do would be to use the device file to write things to the modem (either modem commands or data to be sent through the phone line) and read things from the modem (either responses for commands or the data received through the phone line). However, this leaves open the question of what to do when you need to talk to the serial port itself, for example to send the rate at which data is sent and received. The answer in Unix is to use a special function called (short for Input Output ConTroL). Every device can have its own commands, which can be read 's (to send information from a process to the kernel), write 's (to return information to a process), both or neither. The function is called with three parameters: the file descriptor of the appropriate device file, the ioctl number, and a parameter, which is of type long so you can use a cast to use it to pass anything. The ioctl number encodes the major device number, the type of the ioctl, the command, and the type of the parameter. This ioctl number is usually created by a macro call ( , , or --- depending on the type) in a header file. This header file should then be included both by the programs which will use (so they can generate the appropriate 's) and by the kernel module (so it can understand it). In the example below, the header file is and the program which uses it is . If you want to use s in your own kernel modules, it is best to receive an official assignment, so if you accidentally get somebody else's s, or if they get yours, you'll know something is wrong. For more information, consult the kernel source tree at . /* * chardev.c - Create an input/output character device */ #include <linux/kernel.h> /* We're doing kernel work */ #include <linux/module.h> /* Specifically, a module */ #include <linux/fs.h> #include <asm/uaccess.h> /* for get_user and put_user */ #include \"chardev.h\" #define SUCCESS 0 #define DEVICE_NAME \"char_dev\" #define BUF_LEN 80 /* * Is the device open right now? Used to prevent * concurent access into the same device */ static int Device_Open = 0; /* * The message the device will give when asked */ static char Message[BUF_LEN]; /* * How far did the process reading the message get? * Useful if the message is larger than the size of the * buffer we get to fill in device_read. */ static char *Message_Ptr; /* * This is called whenever a process attempts to open the device file */ static int device_open(struct inode *inode, struct file *file) { #ifdef DEBUG printk(\"device_open(%p)\n\n\", file); #endif /* * We don't want to talk to two processes at the same time */ if (Device_Open) return -EBUSY; Device_Open++; /* * Initialize the message */ Message_Ptr = Message; try_module_get(THIS_MODULE); return SUCCESS; } static int device_release(struct inode *inode, struct file *file) { #ifdef DEBUG printk(\"device_release(%p,%p)\n\n\", inode, file); #endif /* * We're now ready for our next caller */ Device_Open--; module_put(THIS_MODULE); return SUCCESS; } /* * This function is called whenever a process which has already opened the * device file attempts to read from it. */ static ssize_t device_read(struct file *file, /* see include/linux/fs.h */ char __user * buffer, /* buffer to be * filled with data */ size_t length, /* length of the buffer */ loff_t * offset) { /* * Number of bytes actually written to the buffer */ int bytes_read = 0; #ifdef DEBUG printk(\"device_read(%p,%p,%d)\n\n\", file, buffer, length); #endif /* * If we're at the end of the message, return 0 * (which signifies end of file) */ if (*Message_Ptr == 0) return 0; /* * Actually put the data into the buffer */ while (length && *Message_Ptr) { /* * Because the buffer is in the user data segment, * not the kernel data segment, assignment wouldn't * work. Instead, we have to use put_user which * copies data from the kernel data segment to the * user data segment. */ put_user(*(Message_Ptr++), buffer++); length--; bytes_read++; } #ifdef DEBUG printk(\"Read %d bytes, %d left\n\n\", bytes_read, length); #endif /* * Read functions are supposed to return the number * of bytes actually inserted into the buffer */ return bytes_read; } /* * This function is called when somebody tries to * write into our device file. */ static ssize_t device_write(struct file *file, const char __user * buffer, size_t length, loff_t * offset) { int i; #ifdef DEBUG printk(\"device_write(%p,%s,%d)\", file, buffer, length); #endif for (i = 0; i < length && i < BUF_LEN; i++) get_user(Message[i], buffer + i); Message_Ptr = Message; /* * Again, return the number of input characters used */ return i; } /* * This function is called whenever a process tries to do an ioctl on our * device file. We get two extra parameters (additional to the inode and file * structures, which all device functions get): the number of the ioctl called * and the parameter given to the ioctl function. * * If the ioctl is write or read/write (meaning output is returned to the * calling process), the ioctl call returns the output of this function. * */ int device_ioctl(struct inode *inode, /* see include/linux/fs.h */ struct file *file, /* ditto */ unsigned int ioctl_num, /* number and param for ioctl */ unsigned long ioctl_param) { int i; char *temp; char ch; /* * Switch according to the ioctl called */ switch (ioctl_num) { case IOCTL_SET_MSG: /* * Receive a pointer to a message (in user space) and set that * to be the device's message. Get the parameter given to * ioctl by the process. */ temp = (char *)ioctl_param; /* * Find the length of the message */ get_user(ch, temp); for (i = 0; ch && i < BUF_LEN; i++, temp++) get_user(ch, temp); device_write(file, (char *)ioctl_param, i, 0); break; case IOCTL_GET_MSG: /* * Give the current message to the calling process - * the parameter we got is a pointer, fill it. */ i = device_read(file, (char *)ioctl_param, 99, 0); /* * Put a zero at the end of the buffer, so it will be * properly terminated */ put_user('\\0', (char *)ioctl_param + i); break; case IOCTL_GET_NTH_BYTE: /* * This ioctl is both input (ioctl_param) and * output (the return value of this function) */ return Message[ioctl_param]; break; } return SUCCESS; } /* Module Declarations */ /* * This structure will hold the functions to be called * when a process does something to the device we * created. Since a pointer to this structure is kept in * the devices table, it can't be local to * init_module. NULL is for unimplemented functions. */ struct file_operations Fops = { .read = device_read, .write = device_write, .ioctl = device_ioctl, .open = device_open, .release = device_release, /* a.k.a. close */ }; /* * Initialize the module - Register the character device */ int init_module() { int ret_val; /* * Register the character device (atleast try) */ ret_val = register_chrdev(MAJOR_NUM, DEVICE_NAME, &Fops); /* * Negative values signify an error */ if (ret_val < 0) { printk(\"%s failed with %d\n\n\", \"Sorry, registering the character device \", ret_val); return ret_val; } printk(\"%s The major device number is %d.\n\n\", \"Registeration is a success\", MAJOR_NUM); printk(\"If you want to talk to the device driver,\n\n\"); printk(\"you'll have to create a device file. \n\n\"); printk(\"We suggest you use:\n\n\"); printk(\"mknod %s c %d 0\n\n\", DEVICE_FILE_NAME, MAJOR_NUM); printk(\"The device file name is important, because\n\n\"); printk(\"the ioctl program assumes that's the\n\n\"); printk(\"file you'll use.\n\n\"); return 0; } /* * Cleanup - unregister the appropriate file from /proc */ void cleanup_module() { int ret; /* * Unregister the device */ ret = unregister_chrdev(MAJOR_NUM, DEVICE_NAME); /* * If there's an error, report it */ if (ret < 0) printk(\"Error in module_unregister_chrdev: %d\n\n\", ret); } /* * chardev.h - the header file with the ioctl definitions. * * The declarations here have to be in a header file, because * they need to be known both to the kernel module * (in chardev.c) and the process calling ioctl (ioctl.c) */ #ifndef CHARDEV_H #define CHARDEV_H #include <linux/ioctl.h> /* * The major device number. We can't rely on dynamic * registration any more, because ioctls need to know * it. */ #define MAJOR_NUM 100 /* * Set the message of the device driver */ #define IOCTL_SET_MSG _IOR(MAJOR_NUM, 0, char *) /* * _IOR means that we're creating an ioctl command * number for passing information from a user process * to the kernel module. * * The first arguments, MAJOR_NUM, is the major device * number we're using. * * The second argument is the number of the command * (there could be several with different meanings). * * The third argument is the type we want to get from * the process to the kernel. */ /* * Get the message of the device driver */ #define IOCTL_GET_MSG _IOR(MAJOR_NUM, 1, char *) /* * This IOCTL is used for output, to get the message * of the device driver. However, we still need the * buffer to place the message in to be input, * as it is allocated by the process. */ /* * Get the n'th byte of the message */ #define IOCTL_GET_NTH_BYTE _IOWR(MAJOR_NUM, 2, int) /* * The IOCTL is used for both input and output. It * receives from the user a number, n, and returns * Message[n]. */ /* * The name of the device file */ #define DEVICE_FILE_NAME \"char_dev\" #endif /* * ioctl.c - the process to use ioctl's to control the kernel module * * Until now we could have used cat for input and output. But now * we need to do ioctl's, which require writing our own process. */ /* * device specifics, such as ioctl numbers and the * major device file. */ #include \"chardev.h\" #include <fcntl.h> /* open */ #include <unistd.h> /* exit */ #include <sys/ioctl.h> /* ioctl */ /* * Functions for the ioctl calls */ ioctl_set_msg(int file_desc, char *message) { int ret_val; ret_val = ioctl(file_desc, IOCTL_SET_MSG, message); if (ret_val < 0) { printf(\"ioctl_set_msg failed:%d\n\n\", ret_val); exit(-1); } } ioctl_get_msg(int file_desc) { int ret_val; char message[100]; /* * Warning - this is dangerous because we don't tell * the kernel how far it's allowed to write, so it * might overflow the buffer. In a real production * program, we would have used two ioctls - one to tell * the kernel the buffer length and another to give * it the buffer to fill */ ret_val = ioctl(file_desc, IOCTL_GET_MSG, message); if (ret_val < 0) { printf(\"ioctl_get_msg failed:%d\n\n\", ret_val); exit(-1); } printf(\"get_msg message:%s\n\n\", message); } ioctl_get_nth_byte(int file_desc) { int i; char c; printf(\"get_nth_byte message:\"); i = 0; while (c != 0) { c = ioctl(file_desc, IOCTL_GET_NTH_BYTE, i++); if (c < 0) { printf (\"ioctl_get_nth_byte failed at the %d'th byte:\n\n\", i); exit(-1); } putchar(c); } putchar('\n\n'); } /* * Main - Call the ioctl functions */ main() { int file_desc, ret_val; char *msg = \"Message passed by ioctl\n\n\"; file_desc = open(DEVICE_FILE_NAME, 0); if (file_desc < 0) { printf(\"Can't open device file: %s\n\n\", DEVICE_FILE_NAME); exit(-1); } ioctl_get_nth_byte(file_desc); ioctl_get_msg(file_desc); ioctl_set_msg(file_desc, msg); close(file_desc); }\n\nSo far, the only thing we've done was to use well defined kernel mechanisms to register files and device handlers. This is fine if you want to do something the kernel programmers thought you'd want, such as write a device driver. But what if you want to do something unusual, to change the behavior of the system in some way? Then, you're mostly on your own. This is where kernel programming gets dangerous. While writing the example below, I killed the system call. This meant I couldn't open any files, I couldn't run any programs, and I couldn't shutdown the computer. I had to pull the power switch. Luckily, no files died. To ensure you won't lose any files either, please run sync right before you do the insmod and the rmmod. Forget about files, forget about device files. They're just minor details. The real process to kernel communication mechanism, the one used by all processes, is system calls. When a process requests a service from the kernel (such as opening a file, forking to a new process, or requesting more memory), this is the mechanism used. If you want to change the behaviour of the kernel in interesting ways, this is the place to do it. By the way, if you want to see which system calls a program uses, run strace <arguments>. In general, a process is not supposed to be able to access the kernel. It can't access kernel memory and it can't call kernel functions. The hardware of the CPU enforces this (that's the reason why it's called `protected mode'). System calls are an exception to this general rule. What happens is that the process fills the registers with the appropriate values and then calls a special instruction which jumps to a previously defined location in the kernel (of course, that location is readable by user processes, it is not writable by them). Under Intel CPUs, this is done by means of interrupt 0x80. The hardware knows that once you jump to this location, you are no longer running in restricted user mode, but as the operating system kernel --- and therefore you're allowed to do whatever you want. The location in the kernel a process can jump to is called system_call. The procedure at that location checks the system call number, which tells the kernel what service the process requested. Then, it looks at the table of system calls ( ) to see the address of the kernel function to call. Then it calls the function, and after it returns, does a few system checks and then return back to the process (or to a different process, if the process time ran out). If you want to read this code, it's at the source file , after the line . So, if we want to change the way a certain system call works, what we need to do is to write our own function to implement it (usually by adding a bit of our own code, and then calling the original function) and then change the pointer at to point to our function. Because we might be removed later and we don't want to leave the system in an unstable state, it's important for to restore the table to its original state. The source code here is an example of such a kernel module. We want to `spy' on a certain user, and to a message whenever that user opens a file. Towards this end, we replace the system call to open a file with our own function, called . This function checks the uid (user's id) of the current process, and if it's equal to the uid we spy on, it calls to display the name of the file to be opened. Then, either way, it calls the original function with the same parameters, to actually open the file. The function replaces the appropriate location in and keeps the original pointer in a variable. The function uses that variable to restore everything back to normal. This approach is dangerous, because of the possibility of two kernel modules changing the same system call. Imagine we have two kernel modules, A and B. A's open system call will be A_open and B's will be B_open. Now, when A is inserted into the kernel, the system call is replaced with A_open, which will call the original sys_open when it's done. Next, B is inserted into the kernel, which replaces the system call with B_open, which will call what it thinks is the original system call, A_open, when it's done. Now, if B is removed first, everything will be well---it will simply restore the system call to A_open, which calls the original. However, if A is removed and then B is removed, the system will crash. A's removal will restore the system call to the original, sys_open, cutting B out of the loop. Then, when B is removed, it will restore the system call to what it thinks is the original, A_open, which is no longer in memory. At first glance, it appears we could solve this particular problem by checking if the system call is equal to our open function and if so not changing it at all (so that B won't change the system call when it's removed), but that will cause an even worse problem. When A is removed, it sees that the system call was changed to B_open so that it is no longer pointing to A_open, so it won't restore it to sys_open before it is removed from memory. Unfortunately, B_open will still try to call A_open which is no longer there, so that even without removing B the system would crash. Note that all the related problems make syscall stealing unfeasiable for production use. In order to keep people from doing potential harmful things sys_call_table is no longer exported. This means, if you want to do something more than a mere dry run of this example, you will have to patch your current kernel in order to have sys_call_table exported. In the example directory you will find a README and the patch. As you can imagine, such modifications are not to be taken lightly. Do not try this on valueable systems (ie systems that you do not own - or cannot restore easily). It should go O.K., but kernel people, choose to not support hacks like this in 2.6. and I'm sure they've had their reasons for that. For more details, see the README. If in doubt, saying N here and skipping this example is the safe choice. /* * syscall.c * * System call \"stealing\" sample. */ /* * Copyright (C) 2001 by Peter Jay Salzman */ /* * The necessary header files */ /* * Standard in kernel modules */ #include <linux/kernel.h> /* We're doing kernel work */ #include <linux/module.h> /* Specifically, a module, */ #include <linux/moduleparam.h> /* which will have params */ #include <linux/unistd.h> /* The list of system calls */ /* * For the current (process) structure, we need * this to know who the current user is. */ #include <linux/sched.h> #include <asm/uaccess.h> /* * The system call table (a table of functions). We * just define this as external, and the kernel will * fill it up for us when we are insmod'ed * * sys_call_table is no longer exported in 2.6.x kernels. * If you really want to try this DANGEROUS module you will * have to apply the supplied patch against your current kernel * and recompile it. */ extern void *sys_call_table[]; /* * UID we want to spy on - will be filled from the * command line */ static int uid; module_param(uid, int, 0644); /* * A pointer to the original system call. The reason * we keep this, rather than call the original function * (sys_open), is because somebody else might have * replaced the system call before us. Note that this * is not 100% safe, because if another module * replaced sys_open before us, then when we're inserted * we'll call the function in that module - and it * might be removed before we are. * * Another reason for this is that we can't get sys_open. * It's a static variable, so it is not exported. */ asmlinkage int (*original_call) (const char *, int, int); /* * The function we'll replace sys_open (the function * called when you call the open system call) with. To * find the exact prototype, with the number and type * of arguments, we find the original function first * (it's at fs/open.c). * * In theory, this means that we're tied to the * current version of the kernel. In practice, the * system calls almost never change (it would wreck havoc * and require programs to be recompiled, since the system * calls are the interface between the kernel and the * processes). */ asmlinkage int our_sys_open(const char *filename, int flags, int mode) { int i = 0; char ch; /* * Check if this is the user we're spying on */ if (uid == current->uid) { /* * Report the file, if relevant */ printk(\"Opened file by %d: \", uid); do { get_user(ch, filename + i); i++; printk(\"%c\", ch); } while (ch != 0); printk(\"\n\n\"); } /* * Call the original sys_open - otherwise, we lose * the ability to open files */ return original_call(filename, flags, mode); } /* * Initialize the module - replace the system call */ int init_module() { /* * Warning - too late for it now, but maybe for * next time... */ printk(\"I'm dangerous. I hope you did a \"); printk(\"sync before you insmod'ed me.\n\n\"); printk(\"My counterpart, cleanup_module(), is even\"); printk(\"more dangerous. If\n\n\"); printk(\"you value your file system, it will \"); printk(\"be \\\"sync; rmmod\\\" \n\n\"); printk(\"when you remove this module.\n\n\"); /* * Keep a pointer to the original function in * original_call, and then replace the system call * in the system call table with our_sys_open */ original_call = sys_call_table[__NR_open]; sys_call_table[__NR_open] = our_sys_open; /* * To get the address of the function for system * call foo, go to sys_call_table[__NR_foo]. */ printk(\"Spying on UID:%d\n\n\", uid); return 0; } /* * Cleanup - unregister the appropriate file from /proc */ void cleanup_module() { /* * Return the system call back to normal */ if (sys_call_table[__NR_open] != our_sys_open) { printk(\"Somebody else also played with the \"); printk(\"open system call\n\n\"); printk(\"The system may be left in \"); printk(\"an unstable state.\n\n\"); } sys_call_table[__NR_open] = original_call; }\n\nWhat do you do when somebody asks you for something you can't do right away? If you're a human being and you're bothered by a human being, the only thing you can say is: \"Not right now, I'm busy. Go away!\". But if you're a kernel module and you're bothered by a process, you have another possibility. You can put the process to sleep until you can service it. After all, processes are being put to sleep by the kernel and woken up all the time (that's the way multiple processes appear to run on the same time on a single CPU). This kernel module is an example of this. The file (called ) can only be opened by a single process at a time. If the file is already open, the kernel module calls . This function changes the status of the task (a task is the kernel data structure which holds information about a process and the system call it's in, if any) to , which means that the task will not run until it is woken up somehow, and adds it to , the queue of tasks waiting to access the file. Then, the function calls the scheduler to context switch to a different process, one which has some use for the CPU. When a process is done with the file, it closes it, and is called. That function wakes up all the processes in the queue (there's no mechanism to only wake up one of them). It then returns and the process which just closed the file can continue to run. In time, the scheduler decides that that process has had enough and gives control of the CPU to another process. Eventually, one of the processes which was in the queue will be given control of the CPU by the scheduler. It starts at the point right after the call to . It can then proceed to set a global variable to tell all the other processes that the file is still open and go on with its life. When the other processes get a piece of the CPU, they'll see that global variable and go back to sleep. To make our life more interesting, doesn't have a monopoly on waking up the processes which wait to access the file. A signal, such as Ctrl+c ( ) can also wake up a process. In that case, we want to return with immediately. This is important so users can, for example, kill the process before it receives the file. There is one more point to remember. Some times processes don't want to sleep, they want either to get what they want immediately, or to be told it cannot be done. Such processes use the flag when opening the file. The kernel is supposed to respond by returning with the error code from operations which would otherwise block, such as opening the file in this example. The program cat_noblock, available in the source directory for this chapter, can be used to open a file with . /* * sleep.c - create a /proc file, and if several processes try to open it at * the same time, put all but one to sleep */ #include <linux/kernel.h> /* We're doing kernel work */ #include <linux/module.h> /* Specifically, a module */ #include <linux/proc_fs.h> /* Necessary because we use proc fs */ #include <linux/sched.h> /* For putting processes to sleep and waking them up */ #include <asm/uaccess.h> /* for get_user and put_user */ /* * The module's file functions */ /* * Here we keep the last message received, to prove that we can process our * input */ #define MESSAGE_LENGTH 80 static char Message[MESSAGE_LENGTH]; static struct proc_dir_entry *Our_Proc_File; #define PROC_ENTRY_FILENAME \"sleep\" /* * Since we use the file operations struct, we can't use the special proc * output provisions - we have to use a standard read function, which is this * function */ static ssize_t module_output(struct file *file, /* see include/linux/fs.h */ char *buf, /* The buffer to put data to (in the user segment) */ size_t len, /* The length of the buffer */ loff_t * offset) { static int finished = 0; int i; char message[MESSAGE_LENGTH + 30]; /* * Return 0 to signify end of file - that we have nothing * more to say at this point. */ if (finished) { finished = 0; return 0; } /* * If you don't understand this by now, you're hopeless as a kernel * programmer. */ sprintf(message, \"Last input:%s\n\n\", Message); for (i = 0; i < len && message[i]; i++) put_user(message[i], buf + i); finished = 1; return i; /* Return the number of bytes \"read\" */ } /* * This function receives input from the user when the user writes to the /proc * file. */ static ssize_t module_input(struct file *file, /* The file itself */ const char *buf, /* The buffer with input */ size_t length, /* The buffer's length */ loff_t * offset) { /* offset to file - ignore */ int i; /* * Put the input into Message, where module_output will later be * able to use it */ for (i = 0; i < MESSAGE_LENGTH - 1 && i < length; i++) get_user(Message[i], buf + i); /* * we want a standard, zero terminated string */ Message[i] = '\\0'; /* * We need to return the number of input characters used */ return i; } /* * 1 if the file is currently open by somebody */ int Already_Open = 0; /* * Queue of processes who want our file */ DECLARE_WAIT_QUEUE_HEAD(WaitQ); /* * Called when the /proc file is opened */ static int module_open(struct inode *inode, struct file *file) { /* * If the file's flags include O_NONBLOCK, it means the process doesn't * want to wait for the file. In this case, if the file is already * open, we should fail with -EAGAIN, meaning \"you'll have to try * again\", instead of blocking a process which would rather stay awake. */ if ((file->f_flags & O_NONBLOCK) && Already_Open) return -EAGAIN; /* * This is the correct place for try_module_get(THIS_MODULE) because * if a process is in the loop, which is within the kernel module, * the kernel module must not be removed. */ try_module_get(THIS_MODULE); /* * If the file is already open, wait until it isn't */ while (Already_Open) { int i, is_sig = 0; /* * This function puts the current process, including any system * calls, such as us, to sleep. Execution will be resumed right * after the function call, either because somebody called * wake_up(&WaitQ) (only module_close does that, when the file * is closed) or when a signal, such as Ctrl-C, is sent * to the process */ wait_event_interruptible(WaitQ, !Already_Open); /* * If we woke up because we got a signal we're not blocking, * return -EINTR (fail the system call). This allows processes * to be killed or stopped. */ /* * Emmanuel Papirakis: * * This is a little update to work with 2.2.*. Signals now are contained in * two words (64 bits) and are stored in a structure that contains an array of * two unsigned longs. We now have to make 2 checks in our if. * * Ori Pomerantz: * * Nobody promised me they'll never use more than 64 bits, or that this book * won't be used for a version of Linux with a word size of 16 bits. This code * would work in any case. */ for (i = 0; i < _NSIG_WORDS && !is_sig; i++) is_sig = current->pending.signal.sig[i] & ~current-> blocked.sig[i]; if (is_sig) { /* * It's important to put module_put(THIS_MODULE) here, * because for processes where the open is interrupted * there will never be a corresponding close. If we * don't decrement the usage count here, we will be * left with a positive usage count which we'll have no * way to bring down to zero, giving us an immortal * module, which can only be killed by rebooting * the machine. */ module_put(THIS_MODULE); return -EINTR; } } /* * If we got here, Already_Open must be zero */ /* * Open the file */ Already_Open = 1; return 0; /* Allow the access */ } /* * Called when the /proc file is closed */ int module_close(struct inode *inode, struct file *file) { /* * Set Already_Open to zero, so one of the processes in the WaitQ will * be able to set Already_Open back to one and to open the file. All * the other processes will be called when Already_Open is back to one, * so they'll go back to sleep. */ Already_Open = 0; /* * Wake up all the processes in WaitQ, so if anybody is waiting for the * file, they can have it. */ wake_up(&WaitQ); module_put(THIS_MODULE); return 0; /* success */ } /* * This function decides whether to allow an operation (return zero) or not * allow it (return a non-zero which indicates why it is not allowed). * * The operation can be one of the following values: * 0 - Execute (run the \"file\" - meaningless in our case) * 2 - Write (input to the kernel module) * 4 - Read (output from the kernel module) * * This is the real function that checks file permissions. The permissions * returned by ls -l are for reference only, and can be overridden here. */ static int module_permission(struct inode *inode, int op, struct nameidata *nd) { /* * We allow everybody to read from our module, but only root (uid 0) * may write to it */ if (op == 4 || (op == 2 && current->euid == 0)) return 0; /* * If it's anything else, access is denied */ return -EACCES; } /* * Structures to register as the /proc file, with pointers to all the relevant * functions. */ /* * File operations for our proc file. This is where we place pointers to all * the functions called when somebody tries to do something to our file. NULL * means we don't want to deal with something. */ static struct file_operations File_Ops_4_Our_Proc_File = { .read = module_output, /* \"read\" from the file */ .write = module_input, /* \"write\" to the file */ .open = module_open, /* called when the /proc file is opened */ .release = module_close, /* called when it's closed */ }; /* * Inode operations for our proc file. We need it so we'll have somewhere to * specify the file operations structure we want to use, and the function we * use for permissions. It's also possible to specify functions to be called * for anything else which could be done to an inode (although we don't bother, * we just put NULL). */ static struct inode_operations Inode_Ops_4_Our_Proc_File = { .permission = module_permission, /* check for permissions */ }; /* * Module initialization and cleanup */ /* * Initialize the module - register the proc file */ int init_module() { int rv = 0; Our_Proc_File = create_proc_entry(PROC_ENTRY_FILENAME, 0644, NULL); Our_Proc_File->owner = THIS_MODULE; Our_Proc_File->proc_iops = &Inode_Ops_4_Our_Proc_File; Our_Proc_File->proc_fops = &File_Ops_4_Our_Proc_File; Our_Proc_File->mode = S_IFREG | S_IRUGO | S_IWUSR; Our_Proc_File->uid = 0; Our_Proc_File->gid = 0; Our_Proc_File->size = 80; if (Our_Proc_File == NULL) { rv = -ENOMEM; remove_proc_entry(PROC_ENTRY_FILENAME, &proc_root); printk(KERN_INFO \"Error: Could not initialize /proc/test\n\n\"); } return rv; } /* * Cleanup - unregister our file from /proc. This could get dangerous if * there are still processes waiting in WaitQ, because they are inside our * open function, which will get unloaded. I'll explain how to avoid removal * of a kernel module in such a case in chapter 10. */ void cleanup_module() { remove_proc_entry(PROC_ENTRY_FILENAME, &proc_root); }"
    },
    {
        "link": "https://quora.com/Linux-Kernel-How-does-copy_to_user-work",
        "document": "Something went wrong. Wait a moment and try again."
    },
    {
        "link": "https://doc-developpement-durable.org/file/Projets-informatiques/cours-&-manuels-informatiques/Linux/Linux%20Kernel%20Development,%203rd%20Edition.pdf",
        "document": ""
    },
    {
        "link": "https://stackoverflow.com/questions/42774058/how-to-use-copy-to-user-in-a-kernel-program",
        "document": "As many times as you want. But they have to make sense (because anything you do in any kind of program has to make sense).\n\nI thought if the data that is passed into the copy_to_user() will append the data to the next line.\n\nNo, does not append anything. I'm not sure where you got that idea.\n\nWell, you're copying the data for the first process, then overwriting it with the data for the second process, then overwriting that with the data for the third process, and so on. At the end you're left with the third process's data.\n\nStore the data for each process at a different location."
    },
    {
        "link": "https://quora.com/What-are-some-examples-from-Linux-kernel-source-implementing-copy-on-write-feature",
        "document": "Something went wrong. Wait a moment and try again."
    },
    {
        "link": "https://stackoverflow.com/questions/41617907/how-to-use-copy-to-user-in-workqueue-linux-kernel",
        "document": "intented to be called from user context only. It is bad idea to call it from workqueue context.\n\nYou can allocate memory block (kmalloc), submit it to workqueue, wait until wokqueue finished it's work in user context (in functions like read, write, ioctl) and copy workqueue result to userspace.\n\nAs an another approach you can allocate kernel memory and mmap it to userspace so the memory could be directly accessed by kernel and userspace at same time. Each time workqueue update kernel memory the data became available to userspace. You have to implement some sort of synchronization between userspace and kernel space workqueues to make this approach workable.\n\nSee uvc_queue.c for example of mmap implementation."
    }
]