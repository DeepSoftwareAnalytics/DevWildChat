[
    {
        "link": "https://expressjs.com/en/guide/using-middleware.html",
        "document": "Express is a routing and middleware web framework that has minimal functionality of its own: An Express application is essentially a series of middleware function calls.\n\nMiddleware functions are functions that have access to the request object ( ), the response object ( ), and the next middleware function in the application’s request-response cycle. The next middleware function is commonly denoted by a variable named .\n\nMiddleware functions can perform the following tasks:\n• Make changes to the request and the response objects.\n• Call the next middleware function in the stack.\n\nIf the current middleware function does not end the request-response cycle, it must call to pass control to the next middleware function. Otherwise, the request will be left hanging.\n\nAn Express application can use the following types of middleware:\n\nYou can load application-level and router-level middleware with an optional mount path. You can also load a series of middleware functions together, which creates a sub-stack of the middleware system at a mount point.\n\nBind application-level middleware to an instance of the app object by using the and functions, where is the HTTP method of the request that the middleware function handles (such as GET, PUT, or POST) in lowercase.\n\nThis example shows a middleware function with no mount path. The function is executed every time the app receives a request.\n\nThis example shows a middleware function mounted on the path. The function is executed for any type of HTTP request on the path.\n\nThis example shows a route and its handler function (middleware system). The function handles GET requests to the path.\n\nHere is an example of loading a series of middleware functions at a mount point, with a mount path. It illustrates a middleware sub-stack that prints request info for any type of HTTP request to the path.\n\nRoute handlers enable you to define multiple routes for a path. The example below defines two routes for GET requests to the path. The second route will not cause any problems, but it will never get called because the first route ends the request-response cycle.\n\nThis example shows a middleware sub-stack that handles GET requests to the path.\n\nTo skip the rest of the middleware functions from a router middleware stack, call to pass control to the next route.\n\nThis example shows a middleware sub-stack that handles GET requests to the path.\n\nMiddleware can also be declared in an array for reusability.\n\nThis example shows an array with a middleware sub-stack that handles GET requests to the path\n\nRouter-level middleware works in the same way as application-level middleware, except it is bound to an instance of .\n\nLoad router-level middleware by using the and functions.\n\nThe following example code replicates the middleware system that is shown above for application-level middleware, by using router-level middleware:\n\n// a middleware function with no mount path. This code is executed for every request to the router // a middleware sub-stack shows request info for any type of HTTP request to the /user/:id path // a middleware sub-stack that handles GET requests to the /user/:id path // if the user ID is 0, skip to the next router // otherwise pass control to the next middleware function in this stack // handler for the /user/:id path, which renders a special page // mount the router on the app\n\nTo skip the rest of the router’s middleware functions, call to pass control back out of the router instance.\n\nThis example shows a middleware sub-stack that handles GET requests to the path.\n\nDefine error-handling middleware functions in the same way as other middleware functions, except with four arguments instead of three, specifically with the signature :\n\nFor details about error-handling middleware, see: Error handling.\n\nStarting with version 4.x, Express no longer depends on Connect. The middleware functions that were previously included with Express are now in separate modules; see the list of middleware functions.\n\nExpress has the following built-in middleware functions:\n• express.static serves static assets such as HTML files, images, and so on.\n• express.json parses incoming requests with JSON payloads. NOTE: Available with Express 4.16.0+\n• express.urlencoded parses incoming requests with URL-encoded payloads. NOTE: Available with Express 4.16.0+\n\nUse third-party middleware to add functionality to Express apps.\n\nInstall the Node.js module for the required functionality, then load it in your app at the application level or at the router level.\n\nThe following example illustrates installing and loading the cookie-parsing middleware function .\n\nFor a partial list of third-party middleware functions that are commonly used with Express, see: Third-party middleware."
    },
    {
        "link": "https://expressjs.com/en/api.html",
        "document": "Creates an Express application. The function is a top-level function exported by the module.\n\nThe object conventionally denotes the Express application. Create it by calling the top-level function exported by the Express module:\n\nThe object has methods for\n• Routing HTTP requests; see for example, app.METHOD and app.param.\n\nIt also has settings (properties) that affect how the application behaves; for more information, see Application settings.\n\nAdd callback triggers to route parameters, where is the name of the parameter or an array of them, and is the callback function. The parameters of the callback function are the request object, the response object, the next middleware, the value of the parameter and the name of the parameter, in that order. If is an array, the trigger is registered for each parameter declared in it, in the order in which they are declared. Furthermore, for each declared parameter except the last one, a call to inside the callback will call the callback for the next declared parameter. For the last parameter, a call to will call the next middleware in place for the route currently being processed, just like it would if were just a string. For example, when is present in a route path, you may map user loading logic to automatically provide to the route, or perform validations on the parameter input. // try to get the user details from the User model and attach it to the request object Param callback functions are local to the router on which they are defined. They are not inherited by mounted apps or routers, nor are they triggered for route parameters inherited from parent routers. Hence, param callbacks defined on will be triggered only by route parameters defined on routes. All param callbacks will be called before any handler of any route in which the param occurs, and they will each be called only once in a request-response cycle, even if the parameter is matched in multiple routes, as shown in the following examples. On , the following is printed: CALLED ONLY ONCE although this matches and this matches too On , the following is printed: CALLED ONLY ONCE with 42 CALLED ONLY ONCE with 3 although this matches and this matches too The following section describes , which is deprecated as of v4.11.0. The behavior of the method can be altered entirely by passing only a function to . This function is a custom implementation of how should behave - it accepts two parameters and must return a middleware. The first parameter of this function is the name of the URL parameter that should be captured, the second parameter can be any JavaScript object which might be used for returning the middleware implementation. The middleware returned by the function decides the behavior of what happens when a URL parameter is captured. In this example, the signature is modified to . Instead of accepting a name and a callback, will now accept a name and a number. In this example, the signature remains the same, but instead of a middleware callback, a custom data type checking function has been defined to validate the data type of the user id. The ‘ ’ character can’t be used to capture a character in your capturing regexp. For example you can’t use to capture , use or instead (as in . // captures '1-a_6' and '543-az(ser\"-sder' but not '5-a s'\n\nThe object represents the HTTP request and has properties for the request query string, parameters, body, HTTP headers, and so on. In this documentation and by convention, the object is always referred to as (and the HTTP response is ) but its actual name is determined by the parameters to the callback function in which you’re working.\n\nBut you could just as well have:\n\nThe object is an enhanced version of Node’s own request object and supports all built-in fields and methods.\n\nThe object represents the HTTP response that an Express app sends when it gets an HTTP request.\n\nIn this documentation and by convention, the object is always referred to as (and the HTTP request is ) but its actual name is determined by the parameters to the callback function in which you’re working.\n\nBut you could just as well have:\n\nThe object is an enhanced version of Node’s own response object and supports all built-in fields and methods."
    },
    {
        "link": "https://geeksforgeeks.org/middleware-in-express-js",
        "document": "Middleware functions are the building blocks of any web server, especially in frameworks like ExpressJS. It plays a vital role in the request-response cycle. They are functions that have access to the request object (req), the response object (res), and the next function in the application’s request-response cycle.\n\nWhat is Middleware in Express?\n\nMiddleware in Express refers to functions that process requests before reaching the route handlers. These functions can modify request and response objects, end the request-response cycle, or call the next middleware function.\n• None Middleware functions are executed in the order they are defined.\n• None They can perform tasks like authentication, logging, or error handling.\n• (req, res, next) => {}: This is the middleware function where you can perform actions on the request and response objects before the final handler is executed.\n• next(): This function is called to pass control to the next middleware in the stack if the current one doesn’t end the request-response cycle.\n\nIn Express.js, middleware functions are executed sequentially in the order they are added to the application. When a request is received, it is passed through the middleware functions in the order they were defined. Each middleware can perform a task and either send a response or call the next() function to pass control to the next middleware function.\n\nHere’s how the typical flow looks:\n• Middleware functions are applied to the request, one by one.\n• None Each middleware can either:\n• Call next() to pass control to the next middleware.\n• None If no middleware ends the cycle, the route handler is reached, and a final response is sent.\n\nExpressJS offers different types of middleware and you should choose the middleware based on functionality required.\n• Application-level middleware: Bound to the entire application using app.use() app.METHOD() and executes for all routes.\n• Router-level middleware : Associated with specific routes using router.use() router.METHOD() and executes for routes defined within that router.\n• Error-handling middleware: Handles errors during the request-response cycle. Defined with four parameters (err, req, res, next).\n\nWhen you navigate to http://localhost:3000/, you will see:\n\nMiddleware can be chained from one to another, Hence creating a chain of functions that are executed in order. The last function sends the response back to the browser. So, before sending the response back to the browser the different middleware processes the request.\n\nThe next() function in the express is responsible for calling the next middleware function if there is one.\n\nModified requests will be available to each middleware via the next function\n• Middleware 1: Logs the HTTP method and URL of the incoming request.\n\nWhen a client makes a GET request to http://localhost:3000/, the server responds with:\n• Reusability: Middleware functions can be reused across different routes or applications.\n• Maintainability : Organizes code logically, making it easier to manage and update.\n• Performance Optimization : Allows for tasks like caching, compression, and security checks to be handled efficiently.\n\nBest Practices for Middleware in ExpressJS\n• None Always call next() to pass control to the next middleware unless you are ending the request-response cycle.\n• None Use specific middleware for different tasks (e.g., authentication, logging) to keep the code modular and clean.\n• None Place error-handling middleware at the end of the middleware stack to catch any unhandled errors.\n• None Avoid using synchronous code in middleware to prevent blocking the event loop.\n\nWhat is the purpose of next() in Express middleware?\n\nHow do I handle errors in middleware?\n\nCan middleware be applied to specific routes?\n\nIs it a good practice to have large middleware functions?\n\nHow can I avoid security issues with middleware?"
    },
    {
        "link": "https://developer.okta.com/blog/2018/09/13/build-and-understand-express-middleware-through-examples",
        "document": "If you’ve done any significant Node development in the past seven or eight years, you’ve probably used Express to build a web server at some point. While you can create a server in Node without using a library, it doesn’t give you a lot out of the box and can be quite cumbersome to add functionality. Express is a minimalist, “unopinionated” server library and has become the de facto standard for building web apps in Node. To understand Express, you need to understand Express Middleware.\n\nMiddleware literally means anything you put in the middle of one layer of the software and another. Express middleware are functions that execute during the lifecycle of a request to the Express server. Each middleware has access to the HTTP and for each route (or path) it’s attached to. In fact, Express itself is compromised wholly of middleware functions. Additionally, middleware can either terminate the HTTP request or pass it on to another middleware function using (more on that soon). This “chaining” of middleware allows you to compartmentalize your code and create reusable middleware.\n\nIn this article I’ll explain what middleware is, why you would use it, how to use existing Express middleware, and how to write your own middleware for Express.\n\nThere are a few things you will need installed to create, use, and test Express middleware. First, you will need Node and NPM. To ensure you have them installed, you can run:\n\nYou should see the Node and NPM versions you have installed. If you get an error, you need to install Node. I’m using the latest version of both as of the time of this article, which is Node 10.9.0 and NPM 6.4.1, but all the examples should work with Node versions 8+ and NPM versions 5+.\n\nI will also be using Express version 4.x. This is important because major changes were made from version 3.x to 4.x.\n\nIt will also be helpful to have Postman installed to test routes using any HTTP verbs other than .\n\nTo get started, you’ll use the most basic of Express’ built-in middleware. This will give you the chance to see how middleware is used, and how Express middleware is structured.\n\nCreate and paste the following code:\n\nRun the server via , access , and you should see “Welcome Home” printed in your browser.\n\nThe function is Application-level Middleware. You’ll notice the parameters passed to the method are , , and . These are the incoming request, the response being written, and a method to call to pass the call to the next middleware function once the current middleware is finished. In this case, once the response is sent, the function exits. You could also chain other middleware here by calling the method.\n\nLet’s take a look at a few more examples of the different types of middleware.\n\nIn Express, you can set up middleware to be “global” middleware; meaning it will be called for every incoming request.\n\nChange the contents of to:\n\nThis time, when you go to you should see the same thing in your browser window, but back in the console window you will see the output of the incoming request object.\n\nThe middleware logs out the request object and then calls . The next middleware in the pipeline handles the get request to the root URL and sends back the text response. Using means that this middleware will be called for every call to the application.\n\nIn addition to running middleware for all calls, you could also specify to only run middleware for specific calls.\n\nChange the file again to:\n\nThis time, start the server by running:\n\nTo test this, open up Postman and create a post request to . Don’t set any headers and run the request. You will get back the “Server requires application/json” message.\n\nNow go back and add the header with a value of and run the request again. You will get the “You sent JSON” message back from the server.\n\nThis method call adds the middleware function to ensure the incoming request payload has a header value set to . If it doesn’t pass the check, an error response is sent. If it does, the request is then handed off to the next piece of middleware in the chain via the method.\n\nYou’ve built a couple of custom middlewares to far, but there are lots of packages already built to do the things you might normally want to do. In fact, you’ve used the simple routing middleware library by using the or middleware functions. There are thousands of middleware libraries for doing things like parsing incoming data, routing, and authorization.\n\nOkta has an Express middleware for OIDC security that I’ll show you to demonstrate using third-party middleware libraries.\n\nAt Okta, our goal is to make identity management a lot easier, more secure, and more scalable than what you’re used to. Okta is a cloud service that allows developers to create, edit, and securely store user accounts and user account data, and connect them with one or multiple applications. Our API enables you to:\n• And much more! Check out our product documentation\n\nThen in the file, you create an instance if the middleware with some configuration options so that Okta knows how to connect to your Okta application.\n\nYou’ll also need to tell Express to use the OIDC middleware router instead of the default router.\n\nThen you use it like any other middleware:\n\nThe function is a middleware in the Okta library. It runs a function to see if the current user is logged in. If they are, it calls to let the function continue handling the request. If they aren’t it will send back an response.\n\nWhen a request is received by Express, each middleware that matches the request is run in the order it is initialized until there is a terminating action (like a response being sent).\n\nSo if an error occurs, all middleware that is meant to handle errors will be called in order until one of them does not call the function call.\n\nExpress has a built-in default error handler that is inserted at the end of the middleware pipeline that handles any unhandled errors that may have occurred in the pipeline. Its signature adds an error parameter to the standard parameters of request, response, and next. The basic signature looks like this:\n\nIn order to call an error-handling middleware, you simply pass the error to , like this:\n\nIn this case, the error handling middleware at the end of the pipeline will handle the error. You might also notice that I checked the property. This just checks to see if the response has already sent the headers to the client. If it hasn’t it sends a 500 HTTP status and the error message to the client. You can also chain error-handling middleware. This is common to handle different types of errors in different ways. For instance:\n\nIn this case, the middleware checks to see if a 404 (not found) error was thrown. If so, it renders the ‘NotFound’ template page and then passes the error to the next item in the middleware. The next middleware checks to see if a 304 (unauthorized) error was thrown. If it was, it renders the ‘Unauthorized’ page, and passes the error to the next middleware in the pipeline. Finally the “catch all” error handler just logs the error and if no response has been sent, it sends the error’s (or an HTTP 500 status if none is provided) and renders the ‘UnknownError’ template.\n\nFor detailed instructions on setting up the Okta OIDC middleware, you can follow the ExpressJS Quickstart.\n\nThere is also a list of officially supported Express middleware in this GitHub repo you can try out and dig into to learn more\n\nFinally, if you’re interested in learning more about how to use Okta, there’s an Okta Node SDK for implementing more user management functionality in your application.\n\nAs always, I’d love to hear your thoughts and questions in the comments or on Twitter @oktadev!"
    },
    {
        "link": "https://stackoverflow.com/questions/46127058/how-to-use-errorhandler-middleware-in-express-4-x",
        "document": "Error handling is declared after all your other routes. Express moves through routes from top to bottom or left to right (if you imagine all your code on one line).\n\nYou can capitalize on this by putting a splat route after all your other routes, and it will be activated if no other exact route matches. This is how you can do an error 404 page.\n\nIt's why you build your routes like this (which will prepare you for React Router 'switch component', if you move into React coding):\n\nHere is an example of a splat route and following that, your error handler middleware:\n\nYou do not need the async functions as I have shown here, but I do it as a matter of convention so I can always slap in there. I use explicit returns to prevent any issues with sending headers after they are already sent, and because async functions return promises, so explicit return will resolve them.\n\nAll my routes generally look like this:\n\nThis should hopefully be informative for you and offer some code to forensically analyze. The Express error handler middleware takes a 4th parameter in the first position called which contains the value passed into .\n\nCheck out the Express documentation again after studying this, and it will make much more sense :)\n\nTry commenting this out now and run it again. You should see \"this is home page!\".\n\nWhen you call with no parameter in it, Express treats it as no error. If you pass any value in, like or , you will see defined with that value in your error handling middleware."
    },
    {
        "link": "https://stackoverflow.com/questions/18899828/best-practices-for-using-sqlite3-node-js",
        "document": "I've got a modest Node.js script that pulls down data from Wikipedia via the API and stores it in a SQLite database. I'm using this node-sqlite3 module.\n\nIn some cases, I'm pulling down data on upward of 600,000 articles and storing some metadata about each one in a row in the db. The articles are retrieved in groups of 500 from the API.\n\nThe request that retrieves the JSON object with the data on the 500 articles passes the object to this callback:\n\nThe modules operates by default in parallel, but the documentation for node-sqlite3 includes one example of serial operations like so:\n\nI tried to imitate this and saw almost no performance difference. Am I doing it wrong? Right now, the data retrieves from the API much faster than it writes to the DB, though it's not intolerably slow. But pummeling the DB with 600K individual commands feels clumsy.\n\nUPDATE: Per accepted answer, this appears to work for node-sqlite3, in lieu of a native solution. (See this Issue)."
    },
    {
        "link": "https://dextrop.medium.com/how-to-build-a-fast-and-lightweight-api-with-node-js-and-sqlite-676cbbec1b6a",
        "document": "When building web applications, it’s often necessary to store data in a database. In this article, we’ll show you how to create a Node.js API that uses an SQLite database to store product information.\n\nSQLite is a lightweight, serverless database engine that can be used for small to medium-sized web applications. It’s easy to set up and requires no special installation or configuration. Node.js is a popular server-side runtime for JavaScript commonly used for building web applications and APIs.\n\nBefore we get started, you’ll need to have the following installed on your machine:\n• Node.js: You can download it from the official website.\n• SQLite: You can download it from the official website.\n\nYou’ll also need a text editor or integrated development environment (IDE) to write and edit the code. Some popular options include Visual Studio Code, Sublime Text, and Atom.\n\nTo create the project, follow these steps:\n• Create a new directory for your project:\n\nThis will create a new file in your directory.\n• : A popular web framework for Node.js that provides easy-to-use middleware for handling HTTP requests and responses.\n• : A Node.js driver for SQLite that provides an easy-to-use interface for interacting with SQLite databases.\n\nNow that we have our project set up, let’s create the SQLite database that we’ll use to store product information.\n• Create a new file called in your project directory.\n• Open the file in your text editor and add the following SQL statements:\n\nThis will create a new table called with three columns: , , and .\n• Open a terminal window and navigate to your project directory.\n• Run the following command to create the database file:\n\nThis will create a new SQLite database file called in your project directory and initialize it with the table.\n\nNow that we have our project and database set up, let’s create the API.\n• Create a new file called in your project directory.\n• Open the file in your text editor and add the following code:\n\nconst express = require('express');\n\nconst sqlite3 = require('sqlite3').verbose();\n\n\n\nconst app = express();\n\nconst port = process.env.PORT || 3000;\n\n\n\nconst db = new sqlite3.Database('./products.db', (err) => {\n\n if (err) {\n\n console.error(err.message);\n\n }\n\n console.log('Connected to the products database.');\n\n});\n\n\n\napp.use(express.json());\n\n\n\n// GET all products\n\napp.get('/products', (req, res) => {\n\n db.all('SELECT * FROM products', (err, rows) => {\n\n if (err) {\n\n console.error(err.message);\n\n res.status(500).send('Internal server error');\n\n } else {\n\n res.send(rows);\n\n }\n\n });\n\n});\n\n\n\n// GET single product by ID\n\napp.get('/products/:id', (req, res) => {\n\n const { id } = req.params;\n\n db.get('SELECT * FROM products WHERE id = ?', [id], (err, row) => {\n\n if (err) {\n\n console.error(err.message);\n\n res.status(500).send('Internal server error');\n\n } else if (!row) {\n\n res.status(404).send('Product not found');\n\n } else {\n\n res.send(row);\n\n }\n\n });\n\n});\n\n\n\n// POST new product\n\napp.post('/products', (req, res) => {\n\n const { name, price } = req.body;\n\n if (!name || !price) {\n\n res.status(400).send('Name and price are required');\n\n } else {\n\n const sql = 'INSERT INTO products(name, price) VALUES (?, ?)';\n\n db.run(sql, [name, price], function(err) {\n\n if (err) {\n\n console.error(err.message);\n\n res.status(500).send('Internal server error');\n\n } else {\n\n const id = this.lastID;\n\n res.status(201).send({ id, name, price });\n\n }\n\n });\n\n }\n\n});\n\n\n\n// PUT update product by ID\n\napp.put('/products/:id', (req, res) => {\n\n const { id } = req.params;\n\n const { name, price } = req.body;\n\n if (!name || !price) {\n\n res.status(400).send('Name and price are required');\n\n } else {\n\n const sql = 'UPDATE products SET name = ?, price = ? WHERE id = ?';\n\n db.run(sql, [name, price, id], function(err) {\n\n if (err) {\n\n console.error(err.message);\n\n res.status(500).send('Internal server error');\n\n } else if (this.changes === 0) {\n\n res.status(404).send('Product not found');\n\n } else {\n\n res.status(200).send({ id, name, price });\n\n }\n\n });\n\n }\n\n});\n\n\n\n// DELETE product by ID\n\napp.delete('/products/:id', (req, res) => {\n\n const { id } = req.params;\n\n db.run('DELETE FROM products WHERE id = ?', [id], function(err) {\n\n if (err) {\n\n console.error(err.message);\n\n res.status(500).send('Internal server error');\n\n } else if (this.changes === 0) {\n\n res.status(404).send('Product not found');\n\n } else {\n\n res.status(204).send();\n\n }\n\n });\n\n});\n\n\n\n// Start the server\n\napp.listen(port, () => {\n\n console.log(`Server listening on port ${port}.`);\n\n});\n\nAfter creating the API, you can test it using a tool like or Postman. Here's how to use to test the endpoints:\n• Start the server by running the following command in your terminal:\n\nThis will start the server and listen for incoming requests on port 3000.\n• Open a new terminal window and use the command to test the endpoint:\n\nThis should return an empty array , since we haven't added any products to the database yet.\n• Use the command to test the endpoint:\n\nThis will create a new product in the database with the name “Product A” and price 10.99. The response should look something like this:\n• Use the command to test the endpoint again:\n\nThis should return an array with a single object representing the product we just created:\n\nThat’s it! You’ve successfully created a Node.js API that uses an SQLite database to store product information. From here, you can expand the API to include additional endpoints and functionality as needed.\n\nTo read more about Nodejs continue with\n\nSaurabh Pandey is a passionate Software Engineer from India. With years of experience in the industry, Saurabh has honed his skills in various programming languages and technologies, allowing him to effectively lead and contribute to complex projects.\n\nTo connect with Saurabh and learn more about his work, you can visit his LinkedIn profile at https://www.linkedin.com/in/dextrop/."
    },
    {
        "link": "https://github.com/dev-ajithkumar/express-auth-api",
        "document": "This project implements a User Authentication API using Node.js, Express.js, and SQLite. The API provides endpoints for user registration, login, and password change. User information is stored in a SQLite database, and passwords are hashed using bcrypt for security.\n• Open the file using an SQLite database management tool.\n• Run the following SQL query to create the table:\n• Use an API testing tool (e.g., Postman) to send requests to the following endpoints:\n• Description: Fetches all users from the database.\n• Request Body: JSON object with the following properties:\n• Response:\n• Error (Password too short): \"Password is too short\".\n• Request Body: JSON object with the following properties:\n• Description: Changes the password for a user.\n• Request Body: JSON object with the following properties:\n• Response:\n• Error (New password too short): \"Password is too short\"."
    },
    {
        "link": "https://stackoverflow.com/questions/36410486/login-authentication-in-node-js-using-sqlite3-bookshelf",
        "document": "I'm trying to create a very simple login authentication in node.js, using bookshelf and sqlite3.\n\nYes i know there are many many examples on the internet, but none really uses either sqlite or bookshelf, they are all mostly based on passport and mongoose.\n\nWhen i try to check the login, i get the error data.\n\nThis is my code\n\nThank you very much!\n\nI tried displaying values as suggested and i realized both\n\nare undefined, which means there must be something wrong with query or something?\n\nIf i try this code...\n\nI get displayed user who tried to login...all of his data...hovewever...if i do this:\n\nit says value is undefined"
    },
    {
        "link": "https://medium.com/@victor.teo/implement-user-authentication-with-node-js-and-teo-in-5-lines-of-code-acedbd2a22d4",
        "document": "Teo is a schema-centered web framework for Node.js, Python and Rust. It’s very concise and declarative. In this article, we’re going to use the Node.js version.\n\nAuthentication is vital to modern server apps. Teo simplifies the implementation of authentication. Authentication includes handling user signing in sessions, generate and validate user’s API tokens.\n\nTo setup a project, install the dependencies and do programming language specific setups. In the first article in the series, we explained what each step does in this process. In this tutorial, we just include the command for pasting.\n\nLet’s create a simple password authentication. Paste this into a new file named .\n\nCreate a dot env file in the same directory.\n\nLet’s explain the newly introduced decorators and pipeline items one by one.\n• specifies which field is used to fetch the user\n• specifies which field is used to validate credentials and how to validate\n• verifies the input value against the stored one\n• hides the field value from the output\n• specifies which type of token it generates\n• middleware decodes the JWT token and set the identity to the request\n• is the template which defines the handler\n• is the template which fetches the user information from the token in the header\n\nSend this JSON input to to create a user.\n\nWe’ve create a token from this user. If you intentionally type the password wrongly, an error response is returned.\n\nPractically only something like username and pasword are not enough. A lot of websites and apps integrates some third party image authentications to prevent non-human access. As a framework, Teo doesn’t integrate with any service providers. Instead, it’s easy to integrate any third-party service or identity with Teo.\n\nReplace the content of with this.\n\nWe created a field which is . A virtual field isn't stored into the database. Companion values are present when checking and validating against the checker value. In this simple example, we just ensure the image auth token value exists.\n\nRestart the server and send this JSON input to .\n\nWithout the image auth token, this request would fail.\n\nThe token expiration interval can be dynamic instead of static. Let’s try an example of frontend passed expiration interval. Replace the content of with this.\n\nStarts the server again and send this to .\n\nSince this token is valid for 2 seconds, just paste the token to the header and send this empty JSON input to .\n\nPractically accounts can be blocked from signing in. Implement account blocking is quite easy. Just tell us what does it mean by invalid account.\n\nReplace the content of with this.\n\nLet’s disable the previously created account. Send this JSON input to .\n\nNow the handler doesn't work for him and token authencation always failed.\n\nTeo provides an easy way for developers to integrate with third party identity services such as signing in with Google, Facebook. For China developers, this may be something like signing in with WeChat.\n\nUpdate the the content of with this.\n\nRestart the server and let’s create a new account with third party account binded by sending this input to .\n\nNow try signing in with the third party id and token. Send this input to .\n\nFor the sake of simplicity, let’s just use to make every third party token valid. In the next section, we'll demonstrate how to create a custom pipeline item to validate user's credential input.\n\nLet’s add some complexity by introducing phone number and auth code. Replace the content of with this.\n\nNow let’s create main program file. Create a file named in the project directory.\n\nNotice that we changed the type of email field from to . For databases other than SQLite is all ok. However, SQLite disallows altering table columns. Using SQLite is for our demo purpose as it doesn't require installation. Just delete the file and let's have a new database setup.\n\nStart the server with the updated command.\n\nLet’s recreate the previously created user. Send this to .\n\nLet’s send the auth code to this user. Send this JSON input to .\n\nIn practice, mark the field with to hide it from the output, and set a expire time.\n\nNow try to sign in with this auth code. Send this to . Remember to replace the auth code with the one that you got.\n\nNow we can sign in with email and password, email and auth code, phone number with password, phone number with auth code. Together with the third party account bindings."
    },
    {
        "link": "https://blog.logrocket.com/password-hashing-node-js-bcrypt",
        "document": "Editor’s note: This guide to password hashing in Node.js with bcrypt was last updated by Shalitha Suranga on 1 October 2024 to include a practical bcrypt password hashing demo and best practices for security with bcrypt.\n\nPassword hashing is a way to transform a plaintext password into a string sequence using a hash function that performs one-way string obfuscation. Unlike encryption, hashing cannot be reversed. This makes it particularly useful in data breaches, where data is unintelligible and irreversible to hackers even if they know the hashing algorithm.\n\nHere’s an example of hashing a plaintext password:\n\nAmong the various password-hashing algorithms, bcrypt is one of the most widely used and is generally considered the most secure and reliable. In this article, we’ll demonstrate how to perform secure passwording hashing using bcrypt in Node.js.\n\nbcrypt is a password hashing algorithm designed by Niels Provos and David Mazières based on the Blowfish cipher. The name “bcrypt” is made of two parts: b and crypt, where “b” stands for Blowfish and “crypt” is the name of the hashing function used by the Unix password system.\n\nbcrypt was created as a result of the failure of Crypt to adapt to technology and hardware advancement. bcrypt is designed to be a slow algorithm, which makes it ideal for password hashing. Its design offers native protection from brute-force attacks.\n\nOn the surface, bcrypt takes a user-submitted plain password and converts it into a hash. The hash is what is stored in the database. This prevents attackers from accessing users’ plain passwords in the event of a data breach. Unlike some other password-hashing algorithms that just hash the plain password, bcrypt uses the concept of salt.\n\nThis salt value, a unique and randomly generated string, provides an additional level of security for a generated hash. Before the plain password is hashed, a salt is generated. Then, it is appended to the plain password, and everything is hashed (the plain password and salt). This helps protect against rainbow table attacks because attackers can’t guess known passwords using a pre-computed hash-password lookup table.\n\nbcrypt also uses a cost factor (or work factor) to determine how long it takes to generate a hash. This cost factor can be increased to make it slower as hardware power increases. The higher the cost factor, the more secure the hash and the slower the process. Therefore, you need to find the right balance between security and performance.\n\nThe generated hash will include the salt and other things, like the hash algorithm identifier prefix, the cost factor, and the hash. The hashing process is irreversible; the hash cannot be converted back to the original plain password. Therefore, to determine whether a user is providing the correct password, the password is hashed and compared against the hash stored in the database.\n\nExamples of password hashing with bcrypt in Node.js\n\nThe bcrypt package offers a simple API to generate and compare hashes so Node.js developers can easily install it via any Node.js package manager and use it without wasting more time reading the documentation.\n\nLet’s create a Node.js project and use bcrypt to hash passwords.\n\nThe bcrypt library uses a C++-based implementation of the bcrypt algorithm from prebuilt, platform-specific Node binary addons. This allows you to install the library without installing C++ compilers or any Node add-on compilation dependencies.\n\nCreate a new Node.js project using the npm/Yarn command and install bcrypt as follows:\n\nNow, you are ready to work with bcrypt:\n\nNote: The pure JavaScript bcryptjs package offers the same API structure as the bcrypt package. However, bcryptjs doesn’t use a C++-based algorithm implementation — it is written in JavaScript — so the hash comparison is slower than bcrypt.\n\nIn this section, we’ll create a simple CLI program to hash and verify passwords using a simple JSON file-based storage. In this tutorial, we don’t use a popular database system or RESTful web API implementation because we’re focusing on bcrypt password hashing, but you can use this bcrypt password hashing method in any web, mobile, or desktop app project with Node.js.\n\nOur CLI program implements two sub-commands to hash and verify passwords:\n• : Asks the username and password and stores a hashed password using an auto-generated salt value\n• : Asks the username and password and verifies the credentials based on the stored password hash\n\nCreate the basic functionality of the project without password hashing by adding the following source code to the file:\n\nNote that you should also install and packages because the above source file uses them to capture usernames as passwords from the terminal.\n\nRun the above source file using the sub-command. The program asks for the username and password and stores them in :\n\nRun the source file using the sub-command to verify the previously stored credentials. The program verifies the stored username as a password:\n\nThe functionality of this program is perfectly fine, but what if someone finds the contents of the file? Then your private password becomes a public one:\n\nSo, let’s hash the password using bcrypt. That way, unauthorized users can’t reveal the actual password by reading the file contents.\n\nbcrypt offers functions to generate a secure random salt and the hash, so we can update the function as follows:\n\nHere, we used the async function to generate a salt value. By default, this function uses 10 salting rounds, but you can change it by passing a preferred numerical value parameter to the function.\n\nThe function generates a hash value using the plain password and the generated salt value. Inspect the contents to view the hashed password. Unauthorized users can’t access the plain password because bcrypt is an irreversible algorithm:\n\nOne last thing — do you think I will get the same hash if I re-run the command by entering the same password I entered before?\n\nObviously, not! The function will generate a unique hash based on a special salt every time. That’s how it prevents rainbow table attacks.\n\nYou can also use the following technique to generate both the salt and the final hash with only one function call:\n\nUsing the function to hash passwords in Node.js\n\nNow, how will we validate that hash? This will be necessary to perform user logins. To handle this, bcrypt provides the function, which compares the plaintext password with the stored hash. The current version of the function won’t work anymore because we are now storing hashed passwords.\n\nCompare the plain password and the stored hashed password using the function as follows:\n\nNow the sub-command will work as usual even if we store the hashed password in :\n\nUsing the same code modifications, you can also hash passwords in your web projects. Check out this comprehensive article to learn how to use the Node.js bcrypt password hashing library with a Node MVC web app.\n\nAs you see at the end, you’ll get a 60 characters long bcrypt hash that uses the following format:\n\nHere’s an example of the above hash format:\n\nThis is how the bifurcation of a hash works:\n• : Two characters for hash algorithm identifier ( or means bcrypt)\n• : Cost factor that represents the exponent used to determine how many salting iterations ( )\n\nThe bcrypt hashing process performs a series of salting rounds before creating the final hash, resulting in a secure hash that is unpredictable to any system or user.\n\nHashing options data costs generally refer to the time one hash round takes, which depends on the system’s hardware. On a 2GHz core processor, you can roughly expect the following result:\n\nBenefits of password hashing in Node.js with bcrypt\n\nbcrypt has significant advantages over general-purpose hashing methods like MD5, SHA1, SHA2, and SHA3. While these methods can hash large amounts of data quickly, they are vulnerable when it comes to password security.\n\nbcrypt was built on the Blowfish encryption algorithm and uses a “work factor,” which decides how expensive the hash function will be. The work factor ensures that bcrypt hashing becomes slower as more requests are made, making it more difficult for attackers to make multiple requests in a single time frame.\n\nMoreover, bycrypt incorporates “salting,” which protects against attacks like rainbow table attacks by adding a unique value to each password before hashing. This makes it incredibly challenging to crack a well-crafted password, even those containing only eight characters.\n\nBest practices for security with bcrypt\n\nStoring passwords with bcrypt hashes improves password security but doesn’t remove every vulnerability within a software system. It is important to implement best practices to maximize security, such as:\n• Motivating users to use longer passwords than shorter complex ones — cracking passwords becomes harder with the increased plain password length. Developers can tweak password strength checkers focusing on the password length to implement this enhancement\n• Using a proper hashing cost factor based on your server/computer and the security. You don’t need to reduce security by speeding up the hashing process or hinder user productivity by deliberately slowing down the hashing process — choose the bcrypt cost factor optimally\n• Never logging or making bcrypt password hashes public from the software system, even if the hashing algorithm is considered a secure one. Hashing offers second-level security protection for user data after a data breach, but making hashes public is just like deliberately doing a data breach and removing the first security layer\n\nApart from these bcrypt hashing practices, always strive to eliminate vulnerabilities and strengthen security by implementing two-factor authentication (2FA), data encryption (i.e., using HTTPS), secure coding, and conducting security-focused audits.\n\nIt is crucial to secure data to avoid significant damage. An attacker may find a way to access your data storage, but well-hashed passwords are a waste of time and effort for an attacker. They won’t get any benefits from our encrypted data because they would have to run a computer for thousands or millions of years to find a plaintext password that generates a matching hash.\n\nNode.js makes it easy to use bcrypt, which is essential for securely hashing passwords and protecting sensitive data. By using bcrypt, you can build a robust system and avoid the risk of exposing users’ sensitive information."
    },
    {
        "link": "https://freecodecamp.org/news/how-to-hash-passwords-with-bcrypt-in-nodejs",
        "document": "Security is critical in the field of web development, particularly when dealing with user credentials such as passwords. One security procedure that's critical in web development is password hashing.\n\nPassword hashing guarantees that plaintext passwords are difficult for attackers to find, even in a situation where a database is compromised. But not all hashing methods are created equal, and this is where bcrypt stands out.\n\nNode.js, a popular framework for developing web applications, provides a robust ecosystem for constructing secure authentication systems. In this article, we'll look at using bcrypt in Node.js to hash passwords. We'll look at how bcrypt may be smoothly incorporated into Node.js applications to improve security and safeguard user credentials effectively.\n\nWhether you're an experienced Node.js developer looking to strengthen your authentication practices or a beginner looking to learn the best techniques for secure password management, this article will be helpful to you. Let's have a look at how you can use bcrypt to hash passwords in Node.js.\n• How to Install Bcrypt in Nodejs\n• How to Set Up Bcrypt in Node.js\n• How to Hash Passwords With Bcrypt\n• How to Verify Passwords With Bcrypt\n\nHashing involves converting a given key or string of characters into another value. This is typically represented by a shorter, fixed-length value or key that represents the original value and facilitates the retrieval.\n\nPassword Hashing is a process of converting an input password into a fixed-length string of characters, typically for the purpose of securely storing and transmitting the password.\n\nPassword hash functions are designed to be one-way functions. This means it should not be computationally possible to reverse the process and get the original input password from the hashed value.\n\nFor example, suppose we want to hash a password like \"password123\". The password will be transformed into a fixed-length character string using a hash algorithm like bcrypt. And we'll get a hashed result once the hash function has processed our password.\n\nThe hashed output of \"password123\" using bcrypt, for instance, would look like this:\n\nNow that you understand the basics of how password hashing works, it's time to dive deeper into the practical application of hashing a password using the bcrypt algorithm.\n\nBut before we proceed with that, let's learn a bit more about bcrypt so you understand its workings and installation process, as well as how to integrate it into a Node.js project.\n\nFirstly, let's gain insight into bcrypt – what it is, how it operates, and its significance in password security. Then we'll discuss how to install bcrypt and integrate it seamlessly within a Node.js environment. This will include a detailed walkthrough on setting up bcrypt within your project and leveraging its functionalities effectively.\n\nBy the end of this article, you'll have a comprehensive understanding of bcrypt, equipped with the knowledge to securely hash passwords in your Node.js applications. So, let's embark on this journey to enhance the security of our projects through bcrypt integration.\n\nbcrypt is a type of cryptographic algorithm used to securely store passwords. It scrambles a user's password into a unique code. This way, even if a thief takes the database, they won't be able to recover the original passwords readily.\n\nbcrypt works by combining hashing and a technique known as salting, which is specifically developed to make stored passwords more safe.\n• Hashing: Bcrypt processes a user's password using a sophisticated mathematical function. This function converts the password to a fixed-length string of characters that appear random and meaningless. The hashed value is what is kept in the database, not the original password. Because the hashing function is one-way, reversing the hash will not produce the original password.\n• Salting: To improve security, bcrypt incorporates a random number called a salt. This salt is unique to each password and is attached to it before hashing. The combined value (password + salt) is then passed to the hashing function.\n\nHow to Install Bcrypt in Nodejs\n\nBefore you install bcrypt, you'll need to have a Node.js project already set up. If you haven't created one yet, follow these steps to create a new Node.js project:\n\nThis command creates a new directory (folder) where your Node.js project will reside. It's named .\n• : This command stands for \"make directory.\" It's used to create a new directory.\n• : This is the name of the directory you're creating. You can choose any name you prefer for your project directory.\n\nThis command navigates you into the newly created directory so that you can start working on your project within it.\n• : This command stands for \"change directory.\" It's used to move from one directory to another.\n• : This is the name of the directory you want to navigate into.\n\nThis command initializes a new Node.js project within the directory you created. It creates a file, which is used to manage dependencies and configuration for your Node.js project.\n• : This command initializes a new Node.js project using npm (Node Package Manager).\n• : This flag automatically accepts all default values for the file, so you don't have to manually provide input for each field.\n\nAfter running these commands, you should have a new directory (bcrypt-password-hash) with a package.json file, indicating that you successfully created a new Node.js project. You can now go ahead and install dependencies and write code.\n\nCreate a file named where you will write your code:\n\nTo create a file named where you will write your code, you can use the command in your terminal. Here's how to do it:\n• : This command is used to create a new file. (Note that you must have already installed on your machine to use it. If\n\nyou haven't, you may run this command in your terminal to install\n\ntouch: .)\n• : This is the name of the file you want to create. In this case, you're creating a JavaScript file named .\n\nAfter running this command, you'll have a new file named in your project directory where you can write your Node.js code just like you can see in the image below:\n\nNow that we've correctly constructed a Node.js project, we can install bcrypt in our project.\n\nTo install bcrypt, you'll use npm, the Node.js package manager. Here's the command to install bcrypt:\n• : This command is used to install packages from the npm registry.\n• : This is the name of the package you want to install. bcrypt is a popular package for hashing passwords securely in Node.js.\n\nWhen you run this command, npm will download and install the bcrypt package and its dependencies in the directory of your project. This directory will include all of the dependencies required for your project, including bcrypt.\n\nHow to Set Up Bcrypt in Node.js\n\nOnce Bcrypt is installed in your Node.js project, you can seamlessly integrate its functionality into your application. Here's how to proceed:\n\nFirstly, after installing the bcrypt package using npm, make sure you import it into your Node.js application file to utilize its features effectively.\n\nHere's how to do it:\n\nThis line of code ensures that the bcrypt package is accessible within your application, allowing you to leverage its powerful capabilities for secure password hashing and verification.\n\nWith bcrypt integrated into your project, you can enhance the security of user authentication and data protection.\n\nbcrypt provides two primary functions for password hashing and comparison:\n• : This function is used to generate a hash of a plaintext password. It takes the plaintext password and a salt factor (optional) as input parameters and returns the hashed password asynchronously.\n• : This function is used to compare a plaintext password with its hashed counterpart. It takes the plaintext password and the hashed password as input parameters and returns a boolean value indicating whether the passwords match.\n\nHow to Hash Passwords With Bcrypt\n\nHaving delved into the significance of password hashing, as well as the concepts of hash and salt, let's put theory into practice within our file.\n\nHow to Generate a Salt and Hash the Password\n\nAs we've learned, a key aspect of secure password hashing involves incorporating a unique salt into the hashing process. bcrypt simplifies this by handling salt generation and password hashing seamlessly.\n\nTo begin, we require the bcrypt module in our Node.js application:\n\nTo ensure the strength of our password hashes, we determine the number of salt rounds. This value dictates the computational cost of hashing and, consequently, the level of security:\n\nWith our configuration established, we can generate a salt asynchronously using the function. This salt will be unique for each password hash, enhancing security:\n\nOnce the salt is generated, we combine it with the user's password to compute the hash using the function. This results in a securely hashed password ready for storage:\n\nBy leveraging bcrypt for password hashing in our Node.js application, we ensure the robust security of user credentials. The incorporation of unique salts for each password hash, coupled with the computational complexity of bcrypt, fortifies our defense against unauthorized access and malicious attacks.\n\nIn the next section, we'll explore how to verify passwords and discuss best practices for securely managing hashed passwords.\n\nHow to Verify Passwords With Bcrypt\n\nNow that we've covered the process of hashing passwords using bcrypt within our Node.js application, let's shift our focus to verifying passwords during user authentication.\n\nIn this section, we'll explore how bcrypt facilitates password verification, ensuring a secure and seamless authentication process.\n\nHow to Retrieve a Hashed Password from the Database\n\nBefore we can verify a user's password, we need to retrieve the hashed password associated with the user's account from the database.\n\nAssuming you have a user authentication system in place, you'll typically query the database to fetch the hashed password based on the user's username or email.\n\nOnce you have retrieved the hashed password from the database, you're ready to proceed with the password verification process.\n\nTo verify a password using bcrypt, use the function. This function compares a plaintext password provided by the user during login with the hashed password stored in the database.\n\nHere's how you can implement password verification using bcrypt in your Node.js application:\n\nIn this code snippet, represents the hashed password retrieved from the database, while is the plaintext password provided by the user during login. The function compares these two passwords and returns a boolean value indicating whether they match.\n\nIn the next section, we'll discuss best practices for securely managing hashed passwords, including considerations for password storage and handling.\n\nNow that we've discussed the principles of password hashing and verification with bcrypt, let's look at some important security best practices to ensure the integrity of our authentication system.\n\nEncourage users to create strong and complex passwords that are resistant to dictionary attacks. Provide guidance on password length, the inclusion of alphanumeric characters, symbols, and the avoidance of common patterns.\n\nAlways use a unique salt for each password hash. This prevents attackers from using precomputed rainbow tables to crack passwords. bcrypt automatically handles salt generation, ensuring that each hash is unique.\n\nbcrypt employs adaptive hashing, allowing developers to adjust the computational cost of hashing over time. Periodically increase the number of hashing rounds to keep pace with advancements in hardware and computational power.\n\nStore hashed passwords securely in your database. Ensure that access controls are in place to prevent unauthorized access to user credentials. Avoid storing plaintext passwords or using reversible encryption algorithms.\n\nImplement proper error handling mechanisms when working with bcrypt functions. Handle errors gracefully and avoid leaking sensitive information that could aid attackers in exploiting vulnerabilities.\n\nIn conclusion, we have explored the essential aspects of password security and the role of bcrypt in safeguarding user credentials within Node.js applications. From understanding the fundamentals of password hashing and salting to implementing secure authentication mechanisms, we have covered a wide array of topics aimed at enhancing the security posture of our applications.\n\nBy leveraging bcrypt for password hashing and verification, we ensure that sensitive user data remains protected against unauthorized access and malicious attacks. bcrypt's robust algorithm, combined with adaptive hashing and salt generation, provides a reliable defense mechanism against common password-based vulnerabilities.\n\nWe also discussed security best practices, including strong password policies, secure storage practices, and error handling. By adhering to these best practices and staying vigilant against evolving threats, we can create a secure authentication system that instills confidence in our users and upholds the integrity of our applications.\n\nLet's continue to prioritize security and strive for excellence in our pursuit of building robust and trustworthy applications.\n\nThank you for joining me on this exploration of password security with bcrypt. Together, we can create a safer digital environment for all users."
    },
    {
        "link": "https://npmjs.com/package/bcrypt",
        "document": "A library to help you hash passwords.\n\nYou can read about bcrypt in Wikipedia as well as in the following article: How To Safely Store A Password\n\nIf You Are Submitting Bugs or Issues\n\nPlease verify that the NodeJS version you are using is a stable version; Unstable versions are currently not supported and issues created while using an unstable version will be closed.\n\nIf you are on a stable version of NodeJS, please provide a sufficient code snippet or log files for installation issues. The code snippet does not require you to include confidential information. However, it must provide enough information so the problem can be replicable, or it may be closed without an explanation.\n\nPlease upgrade to atleast v5.0.0 to avoid security issues mentioned below.\n\nonly works with stable/released versions of node. Since the module uses to build and install, you'll need a stable version of node to use bcrypt. If you do not, you'll likely see an error that starts with:\n\nAs should be the case with any security tool, anyone using this library should scrutinise it. If you find or suspect an issue with the code, please bring it to the maintainers' attention. We will spend some time ensuring that this library is as secure as possible.\n\nHere is a list of BCrypt-related security issues/concerns that have come up over the years.\n• An issue with passwords was found with a version of the Blowfish algorithm developed for John the Ripper. This is not present in the OpenBSD version and is thus not a problem for this module. HT zooko.\n• Versions suffer from bcrypt wrap-around bug and will truncate passwords >= 255 characters leading to severely weakened passwords. Please upgrade at earliest. See this wiki page for more details.\n• Versions do not handle NUL characters inside passwords properly leading to all subsequent characters being dropped and thus resulting in severely weakened passwords. Please upgrade at earliest. See this wiki page for more details.\n\nThis library supports and prefix bcrypt hashes. and hashes are specific to bcrypt implementation developed for John the Ripper. In theory, they should be compatible with prefix.\n\nCompatibility with hashes generated by other languages is not 100% guaranteed due to difference in character encodings. However, it should not be an issue for most cases.\n\nHashes generated in earlier version of remain 100% supported in and later versions. In most cases, the migration should be a bump in the .\n\nHashes generated in using the defaults parameters will not work in earlier versions.\n• Please check the dependencies for this tool at: https://github.com/nodejs/node-gyp\n• Windows users will need the options for c# and c++ installed with their visual studio instance.\n• - This is only required to build the project if you are using versions <= 0.7.7. Otherwise, we're using the builtin node crypto bindings for seed data (which use the same OpenSSL code paths we were, but don't have the external dependency).\n\nNote: OS X users using Xcode 4.3.1 or above may need to run the following command in their terminal prior to installing if errors occur regarding xcodebuild:\n\nPre-built binaries for various NodeJS versions are made available on a best-effort basis.\n\nOnly the current stable and supported LTS releases are actively tested against.\n\nThere may be an interval between the release of the module and the availabilty of the compiled modules.\n\nCurrently, we have pre-built binaries that support the following platforms:\n\nIf you face an error like this:\n\nmake sure you have the appropriate dependencies installed and configured for your platform. You can find installation instructions for the dependencies for some common platforms in this page.\n\nNote that both techniques achieve the same end-result.\n\nbcrypt uses whatever implementation is available in . NodeJS >= 0.12 has a native implementation built in. However, this should work in any Promises/A+ compliant implementation.\n\nAsync methods that accept a callback, return a when callback is not specified if Promise support is available.\n\nThis is also compatible with\n\nAs with async, both techniques achieve the same end-result.\n\nWhy is async mode recommended over sync mode?\n\nWe recommend using async API if you use on a server. Bcrypt hashing is CPU intensive which will cause the sync APIs to block the event loop and prevent your application from servicing any inbound requests or events. The async version uses a thread pool which does not block the main event loop.\n• \n• - [OPTIONAL] - the cost of processing the data. (default - 10)\n• - [OPTIONAL] - minor version of bcrypt to use. (default - b)\n• \n• - [OPTIONAL] - the cost of processing the data. (default - 10)\n• - [OPTIONAL] - minor version of bcrypt to use. (default - b)\n• - [OPTIONAL] - a callback to be fired once the salt has been generated. uses eio making it asynchronous. If is not specified, a is returned if Promise support is available.\n• - First parameter to the callback detailing any errors.\n• - Second parameter to the callback providing the generated salt.\n• \n• - [REQUIRED] - the data to be encrypted.\n• - [REQUIRED] - the salt to be used to hash the password. if specified as a number then a salt will be generated with the specified number of rounds and used (see example under Usage).\n• \n• - [REQUIRED] - the data to be encrypted.\n• - [REQUIRED] - the salt to be used to hash the password. if specified as a number then a salt will be generated with the specified number of rounds and used (see example under Usage).\n• - [OPTIONAL] - a callback to be fired once the data has been encrypted. uses eio making it asynchronous. If is not specified, a is returned if Promise support is available.\n• - First parameter to the callback detailing any errors.\n• - Second parameter to the callback providing the encrypted form.\n• \n• - [REQUIRED] - data to be compared to.\n• \n• - [REQUIRED] - data to be compared to.\n• - [OPTIONAL] - a callback to be fired once the data has been compared. uses eio making it asynchronous. If is not specified, a is returned if Promise support is available.\n• - First parameter to the callback detailing any errors.\n• - Second parameter to the callback providing whether the data and encrypted forms match [true | false].\n• - return the number of rounds used to encrypt a given hash\n• - [REQUIRED] - hash from which the number of rounds used should be extracted.\n\nA note about the cost: when you are hashing your data, the module will go through a series of rounds to give you a secure hash. The value you submit is not just the number of rounds the module will go through to hash your data. The module will use the value you enter and go through hashing iterations.\n\nFrom @garthk, on a 2GHz core you can roughly expect:\n\nBecause it's come up multiple times in this project and other bcrypt projects, it needs to be said. The library is not susceptible to timing attacks. From codahale/bcrypt-ruby#42:\n\nA great thread on this, in much more detail can be found @ codahale/bcrypt-ruby#43\n\nIf you're unfamiliar with timing attacks and want to learn more you can find a great writeup @ A Lesson In Timing Attacks\n\nHowever, timing attacks are real. And the comparison function is not time safe. That means that it may exit the function early in the comparison process. Timing attacks happen because of the above. We don't need to be careful that an attacker will learn anything, and our comparison function provides a comparison of hashes. It is a utility to the overall purpose of the library. If you end up using it for something else, we cannot guarantee the security of the comparator. Keep that in mind as you use the library.\n\nThe characters that comprise the resultant hash are .\n\nResultant hashes will be 60 characters long and they will include the salt among other parameters, as follows:\n• Cost-factor (n). Represents the exponent used to determine how many iterations 2^n\n\nIf you create a pull request, tests better pass :)\n\nThe code for this comes from a few sources:\n• Antonio Salazar Cardozo - Early MacOS X support (when we used libbsd)\n• Roman Shtylman - Code refactoring, general rot reduction, compile options, better memory management with delete and new, and an upgrade to libuv over eio/ev.\n• Ben Noordhuis - Fixed a thread safety issue in nodejs that was perfectly mappable to this module.\n\nUnless stated elsewhere, file headers or otherwise, the license as stated in the LICENSE file."
    },
    {
        "link": "https://honeybadger.io/blog/node-password-hashing",
        "document": "In the digital age, security is of paramount importance, especially when it comes to user data and credentials. As developers, we must ensure that sensitive information, such as passwords, is stored securely to prevent unauthorized access and potential breaches. One of the key techniques employed to enhance security is password hashing, and in the realm of Node.js development, the bcrypt library stands out as a robust solution for this purpose.\n\nIn this comprehensive article, we will delve into the world of password hashing and explore how to implement it effectively using the bcrypt library in a Node.js application. We'll cover the fundamental concepts of password security, the drawbacks of storing plain passwords, and how bcrypt addresses these challenges. By the end of this article, you'll have a solid understanding of the importance of password hashing and be equipped with practical knowledge to integrate bcrypt into your Node.js projects for safeguarding user credentials.\n\nPasswords have been the go-to method for proving your identity when using websites and apps for a while. However, there's a big problem with them; if they're not protected well, like being kept in plain text or with weak encryption, an attacker who gets into the system can easily gain access to your account and private information. This is a danger for both the average user and businesses.\n\nTo mitigate this risk, password security protocols aim to change plain text passwords into an unintelligible format that cannot be easily reversed. This process, known as password hashing, involves applying cryptographic algorithms to the original password and generating a hash value that appears random and unrelated to the original input. Even if an attacker gains access to the hashed passwords, it should be quite difficult for them to convert it to the original password.\n\nStoring passwords in plain text within databases might seem like an easy way to keep track of them, but it's a massive security problem. When a database gets hacked, attackers can instantly see everyone's login details. This is especially bad news for people who use the same passwords for lots of different websites because all their accounts are now vulnerable. However, even if you consistently use unique passwords, there's still a risk because of something called \"rainbow table attacks\". This is when attackers use pre-made lists of hash values to quickly match them up with stolen hashes.\n\nTo deal with these problems, we use something called \"password hashing\". It's like supercharging the security of an app. One popular tool for this is called \"bcrypt\", which is proven to be highly effective at protecting passwords. It makes it difficult for attackers to guess passwords by trying lots of combinations and thwarts rainbow table attacks.\n\nBcrypt is a widely used library for securely hashing passwords. It relies on the Blowfish cipher and a technique called \"salting\" to hash passwords. Salting involves adding a random value (called the \"salt\") to the original password before hashing it. This ensures that even if two users happen to have the same password, their hashed values will be different because of the unique salt added to each one.\n\nBy using a cryptographically secure hash function, bcrypt significantly slows down the hashing process, making it computationally expensive. This is a good thing because it makes it much harder for attackers to use brute-force methods to guess passwords.\n\nIn the upcoming sections of this article, we'll take a deep dive into how bcrypt works. We'll look at how it can be used within Node.js applications and break down the steps needed to hash and check passwords securely. We'll provide practical examples to help you understand how to use bcrypt effectively to enhance the security of your application.\n\nTo fully appreciate the power of bcrypt, it's important to delve into the underlying mechanisms that make it an excellent choice for password hashing in Node.js applications. Let's break down the key components and processes involved in bcrypt's operation:\n\nThe first step in bcrypt's password hashing process is the generation of a unique salt for each password. A salt is a random value that is combined with the password before hashing. This ensures that even if two users have the same password, their resulting hash values will differ due to the unique salt applied.\n\nbcrypt employs a process called key stretching to slow down the hashing process. Key stretching involves repeatedly applying a cryptographic hash function multiple times. This deliberate slowdown is intentional, as it thwarts brute-force attacks by forcing attackers to spend significantly more time and computational resources trying various password combinations. The number of times the hash function is iterated is controlled by a parameter known as the \"work factor\" or \"cost factor\". A higher work factor increases the time and resources required to compute the hash, thereby enhancing the security of the hashed passwords.\n\nOnce the salt is generated and the work factor is determined, bcrypt combines these values with the user's password and passes them through the Blowfish cipher. The result is a cryptographic hash that represents the password and the associated salt. The resulting hash is a fixed-length value, which means that regardless of the length of the original password, the hash length remains constant. This is a valuable property for securely storing and comparing password hashes.\n\nWhen a user attempts to log in, the application retrieves the stored hash from the database and applies the same salt and work factor during the verification process. The user's provided password is hashed using these parameters, and the resulting hash is compared with the stored hash. If they match, the provided password is correct; otherwise, authentication fails. By incorporating salts, key stretching, and a cryptographically secure hashing algorithm, bcrypt ensures that password hashes are resistant to various types of attacks, providing a robust defense against unauthorized access.\n\nNow that we have a solid grasp of bcrypt's inner workings, let's explore how to integrate bcrypt into your Node.js applications for secure password hashing. The process can be broken down into a few simple steps.\n\nFirst, install the bcrypt library using npm or yarn. Open your terminal and run the following command:\n\nThis will install the bcrypt package and make it available for use in your Node.js project.\n\nTo hash a user's password during registration, follow these steps:\n\nAdjust the saltRounds value according to the desired level of security. Higher values will result in slower hash generation.\n\nVerifying passwords: When verifying a user's login attempt, use bcrypt to compare the stored hash with the provided password:\n\nBy following these steps, you can seamlessly integrate bcrypt into your Node.js application, ensuring that user passwords are securely hashed and verified.\n\nNow that we have a solid theoretical understanding of bcrypt, let's dive into a practical example of how to implement bcrypt for secure password hashing in a real-world Node.js application. For this example, we'll consider a simple user authentication system using Node.js, Express, and MongoDB. We'll walk through the process of registering users with hashed passwords, verifying passwords during login, and applying best practices for enhanced security.\n\nCreate a new directory for your project and navigate to it in your terminal. Run to initialize a new Node.js project and follow the prompts to set up your .\n\nInstall the necessary packages for your project:\n\nCreate a new file, , and set up your Express application:\n\nConnect to your MongoDB database using Mongoose:\n\nImplement the registration route to hash passwords and save users:\n\nBest practices for using bcrypt in Node.js\n\nWhile bcrypt is a powerful tool for securing passwords in Node.js applications, there are several best practices you should keep in mind to ensure it’s used effectively and responsibly. Let's delve into these practices to maximize the security of your application:\n• None Choose an appropriate salt rounds value: The parameter determines the computational cost of hashing a password. A higher value increases the time it takes to hash a password, thereby making brute-force attacks more difficult. However, this also means more processing time, so strike a balance between security and performance. The most common value is around 10, but you might need to adjust it based on your application's requirements.\n• The quality of the salt is crucial. Ensure you're using a secure random number generator to create the salt. Node.js provides the module, which offers strong cryptographic primitives, including random number generation.\n• Like any software library, bcrypt could have vulnerabilities that are discovered over time. Make sure to keep your dependencies up to date and monitor the bcrypt project for any security updates. Regularly updating the library in your project helps you stay protected against known vulnerabilities.\n• None Use HTTPS and Other security measures: While bcrypt is a robust method for password hashing, it's not the only aspect of securing user data. Utilize HTTPS to encrypt data in transit and follow other security best practices, such as input validation, to prevent other attack vectors.\n• Two-factor authentication (2FA) adds an extra layer of security by requiring users to provide a second piece of information, such as a code sent to their smartphone, in addition to their password. Implementing 2FA can significantly enhance the security of user accounts.\n• To protect against brute-force attacks, implement account lockout mechanisms that temporarily lock an account after a certain number of failed login attempts. This prevents attackers from making unlimited login attempts, rendering brute-force attacks ineffective.\n• Routinely audit your application's security practices and monitor your logs for any suspicious activity. This proactive approach helps identify and address potential security breaches before they escalate.\n• While bcrypt is widely used and trusted, it's important to use libraries that have active maintenance and a responsive development community. This ensures that any potential issues are addressed promptly.\n\nbcrypt is a crucial tool for enhancing password security in Node.js applications. We've explored its core processes, from generating salts to creating secure hashes, and explained how to practically implement it for user authentication. Remembering best practices, such as setting strong salt rounds and staying updated, ensures the effective protection of user data. By using bcrypt, we can confidently safeguard passwords, bolster application security, and maintain user confidence in today's digital environment."
    },
    {
        "link": "https://medium.com/@amirakhaled2027/node-js-bcrypt-js-a-password-hashing-library-c9f3270ca024",
        "document": "bcrypt.js is a popular Node.js library used for password hashing. It implements the bcrypt password hashing algorithm, which is considered a secure and industry-standard method for storing passwords in a database.\n• Strong Hashing Algorithm: bcrypt.js uses the bcrypt algorithm, known for its high computational cost and resistance to brute-force attacks.\n• Salt Generation: bcrypt.js automatically generates a unique salt for each password, making it even more difficult to crack hashed passwords.\n• Asynchronous Operations: bcrypt.js provides asynchronous methods for hashing and comparing passwords, allowing for non-blocking operations in Node.js applications.\n• Easy Integration: bcrypt.js is well-documented and easy to integrate into Node.js projects using the package manager.\n• Salt Generation: bcrypt.js generates a random salt, a unique string of characters, for each password.\n• Hashing: The password is combined with the salt and passed through the bcrypt algorithm, generating a hashed password.\n• Storage: The hashed password is stored in the database instead of the plain-text password.\n• Comparison: When a user attempts to log in, their entered password is hashed using the same salt and compared to the stored hashed password. If the hashes match, the login is successful.\n• Enhanced Security: bcrypt.js significantly improves password security by making it extremely difficult for attackers to recover plain-text passwords from the database.\n• Compliance: bcrypt.js is a widely accepted and recommended method for password hashing, ensuring compliance with industry best practices.\n• Ease of Use: bcrypt.js provides a simple and straightforward API for hashing and comparing passwords, making it easy to integrate into your Node.js applications."
    }
]